{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1512030592,"rating":64,"authorHandle":"Helgui","modificationTimeSeconds":1512039541,"id":56074,"title":"\u003cp\u003eБинпоиск по ответу с помощью STL\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eПривет, Codeforces! Сегодня мы попробуем решить пару задач на целочисленный бинпоиск по ответу с помощью \u003ccode\u003estd::lower_bound\u003c/code\u003e и поймем, что это бессмысленно, но красиво (на самом деле нет).\u003c/p\u003e\u003cp\u003eНачнем с задачи \u003ca href\u003d\"/contest/535/problem/C\" title\u003d\"Codeforces Round 299 (Div. 2)\"\u003e535C - Tavas and Karafs\u003c/a\u003e, которая решается двоичным поиском (например, \u003ca href\u003d\"/contest/535/submission/32799258\" title\u003d\"Submission 32799258 by Helgui\"\u003e32799258\u003c/a\u003e). В этой задаче по заданным \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e, \u003ci\u003eA\u003c/i\u003e, \u003ci\u003eB\u003c/i\u003e\u003c/span\u003e нужно найти такое наибольшее \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/aa/a4/aaa4a61314b08c9d7a22a743d7343ec0ffdc56f0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, что\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cc/26/cc26fc3c5ef451663cd30e6bfdc47481df7e56ed.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eКак известно, \u003ccode\u003estd::lower_bound(first, last, v, pred)\u003c/code\u003e возвращает итератор, указывающий на первое значение \u003ccode\u003ea\u003c/code\u003e такое, что \u003ccode\u003epred(a, v) \u003d\u003d false\u003c/code\u003e, или \u003ccode\u003elast\u003c/code\u003e, если такого значения нет. Если в качестве предиката использовать \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) - \u003ci\u003es\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e - 1) ≤ \u003ci\u003et\u003c/i\u003e·\u003ci\u003em\u003c/i\u003e\u003c/span\u003e, то ответом на задачу будет значение, предшествующее \u003ccode\u003elower_bound\u0027у\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eПриступим. Диапазоном для бинпоиска будет служить массив \u003ccode\u003erange\u003c/code\u003e такой, что \u003ccode\u003erange[i] \u003d i\u003c/code\u003e. Заполнить такой массив поможет \u003ccode\u003estd::iota\u003c/code\u003e из \u003ccode\u003e\u0026lt;numeric\u0026gt;\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003econst int N \u003d 1000000;\nint range[N + 5];\n//...\niota(range, range + N, 0);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003elower_bound\u003c/code\u003e заточен под бинарные предикаты, но у нас унарный. Значит, второй аргумент и искомое значение (третий параметр \u003ccode\u003elower_bound\u003c/code\u003e) будут фиктивными. Оформим предикат в виде лямбды и получим такую функцию\u003c/p\u003e \u003cpre\u003e\u003ccode\u003einline int solve(int l, int t, int m) {\n    int r \u003d (t - A) / B + 1;\n    i64 lim \u003d i64(t)*m;\n    if (r \u0026lt; l)            \n        return -1;\n    if (sum(l, l) \u0026gt; lim)\n        return -1;\n    return *lower_bound(range + l, range + r + 1, 0, [lim, l](int item, int) -\u0026gt; bool {\n    \treturn sum(l, item) \u0026lt;\u003d lim; //sum(l, item) - это s(item) - s(l - 1) из описания\n    }) - 1;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВозможно, обработка случаев с -1 не требуется, но я её оставил от предыдущего решения. Полный вариант — \u003ca href\u003d\"/contest/535/submission/32800781\" title\u003d\"Submission 32800781 by Helgui\"\u003e32800781\u003c/a\u003e. Время работы этого решения почти не отличается от самописного бинпоиска.\u003c/p\u003e\u003cp\u003eВ рассмотренной задаче мы явно использовали то, что диапазон бинпоиска небольшой, и его можно целиком хранить в массиве. Но что делать, если границы имеют порядок \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e или даже \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e\u003c/span\u003e? В этом случае придется реализовать итератор для целочисленного диапазона, использующий \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e памяти, который удовлетворяет интерфейсу \u003ccode\u003eRandomAccessIterator\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eНапример, так (много кода):\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eclass Range{...}\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eclass Range {\npublic:\n\ttypedef long long IntType;\n\t\n\tclass iterator : public std::iterator\u0026lt;random_access_iterator_tag, \n\t\tIntType, \n\t\tIntType, \n\t\tconst IntType*, \n\t\tIntType\u0026gt; {\n\tpublic:\n\t\ttypedef iterator It;\n\t\t\n\t\titerator(IntType pos)\n\t\t\t: pos(pos) {\n\t\t}\n\n\t\t//value access\n\t\tIntType operator[](IntType idx) {\n\t\t\treturn (pos + idx);\n\t\t}\n\n\t\tIntType operator*() {\n\t\t\treturn pos;\n\t\t}\n\n\t\t//arithmetics\n\t\tIt\u0026amp; operator +\u003d(IntType delta) {\n\t\t\tpos +\u003d delta;\n\t\t\treturn (*this);\n\t\t}\n\n\t\tIt\u0026amp; operator ++() {\n\t\t\treturn (*this) +\u003d 1;\n\t\t}\n\n\t\tIt operator ++(int) {\n\t\t\t++pos;\n\t\t\treturn It(pos - 1);\n\t\t}\n\n\t\tIt\u0026amp; operator -\u003d(IntType delta) {\n\t\t\tpos -\u003d delta;\n\t\t\treturn (*this);\n\t\t}\n\n\t\tIt\u0026amp; operator --() {\n\t\t\treturn (*this) -\u003d 1;\n\t\t}\n\n\t\tIt operator --(int) {\n\t\t\t--pos;\n\t\t\treturn It(pos + 1);\n\t\t}\n\n\t\tIntType operator -(const It\u0026amp; rhs) const {\n\t\t\treturn pos - rhs.pos;\n\t\t}\n\n\t\t//relational\n\t\tbool operator \u003d\u003d(const It\u0026amp; rhs) const {\n\t\t\treturn pos \u003d\u003d rhs.pos;\n\t\t}\n\n\t\tbool operator !\u003d (const It\u0026amp; rhs) const {\n\t\t\treturn pos !\u003d rhs.pos;\n\t\t}\n\n\t\tbool operator \u0026lt;(const It\u0026amp; rhs) const {\n\t\t\treturn pos \u0026lt; rhs.pos;\n\t\t}\n\n\t\tbool operator \u0026lt;\u003d(const It\u0026amp; rhs) const {\n\t\t\treturn pos \u0026lt;\u003d rhs.pos;\n\t\t}\n\n\t\tbool operator \u0026gt;(const It\u0026amp; rhs) const {\n\t\t\treturn pos \u0026gt; rhs.pos;\n\t\t}\n\n\t\tbool operator \u0026gt;\u003d(const It\u0026amp; rhs) const {\n\t\t\treturn pos \u0026gt;\u003d rhs.pos;\n\t\t}\n\n\tprivate:\n\t\tIntType pos;\n\t};\n\n\tRange(IntType a, IntType b)\n\t\t: a(a), b(b) {\n\t}\n\n\tRange()\n\t\t: Range(0, 1) {\n\t}\n\t\n\titerator begin() const {\n\t\treturn iterator(a);\n\t}\n\n\titerator end() const {\n\t\treturn iterator(b + 1);\n\t}\n\n\tIntType a, b;\n};\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eЭтот вариант опробуем на задаче \u003ca href\u003d\"/contest/760/problem/B\" title\u003d\"Codeforces Round 393 (Div. 2) (8VC Venture Cup 2017 - Final Round Div. 2 Edition)\"\u003e760B - Frodo and pillows\u003c/a\u003e (спасибо \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/-Morass-\" title\u003d\"Candidate Master -Morass-\"\u003e-Morass-\u003c/a\u003e за \u003ca href\u003d\"//codeforces.com/blog/entry/55274\"\u003eProblem Topics\u003c/a\u003e). В этой задаче по заданным \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e небходимо найти такое наибольшее \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d3/86/d386715eb14061a0fbca364531aa385ae4807e78.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, что\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e - 1) + \u003ci\u003es\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e) + \u003ci\u003ex\u003c/i\u003e ≤ \u003ci\u003em\u003c/i\u003e\u003c/span\u003e\u003c/center\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9f/83/9f837ae0b5ab4eb87d8d70840227eb79b2a33907.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eОформим все аналогично предыдущей задаче и получим такое решение c использованием \u003ccode\u003eRange\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e//...\ntypedef long long i64;\n\ninline i64 pillows(i64 x, i64 y) {\n\tif (y \u0026gt; x -; 1) {\n\t\treturn (x*(x - 1)) / 2 + y - (x - 1);\n\t}\n\treturn ((2*x - y - 1)*y) / 2;\n}\n\nint main() {\n\ti64 n, m, k;\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k;\n\tRange range(1, m);\n\tcout \u0026lt;\u0026lt; (*lower_bound(range.begin(), range.end(), 0, [n, m, k](long long x, int) -\u0026gt; bool {\n\t\treturn pillows(x, k - 1) + pillows(x, n - k) + x \u0026lt;\u003d m; \t\t\n\t}) - 1);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПолный вариант — \u003ca href\u003d\"/contest/760/submission/32802235\" title\u003d\"Submission 32802235 by Helgui\"\u003e32802235\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eОчевидно, что вариант с \u003ccode\u003eRange\u003c/code\u003e имеет смысл только тогда, когда есть возможность заинлайнить (с помощью JHelper и подобных инструментов) написанный ранее класс \u003ccode\u003eRange\u003c/code\u003e. Но в этом случае можно заинлайнить и написанный ранее шаблонизированный бинпоиск, получив исходник меньшего размера и более быстрое (хоть и незначительно) решение. Таким образом, практическое применение \u003ccode\u003elower_bound\u003c/code\u003e в задачах на бинпоиск по ответу имеет смысл только при небольшом размере диапазона.\u003c/p\u003e\u003c/div\u003e","tags":["binary search","stl","двоичный поиск","бин. поиск","lower_bound"]}}