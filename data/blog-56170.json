{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1512392218,"rating":0,"authorHandle":"Mohammad_kilani","modificationTimeSeconds":1525867178,"id":56170,"title":"\u003cp\u003eWeek 4 contest tutorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eProblem A:\u003c/h1\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTags\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eBinary search, Prefix sum, Frequency array, Brute force.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSub-task 1 solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFor each query just iterate on all the numbers and check if they are between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003ecomplexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e × \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSub-task 2 solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eWhen reading a number increase the frequency of that number, the answer will be the sum of the frequency of all the numbers between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003ecomplexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e × (\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + 1))\u003c/span\u003e \u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSub-task 3 solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eDo the same as Sub-task 2, but to get sum use prefix-sum so you get sum in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e(1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003ecomplexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e \u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSub-task 4 solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThe answer of each query equals to upper_bound \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e - \u003c/span\u003e lower_bound \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e, those function runs in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/60/15/6015bd52c75c383b7eaa3a4d93740da1b92a076c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003ecomplexity : \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/74/41/744195df4122863d222e20c5bce41cd495b25ffc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSub-task 1 code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int N \u003d 1010;\nint arr[N] , n , m;\n\nint main() {\n\tint t, s;\n\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;t,\u0026amp;s);\n\twhile(t--){\n\t\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\n\t\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;arr[i]);\n\t\twhile(m--){\n\t\t\tint l , r;\n\t\t\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;l,\u0026amp;r);\n\t\t\tint ans \u003d 0 ;\n\t\t\tfor(int i\u003d0;i\u0026lt;n;i++){\n\t\t\t\tif(arr[i] \u0026gt;\u003d l \u0026amp;\u0026amp; arr[i] \u0026lt;\u003d r) \n\t\t\t\t\tans++;\n\t\t\t}\n\t\t\tprintf(\u0026quot;%d\\n\u0026quot;,ans);\n\t\t}\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSub-task 2 code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int N \u003d 100010;\nint arr[N] , n , m , frq[N];\n\nint main() {\n\tint t, s;\n\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;t,\u0026amp;s);\n\twhile(t--){\n\t\tmemset(frq,0,sizeof(frq));\n\t\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\n\t\tfor(int i\u003d0;i\u0026lt;n;i++){\n\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;arr[i]);\n\t\t\tfrq[arr[i]]++;\n\t\t}\n\t\twhile(m--){\n\t\t\tint l , r;\n\t\t\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;l,\u0026amp;r);\n\t\t\tint ans \u003d 0 ;\n\t\t\tfor(int i\u003dl;i\u0026lt;\u003dr;i++)\n\t\t\t\tans +\u003d frq[i];\n\t\t\tprintf(\u0026quot;%d\\n\u0026quot;,ans);\n\t\t}\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSub-task 3 code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int N \u003d 100010;\nint arr[N] , n , m , frq[N], sum[N];\n\nint main() {\n\tint t, s;\n\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;t,\u0026amp;s);\n\twhile(t--){\n\t\tmemset(frq,0,sizeof(frq));\n\t\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\n\t\tfor(int i\u003d0;i\u0026lt;n;i++){\n\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;arr[i]);\n\t\t\tfrq[arr[i]]++;\n\t\t}\n\t\tfor(int i\u003d1;i\u0026lt;N;i++) \n\t\t\tsum[i] \u003d sum[i-1] + frq[i];\n\t\twhile(m--){\n\t\t\tint l , r;\n\t\t\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;l,\u0026amp;r);\n\t\t\tint ans \u003d sum[r] - sum[l-1];\n\t\t\tprintf(\u0026quot;%d\\n\u0026quot;,ans);\n\t\t}\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSub-task 4 code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int N \u003d 100010;\nint arr[N] , n , m;\n\nint main() {\n\tint t, s;\n\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;t,\u0026amp;s);\n\twhile(t--){\n\t\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\n\t\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;arr[i]);\n                sort(arr,arr+n);\n\t\twhile(m--){\n\t\t\tint l , r;\n\t\t\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;l,\u0026amp;r);\n\t\t\tint ans \u003d upper_bound(arr,arr+n,r) - lower_bound(arr,arr+n,l);\n\t\t\tprintf(\u0026quot;%d\\n\u0026quot;,ans);\n\t\t}\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch1\u003eProblem B:\u003c/h1\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTags\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eBrute force, Complete search, DP. \u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSub-task 1 solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eN always equals to 3 so you can do 3 nested loops for each index, to try to swap that number or not and then check if the 2 arrays become sorted or not.\u003c/p\u003e\u003cp\u003eYou should minimize the answer. \u003c/p\u003e\u003cp\u003ecomplexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e × \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSub-task 2 solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eYou have to try all possible ways of swapping and check if the 2 arrays becomes sorted or not and minimize the answer.\u003c/p\u003e\u003cp\u003eTo do this you can use bitmasks or recursion.\u003c/p\u003e\u003cp\u003ecomplexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e × \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSub-task 3 solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eYou can try to swap one index every time and check if the 2 arrays becomes sorted or not.\u003c/p\u003e\u003cp\u003eYou can check if the arrays becomes sorted in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e \u003c/p\u003e\u003cp\u003ecomplexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e \u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSub-task 4 solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eIf the 2 arrays are sorted then the answer is zero, otherwise it is one. \u003c/p\u003e\u003cp\u003ecomplexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSub-task 5 solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eYou should make 2 arrays, the first array contains the minimal number for each index, and the second array contains the maximal number for each index.\u003c/p\u003e\u003cp\u003eYou should only to check if the 2 arrays are sorted.\u003c/p\u003e\u003cp\u003ecomplexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSub-task 6 solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eLet dp[i][s] be the minimum number of swaps needed to make the sub-array starting from index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e sorted in the both arrays, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e says if the previous index is swapped or not.\u003c/p\u003e\u003cp\u003eNow you can try swapping the current index and try not to swap it. In the both cases you should check if it is larger or equal to the previous index, if it makes the array sorted until now you can try to go the next state and minimize the answer, if there are no way to go return infinity.\u003c/p\u003e\u003cp\u003ecomplexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e \u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSub-task 1 code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define mod 1000000007\n#define oo 2000000000\nconst int N \u003d 100010;\nint n , a[N] , b[N];\n\nbool check(){\n\tfor(int i\u003d1;i\u0026lt;n;i++){\n\t\tif(a[i] \u0026lt; a[i-1] || b[i] \u0026lt; b[i-1]) return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tint t, s;\n\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;t,\u0026amp;s);\n\twhile(t--){\n\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\n\t\tfor(int i\u003d0;i\u0026lt;n;i++) \n\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;a[i]);\n\t\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;b[i]);\n\t\tint ans \u003d oo;\n\t\tfor(int i\u003d0;i\u0026lt;2;i++){\n\t\t\tfor(int j\u003d0;j\u0026lt;2;j++){\n\t\t\t\tfor(int k\u003d0;k\u0026lt;2;k++){\n\t\t\t\t\tint cur \u003d i + j + k;\n\t\t\t\t\tif(i) swap(a[0],b[0]);\n\t\t\t\t\tif(j) swap(a[1],b[1]);\n\t\t\t\t\tif(k) swap(a[2],b[2]);\n\t\t\t\t\tif(check()) ans \u003d min(ans,cur);\n\t\t\t\t\tif(i) swap(a[0],b[0]);\n\t\t\t\t\tif(j) swap(a[1],b[1]);\n\t\t\t\t\tif(k) swap(a[2],b[2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans \u003d\u003d oo) \n\t\t\tans \u003d -1;\n\t\tprintf(\u0026quot;%d\\n\u0026quot;,ans);\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSub-task 2 code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define mod 1000000007\n#define oo 2000000000\nconst int N \u003d 100010;\nint n , a[N] , b[N] ,ans \u003d 0;\n\nbool check(){\n\tfor(int i\u003d1;i\u0026lt;n;i++){\n\t\tif(a[i] \u0026lt; a[i-1] || b[i] \u0026lt; b[i-1]) return false;\n\t}\n\treturn true;\n}\n\nvoid calc(int i,int cur){\n\tif(i \u003d\u003d n){\n\t\tif(check())\n\t\t\tans \u003d min(ans,cur);\n\t\treturn;\n\t}\n\tswap(a[i],b[i]);\n\tcalc(i+1,cur + 1);\n\tswap(a[i],b[i]);\n\tcalc(i+1,cur);\n}\n\nint main() {\n\tint t, s;\n\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;t,\u0026amp;s);\n\twhile(t--){\n\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\n\t\tfor(int i\u003d0;i\u0026lt;n;i++) \n\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;a[i]);\n\t\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;b[i]);\n\t\tans \u003d oo;\n\t\tcalc(0,0);\n\t\tif(ans \u003d\u003d oo) \n\t\t\tans \u003d -1;\n\t\tprintf(\u0026quot;%d\\n\u0026quot;,ans);\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSub-task 3 code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define mod 1000000007\n#define oo 2000000000\nconst int N \u003d 100010;\nint n , a[N] , b[N] ,ans \u003d 0;\n\nbool check(){\n\tfor(int i\u003d1;i\u0026lt;n;i++){\n\t\tif(a[i] \u0026lt; a[i-1] || b[i] \u0026lt; b[i-1]) return false;\n\t}\n\treturn true;\n}\n\n\n\nint main() {\n\tint t, s;\n\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;t,\u0026amp;s);\n\twhile(t--){\n\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\n\t\tfor(int i\u003d0;i\u0026lt;n;i++) \n\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;a[i]);\n\t\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;b[i]);\n\t\tans \u003d oo;\n\t\tif(check()) ans \u003d 0 ;\n\t\tfor(int i\u003d0;i\u0026lt;n;i++){\n\t\t\tswap(a[i],b[i]);\n\t\t\t if(check())\n\t\t\t \tans \u003d min(ans,1);\n\t\t\t swap(a[i],b[i]);\n\t\t}\n\t\tif(ans \u003d\u003d oo) \n\t\t\tans \u003d -1;\n\t\tprintf(\u0026quot;%d\\n\u0026quot;,ans);\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSub-task 4 code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int N \u003d 100010;\nint arr[N] , n , m;\n\nint main() {\n\tint t, s;\n\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;t,\u0026amp;s);\n\twhile(t--){\n\t\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\n\t\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;arr[i]);\n                sort(arr,arr+n);\n\t\twhile(m--){\n\t\t\tint l , r;\n\t\t\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;l,\u0026amp;r);\n\t\t\tint ans \u003d upper_bound(arr,arr+n,r) - lower_bound(arr,arr+n,l);\n\t\t\tprintf(\u0026quot;%d\\n\u0026quot;,ans);\n\t\t}\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSub-task 5 code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define mod 1000000007\n#define oo 2000000000\nconst int N \u003d 100010;\nint n , a[N] , b[N] ,ans \u003d 0;\n\nbool check(){\n\tfor(int i\u003d1;i\u0026lt;n;i++){\n\t\tif(a[i] \u0026lt; a[i-1] || b[i] \u0026lt; b[i-1]) return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tint t, s;\n\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;t,\u0026amp;s);\n\twhile(t--){\n\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\n\t\tfor(int i\u003d0;i\u0026lt;n;i++) \n\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;a[i]);\n\t\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;b[i]);\n\t\tfor(int i\u003d0;i\u0026lt;n;i++){\n\t\t\tif(a[i] \u0026gt; b[i]) swap(a[i],b[i]);\n\t\t}\n\t\tans \u003d -1;\n\t\tif(check()) ans \u003d 0 ;\n\t\tprintf(\u0026quot;%d\\n\u0026quot;,ans);\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSub-task 6 code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int N \u003d 100010;\nint n , a[N],b[N];\nint dp[N][2];\nint solve(int i,bool s){\n\tif(i \u003d\u003d n)\n\t\treturn 0;\n\tif(dp[i][s] !\u003d -1)\n\t\treturn dp[i][s];\n\tdp[i][s] \u003d 1e9;\n\tif(s){\n\t\tif(i \u003d\u003d 0 || (a[i] \u0026gt;\u003d b[i-1] \u0026amp;\u0026amp; b[i] \u0026gt;\u003d a[i-1]))\n\t\t\tdp[i][s] \u003d min(dp[i][s],solve(i+1,0));\n\t\tif(i \u003d\u003d 0 || (b[i] \u0026gt;\u003d b[i-1] \u0026amp;\u0026amp; a[i] \u0026gt;\u003d a[i-1]))\n\t\t\tdp[i][s] \u003d min(dp[i][s],1+solve(i+1,1));\n\t}\n\telse{\n\t\tif(i \u003d\u003d 0 || (a[i] \u0026gt;\u003d b[i-1] \u0026amp;\u0026amp; b[i] \u0026gt;\u003d a[i-1]))\n\t\t\tdp[i][s] \u003d min(dp[i][s],1+solve(i+1,1));\n\t\tif(i \u003d\u003d 0 || (b[i] \u0026gt;\u003d b[i-1] \u0026amp;\u0026amp; a[i] \u0026gt;\u003d a[i-1]))\n\t\t\tdp[i][s] \u003d min(dp[i][s],solve(i+1,0));\n\n\t}\n\treturn dp[i][s];\n}\n\n\nint main(){\n\tint t , s;\n\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;t,\u0026amp;s);\n\twhile(t--){\n\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;a[i]);\n\t\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;b[i]);\n\t\tint ans \u003d solve(0,0);\n\t\tif(ans \u0026gt;\u003d 1e9)\n\t\t\tans \u003d -1;\n\t\tprintf(\u0026quot;%d\\n\u0026quot;,ans);\n\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch1\u003eProblem C:\u003c/h1\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTags\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eShortest paths, Implementation.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eBest solution was found by judges is to create one long path starting from the top right cell, the best way to do that is to make one opened row and then a closed row and then an opened row and so on, then you should open one cell from each closed row, the cell should be the one that makes the longest distance with the cell that was opened in the previous closed row. \u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHow to implement\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eBlock all the cells of the second row and the fourth row and so on. Then open last cell in the second row, then the first cell in the fourth row, then the last cell in the sixth row and so on.\u003c/p\u003e\u003cp\u003ePut the \u0027A\u0027 character in the top left cell.\u003c/p\u003e\u003cp\u003eStart at the top left cell with cost equals to 0, move to the right until the end of the row, then move down two times, then move to the left until you reach the first cell in that row, then move down 2 times, just keep doing this, every time when you do a move increase the cost by one. When you reach a cell with cost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e put the \u0027B\u0027 character in it.\u003c/p\u003e\u003cp\u003eAfter that print the grid.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int N \u003d 510;\nchar grid[N][N];\nint n , m , k;\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k;\n\tfor(int i\u003d0;i\u0026lt;n;i++){\n\t\tfor(int j\u003d0;j\u0026lt;m;j++)\n\t\t\tgrid[i][j] \u003d \u0027.\u0027;\n\t}\n\tfor(int i\u003d1;i\u0026lt;n;i+\u003d2){\n\t\tfor(int j\u003d0;j\u0026lt;m;j++){\n\t\t\tgrid[i][j] \u003d \u0027#\u0027;\n\t\t}\n\t}\n\tbool lastcell \u003d true;\n\tfor(int i\u003d1;i\u0026lt;n;i+\u003d2){\n\t\tif(lastcell)\n\t\t\tgrid[i][m-1] \u003d \u0027.\u0027;\n\t\telse\n\t\t\tgrid[i][0] \u003d \u0027.\u0027;\n\t\tlastcell \u003d lastcell ^ 1; // this changes the true to false and the false to true.\n\t}\n\tgrid[0][0] \u003d \u0027A\u0027;\n\tint cost \u003d 0 ;\n\tbool moveright \u003d true;\n\tfor(int i\u003d0;i\u0026lt;n;i++){\n\t\tif(i % 2 \u003d\u003d 0){\n\t\t\tif(moveright){\n\t\t\t\tfor(int j\u003d0;j\u0026lt;m;j++){\n\t\t\t\t\tif(cost \u003d\u003d k){\n\t\t\t\t\t\tgrid[i][j] \u003d \u0027B\u0027;\n\t\t\t\t\t}\n\t\t\t\t\tcost++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j\u003dm-1;j\u0026gt;\u003d0;j--){\n\t\t\t\t\tif(cost \u003d\u003d k){\n\t\t\t\t\t\tgrid[i][j] \u003d \u0027B\u0027;\n\t\t\t\t\t}\n\t\t\t\t\tcost++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmoveright \u003d moveright ^ 1;\n\t\t}\n\t\telse{\n\t\t\tif(moveright){\n\t\t\t\tif(cost \u003d\u003d k){\n\t\t\t\t\tgrid[i][0] \u003d \u0027B\u0027;\n\t\t\t\t}\n\t\t\t\tcost++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(cost \u003d\u003d k){\n\t\t\t\t\tgrid[i][m-1] \u003d \u0027B\u0027;\n\t\t\t\t}\n\t\t\t\tcost++;\n\t\t\t}\n\n\t\t}\n\t}\n\tfor(int i\u003d0;i\u0026lt;n;i++){\n\t\tputs(grid[i]);\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}