{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1455880125,"rating":3,"authorHandle":"zscoder","modificationTimeSeconds":1455895921,"id":43202,"title":"\u003cp\u003eCodeforces Training 2 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eA. Diverse Permutation\u003c/h3\u003e\u003cp\u003eFor \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e even, the sequence \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f4/c6/f4c65bd3e35a1a4e8fef78d2b3dbb175e4f16bd6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e works. \u003c/p\u003e\u003cp\u003eFor \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e odd, the sequence \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/fd/91/fd910470c4527bffbc8cc748095946a901e5e203.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e works.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/SDRxMD\"\u003eC++ Solution\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eB. Bots\u003c/h3\u003e\u003cp\u003eShort answer : The desired answer is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9c/10/9c1070f0498e93c397e9b08dedf62958b020cf7b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e. We can easily evaluate this number mod \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e + 7\u003c/span\u003e using standard exponentiation by squaring. I didn\u0027t prove this fact but it does pass all test cases.\u003c/p\u003e\u003cp\u003eOfficial Solution :\u003c/p\u003e\u003cp\u003eProblem naturally can be transformed to a more formal way: how many vertices will a trie contain if we add all possible strings with length \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e with equal number of zeros and ones to it. So, first of all, it is obvious that upper half of this tree would be a full binary tree. Let’s take a look on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e \u003d 3\u003c/span\u003e: level \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e – \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e vertex, level \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e – \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e vertices, level \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e – \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e vertices, level \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e – \u003cspan class\u003d\"tex-span\"\u003e8\u003c/span\u003e vertices. Starting from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e-th level not every vertex will duplicate: only those that haven’t spent theirs \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003es or \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003es will. So, here is how to calculate how many vertices will be there on level \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e: \u003c/p\u003e\u003cp\u003eLets’ assign Number_of_non_duplicating_vertices_from_level to PD(i) Counti + 1\u003d PD(i) + (Counti-PD(i))*2. And PD can be calculated pretty easily with binomial coefficients: PD(i) \u003d 2*C(i, N). Everything else is implementation techniques: inverse module arithmetic’s + some fast way tocalculate these C(i, N) and sum Counts\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/zuxIRv\"\u003eC++ Solution\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eC. Primes or Palindromes\u003c/h3\u003e\u003cp\u003eIt is known that the amount of primes not greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is about \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/66/45/66454496b141b3f3afce3e12c6e44c9163b8111f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003c/p\u003e\u003cp\u003eWe can also find that the amount of palindromes with fixed length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, which is about \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/be/4ebe183d1d5349273df98b6e97b4ca4e51c443f5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eTherefore the number of primes asymptotically bigger than the number of palindromic numbers and for every constant \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e there is an answer. Moreover, for this answer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e the next condition hold : \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/26/af/26afa65fec7ae5f1bbea7f15b9b9dd3b6a8a47f7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. In this case, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u0026lt; 10\u003csup class\u003d\"upper-index\"\u003e7\u003c/sup\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eFor all numbers \u003cspan class\u003d\"tex-span\"\u003e \u0026lt; 10\u003csup class\u003d\"upper-index\"\u003e7\u003c/sup\u003e\u003c/span\u003e we can check if they are primes (via sieve of Eratosthenes) and/or palindromes (via trivial algorithm or compute reverse number via dynamic approach). Then we can calculate prefix sums (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eπ\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003erub\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e) and find the answer using linear search. For \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e ≤ 42\u003c/span\u003e the answer is smaller than \u003cspan class\u003d\"tex-span\"\u003e2·10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/pF1vkS\"\u003eC++ Solution\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eD. Space Tour\u003c/h3\u003e\u003cp\u003eThis is a dynamic programming problem. Note that the \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e different paths do not have a common point, so we can consider them separatedly. Use \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e different dp functions to calculate the length of each \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e paths.\u003c/p\u003e\u003cp\u003eFor example, the path that initially go to left direction can be calculated this way:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor(int i \u003d 1; i \u0026lt;\u003d m; i++)\n{\n\tfor(int j \u003d n; j \u0026gt;\u003d 1; j--)\n\t{\n\t\tif(a[i][j])\n\t\t{\n\t\t\tl[i][j] \u003d 1;\n\t\t\tif(a[i - 1][j])\n\t\t\t{\n\t\t\t\tl[i][j] \u003d l[i - 1][j + 1] + 2;\n\t\t\t}\n\t\t}\n\t}\n}\t\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAfter calculating the \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e dp functions, we can loop through each starting position \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e and calculate the result if we start at this position. See the code below for more details.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/f725cd\"\u003eC++ Solution\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eE. Hack It!\u003c/h3\u003e\u003cp\u003eThere are many possible solutions. However, the following solution is the shortest one among all of them :\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d \u003ci\u003ef\u003c/i\u003e(0) + \u003ci\u003ef\u003c/i\u003e(1) + \u003ci\u003ef\u003c/i\u003e(2) + ... + \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e - 1)\u003c/span\u003e. Then, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e) + \u003ci\u003ef\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e + 1) + ... + \u003ci\u003ef\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e) \u003d \u003ci\u003eg\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e + 1) - \u003ci\u003eg\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e)\u003c/span\u003e. We want to find a pair of distinct numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e such that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d5/ad/d5ada7fffad569f70c1b8f6aa4168f6f15763f27.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eNote that for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026lt; 10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e\u003c/span\u003e, we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e + \u003ci\u003ex\u003c/i\u003e) \u003d \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) + 1\u003c/span\u003e. Thus, if we shift the interval \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ex\u003c/i\u003e + 1, \u003ci\u003ex\u003c/i\u003e + 10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e]\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, the sum of the fs in the interval will also increase by exactly \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Also, we can prove that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(10\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sup\u003e) \u003d 45\u003ci\u003ex\u003c/i\u003e·10\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ex\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e for all positive integers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Let \u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003ex\u003c/i\u003e \u0026lt; \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e such that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3f/5f/3f5fe920296f80419eb04270965851ed10e87ebd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. The desired answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e + 10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e - 1\u003c/span\u003e by the above observations. The operations required can be implemented to fit in the long long data type. (see the below code for more details)\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/2ZzxbO\"\u003eC++ Solution\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eF. Water Tree\u003c/h3\u003e\u003cp\u003eOfficial Solution :\u003c/p\u003e\u003cp\u003eLet\u0027s learn how to color a whole subtree. For that enumerate all vertices in post-order DFS. Then each subtree covers a single continious vertex number segment. For each vertex we store the bounds of such segment for a subtree with a root in this vertex. Then to color a subtree means to color a segment in a segment tree.\u003c/p\u003e\u003cp\u003eThen create a segment tree that has a following property: if a vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e was emptied, and is still empty, then this vertex is colored in the segment tree. In the beginning \u0026quot;empty\u0026quot; all the vertices. That is, color all the vertices in the segment tree. With this tree we can efficiently process the queries:\u003c/p\u003e\u003cp\u003eFill a vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. Clean the interval for the subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. If before that some vertex of a subtree was empty, color the parent of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eEmpty a vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. Color the vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in the segment tree.\u003c/p\u003e\u003cp\u003eReply whether a vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is filled. If in the segment tree at least one vertex is colored, then there is such a descendant of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e that is empty now, so the vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is not filled.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/vhzQB3\"\u003eC++ Solution\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eG. Valera and Number\u003c/h3\u003e\u003cp\u003eThe idea is to use dp + bitmask. We calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003emask\u003c/i\u003e][\u003ci\u003ecnt\u003c/i\u003e][\u003ci\u003elast\u003c/i\u003e]\u003c/span\u003e, which is the expected number produced after the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th move, the last \u003cspan class\u003d\"tex-span\"\u003e8\u003c/span\u003e bits of the current number coincides with the bitmask \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e ranges from \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e255\u003c/span\u003e), \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elast\u003c/i\u003e\u003c/span\u003e is the \u003cspan class\u003d\"tex-span\"\u003e9\u003c/span\u003e-th least significant bit, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e\u003c/span\u003e is the number of consecutive bits (following \u003cspan class\u003d\"tex-span\"\u003e9\u003c/span\u003e-th bit) equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elast\u003c/i\u003e\u003c/span\u003e after the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th move. With this dp, transitions of states (+1 and x2) is not hard.\u003c/p\u003e\u003cp\u003eRefer to the solution for more details.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/G6nWkT\"\u003eC++ Solution\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eH. Subset Sums\u003c/h3\u003e\u003cp\u003eOfficial Solution :\u003c/p\u003e\u003cp\u003eThis problem is about data structures.\u003c/p\u003e\u003cp\u003eFirst step of the solution is to divide sets to heavy and light. Light ones are those that contains less than \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/5c/4e5c9f371024ad4e1f5b0f2dfeb967ffe7cb5f4e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e elements. All other sets are heavy.\u003c/p\u003e\u003cp\u003eKey observation is that every light set contains less than \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/5c/4e5c9f371024ad4e1f5b0f2dfeb967ffe7cb5f4e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e elements and number of heavy sets doesn\u0027t exceed \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/5c/4e5c9f371024ad4e1f5b0f2dfeb967ffe7cb5f4e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e because we have upper bound for sum of the sizes of all sets.\u003c/p\u003e\u003cp\u003eIn order to effectively answer queries, for every set (both light and heavy) we calculate size of the intersection of this set and each heavy set. It can be done with time and memory \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d1/0b/d10b20036a61c81a267aab9909e5999331abd538.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. For every heavy set we create boolean array of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. In \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th cell of this array we store how many elements \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e in given set. Then for each element and each heavy set we can check for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time whether element is in the set.\u003c/p\u003e\u003cp\u003eNow let\u0027s consider \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e possible cases:\u003c/p\u003e\u003cp\u003eAdd to the light set. Traverse all numbers in the set and add the value from the query to each of them. Then traverse all heavy sets and add (size of intersection * the value from the query). Time is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eAdd to the heavy set. Just update the counter for the heavy set. Time is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eAnswer to the query for the light set. Traverse all numbers in the set and add values to the answer. Then traverse all heavy sets and add to the answer (answer for this heavy set * size of intersection with the set in the query). Time is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eAnswer to the query for the heavy set. Take already calculated answer, then traverse all heavy sets and add (answer for this heavy set * size of intersection with the set in the query). Time is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eWe have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e queries so total time is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d1/0b/d10b20036a61c81a267aab9909e5999331abd538.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eNote : Actually, it is better to replace \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/5c/4e5c9f371024ad4e1f5b0f2dfeb967ffe7cb5f4e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e with a constant \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9d/05/9d05a17786f323ee55e10ff32bde0665874bfe66.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/uqTdBK\"\u003eC++ Solution\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}