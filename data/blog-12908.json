{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1404294796,"rating":-25,"authorHandle":"ap_hawkdown","modificationTimeSeconds":1404304686,"id":12908,"title":"\u003cp\u003eSimple Dijkstra Implementation in C++\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eSimple Dijkstra in C++\u003c/p\u003e\u003cp\u003ePseudo Code From CLRS:\u003c/p\u003e\u003cp\u003eDijkstra(G,w,s)\u003c/p\u003e\u003cp\u003e1 -Initialise single source(G,s)\u003c/p\u003e\u003cp\u003e2 -S\u003d\u0027\\0\u0027\u003c/p\u003e\u003cp\u003e3 -Q\u003dG.V\u003c/p\u003e\u003cp\u003e4 -while Q!\u003d\u0027\\0\u0027\u003c/p\u003e\u003cp\u003e5 --u\u003dExtract-MIN(Q)\u003c/p\u003e\u003cp\u003e6 --S\u003dS U {u}\u003c/p\u003e\u003cp\u003e7 --for each vertex v belongs to G.Adj[u]\u003c/p\u003e\u003cp\u003e8 ----RELAX(u,v,w)\u003c/p\u003e\u003cp\u003eFunction Relax is described in below C++ code\u003c/p\u003e\u003cp\u003eThis Blog entry is with reference to problem \u003ca href\u003d\"http://www.spoj.com/problems/EZDIJKST/\"\u003ehttp://www.spoj.com/problems/EZDIJKST/\u003c/a\u003e \u003c/p\u003e\u003cp\u003e/*This is the simplest implemententation of Dijkstra Algorithm in C++. Graph is implemented via STL container list using an adjacency list representation This includes use of STL container Set as a pririty queue thus doing away the need of implementing heaps like in C. */\u003c/p\u003e\u003cp\u003eCode Below:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eLL d[1000000];//Distance function\n\nlist\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt; *graph;\n\nvoid dijkstra(int root) {\n\nset\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt; pq;\n/* A set helps insertion and extraction operations in logarithmic time. This set maintains (distance,vertex number) pair sorted on basis of distance*/\n\nset\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt; ::iterator it;\n\nint u,v,wt;\n\nlist\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt; :: iterator i;\n\n\n\n\nd[root]\u003d0;\n\npq.insert(pair\u0026lt;int,int\u0026gt;(0,root));\n\nwhile(pq.size()!\u003d0)\n{\n    it\u003dpq.begin();\n\n    u\u003dit-\u0026gt;second;\n\n    pq.erase(it);\n\n    for(i\u003dgraph[u].begin(); i!\u003dgraph[u].end(); i++)\n    {\n        v\u003di-\u0026gt;first;\n        wt\u003di-\u0026gt;second;\n        //Relax u-v edge with weight wt below:\n        if(d[v]\u0026gt;d[u]+wt)\n        {\n            if(d[v]!\u003d1e8)\n            {\n                pq.erase(pq.find(pair\u0026lt;int,int\u0026gt;(d[v],v)));\n            }\n            d[v]\u003dd[u]+wt;\n            pq.insert(pair\u0026lt;int,int\u0026gt;(d[v],v));\n        }\n//Relax ends\n\n}\n\n}\n}\n\nvoid addedge(int src,int des,int wt) { pair\u0026lt;int,int\u0026gt; x;\n\nx.first\u003ddes;\nx.second\u003dwt;\n\ngraph[src].push_front(x);\n//here we are consering directed graph so. /* include in case of undirected graph\n\nx.first\u003dsrc;\n\nx.second\u003dwt;\n\ngraph[des].push_front(x);\n*/ //This algorithm works in same way for undirected graph }\n\nint main() {\n\nint i;\n\nint t;\n\ncin\u0026gt;\u0026gt;t;\n\nwhile(t--){\n\nint v,e,src,des,wt;\n\ncin\u0026gt;\u0026gt;v\u0026gt;\u0026gt;e;\n\n//Initialise all d[v] to a large number\nfor(i\u003d0; i\u0026lt;\u003dv; i++)\n{\n    d[i]\u003d1e8;\n/*Do not use INF because mathematical operations performed on it will cause overflow\nin some cases you may need higher values like 1e18 etc. as per constraints\n*/\n\n}\n\ngraph\u003dnew list\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt;[v+1];\n\nfor(i\u003d0; i\u0026lt;e; i++)\n{\n    cin\u0026gt;\u0026gt;src\u0026gt;\u0026gt;des\u0026gt;\u0026gt;wt;\n    addedge(src,des,wt);\n}\nint x,y;\n\ncin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\n\ndijkstra(x);\n\nif(d[y]!\u003d1e8)\ncout\u0026lt;\u0026lt;d[y]\u0026lt;\u0026lt;endl;\nelse\n    cout\u0026lt;\u0026lt;\u0026quot;NO\u0026quot;\u0026lt;\u0026lt;endl;\n}\nreturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["dijkstra","simple","tutorial"]}}