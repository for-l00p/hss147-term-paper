{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1499199641,"rating":-7,"authorHandle":"vamaddur","modificationTimeSeconds":1499259884,"id":53112,"title":"\u003cp\u003eIs my alternate approach to USACO 2012 Gold December Contest: \u0026quot;Running Away From the Barn\u0026quot; valid?\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eProblem: \u003ca href\u003d\"http://www.usaco.org/index.php?page\u003dviewproblem2\u0026amp;cpid\u003d213\"\u003ehttp://www.usaco.org/index.php?page\u003dviewproblem2\u0026amp;cpid\u003d213\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFor whatever reason, implementing any of the three official editorial solutions is not working out for me, so I am changing tact.\u003c/p\u003e\u003cp\u003eMy idea is to store the depths relative to the root for each node, run a DFS and BIT similar to what I used in \u003ca href\u003d\"//codeforces.com/blog/entry/53060\"\u003ethis problem\u003c/a\u003e, add/subtract values to/from the BIT according to a sliding window (e.g. when L \u003d 3 and a node with depth 5 is at the bottom of the sliding window, nodes with depth of at most 8 are at the top), and query all nodes in the window that are ancestors of the node in question.\u003c/p\u003e\u003cp\u003eI would appreciate comments on my method.\u003c/p\u003e\u003cp\u003ePlease help, and thanks in advance!\u003c/p\u003e\u003cp\u003eUPD: I coded my fourth attempted solution, only for it to fail the same cases (7, 8, and 9). I would appreciate it if someone could find out what is wrong with it, as I have wasted 8+ hours trying to upsolve this problem to get no variance/change in results. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;unordered_set\u0026gt;\n\nusing namespace std;\n\nint N;\nvector\u0026lt;int\u0026gt; children [200001];\npair\u0026lt;long long, int\u0026gt; pis [200001];\nint tree [200001], id [200001], mx [200001], ret [200001], curr \u003d 1, index \u003d 1;\nlong long L, depth [200001];\n\nvoid add(int pos, long long x){\n    while(pos \u0026lt; 200001){\n        tree[pos] +\u003d x;\n        pos +\u003d (pos\u0026amp;-pos);\n    }\n}\n\nint query(int pos){\n    int sum \u003d 0;\n    while(pos \u0026gt; 0){\n        sum +\u003d tree[pos];\n        pos -\u003d (pos\u0026amp;-pos);\n    }\n    return sum;\n}\n\nint dfs(int x){\n    id[x] \u003d curr++; mx[x] \u003d id[x];\n    for(int i \u003d 0; i \u0026lt; children[x].size(); i++){\n        int next \u003d children[x][i];\n        mx[x] \u003d max(mx[x], dfs(next));\n    }\n    return mx[x];\n}\n\nint main(){\n    //freopen(\u0026quot;runaway.in\u0026quot;, \u0026quot;r\u0026quot;, stdin); freopen(\u0026quot;runaway.out\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n    scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;N, \u0026amp;L); depth[0] \u003d 0ll;\n    for(int i \u003d 2; i \u0026lt;\u003d N; i++){\n        int x; long long y; scanf(\u0026quot;%d %I64d\u0026quot;, \u0026amp;x, \u0026amp;y);\n        children[x].push_back(i); depth[i] \u003d depth[x]+y;\n    }\n    dfs(1);\n    for(int i \u003d 1; i \u0026lt;\u003d N; i++) pis[i] \u003d make_pair(depth[i], i);\n    sort(pis+1, pis+N+1);\n    for(int i \u003d 1; i \u0026lt;\u003d N; i++){\n        long long curDepth \u003d pis[i].first; int now \u003d pis[i].second; int from \u003d id[now]; int to \u003d mx[now];\n        while(index \u0026lt;\u003d N \u0026amp;\u0026amp; curDepth+L \u0026gt;\u003d depth[pis[index].second]){\n            add(id[pis[index].second], 1);\n            index++;\n        }\n        ret[now] \u003d query(to)-query(from-1);\n    }\n    for(int i \u003d 1; i \u0026lt;\u003d N; i++) cout \u0026lt;\u0026lt; ret[i] \u0026lt;\u0026lt; \u0027\\n\u0027;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["usaco","bit/fenwick tree","preorder traversal"]}}