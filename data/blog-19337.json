{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1437419469,"rating":1,"authorHandle":"rekt_n00b","modificationTimeSeconds":1437420133,"id":19337,"title":"\u003cp\u003eManhattan Distance Function\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eDevang\u0027s approach to the problem :\u003c/h3\u003e\u003cp\u003eSo, when I initially saw the problem, I could only make out that brute forcing it was the common perspective and it would not work. So, in order to get an elegant solution, I tried to find any common links between the answer the test cases input. After trying for about 5 test cases, I realized that there wasn’t any common link, but during that time, I realized that the summation of the X and the Y co-ordinates are independent of each other, which I guess is the most important part to the problem. Now, the question arose as to how to optimize the summation of the x and y co-ordinates.\u003c/p\u003e\u003ch2\u003eSolution\u003c/h2\u003e\u003cp\u003eWe have to print sum of | x1 — x2 | + | y1-y2 | for all pairs of points. This can be broken up into sum of | x1 — x2 | and sum of | y1 — y2 | for all pairs of points.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eNow we have two arrays X[] and Y[] representing the abscissa and ordinates of the points .\u003cbr /\u003e Lets define a function f() -\u0026gt; f( Array A ) returns sum of |A[i] — A[j] | for all i,j . \u003cbr /\u003e If we can create f() , our answer will be f(X) + f(Y)\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSo now we have effectively reduced the problem to defining this function f(). \u003cbr /\u003e Observe that if we sort the X[] array in ascending order , then for each index i , we know exactly how many values are lesser than it and exactly how many values are greater than it.\u003c/p\u003e\u003cp\u003eSay N elements are in X , and our current number is at index \u0027i\u0027 . { 0 based indexing } Therefore we know that there are (i) numbers lesser than it and (N-1-i) numbers greater than it. Therefore , for co-ordinate X[i] --\u0026gt; We will add it i times and subtract it (N-1-i) times.\u003c/p\u003e\u003cp\u003eSo what we have ended up doing is that , for each \u0027i\u0027 , we know how much X[i] will contribute to the answer \u003cstrong\u003eWITHOUT LOOKING\u003c/strong\u003e at other X[] values.\u003c/p\u003e\u003cp\u003eExample , say X \u003d { 5 , 2 , 4 , 1 , 7 } \u003cbr /\u003e Sorted X \u003d { 1 , 2 , 4 , 5 , 7 } \u003cbr /\u003e Now lets consider 4 i.e i \u003d 2 \u003cbr /\u003e We now know that 4 will be added twice and will be subtracted twice so we do ans +\u003d (2*4 — 2*4) \u003cbr /\u003e \u003c/p\u003e\u003cp\u003eIn this way , for each \u0027i\u0027 we can compute how many times it must be added/subtracted in constant time and thus for an array of size N it will take O(N) time.\u003c/p\u003e\u003cp\u003eSimilarly , we can solve for Y[] Array and print f(X) + f(Y) as the answer.\u003c/p\u003e\u003cp\u003eComplexity --\u0026gt; O(N log N) { Sorting }\u003c/p\u003e\u003cp\u003eSolutions \u003cbr /\u003e(\u003ca href\u003d\"http://pastie.org/10302909\"\u003ehttp://pastie.org/10302909\u003c/a\u003e) [Author\u0027s solution] \u003cbr /\u003e  [submission:12133826](Devang\u0027s solution) \u003cbr /\u003e  [submission:12135821](Akshal\u0027s solution) \u003c/p\u003e\u003c/div\u003e","tags":["basic math","sorting"]}}