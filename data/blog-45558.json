{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1466440830,"rating":85,"authorHandle":"ch_egor","modificationTimeSeconds":1467588482,"id":45558,"title":"\u003cp\u003eCodeforces Round #359 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eIf you notice typos or errors, please send a private message. \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/686/problem/A\"\u003eDiv2A Free Ice Cream\u003c/a\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eAuthor: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/cdkrot\" title\u003d\"Candidate Master cdkrot\"\u003ecdkrot\u003c/a\u003e \u003cbr /\u003e Developer: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/ch_egor\" title\u003d\"Candidate Master ch_egor\"\u003ech_egor\u003c/a\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eYou just needed to implement the actions described in statement. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eIf you solution failed, then you probably forgot to use 64-bit integers or made some small mistake. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eCorrect solution: \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;deque\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;iomanip\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;bitset\u0026gt;\n\n#pragma comment(linker, \u0026quot;/STACK:256000000\u0026quot;)\n\nusing namespace std;\n\ntypedef long long int int64;\ntypedef long double double80;\n\nconst int INF \u003d (1 \u0026lt;\u0026lt; 29) + 5;\nconst int64 LLINF \u003d (1ll \u0026lt;\u0026lt; 59) + 5;\nconst int MOD \u003d 1000 * 1000 * 1000 + 7;\n\nconst int MAX_N \u003d 1005;\n\nint n, x, sad;\nint64 answer;\n\nint main()\n{\n\t//freopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;output.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n\tscanf(\u0026quot;%d %d\\n\u0026quot;, \u0026amp;n, \u0026amp;x);\n\n\tanswer \u003d x;\n\tsad \u003d 0;\n\n\tint cur;\n\tchar type;\n\tfor (int i \u003d 0; i \u0026lt; n; ++i)\n\t{\n\t\tscanf(\u0026quot;%c %d\\n\u0026quot;, \u0026amp;type, \u0026amp;cur);\n\t\tif (type \u003d\u003d \u0027+\u0027)\n\t\t{\n\t\t\tanswer +\u003d cur;\n\t\t}\n\t\telse if (answer \u0026gt;\u003d cur)\n\t\t{\n\t\t\tanswer -\u003d cur;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++sad;\n\t\t}\n\t}\n\n\tcout \u0026lt;\u0026lt; answer \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; sad \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ePython code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport sys\n\ndef main():\n    n, answer \u003d map(int, sys.stdin.readline().split())\n    sad \u003d 0\n\n    for i in range(n):\n        type_of, cur \u003d sys.stdin.readline().split()\n        cur \u003d int(cur)\n        if type_of \u003d\u003d \u0026quot;+\u0026quot;:\n            answer +\u003d cur\n        elif answer \u0026gt;\u003d cur:\n            answer -\u003d cur\n        else:\n            sad +\u003d 1\n\n    sys.stdout.write(str(answer) + \u0026quot; \u0026quot; + str(sad))\n\nmain()\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/686/problem/B\"\u003eDiv2B Little Robber Girl\u0027s Zoo\u003c/a\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eAuthor: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/ch_egor\" title\u003d\"Candidate Master ch_egor\"\u003ech_egor\u003c/a\u003e \u003cbr /\u003e Developer: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/ch_egor\" title\u003d\"Candidate Master ch_egor\"\u003ech_egor\u003c/a\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eWe need to sort an array with strange operations — namely, to swap elements with even and odd indices in subarray of even length. Note that we can change the 2 neighboring elements, simply doing our exchange action for subarray of length \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e containing these elements. Also, note that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≤ 100\u003c/span\u003e, and it is permission to do \u003cspan class\u003d\"tex-span\"\u003e20 000\u003c/span\u003e actions, therefore, we can write any quadratic sort, which changes the neighboring elements in each iteration (bubble sort for example). \u003cbr /\u003e Complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;deque\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;iomanip\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;bitset\u0026gt;\n\n#pragma comment(linker, \u0026quot;/STACK:256000000\u0026quot;)\n\nusing namespace std;\n\ntypedef long long int int64;\ntypedef long double double80;\n\nconst int INF \u003d (1 \u0026lt;\u0026lt; 29) + 5;\nconst int64 LLINF \u003d (1ll \u0026lt;\u0026lt; 59) + 5;\nconst int MOD \u003d 1000 * 1000 * 1000 + 7;\n\nconst int MAX_N \u003d 105;\n\nint n;\nint arr[MAX_N];\n\nint main()\n{\n\t//freopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;output.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\n\tfor (int i \u003d 0; i \u0026lt; n; ++i)\n\t{\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;arr[i]);\n\t}\n\n\tfor (int i \u003d n - 1; i \u0026gt; 0; --i)\n\t{\n\t\tfor (int j \u003d 0; j \u0026lt; i; ++j)\n\t\t{\n\t\t\tif (arr[j] \u0026gt; arr[j + 1])\n\t\t\t{\n\t\t\t\tswap(arr[j], arr[j + 1]);\n\t\t\t\tprintf(\u0026quot;%d %d\\n\u0026quot;, j + 1, j + 2);\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ePython code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003en \u003d int(input())\narr \u003d list(map(int, input().split()))\n\nfor i in range(n - 1, 0, -1):\n    for j in range(i):\n        if arr[j] \u0026gt; arr[j + 1]:\n            arr[j], arr[j + 1] \u003d arr[j + 1], arr[j]\n            print(j + 1, j + 2)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eBonus: Is anyone able to search the shortest solution of this problem? If yes, what complexity?\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/686/problem/C\"\u003eDiv2C Robbers\u0027 watch\u003c/a\u003e/\u003ca href\u003d\"//codeforces.com/contest/685/problem/A\"\u003eDiv1A Robbers\u0027 watch\u003c/a\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eAuthor: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/cdkrot\" title\u003d\"Candidate Master cdkrot\"\u003ecdkrot\u003c/a\u003e \u003cbr /\u003e Developer: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/themikemikovi4\" title\u003d\"Expert themikemikovi4\"\u003ethemikemikovi4\u003c/a\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eIn this problem we use the septimal number system. It is a very important limitation. Let\u0027s count how many digits are showed on the watch display and call it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e\u003c/span\u003e more than \u003cspan class\u003d\"tex-span\"\u003e7\u003c/span\u003e, the answer is clearly \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e (because of pigeonhole principle). If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e\u003c/span\u003e is not greater than \u003cspan class\u003d\"tex-span\"\u003e7\u003c/span\u003e, then you can just bruteforces all cases. \u003cbr /\u003e Depending on the implementation it will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eBASE\u003c/i\u003e \u003ci\u003eBASE\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eBASE\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eBASE\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eBASE\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eBASE\u003c/i\u003e \u003ci\u003eBASE\u003c/i\u003e!)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eBASE\u003c/i\u003e \u003d 7\u003c/span\u003e. Actually the most simple implementation is just to cycle between all posible hour:minute combinations and check them. \u003cbr /\u003e In the worst case, it will work in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eBASE\u003c/i\u003e \u003ci\u003eBASE\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eBASE\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e. \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e// Copyright (C) 2016 Sayutin Dmitry.\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;.\n\n\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;stdint.h\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;array\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;functional\u0026gt;\n#include \u0026lt;utility\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;assert.h\u0026gt;\n#include \u0026lt;iterator\u0026gt;\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n\nusing std::pair;\nusing std::make_pair;\n\nusing std::min;\nusing std::abs;\nusing std::max;\n\nusing std::sort;\nusing std::generate;\nusing std::min_element;\nusing std::max_element;\n\ntemplate \u0026lt;typename T\u0026gt;\nT input() {\n    T res;\n    cin \u0026gt;\u0026gt; res;\n    return res;\n}\n\nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    size_t n, m;\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\n    size_t len1 \u003d 1, len2 \u003d 1;\n    for (size_t a \u003d 7; a \u0026lt; n; a *\u003d 7)\n        len1 +\u003d 1;\n    for (size_t b \u003d 7; b \u0026lt; m; b *\u003d 7)\n        len2 +\u003d 1;\n\n    size_t ans \u003d 0;\n    if (len1 + len2 \u0026lt;\u003d 7)\n        for (size_t i \u003d 0; i !\u003d n; ++i)\n            for (size_t j \u003d 0; j !\u003d m; ++j) {\n                vector\u0026lt;size_t\u0026gt; used(7, 0);\n                \n                for (size_t a \u003d i, k \u003d 0; k !\u003d len1; a /\u003d 7, ++k)\n                    used[a % 7] +\u003d 1;\n                for (size_t b \u003d j, k \u003d 0; k !\u003d len2; b /\u003d 7, ++k)\n                    used[b % 7] +\u003d 1;\n                \n                if (*std::max_element(used.begin(), used.end()) \u0026lt;\u003d 1)\n                    ++ans;\n            }\n    \n    cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ePython code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eBASE \u003d 7\n\ndef itov(x):\n    digits \u003d []\n    if x \u003d\u003d 0:\n        digits.append(0)\n    while x \u0026gt; 0:\n        digits.append(x % BASE)\n        x //\u003d BASE\n    digits.reverse()\n    return digits\n\ndef gen(pos \u003d 0, minute \u003d False, smaller \u003d False):\n    max_val \u003d max_minute if minute else max_hour\n    if pos \u0026gt;\u003d len(max_val):\n        if minute:\n            return 1\n        else:\n            return gen(0, True)\n    else:\n        ans \u003d 0\n        for digit in range(BASE):\n            if not used[digit] and (smaller or digit \u0026lt;\u003d max_val[pos]):\n                used[digit] \u003d True\n                ans +\u003d gen(pos + 1, minute, smaller or digit \u0026lt; max_val[pos])\n                used[digit] \u003d False\n        return ans\n\nn, m \u003d map(int, input().split())\nn -\u003d 1\nm -\u003d 1\nused \u003d [False] * BASE\nmax_hour \u003d itov(n)\nmax_minute \u003d itov(m)\nprint(gen())\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eBonus: Suppose the base is not fixed. Solve a problem with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eBASE\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e. Can you do it in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5f/7a/5f7a94358321b410475554ff58a3990331fcb7b3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e?\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/686/problem/D\"\u003eDiv2D Kay and Snowflake\u003c/a\u003e/\u003ca href\u003d\"//codeforces.com/contest/685/problem/B\"\u003eDiv1B Kay and Snowflake\u003c/a\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eAuthor: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/cdkrot\" title\u003d\"Candidate Master cdkrot\"\u003ecdkrot\u003c/a\u003e \u003cbr /\u003e Developers: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/ch_egor\" title\u003d\"Candidate Master ch_egor\"\u003ech_egor\u003c/a\u003e, \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/cdkrot\" title\u003d\"Candidate Master cdkrot\"\u003ecdkrot\u003c/a\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eThere are many possible approaches. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eSolution by \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/cdkrot\" title\u003d\"Candidate Master cdkrot\"\u003ecdkrot\u003c/a\u003e: \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eLook at the all candidates for the centroid of the vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e subtree. The size of centroid subtree must be at least \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/72/cd/72cd95755fc9dff3a789ea4065c5e3a46b5408b8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e of the vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e subtree size. (If it isn\u0027t, then after cutting the upper part will have too big size)\u003c/p\u003e\u003cp\u003eChoose the vertex with the smallest subtree size satisfying the constraint above. Let\u0027s prove, that this vertex is centroid indeed. If it isn\u0027t, then after cutting some part will have subtree size greater than \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/72/cd/72cd95755fc9dff3a789ea4065c5e3a46b5408b8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e of subtree size of query vertex. It isn\u0027t upper part (because of constraint above), it is one of our sons. Ouch, it\u0027s subtree less than of selected vertex, and it\u0027s still greater than \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/72/cd/72cd95755fc9dff3a789ea4065c5e3a46b5408b8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e of subtree size of query vertex. Contradiction.\u003c/p\u003e\u003cp\u003eSo we find a centroid. \u003cbr /\u003e We write the euler tour of tree and we will use a 2D segment tree in order to search for a vertex quickly. \u003cbr /\u003e Complexity \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8c/e8/8ce87bc8b184406ef14df1b59202acd0fb966aab.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e// Copyright (C) 2016 Sayutin Dmitry.\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;.\n\n\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;stdint.h\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;array\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;functional\u0026gt;\n#include \u0026lt;utility\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;assert.h\u0026gt;\n#include \u0026lt;iterator\u0026gt;\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n\nusing std::pair;\nusing std::make_pair;\n\nusing std::min;\nusing std::abs;\nusing std::max;\n\nusing std::sort;\nusing std::generate;\nusing std::min_element;\nusing std::max_element;\n\ntemplate \u0026lt;typename T\u0026gt;\nT input() {\n    T res;\n    cin \u0026gt;\u0026gt; res;\n    return res;\n}\n\nconst size_t MAXN \u003d (1 \u0026lt;\u0026lt; 19);\nvector\u0026lt;size_t\u0026gt; graph[MAXN];\n\nvector\u0026lt;pair\u0026lt;size_t, size_t\u0026gt;\u0026gt; segm[2 * MAXN - 1];\n\n#define time TIME_FUCKLIBC\n\npair\u0026lt;size_t, size_t\u0026gt; times[MAXN];\nsize_t time \u003d 0;\n\nsize_t sizes[MAXN];\n\nvoid dfs(size_t v) {\n    size_t sz \u003d 1;\n    \n    times[v].first \u003d time++;\n\n    for (size_t u: graph[v]) {\n        dfs(u);\n        sz +\u003d sizes[u];\n    }\n    \n    times[v].second \u003d time;\n    segm[MAXN - 1 + times[v].first].emplace_back(sz, v);\n    \n    sizes[v] \u003d sz;\n}\n\nvoid buildseg(size_t node, size_t L, size_t R) {\n    if (L !\u003d R - 1) {\n        size_t mid \u003d L + (R - L) / 2;\n        buildseg(2 * node + 1, L, mid);\n        buildseg(2 * node + 2, mid, R);\n        \n        segm[node].resize(segm[2 * node + 1].size() + segm[2 * node + 2].size());\n        std::merge(segm[2 * node + 1].begin(), segm[2 * node + 1].end(), segm[2 * node + 2].begin(), segm[2 * node + 2].end(), segm[node].begin());\n    }\n}\n\npair\u0026lt;size_t, size_t\u0026gt; lowerb(size_t node, size_t L, size_t R, size_t rl, size_t rr, pair\u0026lt;size_t, size_t\u0026gt; minval) {\n    if (rl \u0026lt;\u003d L and R \u0026lt;\u003d rr) {\n        auto it \u003d std::lower_bound(segm[node].begin(), segm[node].end(), minval);\n        if (it \u003d\u003d segm[node].end())\n            return make_pair(SIZE_MAX, SIZE_MAX);\n        else\n            return *it;\n    }\n    if (R \u0026lt;\u003d rl or rr \u0026lt;\u003d L)\n        return make_pair(SIZE_MAX, SIZE_MAX);\n\n    size_t mid \u003d L + (R - L) / 2;\n    return min(lowerb(2 * node + 1, L, mid, rl, rr, minval)\n              ,lowerb(2 * node + 2, mid, R, rl, rr, minval));\n}\n\nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    size_t n, q;\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q;\n    \n    for (size_t i \u003d 1; i !\u003d n; ++i)\n        graph[input\u0026lt;size_t\u0026gt;() - 1].push_back(i);\n\n    dfs(0);\n    buildseg(0, 0, MAXN);\n    \n    for (size_t i \u003d 0; i !\u003d q; ++i) {\n        size_t v \u003d input\u0026lt;size_t\u0026gt;() - 1;\n        cout \u0026lt;\u0026lt; lowerb(0, 0, MAXN, times[v].first, times[v].second, make_pair((sizes[v] + 1) / 2, 0)).second + 1 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n    }\n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eYou can consider all answers by one in dfs using this idea. Use std::set for pair (subtree size, vertex number) and at each vertex merge sets obtained from children. (Also known as \u0026quot;merging sets\u0026quot; idea) \u003cbr /\u003e Thus we get the answers for all vertex and we need only output answers for queries. \u003cbr /\u003e Complexity \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/52/a4/52a40be0688f5a952da7293a965c5f7d6d50ef05.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e// Copyright (C) 2016 Sayutin Dmitry.\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;.\n\n\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;stdint.h\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;array\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;functional\u0026gt;\n#include \u0026lt;utility\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;assert.h\u0026gt;\n#include \u0026lt;iterator\u0026gt;\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n\nusing std::pair;\nusing std::make_pair;\n\nusing std::min;\nusing std::abs;\nusing std::max;\n\nusing std::sort;\nusing std::generate;\nusing std::min_element;\nusing std::max_element;\n\ntemplate \u0026lt;typename T\u0026gt;\nT input() {\n    T res;\n    cin \u0026gt;\u0026gt; res;\n    return res;\n}\n\nset\u0026lt;pair\u0026lt;size_t, size_t\u0026gt;\u0026gt; solve(const vector\u0026lt;vector\u0026lt;size_t\u0026gt;\u0026gt;\u0026amp; graph, vector\u0026lt;size_t\u0026gt;\u0026amp; ans, size_t v) {\n    set\u0026lt;pair\u0026lt;size_t, size_t\u0026gt;\u0026gt; cur;\n\n    for (size_t u: graph[v]) {\n        auto ch \u003d solve(graph, ans, u);\n        if (not (ch.size() \u0026lt; cur.size()))\n            std::swap(ch, cur);\n        \n        for (auto elem: ch)\n            cur.insert(elem);\n    }\n\n    size_t sz \u003d cur.size() + 1;\n    cur.emplace(sz, v);\n\n    ans[v] \u003d cur.lower_bound(make_pair((sz + 1) / 2, 0))-\u0026gt;second;\n    \n    return std::move(cur);\n}\n\nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    size_t n, q;\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q;\n    \n    vector\u0026lt;vector\u0026lt;size_t\u0026gt;\u0026gt; graph(n);\n    for (size_t i \u003d 1; i !\u003d n; ++i)\n        graph[input\u0026lt;size_t\u0026gt;() - 1].push_back(i);\n\n    vector\u0026lt;size_t\u0026gt; ans(n, SIZE_MAX);\n\n    solve(graph, ans, 0);\n    \n    for (size_t i \u003d 0; i !\u003d q; ++i)\n        cout \u0026lt;\u0026lt; ans[input\u0026lt;size_t\u0026gt;() - 1] + 1 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eSolution by \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/ch_egor\" title\u003d\"Candidate Master ch_egor\"\u003ech_egor\u003c/a\u003e: \u003cbr /\u003e Solve it for all subtrees. We can solve the problem for some subtree, after solving the problem for all of it\u0027s children. Let\u0027s choose the heaviest child. Note that the centroid of the child after a certain lifting goes into our centroid. Let\u0027s model the lifting. \u003cbr /\u003e Thus we get the answers for all vertex and we need only output answers for queries. \u003cbr /\u003e Complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003eq\u003c/i\u003e)\u003c/span\u003e \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;deque\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;iomanip\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;bitset\u0026gt;\n\n#pragma comment(linker, \u0026quot;/STACK:256000000\u0026quot;)\n\nusing namespace std;\n\ntypedef long long int int64;\ntypedef long double double80;\n\nconst int INF \u003d (1 \u0026lt;\u0026lt; 29) + 5;\nconst int64 LLINF \u003d (1ll \u0026lt;\u0026lt; 59) + 5;\nconst int MOD \u003d 1000 * 1000 * 1000 + 7;\n\nconst int MAX_N \u003d 300 * 1000 + 5;\nconst int MAX_Q \u003d 300 * 1000 + 5;\n\nint n, q;\nvector\u0026lt;int\u0026gt; graph[MAX_N];\nint size_of[MAX_N];\nint prev_of[MAX_N];\nint big_subtree[MAX_N];\nint centroid[MAX_N];\n\nbool is_centroid_of_subtree(int v, int c)\n{\n\treturn ((size_of[v] - size_of[c]) * 2 \u0026lt;\u003d size_of[v] \u0026amp;\u0026amp; big_subtree[c] * 2 \u0026lt;\u003d size_of[v]);\n}\n\nvoid dfs_calc(int v, int p)\n{\n\tbig_subtree[v] \u003d 0;\n\tsize_of[v] \u003d 1;\n\tprev_of[v] \u003d p;\n\n\tfor (int i \u003d 0; i \u0026lt; graph[v].size(); ++i)\n\t{\n\t\tdfs_calc(graph[v][i], v);\n\t\tsize_of[v] +\u003d size_of[graph[v][i]];\n\t\tbig_subtree[v] \u003d max(big_subtree[v], size_of[graph[v][i]]);\n\t}\n}\n\nvoid dfs_centroid(int v)\n{\n\tif (size_of[v] \u003d\u003d 1)\n\t{\n\t\tcentroid[v] \u003d v;\n\t}\n\telse\n\t{\n\t\tint ptr \u003d 0;\n\t\tfor (int i \u003d 0; i \u0026lt; graph[v].size(); ++i)\n\t\t{\n\t\t\tdfs_centroid(graph[v][i]);\n\t\t\tif (size_of[graph[v][ptr]] \u0026lt; size_of[graph[v][i]])\n\t\t\t{\n\t\t\t\tptr \u003d i;\n\t\t\t}\n\t\t}\n\n\t\tint c \u003d centroid[graph[v][ptr]];\n\n\t\twhile (!is_centroid_of_subtree(v, c))\n\t\t{\n\t\t\tc \u003d prev_of[c];\n\t\t}\n\n\t\tcentroid[v] \u003d c;\n\t}\n}\n\nint main()\n{\n\t//freopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;output.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n\tscanf(\u0026quot;%d %d\u0026quot;, \u0026amp;n, \u0026amp;q);\n\n\tint v;\n\tfor (int i \u003d 0; i \u0026lt; n - 1; ++i)\n\t{\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;v);\n\t\tgraph[v - 1].push_back(i + 1);\n\t}\n\n\tdfs_calc(0, 0);\n\tdfs_centroid(0);\n\n\tfor (int i \u003d 0; i \u0026lt; q; ++i)\n\t{\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;v);\n\t\tprintf(\u0026quot;%d\\n\u0026quot;, centroid[v - 1] + 1);\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/686/problem/E\"\u003eDiv2E Optimal Point\u003c/a\u003e/\u003ca href\u003d\"//codeforces.com/contest/685/problem/C\"\u003eDiv1C Optimal Point\u003c/a\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eAuthor: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/cdkrot\" title\u003d\"Candidate Master cdkrot\"\u003ecdkrot\u003c/a\u003e \u003cbr /\u003e Developer: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/cdkrot\" title\u003d\"Candidate Master cdkrot\"\u003ecdkrot\u003c/a\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s say few words about ternary search. It works correctly, but too slow. \u003cbr /\u003e It\u0027s complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/87/d0/87d0155bc1cae02148200617f8a16537ff4f331a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e\u003c/span\u003e. \u003cbr /\u003e Don\u0027t use it. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eSolution. \u003cbr /\u003e 1) Let\u0027s make binary search on answer \u003cbr /\u003e 2) Consider areas of \u0026quot;good\u0026quot; points (with dist \u003cspan class\u003d\"tex-span\"\u003e ≤ \u003ci\u003emid\u003c/i\u003e\u003c/span\u003e) for each source point. \u003cbr /\u003e 3) Intersect those areas and check for solution. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eThis area can be decsribed by following inequalities: \u003cbr /\u003e (You can achieve them if you expand modules in inequality \u0026quot;manhattan distance \u0026lt;\u003d const\u0026quot;) \u003cbr /\u003e\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e.. ≤ \u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e + \u003ci\u003ez\u003c/i\u003e ≤ ..\u003c/span\u003e\u003c/center\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e.. ≤  - \u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e + \u003ci\u003ez\u003c/i\u003e ≤ ..\u003c/span\u003e\u003c/center\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e.. ≤ \u003ci\u003ex\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e + \u003ci\u003ez\u003c/i\u003e ≤ ..\u003c/span\u003e\u003c/center\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e.. ≤ \u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e - \u003ci\u003ez\u003c/i\u003e ≤ ..\u003c/span\u003e\u003c/center\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e..\u003c/span\u003e denote some constants. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eIf you intersect set of such system, you will get system of the same form, so let\u0027s learn how to solve such system. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s replace some variables: \u003cbr /\u003e\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d  - \u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e + \u003ci\u003ez\u003c/i\u003e\u003c/span\u003e\u003c/center\u003e\u003cp\u003e\u003cbr /\u003e \u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e \u003d \u003ci\u003ex\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e + \u003ci\u003ez\u003c/i\u003e\u003c/span\u003e\u003c/center\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e \u003d \u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e - \u003ci\u003ez\u003c/i\u003e\u003c/span\u003e\u003c/center\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eThen: \u003cbr /\u003e\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e + \u003ci\u003ez\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e + \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e\u003c/center\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d (\u003ci\u003eb\u003c/i\u003e + \u003ci\u003ec\u003c/i\u003e) / 2\u003c/span\u003e\u003c/center\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e \u003d (\u003ci\u003ea\u003c/i\u003e + \u003ci\u003ec\u003c/i\u003e) / 2\u003c/span\u003e\u003c/center\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e \u003d (\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e) / 2\u003c/span\u003e\u003c/center\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eNow the system transforms into: \u003cbr /\u003e\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e.. ≤ \u003ci\u003ea\u003c/i\u003e ≤ ..\u003c/span\u003e\u003c/center\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e.. ≤ \u003ci\u003eb\u003c/i\u003e ≤ ..\u003c/span\u003e\u003c/center\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e.. ≤ \u003ci\u003ec\u003c/i\u003e ≤ ..\u003c/span\u003e\u003c/center\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e.. ≤ \u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e + \u003ci\u003ec\u003c/i\u003e ≤ ..\u003c/span\u003e\u003c/center\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eWe need to check if the system has solution in integers, also the numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e must be of the same parity (have equal remainder after division by \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e). (This is required for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e to be integers too) \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s get rid of parity constraint. Bruteforce the parity of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e (two cases) \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eMake following replacement: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d 2\u003ci\u003ea\u003c/i\u003e\u0027 + \u003ci\u003er\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e \u003d 2\u003ci\u003eb\u003c/i\u003e\u0027 + \u003ci\u003er\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e \u003d 2\u003ci\u003ec\u003c/i\u003e\u0027 + \u003ci\u003er\u003c/i\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e \u003d 0\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e \u003d 1\u003c/span\u003e. Substitute in equations above, simplify, and gain the same system for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u0027\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u0027\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u0027\u003c/span\u003e without parity constraint. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eAnd now the system can be solved greedy (At first set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e with minimum, and then raise slowly if necessary). \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eTotal complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/75/3d/753d46f55fd820bea094a3f88c298e678b4b0ef7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e// Copyright (C) 2016 Sayutin Dmitry.\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;.\n\n\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;stdint.h\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;array\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;functional\u0026gt;\n#include \u0026lt;utility\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;assert.h\u0026gt;\n#include \u0026lt;iterator\u0026gt;\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n\nusing std::pair;\nusing std::make_pair;\n\nusing std::min;\nusing std::abs;\nusing std::max;\n\nusing std::sort;\nusing std::generate;\nusing std::min_element;\nusing std::max_element;\n\ntemplate \u0026lt;typename T\u0026gt;\nT input() {\n    T res;\n    cin \u0026gt;\u0026gt; res;\n    return res;\n}\n\nstruct coord {\n    int64_t x;\n    int64_t y;\n    int64_t z;\n};\n\nstruct equation {\n    pair\u0026lt;int64_t, int64_t\u0026gt; S;\n    pair\u0026lt;int64_t, int64_t\u0026gt; a;\n    pair\u0026lt;int64_t, int64_t\u0026gt; b;\n    pair\u0026lt;int64_t, int64_t\u0026gt; c;\n};\n\nvector\u0026lt;coord\u0026gt; list;\n\nequation operator+(const equation\u0026amp; e1, const equation\u0026amp; e2) {\n    equation res;\n    res.S \u003d {max(e1.S.first, e2.S.first), min(e1.S.second, e2.S.second)};\n    res.a \u003d {max(e1.a.first, e2.a.first), min(e1.a.second, e2.a.second)};\n    res.b \u003d {max(e1.b.first, e2.b.first), min(e1.b.second, e2.b.second)};\n    res.c \u003d {max(e1.c.first, e2.c.first), min(e1.c.second, e2.c.second)};\n    return res;\n}\n\ncoord get_solution(const equation\u0026amp; eq) {\n    if ((eq.S.first \u0026gt; eq.S.second)\n     or (eq.a.first \u0026gt; eq.a.second)\n     or (eq.b.first \u0026gt; eq.b.second)\n     or (eq.c.first \u0026gt; eq.c.second))\n        return coord {INT64_MAX, INT64_MAX, INT64_MAX};\n        \n     if ((eq.a.first + eq.b.first + eq.c.first \u0026gt; eq.S.second)\n     or (eq.a.second + eq.b.second + eq.c.second \u0026lt; eq.S.first))\n        return coord {INT64_MAX, INT64_MAX, INT64_MAX};\n\n     coord res;\n     res.x \u003d eq.a.first;\n     res.y \u003d eq.b.first;\n     res.z \u003d eq.c.first;\n     int64_t delta \u003d max(int64_t(0), eq.S.first - res.x - res.y - res.z);\n\n     res.x +\u003d min(delta, eq.a.second - eq.a.first);\n     delta -\u003d min(delta, eq.a.second - eq.a.first);\n     res.y +\u003d min(delta, eq.b.second - eq.b.first);\n     delta -\u003d min(delta, eq.b.second - eq.b.first);\n     res.z +\u003d min(delta, eq.c.second - eq.c.first);\n     delta -\u003d min(delta, eq.c.second - eq.c.first);\n\n     assert(delta \u003d\u003d 0);\n     \n     return res;\n}\n\nint64_t DIV2(int64_t arg) {\n    return (arg - (arg \u0026amp; 1)) / 2;\n}\n\ncoord can(int64_t MAXANS) {\n    equation eq;\n    eq.S \u003d eq.a \u003d eq.b \u003d eq.c \u003d {INT64_MIN, INT64_MAX};\n    \n    for (const coord\u0026amp; crd: list) {\n        equation nw;\n        nw.S \u003d { crd.x + crd.y + crd.z - MAXANS,  crd.x + crd.y + crd.z + MAXANS};\n        nw.a \u003d {-crd.x + crd.y + crd.z - MAXANS, -crd.x + crd.y + crd.z + MAXANS};\n        nw.b \u003d { crd.x - crd.y + crd.z - MAXANS,  crd.x - crd.y + crd.z + MAXANS};\n        nw.c \u003d { crd.x + crd.y - crd.z - MAXANS,  crd.x + crd.y - crd.z + MAXANS};\n        \n        eq \u003d eq + nw;\n    }\n\n    for (int64_t r \u003d 0; r \u0026lt;\u003d 1; ++r) {\n        equation tr \u003d eq;\n\n        tr.S.first  \u003d DIV2(tr.S.first - 3 * r + 1);\n        tr.a.first  \u003d DIV2(tr.a.first - r + 1);\n        tr.b.first  \u003d DIV2(tr.b.first - r + 1);\n        tr.c.first  \u003d DIV2(tr.c.first - r + 1);\n\n        tr.S.second \u003d DIV2(tr.S.second - 3 * r);\n        tr.a.second \u003d DIV2(tr.a.second - r);\n        tr.b.second \u003d DIV2(tr.b.second - r);\n        tr.c.second \u003d DIV2(tr.c.second - r);\n\n        coord sol \u003d get_solution(tr);\n        if (sol.x !\u003d INT64_MAX) {\n            coord ans;\n            ans.x \u003d r + sol.y + sol.z;\n            ans.y \u003d r + sol.x + sol.z;\n            ans.z \u003d r + sol.x + sol.y;\n\n            return ans;\n        }\n    }\n    return coord {INT64_MAX, INT64_MAX, INT64_MAX};\n}\n\nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    list.reserve(100000);\n    \n    for (size_t T \u003d input\u0026lt;size_t\u0026gt;(); T !\u003d 0; --T) {\n        list.resize(input\u0026lt;size_t\u0026gt;());\n        \n        for (coord\u0026amp; crd: list)\n            cin \u0026gt;\u0026gt; crd.x \u0026gt;\u0026gt; crd.y \u0026gt;\u0026gt; crd.z;\n\n        int64_t L \u003d -1; // definitely imposible\n        int64_t R \u003d 3 * int64_t(1000 * 1000 * 1000) * int64_t(1000 * 1000 * 1000) + 10; // definitely possible\n\n        while (R - L \u0026gt; 1) {\n            int64_t M \u003d L + (R - L) / 2;\n            if (can(M).x !\u003d INT64_MAX)\n                R \u003d M;\n            else\n                L \u003d M;\n        }\n        coord ans \u003d can(R);\n        cout \u0026lt;\u0026lt; ans.x \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ans.y \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ans.z \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n    }\n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eBonus. This task can be solved in a lot of modifications, for example euclidian distance instead of manhattan, 2d instead of 3d, floats instead of integers. How to solve this varations? \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/685/problem/D\"\u003eDiv1D Kay and Eternity\u003c/a\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eAuthors: \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/platypus179\" title\u003d\"Master platypus179\"\u003eplatypus179\u003c/a\u003e, \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Endagorion\" title\u003d\"International Grandmaster Endagorion\"\u003eEndagorion\u003c/a\u003e \u003cbr /\u003e Developer: \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/platypus179\" title\u003d\"Master platypus179\"\u003eplatypus179\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s solve this problem with scanline. Go through all rows from left to right and maintain the array in which in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e index we will store the number of points in a square with bottom left coordinate \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e, where i is current row of scanline. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eThis takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eMAXCORD\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e time. Note that the set of squares that contain some of the shaded points is not very large, namely — if the point has coordinates \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e, then the set of left bottom corners of square is defined as \u003cspan class\u003d\"tex-span\"\u003e{(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)|\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e + 1 \u0026lt;  \u003d \u003ci\u003ea\u003c/i\u003e \u0026lt;  \u003d \u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e + 1 \u0026lt;  \u003d \u003ci\u003eb\u003c/i\u003e \u0026lt;  \u003d \u003ci\u003ey\u003c/i\u003e}\u003c/span\u003e. Let\u0027s consider each point \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e as the \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e events: \u003cbr /\u003e Add one to the all elements with indexes from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e on the row \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e and take one at the same interval on the row \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + 1\u003c/span\u003e. How to calculate answer? Suppose we update the value of a cell on the row \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, and before it was updated the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e on the row \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. Let add to the answer for the number of squares containing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e points value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e - \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. We can implement the addition of the segment directly and have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enk\u003c/i\u003e)\u003c/span\u003e for processing all the events that fit in time limit. To get rid of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eMAXCORD\u003c/i\u003e)\u003c/span\u003e memory, we need to write all interested in the coordinates before processing events (them no more than nk) and reduce the coordinates in the events. It takes \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c9/1e/c91ed9391dc8f62a7c90154b3889ad2609fb8c4c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enk\u003c/i\u003e)\u003c/span\u003e memory. Now we can execute the previous point in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enk\u003c/i\u003e)\u003c/span\u003e memory. \u003cbr /\u003e Complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8e/13/8e135f665e2433ecf801409a6a70b13530d5f95e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enk\u003c/i\u003e)\u003c/span\u003e memory. \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n\nusing namespace std;\ntypedef long long ll;\n\n#define NotANumber -1791791791\n\nstruct query {\n    int row, l, r; bool a;\n    int lbl, ubr;\n    query(int _row, int _l, int _r, bool _a) {row \u003d _row; l \u003d _l; r \u003d _r; a \u003d _a;}\n    bool operator\u0026lt;(const query\u0026amp; other) const {\n        return row \u0026lt; other.row;\n    }\n};\n\nint main() {\n    int n, k;\n    scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;n, \u0026amp;k);\n    vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; points(n);\n    for (int i \u003d 0; i \u0026lt; n; i++)\n        scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;points[i].first, \u0026amp;points[i].second);\n\n    sort(points.begin(), points.end());\n    vector\u0026lt;int\u0026gt; xcoords;\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        int st;\n        if (xcoords.empty())\n            st \u003d points[i].first - k + 1;\n        else\n            st \u003d max(xcoords.back() + 1, points[i].first - k + 1);\n        for (int j \u003d st; j \u0026lt;\u003d points[i].first; j++)\n            xcoords.push_back(j);\n    }\n\n    vector\u0026lt;query\u0026gt; qs;\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        qs.push_back(query(points[i].second - k + 1, points[i].first - k + 1, points[i].first, 1));\n        qs.push_back(query(points[i].second + 1, points[i].first - k + 1, points[i].first, 0));\n    }\n\n    for (query \u0026amp; q : qs) {\n        q.lbl \u003d lower_bound(xcoords.begin(), xcoords.end(), q.l) - xcoords.begin();\n        q.ubr \u003d upper_bound(xcoords.begin(), xcoords.end(), q.r) - xcoords.begin();\n    }\n    \n    int xcdssz \u003d xcoords.size();\n    xcoords.clear();\n    xcoords.shrink_to_fit();\n\n    sort(qs.begin(), qs.end());\n\n    vector\u0026lt;int\u0026gt; vec(xcdssz, 0);\n    vector\u0026lt;int\u0026gt; lastchanged(xcdssz, NotANumber);\n    vector\u0026lt;ll\u0026gt; ans(n);\n\n    for (query q : qs) {\n        int lbl \u003d q.lbl;\n        int ubr \u003d q.ubr;\n        for (int i \u003d lbl; i \u0026lt; ubr; i++) {\n            if (lastchanged[i] !\u003d NotANumber \u0026amp;\u0026amp; vec[i] !\u003d 0) {\n                ans[vec[i] - 1] +\u003d q.row - lastchanged[i];\n            }\n            if (q.a)\n                vec[i]++;\n            else\n                vec[i]--;\n            lastchanged[i] \u003d q.row;\n        }\n    }\n\n    for (int i \u003d 0; i \u0026lt; n; i++)\n        printf(\u0026quot;%lld \u0026quot;, ans[i]);\n    printf(\u0026quot;\\n\u0026quot;);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eBonus: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b9/f6/b9f67c8c6c0f5be0ff146fccb2024c545f6c6a9d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e memory. \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;deque\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;iomanip\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;bitset\u0026gt;\n\n#pragma comment(linker, \u0026quot;/STACK:256000000\u0026quot;)\n\nusing namespace std;\n\ntypedef long long int int64;\ntypedef long double double80;\n\nconst int INF \u003d (1 \u0026lt;\u0026lt; 29) + 5;\nconst int64 LLINF \u003d (1ll \u0026lt;\u0026lt; 59) + 5;\nconst int MOD \u003d 1000 * 1000 * 1000 + 7;\n\nconst int MAX_N \u003d 1000 * 100 + 5;\nconst int MAX_K \u003d 305;\n\n/** Interface */\n\ninline int readChar();\ntemplate \u0026lt;class T \u003d int\u0026gt; inline T readInt();\ntemplate \u0026lt;class T\u0026gt; inline void writeInt(T x);\ninline void writeChar(int x);\ninline void writeWord(const char *s);\ninline void flush();\n\n/** Read */\n\nstatic const int buf_size \u003d 20 * 1000 * 1000;\n\ninline int getChar()\n{\n\tstatic char buf[buf_size];\n\tstatic int len \u003d 0, pos \u003d 0;\n\tif (pos \u003d\u003d len)\n\t\tpos \u003d 0, len \u003d fread(buf, 1, buf_size, stdin);\n\tif (pos \u003d\u003d len)\n\t\treturn -1;\n\treturn buf[pos++];\n}\n\ninline int readChar()\n{\n\tint c \u003d getChar();\n\twhile (c \u0026lt;\u003d 32)\n\t\tc \u003d getChar();\n\treturn c;\n}\n\ntemplate \u0026lt;class T\u0026gt;\ninline T readInt()\n{\n\tint s \u003d 1, c \u003d readChar();\n\tT x \u003d 0;\n\tif (c \u003d\u003d \u0027-\u0027)\n\t\ts \u003d -1, c \u003d getChar();\n\twhile (\u00270\u0027 \u0026lt;\u003d c \u0026amp;\u0026amp; c \u0026lt;\u003d \u00279\u0027)\n\t\tx \u003d x * 10 + c - \u00270\u0027, c \u003d getChar();\n\treturn s \u003d\u003d 1 ? x : -x;\n}\n\ninline int64 readInt64()\n{\n\tint s \u003d 1, c \u003d readChar();\n\tint64 x \u003d 0;\n\tif (c \u003d\u003d \u0027-\u0027)\n\t\ts \u003d -1, c \u003d getChar();\n\twhile (\u00270\u0027 \u0026lt;\u003d c \u0026amp;\u0026amp; c \u0026lt;\u003d \u00279\u0027)\n\t\tx \u003d x * 10 + c - \u00270\u0027, c \u003d getChar();\n\treturn s \u003d\u003d 1 ? x : -x;\n}\n\n/** Write */\n\nstatic int write_pos \u003d 0;\nstatic char write_buf[buf_size];\n\ninline void writeChar(int x)\n{\n\tif (write_pos \u003d\u003d buf_size)\n\t\tfwrite(write_buf, 1, buf_size, stdout), write_pos \u003d 0;\n\twrite_buf[write_pos++] \u003d x;\n}\n\ninline void flush()\n{\n\tif (write_pos)\n\t\tfwrite(write_buf, 1, write_pos, stdout), write_pos \u003d 0;\n}\n\ntemplate \u0026lt;class T\u0026gt;\ninline void writeInt(T x)\n{\n\tif (x \u0026lt; 0)\n\t\twriteChar(\u0027-\u0027), x \u003d -x;\n\n\tchar s[24];\n\tint n \u003d 0;\n\twhile (x || !n)\n\t\ts[n++] \u003d \u00270\u0027 + x % 10, x /\u003d 10;\n\twhile (n--)\n\t\twriteChar(s[n]);\n}\n\ninline void writeInt64(int64 x)\n{\n\tif (x \u0026lt; 0)\n\t\twriteChar(\u0027-\u0027), x \u003d -x;\n\n\tchar s[24];\n\tint n \u003d 0;\n\twhile (x || !n)\n\t\ts[n++] \u003d \u00270\u0027 + x % 10, x /\u003d 10;\n\twhile (n--)\n\t\twriteChar(s[n]);\n}\n\ninline void writeWord(const char *s)\n{\n\twhile (*s)\n\t\twriteChar(*s++);\n}\n\nstruct point\n{\n\tint x;\n\tint y;\n};\n\nstruct ask\n{\n\tint l;\n\tint r;\n\tint ptr;\n\tint type;\n};\n\nbool cmp(const ask \u0026amp;a, const ask \u0026amp;b)\n{\n\treturn a.ptr \u0026lt; b.ptr;\n}\n\nint n, k;\npoint arr[MAX_N];\nint cord[MAX_N * 2];\nask asks[MAX_N * 2];\nint cord_len \u003d 0;\nint asks_len \u003d 0;\nbool have_prev_cord[MAX_N * 2];\nbool have_prev_line[MAX_N * 2];\nint last_of_cord[MAX_N * 2];\nint last_of_line[MAX_N * 2];\nint at_cord[MAX_N * 2];\nint at_line[MAX_N * 2];\nint64 answer[MAX_N];\n\nint main()\n{\n\t//freopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;output.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n\tn \u003d readInt();\n\tk \u003d readInt();\n\n\tfor (int i \u003d 0; i \u0026lt; n; ++i)\n\t{\n\t\tarr[i].x \u003d readInt();\n\t\tarr[i].y \u003d readInt();\n\t\tcord[cord_len++] \u003d arr[i].x;\n\t\tcord[cord_len++] \u003d arr[i].x - k + 1;\n\t}\n\n\tsort(cord, cord + 2 * n);\n\tcord_len \u003d unique(cord, cord + 2 * n) - cord;\n\t\n\tfor (int i \u003d 0; i \u0026lt; n; ++i)\n\t{\n\t\tasks[asks_len].l \u003d lower_bound(cord, cord + cord_len, arr[i].x - k + 1) - cord;\n\t\tasks[asks_len].r \u003d lower_bound(cord, cord + cord_len, arr[i].x) - cord;\n\t\tasks[asks_len].ptr \u003d arr[i].y - k + 1;\n\t\tasks[asks_len].type \u003d 1;\n\t\t++asks_len;\n\t\tasks[asks_len].l \u003d asks[asks_len - 1].l;\n\t\tasks[asks_len].r \u003d asks[asks_len - 1].r;\n\t\tasks[asks_len].ptr \u003d arr[i].y + 1;\n\t\tasks[asks_len].type \u003d -1;\n\t\t++asks_len;\n\t}\n\n\tsort(asks, asks + asks_len, cmp);\n\tmemset(answer, 0, sizeof(answer));\n\tmemset(last_of_cord, 0, sizeof(last_of_cord));\n\tmemset(last_of_line, 0, sizeof(last_of_line));\n\tmemset(at_cord, 0, sizeof(at_cord));\n\tmemset(at_line, 0, sizeof(at_line));\n\tmemset(have_prev_cord, 0, sizeof(have_prev_cord));\n\tmemset(have_prev_line, 0, sizeof(have_prev_cord));\n\n\tfor (int i \u003d 0; i \u0026lt; asks_len; ++i)\n\t{\n\t\tfor (int j \u003d asks[i].l; j \u0026lt;\u003d asks[i].r; ++j)\n\t\t{\n\t\t\tif (!have_prev_cord[j])\n\t\t\t{\n\t\t\t\thave_prev_cord[j] \u003d true;\n\t\t\t\tlast_of_cord[j] \u003d asks[i].ptr;\n\t\t\t\tat_cord[j] +\u003d asks[i].type;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tanswer[at_cord[j]] +\u003d asks[i].ptr - last_of_cord[j];\n\n\t\t\t\tlast_of_cord[j] \u003d asks[i].ptr;\n\t\t\t\tat_cord[j] +\u003d asks[i].type;\n\t\t\t}\n\t\t\n\n\t\t\tif (j !\u003d asks[i].r)\n\t\t\t{\n\t\t\t\tif (!have_prev_line[j])\n\t\t\t\t{\n\t\t\t\t\thave_prev_line[j] \u003d true;\n\t\t\t\t\tlast_of_line[j] \u003d asks[i].ptr;\n\t\t\t\t\tat_line[j] +\u003d asks[i].type;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tanswer[at_line[j]] +\u003d 1ll * (cord[j + 1] - cord[j] - 1) * (asks[i].ptr - last_of_line[j]);\n\n\t\t\t\t\tlast_of_line[j] \u003d asks[i].ptr;\n\t\t\t\t\tat_line[j] +\u003d asks[i].type;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i \u003d 1; i \u0026lt;\u003d n; ++i)\n\t{\n\t\twriteInt64(answer[i]);\n\t\twriteChar(\u0027 \u0027);\n\t}\n\n\tflush();\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/685/problem/E\"\u003eDiv1E Travelling Through the Snow Queen\u0027s Kingdom\u003c/a\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eAuthors: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/cdkrot\" title\u003d\"Candidate Master cdkrot\"\u003ecdkrot\u003c/a\u003e, \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/GlebsHP\" title\u003d\"Grandmaster GlebsHP\"\u003eGlebsHP\u003c/a\u003e \u003cbr /\u003e Developers: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/ch_egor\" title\u003d\"Candidate Master ch_egor\"\u003ech_egor\u003c/a\u003e, \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/cdkrot\" title\u003d\"Candidate Master cdkrot\"\u003ecdkrot\u003c/a\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eUnfortunately, due to my, \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/cdkrot\" title\u003d\"Candidate Master cdkrot\"\u003ecdkrot\u003c/a\u003e, failure, it was possible to get Ac with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e)\u003c/span\u003e solution, I apologise for that. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eWe propose following solution: \u003cbr /\u003e Let\u0027s solve task with divide \u0026amp; conquer. At first let\u0027s lift \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e to the first index, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e was mentioned And lower the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e to the last index, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e was mentioned. This will not affect answers, but will make implementation much more easy. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s look on all queries. For each query consider it\u0027s location relative to centre of edges array. If it\u0027s stricly on the left half or on the right half, then solve recursively (You need to implement function like \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esolve\u003c/i\u003e(\u003ci\u003erequests\u003c/i\u003e, \u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e). \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eHow to answer on query, if it contains the centre? Let\u0027s precalculate two dp\u0027s: \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d \u003c/span\u003e bitset of vertices you can from to the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d \u003ci\u003em\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e \u003d \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d \u003c/span\u003e bitset of vertices you can go to starting from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e \u003d \u003ci\u003em\u003c/i\u003e - 1\u003c/span\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e are vertices of i\u0027th edge. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eUsing this dp the answer is yes if and ony if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003el\u003c/i\u003e][\u003ci\u003eu\u003c/i\u003e] \u003d \u003ci\u003etrue\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003er\u003c/i\u003e][\u003ci\u003eu\u003c/i\u003e] \u003d \u003ci\u003etrue\u003c/i\u003e\u003c/span\u003e for some \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eAll above can be implemented using bitwise operations. \u003cbr /\u003e So the time is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/26/de/26ded77fd2d28f833c297e4e2b523804ac398e54.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e// Copyright (C) 2016 Sayutin Dmitry.\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;.\n\n\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;stdint.h\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;array\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;functional\u0026gt;\n#include \u0026lt;utility\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;assert.h\u0026gt;\n#include \u0026lt;iterator\u0026gt;\n#include \u0026lt;bitset\u0026gt;\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n\nusing std::pair;\nusing std::make_pair;\n\nusing std::min;\nusing std::abs;\nusing std::max;\n\nusing std::sort;\nusing std::generate;\nusing std::min_element;\nusing std::max_element;\n\n#define size_t uint32_t\n\nstruct Req {\n    size_t L;\n    size_t R;\n    size_t S;\n    size_t T;\n    size_t ID;\n};\n\nstruct Edge {\n    size_t v;\n    size_t u;\n    size_t prev1;\n    size_t prev2;\n    size_t next1;\n    size_t next2;\n};\n\nconst size_t MAXQ \u003d 200000;\nconst size_t MAXN \u003d 1000;\nconst size_t MAXM \u003d 200000;\n\nchar answers[MAXQ];\nEdge list[MAXM];\nvector\u0026lt;size_t\u0026gt; last[MAXN];\n\nstd::bitset\u0026lt;MAXN\u0026gt; masks_r[MAXM / 2 + 10];\nstd::bitset\u0026lt;MAXN\u0026gt; masks_l[MAXM / 2 + 10];\n\nvoid solve_layer(vector\u0026lt;Req\u0026gt;\u0026amp; requests, size_t l, size_t m, size_t r) {\n    bool has \u003d false;\n    for (size_t i \u003d 0; i !\u003d requests.size(); ++i)\n        has or_eq (requests[i].L \u0026lt;\u003d m - 1 and requests[i].R \u0026gt;\u003d m);\n    if (not has)\n        return;\n    \n    for (size_t i \u003d 0; i !\u003d r - m; ++i) {\n        masks_r[i] \u003d std::bitset\u0026lt;MAXN\u0026gt;();\n        if (list[m + i].prev1 \u0026gt;\u003d m and list[m + i].prev1 !\u003d std::numeric_limits\u0026lt;size_t\u0026gt;::max())\n            masks_r[i] |\u003d masks_r[list[m + i].prev1 - m];\n        if (list[m + i].prev2 \u0026gt;\u003d m and list[m + i].prev2 !\u003d std::numeric_limits\u0026lt;size_t\u0026gt;::max())\n            masks_r[i] |\u003d masks_r[list[m + i].prev2 - m];\n\n        masks_r[i][list[m + i].v] \u003d true;\n        masks_r[i][list[m + i].u] \u003d true;\n    }\n    \n    for (size_t z \u003d 0; z !\u003d m - l; ++z) {\n        size_t i \u003d (m - l) - 1 - z;\n        masks_l[i] \u003d std::bitset\u0026lt;MAXN\u0026gt;();\n        \n        if (list[l + i].next1 \u0026lt; m)\n            masks_l[i] |\u003d masks_l[list[l + i].next1 - l];\n        if (list[l + i].next2 \u0026lt; m)\n            masks_l[i] |\u003d masks_l[list[l + i].next2 - l];\n        masks_l[i][list[l + i].v] \u003d true;\n        masks_l[i][list[l + i].u] \u003d true;\n    }\n\n    for (size_t i \u003d 0; i !\u003d requests.size();)\n        if (requests[i].L \u0026lt;\u003d m - 1 and requests[i].R \u0026gt;\u003d m) {\n            answers[requests[i].ID] \u003d (masks_r[requests[i].R - m] \u0026amp; masks_l[requests[i].L - l]).any();\n            std::swap(requests[i], requests.back());\n            requests.pop_back();\n        } else {\n            ++i;\n        }\n}\n\nvoid solve(vector\u0026lt;Req\u0026gt;\u0026amp; requests, size_t l, size_t r) {\n    if (l \u003d\u003d r - 1) {\n        for (auto\u0026amp; req: requests)\n            answers[req.ID] \u003d (req.S \u003d\u003d list[l].v or req.S \u003d\u003d list[l].u)\n                          and (req.T \u003d\u003d list[l].v or req.T \u003d\u003d list[l].u);\n        return;\n    }\n    size_t m \u003d l + (r - l) / 2;\n    // [l, m), [m, r).\n\n    solve_layer(requests, l, m, r);\n\n    vector\u0026lt;Req\u0026gt; right;\n    for (size_t i \u003d 0; i !\u003d requests.size();)\n        if (requests[i].L \u0026gt;\u003d m) {\n            right.push_back(requests[i]);\n            std::swap(requests[i], requests.back());\n            requests.pop_back();\n        } else {\n            ++i;\n        }\n\n    requests.shrink_to_fit();\n    solve(requests, l, m);\n    solve(right, m, r);\n}\n\nint main() {\n    size_t n, m, q;\n    scanf(\u0026quot;%d %d %d\u0026quot;, \u0026amp;n, \u0026amp;m, \u0026amp;q);\n\n    assert(n \u0026lt;\u003d MAXN);\n    assert(q \u0026lt;\u003d MAXQ);\n    assert(m \u0026lt;\u003d MAXM);\n    \n    std::fill(answers, answers + q, 16);\n    \n    for (size_t i \u003d 0; i !\u003d m; ++i) {\n        scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;list[i].v, \u0026amp;list[i].u);\n        --list[i].v, --list[i].u;\n        list[i].prev1 \u003d list[i].prev2 \u003d list[i].next1 \u003d list[i].next2 \u003d std::numeric_limits\u0026lt;size_t\u0026gt;::max();\n        \n        if (not last[list[i].v].empty()) {\n            list[i].prev1 \u003d last[list[i].v].back();\n            \n            if (list[last[list[i].v].back()].v \u003d\u003d list[i].v)\n                list[last[list[i].v].back()].next1 \u003d i;\n            else {\n                list[last[list[i].v].back()].next2 \u003d i;\n            }\n        }\n\n        if (not last[list[i].u].empty()) {\n            list[i].prev2 \u003d last[list[i].u].back();\n            \n            if (list[last[list[i].u].back()].v \u003d\u003d list[i].u)\n                list[last[list[i].u].back()].next1 \u003d i;\n            else {\n                list[last[list[i].u].back()].next2 \u003d i;\n            }\n        }\n        \n        last[list[i].v].push_back(i);\n        last[list[i].u].push_back(i);\n    }\n\n    vector\u0026lt;Req\u0026gt; requests;\n    for (size_t i \u003d 0; i !\u003d q; ++i) {\n        Req req;\n        scanf(\u0026quot;%d %d %d %d\u0026quot;, \u0026amp;req.L, \u0026amp;req.R, \u0026amp;req.S, \u0026amp;req.T);\n        --req.L, --req.R, --req.S, --req.T;\n        req.ID \u003d i;\n        \n        auto it1 \u003d std::lower_bound(last[req.S].begin(), last[req.S].end(), req.L);\n        auto it2 \u003d std::upper_bound(last[req.T].begin(), last[req.T].end(), req.R);\n\n        if (it1 \u003d\u003d last[req.S].end() or it2 \u003d\u003d last[req.T].begin())\n            answers[i] \u003d false;\n        else {\n            req.L \u003d *it1;\n            req.R \u003d *std::prev(it2);\n            if (req.L \u0026gt; req.R)\n                answers[i] \u003d false;\n            else\n                requests.push_back(req);\n        }\n    }\n    \n    solve(requests, 0, m);\n\n    for (size_t i \u003d 0; i !\u003d q; ++i) {\n        printf(\u0026quot;%s\u0026quot;, (answers[i] ? \u0026quot;Yes\\n\u0026quot; : \u0026quot;No\\n\u0026quot;));\n    }\n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}