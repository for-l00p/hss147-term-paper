{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1497569884,"rating":0,"authorHandle":"SAeed","modificationTimeSeconds":1497569884,"id":52641,"title":"\u003cp\u003eSPU Contest #7\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e \u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214128/problem/Blue\"\u003eBlue — Famil Door and Brackets\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eDP\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eFirst, let\u0027s calculate the following for string \u003ccode\u003es\u003c/code\u003e:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003ecloseInS\u003c/code\u003e denoting the number of closing brackets in \u003ccode\u003es\u003c/code\u003e that doesn\u0027t match to an opening bracket before them.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003eopenInS\u003c/code\u003e denoting the number of opening brackets in \u003ccode\u003es\u003c/code\u003e that doesn\u0027t match to a closing bracket after them.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eIf string \u003ccode\u003es\u003c/code\u003e is going to be in the middle between string \u003ccode\u003ep\u003c/code\u003e, and string \u003ccode\u003eq\u003c/code\u003e, then the following must hold:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003ep\u003c/code\u003e must contain at least \u003ccode\u003ecloseInS\u003c/code\u003e opening brackets (because \u003ccode\u003es\u003c/code\u003e will close \u003ccode\u003ecloseInS\u003c/code\u003e closing brackets, and we need to have a matching opening brackets for all of them).\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003eq\u003c/code\u003e must must contain at least \u003ccode\u003eopenInS\u003c/code\u003e closing brackets (because \u003ccode\u003es\u003c/code\u003e opened \u003ccode\u003eopenInS\u003c/code\u003e opening brackets, and we need to have a matching closing brackets for all of them).\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eLet\u0027s create the following DP array: \u003cstrong\u003eDP[\u003c/strong\u003e current index \u003cstrong\u003e][\u003c/strong\u003e opened brackets so far \u003cstrong\u003e][\u003c/strong\u003e side \u003cstrong\u003e]\u003c/strong\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003eside\u003c/code\u003e equals to zero if we are still at the part before \u003ccode\u003es\u003c/code\u003e (if we are still forming \u003ccode\u003ep\u003c/code\u003e).\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003eside\u003c/code\u003e equals to one if we are at the part after \u003ccode\u003es\u003c/code\u003e (if we are forming \u003ccode\u003eq\u003c/code\u003e).\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eHow about our moves inside DP function?\u003c/p\u003e\u003cp\u003eIf we are forming \u003ccode\u003ep\u003c/code\u003e:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eIf the current index is smaller than \u003ccode\u003en\u003c/code\u003e we can always try opening a bracket.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf the current index is smaller than \u003ccode\u003en\u003c/code\u003e and we have at least one opening bracket, we can try closing a bracket.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf we have opening brackets that are at least equal to \u003ccode\u003ecloseInS\u003c/code\u003e we can finish forming \u003ccode\u003ep\u003c/code\u003e and move to forming \u003ccode\u003eq\u003c/code\u003e. In order to make this move we also have to check if the remaining places are smaller than the new opened brackets. In other words, if we have 5 places left, and we have 10 brackets opened, then we definitely won\u0027t reach an answer.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eIf we are forming \u003ccode\u003eq\u003c/code\u003e:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eWe can always try opening a new bracket.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf we have at least one opening bracket, we can try closing a bracket.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eIf we reached our last index, and we were forming \u003ccode\u003eq\u003c/code\u003e then:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eIf \u003ccode\u003eopen \u003d\u003d 0\u003c/code\u003e then we formed a valid string, and must return \u003ccode\u003e1\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf \u003ccode\u003eopen !\u003d 0\u003c/code\u003e then we formed a bad string (because some of the opening brackets are not closed), and we must return \u003ccode\u003e0\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n x n x 2)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits\\stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long         ll;\n\nll MOD \u003d 1e9 + 7;\nint n, m;\nint closeInS \u003d 0, openInS \u003d 0;\nll memo[2010][2010][2];\nll dp(int i, int opened, int side){\n\tif (i \u003d\u003d n - m \u0026amp;\u0026amp; side \u003d\u003d 1) return (opened \u003d\u003d 0);\n\n\tll \u0026amp;ret \u003d memo[i][opened][side];\n\tif (ret !\u003d -1) return ret;\n\n\tret \u003d 0;\n\tif (side \u003d\u003d 0){\n\t\tif(i \u0026lt; n - m) ret +\u003d dp(i + 1, opened + 1, 0); // put \u0026quot;(\u0026quot; and stay on this side\n\t\tif(i \u0026lt; n - m \u0026amp;\u0026amp; opened \u0026gt; 0) ret +\u003d dp(i + 1, opened - 1, 0); // put \u0026quot;)\u0026quot; and stay on this side\n\t\tif (opened \u0026gt;\u003d closeInS \u0026amp;\u0026amp; opened - closeInS + openInS \u0026lt;\u003d n - m - i) ret +\u003d dp(i, opened - closeInS + openInS, 1); // move to the other side\n\t\tret %\u003d MOD;\n\t}\n\telse{\n\t\tret +\u003d dp(i + 1, opened + 1, 1);\n\t\tif(opened \u0026gt; 0) ret +\u003d dp(i + 1, opened - 1, 1);\n\t\tret %\u003d MOD;\n\t}\n\treturn ret;\n}\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tstring s; cin \u0026gt;\u0026gt; s;\n\tint open \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; m; i++){\n\t\tif (s[i] \u003d\u003d \u0027(\u0027) open++;\n\t\telse{\n\t\t\topen--;\n\t\t\t// if open \u0026lt; 0 this means that the current string needs another \u0026quot;(\u0026quot; before string s for this \u0026quot;)\u0026quot;\n\t\t\t// string p should have this \u0026quot;(\u0026quot;\n\t\t\tif (open \u0026lt; 0) open \u003d 0, closeInS++;\n\t\t}\n\t}\n\t// all the left \u0026quot;(\u0026quot; needs to be closed by string q\n\topenInS \u003d open;\n\n\tmemset(memo, -1, sizeof memo);\n\tcout \u0026lt;\u0026lt; dp(0, 0, 0) \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214128/problem/Green\"\u003eGreen — Mishka and Game\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAdHoc\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eProblem statement it self is a tutorial :D.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits\\stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long         ll;\n\n\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tint n; cin \u0026gt;\u0026gt; n;\n\tint mishka \u003d 0, chris \u003d 0;\n\twhile (n--){\n\t\tint a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\t\tif (a \u0026gt; b) mishka++;\n\t\telse if (a \u0026lt; b) chris++;\n\t}\n\tif (mishka \u0026gt; chris) cout \u0026lt;\u0026lt; \u0026quot;Mishka\u0026quot; \u0026lt;\u0026lt; endl;\n\telse if (chris \u0026gt; mishka) cout \u0026lt;\u0026lt; \u0026quot;Chris\u0026quot; \u0026lt;\u0026lt; endl;\n\telse cout \u0026lt;\u0026lt; \u0026quot;Friendship is magic!^^\u0026quot; \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214128/problem/Purple\"\u003ePurple — Igor and his way to work\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eGraph\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eIf we ran a simple DFS code to check if we can reach the ending cell starting from the starting cell, we will get WA (because we haven\u0027t checked the condition about not turning more than twice).\u003c/p\u003e\u003cp\u003eObviously, we will need to pass the following arguments to our DFS function:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e denoting our current location\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003edirection\u003c/code\u003e denoting our direction (0 for right, 1 for left, 2 for down, 3 for up) (to simplify our code we can create our \u003ccode\u003edx\u003c/code\u003e and \u003ccode\u003edy\u003c/code\u003e array to hold the moves in this order too (right, left, down, up).\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003eturns\u003c/code\u003e denoting the number of turns we\u0027ve made so far.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eIf we created a visited array holding only two dimensions \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e it\u0027s a WA, why is that? because we can reach cell \u003ccode\u003e(x,y)\u003c/code\u003e with \u003ccode\u003eturns \u003d\u003d 2\u003c/code\u003e and fail to reach our destination, but we will mark \u003ccode\u003evis[x][y]\u003d1\u003c/code\u003e. Now, when we reach the cell \u003ccode\u003e(x,y)\u003c/code\u003e without making any turns we will see that \u003ccode\u003evis[x][y]\u003c/code\u003e is true, and stop trying to go further, while we actually might be able to reach our destination because we still have 2 more turns to do.\u003c/p\u003e\u003cp\u003eSo, what is the solution? all we have to do is expand our \u003ccode\u003evis\u003c/code\u003e array a little. We make our array to be a 4 dimensional array, holding \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ey\u003c/code\u003e, \u003ccode\u003edirection\u003c/code\u003e, \u003ccode\u003eturns\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eNow, we will just run a simple DFS code to check if we can reach the goal without making more than 2 turns.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n x m x 4 x 2)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits\\stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long         ll;\n\nint n, m;\nchar G[1010][1010];\nint vis[1010][1010][4][3];\nint ok \u003d 0;\nint dx[4] \u003d { 0, 0, 1, -1 };\nint dy[4] \u003d { 1, -1, 0, 0 };\nint goalX, goalY;\nvoid dfs(int x, int y, int direction, int turns){\n\tvis[x][y][direction][turns] \u003d 1;\n\tif (x \u003d\u003d goalX \u0026amp;\u0026amp; y \u003d\u003d goalY){\n\t\tok \u003d 1;\n\t\treturn;\n\t}\n\tfor (int i \u003d 0; i \u0026lt; 4; i++){\n\t\tint u \u003d x + dx[i];\n\t\tint v \u003d y + dy[i];\n\t\tint newTurns \u003d turns;\n\t\tif (direction !\u003d i) newTurns++;\n\t\tif (newTurns \u0026gt; 2) continue;\n\t\tif (u \u0026lt; 0 || u \u0026gt;\u003d n || v \u0026lt; 0 || v \u0026gt;\u003d m) continue;\n\t\tif (vis[u][v][i][newTurns]) continue;\n\t\tif (G[u][v] \u003d\u003d \u0027*\u0027) continue;\n\t\tdfs(u, v, i, newTurns);\n\t}\n}\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tint startX, startY;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) for (int j \u003d 0; j \u0026lt; m; j++){\n\t\tcin \u0026gt;\u0026gt; G[i][j];\n\t\tif (G[i][j] \u003d\u003d \u0027S\u0027) startX \u003d i, startY \u003d j;\n\t\tif (G[i][j] \u003d\u003d \u0027T\u0027) goalX \u003d i, goalY \u003d j;\n\t}\n\t// when you start from the first cell,\n\t// assume that your previous directions was once up, once down, once left, and once right\n\tdfs(startX, startY, 0, 0);\n\tdfs(startX, startY, 1, 0);\n\tdfs(startX, startY, 2, 0);\n\tdfs(startX, startY, 3, 0);\n\tif (ok) cout \u0026lt;\u0026lt; \u0026quot;YES\u0026quot; \u0026lt;\u0026lt; endl;\n\telse cout \u0026lt;\u0026lt; \u0026quot;NO\u0026quot; \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214128/problem/Red\"\u003eRed — Cells Not Under Attack\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAdHoc\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s keep 2 sets:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003etakenRows\u003c/code\u003e denoting the rows we have placed a rook in.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003etakenColums\u003c/code\u003e denoting the columns we have placed a rook in.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eFirst, let\u0027s see how many cells is the new rook going to delete within its row?\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eIf the given row was given before, then this rook doesn\u0027t delete any new cells within its row.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf the given row was not given before, then this rook deletes \u003ccode\u003en\u003c/code\u003e cells within its row. What is missing? some of those cells have been deleted before. How were they deleted? while we deleted the columns before, each column deleted exactly one cell from the given row. So, the total number of deleted cells withing the given row is \u003ccode\u003en - number of deleted columns (takenColums.size())\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSecond, we will have to do the same about the number of deleted cells within the given column.\u003c/p\u003e\u003cp\u003ePay attention that if the number of deleted cells within the given row is not zero, and the number of deleted cells within the given column is also not zero, then we have deleted the given cell twice, so add one to the cells that are not deleted.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits\\stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long         ll;\n\nset\u0026lt;int\u0026gt; takenRows;\nset\u0026lt;int\u0026gt; takenColums;\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tll n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tll ans \u003d n * n;\n\tfor (int i \u003d 0; i \u0026lt; m; i++){\n\t\tint a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\t\tif (i) cout \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n\n\t\tll deletedCellsOnRow \u003d n - takenColums.size();\n\t\tif (takenRows.count(a)) deletedCellsOnRow \u003d 0; // we deleted this row before\n\n\t\tll deletedCellsOnColum \u003d n - takenRows.size();\n\t\tif (takenColums.count(b)) deletedCellsOnColum \u003d 0; // we deleted this colum before\n\n\t\tans -\u003d deletedCellsOnRow + deletedCellsOnColum;\n\n\t\t// if the row and column are both new, then we calculated the (a, b) cell twice\n\t\tif (deletedCellsOnRow !\u003d 0 \u0026amp;\u0026amp; deletedCellsOnColum !\u003d 0) ans++;\n\n\t\tcout \u0026lt;\u0026lt; ans;\n\t\ttakenRows.insert(a);\n\t\ttakenColums.insert(b);\n\t}\n\tcout \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214128/problem/Yellow\"\u003eYellow — Tennis Tournament\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eImplementation\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eCreate an array named \u003ccode\u003epowerOfTwo\u003c/code\u003e which holds all the powers of two up to million.\u003c/p\u003e\u003cp\u003eNow, just simulate what was happening. Each time get the maximum power of two that is smaller than or equal to the remaining players \u003ccode\u003emaximumPowerOfTwo\u003c/code\u003e. Now, \u003ccode\u003emaximumPowerOfTwo\u003c/code\u003e denotes the number of players who will play matches. each one of these players will get \u003ccode\u003eb\u003c/code\u003e bottles. These players need \u003ccode\u003emaximumPowerOfTwo/2\u003c/code\u003e matches, so there will be exaclty \u003ccode\u003emaximumPowerOfTwo/2\u003c/code\u003e judges, and each of them needs one bottle. Finally, each match will force one player to leave the tournament, so decrease the number of remaining players by \u003ccode\u003emaximumPowerOfTwo/2\u003c/code\u003e. Keep simulating until the number of remaining players is exactly one.\u003c/p\u003e\u003cp\u003eTowels are really easy to compute, they equal \u003ccode\u003enumber of players x p\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n log(20))\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits\\stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long         ll;\n\nll powerOfTwo[20];\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tpowerOfTwo[0] \u003d 1;\n\tfor (int i \u003d 1; i \u0026lt; 20; i++) powerOfTwo[i] \u003d powerOfTwo[i - 1] * 2;\n\n\tll n, b, p; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; b \u0026gt;\u0026gt; p;\n\tll bottles \u003d 0;\n\tll towels \u003d p * n;\n\twhile (n \u0026gt; 1){\n\t\t// maximum power of two that is smaller than or equal to n \u003d upper - 1\n\t\tll maximumPowerOfTwo \u003d *(upper_bound(powerOfTwo, powerOfTwo + 20, n) - 1);\n\t\t// there is maximumPowerOfTwo participants who played matches,\n\t\t// and maximumPowerOfTwo/2 matches played, each match has 1 judge\n\t\tbottles +\u003d b * maximumPowerOfTwo + (maximumPowerOfTwo / 2);\n\t\tn -\u003d maximumPowerOfTwo / 2;\n\t}\n\tcout \u0026lt;\u0026lt; bottles \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; towels \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}