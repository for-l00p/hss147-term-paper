{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1455964740,"rating":407,"authorHandle":"rekt_n00b","modificationTimeSeconds":1474584759,"id":43230,"title":"\u003cp\u003eMo\u0027s Algorithm on Trees [Tutorial]\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eIntroduction\u003c/h2\u003e\u003cp\u003eMo\u0027s Algorithm has become pretty popular in the past few years and is now considered as a pretty standard technique in the world of Competitive Programming. This blog will describe a method to generalize Mo\u0027s algorithm to maintain information about paths between nodes in a tree.\u003c/p\u003e\u003ch2\u003ePrerequisites\u003c/h2\u003e\u003cp\u003eMo\u0027s Algorithm — If you do not know this yet, read this amazing \u003ca href\u003d\"http://blog.anudeep2011.com/mos-algorithm/\"\u003earticle\u003c/a\u003e before continuing with this blog. \u003c/p\u003e\u003cp\u003ePreorder Traversal or DFS Order of the Tree.\u003c/p\u003e\u003ch2\u003eProblem 1 — Handling Subtree Queries\u003c/h2\u003e\u003cp\u003eConsider the following problem. You will be given a rooted Tree \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e nodes where each node is associated with a value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003enode\u003c/i\u003e]\u003c/span\u003e. You need to handle \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e queries, each comprising one integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e. In each query you must report the number of distinct values in the subtree rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e. In other words, if you store all the values in the subtree rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e in a set, what would be the size of this set?\u003c/p\u003e\u003ch3\u003eConstraints\u003c/h3\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003eN\u003c/i\u003e, \u003ci\u003eQ\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003eA\u003c/i\u003e[\u003ci\u003enode\u003c/i\u003e] ≤ 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e\u003c/p\u003e\u003ch3\u003eSolution(s)\u003c/h3\u003e\u003cp\u003eSeems pretty simple, doesn\u0027t it? One easy way to solve this is to flatten the tree into an array by doing a Preorder traversal and then implement Mo\u0027s Algorithm. Maintain a lookup table which maintains the frequency of each value in the current window. By maintaining this, the answer can be updated easily. The complexity of this algorithm would be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f5/cf/f5cfb6d16643eaf727724300cadeb654df0f4ea1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eNote that you can also solve this in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5a/ac/5aacd2b5847ae17c98390cd30574a1fae41e41a7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e by maintaining a set in each node and merging the smaller set into the larger ones. \u003c/p\u003e\u003ch2\u003eProblem 2 — Handling Path Queries\u003c/h2\u003e\u003cp\u003eNow let\u0027s modify Problem 1 a little. Instead of computing the number of distinct values in a subtree, compute the number of distinct values in the unique path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. I recommend you to pause here and try solving the problem for a while. The constraints of this problem are the same as Problem 1.\u003c/p\u003e\u003ch3\u003eThe Issue\u003c/h3\u003e\u003cp\u003eAn important reason why Problem (1) worked beautifully was because the dfs-order traversal made it possible to represent any subtree as a contiguous range in an array. Thus the problem was reduced to \u0026quot;finding number of distinct values in a subarray \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e]\u003c/span\u003e of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[].\u003c/span\u003e Note that it is not possible to do so for path queries, as nodes which are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e distance apart in the tree might be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e distance apart in the flattened tree (represented by Array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[]\u003c/span\u003e). So doing a normal dfs-order would not work out.\u003c/p\u003e\u003ch3\u003eObservation(s)\u003c/h3\u003e\u003cp\u003eLet a node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e children. Let us number them as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e...\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e.\u003c/span\u003e Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e)\u003c/span\u003e denote the subtree rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e.\u003c/span\u003e \u003c/p\u003e\u003cp\u003eLet us assume that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edfs\u003c/i\u003e()\u003c/span\u003e will visit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u0027\u003ci\u003es\u003c/i\u003e\u003c/span\u003e children in the order \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e...\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e.\u003c/span\u003e Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e be any node in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e be any node in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e and let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. Notice that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edfs\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e will be called only after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edfs\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e has been completed and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e has been explored. Thus, before we call \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edfs\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e, we would have entered and exited \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e. We will exploit this seemingly obvious property of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edfs\u003c/i\u003e()\u003c/span\u003e to modify our existing algorithm and try to represent each query as a contiguous range in a flattened array.\u003c/p\u003e\u003ch3\u003eModified DFS-Order\u003c/h3\u003e\u003cp\u003eLet us modify the dfs order as follows. For each node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, maintain the Start and End time of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e)\u003c/span\u003e. Let\u0027s call them \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eST\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eEN\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e)\u003c/span\u003e. The only change you need to make is that you must increment the global timekeeping variable even when you finish traversing some subtree (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eEN\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e)\u003c/span\u003e \u003d ++\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecur\u003c/i\u003e\u003c/span\u003e). In short, we will maintain 2 values for each node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e. One will denote the time when you entered \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e)\u003c/span\u003e and the other would denote the time when you exited \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e).\u003c/span\u003e Consider the tree in the picture. Given below are the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eST\u003c/i\u003e()\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eEN\u003c/i\u003e()\u003c/span\u003e values of the nodes. \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/c9/eb/c9ebd8458f532ea9b05368f894cba9ff0561354f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eST\u003c/i\u003e(1) \u003d 1\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eEN\u003c/i\u003e(1) \u003d 18\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eST\u003c/i\u003e(2) \u003d 2\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eEN\u003c/i\u003e(2) \u003d 11\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eST\u003c/i\u003e(3) \u003d 3\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eEN\u003c/i\u003e(3) \u003d 6\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eST\u003c/i\u003e(4) \u003d 4\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eEN\u003c/i\u003e(4) \u003d 5\u003c/span\u003e \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eST\u003c/i\u003e(5) \u003d 7\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eEN\u003c/i\u003e(5) \u003d 10\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eST\u003c/i\u003e(6) \u003d 8\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eEN\u003c/i\u003e(6) \u003d 9\u003c/span\u003e \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eST\u003c/i\u003e(7) \u003d 12\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eEN\u003c/i\u003e(7) \u003d 17\u003c/span\u003e \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eST\u003c/i\u003e(8) \u003d 13\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eEN\u003c/i\u003e(8) \u003d 14\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eST\u003c/i\u003e(9) \u003d 15\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eEN\u003c/i\u003e(9) \u003d 16\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[] \u003d {1, 2, 3, 4, 4, 3, 5, 6, 6, 5, 2, 7, 8, 8, 9, 9, 7, 1}\u003c/span\u003e\u003c/p\u003e\u003ch2\u003eThe Algorithm\u003c/h2\u003e\u003cp\u003eNow that we\u0027re equipped with the necessary weapons, let\u0027s understand how to process the queries. \u003c/p\u003e\u003cp\u003eLet a query be \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e).\u003c/span\u003e We will try to map each query to a range in the flattened array. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eST\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e) ≤ \u003ci\u003eST\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eST\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e)\u003c/span\u003e denotes visit time of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e.\u003c/span\u003e Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e \u003d \u003ci\u003eLCA\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e denote the lowest common ancestor of nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e.\u003c/span\u003e There are \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e possible cases:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eCase\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e \u003d \u003ci\u003eu\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eIn this case, our query range would be \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eST\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e), \u003ci\u003eST\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e)].\u003c/span\u003e Why will this work?\u003c/p\u003e\u003cp\u003eConsider any node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e that does not lie in the \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e path.\u003cbr /\u003e Notice that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e occurs twice or zero times in our specified query range. \u003cbr /\u003e Therefore, the nodes which occur exactly once in this range are precisely those that are on the \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e path! (Try to convince yourself of why this is true : It\u0027s all because of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edfs\u003c/i\u003e()\u003c/span\u003e properties.)\u003c/p\u003e\u003cp\u003eThis forms the crux of our algorithm. While implementing Mo\u0027s, our add/remove function needs to check the number of times a particular node appears in a range. If it occurs twice (or zero times), then we don\u0027t take it\u0027s value into account! This can be easily implemented while moving the left and right pointers.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eCase\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e ≠ \u003ci\u003eu\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eIn this case, our query range would be \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eEN\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e), \u003ci\u003eST\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e)]\u003c/span\u003e + \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eST\u003c/i\u003e(\u003ci\u003eP\u003c/i\u003e), \u003ci\u003eST\u003c/i\u003e(\u003ci\u003eP\u003c/i\u003e)]\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe same logic as Case 1 applies here as well. The only difference is that we need to consider the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e i.e the LCA separately, as it would not be counted in the query range.\u003c/p\u003e\u003cp\u003eThis same problem is available on \u003ca href\u003d\"http://www.spoj.com/problems/COT2/\"\u003eSPOJ\u003c/a\u003e. \u003c/p\u003e\u003cp\u003eIf you aren\u0027t sure about some elements of this algorithm, take a look at this neat \u003ca href\u003d\"http://ideone.com/6NVoPD\"\u003ecode\u003c/a\u003e. \u003c/p\u003e\u003ch2\u003eConclusion\u003c/h2\u003e\u003cp\u003eWe have effectively managed to reduce problem (2) to number of distinct values in a subarray by doing some careful bookkeeping. Now we can solve the problem in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ca/db/cadb7cdba0d95ad458cd494f74e31d962df59b9c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e This modified DFS order works brilliantly to handle any type path queries and works well with Mo\u0027s algo. We can use a similar approach to solve many types of path query problems. \u003c/p\u003e\u003cp\u003eFor example, consider the question of finding number of inversions in a \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e path in a Tree \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e, where each node has a value associated with it. This can now be solved in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1a/12/1a1240cdd2f8ebef08a0237629921167f1d6a02f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e by using the above technique and maintaining a BIT or Segment Tree.\u003c/p\u003e\u003cp\u003eThis is my first blog and I apologize for any mistakes that I may have made. I would like to thank \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/sidhant\" title\u003d\"Candidate Master sidhant\"\u003esidhant\u003c/a\u003e for helping me understand this technique. \u003c/p\u003e\u003ch2\u003eSample Problems\u003c/h2\u003e\u003cp\u003e1) \u003ca href\u003d\"http://www.spoj.com/problems/COT2/\"\u003eCount on a Tree II\u003c/a\u003e \u003cbr /\u003e 2) \u003ca href\u003d\"//codeforces.com/gym/100962/attachments/download/4255/20152016-petrozavodsk-winter-training-camp-moscow-su-trinity-contest-en.pdf\"\u003eFrank Sinatra — Problem F\u003c/a\u003e \u003cbr /\u003e 3) \u003ca href\u003d\"https://www.codechef.com/ALKH2016/problems/VLB\"\u003eVasya and Little Bear\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThanks a lot for reading!\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://www.animeshf.com/posts/mo-s-algorithm-on-trees\"\u003eOriginal Post\u003c/a\u003e\u003cbr /\u003e \u003ca href\u003d\"//codeforces.com/blog/entry/22060\"\u003eRelated Blog\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}