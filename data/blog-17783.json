{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1431077557,"rating":23,"authorHandle":"ediston","modificationTimeSeconds":1431079963,"id":17783,"title":"\u003cp\u003eExplanation for Problem 543 A\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eIn this problem one of the things that is new(for me) is the fact that number of times you can reach a state i,j only depends on number of ways of reaching this state from the previous programmers and the current pogrammer. In other words, a new programmer can only effect the count for previous counts to reach a stage of dl, bugs. (dl is done lines).\u003c/p\u003e\u003cp\u003eA 2D DP solution will look like this\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint main() {\n    long long dp[501][501];\n    long b, a[500];\n    long long n, m;\n    long long mod;\n    long long ans \u003d 0;\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; b \u0026gt;\u0026gt; mod;\n    for(int i\u003d0; i\u0026lt;\u003d500; i++)\n        for(int j\u003d0; j\u0026lt;\u003d500; j++)\n        /// we initialize that we can never write any line with any error\n            dp[i][j]  \u003d 0;\n    /// we can write 0 line with 0 error only in 1 way.\n    /// if you are doubtful ask yourself in \u0026quot;how many ways I can write no line?\u0026quot;\n    /// answer will be 1 way i.e. do not write the line.\n    dp[0][0] \u003d 1;\n    for(int i\u003d0; i\u0026lt;n; i++) {\n        cin \u0026gt;\u0026gt; a[i];\n        for(int ld\u003d0; ld\u0026lt;m; ld++){  /// ld is lines done or lines written\n            for(int bugs\u003d0; bugs+a[i]\u0026lt;\u003db; bugs++){\n                /// bugs is the count of bugs we can have, we cannot have more than b bugs.\n                /// if stage(ld, bugs) has never been reached before, i.e. dp[ld][bugs] \u003d 0\n                /// this programmer also cannot reach stage(ld+1, bugs+a[i])\n                /// i.e. dp[ld+1][bugs+a[i]] will not change.\n                /// but if some previous programmer has reached this stage i.e.  dp[ld][bugs] \u0026gt;0\n                /// then we can also reach ld+1, bugs+a[i]\n                dp[ld+1][bugs+a[i]] \u003d (dp[ld+1][bugs+a[i]] + dp[ld][bugs])%mod;\n            }\n        }\n    }\n    for(int i\u003d0; i\u0026lt;\u003db; i++) {\n        /// now for each possible stage(m, bugs) add it to answer.\n        /// Note that stage(m, i) means that some how we were able to have written all\n        /// m lines with bugs \u003d i in total.\n        /// so dp[m][0] means m lines were written with no bug in any line. this is only\n        /// possible if atleast one programmer can write a line of code with 0 error and\n        /// if he writes all the lines \u0027m\u0027, then he will never add any error;\n        ans \u003d (ans+dp[m][i])%mod;\n    }\n    cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n    /// Do not understand something? Feel free to send me a message or comment below\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLets look at the solution from editorial\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define forn(i, n) for(int i \u003d 0; i \u0026lt; int(n); i++)\nconst int N \u003d 505;\nint a[N];\n/// as we know that current programmer can only impact count of previous programmer\n/// so basically we can store two instances, we can store previous instance and \n/// then the current instance.\n/// If you do not use two instances, you cannot differ between current and previous instance\n/// more details below\nint z[2][N][N];\nint main() {\n    int n, bl, bugs, md;\n    scanf(\u0026quot;%d %d %d %d\u0026quot;, \u0026amp;n, \u0026amp;bl, \u0026amp;bugs, \u0026amp;md);\n    forn(i, n) \n        scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]);\n    /// we can conclude that we can write 0 line with 0 bugs in 1 way. \n    /// that way is not to write anything.\n    z[0][0][0] \u003d 1;\n    for(int it \u003d 1; it \u0026lt;\u003d n; it++){\n        // i will store which instance are we in\n        // if \u0027it\u0027 is odd then i is 1 else i is 0\n        int i \u003d it \u0026amp; 1;  \n        for(int j \u003d 0; j \u0026lt;\u003d bl; j++) {\n            for(int k \u003d 0; k \u0026lt;\u003d bugs; k++){\n                /// j is the count of lines written and k is the count of bugs                \n                /// first we make current instance value equal to previous instance\n                /// i^1 (xor) will give us 0 if i is 1, otherwise 1 if i is 0. basically\n                /// i^1 gives the same result like (!i), if i can be 0 or 1.\n                z[i][j][k] \u003d z[i ^ 1][j][k];\n                /// now we check that if j \u0026gt; 0 and bugs k is more or equal than \n                /// the bugs(a[it-1]) possible  by current programmer.  \n                /// if k \u0026lt; a[it-1] then k - a[it-1] \u0026lt; 0, which is not possible\n                if (j \u0026gt; 0 \u0026amp;\u0026amp; k \u0026gt;\u003d a[it - 1]){\n                    z[i][j][k] +\u003d z[i][j - 1][k - a[it - 1]];\n                    /// if you are asking yourself but why are we only subtracting\n                    /// this programmers a[i] for the current instance, then think like this\n                    /// if the current programmer changed the count of (j-1, k-a[i]) in the current\n                    /// instance then that new value should be added here else the value from previous\n                    /// instance should be added. This is because we are making \n                    /// current [j-1][k-a[i]] equal to previous [j-1][k-a[i]] \n                    /// at this line: z[i][j][k] \u003d z[i ^ 1][j][k];\n                }\n                /// here we take care of the mod\n                while(z[i][j][k] \u0026gt;\u003d md) \n                    z[i][j][k] -\u003d md;\n            }\n        }\n    }\n    int ans \u003d 0;\n    for(int i \u003d 0; i \u0026lt;\u003d bugs; i++) {\n        /// now we add all the values for the last programmer\u0027s instance\n        /// Note that stage(bl, i) means that some how we were able to have written all\n        /// \u0027bl\u0027 lines with bugs \u003d i in total.\n        /// so [bl][0] means all \u0027bl\u0027 lines were written with no bug in any line. this is only\n        /// possible if atleast one programmer can write a line of code with 0 error and\n        /// if he writes all the lines \u0027bl\u0027, then he will never add any error;\n        /// also we need to add the value of the instance written by the nth (last) programmer\n        ans +\u003d z[n \u0026amp; 1][bl][i];\n        /// taking care of the mod\n        while (ans \u0026gt;\u003d md) ans -\u003d md;\n    }\n    printf(\u0026quot;%d\\n\u0026quot;, ans);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHopefully this will help some one. Also if someone can write a recursive solution that would be great. Sorry for any grammatical mistakes.\u003c/p\u003e\u003cp\u003eThanks Ediston\u003c/p\u003e\u003c/div\u003e","tags":["problem 543a","#dp"]}}