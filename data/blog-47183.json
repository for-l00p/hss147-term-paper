{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1474205091,"rating":67,"authorHandle":"RussianCodeCup","modificationTimeSeconds":1474205520,"id":47183,"title":"\u003cp\u003eRussian Code Cup 2016 — Results and Tutorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi, everyone!\u003c/p\u003e\u003cp\u003eRussian Code Cup 2016 is over, the problems for the Final Round were more difficult than usually, but the participants didn\u0027t give up. The champion is Gennady Korotkevich \u003ca class\u003d\"rated-user user-legendary\" href\u003d\"/profile/tourist\" title\u003d\"Legendary grandmaster tourist\"\u003e\u003cspan class\u003d\"legendary-user-first-letter\"\u003et\u003c/span\u003eourist\u003c/a\u003e, the second place winner is Vladislav Epifanov \u003ca class\u003d\"rated-user user-legendary\" href\u003d\"/profile/vepifanov\" title\u003d\"Legendary grandmaster vepifanov\"\u003e\u003cspan class\u003d\"legendary-user-first-letter\"\u003ev\u003c/span\u003eepifanov\u003c/a\u003e, the third place winner is Nikolay Kalinin \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/KAN\" title\u003d\"International Grandmaster KAN\"\u003eKAN\u003c/a\u003e. Congratulations to the winners, the complete results are at the RCC web site \u003ca href\u003d\"http://russiancodecup.ru\"\u003ehttp://russiancodecup.ru\u003c/a\u003e\u003c/p\u003e\u003cp\u003eBefore proceeding to the tutorial, we would like to thank \u003ca href\u003d\"https://corp.mail.ru/\"\u003eMail.Ru Group\u003c/a\u003e for organizing the tournament and providing the prizes, and the judges from \u003ca href\u003d\"http://www.ifmo.ru\"\u003eITMO University\u003c/a\u003e for problems. Chief judge Andrew Stankevich \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/andrewzta\" title\u003d\"Grandmaster andrewzta\"\u003eandrewzta\u003c/a\u003e, judges Vitaly Aksenov \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Aksenov239\" title\u003d\"Master Aksenov239\"\u003eAksenov239\u003c/a\u003e, Nikolay Budin \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Budalnik\" title\u003d\"International master Budalnik\"\u003eBudalnik\u003c/a\u003e, Dmitry Filippov \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/DimaPhil\" title\u003d\"Candidate Master DimaPhil\"\u003eDimaPhil\u003c/a\u003e, Borys Minaiev \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/qwerty787788\" title\u003d\"Grandmaster qwerty787788\"\u003eqwerty787788\u003c/a\u003e, Ilya Peresadin \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/pva701\" title\u003d\"Candidate Master pva701\"\u003epva701\u003c/a\u003e, Grigory Shovkoplyas \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/GShark\" title\u003d\"Expert GShark\"\u003eGShark\u003c/a\u003e, Artem Vasiliev \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/vartem\" title\u003d\"International Grandmaster vartem\"\u003evartem\u003c/a\u003e, Nikolay Vedernikov \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Niko\" title\u003d\"Master Niko\"\u003eNiko\u003c/a\u003e, Ilya Zban \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/izban\" title\u003d\"Grandmaster izban\"\u003eizban\u003c/a\u003e. \u003c/p\u003e\u003cp\u003eAnd now the short tutorial. To get more details, you can read the programs of the judges solutions, published at the official site \u003ca href\u003d\"http://russiancodecup.ru\"\u003ehttp://russiancodecup.ru\u003c/a\u003e together with the official tests.\u003c/p\u003e\u003cdiv class\u003d\"problem-statement\"\u003e\u003cdiv class\u003d\"header\"\u003e\u003cdiv class\u003d\"title\"\u003eA. Closing ceremony\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp\u003eProbably the easiest way to solve the problem is greedy. Sort people from the first line by increasing of their stamina. Give them tickets in this order, each time using the place which is furthest away from the other line. After that try to assign people from the second line to the remaining seats by sorting people by stamina and seats by the distance.\u003c/p\u003e\u003cp\u003eThe time complexity of your solution must not exceed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003enm\u003c/i\u003e)\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e, however using std::set one can get a solution with complexity of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e \u003ci\u003elog\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e))\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problem-statement\"\u003e\u003cdiv class\u003d\"header\"\u003e\u003cdiv class\u003d\"title\"\u003eB. Cactusophobia\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp\u003eLet us divide the graph to biconnected blocks. Each block is either a bridge, or a cycle. Our goal is to remove one edge from each cycle, so that the number of remaining colors were maximum possible.\u003c/p\u003e\u003cp\u003eLet us build a bipartite graph, one part would be blocks, another one would be colors. For each block put an edge of capacity \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e for each color of an edge in this block (make multiple edges, or bigger capacity if there are several edges of some color). Add two vertices: source and sink, add edges from source to blocks, if the block is a cycle of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e, set its capacity to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e - 1\u003c/span\u003e, if it is a bridge, set its capacity to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Add edges from color vertices to the sink of capacity \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eIt is quite clear that size of the maximum flow in this graph is indeed the answer to the problem.\u003c/p\u003e\u003cp\u003eAs a final note, the judges know the solution that runs in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e and requires no maximum flow algorithms, challenge yourself to come up with it!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problem-statement\"\u003e\u003cdiv class\u003d\"header\"\u003e\u003cdiv class\u003d\"title\"\u003eC. Homework\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp\u003eThe solution is constructive.\u003c/p\u003e\u003cul\u003e \u003cli\u003e First let us use backtracking to find solutions for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e \u0026lt; 5\u003c/span\u003e, it is also better to precalculate all answers, in order not to mess with non-asymptotic optimizations. \u003c/li\u003e\u003cli\u003e Now \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e ≥ 5\u003c/span\u003e. \u003c/li\u003e\u003cli\u003e Let us put asterisks from left to right, one row after another. When adding the new asterisk, we add 4 new L-trominoes, except the first asterisk in a row that adds 1 new L-tromino, and the last asterisk in a row adds 3 new L-trominoes. Let us stop when the number of remaining L-trominoes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is less than 4, or there are less than 5 free squares in the table. \u003c/li\u003e\u003cli\u003e Now there are two cases \u003cul\u003e \u003cli\u003e there is a free row \u003c/li\u003e\u003cli\u003e thee is no free row \u003c/li\u003e\u003c/ul\u003e \u003c/li\u003e\u003cli\u003e If there is a free row, we stopped because \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is now less then 4. So: \u003cul\u003e \u003cli\u003e k \u003d 0: the solution is found \u003c/li\u003e\u003cli\u003e k \u003d 1: if there are already at least \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e asterisks in the current row, put the asterisk in the beginning of the next row, if there is only \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, put it in the end of the current row \u003c/li\u003e\u003cli\u003e k \u003d 2, k \u003d 3 — similar, left as an exercise. \u003c/li\u003e\u003c/ul\u003e \u003c/li\u003e\u003cli\u003e If there are now free rows left, one can see that you can only add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e from the set \u003cspan class\u003d\"tex-span\"\u003e{0, 1, 2, 3, 4, 5, 6, 8, 9, 12, 15}\u003c/span\u003e L-trominoes. \u003c/li\u003e\u003cli\u003e And finally there is also the special case where the size of the board is \u003cspan class\u003d\"tex-span\"\u003e3 × \u003ci\u003em\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e ≥ 5\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d 2 * (\u003ci\u003em\u003c/i\u003e - 1) - 8\u003c/span\u003e — in this case the first column should be left empty, and the rest of the board must be completely filled with asterisks. \u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problem-statement\"\u003e\u003cdiv class\u003d\"header\"\u003e\u003cdiv class\u003d\"title\"\u003eD. Slalom\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp\u003eFirst let us consider all paths from the starting square to the finish one. Let us say that two paths are equivalent, if each obstacle is at the same side for both paths. For each class of equivalence let us choose the representative path — the one that tries to go as low as possible, lexicographically minimum.\u003c/p\u003e\u003cp\u003eLet us use dynamic programming. For each square let us count the number of representative paths that go from the starting square to this one. When the obstacle starts, some paths can now separate. The new representatives will pass this obstacle from above (it will be to the right of them). So we add the sum of values for squares below it, but above any other lower obstacle, to the value for the square right above the obstacle.\u003c/p\u003e\u003cp\u003eTo overcome the time and memory limits that the naive solution with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e)\u003c/span\u003e memory and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e time complexity, we use segment tree for range sum queries with mass update, running scanline and events \u0026quot;start of an obstacle\u0026quot;, \u0026quot;end of an obstacle\u0026quot;. This leads to the solution with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003em\u003c/i\u003e)\u003c/span\u003e memory and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e \u003ci\u003elog\u003c/i\u003e \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e time complexity.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problem-statement\"\u003e\u003cdiv class\u003d\"header\"\u003e\u003cdiv class\u003d\"title\"\u003eE. Cipher\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp\u003eFirst let us consider a slow solution. Let us find a condition for each number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e after what number of seconds Borya can distinguish it from the given number. Let us look at their initial encoding. Increase both numbers by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e until the encodings are different (or one of the numbers needs more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e digits to represent in which case the beep allows Borya to distinguish the numbers as well).\u003c/p\u003e\u003cp\u003eNow there are two main ideas that allow us to get a better solution. First, we don\u0027t have to check all numbers. We only need to check numbers that differ from the given number in exactly one digit.\u003c/p\u003e\u003cp\u003eSecond: to get the time when the numbers can be distinguished we don\u0027t need to iterate over all possible values. We just need to try all digit positions and all values for that position, and check only moments when the digit at the position will first have this value in one of the numbers.\u003c/p\u003e\u003cp\u003eSo the complexity is now polynomial in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≤ 18\u003c/span\u003e, it easily fits into the time limit.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problem-statement\"\u003e\u003cdiv class\u003d\"header\"\u003e\u003cdiv class\u003d\"title\"\u003eF. Array Covering\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp\u003eWe give the outline of the solution, leaving technical details as an excercise.\u003c/p\u003e\u003cp\u003eFirst note that the answer will always use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e - \u003ci\u003en\u003c/i\u003e, 0)\u003c/span\u003e subarrays with maximal sums. Sof let us find the sum of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e - \u003ci\u003en\u003c/i\u003e, 0)\u003c/span\u003e maximal subarrays, elements that are used in them, and the following \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e subarrays. We can do it using binary search for the border sum, and a data structure similar to Fenwick tree. For the given value of the sum this tree must provide the number of subarrays with greater or equal sum, sum of their sums, and the set of the elements of these subarrays. It should also allow to list all these subarrays in linear time complexity. This part has time complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e \u003ci\u003elog\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLet us now describe how to solve the problem in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e \u003ci\u003elog\u003c/i\u003e \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. Let us try all values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e — the number of subarrays with maximum sums that we will use in our solution (there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e variants, because top \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e - \u003ci\u003en\u003c/i\u003e, 0)\u003c/span\u003e subarrays will definitely be used). Let elements with indices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, ..., \u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the ones that are not used in these subarrays. Now we must add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e segments that would contain all of these elements. Note that each of these \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e segments must contain at least one of these elements, and no two segments can have a common element among them (in the other case the solution is not optimal). These observations let us greedily choose these \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e segments in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e \u003ci\u003elog\u003c/i\u003e \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e and the final solution complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e \u003ci\u003elog\u003c/i\u003e \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003eTo optimize this solution, we keep segments [\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e + 1\u003c/span\u003e; \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/sub\u003e - 1\u003c/span\u003e] in the ordered set. When we iterate over \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and increase its value, we remove some of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e-s, and recalculate the required values for the affected segments. After that we must take \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e maximal values from the set, so since there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e changes in total, this part now works in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e \u003ci\u003elog\u003c/i\u003e \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}