{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1439393475,"rating":6,"authorHandle":"MedalPluS","modificationTimeSeconds":1439394917,"id":19742,"title":"\u003cp\u003eCodeforces Round #315 (Div.1) A Solution\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI think it\u0027s a simple task.\u003c/p\u003e\u003cp\u003eLet\u0027s make problem simplely.  pi(n)\u0026lt;\u003dA*rub(n) \u0026lt;\u003d\u0026gt;pi(n)\u0026lt;\u003dp/q*rub(n) \u0026lt;\u003d\u0026gt;pi(n)*q\u0026lt;\u003dp*rub(n) So we don\u0027t need to use \u003cem\u003edouble\u003c/em\u003e\u003c/p\u003e\u003cp\u003eWe know that Max n \u0026lt;\u003d 2e6 So we can prefix n 1 to 2e6 How to get pi\u0026amp;rub? We can use DP.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor(i\u003d2;i*i\u0026lt;\u003dn;i++)//O(n) get prime\n  if(isp[i])\n    for(j\u003di*i;j\u0026lt;\u003dn;j+\u003di)\n      isp[j]\u003dfalse;\npi[0]\u003dpi[1]\u003d0;//both 1 and 0 isn\u0027t prime\nfor(i\u003d2;i\u0026lt;\u003dn;i++)\n  if(isp[i])pi[i]\u003dpi[i-1]+1;//because i is a prime\n  else pi[i]\u003dpi[i-1];\nfor(i\u003d1;i\u0026lt;\u003dn;i++)\n  if(is_palind(i))rub[i]\u003drub[i-1]+1;\n  else rub[i]\u003drub[i-1];\n//How to write _is_palind(i)_?\nbool is_palind(int x){\n  int k\u003d0,tmp\u003dx;\n  while(x){k\u003dk*10+x%10;x/\u003d10;}//rotate x\n  if(k\u003d\u003dx)return true;\n  else return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo the code is O(n)\u003c/p\u003e\u003cp\u003eThanks.\u003c/p\u003e\u003c/div\u003e","tags":[]}}