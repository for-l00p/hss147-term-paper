{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1429639530,"rating":-3,"authorHandle":"light42","modificationTimeSeconds":1429639530,"id":17510,"title":"\u003cp\u003eNeed help for google code jam 2014 round 1A problem A optimization\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eLink to problem \u003ca href\u003d\"https://code.google.com/codejam/contest/2984486/dashboard\"\u003ehere\u003c/a\u003e\u003c/p\u003e\u003cp\u003eMy method for solve this problem is to generate N^2 possible switch combination and from that combination we\u0027ll simply check if there\u0027s optimum solution. I pick this method because it\u0027s the most understandable way in the analysis and some coders use it and get acc. But my code still slow though (didn\u0027t pass 8 minute limit). I try to optimize the code but still too slow :(. Is there any way to optimize my code more?\u003c/p\u003e\u003cp\u003ePS: Sorry if this post is bad. This is the first time I\u0027m posting codes(and sorry if my english is bad). \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;climits\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;set\u0026gt;\n\nusing namespace std;\n\n#define LOOP(i,n) for(int i \u003d 0; i \u0026lt; n; i++)\n\nint T,N,Leng;\nstring outlet[200];\nstring devices[200];\nint main()\n{\n\tcin \u0026gt;\u0026gt; T;\n\tLOOP(i,T)\n\t{\n\t\tset\u0026lt;pair\u0026lt;string,int\u0026gt; \u0026gt; flipSwitch;\n\t\tset\u0026lt;string\u0026gt; dv;\n\t\tstring dummy;\n\t\tint best \u003d INT_MAX;\n\t\tcin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; Leng;\n\t\t\n\t\tLOOP(j,N)\n\t\t{\n\t\t\tcin \u0026gt;\u0026gt; outlet[j];\n\t\t}\n\t\t\n\t\tLOOP(j,N)\n\t\t{\n\t\t\tcin \u0026gt;\u0026gt; devices[j];\n\t\t\tdv.insert(devices[j]);\n\t\t}\n\n\t\tLOOP(j,N)\n\t\t{\n\t\t\tLOOP(k,N)\n\t\t\t{\n\t\t\t\tstring curr \u003d \u0026quot;\u0026quot;;\n\t\t\t\tint change \u003d 0;\n\t\t\t\tLOOP(l,Leng)\n\t\t\t\t{\n\t\t\t\t\tif(outlet[j][l] \u003d\u003d devices[k][l])curr +\u003d \u00270\u0027;\n\t\t\t\t\telse{curr +\u003d \u00271\u0027;change++;}\n\t\t\t\t}\n\t\t\t\tflipSwitch.insert(make_pair(curr, change));\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(set\u0026lt;pair\u0026lt;string,int\u0026gt; \u0026gt;::iterator it \u003d flipSwitch.begin(); it !\u003d flipSwitch.end(); it++)\n\t\t{\n\t\t\tstring flipIt \u003d (*it).first;\n\t\t\tset\u0026lt;string\u0026gt; ot;\n\t\t\tLOOP(j,N)\n\t\t\t{\n\t\t\t\tstring x \u003d \u0026quot;\u0026quot;;\n\t\t\t\tLOOP(k,Leng)\n\t\t\t\t{\n\t\t\t\t\tif(flipIt[k] \u003d\u003d \u00270\u0027) x +\u003d outlet[j][k];\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(outlet[j][k] \u003d\u003d \u00271\u0027)x +\u003d \u00270\u0027;\n\t\t\t\t\t\telse x +\u003d \u00271\u0027;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tot.insert(x);\n\t\t\t}\n\t\t\tif(ot \u003d\u003d dv)best \u003d min(best,(*it).second);\n\t\t}\n\n\t\tprintf(\u0026quot;Case #%d: \u0026quot;,i+1);\n\t\tif(best \u003d\u003d INT_MAX)printf(\u0026quot;Not Possible\\n\u0026quot;);\n\t\telse printf(\u0026quot;%d\\n\u0026quot;,best);\n\t}\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["gcj 2014"]}}