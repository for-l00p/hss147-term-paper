{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1494706360,"rating":48,"authorHandle":"LiChenKoh","modificationTimeSeconds":1494711623,"id":51975,"title":"\u003cp\u003eGoogle Code Jam C++ Parallelization Template (Linux)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eAfter a long and arduous search, I was not able to find a Google Code Jam template that fulfilled the following properties:\u003cbr /\u003e1. Written in C++\u003cbr /\u003e2. Parallelizes test cases\u003cbr /\u003e3. Executes each test case in a separate process so I don\u0027t have to re-initialize global variables after each test case. \u003c/p\u003e\u003cp\u003eI decided to write my own template below. \u003c/p\u003e\u003cp\u003eThe boilerplate template code below solves the following sample problem:\u003cbr /\u003eYou are given the number of test cases T\u003cbr /\u003eYou are given an integer n, followed by n integers a_i.\u003cbr /\u003ePlease output the sum of the n integers as \u0026quot;Case #TEST_CASE_NUMBER: SUM\u0026quot;. \u003c/p\u003e\u003cp\u003eInstructions:\u003cbr /\u003eStep 1: Write code to parse one test case in readOneTestCase().\u003cbr /\u003eStep 2: Write your code in solve().\u003cbr /\u003eStep 3: Compile and run with no arguments. Pass test data into stdin. Results are passed to stdout.\u003cbr /\u003eStep 4: If you want to debug test case X, run the executable with X as its only argument, where X is some positive integer.\u003cbr /\u003eTo modify the input test case, look for testcaseinX.\u003cbr /\u003eStep 5: If you modify the original test file, be sure to run the executable with no arguments to regenerate the partitioned input files. \u003c/p\u003e\u003cp\u003eHow does this work?\u003cbr /\u003eWhen you run ./executable, it reads and parses all test cases from stdin, and writes each test case into an individual input file specific to that test case.\u003cbr /\u003eThen ./executable spawns various new processes with the command line \u0026quot;./executable X\u0026quot;, where X is the test case number to run.\u003cbr /\u003e\u0026quot;./executable X\u0026quot; reads an individual test case, and writes the solution to a file dedicated to that test case.\u003cbr /\u003eAfter the child processses have finished execution, then the main parent process will reads all the solutions from the files written\u003cbr /\u003eby the child processes, and print them out in order. \u003c/p\u003e\u003cp\u003eNote 1: Your code does not have to clear global state for each test case. Each test case is run in a brand new process.\u003cbr /\u003eNote 2: I\u0027ve only tested this code under Linux. It most probably works on Mac too, once you\u0027ve replaced \u0026quot;bits/stdc++.h\u0026quot; with the standard headers. For Windows, you probably have to replace the fork() and system() pattern with CreateProcess.\u003cbr /\u003eNote 3: Please suggest improvements and help report bugs/races in the code! I randomly cobbled this code together from Stackoverflow and the template generated by the TesterDream Topcoder plugin. This was done mostly in a fit of blind rage after today\u0027s round, where I failed to clear global state properly after each test case, so I cannot attest to the quality of this code. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;assert.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n#include \u0026lt;sys/wait.h\u0026gt;\nextern char **environ;\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define PB push_back\n#define MP make_pair\n#define MOD 1000000007LL\n#define endl \u0026quot;\\n\u0026quot;\n#define fst first\n#define snd second\nconst ll UNDEF \u003d -1;\nconst ll INF\u003d1LL\u0026lt;\u0026lt;61;\ntemplate\u0026lt;typename T\u0026gt; inline bool chkmax(T \u0026amp;aa, T bb) { return aa \u0026lt; bb ? aa \u003d bb, true : false; }\ntemplate\u0026lt;typename T\u0026gt; inline bool chkmin(T \u0026amp;aa, T bb) { return aa \u0026gt; bb ? aa \u003d bb, true : false; }\ntypedef pair\u0026lt;ll,ll\u0026gt; pll;\ntypedef vector\u0026lt;ll\u0026gt; vll;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef pair\u0026lt;int,int\u0026gt; pii;\nstring STDOUT_RESERVED \u003d \u0026quot;STDOUT_RESERVED\u0026quot;;\n/*\nThis solves the following problem:\nYou are given the number of test cases T\nYou are given an integer n, followed by n integers a_i.\nPlease output the sum of the n integers as \u0026quot;Case #TEST_CASE_NUMBER: SUM\\n\u0026quot;.\n\nInstructions:\nStep 1: Write code to parse one test case in readOneTestCase().\nStep 2: Write your code in solve().\nStep 3: Compile and run with no arguments. Pass test data into stdin. Results are passed to stdout.\nStep 4: If you want to debug test case X, run the executable with X as its only argument, where X is some positive integer.\nTo modify the input test case, look for testcaseinX.\nStep 5: If you modify the original test file, be sure to run the executable with no arguments to regenerate the partitioned input files.\n\nNotes: Your code does not have to clear global state for each test case. Each test case is run in a brand new process.\n\nHow does this work?\nLet ./executable be the name of this executable.\nWhen you run ./executable, it reads and parses all test cases from stdin, and writes each test case into an individual input file.\nThen ./executable spawns various new processes with the command line \u0026quot;./executable X\u0026quot;, where X is the test case number to run.\n\u0026quot;./executable X\u0026quot; reads an individual test case, and writes the solution to a file dedicated to that test case.\nAfter the child processses have finished execution, then the main parent process will reads all the solutions from the files written\nby the child processes, and print them out in order.\n*/\n\nint solve(string testcasein, string testcaseout, int testnum)\n{\n\t/*\n\tTO THE USER: You must modify this code!\n\tSolve a test case from the file named testcasein, and writes answer to the file named testcaseout.\n\tTo make debugging easier, if testcaseout is STDOUT_RESERVED, you want to write the answer to stdout.\n\t*/\n\tstd::ifstream ifs(testcasein.c_str(),std::ifstream::in);\n\tFILE *fout;\n\t// Make debugging individual test case easier: Pipe answers to stdout\n\tif (testcaseout\u003d\u003dSTDOUT_RESERVED) fout \u003d stdout;\n\telse fout\u003dfopen(testcaseout.c_str(),\u0026quot;wb\u0026quot;);\n\tassert(fout!\u003dNULL);\n\tll n; ifs\u0026gt;\u0026gt;n;\n\tll sum\u003d0;\n\tfor (int i\u003d0;i\u0026lt;n;i++) {ll x; ifs\u0026gt;\u0026gt;x; sum+\u003dx;}\n\tfprintf(fout, \u0026quot;Case #%d: %lld\\n\u0026quot;,testnum,sum);\n}\n\nvoid readOneTestCase(string testcaseout) {\n\t/*\n\tTO THE USER: You must modify this code!\n\tRead one test case, and output to a file named testcaseout\n\t*/\n\tll n;\n\tcin\u0026gt;\u0026gt;n;\n\tvector\u0026lt;ll\u0026gt; tmp;\n\tfor (int i\u003d0;i\u0026lt;n;i++) {ll x; cin\u0026gt;\u0026gt;x; tmp.PB(x);}\n\tFILE *fp \u003d fopen(testcaseout.c_str(),\u0026quot;wb\u0026quot;);\n\tfprintf(fp, \u0026quot;%lld\\n\u0026quot;,n);\n\tfor (auto \u0026amp;w:tmp) {\n\t\tfprintf(fp, \u0026quot;%lld \u0026quot;,w);\n\t}\n\tfprintf(fp, \u0026quot;\\n\u0026quot;);\n\tfclose(fp);\n\t/* End custom code! */\n}\n\nconst int MAX_NUM_PROCESSES \u003d 4;\n\nstring getinputfilename(int testnum) {\n\tostringstream testcasein; testcasein\u0026lt;\u0026lt;\u0026quot;testcasein\u0026quot;\u0026lt;\u0026lt;testnum;\n\treturn testcasein.str();\n}\nstring getoutputfilename(int testnum) {\n\tostringstream testcaseout; testcaseout\u0026lt;\u0026lt;\u0026quot;testcaseout\u0026quot;\u0026lt;\u0026lt;testnum;\n\treturn testcaseout.str();\n}\n\nvoid wait_for_running_children_to_be_under_limit(set\u0026lt;pid_t\u0026gt; \u0026amp;running_child_pids, int limit) {\n\twhile(running_child_pids.size() \u0026gt; limit) {\n\t\tfor (auto \u0026amp;ChildPID:running_child_pids) {\n\t\t\tint status;\n\t\t\tpid_t result \u003d waitpid(ChildPID, \u0026amp;status, WNOHANG);\n\t\t\tif (result \u003d\u003d 0) {\n\t\t\t  // Child still alive\n\t\t\t} else if (result \u003d\u003d -1) {\n\t\t\t  // Error \n\t\t\t  cerr\u0026lt;\u0026lt;\u0026quot;waitpid error\u0026quot;\u0026lt;\u0026lt;endl; assert(0);\n\t\t\t} else {\n\t\t\t  // Child exited\n\t\t\t  if (status!\u003d0) {\n\t\t\t  \tcerr\u0026lt;\u0026lt;\u0026quot;Child returned nonzero status.\u0026quot;\u0026lt;\u0026lt;endl; assert(0);\n\t\t\t  }\n\t\t\t  running_child_pids.erase(ChildPID);\n\t\t\t}\n\t\t}\n\t}\t\n}\n\nint main(int argc, char* argv[])\n{\n\t/*\n\tIf no arguments are passed, then please pass full data set into stdin\n\tIf one argument is passed, that argument should be the test case number. It will read from getinputfilename(testnum)\n\tand write to getoutputfilename(testnum). Usually, you first run this with no arguments to populate all the input files,\n\tthen you pass in the test case number as the argument to debug this particular test case.\n\t*/\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tset\u0026lt;pid_t\u0026gt; running_child_pids;\n\tif (argc \u003d\u003d 1)\n\t{\n\t\tint number_of_test_cases; cin\u0026gt;\u0026gt;number_of_test_cases;\n\t\tfor (int testnum\u003d1;testnum\u0026lt;\u003dnumber_of_test_cases;testnum++) {\n\t\t\treadOneTestCase(getinputfilename(testnum));\n\n\t\t\t// Execute child process with test case number as its only argument, plus one additional dummy argument\n\t\t\tostringstream childCommandLine; childCommandLine \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; testnum \u0026lt;\u0026lt; \u0026quot; 0\u0026quot;;\n\t\t\tpid_t pid\u003dfork();\n\t\t\trunning_child_pids.insert(pid);\n\t\t\tint exitCode,status;\n\t\t\tswitch(pid) {\n\t\t\t\tcase -1:\n\t\t\t\t\tcerr\u0026lt;\u0026lt;\u0026quot;Fork failed\u0026quot;\u0026lt;\u0026lt;endl; assert(0);\n\t\t\t\t\treturn 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0:\n\t\t\t\t\t/*\n\t\t\t\t\tStart a new process by running this executable with the test case number as an argument.\n\t\t\t\t\t*/\n\t\t\t\t\texitCode \u003d system(childCommandLine.str().c_str());\n\t\t\t\t\tif (exitCode!\u003d0) {\n\t\t\t\t\t\tcerr\u0026lt;\u0026lt;\u0026quot;Runtime error\u0026quot;\u0026lt;\u0026lt;endl;\n\t\t\t\t\t\tassert(0);\n\t\t\t\t\t}\n\t\t\t\t\tassert(exitCode\u003d\u003d0);\n\t\t\t\t\treturn 0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// Parent process. Continue execution below.\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\twait_for_running_children_to_be_under_limit(running_child_pids, MAX_NUM_PROCESSES);\n\t\t}\n\t\t// Wait for processes to finish executing\n\t\twait_for_running_children_to_be_under_limit(running_child_pids, 0);\n\n\t\tfor (int testnum\u003d1;testnum\u0026lt;\u003dnumber_of_test_cases;testnum++) {\n\t\t\tstd::ifstream ifs(getoutputfilename(testnum).c_str(),std::ifstream::in);\n\t\t\tstring str;\n\t\t\twhile(getline(ifs,str)) {\n\t\t\t\tif (ifs.bad()) {cerr\u0026lt;\u0026lt;\u0026quot;ifs bad\u0026quot;\u0026lt;\u0026lt;endl; assert(0);}\n\t\t\t\tcout\u0026lt;\u0026lt;str\u0026lt;\u0026lt;endl;\n\t\t\t\tif (ifs.eof()) break;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tint testnum; istringstream(argv[1]) \u0026gt;\u0026gt; testnum;\n\t\tostringstream testcasein; testcasein\u0026lt;\u0026lt;\u0026quot;testcasein\u0026quot;\u0026lt;\u0026lt;testnum;\n\t\tostringstream testcaseout; testcaseout\u0026lt;\u0026lt;\u0026quot;testcaseout\u0026quot;\u0026lt;\u0026lt;testnum;\n\t\t// If only testnum is passed, then print results to stdout for debugging.\n\t\tif (argc\u003d\u003d2) solve(getinputfilename(testnum), STDOUT_RESERVED, testnum);\n\t\telse solve(getinputfilename(testnum),getoutputfilename(testnum), testnum);\n\t}\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}