{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1456321543,"rating":-26,"authorHandle":"qzqzgfy","modificationTimeSeconds":1456322052,"id":43329,"title":"\u003cp\u003eCodeforces Round #340 (Div. 2) E. XOR and Favorite Number (617E)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cpre\u003eE. XOR and Favorite Number\n                                       617E\n                            time limit per test4 seconds\n                        memory limit per test256 megabytes\n                                inputstandard input\n                                outputstandard output\u003c/pre\u003e\u003cp\u003eBob has a favorite number k and ai of length n. Now he asks you to answer m queries. Each query is given by a pair li and ri and asks you to count the number of pairs of integers i and j, such that l ≤ i ≤ j ≤ r and the xor of the numbers ai, ai + 1, ..., aj is equal to k.\u003c/p\u003e\u003cp\u003eInput  The first line of the input contains integers n, m and k (1 ≤ n, m ≤ 100 000, 0 ≤ k ≤ 1 000 000) — the length of the array, the number of queries and Bob\u0027s favorite number respectively.\u003c/p\u003e\u003cp\u003eThe second line contains n integers ai (0 ≤ ai ≤ 1 000 000) — Bob\u0027s array.\u003c/p\u003e\u003cp\u003eThen m lines follow. The i-th line contains integers li and ri (1 ≤ li ≤ ri ≤ n) — the parameters of the i-th query.\u003c/p\u003e\u003cp\u003eOutput Print m lines, answer the queries in the order they appear in the input.\u003c/p\u003e\u003cp\u003eSample test(s) input 6 2 3 1 2 1 1 0 3 1 6 3 5 output 7 0 input 5 3 1 1 1 1 1 1 1 5 2 4 1 3 output 9 4 4\u003c/p\u003e\u003cp\u003e。。好题，我一开始觉得一定是按分块分的可持久化字典树，具体做法呢就是先利用莫队算法，然后将区间内的所有a[i]都加入字典树，然后对于每个节点我们都有对应能异或得k的所有对应节点，然后我们边修改l和r边修改ans。 然后因为位数在20左右，所以非常完美，不会爆炸。\u003c/p\u003e\u003cp\u003e以上都是yy，其实这题只要用一个sum【i】数组存一个前缀异或和，sum[r]^sum[l-1]就是a[l]到a[r]的异或和了，这样我们每加入一个sum[i]都有对应的op[sum[i]]，这样我们再记录一个cnt[i]代表目前a[j]值为i的j的个数 这样ans就能+\u003dcnt[i]*cnt[op[i]]，此外，如果k\u003d0，那么便有l\u003dr的情况出现，然而k\u003d0我们只需要特殊处理即可，此题还需要注意longlong，反正我把全部int改成long long了。 代码：\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstdio\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n#include\u0026lt;cmath\u0026gt;\n#include\u0026lt;string\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n#define ll long long\nstruct wow{\n\tll id,ans,l,r;\n}ans[1000005];\nll l,r,mx,a[1000005],block,n,m,k,now,cnt[2000005],sum[1000005],op[2000005],pos[1000005];\nbool cmp1(wow q,wow w){\n\tif (pos[q.l]\u003d\u003dpos[w.l]) return q.r\u0026lt;w.r;\n\treturn pos[q.l]\u0026lt;pos[w.l];\n}\nbool cmp2(wow q,wow w){\n\treturn q.id\u0026lt;w.id;\n}\nvoid updata(ll x,ll v){\n\tif (k!\u003d0)\n\tnow-\u003dcnt[sum[x]]*cnt[op[sum[x]]];\n\telse\n\tnow-\u003d((cnt[sum[x]]-1)*(cnt[sum[x]]))/2;\n\tcnt[sum[x]]+\u003dv;\n\tif (k!\u003d0)\n\tnow+\u003dcnt[sum[x]]*cnt[op[sum[x]]];\n\telse\n\tnow+\u003d((cnt[sum[x]]-1)*(cnt[sum[x]]))/2;\n}\nint main(){\n\t//freopen(\u0026quot;tx.in\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n\tscanf(\u0026quot;%I64d%I64d%I64d\u0026quot;,\u0026amp;n,\u0026amp;m,\u0026amp;k);\n\tblock\u003dsqrt(n);\n\tfor (int i\u003d1;i\u0026lt;\u003dn;i++)\n\t pos[i]\u003di/block;\n\tfor (int i\u003d1;i\u0026lt;\u003dn;i++)\n\t scanf(\u0026quot;%I64d\u0026quot;,\u0026amp;a[i]);\n\tfor (int i\u003d1;i\u0026lt;\u003dn;i++) \n\t sum[i]\u003dsum[i-1]^a[i],mx\u003dstd::max(mx,sum[i]);\n\tfor (int i\u003d0;i\u0026lt;\u003dmx;i++)\n\t op[i]\u003di^k;\n\tfor (int i\u003d1;i\u0026lt;\u003dm;i++){\n\t\tscanf(\u0026quot;%I64d%I64d\u0026quot;,\u0026amp;ans[i].l,\u0026amp;ans[i].r);\n\t\tans[i].l--;\n\t\tans[i].id\u003di;\n\t\tans[i].ans\u003d0;\n\t}  \n\tstd::sort(ans+1,ans+1+m,cmp1);\n    l\u003dans[1].l;r\u003dans[1].l;cnt[sum[l]]++;now\u003d0;\n    for (int i\u003d1;i\u0026lt;\u003dm;i++){\n    \tif (l\u0026lt;ans[i].l){\n    \t\tfor (int j\u003dl;j\u0026lt;ans[i].l;j++)\n    \t\t updata(j,-1);\n    \t}\n    \telse\n    \tif (l\u0026gt;ans[i].l){\n    \t\tfor (int j\u003dl-1;j\u0026gt;\u003dans[i].l;j--)\n    \t\t updata(j,1);\n    \t}\n    \tl\u003dans[i].l;\n    \tif (r\u0026lt;ans[i].r){\n    \t\tfor (int j\u003dr+1;j\u0026lt;\u003dans[i].r;j++)\n    \t\t updata(j,1);\n    \t}\n    \telse\n    \tif (r\u0026gt;ans[i].r){\n    \t\tfor (int j\u003dr;j\u0026gt;ans[i].r;j--)\n    \t\t updata(j,-1);\n    \t}\n    \tr\u003dans[i].r;\n\t\tans[i].ans\u003dnow;    \n    }\n    std::sort(ans+1,ans+1+m,cmp2);\n    for (int i\u003d1;i\u0026lt;\u003dm;i++)\n     printf(\u0026quot;%I64d\\n\u0026quot;,ans[i].ans);\n} \n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["莫队算法","水题"]}}