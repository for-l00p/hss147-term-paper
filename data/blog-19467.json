{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1438035906,"rating":6,"authorHandle":"zackblick","modificationTimeSeconds":1438035906,"id":19467,"title":"\u003cp\u003eTries Implementation.\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eCan anyone provide me with an efficient non-recursive C++implementation of Trie? I have coded it myself to an extent, but I am not able to code the \u003ccode\u003esearch\u003c/code\u003e function for regular expression matching., i.e, if my trie has the word \u0026quot;zackblick\u0026quot;, then searching \u0026quot;zackblick\u0026quot;,\u0026quot; *blick \u0026quot;, \u0026quot;za*blick\u0026quot; etc, all should return true.\u003c/p\u003e\u003cp\u003eP.S- If anyone has their own implementation of Trie, please share. I would love to have a look. :) \u003c/p\u003e\u003cp\u003eMy version-\u003c/p\u003e \u003cpre\u003e\u003ccode\u003econst int MaxN \u003d 500500;\nint sz \u003d 0;\nint next1[30][MaxN];\nint end[MaxN];\nbool created[MaxN];\n\u003c/code\u003e\u003c/pre\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e    void addWord(string s) {\n        int v \u003d 0;\n \n\tfor (int i \u003d 0; i \u0026lt; s.size(); ++i) {\n\t\tint c \u003d s[i] - \u0027a\u0027;\n\t\tif (!created[next1[c][v]]) {\n\t\t\tnext1[c][v] \u003d ++sz;\n\t\t\tcreated[sz] \u003d true;\n\t\t}\n\t\tv \u003d next1[c][v];\n\t}\n        \n    }\n\n    bool search(string tmp) {\n        \n        int v \u003d 0;\n    int l\u003dtmp.size();\n\tfor (int i \u003d 0; i \u0026lt; tmp.size(); ++i) {\n\t\tint c \u003d tmp[i] - \u0027a\u0027;\n\t\telse\n\t\t{if (!created[next1[c][v]])\n\t\t\treturn false;\n\t\tv \u003d next1[c][v];}\n\t}\n\treturn true;\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}