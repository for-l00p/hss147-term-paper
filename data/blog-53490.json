{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1501077716,"rating":2,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1501077716,"id":53490,"title":"\u003cp\u003eNotes on Codeforces Beta Round #63, A, B, C, D (Game problem with winning and losing state determination), E\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/69/problem/A\" title\u003d\"Codeforces Beta Round 63 (Div. 2)\"\u003e69A - Young Physicist\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAdd all the vectors together, and check whether the result is a zero vector or not. \u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/69/problem/B\" title\u003d\"Codeforces Beta Round 63 (Div. 2)\"\u003e69B - Bets\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe first enumerate all the sections, and for each section we check all the players to find the one who participates and has the minimum time to finish this section. Then, for this section, we can just bet on this selected player and obtain the corresponding profit. Finally, we add the profits of all the sections together to obtain the required answer.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/69/problem/C\" title\u003d\"Codeforces Beta Round 63 (Div. 2)\"\u003e69C - Game\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis problem is solved by straightforward implementation. One should be careful that whenever a new query comes, we should immediately check whether a new composite element can be obtained. If yes, we should implement this operation and update the results at once.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/69/problem/D\" title\u003d\"Codeforces Beta Round 63 (Div. 2)\"\u003e69D - Dot\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI think this is a very nice problem to practice dealing with a game, which two people take turns to play using the optimal strategy. \u003c/p\u003e\u003cp\u003eAt first, one can find that it is not necessary to take the \u0026quot;reflection\u0026quot; operations into consideration. When someone first chooses to reflect x and y, it in fact means that he must have been in a losing state. However, the competitor can reflect the coordinates again, and thus it returns to the previous state. In other words, the two reflection operations from different players cancel each other.\u003c/p\u003e\u003cp\u003eNext, for each coordinate (x, y), we assign it with a state, indicated by \u0027losing and winning\u0027, which gives the final result that one player can achieve if he starts to move from this position. For each position, we can obtain all the feasible positions that he can move to according to the given vectors (note that only the positions inside the circle should be viewed as \u0026quot;feasible\u0026quot;). Moreover, if any of them is a losing state, this position should be assigned with winning state, otherwise with losing state. We can start from the initial position and implement DFS to calculate the states. Note that for some position, if all the next positions to which it can move fall outside the circle, it is definitely a losing state, and this serves as the \u0026quot;return condition\u0026quot; in DFS.\u003c/p\u003e\u003cp\u003eThis sort of problem in fact has a general solution, which uses BFS rather than DFS. It looks a little like Topological Order. One can check the book in \u003ca href\u003d\"//codeforces.com/blog/pllk\"\u003ehttp://codeforces.com/blog/pllk\u003c/a\u003e for more details.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/69/problem/E\" title\u003d\"Codeforces Beta Round 63 (Div. 2)\"\u003e69E - Subsegments\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis problem turns out to be quite easy if one uses the \u0026quot;set\u0026lt;\u0026gt;\u0026quot; in STL of C++. When a new element enters the sliding window, we increase the times that it appears by one, while if an element moves out of the sliding window, we decrease it by one. If one element appears exactly once, then we insert it into the set; otherwise we erase it from the set. Sorting is automatically implemented and maintained in set, and thus the maximum value can be obtained at any time with constant complexity O(1). \u0026quot;Insert, erase, sort\u0026quot; are all implemented with complexity O(logN), which leads to a total complexity of O(NlogN).\u003c/p\u003e\u003c/div\u003e","tags":[]}}