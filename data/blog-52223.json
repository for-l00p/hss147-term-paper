{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1495921961,"rating":80,"authorHandle":"lewin","modificationTimeSeconds":1495926627,"id":52223,"title":"\u003cp\u003eEditorial of Yandex.Algorithm 2017 Round 2\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eFibonacci Frequency\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eSome casework: First, let’s assume n !\u003d 0:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eIf k \u003d 0, then, a\u003d0,b\u003d0,\u003c/li\u003e   \u003cli\u003eIf k \u003d 1, then, a\u003dn,b\u003d2*n,\u003c/li\u003e   \u003cli\u003eIf k \u003d 2, then, a\u003d0,b\u003dn,\u003c/li\u003e   \u003cli\u003eIf k \u003d 3, then, a\u003dn,b\u003d0,\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eFor k \u0026gt;\u003d 4, we can show it is not possible.\u003c/p\u003e\u003cp\u003eThere are two phases, one where two adjacent terms have opposite signs, and one where two adjacent terms have the same sign.\u003c/p\u003e\u003cp\u003eFor the first phase, this kind of looks like the gcd algorithm, so we can show that the absolute value of sequence is strictly decreasing for even and odd indices separately until one of them hits zero, or two adjacent terms get the same sign.\u003c/p\u003e\u003cp\u003eFor the second phase, we can show the absolute value increases.\u003c/p\u003e\u003cp\u003eA number can only appear at most once in the first phase, and at most twice in the second phase.\u003c/p\u003e\u003cp\u003en\u003d0 is a special case. We can show that it can only appear at most once, or an infinite number of times.\u003c/p\u003e\u003cp\u003eMake sure to watch out for the case 0 0 also.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003en,k \u003d map(int, raw_input().split())\n\nif n !\u003d 0:\n\tx \u003d [n,0,n,2*n]\n\tif k \u003d\u003d 0:\n\t\tprint \u0026quot;Yes\u0026quot;\n\t\tprint 0,0\n\telif 1 \u0026lt;\u003d k \u0026lt;\u003d 3:\n\t\tprint \u0026quot;Yes\u0026quot;\n\t\tprint x[3-k], x[4-k]\n\telse:\n\t\tprint \u0026quot;No\u0026quot;\nelse:\n\tif k \u003d\u003d 0:\n\t\tprint \u0026quot;Yes\u0026quot;\n\t\tprint 1,1\n\telif k \u003d\u003d 1:\n\t\tprint \u0026quot;Yes\u0026quot;\n\t\tprint 0,1\n\telse:\n\t\tprint \u0026quot;No\u0026quot;\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eRainbow Road\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eNote that the operations are reversible, so it suffices to see if the two configurations can reach any common state.\u003c/p\u003e\u003cp\u003eLet’s denote the canonical state to be where we merge tokens as much as possible, and after this, move the tokens to the lowest indexed nodes that they can reach. Note we can do this, since merging tokens allows us to travel across more edges. We show how we can simulate this process in O((n+m) * c) time.\u003c/p\u003e\u003cp\u003eFor instance, we can simulate this process c times. For each token, find the set of nodes it can reach. If two tokens or more tokens can reach the same node, merge them. We only need to do this process c times since there can only be at most c merges. This process takes O(n+m) overall for all tokens (i.e. we only visit each node/edge at most once per iteration).\u003c/p\u003e\u003cp\u003eThus, checking if a sequence of moves is possible is to check whether the canonical states of both the initial and final states are identical.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream \u003d System.in;\n        OutputStream outputStream \u003d System.out;\n        InputReader in \u003d new InputReader(inputStream);\n        OutputWriter out \u003d new OutputWriter(outputStream);\n        RainbowRoad solver \u003d new RainbowRoad();\n        int testCount \u003d Integer.parseInt(in.next());\n        for (int i \u003d 1; i \u0026lt;\u003d testCount; i++)\n            solver.solve(i, in, out);\n        out.close();\n    }\n\n    static class RainbowRoad {\n        public List\u0026lt;RainbowRoad.Edge\u0026gt;[] edges;\n        public int[] par;\n        public int[] size;\n        public int[] mn;\n        public long[] ccolor;\n        public int n;\n        public int m;\n        public int c;\n        public boolean[] vis;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            n \u003d in.nextInt();\n            m \u003d in.nextInt();\n            c \u003d in.nextInt();\n\n            edges \u003d new List[n];\n            for (int i \u003d 0; i \u0026lt; n; i++) edges[i] \u003d new ArrayList\u0026lt;\u0026gt;();\n            for (int i \u003d 0; i \u0026lt; m; i++) {\n                int a \u003d in.nextInt() - 1, b \u003d in.nextInt() - 1;\n                long c \u003d in.nextLong();\n                edges[a].add(new RainbowRoad.Edge(a, b, c));\n                edges[b].add(new RainbowRoad.Edge(b, a, c));\n            }\n\n            int[] x \u003d in.readIntArray(c);\n            int[] y \u003d in.readIntArray(c);\n            for (int i \u003d 0; i \u0026lt; c; i++) {\n                x[i]--;\n                y[i]--;\n            }\n\n            List\u0026lt;RainbowRoad.T\u0026gt; p \u003d solve(x), q \u003d solve(y);\n            out.println(p.equals(q) ? \u0026quot;Possible\u0026quot; : \u0026quot;Impossible\u0026quot;);\n        }\n\n        public List\u0026lt;RainbowRoad.T\u0026gt; solve(int[] arr) {\n            par \u003d new int[n];\n            size \u003d new int[n];\n            mn \u003d new int[n];\n            ccolor \u003d new long[n];\n\n            for (int i \u003d 0; i \u0026lt; n; i++) {\n                par[i] \u003d i;\n                mn[i] \u003d i;\n                size[i] \u003d 1;\n                ccolor[i] \u003d 0;\n            }\n            for (int j \u003d 0; j \u0026lt; c; j++) {\n                ccolor[arr[j]] |\u003d 1L \u0026lt;\u0026lt; j;\n            }\n            for (int xx \u003d 0; xx \u0026lt; c; xx++) {\n                vis \u003d new boolean[n];\n                for (int i \u003d 0; i \u0026lt; n; i++) {\n                    if (!vis[i] \u0026amp;\u0026amp; ccolor[find(i)] !\u003d 0)\n                        dfs(i);\n                }\n            }\n\n            List\u0026lt;RainbowRoad.T\u0026gt; ret \u003d new ArrayList\u0026lt;\u0026gt;();\n            for (int i \u003d 0; i \u0026lt; n; i++) {\n                if (find(i) \u003d\u003d i \u0026amp;\u0026amp; ccolor[i] !\u003d 0) {\n                    ret.add(new RainbowRoad.T(mn[i], ccolor[i]));\n                }\n            }\n            Collections.sort(ret);\n            return ret;\n        }\n\n        public void dfs(int node) {\n            if (vis[node]) return;\n            vis[node] \u003d true;\n            for (RainbowRoad.Edge next : edges[node]) {\n                if (join(next.a, next.b, next.c)) {\n                    dfs(next.b);\n                }\n            }\n\n        }\n\n        public int find(int x) {\n            return x \u003d\u003d par[x] ? x : (par[x] \u003d find(par[x]));\n        }\n\n        public boolean join(int a, int b, long c) {\n            int x \u003d find(a), y \u003d find(b);\n            if (x \u003d\u003d y) return false;\n            if ((ccolor[x] \u0026amp; c) !\u003d c \u0026amp;\u0026amp; (ccolor[y] \u0026amp; c) !\u003d c) return false;\n\n            if (size[x] \u0026lt; size[y]) {\n                int t \u003d x;\n                x \u003d y;\n                y \u003d t;\n            }\n            size[x] +\u003d size[y];\n            mn[x] \u003d Math.min(mn[x], mn[y]);\n            par[y] \u003d x;\n            ccolor[x] |\u003d ccolor[y];\n            return true;\n        }\n\n        static class Edge {\n            public int a;\n            public int b;\n            public long c;\n\n            public Edge(int a, int b, long c) {\n                this.a \u003d a;\n                this.b \u003d b;\n                this.c \u003d c;\n            }\n\n        }\n\n        static class T implements Comparable\u0026lt;RainbowRoad.T\u0026gt; {\n            public long color;\n            public int pos;\n\n            public T(int pos, long color) {\n                this.pos \u003d pos;\n                this.color \u003d color;\n            }\n\n\n            public boolean equals(Object o) {\n                if (!(o instanceof RainbowRoad.T)) return false;\n                return ((RainbowRoad.T) o).pos \u003d\u003d pos \u0026amp;\u0026amp; ((RainbowRoad.T) o).color \u003d\u003d color;\n            }\n\n            public int compareTo(RainbowRoad.T other) {\n                return pos - other.pos;\n            }\n\n            public String toString() {\n                return pos + \u0026quot; \u0026quot; + color;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf \u003d new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream \u003d stream;\n        }\n\n        public int[] readIntArray(int tokens) {\n            int[] ret \u003d new int[tokens];\n            for (int i \u003d 0; i \u0026lt; tokens; i++) {\n                ret[i] \u003d nextInt();\n            }\n            return ret;\n        }\n\n        public int read() {\n            if (this.numChars \u003d\u003d -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar \u0026gt;\u003d this.numChars) {\n                    this.curChar \u003d 0;\n\n                    try {\n                        this.numChars \u003d this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars \u0026lt;\u003d 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c \u003d this.read(); isSpaceChar(c); c \u003d this.read()) {\n                ;\n            }\n\n            byte sgn \u003d 1;\n            if (c \u003d\u003d 45) {\n                sgn \u003d -1;\n                c \u003d this.read();\n            }\n\n            int res \u003d 0;\n\n            while (c \u0026gt;\u003d 48 \u0026amp;\u0026amp; c \u0026lt;\u003d 57) {\n                res *\u003d 10;\n                res +\u003d c - 48;\n                c \u003d this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public long nextLong() {\n            int c;\n            for (c \u003d this.read(); isSpaceChar(c); c \u003d this.read()) {\n                ;\n            }\n\n            byte sgn \u003d 1;\n            if (c \u003d\u003d 45) {\n                sgn \u003d -1;\n                c \u003d this.read();\n            }\n\n            long res \u003d 0L;\n\n            while (c \u0026gt;\u003d 48 \u0026amp;\u0026amp; c \u0026lt;\u003d 57) {\n                res *\u003d 10L;\n                res +\u003d (long) (c - 48);\n                c \u003d this.read();\n                if (isSpaceChar(c)) {\n                    return res * (long) sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public String next() {\n            int c;\n            while (isSpaceChar(c \u003d this.read())) {\n                ;\n            }\n\n            StringBuilder result \u003d new StringBuilder();\n            result.appendCodePoint(c);\n\n            while (!isSpaceChar(c \u003d this.read())) {\n                result.appendCodePoint(c);\n            }\n\n            return result.toString();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c \u003d\u003d 32 || c \u003d\u003d 10 || c \u003d\u003d 13 || c \u003d\u003d 9 || c \u003d\u003d -1;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer \u003d new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer \u003d new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i \u003d 0; i \u0026lt; objects.length; i++) {\n                if (i !\u003d 0) {\n                    writer.print(\u0027 \u0027);\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eWildcard Words\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFirst, handle some special cases where the sequence doesn\u0027t start or end with \u0027*\u0027, or contains no \u0027*\u0027 (also, be careful when the pattern’s length is bigger than r-l+1). So, now, let\u0027s assume the sequence starts and ends with \u0027*\u0027.\u003c/p\u003e\u003cp\u003eWe can proceed greedily. First, split the pattern by \u0027*\u0027. For each contiguous substring of letters, we can greedily take the earliest occurrence after a certain position. For each length \u0026lt;\u003d 10 substring of the input, we can build a sorted vector of positions that it occurs in. The next earliest occurrence can be found using lower_bound.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream \u003d System.in;\n        OutputStream outputStream \u003d System.out;\n        InputReader in \u003d new InputReader(inputStream);\n        OutputWriter out \u003d new OutputWriter(outputStream);\n        WildcardWords solver \u003d new WildcardWords();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class WildcardWords {\n        public HashMap\u0026lt;String, ArrayList\u0026lt;Integer\u0026gt;\u0026gt; mp;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            char[] s \u003d in.next().toCharArray();\n            mp \u003d new HashMap\u0026lt;\u0026gt;();\n            for (int i \u003d 0; i \u0026lt; s.length; i++) {\n                String cur \u003d \u0026quot;\u0026quot;;\n                for (int j \u003d i; j \u0026lt; i + 10 \u0026amp;\u0026amp; j \u0026lt; s.length; j++) {\n                    cur +\u003d s[j];\n\n                    ArrayList\u0026lt;Integer\u0026gt; x \u003d mp.get(cur);\n                    if (x \u003d\u003d null) {\n                        mp.put(cur, x \u003d new ArrayList\u0026lt;\u0026gt;());\n                    }\n                    x.add(i);\n                }\n            }\n\n            int q \u003d in.nextInt();\n            while (q-- \u0026gt; 0) {\n                int l \u003d in.nextInt() - 1, r \u003d in.nextInt();\n                String w \u003d in.next();\n                if (!w.contains(\u0026quot;*\u0026quot;)) {\n                    if (r - l !\u003d w.length()) {\n                        out.println(\u0026quot;No\u0026quot;);\n                        continue;\n                    }\n                    String ee \u003d \u0026quot;\u0026quot;;\n                    for (int i \u003d l; i \u0026lt; r; i++) ee +\u003d s[i];\n                    out.println(ee.equals(w) ? \u0026quot;Yes\u0026quot; : \u0026quot;No\u0026quot;);\n                    continue;\n                }\n                String[] pat \u003d w.split(\u0026quot;\\\\*\u0026quot;);\n                int cur \u003d l;\n                if (w.charAt(0) !\u003d \u0027*\u0027) {\n                    // must start with pat[0]\n                    int d \u003d getPos(pat[0], cur);\n                    if (d !\u003d cur) {\n                        cur \u003d 1 \u0026lt;\u0026lt; 29;\n                    } else {\n                        cur \u003d d + pat[0].length();\n                    }\n                }\n                for (int i \u003d 1; i \u0026lt; pat.length; i++) {\n                    if (pat[i].equals(\u0026quot;\u0026quot;)) continue;\n                    cur \u003d next(pat[i], cur);\n                }\n                int c \u003d pat.length - 1;\n                out.println((w.charAt(w.length() - 1) \u003d\u003d \u0027*\u0027 ? cur \u0026lt;\u003d r :\n                        (cur \u0026lt;\u003d r \u0026amp;\u0026amp; getPos(pat[c], r - pat[c].length()) \u003d\u003d r - pat[c].length())) ? \u0026quot;Yes\u0026quot; : \u0026quot;No\u0026quot;);\n            }\n        }\n\n        public int next(String s, int start) {\n            if (start \u003d\u003d 1 \u0026lt;\u0026lt; 29) return 1 \u0026lt;\u0026lt; 29;\n            int k \u003d getPos(s, start);\n            if (k \u003d\u003d 1 \u0026lt;\u0026lt; 29) return k;\n            return k + s.length();\n        }\n\n        public int getPos(String s, int start) {\n            ArrayList\u0026lt;Integer\u0026gt; w \u003d mp.get(s);\n            if (w \u003d\u003d null) {\n                return 1 \u0026lt;\u0026lt; 29;\n            }\n            int pos \u003d Collections.binarySearch(w, start);\n            if (pos \u0026lt; 0) pos \u003d -pos - 1;\n            if (pos \u003d\u003d w.size()) {\n                return 1 \u0026lt;\u0026lt; 29;\n            }\n            return w.get(pos);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer \u003d new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer \u003d new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i \u003d 0; i \u0026lt; objects.length; i++) {\n                if (i !\u003d 0) {\n                    writer.print(\u0027 \u0027);\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf \u003d new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream \u003d stream;\n        }\n\n        public int read() {\n            if (this.numChars \u003d\u003d -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar \u0026gt;\u003d this.numChars) {\n                    this.curChar \u003d 0;\n\n                    try {\n                        this.numChars \u003d this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars \u0026lt;\u003d 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c \u003d this.read(); isSpaceChar(c); c \u003d this.read()) {\n                ;\n            }\n\n            byte sgn \u003d 1;\n            if (c \u003d\u003d 45) {\n                sgn \u003d -1;\n                c \u003d this.read();\n            }\n\n            int res \u003d 0;\n\n            while (c \u0026gt;\u003d 48 \u0026amp;\u0026amp; c \u0026lt;\u003d 57) {\n                res *\u003d 10;\n                res +\u003d c - 48;\n                c \u003d this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public String next() {\n            int c;\n            while (isSpaceChar(c \u003d this.read())) {\n                ;\n            }\n\n            StringBuilder result \u003d new StringBuilder();\n            result.appendCodePoint(c);\n\n            while (!isSpaceChar(c \u003d this.read())) {\n                result.appendCodePoint(c);\n            }\n\n            return result.toString();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c \u003d\u003d 32 || c \u003d\u003d 10 || c \u003d\u003d 13 || c \u003d\u003d 9 || c \u003d\u003d -1;\n        }\n\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCounter Complexity\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eJust simulate the process.\u003c/p\u003e\u003cp\u003eExtension: solve this when n \u0026lt;\u003d 10^5, |x_i|,|y_i| \u0026lt;\u003d 10^5.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003en \u003d int(raw_input())\n\nD \u003d dict()\n\ndef go(x, y):\n    if not (x, y) in D:\n        D[(x, y)] \u003d 0\n    D[(x, y)] \u003d D[(x, y)] + 1\n    if D[(x, y)] \u003d\u003d 5:\n        del D[(x, y)]\n        go(x + 1, y)\n        go(x, y + 1)\n        go(x - 1, y)\n        go(x, y - 1)\n\nfor i in range(n):\n    x, y \u003d map(int, raw_input().split())\n    go(x, y)\n    print len(D)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eAvoiding Adjacent\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFirst, we need to reduce it to a counting problem.\u003c/p\u003e\u003cp\u003eLet the sequence be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e Let\u0027s fix a prefix of the given sequence: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003ep\u003c/i\u003e\u003c/span\u003e. Now, fix \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e + 1\u003c/sub\u003e \u0026lt; \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e + 1\u003c/sub\u003e! \u003d \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe can compute the frequency of the remaining colors. So, we want to solve this problem: How many ways are there to arrange balls of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e colors with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e balls of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th color, such that the first ball in the line cannot be color 1.\u003c/p\u003e\u003cp\u003eWe can solve this using dynamic programming by adding colors one by one, or inclusion exclusion.\u003c/p\u003e\u003cp\u003eFor the inclusion exclusion solution, let\u0027s first ignore color 1.\u003c/p\u003e\u003cp\u003eWe want to count the number of sequences where no two adjacent balls are the same color. Let\u0027s partition the sequence into \u0026quot;groups\u0026quot;, where a group is a sequence of adjacent balls of the same color (not necessarily maximal).\u003c/p\u003e\u003cp\u003eThen, the final answer can be computed as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eS\u003c/i\u003e - 1\u003c/sub\u003e + \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eS\u003c/i\u003e - 2\u003c/sub\u003e - ...\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLet\u0027s look at one color, let\u0027s say it\u0027s color \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. We can precompute the number of ways to partition this into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e groups. This is the number of ways to partition \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e summands. This can be computed with a dp.\u003c/p\u003e\u003cp\u003eNow, let\u0027s consider compute \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. We need to assign \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e groups into color \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e such that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/03/e703c4a39245bea140fbb4eacf8f050f3d1163ef.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Thus, this can be computed with a knapsack like formula. After assigning these, we can rearrange groups freely, for a total of k! ways.\u003c/p\u003e\u003cp\u003eNow, let\u0027s add color 1 back in. Let\u0027s fix the number of other color groups \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, and also the number of groups for color 1 (call it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e). Then, instead of multiplying by \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e)!\u003c/span\u003e, we can multiply by \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/dd/a6/dda60a7bf8e100260bf133d59adcc1092c6b2a83.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eOverall, we need to solve (sum a) * (max a) counting problems, each of which takes len(a) * max(a) * sum(a) time. The overall running time is thus 15^7 (in practice, the constant is much lower, since not all counting problems will be the maximal ones).\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream \u003d System.in;\n        OutputStream outputStream \u003d System.out;\n        InputReader in \u003d new InputReader(inputStream);\n        OutputWriter out \u003d new OutputWriter(outputStream);\n        AvoidingAdjacent solver \u003d new AvoidingAdjacent();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class AvoidingAdjacent {\n        public int mod \u003d 1000000007;\n        public int MAXN \u003d 16 * 16 + 1;\n        public int[][] w1;\n        public long[] fact;\n        public long[] ifact;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int c \u003d in.nextInt();\n            int[] arr \u003d in.readIntArray(c);\n            int s \u003d AUtils.sum(arr);\n            int[] x \u003d in.readIntArray(s);\n            for (int i \u003d 0; i \u0026lt; s; i++) x[i]--;\n\n            long[][] e \u003d Factorials.getFIF(MAXN, mod);\n            fact \u003d e[0];\n            ifact \u003d e[1];\n            w1 \u003d new int[MAXN][MAXN];\n            w1[0][0] \u003d 1;\n            for (int i \u003d 1; i \u0026lt; MAXN; i++) {\n                for (int j \u003d 1; j \u0026lt; MAXN; j++) {\n                    for (int k \u003d 1; k \u0026lt;\u003d i; k++) {\n                        w1[i][j] +\u003d w1[i - k][j - 1];\n                        if (w1[i][j] \u0026gt;\u003d mod) w1[i][j] -\u003d mod;\n                    }\n                }\n            }\n\n            int ans \u003d 0;\n            for (int i \u003d 0; i \u0026lt; s; i++) {\n                for (int j \u003d 0; j \u0026lt; x[i]; j++) {\n                    if (i \u0026gt; 0 \u0026amp;\u0026amp; j \u003d\u003d x[i - 1]) continue;\n                    if (arr[j] \u0026gt; 0) {\n                        arr[j]--;\n                        int w \u003d solve(arr, j);\n                        ans +\u003d w;\n                        if (ans \u0026gt;\u003d mod) ans -\u003d mod;\n                        arr[j]++;\n                    }\n                }\n                arr[x[i]]--;\n            }\n\n            out.println((ans + 1) % mod);\n        }\n\n        public int solve(int[] freq, int special) {\n            int d \u003d AUtils.sum(freq);\n            int b \u003d AUtils.max(freq);\n            if (d \u003d\u003d 0) return 1;\n            if (d \u003d\u003d freq[special]) return 0;\n            if (b + b - 1 \u0026gt; d) return 0;\n            int[] dp \u003d new int[1];\n            dp[0] \u003d 1;\n            for (int j \u003d 0; j \u0026lt; freq.length; j++) {\n                if (freq[j] \u003d\u003d 0 || j \u003d\u003d special) continue;\n                int[] nxt \u003d new int[dp.length + freq[j]];\n                for (int pgr \u003d 0; pgr \u0026lt; dp.length; pgr++) {\n                    for (int cgr \u003d 1; cgr \u0026lt;\u003d freq[j]; cgr++) {\n                        nxt[pgr + cgr] +\u003d 1L * dp[pgr] * w1[freq[j]][cgr] % mod * ifact[cgr] % mod;\n                        if (nxt[pgr + cgr] \u0026gt;\u003d mod) nxt[pgr + cgr] -\u003d mod;\n                    }\n                }\n                dp \u003d nxt;\n            }\n\n            int res \u003d 0;\n            for (int i \u003d 0; i \u0026lt; dp.length; i++) {\n                if (freq[special] \u003d\u003d 0) {\n                    long x \u003d 1L * dp[i] * fact[i] % mod;\n                    if ((d - i) % 2 \u003d\u003d 0) res +\u003d x;\n                    else res -\u003d x;\n                    if (res \u0026gt;\u003d mod) res -\u003d mod;\n                    if (res \u0026lt; 0) res +\u003d mod;\n                } else {\n                    for (int j \u003d 1; j \u0026lt;\u003d freq[special]; j++) {\n                        long x \u003d 1L * dp[i] * w1[freq[special]][j] % mod * ifact[j] % mod;\n                        x \u003d x * fact[i + j - 1] % mod * i % mod;\n\n                        if ((d - i - j) % 2 \u003d\u003d 0) res +\u003d x;\n                        else res -\u003d x;\n                        if (res \u0026gt;\u003d mod) res -\u003d mod;\n                        if (res \u0026lt; 0) res +\u003d mod;\n                    }\n                }\n            }\n            return res;\n        }\n\n    }\n\n    static class AUtils {\n        public static int max(int[] arr) {\n            int res \u003d arr[0];\n            for (int x : arr) res \u003d Math.max(res, x);\n            return res;\n        }\n\n        public static int sum(int[] arr) {\n            int sum \u003d 0;\n            for (int x : arr) {\n                sum +\u003d x;\n            }\n            return sum;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer \u003d new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer \u003d new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf \u003d new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream \u003d stream;\n        }\n\n        public int[] readIntArray(int tokens) {\n            int[] ret \u003d new int[tokens];\n            for (int i \u003d 0; i \u0026lt; tokens; i++) {\n                ret[i] \u003d nextInt();\n            }\n            return ret;\n        }\n\n        public int read() {\n            if (this.numChars \u003d\u003d -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar \u0026gt;\u003d this.numChars) {\n                    this.curChar \u003d 0;\n\n                    try {\n                        this.numChars \u003d this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars \u0026lt;\u003d 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c \u003d this.read(); isSpaceChar(c); c \u003d this.read()) {\n                ;\n            }\n\n            byte sgn \u003d 1;\n            if (c \u003d\u003d 45) {\n                sgn \u003d -1;\n                c \u003d this.read();\n            }\n\n            int res \u003d 0;\n\n            while (c \u0026gt;\u003d 48 \u0026amp;\u0026amp; c \u0026lt;\u003d 57) {\n                res *\u003d 10;\n                res +\u003d c - 48;\n                c \u003d this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c \u003d\u003d 32 || c \u003d\u003d 10 || c \u003d\u003d 13 || c \u003d\u003d 9 || c \u003d\u003d -1;\n        }\n\n    }\n\n    static class Factorials {\n        public static long[][] getFIF(int max, int mod) {\n            long[] fact \u003d new long[max];\n            long[] ifact \u003d new long[max];\n            long[] inv \u003d new long[max];\n            inv[1] \u003d 1;\n            for (int i \u003d 2; i \u0026lt; max; i++) {\n                inv[i] \u003d (mod - mod / i) * inv[mod % i] % mod;\n            }\n            fact[0] \u003d 1;\n            ifact[0] \u003d 1;\n            for (int i \u003d 1; i \u0026lt; max; i++) {\n                fact[i] \u003d fact[i - 1] * i % mod;\n                ifact[i] \u003d ifact[i - 1] * inv[i] % mod;\n            }\n            return new long[][]{fact, ifact, inv};\n        }\n\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eToken Tree\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eWe can look at this backwards. Consider a position for which Bob can make no more moves. Then, we have a token in every node in the tree except for the special vertex. To maximize the number of tokens that Alice can place, we can push these tokens as far away as we can from the special vertex (i.e. remove this token, and place 2 tokens on one of its children).\u003c/p\u003e\u003cp\u003eSo, after fixing a special node, and rooting the tree at the special node, the answer is the sum over nodes of 2^d, where d is longest path from node to a leaf without going up the tree.This can be computed in O(n) time for a single node.\u003c/p\u003e\u003cp\u003eNow, let’s look at what happens when we move the special node to an adjacent vertex. We just need to add contribution of old vertex and subtract contribution of new vertex. These can be done if we keep track of the longest and second longest path at each node.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream \u003d System.in;\n        OutputStream outputStream \u003d System.out;\n        InputReader in \u003d new InputReader(inputStream);\n        OutputWriter out \u003d new OutputWriter(outputStream);\n        TokenTree solver \u003d new TokenTree();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TokenTree {\n        int mod \u003d 1000000007;\n        int[] pow2;\n        List\u0026lt;Integer\u0026gt;[] graph;\n        int[] ans;\n        int[] down;\n        int[] up;\n        int[] b1;\n        int[] b2;\n        int[] id;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n \u003d in.nextInt();\n            pow2 \u003d new int[n + 1];\n            pow2[0] \u003d 1;\n            for (int i \u003d 1; i \u0026lt;\u003d n; i++) {\n                pow2[i] \u003d (pow2[i - 1] \u0026lt;\u0026lt; 1) % mod;\n            }\n            graph \u003d new List[n];\n            for (int i \u003d 0; i \u0026lt; n; i++) graph[i] \u003d new ArrayList\u0026lt;\u0026gt;();\n            for (int i \u003d 0; i \u0026lt; n - 1; i++) {\n                int a \u003d in.nextInt() - 1, b \u003d in.nextInt() - 1;\n                graph[a].add(b);\n                graph[b].add(a);\n            }\n            ans \u003d new int[n];\n            b1 \u003d new int[n];\n            b2 \u003d new int[n];\n            id \u003d new int[n];\n            getFarthest();\n            for (int i \u003d 1; i \u0026lt; n; i++) {\n                ans[0] +\u003d pow2[down[i]];\n                if (ans[0] \u0026gt;\u003d mod) ans[0] -\u003d mod;\n            }\n            dfs3(0, -1);\n            for (int i \u003d 0; i \u0026lt; n; i++) {\n                out.println(ans[i]);\n            }\n        }\n\n        void dfs3(int node, int par) {\n            for (int next : graph[node]) {\n                if (next \u003d\u003d par) continue;\n                ans[next] \u003d ans[node] - pow2[down[next]];\n                if (ans[next] \u0026lt; 0) ans[next] +\u003d mod;\n                int add \u003d b1[node];\n                if (id[node] \u003d\u003d next) add \u003d b2[node];\n                ans[next] +\u003d pow2[add];\n                if (ans[next] \u0026gt;\u003d mod) ans[next] -\u003d mod;\n                dfs3(next, node);\n            }\n        }\n\n        int[] getFarthest() {\n            int n \u003d graph.length;\n            down \u003d new int[n];\n            up \u003d new int[n];\n            dfs(0, -1);\n            dfs2(0, -1, 0);\n            int[] ret \u003d new int[n];\n            for (int i \u003d 0; i \u0026lt; n; i++) {\n                ret[i] \u003d Math.max(up[i], down[i]);\n            }\n            return ret;\n        }\n\n        void dfs(int node, int par) {\n            for (int next : graph[node]) {\n                if (next \u003d\u003d par) continue;\n                dfs(next, node);\n                down[node] \u003d Math.max(down[node], down[next] + 1);\n            }\n        }\n\n        void dfs2(int node, int par, int frompar) {\n            up[node] \u003d frompar;\n            b1[node] \u003d up[node];\n            id[node] \u003d par;\n            int mx1 \u003d 0, id1 \u003d -1, mx2 \u003d 0;\n            for (int next : graph[node]) {\n                if (next \u003d\u003d par) continue;\n                if (down[next] + 1 \u0026gt; b1[node]) {\n                    b2[node] \u003d b1[node];\n                    b1[node] \u003d down[next] + 1;\n                    id[node] \u003d next;\n                } else if (down[next] + 1 \u0026gt; b2[node]) {\n                    b2[node] \u003d down[next] + 1;\n                }\n                if (down[next] + 1 \u0026gt; mx1) {\n                    mx2 \u003d mx1;\n                    mx1 \u003d down[next] + 1;\n                    id1 \u003d next;\n                } else if (down[next] + 1 \u0026gt; mx2) {\n                    mx2 \u003d down[next] + 1;\n                }\n            }\n\n            for (int next : graph[node]) {\n                if (next \u003d\u003d par) continue;\n                dfs2(next, node, Math.max(up[node], next \u003d\u003d id1 ? mx2 : mx1) + 1);\n            }\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer \u003d new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer \u003d new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf \u003d new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream \u003d stream;\n        }\n\n        public int read() {\n            if (this.numChars \u003d\u003d -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar \u0026gt;\u003d this.numChars) {\n                    this.curChar \u003d 0;\n\n                    try {\n                        this.numChars \u003d this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars \u0026lt;\u003d 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c \u003d this.read(); isSpaceChar(c); c \u003d this.read()) {\n                ;\n            }\n\n            byte sgn \u003d 1;\n            if (c \u003d\u003d 45) {\n                sgn \u003d -1;\n                c \u003d this.read();\n            }\n\n            int res \u003d 0;\n\n            while (c \u0026gt;\u003d 48 \u0026amp;\u0026amp; c \u0026lt;\u003d 57) {\n                res *\u003d 10;\n                res +\u003d c - 48;\n                c \u003d this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c \u003d\u003d 32 || c \u003d\u003d 10 || c \u003d\u003d 13 || c \u003d\u003d 9 || c \u003d\u003d -1;\n        }\n\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["yandex"]}}