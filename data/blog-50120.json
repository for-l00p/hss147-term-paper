{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1485789790,"rating":22,"authorHandle":"wrick","modificationTimeSeconds":1485894433,"id":50120,"title":"\u003cp\u003eCircular Buffers: A data structure for O(1) random-indexing, append, prepend, clear, dropFirst and dropLast\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eCircular buffers are simple data structures that provide O(1) \u003ccode\u003eget\u003c/code\u003e, \u003ccode\u003eset\u003c/code\u003e, \u003ccode\u003eappend\u003c/code\u003e, \u003ccode\u003eprepend\u003c/code\u003e, \u003ccode\u003eclear\u003c/code\u003e, \u003ccode\u003edropFirst\u003c/code\u003e and \u003ccode\u003edropLast\u003c/code\u003e operations. It can be implemented using 2 pointers (\u003ccode\u003estart\u003c/code\u003e and \u003ccode\u003eend\u003c/code\u003e) and an array and using modular arithmetics for indexing.\u003c/p\u003e\u003cp\u003eHere is a simple implementation in Java:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass CircularBuffer\u0026lt;T\u0026gt; {\n  private T[] array \u003d (T[]) new Object[1\u0026lt;\u0026lt;4];\n  private int start \u003d 0, end \u003d 0;\n\n  public T get(int i) {\n    assert(0 \u0026lt;\u003d i \u0026amp;\u0026amp; i \u0026lt; size());\n    return array[mod(start + i)];\n  }\n\n  public void set(int i, T elem) {\n    assert(0 \u0026lt;\u003d i \u0026amp;\u0026amp; i \u0026lt; size());\n    array[mod(start + i)] \u003d elem;\n  }\n\n  public void append(T elem) {\n    if (size() \u003d\u003d array.length - 1) resize();\n    array[mod(end++)] \u003d elem;\n  }\n\n  public void prepend(T elem) {\n    if (size() \u003d\u003d array.length - 1) resize();\n    array[mod(--start)] \u003d elem;\n  }\n\n  public void dropFirst(int count) {\n    assert(0 \u0026lt;\u003d count \u0026amp;\u0026amp; count \u0026lt;\u003d size());\n    start +\u003d count;\n  }\n\n  public void dropLast(int count) {\n    assert(0 \u0026lt;\u003d count \u0026amp;\u0026amp; count \u0026lt;\u003d size());\n    end -\u003d count;\n  }\n\n  public int size() {\n    return mod(mod(end) - mod(start));\n  }\n\n  public void clear() {\n    start \u003d end;\n  }\n\n  private int mod(int x) {\n    return Math.floorMod(x, array.length);\n  }\n\n  private void resize() {\n    T[] array2 \u003d (T[]) new Object[2*array.length];\n    for(int i \u003d 0; i \u0026lt; size(); i++) {\n      array2[i] \u003d get(i);\n    }\n    end \u003d size();\n    start \u003d 0;\n    array \u003d array2;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSource: \u003ca href\u003d\"https://gist.github.com/pathikrit/eac29538af53abf7e827a74e110fb0ac\"\u003ehttps://gist.github.com/pathikrit/eac29538af53abf7e827a74e110fb0ac\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["data structures"]}}