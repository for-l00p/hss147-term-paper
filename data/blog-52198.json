{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1495807407,"rating":0,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1495807407,"id":52198,"title":"\u003cp\u003eNotes on Codeforces Beta Round #48, A, B, C(Precision-guaranteed Binary Search), D(Prefix and Suffix idea)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA. Cheaterius\u0027s Problem\u003c/p\u003e\u003cp\u003eWe can adopt a linear array a[4] to denote any 2*2 square, with a[0] being the upper left cell, a[1] being the upper right cell, a[2] being the bottom left cell and a[3] being the bottom right cell. Then, the rotation of 0, 90, 180 and 270 degrees can be viewed as a circular shift of array a[4], with length of 0, 1, 2 and 3. Therefore, for any two squares, they are exactly the same if one of them can be obtained by implementing a circular shift with some length to the other one. \u003c/p\u003e\u003cp\u003eB. bHTML Tables Analisys\u003c/p\u003e\u003cp\u003eOne can check that whenever we meet a \u0027\u0027, it means that we have met a new cell. Thus, we can adopt a variable S to count the number of cells that we have met. Note that when we detect a \u0027\u0027, it means that all the cells that we have counted should belong to this table. Therefore, we can store the current value of S, and set it to zero again, since the following cells, if there are any, should belong to some other table.\u003c/p\u003e\u003cp\u003eC. Three Base Stations\u003c/p\u003e\u003cp\u003eWe use x[0],x[1],...,x[n-1] to denote the cities, counted from left to right. Assume that the center of the most left circle is located at position t, and the radius is R. Then, if t-R\u0026lt;x[0], we can always update t by t\u0027\u003dt+x[0]-(t-R), i.e., the circle is moved to the right, and all the cities that have been covered by the original circle can surely be covered by the new one as well. This implies that for any optimal solution, the center of the most left circle must be located at position x[0]+R, while that of the most right circle is located at position x[n-1]-R. \u003c/p\u003e\u003cp\u003eWith the above arguments, we can use binary search to find out the optimal radius R. Specifically, we use R_L and R_R to denote the lower bound and upper bound, respectively, and we check R_M\u003d(R_L+R_R)/2 can cover all the cities or not. We start from x[0], and find out the first city x[s] that satisfies x[s]\u0026gt;x[0]+2*R_M. Similarly, we start from x[n-1] and find out the first city x[t] that satisfies x[t]\u0026lt;x[n-1]-2*R_M. Note that there may not exist such a position s or t, but if they both exist, we can check whether x[t]-x[s]\u0026lt;\u003d2*R_M holds or not. If it holds, it means that the current radius R_M is large enough to cover all the cities, and thus we should update R_R\u003dR_M for the next implementation of binary search; otherwise we should modify R_L as R_L\u003dR_M. To achieve the requirement of precision, we can find a value T that satisfies (R_R-R_L)/2^T\u0026lt;E, where R_R and R_L are the initialized values before implementing binary search, and E is the inaccuracy. Thus, it is sufficient to implement binary search for T times.\u003c/p\u003e\u003cp\u003eD. Geometrical problem\u003c/p\u003e\u003cp\u003eInstead of using a[i]/a[i-1] to calculate the common ratio, I suggest using a[i]*a[i]\u003da[i-1]*a[i+1] to determine whether it is a geometric series or not. \u003c/p\u003e\u003cp\u003eWe start from index i\u003d1 to i\u003dn-2, and test a[i]*a[i]\u003da[i-1]*a[i+1] for every index i. We adopt another array s[i], and use s[i]\u003d0 to denote that a[i]*a[i]\u003da[i-1]*a[i+1] holds; otherwise we set s[i]\u003d1. Note that only s[1],s[2],...,s[n-2] are assigned values. To check whether it is possible to form a geometric series by deleting a single element, we can just try to delete from the first one to the last one, and test whether all the left elements can satisfy a[i]*a[i]\u003da[i-1]*a[i+1]. To avoid Time Limited Error, we should introduce another two arrays, prefix[n] and suffix[n]. We use prefix[i] to denote that all the elements with indices no larger than i satisfy a[i]*a[i]\u003da[i-1]*a[i+1], while using suffix[i] to denote that all the elements with indices no less than i satisfy a[i]*a[i]\u003da[i-1]*a[i+1]. With the help of prefix[n] and suffix[n], we can claim that the sequence forms a geometric series after deleting some element a[i] based on the following conditions:\u003c/p\u003e\u003cp\u003e1) prefix[i-2]\u003d\u003d0;\u003c/p\u003e\u003cp\u003e2) suffix[i+2]\u003d\u003d0;\u003c/p\u003e\u003cp\u003e3) a[i-1]*a[i-1]\u003d\u003da[i-2]*a[i+1];\u003c/p\u003e\u003cp\u003e4) a[i+1]*a[i+1]\u003d\u003da[i-1]*a[i+2];\u003c/p\u003e\u003cp\u003eNevertheless, we still need to take special care of the following two cases:\u003c/p\u003e\u003cp\u003eCase 1) if n is two, it is always a geometric series unless that the first element is zero but the second one is not;\u003c/p\u003e\u003cp\u003eCase 2) if a[i-1]\u003da[i]\u003d0 but a[i+1]!\u003d0, although a[i]*a[i]\u003da[i-1]*a[i+1] holds, it is still not a geometric series, and thus s[i] should be set to 1 rather than 0.\u003c/p\u003e\u003c/div\u003e","tags":[]}}