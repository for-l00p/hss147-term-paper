{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1479546494,"rating":67,"authorHandle":"ko_osaga","modificationTimeSeconds":1479547160,"id":48465,"title":"\u003cp\u003eFFT, big modulos, precision errors.\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello!\u003c/p\u003e\u003cp\u003eRecently I learned about FFT algorithm, and I was confused because of it\u0027s precision errors.\u003c/p\u003e\u003cp\u003eSuppose that I want to multiply two polynomials A(x) and B(x) modulo 10^9 + 7. (max degree \u0026lt;\u003d 10^6) Then I have two options : \u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003euse NTT with modulo 119 * 2^23 + 1. With these I don\u0027t have to worry about precision errors, but I have to split the coefficients in something like (c0 + c1 * 32 + c2 * 32^2 + c3 * 32^3 .... c5 * 32^5). This is the best we can use, since if we use something over 32, (33-1) * (33-1) * 1000000 \u0026gt; modulo. So I have to split it into at least 6 pieces, which is horrible..\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003euse FFT with complex numbers : Well... we don\u0027t have modulos, so I have to guess here. I\u0027ve experimented with 10^6-digit long integers with all digits in 9. (basically I calculated (10 ** 1000000 â€” 1) ** 2) In first try, I grouped two digits together (coeff \u0026lt; 100), and it worked fine. In second try, I grouped three digits together(coeff \u0026lt; 1000) , which had precision errors. So I can guess that it will be okay to split under 100. Now 5 pieces. Which is... eh, improvement, but still horrible.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eRegarding \u003ca href\u003d\"http://hsin.hr/cerc/2015/tasks/cerc2015_problems.pdf\"\u003eproblem F in here\u003c/a\u003e or \u003ca href\u003d\"//codeforces.com/contest/623/problem/E\"\u003ethis\u003c/a\u003e (spoiler alert), It\u0027s clear that there is a demand for big modulos. However, grouping into something like 30 or 100 is not only dumb, but very slow and constant-heavy, and it should be avoided. \u003c/p\u003e\u003cp\u003eI concluded that NTT won\u0027t help me in this problem, and arrived in following questions : \u003c/p\u003e \u003col\u003e   \u003cli\u003eHow can we estimate the precision error of FFT? (or, is there some kind of rule of thumb in here?)\u003c/li\u003e   \u003cli\u003eWhat is the common way to avoid this situation? Isn\u0027t there any other way than grouping with number lesser than sqrt(mod), or karatsuba?\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eFYI, this is the code used in my experiment : \u003ca href\u003d\"https://gist.github.com/koosaga/ca557138cabe9923bdaacfacd9810cb1\"\u003ehttps://gist.github.com/koosaga/ca557138cabe9923bdaacfacd9810cb1\u003c/a\u003e \u003c/p\u003e\u003c/div\u003e","tags":["fft","precision","ntt"]}}