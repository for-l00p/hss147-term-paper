{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1402000345,"rating":0,"authorHandle":"HidenoriS","modificationTimeSeconds":1402001883,"id":12571,"title":"\u003cp\u003eDisjoint-set data structure (Example)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eIf you don\u0027t know disjoint-set data structure, read this \u003ca href\u003d\"//codeforces.com/group/TkF7VfNoT4/blog/entry/132\"\u003eoverview\u003c/a\u003e and learn how to implement it \u003ca href\u003d\"//codeforces.com/group/TkF7VfNoT4/blog/entry/133\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003ch1\u003eProblem\u003c/h1\u003e\u003cp\u003eA country has N cities and M roads. Each city is named city 1, city 2, ... , city N. Each road connects two cities, and is bidirectional. The problem contains Q queries. Each query consists of two distinct numbers a, b. (1 \u0026lt;\u003d a \u0026lt; b \u0026lt;\u003d N). Print \u0026quot;YES\u0026quot; if city a and city b are connected, \u0026quot;NO\u0026quot; otherwise.\u003c/p\u003e\u003cp\u003eInput: \u003c/p\u003e\u003cp\u003eFirst line contains two numbers N, M, Q. Each of the following M lines contains two numbers u, v.(1 \u0026lt;\u003d u \u0026lt; v \u0026lt;\u003d N) This means city u and city v are connected. Each of the following Q lines contains two numbers a, b. (1 \u0026lt;\u003d a \u0026lt; b \u0026lt;\u003d N) \u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eOutput:\u003c/p\u003e\u003cp\u003eJust put \u0026quot;YES\u0026quot; or \u0026quot;NO\u0026quot; on each line as explained above.\u003c/p\u003e\u003ch1\u003eSolution\u003c/h1\u003e\u003cp\u003eI put the solution for the above problem \u003ca href\u003d\"http://pastebin.com/AbckZLNU\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eAnd the following is the explanation.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e1\u003c/strong\u003e First you need to initialize an array p such that p[i] \u003d i for all i. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2\u003c/strong\u003e Write function \u0027find\u0027.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e3\u003c/strong\u003e Connect cities as we read input. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e4\u003c/strong\u003e Two cities a, b, are connected if and only if find(a) \u003d\u003d find(b).\u003c/p\u003e\u003cp\u003eWhat it does and how it works.\u003c/p\u003e\u003cp\u003eIn this solution, we see N cities as several disjoint sets of cities, where each set is a group of cities that are connected with each other. If two cities are in the same set, they are connected. If two cities are in different sets, they are not connected. \u003c/p\u003e\u003cp\u003eEach set has exactly one node \u003cem\u003ei\u003c/em\u003e whose \u0027parent\u0027 is itself \u003cem\u003ei\u003c/em\u003e(a.k.a. find(_i_) returns \u003cem\u003ei\u003c/em\u003e) . \u003c/p\u003e\u003cp\u003eThe step \u003cstrong\u003e1\u003c/strong\u003e means that we see each city as a disjoint set of one city. \u003c/p\u003e\u003cp\u003eThe function find in step \u003cstrong\u003e2\u003c/strong\u003e does two things. Find \u0027parent\u0027 and record it on an array p.\u003c/p\u003e\u003cp\u003eThe step \u003cstrong\u003e3\u003c/strong\u003e says that parent of parent of v is now the parent of u. That is, u and v are connected since they now have the same parent!\u003c/p\u003e\u003cp\u003eThe step \u003cstrong\u003e4\u003c/strong\u003e is now obvious. We \u0027find\u0027 the parent for each and compare. If they have the same \u0027parents\u0027, it means that they are in the same set, and thus they are connected!\u003c/p\u003e\u003cp\u003eFor deeper understanding, download the solution and check the parent of each node and how ti changes!\u003c/p\u003e\u003cp\u003eThank you very much for reading, and I hope this helps you have some new insight!\u003c/p\u003e\u003c/div\u003e","tags":[]}}