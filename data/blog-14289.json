{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1413396968,"rating":6,"authorHandle":"alv-r-","modificationTimeSeconds":1413397043,"id":14289,"title":"\u003cp\u003eHelp with Suffix Automaton Solution\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello all,\u003c/p\u003e\u003cp\u003eI\u0027m trying to solve this problem on UVa: \u003ca href\u003d\"http://uva.onlinejudge.org/index.php?option\u003dcom_onlinejudge\u0026amp;Itemid\u003d8\u0026amp;page\u003dshow_problem\u0026amp;category\u003d24\u0026amp;problem\u003d3783\"\u003ehttp://uva.onlinejudge.org/index.php?option\u003dcom_onlinejudge\u0026amp;Itemid\u003d8\u0026amp;page\u003dshow_problem\u0026amp;category\u003d24\u0026amp;problem\u003d3783\u003c/a\u003e (from ICPC South America Regional Finals 2011).\u003c/p\u003e\u003cp\u003eI\u0027ve seen how to solve it using Suffix Arrays/LCP Arrays. However, I\u0027m trying to solve it using a Suffix Automaton, mainly to learn more/get more used to it.\u003c/p\u003e\u003cp\u003eSo, my approach is this:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eConcatenate each file using a different separator $ (one that is not a-z).\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eBuild the Suffix Automaton for the resulting string\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eNow, instead of finding the end-sets of each node (the indexes on where the substrings represented by that node end), I use a bitmask on each node the following way: If index i would appear in the end-set of node n and i belongs to file f, turn f on in node n (n.mask |\u003d (1\u0026lt;\u0026lt;f)).\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eTo see the how many searchable subsets are there, I do a DFS from the root (ignoring any \u0027$/!/...\u0026quot; transitions) and count how many different bitmasks I have. (Also, I ignore the source node that represents the empty string).\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThe rationale behind this is that if the substring appears on indexes belonging to the files f0, f1..., that substring (and all substrings represented by that node) can be used to search that subset (and only that one). Ignoring the \u0027$\u0027-transitions should guarantee that we don\u0027t end up checking any invalid substring.\u003c/p\u003e\u003cp\u003eI\u0027m getting WA with this approach. (It gives the correct answer for the mojority of the test cases, though :( ).\u003c/p\u003e\u003cp\u003eCould anyone please help me find out what\u0027s wrong with this idea?\u003c/p\u003e\u003c/div\u003e","tags":["suffix automata","string","acm-icpc"]}}