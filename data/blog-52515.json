{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1497103743,"rating":0,"authorHandle":"just_solve_it","modificationTimeSeconds":1497105548,"id":52515,"title":"\u003cp\u003eРазбор 2012-2013 Тренировка СПбГУ B #2\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eТут будет разбор 2012-2013 Тренировка СПбГУ B #2. Если вы уже вдоволь подумали над этими задачами и у вас нет ни одной годной идеи, то тут будет разбор этих задач .\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/ysnvR1E45m/contest/100083/submit/A\"\u003eЗадача A\u003c/a\u003e\u003c/p\u003e\u003cp\u003eТут нужно просто в порядке обхода \u003ccode\u003eDFS\u003c/code\u003e запоминать времена входа и выхода из каждой вершины. Тогда вершина \u003ccode\u003ea\u003c/code\u003e является предком вершины \u003ccode\u003eb\u003c/code\u003e, если временной интервал \u003ccode\u003ea\u003c/code\u003e содержит временной интервал \u003ccode\u003eb\u003c/code\u003e. Для этого поучительно использовать:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eusing Time \u003d size_t;\nusing Interval \u003d std::pair\u0026lt;Time, Time\u0026gt;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/ysnvR1E45m/contest/100083/submit/B\"\u003eЗадача B\u003c/a\u003e\u003c/p\u003e\u003cp\u003eТут мы просто проходим \u003ccode\u003eDFS\u003c/code\u003e по графу и смотрим -- если мы можем перейти в предка данной вершины, то это и есть цикл. Тут, например, можно запоминать предка каждой вершины и \u0026quot;выбрасывать\u0026quot; пару вершин, которые являются началом и концом цикла. Для этого поучительно использовать:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eenum Status { NEW, LOOKING, LOOKED };\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/ysnvR1E45m/contest/100083/submit/C\"\u003eЗадача C\u003c/a\u003e\u003c/p\u003e\u003cp\u003eТут применяется стандартная идея -- до всех вершин, до которых мы можем добраться не проходя по мосту можно добраться двумя непересекающимися по рёбрам путями. Речь идет об ориентированных ребрах, поэтому следует запустить \u0026quot;режущий\u0026quot; \u003ccode\u003eDFS\u003c/code\u003e, который удаляет все ребра по которым проходит (в предположении что все они ориентированные). Запустив еще раз, но уже красящий, \u003ccode\u003eDFS\u003c/code\u003e, получим все вершины до которых можно добраться без мостов. Далее дело за малым -- тоже самое нужно сделать со всеми вершинами куда мы не попали, но если призадуматься, достаточно делать это в порядке обхода режущего \u003ccode\u003eDFS\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/ysnvR1E45m/contest/100083/submit/D\"\u003eЗадача D\u003c/a\u003e\u003c/p\u003e\u003cp\u003eТут стоит воспользоваться двумя наблюдениями -- если сыновья данной вершины (в дереве обхода \u003ccode\u003eDFS\u003c/code\u003e) могут добраться до ее предка, то это не точка сочленения, если это не корень конечно же. Если из корня мы переходим только в одного сына, то это также не точка сочленения. Легко видеть, что в противном случае мы имеем дело с точками сочленения.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/ysnvR1E45m/contest/100083/submit/E\"\u003eЗадача E\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЕсли переформулировать задачу, выйдет что-то вроде \u0026quot;найти минимальное множество \u003ccode\u003eV\u003c/code\u003e такое что из любой вершины графа существует путь до одной из вершин \u003ccode\u003eV\u003c/code\u003e\u0026quot;. Что же, сделаем пару замечаний -- если мы в дереве обхода \u003ccode\u003eDFS\u003c/code\u003e можем вернуться в родителя, то нет никакого смысла оставаться в вершине. Также, если по каким-то причинам в одном из сыновей уже есть пожарная станция, то возвращаться не имеет никакого смысла. И наконец, если все сыновья нашей вершины могут вернуться только в нее, а она не может попасть никуда кроме как в них, то стоит поставить в нее пожарную машину. Будет удобно пользоваться:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eenum Status { NEW, TO_PARENT, LOOKING, LOOKED };\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/ysnvR1E45m/contest/100083/submit/F\"\u003eЗадача F\u003c/a\u003e\u003c/p\u003e\u003cp\u003eТут следует отметить, что все вершины которые соответствуют одной вершине конденсации достижимы друг из друга. Поэтому стоит запустить из одной вершины два красящих \u003ccode\u003eDFS\u003c/code\u003e по обычным ребрам и инвертированным, чтобы получить все достижимые вершины как вершины покрашенные дважды. Стоит это делать осторожно и, например, при втором \u003ccode\u003eDFS\u003c/code\u003e красить только те вершины, которые были покрашены при первом, а затем применить трюк вроде того, который возникал при поиске мостов.\u003c/p\u003e\u003c/div\u003e","tags":[]}}