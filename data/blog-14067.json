{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1412089093,"rating":0,"authorHandle":"m.radwan","modificationTimeSeconds":1412091870,"id":14067,"title":"\u003cp\u003eWeeks 5-6 writeup\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello everyone I am currenly working on this week\u0027s editorial, however I would prefer that we follow a more collaborative method since writing editorials is somewhat exaustive :D so please if you solve a problem consider writing a short explanation for it. I will keep adding problems which I write in this editorial, until it\u0027s complete, if you want to write a problem just put it in a comment i\u0027ll put it in the editorial.\u003c/p\u003e\u003ch2\u003eDisjoint Pathes\u003c/h2\u003e\u003cp\u003eA dp on a tree problem, let\u0027s first root anywhere, we then observe that any path is either node to ancestor path, or a path going from one node to it\u0027s ancestor then to one of the ancestor descendants, solving the problem for a single path is not hard, we can use the current subtree root, and a flag saying that there\u0027s a path opened from the parent or not for example. The real problem here lies in the multiple paths, for example we have to 5 paths we can start 1 at the root, then give 2 to first child 1 to second child and 1 to last child, or 1, 2, 1 or 4, 0, 0, etc.. the number of such partitionings is indeed exponential so we can\u0027t use complete search to enumerate all of them.\u003cbr /\u003e Instead of doing so we follow another strategy we give all the paths to the first child and then the first child tries to take X paths and give the rest to the second child and so on..\u003cbr /\u003e The dp state then becomes an edge (denoting which subtree we are working on and which child we are currently at) instead of a node, and since the tree has n-1 nodes the solution is still linear.\u003cbr /\u003e This feels like doing a knapsack inside the dp on a tree, it\u0027s useful in many tree dp problems.\u003cbr /\u003e\u003c/p\u003e\u003ch2\u003eLine chart\u003c/h2\u003e\u003cp\u003eIf the constraints weren\u0027t that large, we could\u0027ve solved it using an O(n^2 * k) algorithm, to solve the problem we should speed up our solution.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eI will not explain the solution for this problem, but I\u0027ll explain a solution of a simpler problem which will help you solve this problem at ease.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eGiven an array with 10^5 numbers find the number of distinct increasing subsequences.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eLets first solve the problem if we didn\u0027t need distinct increasing subseqeunces.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eWe could solve it then using bottom up dynamic programming\u003cbr /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor(int i \u003d n-1;i\u0026gt;\u003d0;i--){\n   dp[i] \u003d 1;\n   for(int j \u003d i+1;j\u0026lt;n;j++)\n     if(a[j]\u0026gt;a[i])dp[i]+\u003ddp[j];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ebut how do we get the distinct increasing subsequences ? we first should see where the repetition comes from, for example if we have\u003cbr /\u003e 1 2 3 4\u003cbr /\u003e A B A C\u003cbr /\u003e the number of inc. subseq starting at 1 is {A, AB, ABC, AC}, number of inc. subseq starting at 3 is {A, AC} thus the first A contains whatever in the second A plus some more so if we take from both first A and second A we will end up having repetitions, we should modify the code as follows.\u003cbr /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor(int i \u003d n-1;i\u0026gt;\u003d0;i--){\n   dp[i] \u003d 1;\n   boolean[] v \u003d new boolean[n];\n   for(int j \u003d i+1;j\u0026lt;n;j++)\n     if(a[j]\u0026gt;a[i] \u0026amp;\u0026amp; !v[a[j]])\n     {\n     \tdp[i]+\u003ddp[j];\n     \tv[a[j]]\u003dtrue;\n     }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow that\u0027s still n^2, how do we move to nlgn ? use a datastructure in order to collect dp[j] such that j\u0026gt;i and a[j] \u0026gt; a[i], a binary indexed tree or segment tree would work, this tree has to be indexed using a[i]\u0027s not i\u0027s thus when you make a query you say querySum(a[i]+1, max(a[i])).\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eNotice here in this problem that knowing the order of operations helped us in using datastructures (using bottom up dyanmic programming)\u003cbr /\u003e\u003c/p\u003e\u003ch2\u003eNajkraci\u003c/h2\u003e\u003cp\u003eCount the number of shortest paths that each edge lies on, one useful tools for solving shortest path related problems is the shortest path dag, or that graph where any path is a shortest path, such a graph is constructed for each node S, we can obtain it easily by running shortest path algorithm from S, and each edge where d_S[i] + c[i][j] \u003d\u003d d_S[j] is in the shortest path dag.\u003c/p\u003e\u003cp\u003eNow after obtaining such a dag we can count the number of shortest paths starting at S where a given edge (i, j) lies on as: \u003cbr /\u003e The number of shortest paths from S to i * The number of shortest paths from j to some other node.\u003cbr /\u003e Both values can be obtained by using simple dynamic programming algorithm on that dag.\u003c/p\u003e\u003cp\u003eSo we do this for each node as S, and then sum all values for each edge.\u003c/p\u003e\u003c/div\u003e","tags":[]}}