{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1498176776,"rating":0,"authorHandle":"SAeed","modificationTimeSeconds":1498176836,"id":52834,"title":"\u003cp\u003eSPU Contest #11\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e \u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214187/problem/Blue\"\u003eBlue — How many trees?\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eDP\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eIf we placed the number from 1 to n, how can we build the trees? When choosing a number X as the root, then all the numbers from 1 to X — 1 will go to its left subtree, while all the numbers from X + 1 to n will go to its right subtree. Does this remind you of something? It\u0027s a nested ranges DP solution.\u003c/p\u003e\u003cp\u003ethe arguments of the function are the \u003ccode\u003eleft\u003c/code\u003e and \u003ccode\u003eright\u003c/code\u003e (the current range of numbers). Each time we try all the numbers between \u003ccode\u003eleft\u003c/code\u003e and right to be the root. Now how about the condition that trees length must be higher than or equal to \u003ccode\u003eh\u003c/code\u003e? Obviously we need also to pass our current \u003ccode\u003eheight\u003c/code\u003e to the function, to determine the valid formed trees from the non valid ones.\u003c/p\u003e\u003cp\u003eWhat are the options of forming a valid tree with a \u003ccode\u003eheight\u003c/code\u003e higher than or equal to \u003ccode\u003eh\u003c/code\u003e?\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eThe left subtree has a height of \u003ccode\u003eh\u003c/code\u003e or more, while the right subtree doesn\u0027t.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThe right subtree has a height of \u003ccode\u003eh\u003c/code\u003e or more, while the left subtree doesn\u0027t.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eBoth the left and the right subtrees have the height of \u003ccode\u003eh\u003c/code\u003e or more.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSo, we need to add an additional flag to our DP state, indicating whether we need to build a tree that is \u003ccode\u003esmallerThanH\u003c/code\u003e or greater or equal to it (If we want to build the tree smaller than \u003ccode\u003eh\u003c/code\u003e, both left and right child must have a \u003ccode\u003eheight\u003c/code\u003e smaller than h.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n^4)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\nint h;\nll memo[36][36][36][2];\nll dp(int lo, int hi, int height, int smallerThanH){\n\tif (lo \u003d\u003d hi){\n\t\treturn (smallerThanH \u003d\u003d (height + 1 \u0026lt; h));\n\t}\n\n\tll \u0026amp;ret \u003d memo[lo][hi][height][smallerThanH];\n\tif (ret !\u003d -1) return ret;\n\n\tret \u003d dp(lo + 1, hi, height + 1, smallerThanH); // root is lo\n\tfor (int root \u003d lo + 1; root \u0026lt; hi; root++){\n\t\tif (smallerThanH) ret +\u003d dp(lo, root - 1, height + 1, 1) * dp(root + 1, hi, height + 1, 1);\n\t\telse{\n\t\t\tret +\u003d dp(lo, root - 1, height + 1, 1) * dp(root + 1, hi, height + 1, 0);\n\t\t\tret +\u003d dp(lo, root - 1, height + 1, 0) * dp(root + 1, hi, height + 1, 1);\n\t\t\tret +\u003d dp(lo, root - 1, height + 1, 0) * dp(root + 1, hi, height + 1, 0);\n\t\t}\n\t}\n\tret +\u003d dp(lo, hi - 1, height + 1, smallerThanH); // root is hi\n\treturn ret;\n}\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tint n;  cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; h;\n\tmemset(memo, -1, sizeof memo);\n\tcout \u0026lt;\u0026lt; dp(1, n, 0, 0) \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214187/problem/Green\"\u003eGreen — Biridian Forest\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eBFS\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eWe should take any shortest path from S to E (yes, any!). We will see why this is optimal at the end. If a breeder can reach E faster than or equal to us, then he will battle us. This is since he can simply walk to E and waits for us there.\u003c/p\u003e\u003cp\u003eOtherwise, they can never battle us by contradiction. Assume they battled us, but they cannot reach cell E from their location faster or equal to us. If the battle us in cell X, then cell X is part of the shortest path from S to E that you are travelling. Since he is able to battle us there, he must be able to arrive at cell X \u0026lt;\u003d us. But then, that means he can walk from X to E and reach E before or equal to us! Contradiction.\u003c/p\u003e\u003cp\u003eThis is optimal, since any breeder that we battle in this solution must also be battled in any other solution (the other breeders should immediately go to E and wait).\u003c/p\u003e\u003cp\u003eYou can use BFS once from exit cell to obtain the shortest paths from each breeder to it.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n x m)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint n, m;\nint dx[4] \u003d { 0, 0, -1, 1 };\nint dy[4] \u003d { 1, -1, 0, 0 };\nchar G[1010][1010];\nint dist[1010][1010];\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tint endX, endY, startX, startY;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) for (int j \u003d 0; j \u0026lt; m; j++){\n\t\tcin \u0026gt;\u0026gt; G[i][j];\n\t\tif (G[i][j] \u003d\u003d \u0027E\u0027) endX \u003d i, endY \u003d j;\n\t\tif (G[i][j] \u003d\u003d \u0027S\u0027) startX \u003d i, startY \u003d j;\n\t}\n\tfor (int i \u003d 0; i \u0026lt; n; i++) for (int j \u003d 0; j \u0026lt; m; j++) dist[i][j] \u003d 1e9;\n\tqueue\u0026lt;pair\u0026lt;int, pair\u0026lt;int, int\u0026gt; \u0026gt; \u0026gt; q;\n\tq.push(make_pair(0, make_pair(endX, endY)));\n\tdist[endX][endY] \u003d 0;\n\twhile (!q.empty()){\n\t\tint x \u003d q.front().second.first, y \u003d q.front().second.second, steps \u003d q.front().first;\n\t\tq.pop();\n\t\tfor (int i \u003d 0; i \u0026lt; 4; i++){\n\t\t\tint u \u003d x + dx[i];\n\t\t\tint v \u003d y + dy[i];\n\t\t\tif (u \u0026lt; 0 || u \u0026gt;\u003d n || v \u0026lt; 0 || v \u0026gt;\u003d m) continue;\n\t\t\tif (G[u][v] \u003d\u003d \u0027T\u0027) continue;\n\t\t\tif (dist[u][v] !\u003d 1e9) continue;\n\t\t\tdist[u][v] \u003d steps + 1;\n\t\t\tq.push(make_pair(steps + 1, make_pair(u, v)));\n\t\t}\n\t}\n\n\tint ans \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) for (int j \u003d 0; j \u0026lt; m; j++){\n\t\tif (G[i][j] \u0026gt;\u003d \u00270\u0027 \u0026amp;\u0026amp; G[i][j] \u0026lt;\u003d \u00279\u0027 \u0026amp;\u0026amp; dist[i][j] \u0026lt;\u003d dist[startX][startY]) ans +\u003d (G[i][j] - \u00270\u0027);\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214187/problem/Purple\"\u003ePurple — Save Luke\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eMath\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eIt\u0027s a simple math problem. The given condition happens when:\u003c/p\u003e\u003cp\u003e\u003ccode\u003eThe distance which the first presser moved + d + the distance which the second presser moved \u003d L\u003c/code\u003e\u003c/p\u003e\u003cp\u003eThis means that:\u003c/p\u003e\u003cp\u003e\u003ccode\u003ev1 x t + d + v2 x t \u003d L\u003c/code\u003e\u003c/p\u003e\u003cp\u003eThis equation has only \u003ccode\u003et\u003c/code\u003e as an unknown variable, we simply calculate it:\u003c/p\u003e\u003cp\u003e\u003ccode\u003et \u003d (L - d) / (v1 + v2)\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(1)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tll d, l, v1, v2; cin \u0026gt;\u0026gt; d \u0026gt;\u0026gt; l \u0026gt;\u0026gt; v1 \u0026gt;\u0026gt; v2;\n\tcout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(6) \u0026lt;\u0026lt; (double)(l - d) / (v1 + v2) \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214187/problem/Red\"\u003eRed — Saitama Destroys Hotel\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eSimulation\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe elevator moves from the floor number \u003ccode\u003es\u003c/code\u003e to the first floor. At each floor he either picks all the passengers immediately if there arrival time is smaller than the time the elevator took to get here, or the elevator waits for an amount of time till the latest passenger arrives.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nvector\u0026lt;int\u0026gt; G[1111];\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tint n, s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s;\n\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\tint f, t; cin \u0026gt;\u0026gt; f \u0026gt;\u0026gt; t;\n\t\tG[f].push_back(t);\n\t}\n\tint timer \u003d 0;\n\tfor (int i \u003d s; i \u0026gt;\u003d 1; i--){\n\t\tfor (int j \u003d 0; j \u0026lt; G[i].size(); j++) timer \u003d max(timer, G[i][j]);\n\t\ttimer++;\n\t}\n\tcout \u0026lt;\u0026lt; timer \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214187/problem/Yellow\"\u003eYellow — Comparing Two Long Integers\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAdHoc\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eIf we read both number as strings, and made them of the same length, we can simply compare them with \u003ccode\u003e\u0026lt; \u003d\u003d \u0026gt;\u003c/code\u003e operators. Just read the number as strings then keep adding zeros to their left until their size is equal to \u003ccode\u003e10^6\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(10^6)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nvector\u0026lt;int\u0026gt; G[1111];\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tstring s1, s2; cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2;\n\treverse(s1.begin(), s1.end());\n\treverse(s2.begin(), s2.end());\n\tint mx \u003d max(s1.size(), s2.size());\n\twhile (s1.size() \u0026lt; mx) s1.push_back(\u00270\u0027);\n\twhile (s2.size() \u0026lt; mx) s2.push_back(\u00270\u0027);\n\treverse(s1.begin(), s1.end());\n\treverse(s2.begin(), s2.end());\n\tif (s1 \u0026lt; s2) cout \u0026lt;\u0026lt; \u0026quot;\u0026lt;\u0026quot; \u0026lt;\u0026lt; endl;\n\telse if (s1 \u0026gt; s2) cout \u0026lt;\u0026lt; \u0026quot;\u0026gt;\u0026quot; \u0026lt;\u0026lt; endl;\n\telse cout \u0026lt;\u0026lt; \u0026quot;\u003d\u0026quot; \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}