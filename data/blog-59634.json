{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1527063809,"rating":0,"authorHandle":"strawberrry","modificationTimeSeconds":1527063809,"id":59634,"title":"\u003cp\u003eRound #246 solution\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003eA. Choosing Teams\u003c/h4\u003e \u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e分类：\u003c/strong\u003e \u003ccode\u003egreedy\u003c/code\u003e\u003c/p\u003e \u003c/blockquote\u003e\u003cp\u003e直接统计那些剩余次数大于 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e 的人， 记为 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e\u003c/span\u003e ，那么答案就是 \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9b/13/9b1375ce4b9236add2c53417dfa67db82f2b2281.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e 。\u003c/p\u003e\u003ch4\u003eB. Football Kit\u003c/h4\u003e \u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e分类：\u003c/strong\u003e \u003ccode\u003egreedy\u003c/code\u003e\u003c/p\u003e \u003c/blockquote\u003e\u003cp\u003e用 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003evis\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e 记录主场球衣颜色为 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e 的球队数，那么对于每只球队，客场衣服会重复 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003evis\u003c/i\u003e[\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e]\u003c/span\u003e 次，贪心的让他们这些时候都穿主场衣服，答案就是 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1 + \u003ci\u003evis\u003c/i\u003e[\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e]\u003c/span\u003e 和 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1 - \u003ci\u003evis\u003c/i\u003e[\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e]\u003c/span\u003e 。\u003c/p\u003e\u003ch4\u003eC. Prime Swaps\u003c/h4\u003e \u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e分类：\u003c/strong\u003e \u003ccode\u003emath\u003c/code\u003e \u003ccode\u003ebrute force\u003c/code\u003e\u003c/p\u003e \u003c/blockquote\u003e\u003cp\u003e用 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e 维护数 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e 现在位于哪，直接暴力维护前 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e 个元素的有序的，那么对于第 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e 个位置，最终是要换到 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e 去的，又由哥德巴赫猜想，任意数可以拆成几个素数和，因此预处理出 \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e 内素数，然后每次直接暴力 \u003ccode\u003efor\u003c/code\u003e 一遍 \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003epos\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e]\u003c/span\u003e 对于区间是素数长度的直接交换，最终总能得到答案。\u003c/p\u003e\u003ch4\u003eD. Prefixes and Suffixes\u003c/h4\u003e \u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e分类：\u003c/strong\u003e \u003ccode\u003estrings\u003c/code\u003e \u003ccode\u003edp\u003c/code\u003e\u003c/p\u003e \u003c/blockquote\u003e\u003cp\u003e对于一个字符串 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e 前缀 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[1..\u003ci\u003el\u003c/i\u003e]\u003c/span\u003e 是否有后缀 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e..\u003ci\u003en\u003c/i\u003e]\u003c/span\u003e 与之匹配，且 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e + 1 \u003d \u003ci\u003el\u003c/i\u003e\u003c/span\u003e ，仔细观察，发现 \u003ccode\u003ekmp\u003c/code\u003e 算法的 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enext\u003c/i\u003e[]\u003c/span\u003e 数组就是维护这个东西—— \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enext\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e 表示子串 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[1..\u003ci\u003ei\u003c/i\u003e - 1]\u003c/span\u003e 后缀与前缀不相交匹配的 \u003cstrong\u003e最大\u003c/strong\u003e 长度。那么很容易通过递归 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enext\u003c/i\u003e[]\u003c/span\u003e 得到这个串每一个能匹配后缀的前缀在哪。\u003c/p\u003e\u003cp\u003e接下来问题就在怎么算这个子串出现几次。考虑这样一个过程， \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[1..\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e]\u003c/span\u003e 和 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e..\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e]\u003c/span\u003e 匹配，那么对于前缀串 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[1..\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e]\u003c/span\u003e 的 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enext\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e]\u003c/span\u003e 一定能包含 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e ，且接下来答案一定不在 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e + 1..\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e]\u003c/span\u003e 中。那么倒着递推的话，每个后缀只会对前面的前缀有贡献，这是一个子问题的过程。不妨令 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e (\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e 表示前缀 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[1..\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e 出现过几次，那么就有 \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d1/d2/d1d2622b3557b9d23cbee5cc57051a73dcf1a5ad.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e ，倒着递推就好。\u003c/p\u003e\u003cp\u003e而我们最终要算每个有效的答案，就是算 \u003cspan class\u003d\"tex-span\"\u003e[1..\u003ci\u003elen\u003c/i\u003e]\u003c/span\u003e 中那些位置 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e 满足 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e (\u003ci\u003ei\u003c/i\u003e) ≠ 0\u003c/span\u003e 的位置！\u003c/p\u003e\u003ch4\u003eE. Square Tiling\u003c/h4\u003e \u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e分类：\u003c/strong\u003e \u003ccode\u003egreedy\u003c/code\u003e\u003c/p\u003e \u003c/blockquote\u003e\u003cp\u003e因为字典序是从上到下，从左到右，那么也贪心地按这样递归地填即可，每次枚举能填的最宽的最小 \u003cstrong\u003e合法\u003c/strong\u003e 矩形，对于最小的判别，直接枚举该位置四边颜色是否与它相同即可。\u003c/p\u003e\u003c/div\u003e","tags":[]}}