{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1496668733,"rating":0,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1496762061,"id":52405,"title":"\u003cp\u003eNotes on Codeforces Beta Round #50, A, B, C(Use Pascal\u0027s Triangle to calculate the probability that \u0026quot;at least K events occur among N events\u0026quot;)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA. Presents\u003c/p\u003e\u003cp\u003eThis problem can be solved by starting from the 0-th day and implement the following operations. \u003c/p\u003e\u003cp\u003eFor the i-th day (initially i\u003d0), we check the next K days, i.e., from (i+1)-th to (i+K)-th day. If no holidays are included, we increase the number of presents by one and move to the (i+K)-th day; otherwise we add the number of holidays to the current number of presents and move to the last holiday. Note that if i+K\u0026gt;N, it is sufficient to only count the number of holidays from the i-th day to the N-th day, and add it to the number of presents.\u003c/p\u003e\u003cp\u003eB. Cutting Jigsaw Puzzle\u003c/p\u003e\u003cp\u003eThe solution is straightforward but might be a little complicated to code.\u003c/p\u003e\u003cp\u003eAt first, we should enumerate all the feasible sizes of pieces. A size with x*y is feasible if x and y are factors of A and B, respectively. For each feasible size x*y, we find out all the pieces and check if there exist any two pieces that are exactly the same. Any two pieces are exactly the same if at least one of the following conditions can be satisfied:\u003c/p\u003e\u003cp\u003e1) They are the same without any rotations;\u003c/p\u003e\u003cp\u003e2) They are the same if the second one is rotated with 180 degrees;\u003c/p\u003e\u003cp\u003e3) They are the same if the second one is rotated with 90 degrees;\u003c/p\u003e\u003cp\u003e4) They are the same if the second one is rotated with 270 degrees;\u003c/p\u003e\u003cp\u003eIf there are not any two pieces that are the same, then this size x*y results in a good puzzle, and we should further record the minimum size according to the requirements.\u003c/p\u003e\u003cp\u003eC. First Digit Law\u003c/p\u003e\u003cp\u003eThis problem can be divided into two subproblems.\u003c/p\u003e\u003cp\u003eSubproblem 1): given the interval [L,R], how to count the number of integers whose most significant digit is 1? Suppose that F(n) is a function which calculates the number of integers from 1 to n, and thus this subproblem can be solved by computing F(R)-F(L). To implement such a function, we can try 1,10,100,...,10^m, until 10^m\u0026lt;\u003dn, and the answer will be 1+10+100+...+10^(m-1)+min(10^m, n-10^m+1). Moreover, we can immediately calculate the probability of selecting an integer whose most significant digit is 1 as (F(R)-F(L))/(R-L+1);\u003c/p\u003e\u003cp\u003eSubproblem 2): given N events and the probability that every event occurs, how to calculate the probability that at least K of them occur? A straightforward method that enumerates all the feasible combination may fail since the number is likely to be quite huge. However, we can use DP, like Pascal\u0027s Triangle, to avoid the above difficulty. We use D[n][m] to denote the probability that for the first n events, exactly m of them occur. One can check that D[n][m]\u003dD[n-1][m-1]*p[n]+D[n-1][m]*(1-p[n]), where p[n] denotes the probability that the n-th event occurs, while the initialization is done by setting D[0][0]\u003d1. Then, the answer is just D[N][K]+D[N][K+1]+...+D[N][N].\u003c/p\u003e\u003c/div\u003e","tags":[]}}