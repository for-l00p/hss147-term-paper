{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1524597705,"rating":98,"authorHandle":"gepardo","modificationTimeSeconds":1524598813,"id":59092,"title":"\u003cp\u003eSqrt-tree (part 2): modifications in O(sqrtN), lazy propagation\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello, Codeforces!\u003c/p\u003e\u003cp\u003eSome time ago I created a blog post about \u003ca href\u003d\"//codeforces.com/blog/entry/57046\"\u003eSqrt-tree\u003c/a\u003e. If you didn\u0027t read this post, please do it now.\u003c/p\u003e\u003cp\u003eBut earlier, we were able just to answer the queries on a static array. Now we will make our structure more \u0026quot;dynamic\u0026quot; and add update queries there.\u003c/p\u003e\u003cp\u003eSo, let\u0027s begin!\u003c/p\u003e\u003ch1\u003eUpdate queries\u003c/h1\u003e\u003cp\u003eConsider a query \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/36/55/36559675b9050d2a2d8518c24a17d673145c9fb1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e that does the assignment \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eval\u003c/i\u003e\u003c/span\u003e. We need to perform this query fast enough.\u003c/p\u003e\u003ch2\u003eNaive approach\u003c/h2\u003e\u003cp\u003eFirst, let\u0027s take a look of what is changed in our tree when a single element changes. Consider a tree node with length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and its arrays: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/58/30/5830dcfb3792a9975c8d715aac0bbe994cadef8f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/dd/76/dd76bf13df282941dccce1fac1ff1ebde201f3a2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/17/fe/17feaf63a139ca7c5ee92d6d3d80a9eabb7bc81c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. It is easy to see that only \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/dc/df/dcdf2279c09494c8351731e7e93837f46e1eec3e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e elements from \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/58/30/5830dcfb3792a9975c8d715aac0bbe994cadef8f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/dd/76/dd76bf13df282941dccce1fac1ff1ebde201f3a2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e will change (only inside the block with the changed element). \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/17/fe/17feaf63a139ca7c5ee92d6d3d80a9eabb7bc81c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e will change \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e)\u003c/span\u003e elements. Therefore, total update count per node is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe remember that any element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is present in exactly one tree node at each layer. Root node (layer \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e) has length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e, nodes on layer \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e have length \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, nodes on layer \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e have length \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/48/e0/48e077a519a560f3c071503a77c1f751e9a1d7f7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, etc. So the time complexity per update is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/21/ab/21ab4c741396ba0b6de0c444597ddb0d025d7d76.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eBut it\u0027s too slow. Can it be done faster?  \u003c/p\u003e\u003ch2\u003eA sqrt-tree inside the sqrt-tree\u003c/h2\u003e\u003cp\u003eNote that the bottleneck of updating is rebuilding \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/17/fe/17feaf63a139ca7c5ee92d6d3d80a9eabb7bc81c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e of the root node. To optimize the tree, let\u0027s get rid of it! Instead of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/17/fe/17feaf63a139ca7c5ee92d6d3d80a9eabb7bc81c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e array, we store another sqrt-tree for root. Let\u0027s call it \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/31/2d/312d376665c22b228fccecb9f50b6bc25a622b72.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. It plays the same role as \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/17/fe/17feaf63a139ca7c5ee92d6d3d80a9eabb7bc81c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e— answers the queries on segments of blocks. Note that the rest of the tree nodes don\u0027t have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/31/2d/312d376665c22b228fccecb9f50b6bc25a622b72.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, they keep their \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/17/fe/17feaf63a139ca7c5ee92d6d3d80a9eabb7bc81c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e arrays.\u003c/p\u003e\u003cp\u003eA sqrt-tree is \u003cem\u003e\u003cstrong\u003eindexed\u003c/strong\u003e\u003c/em\u003e, if its root node has \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/31/2d/312d376665c22b228fccecb9f50b6bc25a622b72.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. A sqrt-tree with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/17/fe/17feaf63a139ca7c5ee92d6d3d80a9eabb7bc81c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e array in its root node is \u003cem\u003e\u003cstrong\u003eunindexed\u003c/strong\u003e\u003c/em\u003e. Note that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/31/2d/312d376665c22b228fccecb9f50b6bc25a622b72.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cstrong\u003eis \u003cem\u003eunindexed\u003c/em\u003e itself\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eSo, for the \u003cem\u003eindexed\u003c/em\u003e tree, we have the following algorithm for updating:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eUpdate \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/58/30/5830dcfb3792a9975c8d715aac0bbe994cadef8f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/dd/76/dd76bf13df282941dccce1fac1ff1ebde201f3a2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eUpdate \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/31/2d/312d376665c22b228fccecb9f50b6bc25a622b72.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. It has length \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and we need to update only one item in it (that represents the changed block). So, the time complexity for this step is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. We can use the previous algorithm to do it.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eGo into the child node that represents the changed block and update it in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, again with the previously described algorithm.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eNote that the query complexity is still \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e: we need to use \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/31/2d/312d376665c22b228fccecb9f50b6bc25a622b72.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e in query no more than once, and this will take \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time.\u003c/p\u003e\u003cp\u003eSo, total time complexity for updating a single element is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Hooray! :)\u003c/p\u003e\u003ch2\u003eImplementation\u003c/h2\u003e\u003cp\u003eIt is just a slightly modified code of a static sqrt-tree. \u003ca href\u003d\"https://gist.github.com/alex65536/0f4e69f49481791a9088d16df196789d#file-sqrttree-hpp\"\u003eHere it is\u003c/a\u003e.\u003c/p\u003e\u003ch1\u003eLazy propagation\u003c/h1\u003e\u003cp\u003eSqrt-tree also can do things like assigning an element on a segment. \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5c/58/5c588bb68678bcdb8245e432fd33a6411a61efe3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e means \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003er\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThere are two approaches to do this: one of them does \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ae/cd/aecd0c441ea52d25565ca08fbe0d70919ffbe147.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/13/78/1378afd41d471c5f606121f7097a0c663b00875c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, keeping \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e per query. The second one does \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ae/cd/aecd0c441ea52d25565ca08fbe0d70919ffbe147.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, but the query complexity becomes \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cd/60/cd609b05b5bc5d82ab32907fda94102d347c048a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eWe will do lazy propagation in the same way as it is done in segment trees: we mark some nodes as \u003cem\u003elazy\u003c/em\u003e, meaning that we\u0027ll push them when it\u0027s necessary. But one thing is different from segment trees: pushing a node is expensive, so it cannot be done in queries. On the layer \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, pushing a node takes \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time. So, we don\u0027t push nodes in query, we only see if the parent or current node is \u003cem\u003elazy\u003c/em\u003e, and just take it into account while performing queries.\u003c/p\u003e\u003ch2\u003eFirst approach\u003c/h2\u003e\u003cp\u003eIn the first approach, we say that only nodes on layer \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e (with length \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3c/40/3c40dae16381a010bb09e90a3f240afa84c52607.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e) can be \u003cem\u003elazy\u003c/em\u003e. When pushing such node, it updates all its subtree including itself in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/13/78/1378afd41d471c5f606121f7097a0c663b00875c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. The \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ae/cd/aecd0c441ea52d25565ca08fbe0d70919ffbe147.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e process is done as follows:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eConsider the nodes on layer \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and blocks corresponding to them.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eSome blocks are entirely covered by \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ae/cd/aecd0c441ea52d25565ca08fbe0d70919ffbe147.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Mark them as \u003cem\u003elazy\u003c/em\u003e in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eSome blocks are partially covered. Note there are no more than two blocks of this kind. Rebuild them in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/13/78/1378afd41d471c5f606121f7097a0c663b00875c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. If they were \u003cem\u003elazy\u003c/em\u003e, take it into account.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eUpdate \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/58/30/5830dcfb3792a9975c8d715aac0bbe994cadef8f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/dd/76/dd76bf13df282941dccce1fac1ff1ebde201f3a2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for partially covered blocks in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (because there are only two such blocks).\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eRebuild the \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/31/2d/312d376665c22b228fccecb9f50b6bc25a622b72.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/13/78/1378afd41d471c5f606121f7097a0c663b00875c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSo we can do \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ae/cd/aecd0c441ea52d25565ca08fbe0d70919ffbe147.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e fast. But how lazy propagation affects queries? They will have the following modifications:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eIf our query entirely lies in a \u003cem\u003elazy\u003c/em\u003e block, calculate it and take \u003cem\u003elazy\u003c/em\u003e into account. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf our query consists of many blocks, some of which are \u003cem\u003elazy\u003c/em\u003e, we need to take care of \u003cem\u003elazy\u003c/em\u003e only on the leftmost and the rightmost block. The rest of the blocks are calculated using \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/31/2d/312d376665c22b228fccecb9f50b6bc25a622b72.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, which already knows the answer even on \u003cem\u003elazy\u003c/em\u003e block (because it\u0027s rebuilt after each modification). \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThe query complexity still remains \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e.\u003c/p\u003e\u003ch2\u003eSecond approach\u003c/h2\u003e\u003cp\u003eIn this approach, each node can be \u003cem\u003elazy\u003c/em\u003e (except root). Even nodes in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/31/2d/312d376665c22b228fccecb9f50b6bc25a622b72.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e can be \u003cem\u003elazy\u003c/em\u003e. So, while processing a query, we have to look for \u003cem\u003elazy\u003c/em\u003e tags in all the parent nodes, i. e. query complexity will be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cd/60/cd609b05b5bc5d82ab32907fda94102d347c048a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eBut \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ae/cd/aecd0c441ea52d25565ca08fbe0d70919ffbe147.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e will become faster. It will look in the following way:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ae/cd/aecd0c441ea52d25565ca08fbe0d70919ffbe147.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e fully covers some blocks. So, \u003cem\u003elazy\u003c/em\u003e tags are added to them. It is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eUpdate \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/58/30/5830dcfb3792a9975c8d715aac0bbe994cadef8f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/dd/76/dd76bf13df282941dccce1fac1ff1ebde201f3a2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for partially covered blocks in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (because there are only two such blocks).\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eDo not forget to update the index. It is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (we use the same algorithm as in the next item). \u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eFor partially covered blocks, we go to the nodes representing them and call \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ae/cd/aecd0c441ea52d25565ca08fbe0d70919ffbe147.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e recursively (reminds something, doesn\u0027t it? :) ).\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eNote that when we do the recursive call, we do prefix or suffix \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ae/cd/aecd0c441ea52d25565ca08fbe0d70919ffbe147.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. But for prefix and suffix updates we can have no more than one partially covered child. So, we visit one node on layer \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, two nodes on layer \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e and two nodes on any deeper level. So, the time complexity will be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/11/5b/115b32251c41f5e15d30d4aabaf5da5e20fabf4f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. The approach here is similar to the segment tree mass update.\u003c/p\u003e\u003ch2\u003eImplementation\u003c/h2\u003e\u003cp\u003eI am too lazy (like a node in an sqrt-tree :) ) to write the implementation of lazy propagation on an sqrt-tree. So, I leave it as an exercise. If someone provides an implementation for this, I\u0027ll post it here mentioning the author.\u003c/p\u003e\u003ch1\u003eConclusion\u003c/h1\u003e\u003cp\u003eAs we can see, sqrt-tree can perform update queries and do lazy propagation. So, it provides the same functionality as segment trees, but with faster queries. The disadvantage is slow update time, but sqrt-trees can be helpful if we have many (\u003cspan class\u003d\"tex-span\"\u003e ≈ 10\u003csup class\u003d\"upper-index\"\u003e7\u003c/sup\u003e\u003c/span\u003e) queries but not many updates.\u003c/p\u003e\u003cp\u003eThanks for reading this post. Feel free to write in comments if there are mistakes in it or something is not clear. I hope that this data structure will be helpful for you.\u003c/p\u003e\u003cp\u003eI will publish another one post about sqrt-tree soon.\u003c/p\u003e\u003cp\u003eThanks to \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Vladik\" title\u003d\"Candidate Master Vladik\"\u003eVladik\u003c/a\u003e for inspiring me to write this post.\u003c/p\u003e\u003c/div\u003e","tags":["data structure","sqrt-decomposition","tree","log log n","implement yourself","lazy","segment tree 2.0"]}}