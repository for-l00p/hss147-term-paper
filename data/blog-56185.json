{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1512484049,"rating":0,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1512484049,"id":56185,"title":"\u003cp\u003eNotes on Codeforces Beta Round #98, A, B, C, D, E (Segment tree from top to bottom)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/137/problem/A\" title\u003d\"Codeforces Beta Round 98 (Div. 2)\"\u003e137A - Postcards and photos\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe scan the sequence from left to right, and count the number of consecutive \u0027C\u0027s and \u0027P\u0027s. For each such subsequence of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e, it contributes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e / 5 + (\u003ci\u003em\u003c/i\u003e%5! \u003d 0)\u003c/span\u003e to the final answer.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/137/problem/B\" title\u003d\"Codeforces Beta Round 98 (Div. 2)\"\u003e137B - Permutation\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe adopt a hash table to record the integers that have been appearing in the sequence. Then, the answer is just the number of integers that are not stored in the hash table. \u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/137/problem/C\" title\u003d\"Codeforces Beta Round 98 (Div. 2)\"\u003e137C - History\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe sort the events in an increasing order of their beginning time. Then, we scan the events from the last one to the first one, and for each one we check whether it can be completely covered by any other event. We denote the ending time of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th event in the sorted sequence as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e. It is obvious that only the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/span\u003e events can completely cover it, and thus it suffices to check whether there is such an index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e \u0026lt; \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e] \u0026gt; \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e. Equivalently, we can check \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e \u003d 0, 1, ..., \u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e] \u0026gt; \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e. Therefore, we adopt a prefix array to record the maximum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003em\u003c/i\u003e]\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e \u003d 1, 2, ..., \u003ci\u003em\u003c/i\u003e\u003c/span\u003e, and problem is solved.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/137/problem/D\" title\u003d\"Codeforces Beta Round 98 (Div. 2)\"\u003e137D - Palindromes\u003c/a\u003e\u003c/p\u003e\u003cp\u003eA DP problem. At first, we use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e to denote the minimum number of changes we need to convert the substring starting from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e while ending at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, to a palindrome, which can be computed with complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNext, we consider how to describe the rules of dividing the original string into shorter ones with \u0027+\u0027, since this helps determine the recursive formula of DP. Suppose that we are going to add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e \u0027+\u0027s, and these \u0027+\u0027 are always added from left to right. For instance, given that \u0027abcdefg\u0027 has been divided into \u0027ab\u0027+\u0027cdefg\u0027, if we will add another \u0027+\u0027, then it can only added among \u0027cdefg\u0027 but \u0027ab\u0027 can not be divided any more. It can be shown that with this rule, the original string can always be divided into any shorter ones and thus no potential answer will be missed.\u003c/p\u003e\u003cp\u003eNow, we use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e to denote that we have added \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e \u0027+\u0027s and the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th \u0027+\u0027 is at position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, and the minimum number to convert these substrings (the ones before \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e) into palindrome ones is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eThen, for state \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e, it can transfer to states \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1][\u003ci\u003ej\u003c/i\u003e + \u003ci\u003enextj\u003c/i\u003e]\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e + \u003ci\u003enextj\u003c/i\u003e \u0026gt; \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e + \u003ci\u003enextj\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1][\u003ci\u003ej\u003c/i\u003e + \u003ci\u003enextj\u003c/i\u003e] \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1][\u003ci\u003ej\u003c/i\u003e + \u003ci\u003enextj\u003c/i\u003e], \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e] + \u003ci\u003ep\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e + 1][\u003ci\u003ej\u003c/i\u003e + \u003ci\u003enextj\u003c/i\u003e])\u003c/span\u003e. Also, we should record the “paths” so that we can trace back the division pattern.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/137/problem/E\" title\u003d\"Codeforces Beta Round 98 (Div. 2)\"\u003e137E - Last Chance\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe main idea is that for each position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, we calculate the longest substring that satisifes the requirement. We use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e to denote the total number of vowels in the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e positions.\u003c/p\u003e\u003cp\u003eAt first, for any substring of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e, we transfer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e ≤ 2\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e into \u003cspan class\u003d\"tex-span\"\u003e3\u003ci\u003ev\u003c/i\u003e ≤ 2\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e. Then, for any position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, we should find out the maximum index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e ≥ \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e so that \u003cspan class\u003d\"tex-span\"\u003e3(\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e] - \u003ci\u003ep\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e - 1]) ≤ 2(\u003ci\u003ej\u003c/i\u003e - (\u003ci\u003ei\u003c/i\u003e - 1))\u003c/span\u003e, which is equivalent to \u003cspan class\u003d\"tex-span\"\u003e3\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e] - 2\u003ci\u003ej\u003c/i\u003e ≤ 3\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e - 1] - 2(\u003ci\u003ei\u003c/i\u003e - 1)\u003c/span\u003e. Therefore, we could build a segment tree based on \u003cspan class\u003d\"tex-span\"\u003e3\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e] - 2\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. For any node in the tree, it stores the minimum value of its two child nodes (like a minimum heap). Then, for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, the maximum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e can be computed with complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e, by traversal from top to bottom (it is also possible that no \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e exists). Finally, we only need scan all the positions and find the maximum length.\u003c/p\u003e\u003c/div\u003e","tags":[]}}