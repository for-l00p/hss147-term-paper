{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1456497208,"rating":3,"authorHandle":"Franklyn_W","modificationTimeSeconds":1456497208,"id":43386,"title":"\u003cp\u003eProblem 629D (heaviest increasing subsequence) discussion\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eProblem \u003ca href\u003d\"/contest/629/problem/D\" title\u003d\"Codeforces Round 343 (Div. 2)\"\u003e629D - Babaei and Birthday Cake\u003c/a\u003e asks for the heaviest strictly increasing subsequence of a set of volumes. When I saw this problem (in practice) I immediately recognized that this was probably a well-known problem, so I looked up code. I found some code from StackOverflow, but it occured to me that this code only found the heaviest nondecreasing subsequence. Not willing to change the code too much, I came up with the following idea. If taking the array one by one is like: \u003c/p\u003e \u003cpre\u003e\u003ccode\u003el \u003d []\nfor r in range(n):\n    k \u003d int(input())\n    l.append(k)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ethen in order to make the heaviest strictly increasing subsequence roughly equal to the heaviest nondecreasing subsequence, do something along these lines. This should work, because the epsilon is small enough such that the relative order should not be changed, but equal terms will have a difference: terms which come closer to the front will be ever so slightly larger than equal terms closer to the end. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003el \u003d []\nfor r in range(n):\n    k \u003d int(input())\n    l.append(k + (n-r)*0.000001)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI submitted this idea, \u003ca href\u003d\"/contest/629/submission/16347971\" title\u003d\"Submission 16347971 by Franklyn_W\"\u003e16347971\u003c/a\u003e, but it did not succeed. Why? Because floats do not have sufficient precision, and the numbers in the array can range from 1e15 to 1. Hence, this will have negligible difference under this. The naive way to fix this is just to increase the precision of the numbers, like this: \u003c/p\u003e \u003cpre\u003e\u003ccode\u003el \u003d []\nfor r in range(n):\n    k \u003d int(input())\n    l.append(Decimal(k) + Decimal((n-r)*0.000001))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI tried this too, but it turns out that we in fact get TLE when we try this, even when we water down the precision: \u003ca href\u003d\"/contest/629/submission/16348275\" title\u003d\"Submission 16348275 by Franklyn_W\"\u003e16348275\u003c/a\u003e. And who can blame this? We clearly have to undergo a paradigm shift, because this is bad: since the numbers change so much: a fixed error for each term is not acceptable. How about instead of an absolute error, we use a \u003cem\u003erelative\u003c/em\u003e error? \u003c/p\u003e\u003cp\u003eThis would look like: \u003c/p\u003e \u003cpre\u003e\u003ccode\u003el \u003d []\nfor r in range(n):\n   k \u003d int(input())\n   l.append(k + (n-r)*k*0.00000001)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe reason this works is that equal terms are still larger when they come at the front. However, this method has its own flaws: for instance, there is a chance that if k is large enough, this term will become larger than k+1. Furthermore, the sum of all terms in the subsequence will have a significant difference with the original value. This can be fixed, however, by using a small enough epsilon, as seen below: \u003c/p\u003e \u003cpre\u003e\u003ccode\u003el \u003d []\nfor r in range(n):\n   k \u003d int(input())\n   l.append(k + (n-r)*k*0.00000000001)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSurely enough, this gets AC! \u003ca href\u003d\"/contest/629/submission/16348026\" title\u003d\"Submission 16348026 by Franklyn_W\"\u003e16348026\u003c/a\u003e\u003c/p\u003e\u003cp\u003eHopefully this brightened up your day! \u003c/p\u003e\u003c/div\u003e","tags":[]}}