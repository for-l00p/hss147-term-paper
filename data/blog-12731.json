{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1403160531,"rating":-2,"authorHandle":"codeneo","modificationTimeSeconds":1403163005,"id":12731,"title":"\u003cp\u003eIterative Dynammic Programming\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI am not able to visualize/understand the iterative version of the recurrence, How does we came to know the ordering of the loops in iterative version ?? \u003cstrong\u003eCan you plz help me in understanding how we can convert any recurrence into its iterative dp version ??\u003c/strong\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eF(n \u003d 1, m \u003d 1)  \u003d 1.0\nF(n \u0026gt;\u003d 2, m \u003d 1) \u003d 1/6 + (1/2)*F(n, n, k-1)\nF(n \u0026gt;\u003d 2, m \u0026gt; 1) \u003d (1/2)*F(n, m-1, k-1) +(1/3)*F(n-1,m-1,k-1)\n\u003c/code\u003e\u003c/pre\u003e \u003cpre\u003e\u003ccode\u003e//Recursive version\npublic double find(int n, int m, int k)\n{\n    if (k \u003d\u003d 0)        return (m \u003d\u003d 1? 1.0 : 0.0);\n    if (n \u003d\u003d 1)        return 1.0;\n    if (m \u003d\u003d 1)        return 1/6.0 + find(n, n, k-1)/2;\n\n    return find(n, m-1, k-1)/2 + find(n-1, m-1, k-1)/3;\n}\n\u003c/code\u003e\u003c/pre\u003e \u003cpre\u003e\u003ccode\u003e//Iterative version\npublic double find(int N, int M, int K)\n{\n    double[][][] F \u003d new double[N+1][N+1][K+1];\n    for (int n\u003d1; n\u0026lt;\u003dN; n++)\n        F[n][1][0] \u003d 1.0;\n\n    for (int k\u003d1; k\u0026lt;\u003dK; k++) {\n        F[1][1][k] \u003d 1.0;\n  \n        for (int n\u003d2; n\u0026lt;\u003dN; n++) {\n            F[n][1][k] \u003d 1/6.0 + (1/2.0) * F[n][n][k-1];\n            for (int m\u003d2; m\u0026lt;\u003dn; m++) {\n                F[n][m][k] \u003d (1/2.0)*F[n][m-1][k-1] + (1/3.0)*F[n-1][m-1][k-1];\n            }\n        }\n    }\n    return F[N][M][K];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["dp problem","recurrence"]}}