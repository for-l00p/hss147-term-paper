{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1413131071,"rating":10,"authorHandle":"Ancient_mage","modificationTimeSeconds":1413131071,"id":14244,"title":"\u003cp\u003eSet::iterator, set::lower_bound().\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eСегодня решали один контест и все бы хорошо, но столкнулись с проблемой — задача, которая работает за N log N при N \u0026lt;\u003d 200000, должна была залетать с плюса, но не тут-то было. \u003ca href\u003d\"http://pastebin.com/FSTU1yYQ\"\u003ehttp://pastebin.com/FSTU1yYQ\u003c/a\u003e хорошо видно, что программа действительно работает за N log N : N раз добавляем в set элементы, и столько же раз используем upper_bound. У нас возник вопрос, почему же мы получили TL? Решили разобраться и кроме как спихнуть все на iterator.operator--() и ++() мы ничего не придумали. Может кто объяснит, почему так получается??\u003c/p\u003e\u003cp\u003eP.S. написали эту же задачу на дереве отрезков — все зашло... Так что решение верное.\u003c/p\u003e\u003c/div\u003e","tags":["iterator"]}}