{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1521275629,"rating":0,"authorHandle":"strawberrry","modificationTimeSeconds":1521275629,"id":58410,"title":"\u003cp\u003eRound #236 solution\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cblockquote\u003e\u003cp\u003eall problems are solved at 3.17\u003c/p\u003e \u003c/blockquote\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/group/oQtXiLyxgw/contest/402/problem/A\"\u003eA — Nuts\u003c/a\u003e\u003c/h3\u003e \u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e分类：\u003c/strong\u003e \u003ccode\u003eimplementation\u003c/code\u003e\u003c/p\u003e \u003c/blockquote\u003e\u003cp\u003e考虑如果 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e + 1 ≤ \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e 则直接贪心分 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e + 1\u003c/span\u003e 块，否则 直接分 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e 块！ \u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/group/oQtXiLyxgw/contest/402/problem/B\"\u003eB — Trees in a Row\u003c/a\u003e\u003c/h3\u003e \u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e分类：\u003c/strong\u003e \u003ccode\u003ebrute force\u003c/code\u003e\u003c/p\u003e \u003c/blockquote\u003e\u003cp\u003e因为 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e 很小，直接 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e 枚举以它为基准的单调数列，每次 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e 计算需要修改的次数，取最小值，总的复杂度是 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e 。\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/group/oQtXiLyxgw/contest/402/problem/C\"\u003eC — Searching for Graph\u003c/a\u003e\u003c/h3\u003e \u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e分类：\u003c/strong\u003e \u003ccode\u003ebrute force\u003c/code\u003e \u003ccode\u003econstructive algorithms\u003c/code\u003e\u003c/p\u003e \u003c/blockquote\u003e\u003cp\u003e瞎搞，还没完全看懂题解，先上原文，有空补更\u003c/p\u003e\u003cp\u003eI will describe two solutions.\u003c/p\u003e\u003cp\u003eFirst. Consider all pairs \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e,  \u003ci\u003ej\u003c/i\u003e) (1 ≤ \u003ci\u003ei\u003c/i\u003e  \u0026lt;  \u003ci\u003ej\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. After you should ouput the first \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003en\u003c/i\u003e  +  \u003ci\u003ep\u003c/i\u003e\u003c/span\u003e pairs in lexicographical order.\u003c/p\u003e\u003cp\u003eIt\u0027s clear to understand, that it is enough to prove, that 0-interesting graph is correct or  - 3 -interesting graph is correct. We will prove for  - 3 -interesting graph, that it is correct. This graph consists of triangles, which have an common edge 1 — 2. Let\u0027s fix some subset of vertexes, which does not contains vertexes 1 and 2. In such sets there are no edges. Let\u0027s fix some subset, which contains exactly one vertex (1 or 2). In such subsets there are exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e  -  1\u003c/span\u003e edges, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is the size of such subset. In other subset there are exactly \u003cspan class\u003d\"tex-span\"\u003e2(\u003ci\u003ek\u003c/i\u003e - 2) + 1\u003c/span\u003e edges, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is the size of such subset.\u003c/p\u003e\u003cp\u003eSecond. Let\u0027s use some brute force, to build graphs with 0-interesting graphs with sizes 5, 6, 7, 8, 9 vertexes. Now, to build \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e-interesting graph with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e vertexes, We will build 0-interesting graph, and after that we will add to it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e another edges, which is not in the graph. We will build 0-interesting graphs using the following approach: Let\u0027s took \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e disjointed components, from graphs with number of vertexes from 5 to 9, in such way that there are exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e vertexes in graph.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/group/oQtXiLyxgw/contest/402/problem/D\"\u003eD — Upgrading Array\u003c/a\u003e\u003c/h3\u003e \u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e分类：\u003c/strong\u003e \u003ccode\u003emath\u003c/code\u003e \u003ccode\u003egreedy\u003c/code\u003e\u003c/p\u003e \u003c/blockquote\u003e\u003cp\u003e容易发现 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e 函数就是 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e 的好素数个数减去坏素数个数。那么对于一个元素 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e ，如果它的 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e 值小于 \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e，那么对于它的倍数 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e·\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e 显然把它约去更优，而且我们约的是一个前缀，那么对于某一段 \u003cspan class\u003d\"tex-span\"\u003e[1...\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e 来说约去一个数 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003c/span\u003e，它的子段 \u003cspan class\u003d\"tex-span\"\u003e[1...\u003ci\u003ej\u003c/i\u003e] (1 ≤ \u003ci\u003ej\u003c/i\u003e ≤ \u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e 显然也是最优的，而且不会影响 \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ei\u003c/i\u003e + 1...\u003ci\u003en\u003c/i\u003e]\u003c/span\u003e ，那么我们可以预处理前缀 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egcd\u003c/i\u003e\u003c/span\u003e ，倒着枚举前缀 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egcd\u003c/i\u003e\u003c/span\u003e ，计算约去它之前的 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e 函数，如果不优则贪心的加上这段 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egcd\u003c/i\u003e\u003c/span\u003e ，这样做一遍就是最优解。\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/group/oQtXiLyxgw/contest/402/problem/E\"\u003eE — Strictly Positive Matrix\u003c/a\u003e\u003c/h3\u003e \u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e分类：\u003c/strong\u003e \u003ccode\u003egraph\u003c/code\u003e\u003c/p\u003e \u003c/blockquote\u003e\u003cp\u003e考虑 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e 是某一个图邻接矩阵，初始 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eij\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e 表示从 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e 到 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e 的可达路径数（路径为 \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e ）。那么 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e 以后的 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eij\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e 就表示从 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e 到 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e 长度为 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e 的可达路径数，题目就要求 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e \u0026gt; 0\u003c/span\u003e 也就是说任意的 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e 和 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e 存在至少一条长度为 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e 的通路，当 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e → ∞\u003c/span\u003e 时候，问题就转化为任意两点是否可达，这不就是强连通分量的定义吗？因此这题做法就是如果 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eij\u003c/i\u003e\u003c/sub\u003e \u0026gt; 0\u003c/span\u003e 则连一条 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e 向 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e 的有向边，跑一遍\u003ccode\u003etarjan\u003c/code\u003e看强连通分量数是否为1\u003c/p\u003e\u003cp\u003e没想到这样一道题居然对应着图论模型，感觉图论很神奇。\u003c/p\u003e\u003c/div\u003e","tags":[]}}