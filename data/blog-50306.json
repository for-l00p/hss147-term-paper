{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1486501788,"rating":0,"authorHandle":"1am","modificationTimeSeconds":1486503531,"id":50306,"title":"\u003cp\u003eExtra Day\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eComplexity\u003c/h1\u003e\u003cp\u003eThe first thing we did was talk about the complexity of an algorithm, and that to avoid getting a Time Limit Exceeded verdict, if the time limit is two seconds than the complexity of your solution should be around or less than 10^8, and if it was one second then it should be around or less than 10^7.\u003c/p\u003e\u003cp\u003eThe complexity is calculated as the number of operations your code does. A for loop from 1 to n has complexity O(n). We say the maximum number of operations is the maximum value of n. If n could be 10 ^ 10, do not for loop till n or you will receive a time limit exceeded verdict.\u003c/p\u003e\u003ch1\u003eBinary Search\u003c/h1\u003e\u003cp\u003eWe discussed how sorting an array has complexity O(n logn). To find if a number is in an array or not, the naive solution is O(n*q) — for every query, searching the entire array for the value. The better solution is to sort the array first and use binary search to look for the number.\u003c/p\u003e\u003cp\u003eHere is an explained code on the process: \u003ca href\u003d\"http://ideone.com/lVV1KE\"\u003ehttp://ideone.com/lVV1KE\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTo sort the array make sure to include algorithm\u003c/p\u003e\u003ch1\u003eSieve of Eratosthenes\u003c/h1\u003e\u003cp\u003eThen we learned how to find if a number is prime or not (رقم اولي). The brute force solution is using a for loop from 2 to n-1; if it divides by any number it is not prime. Sieve of Eratosthenes it has a complexity of O(nlog(n)). So you can probably get away with maximum n \u003d 10^6.\u003c/p\u003e\u003cp\u003eWe said that the algorithm works like this:\u003c/p\u003e\u003cp\u003eStart from 2. If a number is not visited yet, run through all multiples of it and mark them visited. But there was two important points. \u003c/p\u003e\u003cp\u003eThe first one was that for example when i reach the number seven, since it is prime it will not be visited. When i start to go through its multiples, i will notice that 2*7 is already visited, as is 3 *7 and 4 *7 all the way to 6*7. That is because i would have ran through them when i was going through multiple of two and three up until 6. So when i reach a number x not visited, the first number i should start marking as visited (not prime) is x*x (x^2). Therefore if my prime number is 7, i will jump to 49. \u003c/p\u003e\u003cp\u003eThat also leads us to our second point. If the range i want is from 1 to 50, then there is no need to check multiples of anything higher than 7 because if i were to check multiples of 8, the first number checked would be 8 *8 which is outside the range of 50. Therefore our outer for loop should be till square root of n. \u003c/p\u003e\u003cp\u003eHere is the code : \u003ca href\u003d\"http://ideone.com/VsSWkR\"\u003ehttp://ideone.com/VsSWkR\u003c/a\u003e\u003c/p\u003e\u003cp\u003eHere is a cool gif: \u003ca href\u003d\"https://en.wikipedia.org/wiki/File:Sieve_of_Eratosthenes_animation.gif#/media/File:Sieve_of_Eratosthenes_animation.gif\"\u003ehttps://en.wikipedia.org/wiki/File:Sieve_of_Eratosthenes_animation.gif#/media/File:Sieve_of_Eratosthenes_animation.gif\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eFrequency Array\u003c/h1\u003e\u003cp\u003eThis is a very broad topic. Frequency array is used to keep track of the number of letters, or numbers, or literally anything you want to keep a count of. We solved a simple problem of finding the frequency of each letter in a lowercase string. Here is the code: \u003ca href\u003d\"http://ideone.com/hvlGsX\"\u003ehttp://ideone.com/hvlGsX\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eLower_bound and Upper_Bound\u003c/h1\u003e\u003cp\u003eInstead of writing the entire binary search code when you want to find if a number is in an array, you can simply use the built in functions lower_bound and upper_bound.\u003c/p\u003e\u003cp\u003eLower bound and upper bound are shortcuts to the binary search method. Before you use them, just like before a binary search, you need to have your array sorted.\u003c/p\u003e\u003cp\u003eA lower bound searches for the first occurrence of an element. If found, returns the index. Otherwise returns the index of the first element higher than it. \u003c/p\u003e\u003cp\u003eAn upper bound searches for the last occurrence of an element, and if found or not... alwayssssssss returns the index of the next element higher than it. \u003c/p\u003e\u003cp\u003eIn both searches, if the number you are searching for is higher than the highest number in the array, it will return the size of the array.\u003c/p\u003e\u003cp\u003eHere is code for reference, try to play around with the elements and see the corresponding output : \u003ca href\u003d\"http://ideone.com/mt7wwJ\"\u003ehttp://ideone.com/mt7wwJ\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eVector\u003c/h1\u003e\u003cp\u003eWe also discussed how a vector is like a re sizable array, where you can push back into the vector and it will grow in size every time. All elements are added to the end. After that elements are accessed the same way an array is.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e        vector\u0026lt;int\u0026gt; v;\n\n        int n;\n\tcin \u0026gt;\u0026gt; n;\n\tint a;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\tcin \u0026gt;\u0026gt; a;\n\t\tv.push_back(a);\n\t}\n\t\n\tsort(v.begin(), v.end());\n\tcout \u0026lt;\u0026lt;v.size()\u0026lt;\u0026lt;endl;\n\t\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\tcout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}