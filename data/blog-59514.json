{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1526550200,"rating":44,"authorHandle":"myownway","modificationTimeSeconds":1526550236,"id":59514,"title":"\u003cp\u003e\u0027/\u0027 or \u0027//\u0027 division â€” python3 \u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello Codeforces community!!\u003c/p\u003e\u003cp\u003eThis is my first post on codeforces. I am not a regular writer who would post ideas or things because the things i used to find out seemed trivial(This post may seem trivial to many of you :D) to me earlier. But not until 2 days ago when i encountered a kind of mistake in my code. I hope this post help other python3 users or those trying to make a shift to python3.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eWhat happened:\u003c/strong\u003e I got wrong answer for Problem A \u003ca href\u003d\"//codeforces.com/contest/979/problem/A\"\u003e979A\u003c/a\u003e . As a normal user i checked, rechecked my logic for it. Read editorial also, it matched my logic too. Looked into \u003ca href\u003d\"//codeforces.com/contest/979/submission/38222153\"\u003etest case\u003c/a\u003e that made it fail. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMy Code\u003c/strong\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003en \u003d int(input())\n\nif n !\u003d 0:\n\tif (n+1)%2:\n\t\tprint(n+1)\n\telse:\n\t\tprint(int((n+1)/2))\nelse:\n\tprint(0)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSeems the logic is correct so, why it is failing for test case 11. Researched a lot on topics i didn\u0027t understood before. Thanks to \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/PikMike\" title\u003d\"Candidate Master PikMike\"\u003ePikMike\u003c/a\u003e and \u003ca class\u003d\"rated-user user-green\" href\u003d\"/profile/qrfkickit\" title\u003d\"Pupil qrfkickit\"\u003eqrfkickit\u003c/a\u003e for pointing out the possible source( \u003cstrong\u003eprecision loss while division\u003c/strong\u003e ). Here is what i found out:\u003c/p\u003e\u003cp\u003eYeah, it does lose precision when dividing in float numbers. But \u0026quot;how\u0026quot; and \u0026quot;why\u0026quot; questions made me curious to read the python3 docs in detail. \u003c/p\u003e\u003cp\u003eI read the python3 \u003ca href\u003d\"https://docs.python.org/3.5/tutorial/floatingpoint.html\"\u003edocumentation\u003c/a\u003e on floating point. I have tried to list down concepts understood on floats and division in python3 point by point after reading from various sources as listed below:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eFirst of all, \u0027/\u0027 is floating point division in python3 by default. So, when we use \u0027/\u0027 for division . The numerator \u003cstrong\u003en\u003c/strong\u003e in \u003cstrong\u003en/d\u003c/strong\u003e is converted to floating point number. And, the floating point number are represented using scientific notation( \u003cstrong\u003ea*10^b\u003c/strong\u003e ) for representing very small and big float numbers. The \u003cstrong\u003ea\u003c/strong\u003e are significant digits and \u003cstrong\u003eb\u003c/strong\u003e is power of exponent. But, the scientific notation can represent only 15 significant digits( \u003ccode\u003esys.float_info.dig\u003c/code\u003e ) for \u003cstrong\u003ea\u003c/strong\u003e. So, here is the catch . The float numbers having significant digits greater than 15 digits will lose some precision while represented as float numbers.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eLet me try to show that using an example. I will add int with float. \u003c/p\u003e\u003cp\u003eint + float \u003d float . So, i will try to push the limits of floating point arithmetic. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u0026gt;\u0026gt; 10**15 + 1.0\n1000000000000001.0 \n# As significant digits are 15 . Result is correct. It doesn\u0027t lose precision\n\n\u0026gt;\u0026gt; 10**16 + 1.0\n1e+16  # 10000000000000000\n# As significant digits are 16 (\u0026gt;15). Result is incorrect . Loses precision. \n \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eMore examples\u003c/strong\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u0026gt;\u0026gt; 2**53\n9007199254740992\n\n\u0026gt;\u0026gt; 2**53 + 1.0\n9007199254740992.0\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThus we can see that it is not safe to represent integers as float . \u003c/p\u003e\u003cp\u003eNow, let\u0027s talk about easy way to tackle this kind of problem.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003e\u0027//\u0027\u003c/strong\u003e integer division comes to rescue. Integer division in python3 can be handled by builtin operand \u0027//\u0027 . Also, the integers in python3 doesn\u0027t have a limit. So, this is the safe approach as compared to float or fractional, decimal module.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eNow coming to test case 11 for problem 979A-38 . \u003c/p\u003e\u003cp\u003eInput: n \u003d 822981260158260519 Now , (n+1)/2 would first convert n+1 as float But 822981260158260519 + 1 converted to float is 8.229812601582605e+17. \u003c/p\u003e\u003cp\u003eLet\u0027s check in interpreter. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u0026gt;\u0026gt; 822981260158260519 + 1\n822981260158260520\n\n# Whereas \n\u0026gt;\u0026gt; 822981260158260519 + 1.0\n8.229812601582605e+17 \n\n# we can see the digits \u002720\u0027 are lost while representing the number as float\n\n# Converting it to int\n\u0026gt;\u0026gt; int(8.229812601582605e+17)\n822981260158260480\n\n\u0026gt;\u0026gt; int((822981260158260519 + 1)/2)\n411490630079130240\n\n\u0026gt;\u0026gt; (822981260158260519 + 1) //2\n411490630079130260\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eSummary:\u003c/strong\u003e Use \u0027//\u0027 integer division for these kind of problem. \u0027/\u0027 may work fine with numbers having significant digits less than 16. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u0026gt;\u0026gt; import sys\n\u0026gt;\u0026gt; sys.float_info\nsys.float_info(max\u003d1.7976931348623157e+308, max_exp\u003d1024, max_10_exp\u003d308, min\u003d2.2250738585072014e-308, min_exp\u003d-1021, min_10_exp\u003d-307, dig\u003d15, mant_dig\u003d53, epsilon\u003d2.220446049250313e-16, radix\u003d2, rounds\u003d1)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["python3","division","integer"]}}