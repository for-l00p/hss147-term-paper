{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1514557301,"rating":336,"authorHandle":"lewin","modificationTimeSeconds":1514653306,"id":56713,"title":"\u003cp\u003eGood Bye 2017 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHere\u0027s the editorial. Hope you have a happy new year!\u003c/p\u003e\u003cp\u003eCode can be found here: \u003ca href\u003d\"https://www.dropbox.com/sh/i9cxj44tvv5pqvn/AACQs7LLNyTZT-Gt_AMf7UQFa?dl\u003d0\"\u003ehttps://www.dropbox.com/sh/i9cxj44tvv5pqvn/AACQs7LLNyTZT-Gt_AMf7UQFa?dl\u003d0\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eNew Year and Counting Cards\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eLet\u0027s start off a bit more abstractly. We would like to know if the statement \u0026quot;if P then Q\u0026quot; is true, where P and Q are some statements (in this case, P is \u0026quot;card has vowel\u0026quot;, and Q is \u0026quot;card has even number\u0026quot;). To do determine this, we need to flip over any cards which could be counter-examples (i.e. could make the statement false).\u003c/p\u003e\u003cp\u003eLet\u0027s look at the truth table for if P then Q (see here: \u003ca\u003ehttp://www.math.hawaii.edu/~ramsey/Logic/IfThen.html)\u003c/a\u003e. The statement is only false when Q is false and P is true. Thus, it suffices to flip cards when P is true or Q is false.\u003c/p\u003e\u003cp\u003eTo solve this problem, we need to print the count of vowels and odd digits in the string.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003estats\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFirst solve: \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/ksun48\" title\u003d\"International Grandmaster ksun48\"\u003eksun48\u003c/a\u003e at 00:01:01\u003c/p\u003e\u003cp\u003eBreakdown of results for submissions that passed pretests\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eOK 6427 (98.74%)\nCHALLENGED 60 (0.92%)\nWRONG_ANSWER 22 (0.34%)\nTOTAL 6509\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eNew Year and Buggy Bot\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThis problem is intended as an implementation problem. The bounds are small enough that a brute force works. We can iterate through all mapping of numbers to directions (i.e. using next permutation in C++ or doing some recursive DFS if there is no built in next permutation in your language), and simulate the robot\u0027s movements. We have to be careful that if the robot ever gets in an invalid state, we break out early and say the mapping is invalid.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003estats\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFirst solve: \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/jonathanirvings\" title\u003d\"Grandmaster jonathanirvings\"\u003ejonathanirvings\u003c/a\u003e, \u003ca class\u003d\"rated-user user-legendary\" href\u003d\"/profile/dotorya\" title\u003d\"Legendary grandmaster dotorya\"\u003e\u003cspan class\u003d\"legendary-user-first-letter\"\u003ed\u003c/span\u003eotorya\u003c/a\u003e at 00:05:16\u003c/p\u003e\u003cp\u003eBreakdown of results for submissions that passed pretests\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eOK 4192 (83.72%)\nWRONG_ANSWER 652 (13.02%)\nCHALLENGED 126 (2.52%)\nRUNTIME_ERROR 33 (0.66%)\nTIME_LIMIT_EXCEEDED 4 (0.08%)\nTOTAL 5007\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eNew Year and Curling\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThis is another simulation problem with some geometry. As we push a disk, we can iterate through all previous disks and see if their \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-coordinates are \u003cspan class\u003d\"tex-span\"\u003e ≤ 2\u003ci\u003er\u003c/i\u003e\u003c/span\u003e. If so, then that means these two circles can possibly touch.\u003c/p\u003e\u003cp\u003eIf they do, we can compute the difference of heights between these two circles using pythagorean theorem. In particular, we want to know the change in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e coordinate between the two touching circles. We know the hypotenuse (it is \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003er\u003c/i\u003e\u003c/span\u003e since the circles are touching), and the change in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-coordinate is given, so the change in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e coordinate is equal to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c7/35/c735432abfd7c78002f4210fead8b6a98f0f3dd3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edx\u003c/i\u003e\u003c/span\u003e is the change in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-coordinate.\u003c/p\u003e\u003cp\u003eWe can then take the maximum over all of these cases to get our final \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e-coordinate, since this is where this disk will first stop. Overall, this takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e time.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003estats\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFirst solve: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/henryx\" title\u003d\"Candidate Master henryx\"\u003ehenryx\u003c/a\u003e at 00:04:05\u003c/p\u003e\u003cp\u003eBreakdown of results for submissions that passed pretests\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eOK 2694 (63.81%)\nWRONG_ANSWER 1064 (25.20%)\nCHALLENGED 448 (10.61%)\nRUNTIME_ERROR 11 (0.26%)\nTIME_LIMIT_EXCEEDED 4 (0.09%)\nMEMORY_LIMIT_EXCEEDED 1 (0.02%)\nTOTAL 4222\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eNew Year and Arbitrary Arrangement\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThe main trickiness of this problem is that the sequence could potentially get arbitrary long, but we want an exact answer. In particular, it helps to think about how to reduce this problem to figuring out what state we need to maintain from a prefix of the sequence we\u0027ve built in order to simulate our algorithm correctly. This suggests a dynamic programming approach.\u003c/p\u003e\u003cp\u003eFor our dp state, we need to keep track of something in our prefix. First, the most obvious candidate is we need to keep track of the number of times \u0027ab\u0027 occurs in the prefix (this is so we know when to stop). However, using only this is not enough, as we can\u0027t distinguish between the sequences \u0027ab\u0027 and \u0027abaaaa\u0027. So, this suggests we also need to keep track of the number of \u0027a\u0027s.\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e be the expected answer given that there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e subsequences of the form \u0027a\u0027 in the prefix and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e subsequences of the form \u0027ab\u0027 in the prefix.\u003c/p\u003e\u003cp\u003eThen, we have something like \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e] \u003d (\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e * \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1][\u003ci\u003ej\u003c/i\u003e] + \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e * \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e + \u003ci\u003ej\u003c/i\u003e]) / (\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e. The first term in this sum comes from adding another \u0027a\u0027 to our sequence, and the second comes from adding a \u0027b\u0027 to our sequence. We also have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e] \u003d \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e ≥ \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e as a base case. The answer should be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[0][0]\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eHowever, if we run this as is, we\u0027ll notice there are still some issues. One is that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e can get arbitrarily large here, as we can keep adding \u0027a\u0027s indefinitely. Instead, we can modify our base case to when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + \u003ci\u003ej\u003c/i\u003e ≥ \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. In this case, the next time we get a \u0027b\u0027, we will stop, so we can find a closed form for this scenario. The second is that any \u0027b\u0027s that we get before any occurrences of \u0027a\u0027 can essentially be ignored. To fix this, we can adjust our answer to be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[1][0]\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003estats\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFirst solve: \u003ca class\u003d\"rated-user user-legendary\" href\u003d\"/profile/dotorya\" title\u003d\"Legendary grandmaster dotorya\"\u003e\u003cspan class\u003d\"legendary-user-first-letter\"\u003ed\u003c/span\u003eotorya\u003c/a\u003e at 00:16:46\u003c/p\u003e\u003cp\u003eBreakdown of results for submissions that passed pretests\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eOK 449 (99.78%)\nWRONG_ANSWER 1 (0.22%)\nTOTAL 450\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eNew Year and Entity Enumeration\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eLet\u0027s ignore \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e for now, and try to characterize good sets \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eFor every bit position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, consider the bitwise AND of all elements of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e which have the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th bit on (note, there is at least one element in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e which has the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th bit on, since we can always \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6a/4d/6a4df46553cbeff6deca4030e86d98d9f077536d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e). We can see that this is equivalent to the smallest element of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e that contains the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th bit. Denote the resulting number as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe can notice that this forms a partition of the bit positions, based on the final element that we get. In particular, there can\u0027t be a scenario where there is two positions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1d/e0/1de0b900bc2e55ba47b4a7bb26c87337ffccc0c7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e such that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f6/83/f6839da6b3082ebde9ae799d82ed3eddf220ef53.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. To show this, let \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/70/60/7060c5a06e6b80768ae341796de9389e635966a8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, and without loss of generality, let\u0027s assume \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/93/e1/93e1792b80f0445a623fc2026ecfefbbfa4b37b3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (it can\u0027t be simultaneously equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e), \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e since \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1d/e0/1de0b900bc2e55ba47b4a7bb26c87337ffccc0c7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e). If the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-th bit in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e is on, we get a contradiction, since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e is a smaller element than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e that contains the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-th bit. If the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-th bit in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e is off, then, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4a/76/4a7681f5b5302ac11a75afdd15f811eaa6e7c349.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is a smaller element of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e that contains the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-th bit.\u003c/p\u003e\u003cp\u003eSo, we can guess at this point that good sets \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e correspond to partitions of \u003cspan class\u003d\"tex-span\"\u003e{1, 2, ..., \u003ci\u003em\u003c/i\u003e}\u003c/span\u003e one to one.\u003c/p\u003e\u003cp\u003eGiven a partition, we can construct a valid good set as follows. We can observe that a good set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e must be closed under bitwise OR also. To prove this, for any two elements \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ea/e4/eae464981ad31229239e1139f4796c1dbc965dac.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/58/3e/583e46ece723083fd62e2e15ffa78a9331de3cec.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Since the latter is some composition of XORs and ANDs, it it also in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e. So, given a partition, we can take all unions of some subset of the partitions to get \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFor an actual solution, partitions can be computed with bell numbers, which is an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003em\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e dp (see this: \u003ca href\u003d\"http://mathworld.wolfram.com/BellNumber.html\"\u003ehttp://mathworld.wolfram.com/BellNumber.html\u003c/a\u003e ).\u003c/p\u003e\u003cp\u003eNow, back to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e, we can see that this decides some partitions beforehand. In particular, for each bit position, we can make a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e-bit mask denoting what its value is in each of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e given values. The partitions are based on what these masks are. We can find what the sizes of these splits are, then multiply the ways to partition each individual split together to get the answer.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003estats\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFirst solve: \u003ca class\u003d\"rated-user user-legendary\" href\u003d\"/profile/Petr\" title\u003d\"Legendary grandmaster Petr\"\u003e\u003cspan class\u003d\"legendary-user-first-letter\"\u003eP\u003c/span\u003eetr\u003c/a\u003e at 00:26:54\u003c/p\u003e\u003cp\u003eBreakdown of results for submissions that passed pretests\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eOK 166 (100.00%)\nTOTAL 166\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eNew Year and Rainbow Roads\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eLet\u0027s make a few simplifying observations\u003c/p\u003e \u003cul\u003e   \u003cli\u003eIt is not optimal to connect a red and blue point directly: Neither Roy or Biv will see this edge.\u003c/li\u003e   \u003cli\u003eIf we have a sequence like red green red (or similarly blue green blue), it is not optimal to connect the outer two red nodes. We can replace the outer edge with two edges that have the same weight. This replacement will form some cycle in the red-green points, so we can remove one of these edges for a cheaper cost.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eWith these two observations, we can construct a solution as follows. First, split the points by the green points. Each section is now independent. There are then two cases, the outer green points are not directly connected, in which case, we must connect all the red/blue points in the line (for 2 * length of segment weight), or the outer green points are directly connected, in which case, we can omit the heaviest red and blue segment (for 3 * length of segment — heaviest red — heaviest blue). Thus, this problem can be solved in linear time.\u003c/p\u003e\u003cp\u003eBe careful about the case with no green points.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003estats\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFirst solve: \u003ca class\u003d\"rated-user user-legendary\" href\u003d\"/profile/Petr\" title\u003d\"Legendary grandmaster Petr\"\u003e\u003cspan class\u003d\"legendary-user-first-letter\"\u003eP\u003c/span\u003eetr\u003c/a\u003e at 00:38:32\u003c/p\u003e\u003cp\u003eBreakdown of results for submissions that passed pretests\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eOK 246 (90.44%)\nWRONG_ANSWER 24 (8.82%)\nRUNTIME_ERROR 2 (0.74%)\nTOTAL 272\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eNew Year and Original Order\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThis is a digit dp problem. Let\u0027s try to solve the subproblem \u0026quot;How many ways can the i-th digit be at least j?\u0026quot;. Let\u0027s fix j, and solve this with dp. We have a dp state dp[a][b][c] \u003d number of ways given we\u0027ve considered the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e digits of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e, we need \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e more occurrences of digits at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e is a boolean saying whether or not we are strictly less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e or not yet.\u003c/p\u003e\u003cp\u003eFor a fixed digit, we can compute this dp table in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e time, and then compute the answers to our subproblem for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e (i.e. by varying \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e in our table).\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003estats\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFirst solve: \u003ca class\u003d\"rated-user user-legendary\" href\u003d\"/profile/dotorya\" title\u003d\"Legendary grandmaster dotorya\"\u003e\u003cspan class\u003d\"legendary-user-first-letter\"\u003ed\u003c/span\u003eotorya\u003c/a\u003e at 00:49:58\u003c/p\u003e\u003cp\u003eBreakdown of results for submissions that passed pretests\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eOK 46 (100.00%)\nTOTAL 46\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eNew Year and Boolean Bridges\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFirst, let\u0027s find connected components using only AND edges. If there are any XOR edges between two nodes in the same component, the answer is -1.\u003c/p\u003e\u003cp\u003eNow, we can place all components in a line. However, it may be optimal to merge some components together. It only makes sense to merge components of size 2 or more, of which there are at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d \u003ci\u003en\u003c/i\u003e / 2\u003c/span\u003e of them. \u003c/p\u003e\u003cp\u003eWe can make a new graph with these \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e components. Two components have an edge if all of the edges between them are OR edges, otherwise, there is no edge.\u003c/p\u003e\u003cp\u003eWe want to know what is the minimum number of cliques needed to cover all the nodes in this graph. To solve this, we can precompute which subsets of nodes forms a clique and put this into some array. Then, we can use the fast walsh hadamard transform to multiply this array onto itself until the element \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e - 1\u003c/span\u003e is nonzero. Naively, this is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e * \u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e, but we can save a factor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e by noticing we only need to compute the last element, and we don\u0027t need to re-transform our input array at each iteration.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003estats\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFirst solve: \u003ca class\u003d\"rated-user user-legendary\" href\u003d\"/profile/dotorya\" title\u003d\"Legendary grandmaster dotorya\"\u003e\u003cspan class\u003d\"legendary-user-first-letter\"\u003ed\u003c/span\u003eotorya\u003c/a\u003e at 01:49:01\u003c/p\u003e\u003cp\u003eBreakdown of results for submissions that passed pretests\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eOK 10 (100.00%)\nTOTAL 10\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["goodbye","2017","editorial"]}}