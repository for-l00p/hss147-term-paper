{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1423349291,"rating":57,"authorHandle":"Noureldin","modificationTimeSeconds":1423570418,"id":16262,"title":"\u003cp\u003eC++14 from the point of view of a competitive programmer\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003efor a competitive programmer the most important features are what C++11 has already introduced namely (range based loops ,lambda expressions ,brace initialization of aggregates, unordered containers ,..... etc) which can be found \u003ca href\u003d\"http://www.quora.com/As-a-competitive-programmer-what-C++11-features-should-I-be-aware-of-and-what-are-some-examples-that-illustrate-their-usage/answer/Brian-Bi\"\u003ehere\u003c/a\u003e .\u003c/p\u003e\u003cp\u003ein addition to:\u003c/p\u003e\u003cp\u003e1) numeric literals\u003c/p\u003e\u003cp\u003enow you can separate digits of a number with single quotes ( \u0027 ) to improve readability\u003c/p\u003e\u003cp\u003e\u003ccode\u003eauto num \u003d 10\u0027000\u0027000; // num \u003d 10^7\u003c/code\u003e\u003c/p\u003e\u003cp\u003ethis works for floating numbers as well\u003c/p\u003e\u003cp\u003e\u003ccode\u003eauto fnum \u003d 0.000\u0027015\u00273; // fnum \u003d 1.53 * 10^-5\u003c/code\u003e\u003c/p\u003e\u003cp\u003enow you can initialize numbers using their binary form this feature was experimentally included in C++0x (the prototype of C++11) however it didn\u0027t become official until the announcement of the new standard\u003c/p\u003e\u003cp\u003e\u003ccode\u003eauto bnum \u003d 0b0100\u00271100\u00270110; // bnum \u003d (010011000110)2 \u003d (4C6)16 \u003d 1222\u003c/code\u003e\u003c/p\u003e\u003cp\u003e//note that the spacing of the quotes doesn\u0027t matter\u003c/p\u003e\u003cp\u003e\u003ccode\u003eauto snum \u003d 1\u00270\u00270\u0027000\u002700; // snum \u003d 10^7\u003c/code\u003e\u003c/p\u003e\u003cp\u003e2) std::gets was removed due to its tendency to cause RTE due to overflow in its buffer\u003c/p\u003e\u003cp\u003e3) lambda expressions can now be generic:\u003c/p\u003e\u003cp\u003ein C++11 you had to specify the type of the inputs to the lambda expression\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eauto lambda \u003d [](int x, int y) {return x + y;}; // C++11 --- had to specify type of x and y\nauto lambda \u003d [](auto x, auto y) {return x + y;}; // C++14 the compiler will decide the type for you ;)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e4) improved std::tuple (in particular improved std::get)\u003c/p\u003e\u003cp\u003ein std::tuple introduced by C++11 (which was experimentally added to TR1 in 2007) to get the value of an element you had to use only its index\u003c/p\u003e\u003cp\u003e\u003ccode\u003eint element \u003d std::get\u0026lt;2\u0026gt;(mytuple); //get the third element in mytuple\u003c/code\u003e\u003c/p\u003e\u003cp\u003enow you can do the same thing plus the ability to index by type\u003c/p\u003e\u003cp\u003e\u003ccode\u003estd::string element \u003d std::get\u0026lt;string\u0026gt;(mytuple);// return the string element in mytuple\u003c/code\u003e\u003c/p\u003e\u003cp\u003enote: if the tuple had more than one element of the same type using std::get that way would cause compilation error\u003c/p\u003e \u003chr /\u003e\u003cp\u003ea feature of C++11 that\u0027s not mentioned in the link above that I find very useful\u003c/p\u003e\u003cp\u003eC++11 introduced the ability to pass rvalues by reference that\u0027s to pass temporary values by reference such as\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// compilation error in C++03 .... legit in C++11 \u0026amp; C++14\nstring mul(string \u0026amp;\u0026amp; a,string \u0026amp;\u0026amp; b); \nmul(\u0026quot;10\u0026quot;,\u0026quot;30\u0026quot;);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eas you can see from the specific example I used ,it speeds up calculuations in particular this snippet is from my biginteger implementation which sped up biginteger multiplication by 30-40% on average (tested on numbers containing ~ 50000 digits) \u003c/p\u003e \u003chr /\u003e\u003cp\u003enote: some legit C++03 \u0026amp;\u0026amp; C++11 codes might break if compiled using C++14 standards\u003c/p\u003e\u003cp\u003ecodes that use std::gets are the simplest case but there are others for more details you can refer to this \u003ca href\u003d\"http://stackoverflow.com/questions/23980929/what-changes-introduced-in-c14-can-potentially-break-a-program-written-in-c1\"\u003elink\u003c/a\u003e\u003c/p\u003e \u003chr /\u003e\u003cp\u003efinally ,there are some other additions and modifications in C++14 that are very important (relaxed constexpr restrictions ,improved lambda capture expressions ,the attribute [[deprecated]] ,heterogeneous lookup ,....etc) to name a few, yet their importance to a competitive programmer is less than that of the mentioned features (at least from my point of view)\u003c/p\u003e\u003c/div\u003e","tags":["c++14","c++11","c++"]}}