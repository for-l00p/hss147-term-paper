{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1500013992,"rating":12,"authorHandle":"Mahilewets","modificationTimeSeconds":1500013992,"id":53294,"title":"\u003cp\u003eDP-задачи часто удобнее решать как графовые задачи\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eНаблюдение, касающееся динамического программирования, которое все, скорее всего, уже давно сделали. \u003c/p\u003e\u003cp\u003eВместо того чтобы строить массив вида \u003ccode\u003eDP[dim_1][dim_2][dim_3]...[dim_N]\u003c/code\u003e,  часто бывает более удобно и понятно строить явным образом граф вида \u003ccode\u003evector \u0026lt;struct {int state_1, state_2, state_3, ..., state_N;} \u0026gt;\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eОсобенно это удобно и понятно, когда количество измерений больше двух. \u003c/p\u003e\u003cp\u003eТогда, например, можно не использовать громоздкие конструкции, чтобы инициализировать значения по умолчанию, а просто воспользоваться значениями для полей структуры по умолчанию. \u003c/p\u003e\u003cp\u003eТакже это позволяет обойтись вообще без написания циклов в явном виде, всё можно сделать при помощи рекурсивной функции обхода графа. \u003c/p\u003e\u003cp\u003eТаким образом можно добиться даже экономии памяти, если создавать новое состояние непосредственно перед тем, как обход графа собирается пойти в него. \u003c/p\u003e\u003cp\u003eПример, где такой подход позволил избежать громоздких выкладок с многомерным массивом: \u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1501\"\u003ehttp://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1501\u003c/a\u003e \u003ca href\u003d\"http://ideone.com/tm1TcB\"\u003ehttp://ideone.com/tm1TcB\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}