{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1488652720,"rating":0,"authorHandle":"1am","modificationTimeSeconds":1490711302,"id":50807,"title":"\u003cp\u003eDay 1 (recounting)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003e\u003ca href\u003d\"//codeforces.com/group/HkEoaKeslR/contest/212241/problem/A\"\u003eA. Kefa and First Steps\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eThis question asks for you to find the maximum non-decreasing subsegment in the array. We solved this by keeping a counter and increasing it if the value we are at is greater than or equal to the previous value. Otherwise we update the answer based on the counter so far and bring the counter back to 1.\u003c/p\u003e\u003cp\u003eIn the case that the entire array is increasing, we will never reach the second if statement so make sure to take the maximum between your counter and the answer also after leaving the array.\u003c/p\u003e\u003cp\u003eHere is the code for it: \u003ca href\u003d\"http://ideone.com/GMbGDL\"\u003ehttp://ideone.com/GMbGDL\u003c/a\u003e\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"//codeforces.com/group/HkEoaKeslR/contest/212241/problem/B\"\u003eB. Cards\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eThis question asks for you to match cards together such that the sum of all pairs of cards are equal. We realized that the best option is to put the highest card with the lowest card, then the second highest card with the 2nd lowest card and so on. To do this, we need to sort the numbers, but because the order of the original indices is lost ( and we need them to print our answer ), we use a pair data structure.\u003c/p\u003e\u003cp\u003eThat way when we sort them based on .first, the .second stores the position of the number originally and that is what we print.\u003c/p\u003e\u003cp\u003eHere is the code for it: \u003ca href\u003d\"http://ideone.com/pO3Z9m\"\u003ehttp://ideone.com/pO3Z9m\u003c/a\u003e\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"//codeforces.com/group/HkEoaKeslR/contest/212241/problem/G\"\u003eG. Polo the Penguin and Matrix\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eFirst of all you should know that a number \u0027a\u0027 modulus d is the same as adding d to \u0027a\u0027 and taking it modulus d:\u003c/p\u003e\u003cp\u003ea % d \u003d (a +d) %d\u003c/p\u003e\u003cp\u003efor example, 1 %3 is equal to 4 %3 which is equal to 7 %3. You can consider modulus like a cycle, %3 is a cycle of values \u003c/p\u003e\u003cp\u003e(0 ,1 ,2 ,0 ,1 ,2 ,0 ,1 ,2 ,...) \u003d( 0%3 , 1 %3, 2%3, 3%3, 4%3, 5%3, 6%3, 7%3, 8%3, ...).\u003c/p\u003e\u003cp\u003eSo if i have numbers in an array and i want them all to be equal by adding d some number of times to each number, the numbers must all have the same value when taken modulus d in the beginning. Like in the previous example, I can get 4 to become 7 by adding d — where d \u003d3 — and to become 1 by subtracting d, but there is no way i can get 4 to become 2.\u003c/p\u003e\u003cp\u003eSo if they all don\u0027t have the same value when taken modulus d, i automatically output -1. Other than that, if we want them all to be equal by adding/subtracting the least amount of d\u0027s, then it is best to take the median in the array.\u003c/p\u003e\u003cp\u003eFor example in the array 1 4 7 , it is best here to make them all equal to 4, by adding d once to 1 and subtracting d from 7 (d \u003d3). We would make them all equal in 2 moves, any other choice (1 or 7) would need 3 moves.\u003c/p\u003e\u003cp\u003eConsider the entire matrix as an array and store it in 1 dimension. Get the median after sorting, and count the number of moves needed to get them equal.\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"//codeforces.com/group/HkEoaKeslR/contest/212241/problem/I\"\u003eI. Stripe\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eThis problem wants you to cut the array into two parts such that their sum is equal. Since we are cutting it into two parts, we know that the sum of each part should be (sum of total array) /2.\u003c/p\u003e\u003cp\u003eAfter that, to get all indices where the sum from the beginning of the array to the index is equal to totalSum / 2, all you have to do is keep a sum count so far and increase it while you go from left to right like this : sum +\u003d arr[i];\u003c/p\u003e\u003cp\u003eIf the sum \u003d\u003d totalsum / 2, then increase your answer.\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"//codeforces.com/group/HkEoaKeslR/contest/212241/problem/E\"\u003eE. Cells Not Under Attack\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eStart off the problem with rows \u003d n and cols \u003d n. Then when you add a rook onto a cell where the row is not taken, you decrease the amount of rows by 1. If the column is not taken, you decrease the amount of col by 1. To keep track if it is taken or not, you keep a boolean array for rows and columns. The area is rows *cols\u003c/p\u003e\u003cp\u003eHere is the code for it: \u003ca href\u003d\"http://ideone.com/jCpONv\"\u003ehttp://ideone.com/jCpONv\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}