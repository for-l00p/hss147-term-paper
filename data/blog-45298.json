{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1465323937,"rating":193,"authorHandle":"quasisphere","modificationTimeSeconds":1465336357,"id":45298,"title":"\u003cp\u003eFast convolution for 64-bit integers\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eFast convolution for 64-bit integers\u003c/h1\u003e\u003cp\u003eWarning: Math ahead. You can find my reference C++ implementation at \u003ca href\u003d\"https://github.com/quasisphere/conv64\"\u003ehttps://github.com/quasisphere/conv64\u003c/a\u003e\u003c/p\u003e\u003ch2\u003eIntroduction\u003c/h2\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, ..., \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≥ 1\u003c/span\u003e, be two tuples of elements of some ring \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e. By their convolution we mean the tuple \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, ..., \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003ci\u003en\u003c/i\u003e - 2\u003c/sub\u003e)\u003c/span\u003e whose elements are given by\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/sub\u003e + ... + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e - \u003ci\u003en\u003c/i\u003e + 1\u003c/sub\u003e.\u003c/span\u003e\u003c/center\u003e\u003cp\u003e(Here we understand that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 0\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026lt; 0\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e ≥ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e.)\u003c/p\u003e\u003cp\u003eA succinct way of encoding this is via polynomials: If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003ci\u003ex\u003c/i\u003e + ... + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e + \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003ci\u003ex\u003c/i\u003e + ... + \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e, then\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)·\u003ci\u003eB\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d \u003ci\u003eC\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e + \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003ci\u003ex\u003c/i\u003e + ... + \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003ci\u003en\u003c/i\u003e - 2\u003c/sub\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003ci\u003en\u003c/i\u003e - 2\u003c/sup\u003e.\u003c/span\u003e\u003c/center\u003e\u003cp\u003eConvolution can thus be understood via multiplication of polynomials and vice versa. From this point on we will exclusively work with polynomials instead of tuples since that is much more natural.\u003c/p\u003e\u003cp\u003eMultiplying polynomials with real or complex coefficients can be done efficiently via the Fast Fourier Transform. The same method can also be applied to polynomials with integer coefficients, but then one has to worry about possible loss of precision and therefore getting a wrong answer. In this blog we will present a way of multiplying polynomials whose coefficients are 64-bit integers, or in mathematical terms, integers modulo \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e64\u003c/sup\u003e\u003c/span\u003e. The underlying ideas of our method are not new, but I have not seen this exact combination used before. A nice survey of fast multiplication methods is given in \u003ca href\u003d\"https://cr.yp.to/papers/m3.pdf\"\u003ehttps://cr.yp.to/papers/m3.pdf\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe note that FFT computes cyclic convolutions, that is products in the ring \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e - 1)\u003c/span\u003e. This is not a problem since to compute an acyclic convolution one can simply pick \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e large enough and zero-pad the polynomial (so that no cyclic overflow occurs).\u003c/p\u003e\u003ch2\u003eA short recap on the Fast Fourier Transform\u003c/h2\u003e\u003cp\u003eAssume that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e is a commutative ring that contains an element \u003cspan class\u003d\"tex-span\"\u003eξ\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003eξ\u003csup class\u003d\"upper-index\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e\u003c/sup\u003e \u003d 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e is the multiplicative order of \u003cspan class\u003d\"tex-span\"\u003eξ\u003c/span\u003e. Then the polynomial \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e\u003c/sup\u003e  - 1 \u003d \u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e\u003c/sup\u003e - ξ\u003csup class\u003d\"upper-index\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e\u003c/sup\u003e\u003c/span\u003e splits recursively into factors as follows:\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e\u003c/sup\u003e - ξ\u003csup class\u003d\"upper-index\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e\u003c/sup\u003e  \u003d (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/sup\u003e\u003c/sup\u003e - ξ\u003csup class\u003d\"upper-index\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/sup\u003e\u003c/sup\u003e)(\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/sup\u003e\u003c/sup\u003e + ξ\u003csup class\u003d\"upper-index\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/sup\u003e\u003c/sup\u003e) \u003d (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/sup\u003e\u003c/sup\u003e - ξ\u003csup class\u003d\"upper-index\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/sup\u003e\u003c/sup\u003e)(\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/sup\u003e\u003c/sup\u003e - (ξ\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003csup class\u003d\"upper-index\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/sup\u003e\u003c/sup\u003e)\u003c/span\u003e\u003c/center\u003e\u003cp\u003eNow, assume that we want to compute the product of two polynomials in the quotient ring \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e\u003c/sup\u003e - 1)\u003c/span\u003e. Then by the Chinese remainder theorem it is enough to compute their product in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/sup\u003e\u003c/sup\u003e - ξ\u003csup class\u003d\"upper-index\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/sup\u003e\u003c/sup\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/sup\u003e\u003c/sup\u003e - (ξ\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003csup class\u003d\"upper-index\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/sup\u003e\u003c/sup\u003e)\u003c/span\u003e. The multiplication by FFT works by doing this reduction repeatedly until we are left only with first degree polynomials of the form \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - ξ\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e \u003d 0, ..., 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIn practice FFT algorithms give you the evaluations \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(ξ\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e, which corresponds exactly to reducing modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - ξ\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. By the preceding discussion to multiply the polynomials \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e we must form the products \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(ξ\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sup\u003e)·\u003ci\u003eB\u003c/i\u003e(ξ\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e and then do the Chinese remainder theorem all the way up to the original ring. This second stage is done by the inverse FFT.\u003c/p\u003e\u003ch2\u003eOutline of the method\u003c/h2\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e \u003d \u003ci\u003eZ\u003c/i\u003e / 2\u003csup class\u003d\"upper-index\"\u003e64\u003c/sup\u003e\u003ci\u003eZ\u003c/i\u003e\u003c/span\u003e denote the ring of integers modulo \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e64\u003c/sup\u003e\u003c/span\u003e. There are two main obstacles to multiplying polynomials in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e]\u003c/span\u003e using the FFT method.\u003c/p\u003e\u003cp\u003e\u003cem\u003eObstacle 1\u003c/em\u003e: \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e is not invertible. This means that we cannot perform the standard (radix-2) FFT, since in the inverse transform we must divide by 2. The solution we will use is to instead perform a radix-3 FFT on an array whose length is a power of 3.\u003c/p\u003e\u003cp\u003e\u003cem\u003eObstacle 2\u003c/em\u003e: There are no roots of unity of order \u003cspan class\u003d\"tex-span\"\u003e3\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. Our solution is to first adjoin a 3rd root of unity to the ring \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e and then manufacture higher order roots via a Schönhage-type trick.\u003c/p\u003e\u003cp\u003eHaving identified what we must overcome, we will now outline the method. First of all, we extend our ring of scalars by looking instead at the ring \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e \u003d \u003ci\u003eR\u003c/i\u003e[ω] / (ω\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e + ω + 1)\u003c/span\u003e. Its elements can be represented as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003eω\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e are 64-bit integers and the ring of 64-bit integers is embedded in it as the elements with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e \u003d 0\u003c/span\u003e. The product of two such elements is given by\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003eω)(\u003ci\u003ec\u003c/i\u003e + \u003ci\u003ed\u003c/i\u003eω) \u003d \u003ci\u003eac\u003c/i\u003e + (\u003ci\u003ead\u003c/i\u003e + \u003ci\u003ebc\u003c/i\u003e) ω + \u003ci\u003ebd\u003c/i\u003eω\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e \u003d \u003ci\u003eac\u003c/i\u003e - \u003ci\u003ebd\u003c/i\u003e + (\u003ci\u003ead\u003c/i\u003e + \u003ci\u003ebc\u003c/i\u003e - \u003ci\u003ebd\u003c/i\u003e)ω, \u003c/span\u003e\u003c/center\u003e\u003cp\u003ewhere we have used the fact that \u003cspan class\u003d\"tex-span\"\u003eω\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e \u003d  - ω - 1\u003c/span\u003e, and it is also easy to check that we have \u003cspan class\u003d\"tex-span\"\u003eω\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e \u003d 1\u003c/span\u003e. Thus \u003cspan class\u003d\"tex-span\"\u003eω\u003c/span\u003e is a 3rd root of unity in this ring. We say that the \u003cstrong\u003econjugate\u003c/strong\u003e of an element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003eω\u003c/span\u003e is the element we get by mapping \u003cspan class\u003d\"tex-span\"\u003eω → ω\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e, that is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003eω\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e \u003d \u003ci\u003ea\u003c/i\u003e - \u003ci\u003eb\u003c/i\u003e - \u003ci\u003eb\u003c/i\u003eω\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIn what follows we will devise an algorithm for multiplication in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e - 1)\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is a power of 3. Assume that we are given a polynomial \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003ci\u003ex\u003c/i\u003e + ... + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e from the extended ring \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e. We will first let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e are powers of \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emr\u003c/i\u003e \u003d \u003ci\u003en\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e3\u003ci\u003em\u003c/i\u003e ≥ \u003ci\u003er\u003c/i\u003e\u003c/span\u003e. Then we can write our polynomial in the form\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e + ... + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/sub\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/sup\u003e) + (\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e + ... + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003ci\u003em\u003c/i\u003e - 1\u003c/sub\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/sup\u003e)\u003ci\u003ey\u003c/i\u003e + ... + (\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e(\u003ci\u003er\u003c/i\u003e - 1)\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e + ... + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003erm\u003c/i\u003e - 1\u003c/sub\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/sup\u003e)\u003ci\u003ey\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e\u003c/center\u003e\u003cp\u003eNotice that in a program this does not require us to do anything since the order of the coefficients stays the same.\u003c/p\u003e\u003cp\u003eNow since the coefficients of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003es are polynomials of degree at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e \u003d 1\u003c/span\u003e, we can think of this as an element of the ring \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e + \u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e + 1)[\u003ci\u003ey\u003c/i\u003e] / (\u003ci\u003ey\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e - 1)\u003c/span\u003e. Clearly if we multiply two such polynomials the products of the coefficients in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e + \u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e + 1)\u003c/span\u003e will not overflow, and we can deduce the result of the original multiplication.\u003c/p\u003e\u003cp\u003eBut we can reduce the problem even further! We have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e + \u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e + 1 \u003d (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω)(\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e. Thus, if we can deduce the products in the rings \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω)[\u003ci\u003ey\u003c/i\u003e] / (\u003ci\u003ey\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e - 1)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)[\u003ci\u003ey\u003c/i\u003e] / (\u003ci\u003ey\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e - 1)\u003c/span\u003e, we will be done by the Chinese remainder theorem. Now in either case \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e itself is a \u003cspan class\u003d\"tex-span\"\u003e3\u003ci\u003em\u003c/i\u003e\u003c/span\u003eth root of unity, so we can use FFT to compute the products, assuming that we have an efficient method of calculating products in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eBut this we can solve recursively! Indeed, the method of computing products in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e - 1)\u003c/span\u003e we have outlined goes through almost identically also in the case of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e - ω)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e - ω\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e. The only difference is that we will end up with a ring \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω)[\u003ci\u003ey\u003c/i\u003e] / (\u003ci\u003ey\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e - ω)\u003c/span\u003e (in the first case, the second case is similar), which we can map to the ring \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω)[\u003ci\u003ey\u003c/i\u003e] / (\u003ci\u003ey\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e - 1)\u003c/span\u003e by mapping \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e → \u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e / \u003ci\u003er\u003c/i\u003e\u003c/sup\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. This requires that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e ≥ \u003ci\u003er\u003c/i\u003e\u003c/span\u003e, which is a bit (but not significantly) worse than the condition \u003cspan class\u003d\"tex-span\"\u003e3\u003ci\u003em\u003c/i\u003e ≥ \u003ci\u003er\u003c/i\u003e\u003c/span\u003e we had earlier.\u003c/p\u003e\u003ch2\u003eDetails and optimizations\u003c/h2\u003e\u003cp\u003eWhen implementing the above strategy, it is useful to notice a couple of things.\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eOn the first round of the recursion when we are working in the ring \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)[\u003ci\u003ey\u003c/i\u003e] / (\u003ci\u003ey\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e - 1)\u003c/span\u003e, we note that we can map this to the ring \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω)[\u003ci\u003ey\u003c/i\u003e] / (\u003ci\u003ey\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e - 1)\u003c/span\u003e by conjugation. Since our original data came from ordinary 64-bit integers, conjugation performs as identity on them. Hence the product in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)[\u003ci\u003ey\u003c/i\u003e] / (\u003ci\u003ey\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e - 1)\u003c/span\u003e is just the conjugate of the product in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω)[\u003ci\u003ey\u003c/i\u003e] / (\u003ci\u003ey\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e - 1)\u003c/span\u003e and it is enough to only compute the latter.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eOn further rounds of the recursion we can assume that we are always trying to multiply in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω)\u003c/span\u003e. Indeed, when we would need a result in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)[\u003ci\u003ey\u003c/i\u003e] / (\u003ci\u003ey\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e - ω)\u003c/span\u003e, we can map this by conjugation to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω)[\u003ci\u003ey\u003c/i\u003e] / (\u003ci\u003ey\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e - ω\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e and then perform the change of variables \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e → \u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003ci\u003em\u003c/i\u003e / \u003ci\u003er\u003c/i\u003e\u003c/sup\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e to get to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω)[\u003ci\u003ey\u003c/i\u003e] / (\u003ci\u003ey\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e - 1)\u003c/span\u003e and proceed using FFT as usual.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThe element of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e + \u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e + 1)\u003c/span\u003e that is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003c/span\u003e modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e is given quite concretely by \u003cspan class\u003d\"tex-span\"\u003e3\u003csup class\u003d\"upper-index\"\u003e - 1\u003c/sup\u003e(1 + 2ω)(\u003ci\u003eg\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω) - \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e))\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThe radix-3 FFT is a rather standard modification of the regular radix-2 FFT, so we will not go through it here. The twiddle factors will be powers of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, and therefore one just needs a simple function that lets one compute the product \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/sup\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] / (\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sup\u003e - ω)\u003c/span\u003e. This same function can also be used for the linear changes of variables in the earlier steps.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003ch2\u003eConclusion\u003c/h2\u003e\u003cp\u003eWe have outlined an algorithm for computing exact convolutions modulo \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e64\u003c/sup\u003e\u003c/span\u003e. All the computations are conveniently done modulo hardware. Other methods for exact convolutions include rounding of floating point convolutions, convolutions modulo suitable primes and the Nussbaumer/Schönhage-tricks. The algorithm here is close in spirit to the latter two, but the implementation is simplified because of the extension of scalars. In particular no zeropadding of the polynomials is needed.\u003c/p\u003e\u003cp\u003eRegarding speed: I haven\u0027t tested too much, but it seems reasonably fast, even compared to regular FFT algorithms (not optimized competitive programming snippets).\u003c/p\u003e\u003cp\u003eI\u0027m happy to hear comments or about other interesting approaches! As it is, the code is on the border line of being competition ready. It certainly works if you can copy-paste but writing it down by hand requires some time. In my implementation there are a lot of long comments, so it\u0027s not quite as bloated as it might seem at first, however.\u003c/p\u003e\u003c/div\u003e","tags":[]}}