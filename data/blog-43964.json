{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1458811949,"rating":34,"authorHandle":"fcspartakm","modificationTimeSeconds":1458815015,"id":43964,"title":"\u003cp\u003eРазбор задач Технокубок 2016 — Отборочный Раунд 1\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/648/problem/A\" title\u003d\"Технокубок 2016 - Отборочный Раунд 1\"\u003e648A - Наибольший подъем\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eДля решения данной задачи насчитаем высоту каждой горы и сохраним ее в массиве \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e[]\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e равно высоте \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e-й горы. Для этого обойдем заданную матрицу, и если элемент, стоящий в строке \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e и в столбце \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e (строки и столбцы 0-индексированы), равен звездочке, обновим высоту \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e-й горы: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e] \u003d \u003ci\u003emax\u003c/i\u003e(\u003ci\u003eh\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e], \u003ci\u003en\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e. Осталось просто проитерироваться по столбцам от 0 до m — 2 включительно, и, если текущий столбец равен \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, обновить величину максимального подъема или максимального спуска величиной \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eh\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e + 1] - \u003ci\u003eh\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]|\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПример решения\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eОсновная часть решения:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint n, m;\nint h[N];\nchar c;\n\nvoid solve() {\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\tfor (int j \u003d 0; j \u0026lt; m; j++) {\n\t\t\tcin \u0026gt;\u0026gt; c;\n\t\t\tif (c \u003d\u003d \u0027*\u0027) {\n\t\t\t\th[j] \u003d max(h[j], n - i);\n\t\t\t}\n\t\t}\n\t}\n\tint maxU \u003d 0, maxD \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; m - 1; i++) {\n\t\tint diff \u003d h[i + 1] - h[i];\n\t\tif (diff \u0026gt; 0) {\n\t\t\tmaxU \u003d max(maxU, diff);\n\t\t} else {\n\t\t\tmaxD \u003d max(maxD, -diff);\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; maxU \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; maxD \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/648/problem/B\" title\u003d\"Технокубок 2016 - Отборочный Раунд 1\"\u003e648B - Собери стол\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eДля решения данной задачи сначала посчитаем длину одной собранной ножки стола и сохраним ее в переменную \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e \u003d \u003ci\u003esum\u003c/i\u003e / \u003ci\u003en\u003c/i\u003e\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e\u003c/span\u003e — это суммарная длина всех частей, а \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e — количество ножек стола). Сохраним длины всех частей ножек в массив \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[]\u003c/span\u003e и отсортируем его по возрастанию. Затем переберем части ножек переменной \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e от 0 до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e включительно и будем выводить в ответ пары вида \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e], \u003ci\u003elen\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e])\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПример решения\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eОсновная часть решения:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint n, len, sum;\nint a[N];\n\nint main() {\n\tcin \u0026gt;\u0026gt; n;\n\tfor (int i \u003d 0; i \u0026lt; 2 * n; i++) {\n\t\tcin \u0026gt;\u0026gt; a[i];\n\t\tsum +\u003d a[i];\n\t}   \t\n\tlen \u003d sum / n;\n\tsort(a, a + 2 * n);\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\tcout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; len - a[i] \u0026lt;\u0026lt; endl;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/648/problem/C\" title\u003d\"Технокубок 2016 - Отборочный Раунд 1\"\u003e648C - Путь Робота\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eСначала найдем стартовую позицию Робота, сохраним ее и присвоим значение стартовой позиции звездоке. Так как по условию задана ломаная без самопересечений и самокасаний верен следующий алгоритм: если есть соседняя с текущей клетка, в которой стоит звездочка, перейдем в соседнюю клетку, значение которой равно звездочке, и присвоим ее значение точке (при этом выведем букву, соответствующую направлению, в котором мы перешли). При этом соседняя клетка должна быть отлична от той, из которой мы пришли в текущую клетку. Если нет соседней клетки с звездочкой, значит мы обошли всю ломаную и нужно закончить работу программы.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПример решения\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eОсновная часть решения:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint n, m, sx, sy;\nchar a[N][N];   \n\nint dx[] \u003d {-1, 1, 0, 0};\nint dy[] \u003d {0, 0, -1, 1};\nchar dir[] \u003d {\u0027U\u0027, \u0027D\u0027, \u0027L\u0027, \u0027R\u0027}; \n\nvoid solve() \n{\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\tfor (int j \u003d 0; j \u0026lt; m; j++)\n\t\t{\n\t\t\tcin \u0026gt;\u0026gt; a[i][j];\n\t\t\tif (a[i][j] \u003d\u003d \u0027S\u0027) {\n\t\t\t\tsx \u003d i, sy \u003d j;\n\t\t\t}\n\t\t}\n\t}\n\ta[sx][sy] \u003d \u0027*\u0027;\n\tint px \u003d -1, py \u003d -1;\n        while (true) {\n    \t    bool wasMove \u003d false;\n    \t    for (int i \u003d 0; i \u0026lt; 4; i++) {\n    \t\tint nx \u003d sx + dx[i];\n    \t\tint ny \u003d sy + dy[i];\n    \t\tif (nx \u0026lt; 0 || nx \u0026gt;\u003d n || ny \u0026lt; 0 || ny \u0026gt;\u003d m) {\n    \t\t\tcontinue;\n    \t\t}\n    \t\tif (a[nx][ny] !\u003d \u0027*\u0027) {\n    \t\t\tcontinue;\n    \t\t}\n    \t\tif (nx \u003d\u003d px \u0026amp;\u0026amp; ny \u003d\u003d py) {\n    \t\t\tcontinue;    \t\t\n    \t\t}\n    \t\ta[nx][ny] \u003d \u0027.\u0027;\n    \t\tpx \u003d sx, py \u003d sy;\n    \t\tsx \u003d nx, sy \u003d ny;    \t\t\n    \t\tcout \u0026lt;\u0026lt; dir[i];\t\n    \t\twasMove \u003d true;\n    \t\tbreak;\n            }         \n            if(wasMove) {\n           \tbreak;\n            }\n        }\n    puts(\u0026quot;\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/648/problem/D\" title\u003d\"Технокубок 2016 - Отборочный Раунд 1\"\u003e648D - Собачки и миски\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eЕсли представить каждую миску в виде отрезка \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e]\u003c/span\u003e, то \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-я собачка сможет покушать из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e миски, если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eБудем решать задачу жадно. Рассмотрим самую левую собачку и те миски из которых она может покушать. Если таких мисок нет, то собачка не сможет покушать. В противном случае из мисок доступных самой левой собачке выберем для неё миску с самым левым правым концом. Далее не будем рассматривать эту собачку и эту миску и продолжим аналогично наши рассуждения.\u003c/p\u003e\u003cp\u003eЛегко видеть, что такая жадность приводит к оптимальному ответу:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eЕсли самая левая собачка может покушать, то нет смысла ей не кушать, поскольку этим мы убираем одну миску и ухудшим ответ на единицу;\u003c/li\u003e   \u003cli\u003eРассмотрим те миски из которых может покушать самая левая собачка. Все эти миски будут доступны и остальным собачкам кроме тех у которых правая граница находится слишком далеко влево. Таким образом, если мы хотим взять какую-либо миску (а мы уже поняли из пункта 1, что это стоит сделать), то выгоднее будет взять миску с самым левым правым концом, так мы не ухудшим выбор для собачек справа.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eПо этой задаче можно было попробовать написать другие жадности, но многие являются неправильными.\u003c/p\u003e\u003cp\u003eДля того, чтобы это реализовать отсортируем собачек и миски (по левому концу) слева направо. Будем идти слева-направо обрабатывая события появилась миска (в этом случае добавим её правый конец в какую-нибудь структуру данных) и появилась собачка (нужно для собачки в структуре данных найти самый левый подходящий правый конец).\u003c/p\u003e\u003cp\u003eСложность: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlogn\u003c/i\u003e)\u003c/span\u003e или \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e в зависимости от структуры данных (*set* или \u003cem\u003equeue\u003c/em\u003e).\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eРешения на С++\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003econst int N \u003d 200200;\n\nint n, m;\nint x[N];\nint u[N], t[N];\n\nbool read() {\n\tif (!(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m)) return false;\n\tforn(i, n) assert(scanf(\u0026quot;%d\u0026quot;, \u0026amp;x[i]) \u003d\u003d 1);\n\tforn(i, m) assert(scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;u[i], \u0026amp;t[i]) \u003d\u003d 2);\n\treturn true;\n}\n\npti segs[N];\n\nvoid solve() {\n\tforn(i, m) segs[i] \u003d mp(u[i] - t[i], u[i] + t[i]);\n\n\tsort(x, x + n);\n\tsort(segs, segs + m);\n\n\tint ans \u003d 0;\n\tmultiset\u0026lt;int\u0026gt; z;\n\tfor (int i \u003d 0, j \u003d 0; i \u0026lt; n; ) {\n\t\tif (j \u0026lt; m \u0026amp;\u0026amp; segs[j].x \u0026lt;\u003d x[i]) {\n\t\t\tz.insert(segs[j].y);\n\t\t\tj++;\n\t\t} else {\n\t\t\tauto it \u003d z.lower_bound(x[i]);\n\t\t\ti++;\n\t\t\tif (it !\u003d z.end()) {\n\t\t\t\tans++;\n\t\t\t\tz.erase(it);\n\t\t\t}\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/648/problem/E\" title\u003d\"Технокубок 2016 - Отборочный Раунд 1\"\u003e648E - Собери число\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eЗаметим, что при построении ответа нам в любой момент важен только лишь остаток от деления текущего его префикса на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Действительно, если текущий префикс ответа имеет остаток от деления на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, равный \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e, то при приписывании к префиксу числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e этот остаток станет равный остатку от деления на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e·10\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/sup\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — количество цифр в записи числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eТогда, очевидно, нас интересует получать любой остаток от деления такой операцией, используя минимальное количество цифр в записи. Конечно, остаток 0 мы можем получить сразу, используя пустой префикс, поэтому для остатка 0 нас будет интересовать второй по величине ответ.\u003c/p\u003e\u003cp\u003eВсе описанное выше позволяет нам построить граф на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e вершинах (от \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e, соответственно остаткам), ребра в котором определяются числами \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e: из вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e в вершину \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/36/06/360646f8707dfe8a64c447af24a3b47b6e9177e4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e длины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, означающее, что с помощью дописывания \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e цифр мы можем из префикса с остатком \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e получить префикс с остатком \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e. Легко заметить, что некоторые \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e в этом графе будут соответствовать одним и тем же ребрам (сейчас их \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enk\u003c/i\u003e\u003c/span\u003e) — это числа с одинаковой длиной десятичной записи и остатком от деления на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, поэтому стоит оставить лишь уникальные по такому критерию числа (их будет не больше \u003cspan class\u003d\"tex-span\"\u003e10\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e), и тогда количество ребер не будет превышать \u003cspan class\u003d\"tex-span\"\u003e10\u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eТеперь все, что от нас требуется — найти длину кратчайшего непустого пути из вершины 0 в саму себя же в построенном графе. Чтобы избежать столь неприятной цикличности, давайте просто добавим дополнительную вершину \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, имеющую те же исходящие ребра, что и вершина 0, считая, что такой остаток может иметь лишь пустой префикс. Теперь задача сводится к нахождению кратчайшего пути из вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e в вершину \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, которую можно решить алгоритмом Дейкстры за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e. Однако, в силу специфичности задачи, решение алгоритмом Форда-Беллмана (с правильными отсечениями, конечно) так же проходит все тесты, хоть в теории и имеет столь большие \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eВосстановление ответа в задаче довольно стандартно, за исключением хранения дополнительного числа для каждой вершины, образовавшего ребро, по которому был осуществлен нужный в кратчайшем ответе переход.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПример решения алгоритмом Дейкстры\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eОсновная часть:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    for (int i \u003d 0; i \u0026lt; n; ++i) {\n        int x;\n        assert(scanf(\u0026quot;%d\u0026quot;, \u0026amp;x) \u003d\u003d 1);\n        any[x % k][length(x)] \u003d x;\n    }\n\n    p10[0] \u003d 1;\n    for (int i \u003d 0; i + 1 \u0026lt; P; ++i)\n        p10[i + 1] \u003d (p10[i] * 10) % k;\n\n    for (int i \u003d 0; i \u0026lt;\u003d k; ++i) {\n        d[i] \u003d int(1e9);\n        p[i] \u003d -1;\n        used[i] \u003d false;\n    }\n\n    d[k] \u003d 0;\n    while (true) {\n        int v \u003d -1;\n        for (int i \u003d 0; i \u0026lt;\u003d k; ++i)\n            if (!used[i] \u0026amp;\u0026amp; (v \u003d\u003d -1 || d[v] \u0026gt; d[i]))\n                v \u003d i;\n        if (v \u003d\u003d -1)\n            break;   \n        if (v \u003d\u003d 0)\n            break;\n        used[v] \u003d true;\n        for (int r \u003d 0; r \u0026lt; k; ++r)\n            for (int l \u003d 0; l \u0026lt; P; ++l)\n                if (any[r][l] !\u003d -1) {\n                    int to \u003d (v * p10[l] + r) % k;\n                    if (d[to] \u0026gt; d[v] + l) {\n                        d[to] \u003d d[v] + l;\n                        p[to] \u003d v;\n                        w[to] \u003d any[r][l];\n                        used[to] \u003d false;\n                    }\n                }               \n    }   \n\n    if (p[0] \u003d\u003d -1) {\n        puts(\u0026quot;NO\u0026quot;);\n    } else {\n        puts(\u0026quot;YES\u0026quot;);\n        vector \u0026lt;int\u0026gt; res;\n        int v \u003d 0;\n        do {\n            res.push_back(w[v]);\n            v \u003d p[v];\n        } while (v !\u003d k);\n\n        reverse(res.begin(), res.end());\n        for (auto x: res)\n            printf(\u0026quot;%d\u0026quot;, x);\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["технокубок","отборочный","editorial","разбор"]}}