{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1484821462,"rating":0,"authorHandle":"zscoder","modificationTimeSeconds":1484911837,"id":49867,"title":"\u003cp\u003eWeekly Training Farm 22 — Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eProblem A\u003c/h3\u003e\u003cp\u003eThis problem can be solved by greedy. We list down the positive integers one by one. We keep a pointer that initially points to the first letter of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e. Whenever the pointed character in the string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e matches the corresponding digit of the integer, we move the pointer one step to the right and continue. Repeat this process until the pointer reaches the end. \u003c/p\u003e\u003cp\u003eHowever, we still need to know whether the answer can be large. The key is to note that the answer will never exceed \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e, because after writing down \u003cspan class\u003d\"tex-span\"\u003e10\u003c/span\u003e consecutive numbers, at least one of them has last digit equals to the current digit, so the pointer will move to the right at least once when we write down \u003cspan class\u003d\"tex-span\"\u003e10\u003c/span\u003e consecutive numbers. Thus, in the worse case, we\u0027ll only list down the numbers from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e, which is definitely fast enough.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nvector\u0026lt;pair\u0026lt;char,int\u0026gt; \u0026gt; vec;\nconst int N \u003d 100000;\n\nvoid gen()\n{\n\tfor(int i \u003d 1; i \u0026lt;\u003d N*10; i++)\n\t{\n\t\tint x\u003di;\n\t\tstring r;\n\t\twhile(x)\n\t\t{\n\t\t\tr+\u003dchar(\u00270\u0027+x%10);\n\t\t\tx/\u003d10;\n\t\t}\n\t\tfor(int j \u003d int(r.size())-1;j\u0026gt;\u003d0;j--)\n\t\t{\n\t\t\tvec.pb(mp(r[j],i));\n\t\t}\t\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tgen();\n\tstring s; cin\u0026gt;\u0026gt;s;\n\tint ptr\u003d0; int p2 \u003d 0;\n\twhile(p2\u0026lt;s.length()\u0026amp;\u0026amp;ptr\u0026lt;vec.size())\n\t{\n\t\tif(s[p2]\u003d\u003dvec[ptr].fi) \n\t\t{\n\t\t\tp2++;\n\t\t\tptr++;\n\t\t\tcontinue;\n\t\t}\n\t\tptr++;\n\t}\n\tptr--; //remember this\n\tcout\u0026lt;\u0026lt;vec[ptr].se;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003eProblem B\u003c/h3\u003e\u003cp\u003eThis problem can be solved using dynamic programming. Firstly, observe that if we already determine which set of problems to solve, then it\u0027s best to solve the problem in increasing order of time needed to solve in order to minimize the time penalty. Thus, we can first sort the problems in increasing order of time needed, breaking ties arbitarily.\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e denote the maximum number of problems solved and minimum time penalty acquired when doing so by using exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e minutes and only solving problems among the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e ones. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[0][0] \u003d (0, 0)\u003c/span\u003e (the first integer denotes the number of problems solved and the second integer denotes the time penalty in order to do so). The transitions can be handled easily by simply considering whether to solve the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th problem or not. The time complexity of this solution is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enT\u003c/i\u003e)\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e is the duration of the contest)\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\nconst int N \u003d 100011;\nconst int T \u003d 301;\nii dp[N][T];\nii a[N];\n\nii maxi(ii a, ii b)\n{\n\tif(a.fi!\u003db.fi)\n\t{\n\t\tif(a.fi\u0026gt;b.fi) return a;\n\t\telse return b;\n\t}\n\telse\n\t{\n\t\tif(a.se\u0026lt;b.se) return a;\n\t\telse return b;\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin\u0026gt;\u0026gt;n;\n\tint t \u003d 300;\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++)\n\t{\n\t\tcin\u0026gt;\u0026gt;a[i].fi\u0026gt;\u0026gt;a[i].se;\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i \u003d 0; i \u0026lt;\u003d n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt;\u003d t; j++)\n\t\t{\n\t\t\tdp[i][j]\u003dmp(-1,-1);\n\t\t}\n\t}\n\tdp[0][0] \u003d mp(0,0);\n\tii maxans \u003d mp(0,0);\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt;\u003d 300; j++)\n\t\t{\n\t\t\tdp[i][j] \u003d dp[i-1][j];\n\t\t\tif(j-a[i].fi\u0026gt;\u003d0\u0026amp;\u0026amp;dp[i-1][j-a[i].fi].fi!\u003d-1)\n\t\t\t{\n\t\t\t\tdp[i][j] \u003d maxi(dp[i][j], mp(dp[i-1][j-a[i].fi].fi+1, dp[i-1][j-a[i].fi].se+j+20LL*a[i].se));\n\t\t\t}\n\t\t\tif(i\u003d\u003dn) maxans \u003d maxi(maxans, dp[i][j]);\n\t\t}\n\t}\n\tcout\u0026lt;\u0026lt;maxans.fi\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;maxans.se\u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003eProblem C\u003c/h3\u003e\u003cp\u003eThis is an ad hoc problem. Firstly, we can use two moves to determine what the value of the first bit is. (simply flipping it twice will tell you its value. Now, if the bit is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, you don\u0027t need to flip it anymore. If it\u0027s \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, you\u0027ll need to flip it. In any case, we\u0027ll flip the second bit as well. (if the first bit needs to be flipped, we\u0027ll flip \u003cspan class\u003d\"tex-span\"\u003e[1, 2]\u003c/span\u003e and flip \u003cspan class\u003d\"tex-span\"\u003e[2, 2]\u003c/span\u003e otherwise) After flipping the second bit, we can determine whether it\u0027s a \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e by calculating from the total number of \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003es of the string before the flip and after the flip. We can repeat this for every \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e consecutive bits until we arrive at the last two bits. At this point, we know what the second last bit is, and we also know the total number of \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e bits. So, we can easily deduce the value of the last bit from the information as well. Now, we just need to perform one last flip to make the last \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e bits become \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. The total number of moves made is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + 1\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nint flip(int l, int r)\n{\n\tcout\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;r\u0026lt;\u0026lt;\u0027\\n\u0027;\n\tfflush(stdout);\n\tint cnt; \n\tcin\u0026gt;\u0026gt;cnt;\n\treturn cnt;\n}\n\nint main()\n{\n\tint n; cin\u0026gt;\u0026gt;n;\n\tint c1 \u003d flip(1,1);\n\tif(c1\u003d\u003dn)\n\t{\n\t\tcout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0027\\n\u0027; fflush(stdout);\n\t\treturn 0;\n\t}\n\tint c2 \u003d flip(1,1);\n\tbool pre \u003d 0; //does previous need a flip?\n\tif(c2\u0026lt;c1)\n\t{\n\t\tpre\u003d1;\n\t}\n\tif(c2\u003d\u003dn)\n\t{\n\t\tcout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0027\\n\u0027; fflush(stdout);\n\t\treturn 0;\n\t}\n\tint cnt \u003d c2;\n\tfor(int i \u003d 2; i \u0026lt;\u003d n - 1; i++)\n\t{\n\t\tint prevcnt \u003d cnt;\n\t\tint newcnt;\n\t\tif(pre)\n\t\t{\n\t\t\tnewcnt \u003d flip(i-1,i);\n\t\t\tif(newcnt\u003d\u003dprevcnt)\n\t\t\t{\n\t\t\t\tpre\u003d1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpre\u003d0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnewcnt \u003d flip(i,i);\n\t\t\tif(newcnt\u0026lt;prevcnt)\n\t\t\t{\n\t\t\t\tpre\u003d1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpre\u003d0;\n\t\t\t}\n\t\t}\n\t\tcnt\u003dnewcnt;\n\t\tif(newcnt\u003d\u003dn)\n\t\t{\n\t\t\tcout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0027\\n\u0027; fflush(stdout);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(cnt\u003d\u003dn)\n\t{\n\t\tcout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0027\\n\u0027; fflush(stdout);\n\t\treturn 0;\n\t}\n\tif(cnt\u003d\u003dn-2)\n\t{\n\t\tflip(n-1,n);\n\t\tcout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0027\\n\u0027; fflush(stdout);\n\t\treturn 0;\n\t}\n\tassert(cnt\u003d\u003dn-1);\n\tif(pre)\n\t{\n\t\tflip(n-1,n-1);\n\t\tcout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0027\\n\u0027; fflush(stdout);\n\t}\n\telse \n\t{\n\t\tflip(n,n);\n\t\tcout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0027\\n\u0027; fflush(stdout);\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003eProblem D1\u003c/h3\u003e\u003cp\u003eFirst, we can use \u003cspan class\u003d\"tex-span\"\u003e18\u003c/span\u003e moves to determine the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, by asking \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e19\u003c/span\u003e in increasing order and the first yes answer will be the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. If there\u0027re no \u0026quot;yes\u0026quot; answers, then the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e20\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eCall a number good if it can be represented as the sum of nonnegative multiples of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003es and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. Note that if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is good, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ea\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e are both good.\u003c/p\u003e\u003cp\u003eNow that we have the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, let\u0027s think about what \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e is. Consider the numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eka\u003c/i\u003e + 1, \u003ci\u003eka\u003c/i\u003e + 2, ..., \u003ci\u003eka\u003c/i\u003e + (\u003ci\u003ea\u003c/i\u003e - 1)\u003c/span\u003e for a fixed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. If none of these numbers are good, we can immediately say that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e is larger than \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e + 1)\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. Why? Suppose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e \u003d \u003ci\u003eqa\u003c/i\u003e + \u003ci\u003er\u003c/i\u003e\u003c/span\u003e. Clearly, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e ≠ 0\u003c/span\u003e since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e are coprime. Note that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exa\u003c/i\u003e + \u003ci\u003er\u003c/i\u003e\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e ≥ \u003ci\u003eq\u003c/i\u003e\u003c/span\u003e will be the good, since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exa\u003c/i\u003e + \u003ci\u003er\u003c/i\u003e \u003d (\u003ci\u003eqa\u003c/i\u003e + \u003ci\u003er\u003c/i\u003e) + (\u003ci\u003ex\u003c/i\u003e - \u003ci\u003eq\u003c/i\u003e)\u003ci\u003ea\u003c/i\u003e \u003d \u003ci\u003eb\u003c/i\u003e + (\u003ci\u003ex\u003c/i\u003e - \u003ci\u003eq\u003c/i\u003e)\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. So, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e cannot be less than any of the numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eka\u003c/i\u003e + 1, \u003ci\u003eka\u003c/i\u003e + 2, ..., \u003ci\u003eka\u003c/i\u003e + (\u003ci\u003ea\u003c/i\u003e - 1)\u003c/span\u003e, or else one of these numbers would\u0027ve been good, a contradiction. Note that this also means that if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e is the smallest integer such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eya\u003c/i\u003e + 1, \u003ci\u003eya\u003c/i\u003e + 2, ..., \u003ci\u003eya\u003c/i\u003e + (\u003ci\u003ea\u003c/i\u003e - 1)\u003c/span\u003e are not all bad, then there will be exactly one good number, which will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. Also note that for all integers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u0026gt; \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, there will have at least one good number among \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eka\u003c/i\u003e + 1, \u003ci\u003eka\u003c/i\u003e + 2, ..., \u003ci\u003eka\u003c/i\u003e + (\u003ci\u003ea\u003c/i\u003e - 1)\u003c/span\u003e. Thus, we can now binary search for the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. In each iteration of the binary search, we need to ask at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e - 1 ≤ 19\u003c/span\u003e questions, and there are at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4a/63/4a63661b9374587d0345b639309b4aed4c12fe18.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e iterations, so the maximum number of operations needed is \u003cspan class\u003d\"tex-span\"\u003e19·19 + 18 \u003d 379 \u0026lt; 380\u003c/span\u003e. \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nbool good(int n) //returns whether n can be represented as ax + by\n{\n\tcout\u0026lt;\u0026lt;\u0026quot;? \u0026quot;\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0027\\n\u0027;\n\tfflush(stdout);\n\tint x; cin\u0026gt;\u0026gt;x;\n\treturn x;\n}\n\nconst int N \u003d 500000;\nint main()\n{\n\tint a, b;\n\ta\u003d20;\n\tint t;\n\tcin\u0026gt;\u0026gt;t;\n\twhile(t--)\n\t{\n\t\ta\u003d20;\n\t\tfor(int i \u003d 2; i \u0026lt;\u003d 19; i++)\n\t\t{\n\t\t\tif(good(i))\n\t\t\t{\n\t\t\t\ta\u003di;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint lo \u003d 1; int hi \u003d N/a+2;\n\t\twhile(lo\u0026lt;\u003dhi)\n\t\t{\n\t\t\tint mid \u003d (lo+hi)\u0026gt;\u0026gt;1;\n\t\t\tint pos \u003d -1;\n\t\t\tfor(int i \u003d 1; i \u0026lt;\u003d a - 1; i++)\n\t\t\t{\n\t\t\t\tif(good(mid*a+i))\n\t\t\t\t{\n\t\t\t\t\tpos\u003dmid*a+i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pos\u003d\u003d-1)\n\t\t\t{\n\t\t\t\tlo\u003dmid+1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb\u003dpos;\n\t\t\t\thi\u003dmid-1;\n\t\t\t}\n\t\t}\n\t\tcout\u0026lt;\u0026lt;\u0026quot;! \u0026quot;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\tfflush(stdout);\n\t\t//int x; cin\u0026gt;\u0026gt;x;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003eProblem D2\u003c/h3\u003e\u003cp\u003eThis problem is the same as D1, but with higher constraints. Firstly, we find the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e18\u003c/span\u003e moves as in problem D. To proceed, we need to think about this problem from another angle. Suppose we know a number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e that is good and not a multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, and we can find the maximum number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - \u003ci\u003eka\u003c/i\u003e\u003c/span\u003e is good, then what does this tell us? This means that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - \u003ci\u003eka\u003c/i\u003e\u003c/span\u003e is a multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. Why? We know that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - \u003ci\u003eka\u003c/i\u003e \u003d \u003ci\u003eax\u003c/i\u003e + \u003ci\u003eby\u003c/i\u003e\u003c/span\u003e for some nonnegative integers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - \u003ci\u003eka\u003c/i\u003e\u003c/span\u003e is good. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026gt; 0\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - (\u003ci\u003ek\u003c/i\u003e + 1)\u003ci\u003ea\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e - 1) + \u003ci\u003eby\u003c/i\u003e\u003c/span\u003e is also good, contradicting the maximality of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Thus, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d 0\u003c/span\u003e and so \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - \u003ci\u003eka\u003c/i\u003e \u003d \u003ci\u003eby\u003c/i\u003e\u003c/span\u003e. Note that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e \u0026gt; 0\u003c/span\u003e since we choose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e so that it\u0027s not a multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTo find a value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e is good and not a multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, it is sufficient to take \u003cspan class\u003d\"tex-span\"\u003e500000\u003ci\u003ea\u003c/i\u003e - 1\u003c/span\u003e, since any number greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eab\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e - \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e is guaranteed to be good. (this is a well-known fact)\u003c/p\u003e\u003cp\u003eWe can find the largest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - \u003ci\u003eka\u003c/i\u003e\u003c/span\u003e is good via binary search, because if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - \u003ci\u003ema\u003c/i\u003e\u003c/span\u003e is not good then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - (\u003ci\u003em\u003c/i\u003e + 1)\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e can\u0027t be good. (or else if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - (\u003ci\u003em\u003c/i\u003e + 1)\u003ci\u003ea\u003c/i\u003e \u003d \u003ci\u003eax\u003c/i\u003e + \u003ci\u003eby\u003c/i\u003e\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - \u003ci\u003ema\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e + 1) + \u003ci\u003eby\u003c/i\u003e\u003c/span\u003e) This takes at most \u003cspan class\u003d\"tex-span\"\u003e19\u003c/span\u003e questions.\u003c/p\u003e\u003cp\u003eWhat to do after finding a value which is a multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e? Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e \u003d \u003ci\u003eN\u003c/i\u003e - \u003ci\u003eka\u003c/i\u003e\u003c/span\u003e. We consider the prime factorization of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e. The main claim is that if \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/65/1d/651da44538c370ac90a5f1a72699a8d088aadd0e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is good, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e must be a multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. The reasoning is the same as what we did before. So, we can find the prime factorization of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e, and divide the prime factors one by one. If the number becomes bad, we know that the prime factor cannot be removed, and proceed to the next prime factor. Since a number less than \u003cspan class\u003d\"tex-span\"\u003e500000\u003c/span\u003e can have at most \u003cspan class\u003d\"tex-span\"\u003e18\u003c/span\u003e prime factors (maximum is \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e\u003c/span\u003e), so this takes another \u003cspan class\u003d\"tex-span\"\u003e18\u003c/span\u003e questions.\u003c/p\u003e\u003cp\u003eThus, we only used \u003cspan class\u003d\"tex-span\"\u003e18 + 19 + 18 \u003d 55 \u0026lt; 60\u003c/span\u003e questions to find the values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nbool good(int n) //returns whether n can be represented as ax + by\n{\n\tcout\u0026lt;\u0026lt;\u0026quot;? \u0026quot;\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0027\\n\u0027;\n\tfflush(stdout);\n\tint x; cin\u0026gt;\u0026gt;x;\n\treturn x;\n}\n\nstruct NumberTheory\n{\n\tvector\u0026lt;ll\u0026gt; primes;\n\tvector\u0026lt;bool\u0026gt; prime;\n\tvector\u0026lt;ll\u0026gt; totient;\n\tvector\u0026lt;ll\u0026gt; sumdiv;\n\tvector\u0026lt;ll\u0026gt; bigdiv;\n\tvoid Sieve(ll n)\n\t{\n\t\tprime.assign(n+1, 1);\n\t\tprime[1] \u003d false;\n\t\tfor(ll i \u003d 2; i \u0026lt;\u003d n; i++)\n\t\t{\n\t\t\tif(prime[i])\n\t\t\t{\n\t\t\t\tprimes.pb(i);\n\t\t\t\tfor(ll j \u003d i*2; j \u0026lt;\u003d n; j +\u003d i)\n\t\t\t\t{\n\t\t\t\t\tprime[j] \u003d false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll phi(ll x)\n\t{\n\t\tmap\u0026lt;ll,ll\u0026gt; pf;\n\t\tll num \u003d 1; ll num2 \u003d x;\n\t\tfor(ll i \u003d 0; primes[i]*primes[i] \u0026lt;\u003d x; i++)\n\t\t{\n\t\t\tif(x%primes[i]\u003d\u003d0)\n\t\t\t{\n\t\t\t\tnum2/\u003dprimes[i];\n\t\t\t\tnum*\u003d(primes[i]-1);\n\t\t\t}\n\t\t\twhile(x%primes[i]\u003d\u003d0)\n\t\t\t{\n\t\t\t\tx/\u003dprimes[i];\n\t\t\t\tpf[primes[i]]++;\n\t\t\t}\n\t\t}\n\t\tif(x\u0026gt;1)\n\t\t{\n\t\t\tpf[x]++; num2/\u003dx; num*\u003d(x-1);\n\t\t}\n\t\tx \u003d 1;\n\t\tnum*\u003dnum2;\n\t\treturn num;\n\t}\n\t\n\tbool isprime(ll x)\n\t{\n\t\tif(x\u003d\u003d1) return false;\n\t\tfor(ll i \u003d 0; primes[i]*primes[i] \u0026lt;\u003d x; i++)\n\t\t{\n\t\t\tif(x%primes[i]\u003d\u003d0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid SievePhi(ll n)\n\t{\n\t\ttotient.resize(n+1);\n\t\tfor (int i \u003d 1; i \u0026lt;\u003d n; ++i) totient[i] \u003d i;\n\t\tfor (int i \u003d 2; i \u0026lt;\u003d n; ++i)\n\t\t{\n\t\t\tif (totient[i] \u003d\u003d i)\n\t\t\t{\n\t\t\t\tfor (int j \u003d i; j \u0026lt;\u003d n; j +\u003d i)\n\t\t\t\t{\n\t\t\t\t\ttotient[j] -\u003d totient[j] / i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid SieveSumDiv(ll n)\n\t{\n\t\tsumdiv.resize(n+1);\n\t\tfor(int i \u003d 1; i \u0026lt;\u003d n; ++i)\n\t\t{\n\t\t\tfor(int j \u003d i; j \u0026lt;\u003d n; j +\u003d i)\n\t\t\t{\n\t\t\t\tsumdiv[j] +\u003d i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll getPhi(ll n)\n\t{\n\t\treturn totient[n];\n\t}\n\t\n\tll getSumDiv(ll n)\n\t{\n\t\treturn sumdiv[n];\n\t}\n\t\n\tll modpow(ll a, ll b, ll mod)\n\t{\n\t\tll r \u003d 1;\n\t\tif(b \u0026lt; 0) b +\u003d mod*100000LL;\n\t\twhile(b)\n\t\t{\n\t\t\tif(b\u0026amp;1) r \u003d (r*a)%mod;\n\t\t\ta \u003d (a*a)%mod;\n\t\t\tb\u0026gt;\u0026gt;\u003d1;\n\t\t}\n\t\treturn r;\n\t}\n\t\n\tll inv(ll a, ll mod)\n\t{\n\t\treturn modpow(a, mod - 2, mod);\n\t}\n\t\n\tll invgeneral(ll a, ll mod)\n\t{\n\t\tll ph \u003d phi(mod);\n\t\tph--;\n\t\treturn modpow(a, ph, mod);\n\t}\n\t\n\tvoid getpf(vector\u0026lt;ii\u0026gt;\u0026amp; pf, ll n)\n\t{\n\t\tfor(ll i \u003d 0; primes[i]*primes[i] \u0026lt;\u003d n; i++)\n\t\t{\n\t\t\tint cnt \u003d 0;\n\t\t\twhile(n%primes[i]\u003d\u003d0)\n\t\t\t{\n\t\t\t\tn/\u003dprimes[i]; cnt++;\n\t\t\t}\n\t\t\tpf.pb(ii(primes[i], cnt));\n\t\t}\n\t\tif(n\u0026gt;1)\n\t\t{\n\t\t\tpf.pb(ii(n, 1));\n\t\t}\n\t}\n\n\t//ll op;\n\tvoid getDiv(vector\u0026lt;ll\u0026gt;\u0026amp; div, vector\u0026lt;ii\u0026gt;\u0026amp; pf, ll n, int i)\n\t{\n\t\t//op++;\n\t\tll x, k;\n\t\tif(i \u0026gt;\u003d pf.size()) return ;\n\t\tx \u003d n;\n\t\tfor(k \u003d 0; k \u0026lt;\u003d pf[i].se; k++)\n\t\t{\n\t\t\tif(i\u003d\u003dint(pf.size())-1) div.pb(x);\n\t\t\tgetDiv(div, pf, x, i + 1);\n\t\t\tx *\u003d pf[i].fi;\n\t\t}\n\t}\n};\n\nNumberTheory nt;\n\nconst int N \u003d 500000;\nint main()\n{\n\tnt.Sieve(N+1);\n\tint a, b;\n\ta\u003d20;\n\tint t; cin\u0026gt;\u0026gt;t;\n\twhile(t--)\n\t{\n\t\ta\u003d20;\n\t\tfor(int i \u003d 2; i \u0026lt;\u003d 19; i++)\n\t\t{\n\t\t\tif(good(i))\n\t\t\t{\n\t\t\t\ta\u003di;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint MX \u003d N*a-1;\n\t\tint lo \u003d 1; int hi \u003d N-1;\n\t\tint ans \u003d 0;\n\t\twhile(lo\u0026lt;\u003dhi)\n\t\t{\n\t\t\tint mid\u003d(lo+hi)\u0026gt;\u0026gt;1;\n\t\t\tif(good(MX-mid*a))\n\t\t\t{\n\t\t\t\tans\u003dmid;\n\t\t\t\tlo\u003dmid+1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thi\u003dmid-1;\n\t\t\t}\n\t\t}\n\t\tint big \u003d MX - ans*a; //this thing is a multiple of b\n\t\tvector\u0026lt;ii\u0026gt; ppf;\n\t\tnt.getpf(ppf, big);\n\t\tfor(int i \u003d 0; i \u0026lt; ppf.size(); i++)\n\t\t{\n\t\t\tint p \u003d ppf[i].fi;\n\t\t\twhile(big%p\u003d\u003d0)\n\t\t\t{\n\t\t\t\tif(!good(big/p)) break;\n\t\t\t\tbig/\u003dp;\n\t\t\t}\n\t\t}\n\t\tb\u003dbig;\n\t\tcout\u0026lt;\u0026lt;\u0026quot;! \u0026quot;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\tfflush(stdout);\n\t\t//int x; cin\u0026gt;\u0026gt;x;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003eProblem E\u003c/h3\u003e\u003cp\u003eFirstly, note that a connected graph on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e vertices with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e edges contains exactly \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e cycle. Call the vertices on the cycle the cycle vertices. From each cycle vertex, there\u0027s a tree rooted at it. Thus, call the remaining vertices the tree vertices. Note that the number of useless edges is equal to the length of the cycle.\u003c/p\u003e\u003cp\u003eNow, we do some casework :\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is equal to a tree vertex\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eNote that this will not change the length of the cycle. Thus, we just have to count how many ways are there to change the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e such that the graph remains connected. The observation is that for each tree node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, the only possible values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e are the nodes which are not in the subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e in the tree \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e belongs to. Thus, the number of possibilities can be calculated with a tree dp. For each tree, we calculate the subtree size of each node and add all these subtree sizes and subtract this from the total number of ways to choose a non-tree vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and choosing the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. This part can be done in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is equal to a cycle vertex\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eFor two cycle vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e be the directed distance from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e (We consider the distance from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in the functional graph \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8d/16/8d165c948747ae871ccc6543f002a0ac1a93db2a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for all \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e). Note that if we change \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, and the root of the tree \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is in is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is a cycle vertex), then the length of the cycle after the change will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e, \u003ci\u003eu\u003c/i\u003e) + 1 + \u003ci\u003eh\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e]\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e]\u003c/span\u003e is the height of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e in its tree. The key is instead of fixing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and iterate through all other nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, we iterate through all endpoints \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and see how it changes our answer. Note that if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is fixed, which also means that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is fixed, then we just have to add \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to the answer for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e \u003d \u003ci\u003ed\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e, \u003ci\u003eu\u003c/i\u003e) + 1 + \u003ci\u003eh\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e]\u003c/span\u003e for all cycle vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e. However, note that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e, \u003ci\u003eu\u003c/i\u003e)\u003c/span\u003e ranges from \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e - 1\u003c/span\u003e (where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e denotes the length of the original cycle), so this is equivalent to adding \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to the answer for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e \u003d \u003ci\u003eh\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] + 1, \u003ci\u003eh\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] + 2, ..., \u003ci\u003eh\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] + \u003ci\u003eC\u003c/i\u003e\u003c/span\u003e. Now, we can iterate through all vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and add \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to the answer for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e \u003d \u003ci\u003eh\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] + 1, \u003ci\u003eh\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] + 2, ..., \u003ci\u003eh\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] + \u003ci\u003eC\u003c/i\u003e\u003c/span\u003e. To do this quickly, we can employ the \u0026quot;+1, -1\u0026quot; method. Whenever we want to add \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to a range \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e, we add \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and subtract \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e. Then, to find the actual values of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003c/span\u003e array, we just have to take the prefix sum of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003c/span\u003e array.\u003c/p\u003e\u003cp\u003eFinally, do not forget to subtract the cases where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e from the answer. The total complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int N \u003d 1000011;\n\nbool iscycle[N];\nint visited[N];\nll ans[N];\nint n;\nvi adj[N];\nint a[N];\nvi cyc;\nll subsize[N];\nvector\u0026lt;vector\u0026lt;ll\u0026gt; \u0026gt; vec; //nodes sorted by height\nll subsizesum;\n\nvoid dfs2(int u)\n{\n\tcyc.pb(u);\n\tiscycle[u]\u003d1;\n\tvisited[u] \u003d 3;\n\tif(visited[a[u]] \u003d\u003d 3) return ;\n\tdfs2(a[u]);\n}\n\nvoid findcyc(int u)\n{\n\tvisited[u] \u003d 2;\n\tif(visited[a[u]] \u003d\u003d 0)\n\t{\n\t\tfindcyc(a[u]);\n\t}\n\telse if(visited[a[u]] \u003d\u003d 1)\n\t{\n\t\tvisited[u] \u003d 1;\n\t\treturn ;\n\t}\n\telse\n\t{\n\t\tdfs2(u);\n\t}\n\tvisited[u] \u003d 1;\n}\n\nvoid upd(int l, int r, ll s)\n{\n\tans[r+1]-\u003ds;\n\tans[l]+\u003ds;\n}\n\nint ptr;\nvoid dfs(int u, int d)\n{\n\tif(vec[ptr].size()\u0026lt;\u003dd) vec[ptr].pb(0);\n\tvec[ptr][d]++;\n\tsubsize[u]\u003d1;\n\tfor(int i \u003d 0; i \u0026lt; adj[u].size(); i++)\n\t{\n\t\tint v \u003d adj[u][i];\n\t\tdfs(v,d+1);\n\t\tsubsize[u]+\u003dsubsize[v];\n\t}\n\tif(d\u0026gt;0) subsizesum+\u003dsubsize[u];\n}\n\nint main()\n{\n\t//ios_base::sync_with_stdio(0); cin.tie(0);\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\t//cin\u0026gt;\u0026gt;a[i];\n\t\tscanf(\u0026quot;%d\u0026quot;, a + i);\n\t\ta[i]--;\n\t}\n\tfindcyc(0);\n\tmemset(visited,0,sizeof(visited));\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tif(!(iscycle[a[i]]\u0026amp;\u0026amp;iscycle[i]))\n\t\t{\n\t\t\tadj[a[i]].pb(i);\n\t\t}\n\t}\n\tvec.resize(int(cyc.size()));\n\tint c \u003d cyc.size();\n\tfor(int i \u003d 0; i \u0026lt; cyc.size(); i++)\n\t{\n\t\tdfs(cyc[i],0);\n\t\tptr++;\n\t}\n\tupd(c,c,ll(n-1)*ll(n-c) - subsizesum);\n\tfor(int i \u003d 0; i \u0026lt; c; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; vec[i].size(); j++)\n\t\t{\n\t\t\t//j is the height\n\t\t\tupd(j+1,j+c,vec[i][j]);\n\t\t}\n\t}\n\tupd(c,c,-c); //subtract original cycle edges\n\tll cur\u003d0;\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++)\n\t{\n\t\tcur+\u003dans[i];\n\t\tprintf(\u0026quot;%I64d \u0026quot;, cur);\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}