{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1465139477,"rating":12,"authorHandle":"RussianCodeCup","modificationTimeSeconds":1465139543,"id":45254,"title":"\u003cp\u003eRussian Code Cup 2016 — Third Qualification Round Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv class\u003d\"problem-statement\"\u003e\u003cdiv class\u003d\"header\"\u003e\u003cdiv class\u003d\"title\"\u003eA. Rectangle and Squares\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp\u003eTo solve this problem, notice that the sides of the Elijah\u0027s rectangle don\u0027t matter, only the area is considered. So he can use any number of squares to create a rectangle of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e × \u003ci\u003enC\u003c/i\u003e\u003c/span\u003e for any positive integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe optimal \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is the result of the division \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAB\u003c/i\u003e / \u003ci\u003eC\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e rounded either up or down. So we just check two variants and choose the better one. Additionally, it is important to remember that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u0026gt; 0\u003c/span\u003e, so sometimes it is impossible to round down.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problem-statement\"\u003e\u003cdiv class\u003d\"header\"\u003e\u003cdiv class\u003d\"title\"\u003eB. Zeroes and Ones\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp\u003eFirst notice, that we can make inversions only in one string. Also notice that the order of inversions doesn\u0027t matter.\u003c/p\u003e\u003cp\u003eSo the solution is greedy: consider characters of the first string from left to right. If the corresponding character \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e[\u003ci\u003ei\u003c/i\u003e] ≠ \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e, we inverse characters \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e of the first string. In the end check that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e[\u003ci\u003en\u003c/i\u003e] \u003d \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e[\u003ci\u003en\u003c/i\u003e]\u003c/span\u003e, if it\u0027s not, there is no solution, in the other case we have found the only, and therefore optimal, solution.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problem-statement\"\u003e\u003cdiv class\u003d\"header\"\u003e\u003cdiv class\u003d\"title\"\u003eC. New Track\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp\u003eThe solution is using special construction.\u003c/p\u003e\u003cp\u003eFirst, let us show how to create the track with maximal possible \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Starting with the horizontal segment, each vertical segment would cross all previous horizontal segments except the adjacent one. The example with 14 segments is shown in the picture.\u003c/p\u003e\u003cp\u003e\u003cimg class\u003d\"tex-graphics\" src\u003d\"/predownloaded/48/73/487334ab92890558f82947a28d93aaf868a785c5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eTo get exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e segments first draw \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003el\u003c/i\u003e\u003c/span\u003e segments such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e - 1) / 2 ≥ \u003ci\u003ek\u003c/i\u003e \u0026gt; (\u003ci\u003el\u003c/i\u003e - 1)(\u003ci\u003el\u003c/i\u003e - 2) / 2\u003c/span\u003e, make a small track with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e intersections. To do so, start creating the maximal example, but terminate the last segment after required number of intersections. The remaining \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 2\u003ci\u003el\u003c/i\u003e\u003c/span\u003e segments can be added in the beginning of the track to form the spiral around the smaller track. See picture below for example, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 17\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d 9\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cimg class\u003d\"tex-graphics\" src\u003d\"/predownloaded/16/56/1656f2b3d43fcb73a0025ec0efa5b380fd6cfffd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThe constraint on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is really the maximal bound on the number of intersections of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e segments. We omit the proof, but the hint is: look at the number of intersections of the pair of segments \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e with pairs \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 3\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 4\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 5\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 6\u003c/span\u003e, ..., \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e (or only the segment \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is even).\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problem-statement\"\u003e\u003cdiv class\u003d\"header\"\u003e\u003cdiv class\u003d\"title\"\u003eD. Tree\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp\u003eLet us add weights to tree edges, and set edge weight equal to 1 initially for all edges. Now instead of removing the vertex we would change the weight of the edge from it to its parent to 0. The distance between any pair of vertices would be equal to the distance that would be should we had actually removed the vertex.\u003c/p\u003e\u003cp\u003eWe can solve the new problem as follows. For each vertex in the initial vertex find the distance from the root to the vertex, and put the distances to the array in DFS order. After changing some edge weight, we must change the distances in the continuous segment of the array. This can be implemented using, for example, range tree.\u003c/p\u003e\u003cp\u003eNow the distance between vertices can be found, using : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eab\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e - 2·\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003elca\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elca\u003c/i\u003e\u003c/span\u003e — is the least common ancestor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — is the distance from the root to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problem-statement\"\u003e\u003cdiv class\u003d\"header\"\u003e\u003cdiv class\u003d\"title\"\u003eE. Barbarians\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp\u003eNotice that the angriness of all people in one connected component is equal to their initial angriness multiplied by some value, the same for all islands in this component.\u003c/p\u003e\u003cp\u003eLet us process edge removal in time proportional to the size of the smaller components that appears after its removal. In this case the time complexity of the algorithm would be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. To prove the complexity notice that for each vertex when it is in the smaller component, the size of the component at least halves. So it can only happen \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e times.\u003c/p\u003e\u003cp\u003eIf removing the edge we could know which component is smaller, we could traverse it and move its vertices to a new component, leaving the vertices from the larger one in the old one. But we don\u0027t know which component is smaller. So let us run two BFS-s simultaneously in both components, and when one of them terminates, terminate the other one as well. This way the time for such BFS would be proportional to the size of the smaller component.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}