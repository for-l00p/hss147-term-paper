{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1502910320,"rating":3,"authorHandle":"arman_ferdous","modificationTimeSeconds":1502910320,"id":53907,"title":"\u003cp\u003eGetting TLE on CF Round#426 (div-1) B\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThe problem link : \u003ca href\u003d\"/contest/833/problem/B\" title\u003d\"Codeforces Round 426 (Div. 1)\"\u003e833B - The Bakery\u003c/a\u003e My TLE solution : \u003ca href\u003d\"/contest/833/submission/29511490\" title\u003d\"Submission 29511490 by arman_ferdous\"\u003e29511490\u003c/a\u003e\u003c/p\u003e\u003cp\u003eDefinition of dp state: dp[s][p] means the maximum total value we can get from the p-th part by putting some amount of boxes starting from s. \u003c/p\u003e\u003cp\u003eAnd to calculate the number of distinct integers in a range I used a persistent segment tree. First I stored the previous occurance for each number. Then for any interval i to j I only need to see how many numbers in previous[i...j] are less than i. And that is where the persistent seg tree helped me.\u003c/p\u003e\u003cp\u003eSo if I am not wrong then at the worst case the dp table will be fully filled so the complexity for the solve() function would be O(n*k*distinct_int_query) in this case it is O(n*k*log n). Building the segment tree at first will take O(n*log n). Afterwards updating for each element will take a total of O(n*log n)\u003c/p\u003e\u003cp\u003eSo total complexity would be O(n*k*log n) right? Then why doesn\u0027t it pass? Why TLE???\u003c/p\u003e\u003cp\u003eP.S: Most likely I am wrong. So plz tell how to do the wrong thing right.\u003c/p\u003e\u003c/div\u003e","tags":["dynamic programming","persistent segment tree","#tle","#help"]}}