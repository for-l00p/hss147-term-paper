{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1459190149,"rating":104,"authorHandle":"Errichto","modificationTimeSeconds":1459193634,"id":44047,"title":"\u003cp\u003eVK Cup 2016 Round 1 — Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eCodes in nicer format will be uploaded later.\u003cbr /\u003e\u003ca href\u003d\"/contest/658/problem/A\" title\u003d\"VK Cup 2016 - Round 1 (Div. 2 Edition)\"\u003e658A - Bear and Reverse Radewoosh\u003c/a\u003e and \u003ca href\u003d\"/contest/639/problem/A\" title\u003d\"VK Cup 2016 - Round 1\"\u003e639A - Bear and Displayed Friends\u003c/a\u003e — \u003ca href\u003d\"http://ideone.com/NYuwV8\"\u003ecodes\u003c/a\u003e.\u003cbr /\u003e\u003ca href\u003d\"/contest/639/problem/B\" title\u003d\"VK Cup 2016 - Round 1\"\u003e639B - Bear and Forgotten Tree 3\u003c/a\u003e and \u003ca href\u003d\"/contest/639/problem/C\" title\u003d\"VK Cup 2016 - Round 1\"\u003e639C - Bear and Polynomials\u003c/a\u003e — \u003ca href\u003d\"http://ideone.com/GcUNZJ\"\u003ecodes\u003c/a\u003e.\u003cbr /\u003e\u003ca href\u003d\"/contest/639/problem/D\" title\u003d\"VK Cup 2016 - Round 1\"\u003e639D - Bear and Contribution\u003c/a\u003e — \u003ca href\u003d\"http://ideone.com/FkE3DU\"\u003ecodes\u003c/a\u003e.\u003cbr /\u003e\u003ca href\u003d\"/contest/639/problem/E\" title\u003d\"VK Cup 2016 - Round 1\"\u003e639E - Bear and Paradox\u003c/a\u003e — \u003ca href\u003d\"http://ideone.com/OoSLF3\"\u003ecodes\u003c/a\u003e.\u003cbr /\u003e\u003ca href\u003d\"/contest/639/problem/F\" title\u003d\"VK Cup 2016 - Round 1\"\u003e639F - Bear and Chemistry\u003c/a\u003e — \u003ca href\u003d\"http://ideone.com/PUSLI2\"\u003ecodes\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/658/problem/A\" title\u003d\"VK Cup 2016 - Round 1 (Div. 2 Edition)\"\u003e658A - Bear and Reverse Radewoosh\u003c/a\u003e — Iterate once from left to right to calculate one player\u0027s score and then iterate from right to left. It\u0027s generally good not to write something similar twice because you are more likely to make mistakes. Or maybe later you will find some bug and correct it only in one place. So, try to write calculating score in a function and run them twice. Maybe you will need to reverse the given arrays in some moment.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/639/problem/A\" title\u003d\"VK Cup 2016 - Round 1\"\u003e639A - Bear and Displayed Friends\u003c/a\u003e — You should remember all friends displayed currently (in set or list) and when you add someone new you must check whether there are at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e people displayed. If there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e then you can iterate over them (over \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e people in your set/list) and find the worst one. Then — remove him. The intended complexity is O(n + q*k).\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/639/problem/B\" title\u003d\"VK Cup 2016 - Round 1\"\u003e639B - Bear and Forgotten Tree 3\u003c/a\u003e — You may want to write some special \u003ccode\u003eif\u003c/code\u003e for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 2\u003c/span\u003e. Let\u0027s assume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≥ 3\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e \u003d 1\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e \u0026gt; 2\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e then there is no answer (it isn\u0027t hard to see and prove). Otherwise, let\u0027s construct a tree as follows.\u003c/p\u003e\u003cp\u003eWe need a path of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e starting from vertex \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and we can just build it. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e \u0026gt; \u003ci\u003eh\u003c/i\u003e\u003c/span\u003e then we should also add an other path from vertex \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, this one with length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e - \u003ci\u003eh\u003c/i\u003e\u003c/span\u003e. Now we have the required height and diameter but we still maybe have too few vertices used. But what we built is one path of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e ≥ 2\u003c/span\u003e. You can choose any vertex on this path other than ends of the path (let\u0027s call him \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e), and add new vertices by connecting them all directly with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. You can draw it to see that you won\u0027t increase height or diameter this way. In my code I sometimes had \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e \u003d 1\u003c/span\u003e but sometimes (when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e \u003d \u003ci\u003eh\u003c/i\u003e\u003c/span\u003e) I needed some other vertex and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e \u003d 2\u003c/span\u003e was fine.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/639/problem/C\" title\u003d\"VK Cup 2016 - Round 1\"\u003e639C - Bear and Polynomials\u003c/a\u003e, my favorite problem in this contest. Let\u0027s count only ways to decrease one coefficient to get the required conditions (you can later multiply coefficient by \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e and run your program again to also calculate ways to increase a coefficient).\u003c/p\u003e\u003cp\u003eOne way of thinking is to treat the given polynomial as a number. You can find the binary representation — a sequence with \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e\u0027s and \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e\u0027s of length at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ae/37/ae3721b551573bafae6863b0c9d1dcf18b1856cb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Changing one coefficient affects up to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/48/0d/480dfdf3f723194843b210eca8bb38ab575847d7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e consecutive bits there and we want to get a sequence with only \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e\u0027s. We may succeed only if all \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e\u0027s are close to each other and otherwise we can print \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e to the output. Let\u0027s think what happens when \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e\u0027s are close to each other.\u003c/p\u003e\u003cp\u003eLet\u0027s say that we got a sequence with two \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e\u0027s as follows: \u003cspan class\u003d\"tex-span\"\u003e...00101000...\u003c/span\u003e. Decreasing by \u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e one coefficient (the one that was once in a place of the current first bit \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e) will create a sequence of \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e\u0027s only. It\u0027s not complicated to show that decreasing coefficients on the right won\u0027t do a job (because the first \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e will remain there) but you should also count some ways to change coefficients on the left. We can decrease by \u003cspan class\u003d\"tex-span\"\u003e10\u003c/span\u003e a coefficient on the left from first \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, or decrease by \u003cspan class\u003d\"tex-span\"\u003e20\u003c/span\u003e a coefficient even more on the left, and so on. Each time you should check whether changing the original coefficient won\u0027t exceed the given maximum allowed value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eOne other solution is to go from left to right and keep some integer value — what number should be added to the current coefficient to get sum equal to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e on the processed prefix. Then, we should do the same from right to left. In both cases maybe in some moment we should break because it\u0027s impossible to go any further. In one case it happens when we should (equally) divide an odd number by \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e, and in the other case it happens when our number becomes too big (more than \u003cspan class\u003d\"tex-span\"\u003e2·10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e) because we won\u0027t be able to make it small again anyway.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/639/problem/D\" title\u003d\"VK Cup 2016 - Round 1\"\u003e639D - Bear and Contribution\u003c/a\u003e — It isn\u0027t enough to sort the input array and use two pointers because it\u0027s not correct to assume that the optimal set of people will be an interval. Instead, let\u0027s run some solution five times, once for each remainder after dividing by \u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e (remainders \u003cspan class\u003d\"tex-span\"\u003e0, 1, 2, 3, 4\u003c/span\u003e). For each remainder \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e we assume that we should move \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e people to some value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/39/2c/392c09f944686daff5c54121e50d8e4b30230f1a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (and at the end we want at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e people to have contribution \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e). Note that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e must be close to some number from the input because otherwise we should decrease \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e and for sure we would get better solution. The solution is to iterate over possible values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e from lowest to highest (remember that we fixed remainder \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/aa/fe/aafe911fe0282ad39faf5fd4961c54a815a2689a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e). At the same time, we should keep people in \u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e vectors/lists and do something similar to the two pointers technique. We should keep two pointers on each of \u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e lists and always move the best among \u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e options. The complexity should be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e·5)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/639/problem/E\" title\u003d\"VK Cup 2016 - Round 1\"\u003e639E - Bear and Paradox\u003c/a\u003e — It\u0027s good to know what to do with problems about optimal order. Often you can use the following trick — take some order and look at two neighbouring elements. When is it good to swap? (When does swapping them increase the score?) You should write some simple formula (high school algebra) and get some inequality. In this problem it turns out that one should sort problems by a fraction \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0a/87/0a873a582d7470611169c3f417cdf1ab94037570.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and it doesn\u0027t depend on a constant \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e. There may be many problems with the same value of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0a/87/0a873a582d7470611169c3f417cdf1ab94037570.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and we can order them however we want (and the question will be: if there is a paradox for at least one order). Let\u0027s call such a set of tied problems a block.\u003c/p\u003e\u003cp\u003eFor each problem you can calculate its minimum and maximum possible number of granted points — one case is at the end of his block and the other case is to solve this problem as early as possible so at the beginning of his block. So, for fixed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e for each problem we can find in linear time the best and worst possible scores (given points).\u003c/p\u003e\u003cp\u003eWhen do we get a paradox? Where we have two problems \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u0026lt; \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e was worth less points) we solved problem \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e much earlier and later we got less points for problem \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. We can now use some segment tree or sort problems by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and check whether there is a pair of problems with inequalities we are looking for — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u0026lt; \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u0026gt; \u003ci\u003emin\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e we found in the previous paragraph.\u003c/p\u003e\u003cp\u003eWe can do the binary search over the answer to get complexity \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bf/8f/bf8fd38bc8f2ad8fcf989eda68ea9f00856b9931.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e or faster. Can you solve the problem in linear time?\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/639/problem/F\" title\u003d\"VK Cup 2016 - Round 1\"\u003e639F - Bear and Chemistry\u003c/a\u003e — Task is about checking if after adding some edges to graph, some given subset of vertices will be in one biconnected component. Firstly, let\u0027s calculate biconnected components in the initial graph. For every vertex in each query we will replace it with index of its bicon-component (for vertices from subset and for edges endpoints). Now we have a forest. When we have a list of interesting vertices in a new graph (bicon-components of vertices from subset or edges) we can compress an entire forest, so it will containg at most 2 times more vertices than the list (from query) and will have simillar structure to forest. To do it, we sort vertices by left-right travelsal order and take LCA of every adjacent pair on the sorted list. If you have compressed forest, then you just have to add edges and calculate biconnected components normally, in linear time.\u003c/p\u003e\u003c/div\u003e","tags":[]}}