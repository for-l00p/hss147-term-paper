{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1433853398,"rating":8,"authorHandle":"_kryptonyte_","modificationTimeSeconds":1433853398,"id":18430,"title":"\u003cp\u003eSegment Tree Problem:Poj 3277\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eProblem Link : \u003ca href\u003d\"http://poj.org/problem?id\u003d3277\"\u003ehttp://poj.org/problem?id\u003d3277\u003c/a\u003e The full code, \u003ca href\u003d\"http://ideone.com/RF1JfE\"\u003ehttp://ideone.com/RF1JfE\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is a very straight forward segment tree problem( if I don\u0027t miss anything ) , but unfortunately it just don\u0027t get AC. Obviously I miss something. Can anybody help. I try to build a seg tree with minimum 2 range sized leaf nodes by following code where Tree[nd] holds the height of the range.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid build( int nd , int st , int en ) {\n    Tree[nd] \u003d 0 ;\n    if( st+1 \u003d\u003d en )return ;\n    build( (nd\u0026lt;\u0026lt;1) , st , (st+en)\u0026gt;\u0026gt;1 );\n    build( (nd\u0026lt;\u0026lt;1)+1 , (st+en)\u0026gt;\u0026gt;1 , en );\n} \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen I update like following manner, here l,r is the index of the value given in the problem,\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid update( int nd , int st , int en ) {\n    propagate(nd,st,en) ;\n    if( st \u003d\u003d en ) return  ;\n    if( st \u0026gt; r || en \u0026lt; l ) return ;\n    if( st\u0026gt;\u003dl \u0026amp;\u0026amp; en \u0026lt;\u003d r ) {\n        Tree[nd] \u003d max( Tree[nd] , h ) ;\n        return ;\n    }\n    if( st+1 \u003d\u003d en ) return  ;\n    update( (nd\u0026lt;\u0026lt;1) , st , (st+en)\u0026gt;\u0026gt;1 );\n    update( (nd\u0026lt;\u0026lt;1)+1 , (st+en)\u0026gt;\u0026gt;1 , en );\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd finally run the query,\u003c/p\u003e \u003cpre\u003e\u003ccode\u003elong long query( int nd , int st , int en ) {\n    propagate(nd,st,en) ;\n    if( st \u003d\u003d en ) return 0 ;\n    if( en-st \u003d\u003d 1 ) {\n        long long ans \u003d (V[en]-V[st])*Tree[nd] ;\n        return ans ;\n    }\n\n    return query( (nd\u0026lt;\u0026lt;1) , st , (st+en)\u0026gt;\u0026gt;1 )\n           +query( (nd\u0026lt;\u0026lt;1)+1 , (st+en)\u0026gt;\u0026gt;1 , en );\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}