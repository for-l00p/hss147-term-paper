{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1467137213,"rating":0,"authorHandle":"aostankov","modificationTimeSeconds":1467280428,"id":45729,"title":"\u003cp\u003eДень 3. Деревья\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eНа мой взгляд это первый сложный контест, где надо было не только написать какой-то стандартный алгоритм, но и значительно подумать головой. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача А. LCA Начало.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eПростая задача на нахождение LCA, которую можно было решать \u0026quot;в лоб\u0026quot;. На каждый GET запрос подниматься от двух вершин одновременно, пока не упремся в одну вершину. В ADD запросе просто подвешиваем новую вершину.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача B. LCA Продолженние.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВ этой задача ограничения уже не позволяли писать тупое решение и заставляли применять технику двоичного подъема. Когда поступает ADD запрос, необходимо пересчитать динамику для него. Ну а GET запрос обрабатывается как обычный запрос LCA. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача С. LCA Запрос минимума.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eКоличество запросов на нахождение LCA двух вершин мягко намекало нам, что на на запросы требуется отвечать за O(1), и при том отвечать надо было в режиме онлайн. Есть единственный алгоритм, который на это способен — это сведение LCA к RMQ и использование разреженных таблиц (Sparse Table). Как сводить LCA к RMQ вам рассказаи на лекции. Далее на полученной массиве требовалось за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eNlog\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e построить sparse table, чтобы затем отвечать на запросы rmq за O(1). Как строить Sparse Table было тоже рассказано на последней лекции.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача D. Выбор столицы Древляндии\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eПостроим ориентированный граф по данному, в который добавим по два ребра для каждого ребра исходного графа вида (a;b). Первое из этих ребер будет (a;b) c нулевым весом, а второе будет (b;a) с единичным весом. После этого решим задачу за два поиска в глубину по полученному графу. Заведём два массива \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e1[]\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e2[]\u003c/span\u003e, которые будем заполнять в первом и втором дфсе. В первом дфсе запустим обход из любой вершины, и в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e1[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e будем хранить кол-во рёбер, которые нужно перенаправить в поддереве вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, чтобы из неё можно было дойти до всех вершин её поддерева только по прямым рёбрам. Считаем обычной динамикой на поддеревьях, начиная с листов. Теперь для \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-ой вершины нам осталось узнать, сколько рёбер нужно перевернуть в тех вершинах, которые являются потомками для вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Для этого запустим второй поиск в глубину из того же корня из которого запускали первый поиск в глубину. в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e2[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e будем хранить ответ для \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-ой вершины. Так как мы знаем, сколько рёбер нужно перенаправить в поддереве для \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e нам останется узнать, сколько нужно перевернуть в потомках. Допустим, что у нас есть ребро (p;v), и для p мы уже знаем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e2[\u003ci\u003ep\u003c/i\u003e]\u003c/span\u003e, тогда \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e2[\u003ci\u003ev\u003c/i\u003e] \u003d \u003ci\u003edp\u003c/i\u003e2[\u003ci\u003ep\u003c/i\u003e]\u003c/span\u003e + некоторая величина \u003d cost, где cost \u003d 1, если ребро ведёт изначально из p в v, и cost \u003d -1, если в изначальном графе ребро вело из v в p.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача E. А и B и аудитории.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВ задаче требовалось найти количество вершин в дереве, которые находятся на одинаковом расстоянии от вершин a и b. Для начала логично было бы найти расстояние от a до b. Пусть h[v] — глубина вершины v. Тогда расстояние между парой вершин (a, b) \u003d h[a] + h[b] — h[lca(a, b)]. В данной задаче (да и вообще по жизни) удобно было использовать двоичный подьем для нахождения LCA, так как нам он еще пригодится. Если расстояние нечетное, то очевидно, что ответ 0. Иначе найдем вершину, которая лежит на одинаковом расстоянии от a и b (тем же двоичным подьемом), назовем ее v и рассотрим несколько случаев. 1. Вершина v \u003d\u003d lca(a, b). Тогда ответом будут все вершины во внешнем поддреве относительно вершины v, и все вершины поддерева v, кроме поддеревьев, где находятся вершины a и b (эти вершины тоже ищутся бинарным подьемом). ans \u003d (n — size[v]) + size[v] — size[exclude_a] — size[exclude_b] \u003d n — size[] — size[]. 2. Вершина v !\u003d lca(a, b). \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача F. Супер М.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВ задаче требовалось выбрать стартовую вершину так, что время, затраченное на посещение помеченных вершин, было бы минимальным. Достаточно ясно, что по некоторым ребрам мы пойдем два раза, а по некоторым один раз. Далее нужно было понять, что ребра, по которым мы пройдем один раз, образуют путь, а все остальные — это какие-то поддеревья, которые примыкают к этому пути. Если мы преобразуем наше дерево так, что в листах и в корне останутся только помеченные вершины, то получается, что нам надо найти диаметр этого дерева. По ребрам, которые вошли в диаметр мы пройдемся один раз, а по всем остальным два раза. Таким образом, стартовая вершина должна быть один из концов диаметра, а время, за которое мы обойдем все дерево \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e \u003d \u003ci\u003en\u003c/i\u003e + \u003ci\u003en\u003c/i\u003e - \u003ci\u003ediam\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача G. Новогоднее взаимодействие Санта-Клаусов.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЧто такое мат ожидание цены d(c1, c2)+d()+d()? Это сумма d()+d()+d() по всем тройкам (c1, c2, c3) деленная на количество этих троек, то есть на n*(n-1)*(n-2). Сумма d(v, u) это сумма по ребрам. Давайте тогда посчитаем сколько раз каждое ребро войдет в ответ. Пусть ребро (u, v) разбивает дерево на два дерева размерами A и B. Тогда данное ребро войдет в ответ ровно (A*(A-1)*B+A*B*(B-1))*3 раз. Первое слагаемое это количество путей, проходящих через данную вершину, если два города расположены в поддереве размера A, а третья вершина расположена в другом поддереве. Второе слагаемое получается аналогично. Умножаем на три потому, что у нас есть три перестановки, которые подходят под каждый случай. Таким образом, ребро (u, v) весом w дает к ответу w * ( (A*(A-1)*B+A*B*(B-1))*6 ) / ( n*(n-1)*(n-2) ). Просуммировав все ребра мы найдем ответ для текущего года. При изменении веса ребра не составит труда пересчитать ответ: надо вычесть старое значение и прибавить новое.\u003c/p\u003e\u003c/div\u003e","tags":[]}}