{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1522516701,"rating":0,"authorHandle":"sumit.chaturvedi","modificationTimeSeconds":1522516858,"id":58663,"title":"\u003cp\u003eEdmond Karp\u0027s Algorithm\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello everyone!\u003c/p\u003e\u003cp\u003eI have been trying to solve problem 1273 on POJ (\u003ca href\u003d\"http://poj.org/problem?id\u003d1273\"\u003ehttp://poj.org/problem?id\u003d1273\u003c/a\u003e). According to me, it is a straight forward application of a max-flow algorithm. But there is some problem in my implementation. I have searched online for the solution and generated test cases. Both the online solution and mine pass them. Yet POJ doesn\u0027t accept my solution. I have gone through my code atleast 10 times. If someone can point out my mistake, I\u0027ll be really grateful.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eYour code here...\n\u003c/code\u003e\u003c/pre\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;queue\u0026gt;\n\n#define fori(i,n) for(int i \u003d 0; i \u0026lt; n; i++)\n#define INF 10000005\n\nusing namespace std;\n// Stores the residual graph\nvector\u0026lt;vector\u0026lt;long long\u0026gt; \u0026gt; gf;\n\nvoid reset_graph(int v){\n    fori(i,v){\n        fori(j,v){\n            gf[i][j] \u003d INF;\n        }\n    } \n}\n\nint ekarp(int v){\n    bool path_exists \u003d true;\n    int flow \u003d 0;\n    while(path_exists){\n        path_exists \u003d false;\n        vector\u0026lt;int\u0026gt; path(v,-1);\n        vector\u0026lt;bool\u0026gt; marked(v, false);\n        queue\u0026lt;int\u0026gt; q;\n        q.push(0);\n        marked[0] \u003d true;\n        while(!q.empty() \u0026amp;\u0026amp; !path_exists){\n            int tp \u003d q.front();\n            q.pop();\n            fori(i,v){\n                if(gf[tp][i] \u0026lt; INF \u0026amp;\u0026amp; !marked[i] \u0026amp;\u0026amp; gf[tp][i] \u0026gt; 0){\n                    q.push(i);\n                    marked[i] \u003d true;\n                    path[i] \u003d tp;\n                    if(i \u003d\u003d v-1){\n                        path_exists \u003d true;\n                    }\n                }\n            }\n        }\n        if(path_exists){\n            long long bn \u003d INF;\n            int prev \u003d v-1;\n            while(path[prev] !\u003d -1){\n                bn \u003d min(bn,gf[path[prev]][prev]);\n                prev \u003d path[prev];\n            }\n            prev \u003d v-1;\n            while(path[prev] !\u003d -1){\n                gf[path[prev]][prev] -\u003d bn;\n                gf[prev][path[prev]] +\u003d bn; \n                prev \u003d path[prev];\n            }\n            flow+\u003d bn;\n        }\n    }\n    return flow;\n}\n\nint main(){\n    int e,v;\n    gf.resize(205);\n    fori(i,205) gf[i].resize(205,INF);\n    while(scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;e, \u0026amp;v) !\u003d EOF){\n        reset_graph(v);\n        fori(i, e){\n            int u,w,c;\n            scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;u, \u0026amp;w, \u0026amp;c);\n            u--;\n            w--;\n            gf[u][w] \u003d c;\n            gf[w][u] \u003d 0;\n        }\n        printf(\u0026quot;%d\\n\u0026quot;, ekarp(v));\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["#network flow"]}}