{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1525908474,"rating":0,"authorHandle":"lucasturci","modificationTimeSeconds":1525908588,"id":59373,"title":"\u003cp\u003eDijkstra\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003e\u003cstrong\u003eDijkstra\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eÉ um algoritmo que resolve o problema de Single-Source Shortest Paths (SSP), ou seja, encontra o menor caminho de um vértice de partida a todos os outros do grafo.\u003c/p\u003e\u003ch3\u003eCódigo\u003c/h3\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003econst int inf \u003d 0x3f3f3f3f; // inf \u003d 1061109567 (um bom valor porque eh maior que 10^9, 2 * inf nao estoura um inteiro e eh rapido de fazer memset\nvector\u0026lt;int\u0026gt; edges[N], costs[N]; // vetor de adjacencias, vetor de pesos\nint dist[N], pred[N], n; // vetor de distancias minimas, vetor de predecessor, numero de vertices\n\n// Realiza o algoritmo partindo do vertice s (start)\nvoid dijkstra(int s) {\n\n    priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; pq;\n    // guarda os proximos vertices a serem visitados, junto com sua distancia minima com sinal trocado  {-dist[u], u}\n    // o sinal eh trocado porque queremos uma priority_queue de minimo. Como queremos ordenar pela distancia, \n    // ela deve vir primeiro no pair\n\n    for(int i \u003d 1; i \u0026lt;\u003d n; ++i) dist[i] \u003d inf;\n    \n    // inicia com o vertice s (de partida)\n    pq.push(make_pair(0, s))\n    dist[s] \u003d 0;\n\n    while(pq.size()) {\n        int u \u003d pq.top().second; // pega o proximo vertice\n        pq.pop(); //retira\n\n        // olha pros adjacentes\n        for(int i \u003d 0; i \u0026lt; edges[u].size(); ++i) {\n            int v \u003d edges[u][i];\n            int w \u003d costs[u][i];\n            if(dist[v] \u0026gt; dist[u] + w) { // relaxa a aresta\n                dist[v] \u003d dist[u] + w; // atualiza a distancia\n                pred[v] \u003d u; // atualiza o predecessor\n                pq.push(make_pair(-dist[v], v)); // coloca na priority queue\n            } \n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}