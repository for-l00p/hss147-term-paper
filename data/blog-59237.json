{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1525399173,"rating":-48,"authorHandle":"CodingKnight","modificationTimeSeconds":1525576052,"id":59237,"title":"\u003cp\u003eC++17 data structure for the simple Sieve of Eratosthenes algorithm\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThe following is C++17 data structure \u003ccode\u003eprimes_t\u003c/code\u003e for the simple Sieve of Eratosthenes algorithm that features: \u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eConstructor \u003ccode\u003eprimes_t( int M, int N )\u003c/code\u003e that computes all prime numbers in the interval \u003ccode\u003e[M,N]\u003c/code\u003e, and stores those ordered prime numbers in an inherited \u003ccode\u003evector\u0026lt; int \u0026gt;\u003c/code\u003e base class.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eMember function \u003ccode\u003ebool exists( int x )\u003c/code\u003e that uses binary search to find whether or not \u003ccode\u003ex\u003c/code\u003e exists among prime numbers in the specified interval. \u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eInheriting all public member functions of \u003ccode\u003evector\u0026lt; int \u0026gt;\u003c/code\u003e as public members functions of \u003ccode\u003eprimes_t\u003c/code\u003e. \u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nstruct primes_t: vector\u0026lt; int \u0026gt;\n{\n    primes_t( int M, int N )\n    {\n        int p \u003d 3, x \u003d 0, z \u003d ( N - 1 ) / 2; bool composite_odd[ z ];\n\n        for( int x1 \u003d 0; x1 \u0026lt; z; x1++ )\n            composite_odd[ x1 ] \u003d false;\n\n        if ( M \u0026lt;\u003d 2 \u0026amp;\u0026amp; N \u0026gt;\u003d 2 )\n            push_back( 2 );\n\n        for( int q \u003d sqrt( N ); p \u0026lt;\u003d q; p +\u003d 2, x++ )\n            if ( !composite_odd[ x ] )\n            {\n                if ( p \u0026gt;\u003d M )\n                  push_back( p );\n\n                for( int x1 \u003d p * x + 3 * ( x + 1 ), y1 \u003d p * p; y1 \u0026lt;\u003d N; x1 +\u003d p, y1 +\u003d 2 * p )\n                    composite_odd[ x1 ] \u003d true;\n            }\n\n        do\n        {\n            if ( !composite_odd[ x ] \u0026amp;\u0026amp; p \u0026gt;\u003d M )\n                push_back( p );\n\n             p +\u003d 2, x++;\n        }\n        while( p \u0026lt;\u003d N );\n    }\n\n    bool exists( int x ) const \n    { \n        return binary_search( cbegin(), cend(), x ); \n    }\n};\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFor example, the following program computes and prints the count of prime numbers in the interval \u003ccode\u003e[M,N]\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint main()\n{\n    int M, N;\n\n    cin \u0026gt;\u0026gt; M \u0026gt;\u0026gt; N;\n\n    cout \u0026lt;\u0026lt; primes_t( M, N ).size();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe data structure can be used by Codeforces as any other shared library in the public domain. \u003c/p\u003e\u003cp\u003eThank you.\u003c/p\u003e\u003c/div\u003e","tags":[]}}