{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1469942550,"rating":20,"authorHandle":"codeonwort","modificationTimeSeconds":1469943318,"id":46350,"title":"\u003cp\u003eEducational Round 15 A~D Solutions with Haskell\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eEducational Round 15 â€” Haskell version. I can\u0027t solve E and F. :P\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/702/problem/A\" title\u003d\"Educational Codeforces Round 15\"\u003e702A - Maximum Increase\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI think it\u0027s trivial, so just see: \u003ca href\u003d\"/contest/702/submission/19483133\" title\u003d\"Submission 19483133 by codeonwort\"\u003e19483133\u003c/a\u003e\u003c/p\u003e\u003cp\u003eOne thing to mention is that you don\u0027t need to hold all integers in memory. You can process integers one by one, thus space complexity can be reduced to O(1), but in this case the problem size is small (N \u0026lt;\u003d 100000) so I reused my previous code that reads whole string at once.\u003c/p\u003e\u003cp\u003eTime complexcity : O(N)\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/702/problem/B\" title\u003d\"Educational Codeforces Round 15\"\u003e702B - Powers of Two\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAll of n integers satisfy 1 \u0026lt;\u003d a[i] \u0026lt;\u003d 10^9. Then possible sums that are any power of 2 are 2 \u0026lt;\u003d 2^x \u0026lt;\u003d 2^30.\u003c/p\u003e\u003cp\u003ejustification:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e1 + 1 \u003d 2\u003c/li\u003e   \u003cli\u003e10^9 \u003d (10^3)^3 \u0026lt; (2^10)^3 \u003d 2^30\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eTherefore for each a[i] and 2^x (1 \u0026lt;\u003d x \u0026lt;\u003d 30), we count the number of a[j] such that a[i] + a[j] \u003d 2^x.\u003c/p\u003e\u003cp\u003eFirst, traverse the input and map each integer to the number of appearence of it. Let\u0027s call this mapping \u003cem\u003ebook\u003c/em\u003e. I used \u003ccode\u003eData.Map.Strict.Map\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eSecond, for each a[i] and 2^x, count the combinations.\u003c/p\u003e \u003cul\u003e   \u003cli\u003eIf \u003ccode\u003ea[i] \u0026gt;\u003d 2^x\u003c/code\u003e, then there is no solution.\u003c/li\u003e   \u003cli\u003eIf \u003ccode\u003e2^x - a[i]\u003c/code\u003e is not in the book, there is no solution.\u003c/li\u003e   \u003cli\u003eIf \u003ccode\u003e2^x - a[i] \u003d\u003d a[i]\u003c/code\u003e, then there is \u003ccode\u003ebook[2^x - a[i]] - 1\u003c/code\u003e solutions.\u003c/li\u003e   \u003cli\u003eOtherwise, there is \u003ccode\u003ebook[2^x - a[i]]\u003c/code\u003e solutions.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSum up all solutions and divide by 2 (We didn\u0027t consider \u003ccode\u003ei \u0026lt; j\u003c/code\u003e constraints, so all combinations have been counted twice), then print it: \u003ca href\u003d\"/contest/702/submission/19513379\" title\u003d\"Submission 19513379 by codeonwort\"\u003e19513379\u003c/a\u003e\u003c/p\u003e\u003cp\u003eBecause the answer can be pretty big, I used \u003ccode\u003eInteger\u003c/code\u003e rather than \u003ccode\u003eInt\u003c/code\u003e. I always forget this. In my computer \u003ccode\u003eInt\u003c/code\u003e is 64-bit, but it seems in Codeforces \u003ccode\u003eInt\u003c/code\u003e is 32-bit. So always use \u003ccode\u003eData.Int.Int64\u003c/code\u003e or \u003ccode\u003eInteger\u003c/code\u003e for big answers.\u003c/p\u003e\u003cp\u003eTime complexity: O(NlogN)\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/702/problem/C\" title\u003d\"Educational Codeforces Round 15\"\u003e702C - Cellular Network\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s consider the line as a 1D Voronoi diagram. That is, we assign for each tower an area in which any city is related to that tower. Because it\u0027s 1D situation and all towers are given sorted, this is very easy: the boundaries are just the middle of consecutive two towers.\u003c/p\u003e\u003cp\u003eSorted boundaries given, for each city we binary search the tower it relates to, calculate the distance between them, update the maximum distance so far: \u003ca href\u003d\"/contest/702/submission/19530243\" title\u003d\"Submission 19530243 by codeonwort\"\u003e19530243\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIt\u0027s annoying that Haskell doesn\u0027t allow O(1) destructive update of an array, but in this case we only need reading array. Happy array time!\u003c/p\u003e\u003cp\u003eTime complexity: O(N + MlogM)\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/702/problem/D\" title\u003d\"Educational Codeforces Round 15\"\u003e702D - Road to Post Office\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is a math problem, nothing specific to Haskell. See the official editorial: \u003ca href\u003d\"//codeforces.com/blog/entry/46324?locale\u003den\"\u003ehttp://codeforces.com/blog/entry/46324?locale\u003den\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["haskell"]}}