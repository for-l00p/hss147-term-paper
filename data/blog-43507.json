{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1456926113,"rating":6,"authorHandle":"dorellin","modificationTimeSeconds":1456935834,"id":43507,"title":"\u003cp\u003eGema Aula 2 2016\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eDISCLAIMER:\u003c/strong\u003e escrevi isso tudo em uma sentada, pode estar cheio de erros. Se achar algo me avise :)\u003c/p\u003e\u003cp\u003eÀ partir de hoje, resolvi escrever um tutorial simples sobre os assuntos vistos na aula. Como vocês devem ter notado, devido à presença de muita gente, bastante gente ficou perdida e não conseguiu ouvir as explicações. A idéia desse post é servir de referência da aula.\u003c/p\u003e\u003cp\u003eOs tópicos que serão abordados hoje são \u003cstrong\u003efor\u003c/strong\u003e, \u003cstrong\u003evetores\u003c/strong\u003e e \u003cstrong\u003estrings\u003c/strong\u003e. Além disso, iremos ver alguns algoritmos que só precisam desses conceitos!\u003c/p\u003e\u003cp\u003eAproveitem que vocês fazem computação e quando estiverem em dúvida de algo, TESTEM! :) \u003c/p\u003e\u003ch2\u003eA construção \u003ccode\u003efor\u003c/code\u003e\u003c/h2\u003e\u003cp\u003eAssim como o \u003ccode\u003ewhile\u003c/code\u003e, a construção \u003ccode\u003efor\u003c/code\u003e permite que um bloco de comandos seja executado múltiplas vezes. A estrutura do for é \u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (inicialização ; condição de parada ; incremento ) {\n    // Bloco a ser executado \n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eVamos ver como isso funciona por partes: \u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003e\u003cstrong\u003eInicialização\u003c/strong\u003e: É um comando que vai ser executado somente UMA vez, no início do for. Nesse momento, geralmente inicializamos um contador: \u003ccode\u003efor (int i \u003d 0; ...\u003c/code\u003e ou alguma coisa do tipo. É possível declarar variáveis na hora de inicializar o for.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003cstrong\u003eCondição de parada\u003c/strong\u003e: Depois de cada execução do bloco de comandos do for, a condição de parada será testada. Ela deve ser uma expressão cujo resultado é true (qualquer coisa não 0, em C/C++) ou false (0). Se a avaliação da expressão for false, o loop irá terminar e o código continuará a ser executado da linha após o final do for. Um exemplo comum de condição de parada é testar se o contador já atingiu um certo número: \u003ccode\u003efor (int i \u003d 0; i \u0026lt; n; ...)\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003cstrong\u003eIncremento\u003c/strong\u003e: É um comando executado \u003cstrong\u003eAPÓS\u003c/strong\u003e cada bloco do for. Um uso comum é incrementar um contador: \u003ccode\u003efor (int i \u003d 0; i \u0026lt; n; ++i)\u003c/code\u003e. (aqui, \u003ccode\u003e++i\u003c/code\u003e é igual a \u003ccode\u003ei +\u003d 1\u003c/code\u003e). \u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eA declaração de variáveis segue prioridade de escopo. Por exemplo, se tivermos o seguinte código:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint main (void) {\n    int x \u003d 0;\n    for (int x \u003d 0; x \u0026lt; 5; ++x) {\n        cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl;\n    }\n    cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt;  endl;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eA variável \u003ccode\u003ex\u003c/code\u003e declarada dentro do for não é a mesma declarada fora. Como o for está mais interno à variável \u003ccode\u003ex\u003c/code\u003e declarada na main, qualquer uso de \u003ccode\u003ex\u003c/code\u003e dentro do for se refere à variável declarada dentro do for, e perdemos o acesso à variável declarada anteriormente. Quando o for acaba, a \u003ccode\u003ex\u003c/code\u003e passa a se referir à variável inicial, uma vez que todas as variáveis declaradas no bloco interno deixam de existir. É bom ficar atento nisso!\u003c/p\u003e\u003ch2\u003eVetores\u003c/h2\u003e\u003cp\u003eSuponha que você precise, para resolver um problema, ler \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e números e imprimir a diferença de cada um deles para a média. Nesse problema, apenas um for não basta, pois quando lemos o número ainda não sabemos qual é a média. É preciso guardar esses valores.\u003c/p\u003e\u003cp\u003eAí que entram vetores. Mas antes disso, vamos aprender o que é o escopo global e local. Como foi explicado na sessão anterior, as variáveis possuem escopos. Uma variável declarada dentro de um for dentro da função main têm prioridade à uma declarada fora, e assim por diante. Uma variável declarada fora de qualquer função é chamada de variável global, e é acessível em qualquer parte do código. \u003c/p\u003e\u003cp\u003ePodemos, portanto, fazer algo assim:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint n;\n\nint main (void) {\n    cin \u0026gt;\u0026gt; x;\n    cout \u0026lt;\u0026lt; x*10 \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eA variável \u003ccode\u003ex\u003c/code\u003e, declarada fora do escopo da função \u003ccode\u003emain\u003c/code\u003e, é acessível dela. Se declarássemos outro \u003ccode\u003ex\u003c/code\u003e dentro da main, entretanto, ela deixaria de ser acessível. \u003c/p\u003e\u003cp\u003eGeralmente, não é uma boa prática de programação utilizar variáveis globais (esse é um dos motivos, se eu tiver um \u003ccode\u003ex\u003c/code\u003e global não poderia (ou não deveria — melhor dizendo), criar uma variável \u003ccode\u003ex\u003c/code\u003e em nenhum outro lugar). Porém, na maratona de programação, utilizar variáveis globais é ótimo, porque:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eGeralmente, há mais espaço para alocar variáveis globais (As variáveis locais — não alocadas dinâmicamente — são alocadas na pilha e geralmente o tamanho da pilha é limitado)\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eÉ mais fácil acessá-las em funções se necessário, poupando o tempo e a passagem de parâmetros (veremos isso mais para a frente)\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eResumindo, se você for precisar de um dado em outra função ou se for alocar muita memória (como faremos com vetores), tente usar variáveis globais, pois elas facilitam bastante a solução de problemas.\u003c/p\u003e\u003cp\u003eVoltando aos vetores, para resolver o problema da média, vamos declarar uma variável especial: um vetor. Um vetor nada mais que é um espaço \u003cstrong\u003econtínuo\u003c/strong\u003e de memória. \u003c/p\u003e\u003cp\u003eFaça o seguinte teste, antes de mais nada:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint main (void) {\n    int x;\n    scanf (\u0026quot;%d\u0026quot;, \u0026amp;x);\n    printf (\u0026quot;Valor \u003d %d  Endereco \u003d %d\\n\u0026quot;, x, \u0026amp;x);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs funções \u003ccode\u003eprintf\u003c/code\u003e e \u003ccode\u003escanf\u003c/code\u003e são análogas ao \u003ccode\u003ecin\u003c/code\u003e e \u003ccode\u003ecout\u003c/code\u003e. A diferença principal está na sintaxe — porém elas são bastante úteis para explicar como funcionam os endereços de memória em C++. \u003c/p\u003e\u003cp\u003eA função \u003ccode\u003escanf\u003c/code\u003e recebe pelo menos um argumento, que é uma string de formato (uma sequencia de caracteres delimitada por \u003ccode\u003e\u0026quot;\u003c/code\u003e). A expressão \u003ccode\u003e%d\u003c/code\u003e indica que queremos ler um número inteiro. Para cada valor esperado de leitura (cada \u003ccode\u003e%\u003c/code\u003e é seguido de uma expressão para um tipo diferente, que pode ser checada em \u003ca\u003ehttp://www.cplusplus.com/reference/cstdio/scanf/)\u003c/a\u003e, o scanf espera um \u003cstrong\u003eendereço de memória\u003c/strong\u003e. Quando criamos variáveis com linhas do tipo \u003ccode\u003eint x\u003c/code\u003e, e fazemos \u003ccode\u003ecin \u0026gt;\u0026gt; x\u003c/code\u003e, ao acessar o símbolo \u003ccode\u003ex\u003c/code\u003e estamos nos referindo à seu valor. Para acessar seu endereço de memória, fazemos \u003ccode\u003e\u0026amp;x\u003c/code\u003e. Por esse motivo, para ler um inteiro com o \u003ccode\u003escanf\u003c/code\u003e, fazemos \u003ccode\u003escanf (\u0026quot;%d\u0026quot;, \u0026amp;x)\u003c/code\u003e e não \u003ccode\u003escanf (\u0026quot;%d\u0026quot;, x)\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eO \u003ccode\u003eprintf\u003c/code\u003e funciona da mesma maneira, porém ele imprime exatamente o valor dado nos argumentos seguintes à string de formato. Se passamos \u003ccode\u003ex\u003c/code\u003e, ele imprime o valor de \u003ccode\u003ex\u003c/code\u003e, pois a função espera um valor. Se tentarmos fazer \u003ccode\u003escanf (\u0026quot;%d\u0026quot;, x)\u003c/code\u003e, estamos dizendo que tentamos ler uma variável no endereço de memória representado pelo valor de \u003ccode\u003ex\u003c/code\u003e, o que geralmente não é o que queremos fazer. Ao acessar \u003ccode\u003ex\u003c/code\u003e, estamos acessando o valor que está guardado no endereço de memória de x. \u003ccode\u003ecin\u003c/code\u003e e \u003ccode\u003ecout\u003c/code\u003e cuidam dessas coisas de forma transparente. \u003c/p\u003e\u003cp\u003eO que acontece quando precisamos declarar um vetor? Utilizamos o seguinte código.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint v[100];\n\nint main (void) {\n    int n;\n    scanf (\u0026quot;%d\u0026quot;, \u0026amp;n);\n    for (int i \u003d 0; i \u0026lt; n; ++i) {\n        scanf (\u0026quot;%d\u0026quot;, \u0026amp;v[i]); \n        // scanf (\u0026quot;%d\u0026quot;, v + i);\n    }\n    printf (\u0026quot;%d\\n\u0026quot;, v); \n    printf (\u0026quot;%d\\n\u0026quot;, v[0]);\n    printf (\u0026quot;%d\\n\u0026quot;, *(v));\n    printf (\u0026quot;%d\\n\u0026quot;, *(v+1));\n    printf (\u0026quot;%d\\n\u0026quot;, \u0026amp;v[1]);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ePrimeiramente, note que fizemos uma declaração global. Para declarar um vetor, fazemos como uma variável normal, mas colocamos seu tamanho entre \u003ccode\u003e[]\u003c/code\u003e. Execute o código acima e observe seu resultado.\u003c/p\u003e\u003cp\u003eQuando declaramos uma variável, por exemplo, \u003ccode\u003ex\u003c/code\u003e, o símbolo \u003ccode\u003ex\u003c/code\u003e se refere à seu valor. Quando declaramos um vetor, o símbolo \u003ccode\u003ex\u003c/code\u003e se refere ao endereço de memória da primeira posição do vetor. Então, quando queremos acessar o conteúdo do vetor, temos duas opções:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ccode\u003ev[pos]\u003c/code\u003e: o operador \u003ccode\u003e[]\u003c/code\u003e no vetor pega o conteúdo da posição de memória (v+pos), que é o conteúdo do vetor na posição pos.\u003c/li\u003e   \u003cli\u003e*(v+pos): o operator \u003ccode\u003e*\u003c/code\u003e serve em geral para acessar o conteúdo que está em um endereço. Teste criar uma variável do tipo int normal, atribuir um valor, e fazer \u003ccode\u003e*(\u0026amp;x)\u003c/code\u003e e verá que tem o mesmo efeito de acessar \u003ccode\u003ex\u003c/code\u003e \u003c/li\u003e \u003c/ul\u003e\u003cp\u003eRecomendo que você faça um monte de testes para se acostumar com o conceito — a idéia de vetores e endereços de memória é simples, basta fazer alguns programas para se acostumar e tirar todas as dúvidas.\u003c/p\u003e\u003cp\u003ePS: vetores globais são inicializados com 0.\u003c/p\u003e\u003ch2\u003eStrings\u003c/h2\u003e\u003cp\u003eObviamente, existem outros tipos de dados além dos inteiros. Por exemplo, ao invés de declarar um vetor de inteiros, podemos declarar um vetor de caracteres: \u003ccode\u003echar v[100]\u003c/code\u003e. A diferença de um inteiro para um caractere é o número de bytes — 32 vs. 4, mas, além disso, a semântica é outra. \u003c/p\u003e\u003cp\u003eUtilizamos \u003ccode\u003echar\u003c/code\u003e quando queremos trabalhar com caracteres. Em C++, caracteres representáveis pelo tipo \u003ccode\u003echar\u003c/code\u003e estão mapeados na tabela ASCII (\u003ca href\u003d\"http://www.asciitable.com/\"\u003ehttp://www.asciitable.com/\u003c/a\u003e) — ou seja, cada caractere tem um número correspondente. Tente fazer o seguinte:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint main (void) {\n    char c;\n    cin \u0026gt;\u0026gt; c;\n    cout \u0026lt;\u0026lt; \u0027a\u0027 \u0026lt;\u0026lt; \u0026quot;  \u0026quot; \u0026lt;\u0026lt; ((int) \u0027a\u0027) \u0026lt;\u0026lt;  \u0026quot; \u0026quot; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ((int)c) \u0026lt;\u0026lt; endl;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eQuando fazemos \u003ccode\u003e(int)c\u003c/code\u003e, estamos imprimindo o valor numérico do caractere \u003ccode\u003ec\u003c/code\u003e. Quando imprimimos somente \u003ccode\u003ec\u003c/code\u003e, o que sairá na tela é o valor correspondente na tabela ascii desse número. É \u003cstrong\u003eimportantíssimo\u003c/strong\u003e saber que podemos fazer contas com caracteres, assim não precisamos \u003cstrong\u003eNUNCA\u003c/strong\u003e decorar seus valores. Por exemplo:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003echar prox \u003d \u0027a\u0027 + 2;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSe você imprimir \u003ccode\u003eprox\u003c/code\u003e como caractere, por exemplo fazendo \u003ccode\u003eprintf (\u0026quot;%c\\n\u0026quot;, prox)\u003c/code\u003e, vai ver que sairá um \u003ccode\u003ec\u003c/code\u003e na tela. Isso se deve ao fato dos valores numéricos dos caracteres minúsculos e maiúsculos serem contínuos (olhe lá na tabela ASCII). Não é incomum utilizar a conta \u003ccode\u003ec \u003d c - \u0027a\u0027 + \u0027A\u0027\u003c/code\u003e por exemplo, para transformar um caractere de minúsculo para maísculo. Cabe a você entender como isso funciona. Também, para checar se um caractere é minúsculo, podemos fazer \u003ccode\u003eif (c \u0026gt;\u003d \u0027a\u0027 and c \u0026lt;\u003d \u0027z\u0027)\u003c/code\u003e.\u003c/p\u003e\u003cp\u003ePor fim, uma string nada mais é que um vetor de caracteres. Veja o exemplo\u003c/p\u003e \u003cpre\u003e\u003ccode\u003echar s[11];\nint main (void) {\n    scanf (\u0026quot;%s\u0026quot;, s);\n    // cin \u0026gt;\u0026gt; s;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eO \u003ccode\u003escanf\u003c/code\u003e possui o identificador \u003ccode\u003e%s\u003c/code\u003e, para indicar que queremos ler uma sequencia de caracteres. Até onde os caracteres são lidos? Até um \u003ccode\u003e\\n\u003c/code\u003e (quebra de linha) ou até um espaço. O mesmo vale para o \u003ccode\u003ecin\u003c/code\u003e. Porém, para ler uma string, o \u003ccode\u003escanf\u003c/code\u003e já espera um endereço de memória. Nenhum dos dois checa se o número de caracteres que está sendo lido cabe no vetor de caracteres correspondente, então tome cuidado! \u003c/p\u003e\u003cp\u003ePor fim, como sabemos onde uma string termina? Suponha que declaramos \u003ccode\u003echar v[10]\u003c/code\u003e mas a entrada do programa era \u003ccode\u003ebob\u003c/code\u003e. Essa string tem apenas 3 caracteres — o que vier depois não deve importar. Tanto o \u003ccode\u003ecin\u003c/code\u003e quanto o \u003ccode\u003escanf\u003c/code\u003e colocam ao final da string um caractere especial, o \u003ccode\u003e\\0\u003c/code\u003e, indicando o final da string. Portant, se você espera em seu programa strings de tamanhoa até 100, \u003cstrong\u003eseu vetor deve ter tamanho até 101\u003c/strong\u003e, para acomodar esse caractere extra no final.\u003c/p\u003e\u003cp\u003eNas próximas aulas veremos o uso da \u003ccode\u003estring\u003c/code\u003e do C++. Por hoje, tente utilizar vetores de caracteres para se acostumar com o conceito. :)\u003c/p\u003e\u003ch2\u003eBônus: O Crivo de Erastótenes\u003c/h2\u003e\u003cp\u003eVamos aplicar a idéia de vetores para resolver um problema famoso: calcular quais são os números primos de 1 a N. Fazendo isso, iremos observar um uso bastante comum de vetores na maratona: marcar o resultado de alguma coisa para um número.\u003c/p\u003e\u003cp\u003eO crivo de erastótenes funciona da seguinte forma. Vamos olhar todos os números de 2 a N. Se ele não foi marcado ainda, significa que ele é primo. Ao encontrar um primo, marcamos todos os seus múltiplos. Por exemplo, ao encontrar o 2, marcamos o 2, o 4, o 6... pois sabemos que todos esses números não são primos. O próximo número que olhamos é o 3: como ele ainda não foi marcado, assumimos que ele é primo. Suponha que queremos fazer isso até o número \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e. O código seria:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003econst int N \u003d 1000001;\n// not_prime[i] é 1 se o número i não é primo!\nbool not_prime[N];\n\nint main (void) {\n    for (int i \u003d 2; i \u0026lt; N; ++i) {\n        if (not_prime[i] \u003d\u003d false) {\n            for (int x \u003d i+i; x \u0026lt; N; x +\u003d i) {\n                not_prime[x] \u003d true;\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRepare que utilizamos um vetor não para ler os valores, mas para marcar os números que não são primos. Além disso, veja que poderíamos ter começado o \u003ccode\u003efor\u003c/code\u003e interior de \u003ccode\u003ei*i\u003c/code\u003e (por quê?).\u003c/p\u003e\u003cp\u003eQuantas operações serão realizadas?\u003c/p\u003e\u003cp\u003ePara o 2, iremos marcar \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e / 2\u003c/span\u003e posições. Para o 3, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e / 3\u003c/span\u003e e assim por diante. Em suma, teremos \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/60/c3/60c399c2191ad7304c28f37d52099d6448d87a8f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e operações, que é equivalente a \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5a/71/5a7107926661e24084c61067dc4cbfd728ba6695.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Como sabemos que a série harmônica é limitada por \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e, faremos no máximo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eNlog\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e operações (você pode provar isso usando cálculo no final do semestre!). \u003c/p\u003e\u003ch2\u003eFAQ\u003c/h2\u003e\u003ch3\u003eQual a diferença entre ++i e i++?\u003c/h3\u003e\u003cp\u003e\u003ccode\u003e++i\u003c/code\u003e faz a conta (\u003ccode\u003ei \u003d i + 1\u003c/code\u003e) e depois retorna o valor. Já \u003ccode\u003ei++\u003c/code\u003e primeiro retorna o valor e depois incrementa. Faça o teste:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint i \u003d 4;\ncout \u0026lt;\u0026lt; (++i) \u0026lt;\u0026lt; endl;\ni \u003d 4;\ncout \u0026lt;\u0026lt; (i++) \u0026lt;\u0026lt; endl;\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eComo eu compilo código no linux?\u003c/h3\u003e\u003cp\u003eSimples. Navegue até o diretório em que o código está salvo (utilizando os comandos \u003ccode\u003epwd\u003c/code\u003e, \u003ccode\u003els\u003c/code\u003e e \u003ccode\u003ecd\u003c/code\u003e — veja o que eles fazem). Quando estiver no diretório certo: \u003ccode\u003eg++ codigo.cpp -o nome_do_executavel\u003c/code\u003e. Isso vai gerar um arquivo binário executável que pode ser executado com \u003ccode\u003e./nome_do_executavel\u003c/code\u003e.\u003c/p\u003e\u003ch3\u003eEu preciso ficar digitando os casos de teste na mão toda vez que for testar meu programa?\u003c/h3\u003e\u003cp\u003eNo windows e no linux, se você estiver utilizando o terminal, é possível utilizar arquivos no lugar da entrada padrão. Por exemplo, suponha que a entrada do seu problema sejam 3 números. Você pode criar um arquivo chamado \u003ccode\u003eproblema.in\u003c/code\u003e, por exemplo (a extensão pouco importa, só colocamos o \u003ccode\u003e.in\u003c/code\u003e para ficar mais claro), e então colocar o caso de teste nesse arquivo. Então, ao rodar seu programa, você pode fazer \u003ccode\u003e./programa \u0026lt; problema.in\u003c/code\u003e. Toda vez que seu programa tentar ler da entrada padrão (\u003ccode\u003ecin\u003c/code\u003e ou \u003ccode\u003escanf\u003c/code\u003e, por exemplo), ele irá ler do arquivo em seu lugar. Dessa forma você não precisa ficar redigitando a entrada toda hora ;)\u003c/p\u003e\u003ch3\u003eComo eu pego o tamanho de uma string?\u003c/h3\u003e\u003cp\u003e\u003ccode\u003estrlen (str)\u003c/code\u003e. Cuidado com esse método: ele passa por toda a string contando os caracteres até achar o \u003ccode\u003e\\0\u003c/code\u003e. Se você fizer o seguinte:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (int i \u003d 0; i \u0026lt; strlen(s); ++i) {\n   // faz algo\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eA cada etapa do for o tamanho da string será recalculado. Você consegue imaginar que isso é lento, né?\u003c/p\u003e\u003ch3\u003eQual o valor máximo de número que cabe em um inteiro?\u003c/h3\u003e\u003cp\u003eImprima INT_MAX no seu código. Se precisar de um número maior, utilize o tipo long long. Os inteiros vão até aprox. \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e (o valor exato descubra você mesmo), enquanto um long long consegue representar até aprox. \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e","tags":[]}}