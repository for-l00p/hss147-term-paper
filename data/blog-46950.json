{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1473032286,"rating":10,"authorHandle":"HardW3ll","modificationTimeSeconds":1473032775,"id":46950,"title":"\u003cp\u003eQualification round #1 editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem A\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThe problem is we want to color the graph into two colors such that no two nodes are colored by \u00271\u0027 and are adjacent to each other. Let\u0027s use topological sort. For each node if it has degree zero check if there is an edge going into it from a node that is colored by \u00271\u0027. if not we give it the color \u00271\u0027. After that there may remain some non-intersecting cycles in the graph. The answer from the cycle will be the number of nodes in the cycle / 2 (integer division).\u003c/p\u003e\u003cp\u003eComplexity \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f1/98/f198ba730b50abde86962f7b8a851ec80a8f89b2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/kfiUaE\"\u003eSolution\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem B\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eIt\u0027s clear that in an optimal move, If a player takes an element x and another number y where x \u0026lt;\u003d y, then it\u0027s optimal to choose every element z where x \u0026lt;\u003d z \u0026lt;\u003d y. So if the array is sorted, an optimal move will be to choose a consecutive subarray. It\u0027s also clear that as each player tries to maximize his score, the right end of the subarray must be as large as possible. So the first move will be a subarray [i, j] where j \u003d n — 1, the second move will be a subarray [i\u0027, j\u0027] where j\u0027 \u003d i — 1, and so on. Now the resulting problem can be solved using dynamic programming.\u003c/p\u003e\u003cp\u003eComplexity \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/22/95/229590595d8dba3f35d6fd84a86fce6cc6199346.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/Uj7oA9\"\u003eSolution\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem C\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eLet\u0027s generate a complete graph of n nodes where the edge going from i to j has a cost of the number of characters that must be added such that if you attach the string j to the end of them the answer will have both string i, j as a recurrence. In other words edge[i][j] \u003d size of string i — longest suffix of i that matches a prefix in j. That part can be solved easily using kmp. Now we want to start at some node and walk over exactly M — 1 edges such that the total length is minimized. It can be solved using dynamic programming where dp[i][M] \u003d for all j min(DP[i][M], DP[j][M-1] + cost[i][j]) As M is large and the recurrence is linear, the problem can be solved using matrix exponentiation.\u003c/p\u003e\u003cp\u003eComplexity \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d0/1b/d01b14f8f8b697d42d0ce808b1d266774c6c4d43.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/Cgzw3h\"\u003eSolution\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem D\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eLet\u0027s have a prefix hash for the array and its reverse. Now let\u0027s try all possible k. For each k we loop over the n / k parts, get the hash of each part and it\u0027s reverse in O(1), and try to find it or its reverse in a set of hashes you have.\u003c/p\u003e\u003cp\u003eComplexity \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7d/44/7d44642304a6b584b3ccec688422d53bef148624.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/0UiT9Y\"\u003eSolution\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem F\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFor each two consecutive characters, we\u0027ll fix them as the center of an antipalindromic string. We\u0027ll use binary search to determine the largest antipalindromic substring that its center is the two fixed characters. The check will be to get the hash of the substring and the hash of the substring if it was reversed and each character is flipped, which can be generated in O(1) using prefix hashing.\u003c/p\u003e\u003cp\u003eComplexity \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/22/95/229590595d8dba3f35d6fd84a86fce6cc6199346.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/tXc0ch\"\u003eSolution\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}