{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1528225934,"rating":9,"authorHandle":"pkaspre","modificationTimeSeconds":1528226278,"id":59858,"title":"\u003cp\u003eLi Chao trees\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003eHi everyone!\u003c/h4\u003e\u003cp\u003eAs I promised, I attach my implementation of Li Chao tree. This is min tree, so it finds min f(x) among all functions inserted to the tree.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSource code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003etypedef long long int ll;\n\nconst ll inf \u003d 3e10;\n\nstruct Line {\n    ll a,b;\n    Line(){\n        this-\u0026gt;a \u003d 0;\n        this-\u0026gt;b \u003d inf;\n    }\n    Line(ll a, ll b) {\n        this-\u0026gt;a \u003d a;\n        this-\u0026gt;b \u003d b;\n    }\n    \n    ll y(ll x) {\n        return a*x+b;\n    }\n};\n\nstruct tree {\n    Line lin;\n};\n\n//[l,r) - line borders, [b,e) - tree vertex interval\nvoid update(int l, int r, int b, int e, Line li, tree Tree[]) {\n    if(b \u0026gt;\u003d r || e \u0026lt;\u003d l)\n        return;\n    \n    if(l \u0026lt;\u003d b \u0026amp;\u0026amp; r \u0026gt;\u003d e) {\n        int m \u003d (b+e) / 2;\n        int x \u003d b+e;\n        \n        if (li.y(m) \u0026lt; Tree[x].lin.y(m))\n            swap(Tree[x].lin, li);\n        if (e-b \u003d\u003d 1)\n            return;\n        if (li.y(b) \u0026lt; Tree[x].lin.y(b))\n            update(l,r,b,(b+e)/2, li, Tree);\n        else\n            update(l, r, (b+e)/2, e, li, Tree);\n\n    } else {\n        update(l,r,b,(b+e)/2, li, Tree);\n        update(l,r,(b+e)/2, e,li, Tree);\n    }\n}\n\n//[l,r) - tree vertex interval\nll query(int l, int r, int x, tree Tree[]) {\n    int v \u003d l+r;\n    int m \u003d v/2;\n    \n    if(r-l\u003d\u003d1)\n        return Tree[v].lin.y(x);\n    \n    if(x \u0026lt; m) {\n        return min(Tree[v].lin.y(x), query(l,m,x,Tree));\n    }\n    return min(Tree[v].lin.y(x), query(m, r, x, Tree));\n    \n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eBrief summarize of what this tree can do:\u003c/p\u003e \u003col\u003e   \u003cli\u003eAdd function f(x) \u003d ax + b \u003cem\u003e[complexity depends, from log(n) up to log^2(n)]\u003c/em\u003e,\u003c/li\u003e   \u003cli\u003eFind min/max f(x0) in point x0 among all inserted functions \u003cem\u003e[log(n)]\u003c/em\u003e.\u003c/li\u003e \u003c/ol\u003e\u003ch4\u003eHere are problems which we discussed:\u003c/h4\u003e \u003col\u003e   \u003cli\u003e\u003ca href\u003d\"//codeforces.com/contest/988/problem/F\"\u003eRain and Umbrellas\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://csacademy.com/contest/archive/task/squared-ends\"\u003eSquared Ends\u003c/a\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eAnd my implementations:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eRain and Umbrellas\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n\nusing namespace std;\ntypedef long long int ll;\n\nconst ll inf \u003d 3e9;\n\nstruct Line {\n    ll a,b;\n    Line(){\n        this-\u0026gt;a \u003d 0;\n        this-\u0026gt;b \u003d inf;\n    }\n    Line(ll a, ll b) {\n        this-\u0026gt;a \u003d a;\n        this-\u0026gt;b \u003d b;\n    }\n    \n    ll get(ll x) {\n        return a*x+b;\n    }\n};\n\nstruct tree {\n    Line lin;\n};\n\nvoid update(int l, int r, int b, int e, Line li, tree Tree[]) {\n    if(b \u0026gt;\u003d r || e \u0026lt;\u003d l)\n        return;\n    \n    if(l \u0026lt;\u003d b \u0026amp;\u0026amp; r \u0026gt;\u003d e) {\n        int m \u003d (b+e) / 2;\n        int x \u003d b+e;\n        \n        if (li.get(m) \u0026lt; Tree[x].lin.get(m))\n            swap(Tree[x].lin, li);\n        if (e-b \u003d\u003d 1)\n            return;\n        if (li.get(b) \u0026lt; Tree[x].lin.get(b))\n            update(l,r,b,(b+e)/2, li, Tree);\n        else\n            update(l, r, (b+e)/2, e, li, Tree);\n\n    } else {\n        update(l,r,b,(b+e)/2, li, Tree);\n        update(l,r,(b+e)/2, e,li, Tree);\n    }\n}\n\nll query(int l, int r, int x, tree Tree[]) {\n    int v \u003d l+r;\n    int m \u003d v/2;\n    \n    if(r-l\u003d\u003d1)\n        return Tree[v].lin.get(x);\n    \n    if(x \u0026lt; m) {\n        return min(Tree[v].lin.get(x), query(l,m,x,Tree));\n    }\n    return min(Tree[v].lin.get(x), query(m, r, x, Tree));\n    \n}\nint a,n,m,s\u003d1;\nconst int MAXA \u003d 2000+2;\n\nll dp[MAXA];\nll add[MAXA];\nll best[MAXA];\n\nll solve(tree Tree[]) {\n    dp[0] \u003d 0;\n    update(0, s/2, 0, s/2, Line(best[0], dp[0] - best[0] * 0), Tree);\n    \n    for(int i \u003d 1; i \u0026lt;\u003d a; ++i) {\n        dp[i] \u003d query(0, s/2, i, Tree);\n        if(add[i-1] \u003d\u003d 0) {\n            dp[i] \u003d min(dp[i], dp[i-1]);\n        }\n        \n        update(0, s/2, 0, s/2, Line(best[i], dp[i] - best[i] * i), Tree);\n    }\n    return dp[a];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    \n    \n    cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n    for(int i \u003d 0; i \u0026lt; n; ++i) {\n        int l,r;\n        cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r;\n        add[l]++;\n        add[r]--;\n    }\n    \n    for(int i \u003d 1; i \u0026lt;\u003d a; ++i) {\n        add[i] +\u003d add[i-1];\n    }\n    \n    for(int i \u003d 0; i \u0026lt;\u003d a; ++i) {\n        best[i] \u003d inf;\n        dp[i] \u003d inf;\n    }\n    \n    for(int i \u003d 0; i \u0026lt; m; ++i) {\n        ll x,p;\n        cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; p;\n        best[x] \u003d min(best[x],p);\n    }\n\n    \n    while (s \u0026lt;\u003d a*2) {\n        s*\u003d2;\n    }\n    tree Tree[s];\n    \n    ll ret \u003d solve(Tree);\n    if(ret \u003d\u003d inf) {\n        cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl;\n    } else {\n        cout \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; endl;\n    }\n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSquared Ends\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;stack\u0026gt;\n\nusing namespace std;\ntypedef long long int ll;\n\nconst ll inf \u003d 1000000000000;\n\nstruct Line {\n    ll a,b;\n    Line(){\n        this-\u0026gt;a \u003d 0;\n        this-\u0026gt;b \u003d inf;\n    }\n    Line(ll a, ll b) {\n        this-\u0026gt;a \u003d a;\n        this-\u0026gt;b \u003d b;\n    }\n    \n    ll get(ll x) {\n        return a*x+b;\n    }\n};\n\nstruct tree {\n    Line lin;\n};\n\nvoid update(int l, int r, int b, int e, Line li, tree Tree[]) {\n    if(b \u0026gt;\u003d r || e \u0026lt;\u003d l)\n        return;\n    \n    if(l \u0026lt;\u003d b \u0026amp;\u0026amp; r \u0026gt;\u003d e) {\n        int m \u003d (b+e) / 2;\n        int x \u003d b+e;\n        \n        if (li.get(m) \u0026lt; Tree[x].lin.get(m))\n            swap(Tree[x].lin, li);\n        if (e-b \u003d\u003d 1)\n            return;\n        if (li.get(b) \u0026lt; Tree[x].lin.get(b))\n            update(l,r,b,(b+e)/2, li, Tree);\n        else\n            update(l, r, (b+e)/2, e, li, Tree);\n        \n    } else {\n        update(l,r,b,(b+e)/2, li, Tree);\n        update(l,r,(b+e)/2, e,li, Tree);\n    }\n}\n\nll query(int l, int r, int x, tree Tree[]) {\n    int v \u003d l+r;\n    int m \u003d v/2;\n    \n    if(r-l\u003d\u003d1)\n        return Tree[v].lin.get(x);\n    \n    if(x \u0026lt; m) {\n        return min(Tree[v].lin.get(x), query(l,m,x,Tree));\n    }\n    return min(Tree[v].lin.get(x), query(m, r, x, Tree));\n    \n}\n\nint n,k;\nconst int MAXN \u003d 1e4;\nconst int MAXK \u003d 1e2;\nconst int MAXA \u003d 1e6;\nll dp[MAXN+1][MAXK+1];\nll tab[MAXN+1];\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k;\n    for(int i \u003d 1; i \u0026lt;\u003d n; ++i) {\n        cin \u0026gt;\u0026gt; tab[i];\n    }\n    \n    int s \u003d 1;\n    while (s \u0026lt;\u003d 2*MAXA) {\n        s*\u003d2;\n    }\n    \n    \n    \n    for(int i \u003d 0; i \u0026lt;\u003d n; ++i) {\n        for(int j \u003d 0; j \u0026lt;\u003d k; ++j) {\n            dp[i][j] \u003d inf;\n        }\n    }\n    dp[0][0] \u003d 0;\n    \n    for(int j \u003d 1; j \u0026lt;\u003d k; ++j) {   //ile podzialow\n        tree Tree[s];\n        \n        \n        for(int i \u003d 1; i \u0026lt;\u003d n; ++i) {\n            \n            update(0, s/2, 0, s/2, Line(-2*tab[i], dp[i-1][j-1] + tab[i]*tab[i]), Tree);\n            \n            dp[i][j] \u003d tab[i]*tab[i] + query(0, s/2, (int)tab[i], Tree);\n          //  cout \u0026lt;\u0026lt; dp[i][j] \u0026lt;\u0026lt; endl;\n        }\n        \n    }\n    \n    cout \u0026lt;\u0026lt; dp[n][k] \u0026lt;\u0026lt; endl;\n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eHope you all enjoyed classes. See you :)\u003c/p\u003e\u003c/div\u003e","tags":["#li chao tree","#segment tree","#geometry"]}}