{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1399998072,"rating":22,"authorHandle":"kien_coi_1997","modificationTimeSeconds":1399998072,"id":12285,"title":"\u003cp\u003eSegment tree with insertion and deletion operators.\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI have created this structure successfully some weeks ago, and I want to share it with you. This structure is \u003cstrong\u003efast, efficient\u003c/strong\u003e, and it is only the improvement from segment tree. I have used this code to submit to two problems, one is in SPOJ, one is in CF. For simpliest example, consider the problem QMAX3VN on SPOJ. (\u003ca href\u003d\"http://www.spoj.com/problems/QMAX3VN/\"\u003ehttp://www.spoj.com/problems/QMAX3VN/\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eThere are two operators: \u003cem\u003eInsert\u003c/em\u003e X before Y-th element, and \u003cem\u003efind Max\u003c/em\u003e between X-th element and Y-th element (inclusively).\u003c/p\u003e\u003cp\u003eFirstly, I use a variant of segment tree, allow us to insert element and access elements by indexes. Each node will have two childs: Left[Node] and Right[Node], by default, they are 0 (NULL). To be indexable, we must maintain array Size[].\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\nusing namespace std;\n\n#define long long long\n#define f1(i,n) for (int i\u003d1; i\u0026lt;\u003dn; i++)\n#define f0(i,n) for (int i\u003d0; i\u0026lt;n; i++)\n\n#define N 400005\n#define oo 0x3c3c3c3c\nint Max[N], Size[N], Height[N], Left[N], Right[N], Peak;\n\nvoid update(int id){\n   int ll\u003dLeft[id], rr\u003dRight[id];\n   Max[id]\u003dmax(Max[ll], Max[rr]);\n   Size[id]\u003dSize[ll]+Size[rr];\n   Height[id]\u003dmax(Height[ll], Height[rr])+1;\n}\n\nint create(int Value){\n   int id \u003d ++Peak;\n   Max[id]\u003dValue;\n   Size[id]\u003d1;\n   return id;\n}\n\nstruct node {\n   int ll, rr, id;\n   node (int L, int X) { ll\u003dL, id\u003dX; rr\u003dll+Size[id]-1; }\n   node left(){ return node(ll, Left[id]); }\n   node right(){ return node(ll+Size[Left[id]], Right[id]); }\n\n   void insert(int u, int Value) {\n      if (ll\u0026gt;u || u\u0026gt;rr) return ;\n      if (ll\u003d\u003drr) {\n         Left[id]\u003dcreate(Value);\n         Right[id]\u003dcreate(Max[id]);\n         update(id); return ;\n      }\n      left().insert(u, Value);\n      right().insert(u, Value);\n      update(id);\n   }\n\n   int max_range(int L, int R) {\n      if (L\u0026gt;rr || ll\u0026gt;R || L\u0026gt;R) return -oo;\n      if (L\u0026lt;\u003dll \u0026amp;\u0026amp; rr\u0026lt;\u003dR) return Max[id];\n      int Max1 \u003d left().max_range(L, R);\n      int Max2 \u003d right().max_range(L, R);\n      return max(Max1, Max2);\n   }\n};\n\nostream\u0026amp; operator \u0026lt;\u0026lt; (ostream\u0026amp; cout, node a){\n   if (a.ll\u003d\u003da.rr) return cout \u0026lt;\u0026lt; Max[a.id];\n   return cout \u0026lt;\u0026lt; \u0026quot;(\u0026quot; \u0026lt;\u0026lt; a.left() \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; a.right() \u0026lt;\u0026lt; \u0026quot;)\u0026quot;;\n   //return cout \u0026lt;\u0026lt; a.left() \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; a.right();\n}\n\nmain(){\n   create(-oo);\n   int m; scanf(\u0026quot;%d\u0026quot;, \u0026amp;m);\n   while (m--){\n      char c; int x, y;\n      scanf(\u0026quot; %c%d%d\u0026quot;, \u0026amp;c, \u0026amp;x, \u0026amp;y);\n\n      if (c\u003d\u003d\u0027A\u0027) node(1, 1).insert(y, x);\n      else printf(\u0026quot;%d\\n\u0026quot;, node(1, 1).max_range(x, y));\n//    cout \u0026lt;\u0026lt; node(1,1) \u0026lt;\u0026lt; endl;\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn average case, each operators will be O(logn), but in worst case, complexity is O(n), then we will get TLE on problem QMAX3VN. I will use tree rotations in \u003cstrong\u003eAVL tree\u003c/strong\u003e to balance tree. Magiccally, the addtional functions are \u003cstrong\u003every independent\u003c/strong\u003e with our old code. Here is some functions we need to add, it is not different from AVL tree:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eint link(int ll, int u, int rr){\n   Left[u]\u003dll, Right[u]\u003drr;\n   return update(u), u;\n}\n\nint right_rotate(int u){ \n   int ll \u003d Left[u]; \n   return link(Left[ll], ll, link(Right[ll], u, Right[u]));\n}\n\nint left_rotate(int u){\n   int rr \u003d Right[u];\n   return link(link(Left[u], u, Left[rr]), rr, Right[rr]);\n}\n\nint balance(int u){\n   if (abs(Height[Left[u]]-Height[Right[u]])\u0026lt;\u003d1) return u;\n   bool x\u003dHeight[Left[u]]\u0026gt;Height[Right[u]];\n   int v\u003d(x?Left[u]:Right[u]);\n   bool y\u003dHeight[Left[v]]\u0026gt;Height[Right[v]];\n   if (x \u0026amp;\u0026amp; y) u\u003dright_rotate(u);\n   if (!x \u0026amp;\u0026amp; !y) u\u003dleft_rotate(u);\n   if (x \u0026amp;\u0026amp; !y) { Left[u]\u003dv\u003dleft_rotate(v); u\u003dright_rotate(u); }\n   if (!x \u0026amp;\u0026amp; y) { Right[u]\u003dv\u003dright_rotate(v); u\u003dleft_rotate(u); }\n   return u;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd add only two statement into \u003cem\u003eInsert\u003c/em\u003e operator:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e   void insert(int u, int Value) {\n      if (ll\u0026gt;u || u\u0026gt;rr) return ;\n      if (ll\u003d\u003drr) {\n         Left[id]\u003dcreate(Value);\n         Right[id]\u003dcreate(Max[id]);\n         update(id); return ;\n      }\n      left().insert(u, Value);\n      right().insert(u, Value);\n      Left[id]\u003dbalance(Left[id]); // this one\n      Right[id]\u003dbalance(Right[id]); // and this\n      update(id);\n   }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is my accepted solution in problem QMAX3VN: \u003ca href\u003d\"https://sites.google.com/site/kc97ble/container/segmenttree-cpp/segmenttree-cpp-7-avl\"\u003ehttps://sites.google.com/site/kc97ble/container/segmenttree-cpp/segmenttree-cpp-7-avl\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI have used this structure to submit successully to a problem in CF. It is problem L in \u003ca href\u003d\"//codeforces.com/gym/100125\"\u003ehttp://codeforces.com/gym/100125\u003c/a\u003e. I implemented three operator: \u003cem\u003eInsert\u003c/em\u003e, \u003cem\u003eRemove\u003c/em\u003e, \u003cem\u003eget OR-Sum\u003c/em\u003e. This is my solution \u003ca href\u003d\"//codeforces.com/gym/100125/submission/6520803\"\u003ehttp://codeforces.com/gym/100125/submission/6520803\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eHope that it would be useful.\u003c/p\u003e\u003c/div\u003e","tags":["segment tree","avl"]}}