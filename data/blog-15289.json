{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1419062525,"rating":0,"authorHandle":"PrashantM","modificationTimeSeconds":1419565351,"id":15289,"title":"\u003cp\u003eSSN Coding Contest — 4 (Editorial)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eEditorial by Roopesh\u003c/p\u003e\u003cp\u003eA ----- The number of positions (\u003ca href\u003d\"//codeforces.com/problemset/problem/124/A\"\u003ehttp://codeforces.com/problemset/problem/124/A\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eThe constraints allow for a brute force solution . Assuming that numbering of the ordering start from 1 .. . .. n , iterate in that range and check how many positions satisfy the give condition ( i \u0026gt; a \u0026amp;\u0026amp; i\u0026lt;\u003d n-b ) . O(n) soln .\u003c/p\u003e\u003cp\u003eOr better , the given condition is min( n-a, b-1 ) . O(1) soln . \u003c/p\u003e\u003cp\u003eB ----- Playing with dice (\u003ca href\u003d\"//codeforces.com/problemset/problem/378/A\"\u003ehttp://codeforces.com/problemset/problem/378/A\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eThe constraints allow for a brute force solution . Iterate from 1 to 6 and check if the absolute distance of the current positions from a , b are less than , equal to or more than each other . Have 3 counters and increment the corresponding counter for the given condition . \u003c/p\u003e\u003cp\u003eC ----- Towers (\u003ca href\u003d\"//codeforces.com/problemset/problem/37/A\"\u003ehttp://codeforces.com/problemset/problem/37/A\u003c/a\u003e)\u003c/p\u003e\u003cp\u003e2 ways for solving this problem \u003c/p\u003e\u003cp\u003e1\u0026gt; Sorting — Sort the given array and check which of the tower heights have the highest count . Also count the number of distinct tower sizes . O(nlog(n)) due to sort . 2\u0026gt;Frequency distribution Since the tower heights cannot exceed 1000 , just use a array of size 1000 and increment the index of the input of the tower height , (freq[v[i]]++ ) and iterate through all the indices in the frequency distribution and find the maximum tower height and the number of distinct towers . O(n) and O(n) extra memory .\u003c/p\u003e\u003cp\u003eD ----- Subtractions (\u003ca href\u003d\"//codeforces.com/problemset/problem/267/A\"\u003ehttp://codeforces.com/problemset/problem/267/A\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eWhile the smaller of the 2 numbers is not zero , divide the larger by the smaller and add the result to a counter . The larger number now results to larger % smaller . Make sure to swap the larger and smaller after a iteration . Depending on the way of implementation , there may be small differences between the differences from the answer due to larger % smaller \u003d 0 or nonzero . Fix that and AC .\u003c/p\u003e\u003cp\u003eE ----- Hungry Sequences (\u003ca href\u003d\"//codeforces.com/problemset/problem/327/B\"\u003ehttp://codeforces.com/problemset/problem/327/B\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eMany ways to solve this problem .\u003c/p\u003e\u003cp\u003e1\u0026gt; You can observe that an array of prime numbers satisfy the given condition since one prime cannot divide another prime . So Display the first n prime numbers . Constraints allow a O(root n) solution . Iterate from 2 to root of P (P is the number in check for primality), and not from 2 to P , which will result in a TLE . (Sieve of eratosthenes was unnecessary for the given conditions . Sieve builds all prime numbers in range of 2 to N in O(Nlog(log (N)) ) . Constraints allowed a O(N*root N) solution .\u003c/p\u003e\u003cp\u003e2\u0026gt; Other way is to observe that large and consecutive numbers always form hungry sequences . ( If the first element in the sequence is sufficiently large , it cannot divide any other term in the sequence . ) . The maximum term in the sequence can be 10 ^ 7 . So , Display n consecutive numbers starting from 10 ^ 6 or so . n \u0026lt;\u003d 10 ^ 5 .\u003c/p\u003e\u003cp\u003e3\u0026gt; Sahitya\u0027s solution — Display all terms from n till 2*n — 1 (inclusive) . How it works ? The minimum of the sequence is n . The next multiple of n is 2*n . So display all numbers between n and 2*n . (We should only care about the multiples of smallest in the sequence because the sequence is strictly increasing ) .\u003c/p\u003e\u003c/div\u003e","tags":[]}}