{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1406990028,"rating":79,"authorHandle":"adamant","modificationTimeSeconds":1408207018,"id":13279,"title":"\u003cp\u003eC++ STL: Policy based data structures. Part 2\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi everyone!\u003c/p\u003e\u003cp\u003eSome of you may remember my \u003ca href\u003d\"/blog/entry/11080\"\u003eentry\u003c/a\u003e about policy based data structures. In addition to a review article on these structures, I also wanted to write about the possibility of using your own \u003ccode\u003eNode_Update\u003c/code\u003e class. Then I hadn\u0027t enough time for it, but now I can and I want to catch up and share with you some new knowledge. \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eSo, let\u0027s start. Node_update class should looks like this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate\u0026lt;class Node_CItr,\n\t class Node_Itr,\n\t class Cmp_Fn,\n\t class _Alloc\u0026gt;\nstruct my_node_update\n{\n    typedef my_type metadata_type;\n\n    void operator()(Node_Itr it, Node_CItr end_it)\n    {\n        ...\n    }\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLet\u0027s consider how this class works. Policy based tree, which is using update policy will additionally keep in node one variable of type \u003ccode\u003emy_type\u003c/code\u003e. When the tree is rebuilt, part of the metadata spoils, so for each node, which could be damaged applied the operator (). At the same time this operator begins to be applied firstly to the leaves, that is, we guarantee that if () is applied to the node, its metadata can be damaged, but the metadata of its children will be intact. The function has two arguments let\u0027s learn them.\u003c/p\u003e\u003cp\u003e\u003ccode\u003eNode_Itr it\u003c/code\u003e \u0026amp; mdash; iterator pointing to the node from which was called (). \u003ccode\u003eNode_CItr end_it\u003c/code\u003e \u0026amp; mdash; \u003ccode\u003econst\u003c/code\u003e-iterator to the node referenced by all NIL-tops. \u003ccode\u003eNode_iterator\u003c/code\u003e has the following methods:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003ccode\u003eget_l_child ()\u003c/code\u003e \u0026amp; mdash; returns \u003ccode\u003enode_iterator\u003c/code\u003e on left child or node_end, if it does not exist.\u003c/li\u003e   \u003cli\u003e\u003ccode\u003eget_r_child ()\u003c/code\u003e is the same for the right child.\u003c/li\u003e   \u003cli\u003e\u003ccode\u003eget_metadata ()\u003c/code\u003e \u0026amp; mdash; returns \u003ccode\u003econst reference\u003c/code\u003e to metadata stored in the node.\u003c/li\u003e   \u003cli\u003e\u003ccode\u003e*\u003c/code\u003e \u0026amp; mdash; dereference. Returns \u003ccode\u003ereference\u003c/code\u003e to a regular iterator of this item in set.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eFor clarity, I give an example of the function () to support the size of the subtree starting at the node:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    void operator()(Node_Itr it, Node_CItr end_it)\n    {\n        auto l\u003dit.get_l_child();\n        auto r\u003dit.get_r_child();\n        int left\u003d0,right\u003d0;\n        if(l!\u003dend_it) left \u003dl.get_metadata();\n        if(r!\u003dend_it) right\u003dr.get_metadata();\n        const_cast\u0026lt;int\u0026amp;\u0026gt;(it.get_metadata())\u003dleft+right+1;\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWell, we learned how to update invariants. Now let\u0027s learn how to use them.In order to do this we note that any public-methods of node_update automatically become public in tree. In addition, we have access to all of the virtual methods in the base class, if we declare them as virtual in node_update. In this regard, we add to our class the following lines:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    virtual Node_CItr\n    node_begin() const \u003d 0;\n \n    virtual Node_CItr\n    node_end() const \u003d 0;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis will give us the opportunity to gain direct access to the tree. In particular, node_begin() will point to the root of the tree, and node_end() to the place where all NIL-nodes are. Finally, we are ready to entirely manage the metadata at the nodes of our tree. For example, here is the function that finds order of \u003ccode\u003eint\u003c/code\u003e key in set:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    int order_of_key(int x)\n    {\n        int ans\u003d0;\n        auto it\u003dnode_begin();\n        while(it!\u003dnode_end())\n        {\n            auto l\u003dit.get_l_child();\n            auto r\u003dit.get_r_child();\n            if(Cmp_Fn()(x,**it))\n            {\n                it\u003dl;\n            }\n            else\n            {\n                ans++;\n                if(l!\u003dnode_end()) ans+\u003dl.get_metadata();\n                it\u003dr;\n            }\n        }\n        return ans;\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCurrently I have two examples of problems solved with node_update it is \u003ca href\u003d\"/problemset/problem/459/D\"\u003etask D\u003c/a\u003e (\u003ca href\u003d\"/contest/459/submission/7485682\" title\u003d\"Submission 7485682 by adamant\"\u003e7485682\u003c/a\u003e) from recent contest and solution of the problem \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1846\"\u003eGCD2010\u003c/a\u003e from the timus (\u003ca href\u003d\"http://ideone.com/xQ8qnX\"\u003esol\u003c/a\u003e). In the near future I will try to find and solve more problems with update policy and add to the article. If there is a problem that you think can be well solved by the structure \u0026amp; mdash; I will be glad if you lay them out now :)\u003c/p\u003e\u003c/div\u003e","tags":["policy based","advanced","pbds","data structures"]}}