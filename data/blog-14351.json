{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1413743696,"rating":65,"authorHandle":"Nerevar","modificationTimeSeconds":1413748480,"id":14351,"title":"\u003cp\u003eCodeforces Round #274: editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI am happy to present you author\u0027s ideas of solutions. Editorial of the first five problem is authored by — \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/HolkinPV\" title\u003d\"Expert HolkinPV\"\u003eHolkinPV\u003c/a\u003e and \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/gridnevvvit\" title\u003d\"Candidate Master gridnevvvit\"\u003egridnevvvit\u003c/a\u003e, editorial for the last two problems is written by me.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/479/problem/A\" title\u003d\"Codeforces Round 274 (Div. 2)\"\u003e479A - Expression\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eIn this task you have to consider several cases and choose the best one:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint ans \u003d a + b + c;\nans \u003d max(ans, (a + b) * c);\n\tans \u003d max(ans, a * (b + c));\n\tans \u003d max(ans, a * b * c);\n\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/479/problem/B\" title\u003d\"Codeforces Round 274 (Div. 2)\"\u003e479B - Towers\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe task is solved greedily. In each iteration, move the cube from the tallest tower to the shortest one. To do this, each time find the position of minimum and maximum in the array of heights (in linear time).\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/479/problem/C\" title\u003d\"Codeforces Round 274 (Div. 2)\"\u003e479C - Exams\u003c/a\u003e, \u003ca href\u003d\"/contest/480/problem/A\" title\u003d\"Codeforces Round 274 (Div. 1)\"\u003e480A - Exams\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe solution is again greedy. Sort the exams by increasing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, breaking ties by increasing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Let’s consider exams in this order and try to take the exams as early as possible. Take the first exams in this order on the early day (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e). Move to the second exam. If we can take it on the day \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e (i.e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ≤ \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e), do it. Otherwise, take the second exam on the day \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e. Continue the process, keeping the day of the latest exam. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003estd::sort(a, a + n);  // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best \u003d -1;\nfor(int i \u003d 0; i \u0026lt; n; i++) {\nif (best \u0026lt;\u003d a[i].second) {\n\t\tbest \u003d a[i].second;\n\t} else {\n\t \tbest \u003d a[i].first;\n\t}\n}\t\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/479/problem/D\" title\u003d\"Codeforces Round 274 (Div. 2)\"\u003e479D - Long Jumps\u003c/a\u003e, \u003ca href\u003d\"/contest/480/problem/B\" title\u003d\"Codeforces Round 274 (Div. 1)\"\u003e480B - Long Jumps\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eIt is easy to see that the answer is always 0, 1 or 2. If we can already measure both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, output 0. Then try to measure both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e by adding one more mark. If it was not successful, print two marks: one at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, other at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSo, how to check if the answer is 1? Consider all existing marks. Let some mark be at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e. Try to add the new mark in each of the following positions: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e + \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. If it become possible to measure both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, you have found the answer. It is easy to check this: if, for example, we are trying to add the mark at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e + \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, we just check if there is a mark at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e + \u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e + \u003ci\u003ex\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e (by a binary search, since the marks are sorted). Make sure that the adde marks are in \u003cspan class\u003d\"tex-span\"\u003e[0, \u003ci\u003eL\u003c/i\u003e]\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/479/problem/E\" title\u003d\"Codeforces Round 274 (Div. 2)\"\u003e479E - Riding in a Lift\u003c/a\u003e, \u003ca href\u003d\"/contest/480/problem/C\" title\u003d\"Codeforces Round 274 (Div. 1)\"\u003e480C - Riding in a Lift\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe task is solved by a dynamic programming. State is a pair \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is the number of trips made, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e is the current floor. Initial state is \u003cspan class\u003d\"tex-span\"\u003e(0, \u003ci\u003ea\u003c/i\u003e)\u003c/span\u003e, final states are \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is any floor (except \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eIt is easy to see the transitions: to calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e, let’s see what can be the previous floor. It turns out that all possible previous floors form a contiguous segment (with a hole at position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, because we can’t visit the same floor twice in a row). So, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e is almost equal to the sum of values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e - 1, \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e belongs to some segment \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e (the values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e can be easily derived from the conditions from the problem statement). Using pretty standard technique called “partial sums” we can compute \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e, so overall complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNK\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eJury solution: \u003ca href\u003d\"/contest/479/submission/8322623\" title\u003d\"Submission 8322623 by gridnevvvit\"\u003e8322623\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/480/problem/D\" title\u003d\"Codeforces Round 274 (Div. 1)\"\u003e480D - Parcels\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eLet’s make two observations.\u003c/p\u003e\u003cp\u003eFirst, consider the parcels as time segments \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ein\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eout\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e]\u003c/span\u003e. It is true that if at some moment of time both parcel \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and parcel \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e are on the platform, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is higher than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, then \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e4/d8/e4d8fdb6365076c7d2ac554abf1424ebf6b8b28b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eSecond, let’s imagine that there are some parcels on the platform. It turns out that it is enough to know just a single number to be able to decide whether we can put another parcel on top of them. Let’s denote this value as “residual strength”. For a parcel (or a platform itself) the residual strength is it’s strength minus the total weight of parcels on top of it. For a set of parcels, the residual strength is the minimum of individual residual strengths. So, we can put another parcel on top if it’s weight does not exceed the residual strength.\u003c/p\u003e\u003cp\u003eThese observations lead us to a dynamic programming solution. Let the top parcel at the given moment has number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, and the residual strength is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ers\u003c/i\u003e\u003c/span\u003e. Make this pair \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ers\u003c/i\u003e)\u003c/span\u003e the state of DP, because it is exactly the original problem, where the platform strength is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ers\u003c/i\u003e\u003c/span\u003e and there are only parcels \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/55/8b/558b1bd77992f9541dd9120a7dd10be00dd32dab.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. In \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ers\u003c/i\u003e)\u003c/span\u003e we will store the answer to this instance of the original problem.\u003c/p\u003e\u003cp\u003eWhich transitions are there? We can choose a set of parcels \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e(1), \u003ci\u003ei\u003c/i\u003e(2), ... \u003ci\u003ei\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e such that\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eout\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e(\u003ci\u003ej\u003c/i\u003e)\u003c/sub\u003e ≤ \u003ci\u003ein\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e(\u003ci\u003ej\u003c/i\u003e + 1)\u003c/sub\u003e\u003c/span\u003e, i.e. segments do not intersect (but can touch) and are sorted;\u003c/li\u003e   \u003cli\u003ethe weight of each of these parcels does not exceed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ers\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThis choice corresponds to the following sequence of actions: first put parcel \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e(1)\u003c/span\u003e on the top of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. This gets us to the state \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e(1), \u003ci\u003emin\u003c/i\u003e(\u003ci\u003ers\u003c/i\u003e - \u003ci\u003ew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e(1)\u003c/sub\u003e, \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e(1)\u003c/sub\u003e)\u003c/span\u003e, so we add up the answer for this state and the cost of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e(1)\u003c/span\u003e. Then we take away all parcels, including \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e(1)\u003c/span\u003e, and put the parcel \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e(2)\u003c/span\u003e on top of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, and so on.\u003c/p\u003e\u003cp\u003eAs the number of states in DP is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNS\u003c/i\u003e)\u003c/span\u003e, all transitions should take linear time. It can be achieved by making an inner helper DP. This give a solution in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003ci\u003eS\u003c/i\u003e)\u003c/span\u003e. Note that for simplicity the platform can be considered as a parcel too.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/480/problem/E\" title\u003d\"Codeforces Round 274 (Div. 1)\"\u003e480E - Parking Lot\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eLet’s denote the car arrivals as events.\u003c/p\u003e\u003cp\u003eConsider the following solution (it will help to understand the author’s idea): let’s consider all empty square in the table. There a too many of them, but imagine that we can afford to loop through all of them. If we fix a square, we can find out when it is no longer empty: find the first event that belongs to this square. Let this event has number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, and the size of the square is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Now we can update the answers for all events with numbers less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e with a value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe model solution use the idea of Divide and Conquer. Let’s make a recursive routine that takes a rectangular sub-table, bounded with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ≤ \u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ≤ \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e), and a list of events that happen inside this sub-table. The purpose of the routine is to consider how maximal empty squares in this sub-table change in time, and to update the answers for some of the events.\u003c/p\u003e\u003cp\u003eLet’s assume that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ≤ \u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - \u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e (the opposite case is symmetric). Take the middle row \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e \u003d (\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e) / 2\u003c/span\u003e. Virtually split all the squares inside the sub-table into those which lie above \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e, those which lie below \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e, and those which intersect \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e. For the first two parts, make two recursive calls, splitting the list of events as well. Now focus on the squares that intersect the row \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eUsing initial table, for each cell \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003er\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e)\u003c/span\u003e we can precompute the distance to the nearest taken cell in all four directions (or the distance to the border, if there is no such cell): \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eup\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edown\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eleft\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e)\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eright\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e)\u003c/span\u003e. Using this values, build two histograms for the row \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e: the first is an array of values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eup\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ≤ \u003ci\u003ec\u003c/i\u003e ≤ \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e; the second is an array of values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edown\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ≤ \u003ci\u003ec\u003c/i\u003e ≤ \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e. I say histograms here, because these arrays actually can be viewed as heights of empty columns, pointing from the row \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e upwards and downwards. Lets call the first histogram “upper”, the second one — “lower”. Now consider all events inside the sub-table in the order they happen. Each event changes a single value in a histogram. If after some event \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e the maximum empty square found in the histograms has size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, and the next event has number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, we can update answers for all events with numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e + 1, ..., \u003ci\u003ey\u003c/i\u003e - 1\u003c/span\u003e with the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eIt remains to learn to find a maximum square in two histograms. It can be done by a two-pointer approach. Set both pointers to the beginning. Move the second pointer until there is such square in histograms: there is a square with side length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e if (minimum on the interval in the upper histogram) + (minimum on the interval in the upper histogram) — 1 \u0026gt;\u003d k. When the second pointer can not be moved any more, update the answer and move the first pointer. To find the minimum in O(1), author’s solution creates a queue with minimum in O(1) support. That is, the maximum square can be found in linear time.\u003c/p\u003e\u003cp\u003eLet’s try to estimate the running time. Each call of the routine (omitting inner calls) costs \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elen\u003c/i\u003e·\u003ci\u003eq\u003c/i\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e is the shortest side of the sub-table, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e is the number of events in it. If we draw a recursion tree, we will see that each second call \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e decreases twice. The total cost of all operations in a single level of a recursion tree is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNK\u003c/i\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e is the total number of events. As long as we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e, overall complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNKlogN\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e","tags":["codeforces round #274","editorial"]}}