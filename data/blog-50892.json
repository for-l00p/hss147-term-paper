{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1489095891,"rating":0,"authorHandle":"SAeed","modificationTimeSeconds":1489095891,"id":50892,"title":"\u003cp\u003eBeginner Contest #1 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e \u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/212377/problem/Red\"\u003eRed. The New Year: Meeting Friends\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAdHoc\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eIf we sorted the positions in ascending order, we will have one person on the left, one on the right, and on on the middle. It\u0027s easy to see that the best answer is for the people on the left and right to go to the person who is in the middle. Thus, the answer simply is: \u003ccode\u003eMaximum\u003c/code\u003e â€” \u003ccode\u003eMinimum\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(1)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint main()\n{\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n\tint maxi \u003d -1, mini \u003d 1e9;\n\tfor (int i \u003d 0; i \u0026lt; 3; i++){\n\t\tint x; cin \u0026gt;\u0026gt; x;\n\t\tmaxi \u003d max(maxi, x);\n\t\tmini \u003d min(mini, x);\n\t}\n\tcout \u0026lt;\u0026lt; maxi - mini \u0026lt;\u0026lt; endl;\n\t\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/212377/problem/Green\"\u003eGreen. USB Flash Drives\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eGreedy\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSince we want to minimize the number of flash drives we use, we must use the flash drives starting from the flash with the biggest capacity. Sort the capacities in descending order, and then keep taking the flash drives from the biggest capacity to the lowest.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(N x Log(N))\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint a[111];\n\nint main()\n{\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n\tint n; cin \u0026gt;\u0026gt; n;\n\tint tot; cin \u0026gt;\u0026gt; tot;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i];\n\tsort(a, a + n, greater\u0026lt;int\u0026gt;());\n\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\ttot -\u003d a[i];\n\t\tif (tot \u0026lt;\u003d 0){\n\t\t\tcout \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/212377/problem/Yellow\"\u003eYellow. Pangram\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAdHoc\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe main problem is that the string contains lowercase and uppercase letters. To deal with this difficulty we can use the function \u003ccode\u003etolower\u003c/code\u003e to convert the character to lowercase always. Now what is left is really simple. Create an array with a length equal to \u003ccode\u003e26\u003c/code\u003e where the first place represents whether the string contains a letter \u003ccode\u003ea\u003c/code\u003e or not, the second place represents whether the string contains a letter \u003ccode\u003eb\u003c/code\u003e or not, and so on..\u003c/p\u003e\u003cp\u003eNow we can iterate over the string and mark the letters we find as true. After that, let\u0027s iterate over our array and check whether all elements are marked as true or not.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(N)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nbool vis[26] \u003d { 0 };\n\nint main()\n{\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n\tint n; cin \u0026gt;\u0026gt; n;\n\tstring s; cin \u0026gt;\u0026gt; s;\n\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\tvis[tolower(s[i]) - \u0027a\u0027] \u003d true;\n\t}\n\tbool ok \u003d true;\n\tfor (int i \u003d 0; i \u0026lt; 26; i++){\n\t\tif (!vis[i]) ok \u003d false;\n\t}\n\tif (ok) cout \u0026lt;\u0026lt; \u0026quot;YES\u0026quot; \u0026lt;\u0026lt; endl;\n\telse cout \u0026lt;\u0026lt; \u0026quot;NO\u0026quot; \u0026lt;\u0026lt; endl;\n\t\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/212377/problem/Blue\"\u003eBlue. Night at the Museum\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eGreedy\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eWe can solve each character from the string independently. Suppose the pointer is pointing to the character \u003ccode\u003enow\u003c/code\u003e, and the current character is \u003ccode\u003es[i]\u003c/code\u003e, We have two choises:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eEither going directly from \u003ccode\u003enow\u003c/code\u003e to \u003ccode\u003es[i]\u003c/code\u003e which can be calculated with the formula: \u003ccode\u003eabs(now - s[i])\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eOr going the opposite way which can be calculated with the formula: \u003ccode\u003e26 - abs(now - s[i])\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThe answer is simply the minimum between these two options. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(N)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint main()\n{\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n\tstring s; cin \u0026gt;\u0026gt; s;\n\tchar now \u003d \u0027a\u0027;\n\tint ans \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; s.size(); i++){\n\t\tans +\u003d min(abs(s[i] - now), 26 - abs(s[i] - now));\n\t\tnow \u003d s[i];\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\t\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/212377/problem/Black\"\u003eBlack. Lecture\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eSTL\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eFor each word the professor has said, find how it\u0027s written in the second language, and then print the one the smallest size (if they have an equal size print the word in the first language). To do this efficiently use a map, where the key is the word in the first language, and the value is the word in the second language.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(N x Log(N))\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nmap\u0026lt;string, string\u0026gt; word;\n\nint main()\n{\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n\tint n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tfor (int i \u003d 0; i \u0026lt; m; i++){\n\t\tstring fir, sec; cin \u0026gt;\u0026gt; fir \u0026gt;\u0026gt; sec;\n\t\tword[fir] \u003d sec;\n\t}\n\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\tif (i) cout \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n\t\tstring s; cin \u0026gt;\u0026gt; s;\n\t\tif (s.size() \u0026lt;\u003d word[s].size()) cout \u0026lt;\u0026lt; s;\n\t\telse cout \u0026lt;\u0026lt; word[s];\n\t}\n\tcout \u0026lt;\u0026lt; endl;\n\t\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/212377/problem/Silver\"\u003eSilver. Domino\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAdHoc + Math\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eFirst, let\u0027s remember something about numbers:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003ethe sum of an \u003ccode\u003eeven\u003c/code\u003e number with \u003ccode\u003eeven\u003c/code\u003e number is equal to an \u003ccode\u003eeven\u003c/code\u003e number.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003ethe sum of an \u003ccode\u003eodd\u003c/code\u003e number with \u003ccode\u003eodd\u003c/code\u003e number is equal to an \u003ccode\u003eeven\u003c/code\u003e number.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003ethe sum of an \u003ccode\u003eodd\u003c/code\u003e number with \u003ccode\u003eeven\u003c/code\u003e number is equal to an \u003ccode\u003eodd\u003c/code\u003e number.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eLet\u0027s calculate the sum of the numbers on the upper half (let\u0027s denote it as \u003ccode\u003esum1\u003c/code\u003e), and on the lower half (let\u0027s denote it as \u003ccode\u003esum2\u003c/code\u003e). Now, consider three cases:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eIf \u003ccode\u003esum1\u003c/code\u003e and \u003ccode\u003esum2\u003c/code\u003e are both even, then we don\u0027t need to do any moves and the answer is simply \u003ccode\u003e0\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf one of them is even and the other one is odd, that means that the even sum has an even number of odd numbers, while the odd number has an odd number of odd numbers. We can see that swapping a domino with an even number on one face and an odd number on the other one won\u0027t solve the problem, and obviously the same thing goes for swapping a domino with 2 evens or 2 odds. Thus, the answer here is \u003ccode\u003e-1\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf both \u003ccode\u003esum1\u003c/code\u003e and \u003ccode\u003esum2\u003c/code\u003e are odd, we must find a domino that has an odd number on one face and an even number on the other face, swapping this domino would make both sides an even number. So if such a domino exists the answer is \u003ccode\u003e1\u003c/code\u003e. Otherwise the answer is \u003ccode\u003e-1\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(N)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint main()\n{\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n\tint n; cin \u0026gt;\u0026gt; n;\n\tbool can \u003d false;\n\tint sum1 \u003d 0, sum2 \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\tint a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\t\tsum1 +\u003d a;\n\t\tsum2 +\u003d b;\n\t\tif (a % 2 !\u003d b % 2) can \u003d true;\n\t}\n\tif (sum1 % 2 \u003d\u003d 0 \u0026amp;\u0026amp; sum2 % 2 \u003d\u003d 0) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl;\n\telse if (sum1 % 2 \u003d\u003d sum2 % 2 \u0026amp;\u0026amp; can) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl;\n\telse cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl;\n\t\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}