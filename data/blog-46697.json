{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1471809502,"rating":0,"authorHandle":"1am","modificationTimeSeconds":1471810040,"id":46697,"title":"\u003cp\u003eDay 4 (8/20)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eYesterday, we first reexplained question Number of Ways from last week. The code is in the previous blog post. After that we went into some new topics\u003c/p\u003e\u003ch1\u003eFrequency Array\u003c/h1\u003e\u003cp\u003eThis is a very broad topic. Frequency array is used to keep track of the number of letters, or numbers, or literally anything you want to keep a count of. We solved a simple problem of finding the frequency of each letter in a lowercase string. Here is the code: \u003ca href\u003d\"http://ideone.com/hvlGsX\"\u003ehttp://ideone.com/hvlGsX\u003c/a\u003e\u003c/p\u003e\u003cp\u003eYou can use this idea to solve problem F from Day 4. We also solved an invented on the spot problem of finding the frequency of a certain letter in between i and j. We said that the brute force n^2 solution wont work unless n \u0026lt;1000. So we created a 2D cumulative sum array cs[26][N]. Try to implement it for fun and write your own test cases for it.\u003c/p\u003e\u003ch1\u003eSieve of Eratosthenes\u003c/h1\u003e\u003cp\u003eThen we learned how to find if a number is prime or not (رقم اولي). The brute force solution is using a for loop from 2 to n-1; if it divides by any number it is not prime. Sieve of Eratosthenes it has a complexity of O(nlog(logn)). So you can probably get away with maximum n \u003d 10^6.\u003c/p\u003e\u003cp\u003eWe said that the algorithm works like this:\u003c/p\u003e\u003cp\u003eStart from 2. If a number is not visited yet, run through all multiples of it and mark them visited. But there was two important points. \u003c/p\u003e\u003cp\u003eThe first one was that for example when i reach the number seven, since it is prime it will not be visited. When i start to go through its multiples, i will notice that 2*7 is already visited, as is 3 *7 and 4 *7 all the way to 6*7. That is because i would have ran through them when i was going through multiple of two and three up until 6. So when i reach a number x not visited, the first number i should start marking as visited (not prime) is x*x (x^2). Therefore if my prime number is 7, i will jump to 49. \u003c/p\u003e\u003cp\u003eThat also leads us to our second point. If the range i want is from 1 to 50, then there is no need to check multiples of anything higher than 7 because if i were to check multiples of 8, the first number checked would be 8 *8 which is outside the range of 50. Therefore our outer for loop should be till square root of n. \u003c/p\u003e\u003cp\u003eHere is the code : \u003ca href\u003d\"http://ideone.com/VsSWkR\"\u003ehttp://ideone.com/VsSWkR\u003c/a\u003e\u003c/p\u003e\u003cp\u003eHere is a cool gif: \u003ca href\u003d\"https://en.wikipedia.org/wiki/File:Sieve_of_Eratosthenes_animation.gif#/media/File:Sieve_of_Eratosthenes_animation.gif\"\u003ehttps://en.wikipedia.org/wiki/File:Sieve_of_Eratosthenes_animation.gif#/media/File:Sieve_of_Eratosthenes_animation.gif\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eBinary Search\u003c/h1\u003e\u003cp\u003eBinary search is the process of eliminating half of a range because that range has numbers outside of our interest. \u003c/p\u003e\u003cp\u003eHere is little game you can play. \u003ca href\u003d\"https://www.cs.usfca.edu/~galles/visualization/Search.html\"\u003ehttps://www.cs.usfca.edu/~galles/visualization/Search.html\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe complexity of finding a number in a range is log (n). This is very fast, in comparison with the naive O(n) solution. Here is an explained code: \u003ca href\u003d\"http://ideone.com/lVV1KE\"\u003ehttp://ideone.com/lVV1KE\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe also explained binary search the answer, where instead of searching for the number, you search for the answer to the problem. We solved problem G from day 4, try to solve it. Remember you will need a check function to check if the middle is a possible answer. And also sort the numbers from largest to smallest by either multiplying by negative one or sorting then reversing. Don\u0027t forget to use long long instead of int for sum of numbers above mid!\u003c/p\u003e\u003cp\u003eGood luck :)\u003c/p\u003e\u003c/div\u003e","tags":[]}}