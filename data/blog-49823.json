{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1484646779,"rating":-1,"authorHandle":"t3rminated","modificationTimeSeconds":1484646779,"id":49823,"title":"\u003cp\u003erolling hash technique in \u003ca href\u003d\"http://www.spoj.com/problems/BEADS/\"\u003ehttp://www.spoj.com/problems/BEADS/\u003c/a\u003e\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI am doing this \u003ca href\u003d\"http://www.spoj.com/problems/BEADS/\"\u003equestion\u003c/a\u003e I implemented it using rolling hash like for each position calculating the hash considering the string begins at that position and ends at one position back. But the problem coming is when i take mod with 1000000007 the hash value changes so i can\u0027t compare now between hashes as the value itself is changed so does anyone has a different idea?\u003c/p\u003e\u003cp\u003ehere\u0027s my code â€” \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\nusing namespace std;\n#define ll long long\n#define MOD 1000000007\nll pw[10010];\n\nll pwr(ll base, ll p, ll mod){\nll ans \u003d 1;while(p){if(p\u0026amp;1)ans\u003d(ans*base)%mod;base\u003d(base*base)%mod;p/\u003d2;}return ans;\n}\nll modularInverse(ll a,ll m) { return pwr(a,m-2,m); }\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    int t;\n    cin \u0026gt;\u0026gt; t;\n    \n    pw[0] \u003d 1;\n    for(int i\u003d1; i\u0026lt;\u003d10010; i++)\n        pw[i] \u003d (pw[i-1]*31)%MOD;\n    \n    while(t--)\n    {\n        string s;\n        cin \u0026gt;\u0026gt; s;\n        ll cumu[10010];\n        memset(cumu, 0, sizeof cumu);\n        for(int j \u003d 0; j \u0026lt; s.length(); j++)\n        {\n            if(j !\u003d 0)\n                cumu[j] \u003d (cumu[j-1] + (s[j]-\u0027a\u0027+1)*pw[j])%MOD;\n            else\n                cumu[j] \u003d s[j]-\u0027a\u0027+1;\n        }\n        \n        pair\u0026lt;int, int\u0026gt; a[s.length() + 1];\n        \n        for(int j \u003d 0; j \u0026lt; s.length(); j++)\n        {\n          ll sum \u003d cumu[s.length()-1] - ((j-1)\u0026gt;0?cumu[j-1]:0);\n        //   cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt;\u0026quot; \u0026quot;;\n          if(j-1 \u0026lt; 0){a[j] \u003d make_pair(sum, j);continue;}\n             sum \u003d (sum*modularInverse(pw[j],MOD))%MOD; \n            //  cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt;\u0026quot; \u0026quot;;\n          sum \u003d (sum + cumu[j-1]*pw[s.length()-j])%MOD;\n          a[j] \u003d make_pair(sum, j);\n        }\n        sort(a, a + s.length());\n        // for(int i \u003d 0; i \u0026lt; s.length(); i++)\n            cout \u0026lt;\u0026lt; a[0].second + 1 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["rolling hashes"]}}