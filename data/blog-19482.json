{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1438101837,"rating":0,"authorHandle":"DedMaxim","modificationTimeSeconds":1440682324,"id":19482,"title":"\u003cp\u003eРазбор задач. Тренировочный контест 1\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e[problem:203826A]\u003c/p\u003e\u003cp\u003eЗадача А достаточно известна в программировании. Она хорошо иллюстрирует применимость двух методов решения задач. \u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cem\u003eМетод двух указателей\u003c/em\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eСуть этого метода состоит в следующем. Пусть у нас зафиксирован какой-то отрезок \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e . На этом отрезке у нас посчитана сумма. Теперь мы считываем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e + 1\u003c/span\u003e -ый элемент. Как может измениться сумма на отрезке теперь? Если сумма стала отрицательной, то нам невыгодно брать такой элемент. Но взять-то нужно. Тогда сдвинем границу \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e. Куда? В \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e + 1\u003c/span\u003e. Потому что, нам нет смысла сдвигать его куда-то до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e + 1\u003c/span\u003e. \u003cem\u003e(Вы можете убедиться в этом сами)\u003c/em\u003e. Тогда мы переходим к следующему состоянию — \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003er\u003c/i\u003e + 1, \u003ci\u003er\u003c/i\u003e + 1]\u003c/span\u003e. Если же сумма положительна, то мы просто переходим к состоянию \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e + 1]\u003c/span\u003e. Изначально мы стоим в состоянии \u003cspan class\u003d\"tex-span\"\u003e[0, 0]\u003c/span\u003e. Возникает вопрос, как восстановить ответ. Это просто. Нужно, когда мы находимся в каком-то состоянии обновлять ответ\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e   ans \u003d max(ans, sum);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗдесь переменная \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5d/e5/5de5a00404723a8c40b4c1790314f045faa4b4e8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003c/p\u003e\u003cp\u003eИзначально непонятно за сколько работает этот метод. Однако, если мы посмотрим, что мы делаем на каждом шаге, когда добавляем новое число, а мы просто изменяем границу, то становится понятно что мы делаем порядка \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e действий. То есть временная сложность этого алгоритма — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cem\u003e\u0026quot;Разделяй и Властвуй\u0026quot;\u003c/em\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eЭтот метод очень эффективен, но его часто сложно бывает придумать. Поэтому рекомендуется прорешать некоторое количество задач по этому методу, чтобы понять его философию. \u003cstrong\u003eКраеугольным камнем\u003c/strong\u003e этой стратегии является рекурсия. пусть нам нужно что-то посчитать на массиве. Тогда мы его разделяем на две равные части (иногда на больше, но мы пока с этим не столкнёмся), и запускаемся рекурсивно от этих частей. А потом просто как-то комбинируем наши результаты. Мы уже сталкивались с этим в сортировке слиянием ( \u003cem\u003eMerge Sort\u003c/em\u003e , её код на Паскале есть в группе). Там мы сортировали левую и правую половинку, а потом сливали всё в один массив. Этим методом также можно решить и нашу задачу. Давайте разобьём наш массив на две части. Левую часть назовём левым сыном, а правую — правым сыном. Посмотрим, где находится наш ответ. \u003c/p\u003e\u003cp\u003eподойдём к этому с рекурсивной точки зрения: пусть для текущего массива все значения в левом сыне и в правом сыне уже подсчитаны, посчитаем их теперь для самого массива. Заметим, что ответ в самом массиве равен:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eлибо ответу в левом сыне, что означает, что лучший подотрезок в текущем массиве целиком помещается в отрезок левого сына,\u003c/li\u003e   \u003cli\u003eлибо ответу в правом сыне, что означает, что лучший подотрезок в текущем массиве целиком помещается в отрезок правого сына,\u003c/li\u003e   \u003cli\u003eлибо сумме максимального суффикса в левом сыне и максимального префикса в правом сыне, что означает, что лучший подотрезок лежит своим началом в левом сыне, а концом — в правом.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eЗначит, ответ в текущем массиве равен максимуму из этих трёх величин. Пересчитывать же максимальную сумму на префиксах и суффиксах ещё проще. Приведём реализацию функции \u003cem\u003ecombine\u003c/em\u003e , которой будут передаваться две структуры \u003cem\u003eType\u003c/em\u003e , содержащие в себе данные о левом и правом сыновьях, и которая возвращает данные в текущем массиве.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eType combine (Type l, Type r) {\n\tType res;\n\tres.sum \u003d l.sum + r.sum;\n\tres.pref \u003d max (l.pref, l.sum + r.pref);\n\tres.suff \u003d max (r.suff, r.sum + l.suff);\n\tres.ans \u003d max (max (l.ans, r.ans), l.suff + r.pref);\n\treturn res;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТогда полный код будет выглядеть так :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eType f(int l, int r) { \\\\левая и правая граница текущего массива \n      if (l \u003d\u003d r) return Type(a[tl]);\n      int m \u003d (l + r) / 2;\n      Type L \u003d f(l, m);\n      Type R \u003d f(m + 1, r);\n      return combine(L, R);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e[problem:203826B]\u003c/p\u003e\u003cp\u003eРешение этой задачи — динамическое программирование. Изначально нужно посчитать \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epsum\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epsum\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — сумма на префиксе массива \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e длиной \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eОбозначим \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — максимальная прибыль которую может получить Юра, если мы уже выбрали \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e последовательностей и последний элемент в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-ой последовательности имеет индекс \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eОчевидно, что если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e·\u003ci\u003em\u003c/i\u003e  \u0026gt;  \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, то \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e  \u003d  0\u003c/span\u003e. Иначе \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e  \u003d  \u003ci\u003emax\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e - 1\u003c/sub\u003e,  \u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1, \u003ci\u003ej\u003c/i\u003e - \u003ci\u003em\u003c/i\u003e\u003c/sub\u003e  +  \u003ci\u003epsum\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e  -  \u003ci\u003epsum\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e - \u003ci\u003em\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e Ответом будет \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eЕщё нужно было не забыть использовать \u003cstrong\u003elong long\u003c/strong\u003e при вычислениях.\u003c/p\u003e\u003cp\u003eАсимптотика: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e·\u003ci\u003eK\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e[problem:203826C]\u003c/p\u003e\u003cp\u003eНужно заметить тот факт, что если сумма всех элементов массива равна \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e, то сумма чисел в каждой части, на которые мы разобьем массив, будет равна \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a7/87/a787247f31eb07c9458b9c83a2e599a3d9837bf2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eТаким образом, если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e не делиться на \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e — то ответ \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eИначе, давайте переберем конец первого блока \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(1  ≤  \u003ci\u003ei\u003c/i\u003e  ≤  \u003ci\u003en\u003c/i\u003e - 2)\u003c/span\u003e и если сумма чисел от первого до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-го равна \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a7/87/a787247f31eb07c9458b9c83a2e599a3d9837bf2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, то значит нам к ответу надо прибавить количество таких \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e + 1  \u0026lt;  \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e, что сумма чисел от \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e-го до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e-го тоже равна \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a7/87/a787247f31eb07c9458b9c83a2e599a3d9837bf2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eСоздадим массив \u003ccode\u003ecnt[]\u003c/code\u003e, где в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-й позиции будем хранить \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, если сумма элементов массива от \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-го до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e-го равна \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a7/87/a787247f31eb07c9458b9c83a2e599a3d9837bf2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, и \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e в других случаях. Теперь, чтобы посчитать ответ, нам нужно уметь быстро считать сумму \u003ccode\u003ecnt[j] + cnt[j+1] + ... + cnt[n]\u003c/code\u003e. Делать это можно разными структурами данных, но наиболее легким вариантом есть такой: построим массив частичных сумм \u003ccode\u003esums[]\u003c/code\u003e на массиве \u003ccode\u003ecnt[]\u003c/code\u003e, где в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e-м элементе будет храниться сумма \u003ccode\u003ecnt[j] + cnt[j+1] + ... + cnt[n]\u003c/code\u003e. Считать его очень просто: \u003ccode\u003esums[n] \u003d cnt[n]\u003c/code\u003e, \u003ccode\u003esums[i] \u003d sums[i+1] + cnt[i] (i \u0026lt; n)\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eТаким образом получаем очень простое решение: для каждого \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e если сумма чисел от первого до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-го равна \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a7/87/a787247f31eb07c9458b9c83a2e599a3d9837bf2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, прибавить к ответу \u003ccode\u003esums[i+2]\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eАсимптотика: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e[problem:203826D]\u003c/p\u003e\u003cp\u003eЗаметим, что после применения операций обмена возможна любая перестановка чисел. Несложно понять, что ответ будет положительным, если можно разместить одно число, что бы оно не стояло в соседних клетках. Таким образом, если некоторое число встретилось \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eС\u003c/i\u003e\u003c/span\u003e раз, то должно выполнятся условие \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/dd/e5/dde556270df7490922a3e8b0f79476cd97ffa5a3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003c/div\u003e","tags":[]}}