{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1417639363,"rating":3,"authorHandle":"Betlista","modificationTimeSeconds":1417683677,"id":14991,"title":"\u003cp\u003eFew notes for a binary search\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI did the same mistake in a second contest (at least), so I have to write this down...\u003c/p\u003e\u003cp\u003eWhen I have sorted array, I\u0027m using binary search to find number of elements lower than some boundary value \u003ccode\u003ed\u003c/code\u003e. Problem is, that in Java, call \u003ccode\u003eArrays.binarySearch(array, d)\u003c/code\u003e returns so called insertion point and it is valid to return for array let say \u003ccode\u003e10, 20, 20, 20, 30\u003c/code\u003e value 2 (0-based index, tried with Java 7) as the insertion point for searched value 20, but it doesn\u0027t mean that there are 2 elements lower than 20 in array... Solution that I used to finally fix my bug in both contests was to force the value d not to be in array, which I achieved by multiplying input by 2 (in \u003ca href\u003d\"//codeforces.com/contest/493/problem/C\"\u003eproblem C, contest 281\u003c/a\u003e there are weak test cases), so there are no odd numbers in input...\u003c/p\u003e\u003cp\u003eIn a future I\u0027ll rather implement my own binary search — it is easy and I do not need to handle negative return values...\u003c/p\u003e\u003cp\u003eOld code with Java binary search (works only with trick mentioned above):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tint idx \u003d Arrays.binarySearch(a, d);\n\tif (idx \u0026lt; 0) {\n\t\tidx \u003d -idx - 1 - 1;\n\t}\n\tlong lower \u003d idx + 1;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eMy implementation of binary search for lower values in sorted array:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tstatic long numberOfLowers(long d, long[] a) {\n\t\tif ( a[0] \u0026gt;\u003d d ) return 0;\n\t\tif ( a[a.length - 1] \u0026lt; d ) return a.length;\n\t\tint ok \u003d 1; // at least a[0] is lower\n\t\tint nok \u003d a.length; // there are not so many items left\n\t\twhile ( ok + 1 \u0026lt; nok ) {\n\t\t\tint mid \u003d (ok + nok) \u0026gt;\u0026gt; 1;\n\t\t\tif ( a[mid-1] \u0026lt; d ) {\n\t\t\t\tok \u003d mid;\n\t\t\t} else {\n\t\t\t\tnok \u003d mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eMy solution with Java binary search — \u003ca href\u003d\"//codeforces.com/contest/493/submission/8973508\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThe same, but with modified binary search — \u003ca href\u003d\"//codeforces.com/contest/493/submission/8974015\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e","tags":["binary search","java"]}}