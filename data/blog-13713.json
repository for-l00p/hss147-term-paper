{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1410088637,"rating":9,"authorHandle":"Binary_ToothLess","modificationTimeSeconds":1410098841,"id":13713,"title":"\u003cp\u003eKadane\u0027s Algorithm — (Dynamic Programming) — For new Solvers!\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eDon\u0027t be afraid this is not very difficult....\u003c/p\u003e\u003cp\u003eFor new programmer, this is very essential... We know a little bit for that we don\u0027t answer many problem as like \u0026quot;largest sum contiguous sub array\u0026quot; that\u0027s really very easy to determine largest sum if we know the following algorithm.....\u003c/p\u003e\u003cp\u003eInitialize:  max_so_far \u003d 0\u003c/p\u003e \u003cpre\u003emax_ending_here \u003d 0\u003c/pre\u003e\u003cp\u003eLoop for each element of the array\u003c/p\u003e\u003cp\u003e(a) max_ending_here \u003d max_ending_here + a[i]\u003c/p\u003e\u003cp\u003e(b) if(max_ending_here \u0026lt; 0)  max_ending_here \u003d 0\u003c/p\u003e\u003cp\u003e(c) if(max_so_far \u0026lt; max_ending_here)  max_so_far \u003d max_ending_here\u003c/p\u003e\u003cp\u003ereturn max_so_far\u003c/p\u003e\u003cp\u003eExplanation: Simple idea of the Kadane\u0027s algorithm is to look for all positive contiguous segments of the array (max_ending_here is used for this). And keep track of maximum sum contiguous segment among all positive segments (max_so_far is used for this). Each time we get a positive sum compare it with max_so_far and update max_so_far if it is greater than max_so_far\u003c/p\u003e\u003cp\u003eLets take the example:\u003c/p\u003e\u003cp\u003e{-2, -3, 4, -1, -2, 1, 5, -3}\u003c/p\u003e\u003cp\u003emax_so_far \u003d max_ending_here \u003d 0\u003c/p\u003e\u003cp\u003efor i\u003d0, a[0] \u003d -2 max_ending_here \u003d max_ending_here + (-2) Set max_ending_here \u003d 0 because max_ending_here \u0026lt; 0\u003c/p\u003e\u003cp\u003efor i\u003d1, a[1] \u003d -3 max_ending_here \u003d max_ending_here + (-3) Set max_ending_here \u003d 0 because max_ending_here \u0026lt; 0\u003c/p\u003e\u003cp\u003efor i\u003d2, a[2] \u003d 4 max_ending_here \u003d max_ending_here + (4) max_ending_here \u003d 4 max_so_far is updated to 4 because max_ending_here greater than max_so_far which was 0 till now\u003c/p\u003e\u003cp\u003efor i\u003d3, a[3] \u003d -1 max_ending_here \u003d max_ending_here + (-1) max_ending_here \u003d 3\u003c/p\u003e\u003cp\u003efor i\u003d4, a[4] \u003d -2 max_ending_here \u003d max_ending_here + (-2) max_ending_here \u003d 1\u003c/p\u003e\u003cp\u003efor i\u003d5, a[5] \u003d 1 max_ending_here \u003d max_ending_here + (1) max_ending_here \u003d 2\u003c/p\u003e\u003cp\u003efor i\u003d6, a[6] \u003d 5 max_ending_here \u003d max_ending_here + (5) max_ending_here \u003d 7 max_so_far is updated to 7 because max_ending_here is greater than max_so_far\u003c/p\u003e\u003cp\u003efor i\u003d7, a[7] \u003d -3 max_ending_here \u003d max_ending_here + (-3) max_ending_here \u003d 4\u003c/p\u003e\u003cp\u003eCode :\u003c/p\u003e\u003cp\u003efor(int i \u003d 0; i \u0026lt; N; i++){\u003c/p\u003e \u003cpre\u003emax_ending_here +\u003d Number[i];\n\n        if(max_ending_here \u0026gt; max_so_far)max_so_far \u003d max_ending_here;\n\n        if(max_ending_here \u0026lt; 0)max_ending_here \u003d 0;\n\n    }\u003c/pre\u003e\u003cp\u003eSo the complexity for this code is O(n)...\u003c/p\u003e\u003cp\u003eHappy coding...:)\u003c/p\u003e\u003c/div\u003e","tags":[]}}