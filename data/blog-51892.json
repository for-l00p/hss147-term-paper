{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1494248654,"rating":5,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1494339667,"id":51892,"title":"\u003cp\u003eSolutions to Codeforces Beta Round #41, A, B, C, D(Hamilton Cycle)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA. Guilty â€” to the kitchen!\u003c/p\u003e\u003cp\u003eSuppose that the maximum volume is x, and then we can derive several inequalities that x should satisfy. \u003c/p\u003e\u003cp\u003e1) For each index i, x*a[i]/(a[1]+a[2]+a[3]+...a[N])\u0026lt;\u003db[i], where \u0026quot;/\u0026quot; means float division;\u003c/p\u003e\u003cp\u003e2) x\u0026lt;\u003dV\u003c/p\u003e\u003cp\u003eTherefore, x\u003dmin(V, min(b[i]*(a[1]+a[2]+a[3]+...a[N])/a[i]) )\u003dmin(V, (a[1]+a[2]+a[3]+...a[N])*min(b[i]/a[i])). This implies that we can first find out the minimum value of b[i]/a[i], and then the answer is straightforward.\u003c/p\u003e\u003cp\u003eB. Game of chess unfinished\u003c/p\u003e\u003cp\u003eFor each rook, we can calculate the positions that it can take. Note that the white king (or another rook) might serve as an obstacle and thus \u0026quot;protect\u0026quot; some positions from being taken by the current rook, even though these positions lie in the same row or column as the rook. For instance, consider a rook with \u0026quot;b2\u0026quot; and a white king with \u0026quot;b4\u0026quot;, in which case all positions with \u0026quot;b5,b6,b7,b8\u0026quot; cannot be taken by this rook (however they may be taken by another rook or the white king). Similarly, we can obtain the positions that the white king can take as well. \u003c/p\u003e\u003cp\u003eNow, we can first check whether the white has checkmated the black. Then, we move the black king to the eight adjacent positions (if these positions are reasonable), and check whether it will be taken by the white or not. As long as there exists one sinlge position at which the black king can avoid being taken by the white, the answer is \u0026quot;OTHER\u0026quot;. Note that one of the white rooks might be taken by the black king, as the problem says.\u003c/p\u003e\u003cp\u003eC. Safe cracking\u003c/p\u003e\u003cp\u003eWell, this is a somewhat weird problem...\u003c/p\u003e\u003cp\u003eA feasible solution is shown as follows:\u003c/p\u003e\u003cp\u003e1) if all the four integers are reduced to 1, stops; otherwise go to step 2);\u003c/p\u003e\u003cp\u003e2) find out the maximum integer a[max_n] and denote its left and right integer as a[L] and a[R], respectively. Then, select one of the following branches to implement:\u003c/p\u003e\u003cp\u003eA) a[max_n]%2\u003d0: if at least one of a[L] and a[R] is an even integer, divide it and a[max_n] by 2 (if they are both even integers, we can select the larger one); if both of them are odd integers, increase the larger one and a[max_n] by 1; after this, go to step 1);\u003c/p\u003e\u003cp\u003eB) a[max_n]%2\u003d1: if at least one of a[L] and a[R] is an odd integer, increase it and a[max_n] by 1 (if they are both odd integers, we can select the larger one); if both of them are even integers, increase the larger one and a[max_n] by 1; after this, go to step 1);\u003c/p\u003e\u003cp\u003eIn genreal, for a given integer N, by dividing it by 2, it takes us log(N) times to reduce it to 1. However, sometimes the intermediate result may turn out to be an odd integer and it might take 3 more times to go on with division. For instance, a[L] is even; a[max_n] is odd; a[R] is even. Therefore, it takes 4*(3*log(N)) operations, which is about \u003c/p\u003e\u003cp\u003e4*(3*log(10^9))\u0026lt;\u003d12*log((2^4)^9)\u003d12*36\u003d432\u0026lt;1000\u003c/p\u003e\u003cp\u003eD. Strange town\u003c/p\u003e\u003cp\u003eI was inspired by the other solutions. Suppose that we assign an integer a[i] to node with index i. Then, for two nodes i and j, if we assign a value a[i]+a[j] to the edge between node i and node j, one can check that for any Hamilton cycle, the total value will always be 2*(a[1]+a[2]+...a[N]), which just meets the request in the problem. Therefore, the problem is solved if we can guarantee that there exists no a[i]+a[j] that is equal to any other a[s]+a[t]. Specifically, we can adopt the \u0026quot;hash idea\u0026quot; to record all the values of a[i]+a[j] that have been appeared for the first N-1 nodes, and for the N-th node, we can enumerate from 1 to 1000 to select an appropriate integer for a[N], which leads to no contradiction, and finally update the \u0026quot;hash table\u0026quot; for the newly added a[N].\u003c/p\u003e\u003cp\u003eWell, this is really a wonderful solution which transforms the original problem into a simpler one, but how could the first person come up with such an idea.....\u003c/p\u003e\u003c/div\u003e","tags":[]}}