{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1432203328,"rating":32,"authorHandle":"kien_coi_1997","modificationTimeSeconds":1432203328,"id":18005,"title":"\u003cp\u003eWhy can this code work strangely?\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThe following code is simple, but it makes different outputs on different machine. \u003c/p\u003e\u003cp\u003eI knew that the reason of this strange behaviour is related to floating-point accuracy. But I can\u0027t find any considerable reasons.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\nusing namespace std;\n\nconst int N \u003d 200005;\nint n, x[N], y[N];\npair\u0026lt;double, double\u0026gt; a[N];\n\nmain() {\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    for (int i\u003d1; i\u0026lt;\u003dn; i++) {\n        scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;x[i], \u0026amp;y[i]);\n        a[i] \u003d make_pair(1.0/x[i], 1.0/y[i]);\n    }\n    sort(a+1, a+n+1);\n    \n    for (int i\u003d1; i\u0026lt;\u003dn; i++)\n    if (binary_search(a+1, a+n+1, make_pair(1.0/x[i], 1.0/y[i])))\n    printf(\u0026quot;%d \u0026quot;, i);\n    cout \u0026lt;\u0026lt; endl;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eInput\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e3\n1 3\n2 2\n3 1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOutput on my computer (expected output)\u003c/p\u003e\u003cp\u003e\u003ccode\u003e1 2 3\u003c/code\u003e\u003c/p\u003e\u003cp\u003eOutput on Codeforces\u003c/p\u003e\u003cp\u003e\u003ccode\u003e2\u003c/code\u003e\u003c/p\u003e\u003cp\u003eCan you show me the reason?\u003c/p\u003e\u003c/div\u003e","tags":["floating number"]}}