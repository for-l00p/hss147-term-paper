{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1403734282,"rating":-3,"authorHandle":"kavishrox","modificationTimeSeconds":1403734282,"id":12842,"title":"\u003cp\u003eSPOJ UPSUB doubt\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi,\u003c/p\u003e\u003cp\u003eI was trying to code a problem on printing all possible LIS of a string in sorted order. The link to the problem is \u003ca href\u003d\"http://www.spoj.com/problems/UPSUB/\"\u003ehttp://www.spoj.com/problems/UPSUB/\u003c/a\u003e. My idea is simply to calculate a 2D LCS matrix by LCS(string s, sort(string s)) and then backtrack over the LCS matrix with optimization to get all the LIS. I am facing problems in optimizing my backtracking code because its visiting way too many states that required. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n/*u,l,d correspond to the possible directions from which the maximum value of the LCS array came from*/\nstruct node{\n    int val,u,l,d;\n};\nint n,maxlen;\nset\u0026lt;string\u0026gt; ans;\nstring s,s1;\n//int vis[110][110];\nvector\u0026lt;vector\u0026lt;node \u0026gt; \u0026gt; dp;\n/*calculates LIS\u003dLCS(s,sort(s))*/\nvoid lis(void){\n    s1\u003ds;\n    sort(s1.begin(),s1.end());\n    //cout\u0026lt;\u0026lt;s1\u0026lt;\u0026lt;endl;\n    for(int i\u003d1;i\u0026lt;\u003dn;i++){\n        for(int j\u003d0;j\u0026lt;\u003dn;j++){\n            if(s1[i-1]\u003d\u003ds[j-1]){\n                /*if(i\u003d\u003d1 and j\u003d\u003d2)\n                    cout\u0026lt;\u0026lt;\u0026quot;Came wrong way \u0026quot;\u0026lt;\u0026lt;endl;*/\n                int x\u003dmax(max(dp[i-1][j].val,dp[i][j-1].val),dp[i-1][j-1].val+1);\n                dp[i][j].val\u003dx;\n                if(dp[i-1][j].val\u003d\u003dx){\n                    dp[i][j].u\u003d1;\n                }\n                if(dp[i][j-1].val\u003d\u003dx){\n                    dp[i][j].l\u003d1;\n                }\n                if((dp[i-1][j-1].val+1)\u003d\u003dx){\n                    dp[i][j].d\u003d1;\n                }\n            }\n            else{\n                int x\u003dmax(dp[i-1][j].val,dp[i][j-1].val);\n                dp[i][j].val\u003dx;\n                if(dp[i-1][j].val\u003d\u003dx){\n                    dp[i][j].u\u003d1;\n                }\n                if(dp[i][j-1].val\u003d\u003dx){\n                    dp[i][j].l\u003d1;\n                }\n            }\n        }\n    }\n    maxlen\u003ddp[n][n].val;\n    //cout\u0026lt;\u0026lt;maxlen\u0026lt;\u0026lt;endl;\n}\nstring st;\nvoid dfs(int x,int y){\n    cout\u0026lt;\u0026lt;\u0026quot;now at \u0026quot;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026quot;\\t\u0026quot;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;\n    if(x\u003d\u003d0 or y\u003d\u003d0){\n        if(st.size()\u003d\u003dmaxlen){\n            set\u0026lt;string\u0026gt;::iterator it\u003dans.begin();\n            ans.insert(it,st);\n            //cout\u0026lt;\u0026lt;\u0026quot;print at \u0026quot;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026quot;\\t\u0026quot;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;\n        }\n        return;\n    }\n    if(dp[x][y].d\u003d\u003d1 ){\n        st\u003ds[y-1]+st;\n        dfs(x-1,y-1);\n        st.erase(st.begin(),st.begin()+1);\n    }\n    if(dp[x][y].u\u003d\u003d1){\n        dfs(x-1,y);\n    }\n    if(dp[x][y].l\u003d\u003d1){\n        dfs(x,y-1);\n    }\n}\nvoid print_lis(void){\n    for(int i\u003d0;i\u0026lt;\u003dn;i++){\n        cout\u0026lt;\u0026lt;endl;\n        for(int j\u003d0;j\u0026lt;\u003dn;j++){\n            cout\u0026lt;\u0026lt;dp[i][j].val\u0026lt;\u0026lt;\u0026quot;\\t\u0026quot;;\n        }\n    }\n    cout\u0026lt;\u0026lt;endl;\n}\nint main(void){\n    int tc;\n    cin\u0026gt;\u0026gt;tc;\n    while(tc--){\n        cin\u0026gt;\u0026gt;s;\n        n\u003ds.size();\n        dp.resize(n+1);\n        for(int i\u003d0;i\u0026lt;\u003dn;i++){\n            dp[i].resize(n+1);\n        }\n        lis();\n        //print_lis();\n        dfs(n,n);\n        //sort(ans.begin(),ans.end());\n        for(set\u0026lt;string\u0026gt;::iterator it\u003dans.begin();it!\u003dans.end();it++)\n            cout\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;endl;\n    }\n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ePlease suggest me some ways by which I can optimize the dfs(i,j) part. \u003c/p\u003e\u003c/div\u003e","tags":["spoj","dp","backtracking"]}}