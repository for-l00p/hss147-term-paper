{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1410548423,"rating":35,"authorHandle":"Antoniuk","modificationTimeSeconds":1410622869,"id":13758,"title":"\u003cp\u003eEditorial Codeforces Round #266 (Div. 2)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/466/problem/A\" title\u003d\"Codeforces Round 266 (Div. 2)\"\u003e466A - Cheap Travel\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSolution of this problem is based on two claims: \u003cbr /\u003e  — If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e·\u003ci\u003ea\u003c/i\u003e ≤ \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e then there is no point to buy a ride ticket. \u003cbr /\u003e  — Sometimes it is better to buy summary more ride tickets for amount of rides than we need. \u003cbr /\u003e If we receive profits bying ride tickets then number of such ones will be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/07/e8/07e8489626b838697d0d2d38edf799b6144e2353.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. For the remain \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003em\u003c/i\u003e·\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e rides we must choose the best variant: to buy separate ticket for each ride, or to buy ride ticket and use it not fully.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity\u003c/strong\u003e: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e\u003cbr /\u003e \u003cstrong\u003eSolution\u003c/strong\u003e: \u003ca href\u003d\"/contest/466/submission/7784793\" title\u003d\"Submission 7784793 by KaiZeR\"\u003e7784793\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/466/problem/B\" title\u003d\"Codeforces Round 266 (Div. 2)\"\u003e466B - Wonder Room\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLet’s assume that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e ≤ \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eFirst of all, let’s consider the situation when we can already accommodate all the students. If \u003cspan class\u003d\"tex-span\"\u003e6·\u003ci\u003en\u003c/i\u003e ≤ \u003ci\u003ea\u003c/i\u003e·\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e then answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e·\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eOtherwise, we have to increase one of the walls(maybe, both). Let’s do it in the following way: iterate the size of the smallest wall \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/ae/4eaefacaa0bb808457e91535cc7ceb7941352416.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e ), after that we can calculate the size of another wall as \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/fb/3d/fb3d18a4f0be2a70ff39863f608235a7489318fb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003cbr /\u003e For all this \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e ≤ \u003ci\u003enew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e we choose such a pair that has the smallest area of a room.\u003c/p\u003e\u003cp\u003eObviously to undestrand, that there is no point to consider \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/62/10/62103ecf30f1a6ee7441cfa9459d70e40d9394cf.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e because we can decrease it and receive room of smaller area when we know that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6a/02/6a02677831d55221c2538ba1eb17ced042995f6a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity\u003c/strong\u003e: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003cbr /\u003e \u003cstrong\u003eSolution\u003c/strong\u003e: \u003ca href\u003d\"/contest/466/submission/7784788\" title\u003d\"Submission 7784788 by KaiZeR\"\u003e7784788\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/466/problem/C\" title\u003d\"Codeforces Round 266 (Div. 2)\"\u003e466C - Number of Ways\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eFirst of all, notice that if sum of all elements is equal \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e then sum of each of three parts is equal \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a7/87/a787247f31eb07c9458b9c83a2e599a3d9837bf2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003cbr /\u003e Therefore, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e is not divided by \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e — then answer is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e.\u003cbr /\u003e Otherwise, let’s iterate the end of first part \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e - 2\u003c/span\u003e) and if sum of 1..i elements is equal \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a7/87/a787247f31eb07c9458b9c83a2e599a3d9837bf2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e then it means that we have to add to the answer the amount of such \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1 \u0026lt; \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e) that the sum of elements from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e-th to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e-tn also equals \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a7/87/a787247f31eb07c9458b9c83a2e599a3d9837bf2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003c/p\u003e\u003cp\u003eLet’s create an array \u003ccode\u003ecnt[]\u003c/code\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e equals 1, if the sum of elements from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e-th equals \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a7/87/a787247f31eb07c9458b9c83a2e599a3d9837bf2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and 0 — otherwise. Now, to calculate the answer we have to find the sum \u003ccode\u003ecnt[j] + cnt[j+1] + ... + cnt[n]\u003c/code\u003e faster then O(n). There are a lot of required ways to do this, but the easiest one is to create a new additional array \u003ccode\u003esums[]\u003c/code\u003e where in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e-th element will be \u003ccode\u003ecnt[j] + cnt[j+1] + ... + cnt[n]\u003c/code\u003e. It is easy to calculate in such way: \u003ccode\u003esums[n] \u003d cnt[n]\u003c/code\u003e, \u003ccode\u003esums[i] \u003d sums[i+1] + cnt[i] (i \u0026lt; n)\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eThus, we receive very simple solution: for each prefix of initial array 1..i with the sum that equals \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a7/87/a787247f31eb07c9458b9c83a2e599a3d9837bf2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e we need to add to the answer \u003ccode\u003esums[i+2]\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity\u003c/strong\u003e: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e\u003cbr /\u003e \u003cstrong\u003eSolution\u003c/strong\u003e: \u003ca href\u003d\"/contest/466/submission/7784781\" title\u003d\"Submission 7784781 by KaiZeR\"\u003e7784781\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/466/problem/D\" title\u003d\"Codeforces Round 266 (Div. 2)\"\u003e466D - Increase Sequence\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLets use dynamic programming to solve this problem. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003eopened\u003c/i\u003e]\u003c/span\u003e — the number of ways to cover prefix of array 1..i by segments and make it equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e and remain after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eopened\u003c/i\u003e\u003c/span\u003e segments that are not closed.\u003c/p\u003e\u003cp\u003eConsider all possible variants opening/closing segments in each position:\u003cbr /\u003e - \u003ccode\u003e]\u003c/code\u003e closing one segment\u003cbr /\u003e - \u003ccode\u003e[\u003c/code\u003e opening one new segment\u003cbr /\u003e - \u003ccode\u003e[]\u003c/code\u003e adding one segment with length 1\u003cbr /\u003e - \u003ccode\u003e][\u003c/code\u003e closing one opened segment and opening a new one\u003cbr /\u003e - \u003ccode\u003e-\u003c/code\u003e do nothing\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eLets understand how to build dynamic. It is obviously to understand that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] + \u003ci\u003eopened\u003c/i\u003e\u003c/span\u003e can be equal \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e - 1\u003c/span\u003e. Otherwise, number of such ways equals 0.\u003c/p\u003e\u003cp\u003eConsider this two cases separately: \u003c/p\u003e\u003cp\u003e1) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] + \u003ci\u003eopened\u003c/i\u003e \u003d \u003ci\u003eh\u003c/i\u003e\u003c/span\u003e\u003cbr /\u003e It means that number of opened segments after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th as max as possible and we can’t open one more segment in this place. So there are two variants:\u003cbr /\u003e - \u003ccode\u003e[\u003c/code\u003e Opening a new segment. If only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eopened\u003c/i\u003e \u0026gt; 0\u003c/span\u003e. \u003ccode\u003edp[i][opened] +\u003d dp[i-1][opened + 1]\u003c/code\u003e\u003cbr /\u003e - \u003ccode\u003e-\u003c/code\u003e Do nothing. \u003ccode\u003edp[i][opened] +\u003d dp[i-1][opened]\u003c/code\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eOther variants are impossible because of summary value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e will be greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e(when segment is finishing in current position — it increase value, but do not influence on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eopened\u003c/i\u003e\u003c/span\u003e, by the dynamic definition.\u003c/p\u003e\u003cp\u003e2) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] + \u003ci\u003eopened\u003c/i\u003e + 1 \u003d \u003ci\u003eh\u003c/i\u003e\u003c/span\u003e \u003cbr /\u003e Here we consider ways where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th element has been increased by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eopened\u003c/i\u003e + 1\u003c/span\u003e segments, but after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th remain only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eopened\u003c/i\u003e\u003c/span\u003e not closed segments. Therefore, there are next variants:\u003cbr /\u003e - \u003ccode\u003e]\u003c/code\u003e — closing one of the opened segments(we can do it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eopened\u003c/i\u003e + 1\u003c/span\u003e ways). \u003ccode\u003edp[i][opened] +\u003d dp[i-1][opened + 1] * (opened + 1)\u003c/code\u003e \u003cbr /\u003e - \u003ccode\u003e[]\u003c/code\u003e — creating 1-length segment. \u003ccode\u003edp[i][opened] +\u003d dp[i-1][opened]\u003c/code\u003e \u003cbr /\u003e - \u003ccode\u003e][\u003c/code\u003e — If only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eopened\u003c/i\u003e \u0026gt; 0\u003c/span\u003e. Amount of ways to choose segment which we will close equals \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eopened\u003c/i\u003e\u003c/span\u003e. \u003ccode\u003edp[i][opened] +\u003d dp[i-1][opened] * opened\u003c/code\u003e\u003c/p\u003e\u003cp\u003eStart values — \u003ccode\u003edp[1][0] \u003d (a[1] \u003d\u003d h || a[1] + 1 \u003d\u003d h?1:0);  dp[1][1] \u003d (a[1] + 1 \u003d\u003d h?1:0)\u003c/code\u003e\u003c/p\u003e\u003cp\u003eAnswer — \u003ccode\u003edp[n][0]\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity\u003c/strong\u003e: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e\u003cbr /\u003e \u003cstrong\u003eSolution\u003c/strong\u003e: \u003ca href\u003d\"/contest/466/submission/7784697\" title\u003d\"Submission 7784697 by KaiZeR\"\u003e7784697\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/466/problem/E\" title\u003d\"Codeforces Round 266 (Div. 2)\"\u003e466E - Information Graph\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLet’s introduce all structure of the company as a graph(if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eу\u003c/i\u003e\u003c/span\u003e is the head of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eх\u003c/i\u003e\u003c/span\u003e then we add edge \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e -\u0026gt; \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e). It is obviously to understand that after each operation our graph will be the set of trees. Actually, the third query — to check is our vertex belong to the subtree of the vertex which has received data package. Graph that we will receive after doing all operations we call final. Also, we will say that two vertexes belong to the same connectivity component if they belong to the same component in graph that we can have from final by changing directed edge to undirected.\u003c/p\u003e\u003cp\u003eConsider the following statement: vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eу\u003c/i\u003e\u003c/span\u003e is the parent of vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eх\u003c/i\u003e\u003c/span\u003e in current graph(after doing first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e queries) if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eу\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eх\u003c/i\u003e\u003c/span\u003e belongs to the same conectitive component and in final graph \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eу\u003c/i\u003e\u003c/span\u003e is the parent of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eх\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe will solve this problem offline. After each query of adding data package we will immediately answer all the questions about this package. Besides that, use disjoint set union to define is this vertex belong to the same component or not. To answer the question we need to check that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e is the parent of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e in final graph and that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e is currently belong to the same connectivity component. Final graph we will build before doing this algorithm because we know all queries. Check that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e is the parent of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e in final tree we can simply in O(1) by arrays of entry-time and output-time which we can calculate use dfs(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e —parent \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e \u0026lt;\u003d\u0026gt; (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ein\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e] ≤ \u003ci\u003ein\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eout\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e] ≤ \u003ci\u003eout\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity\u003c/strong\u003e: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e * \u003ci\u003eu\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e — inverse Ackerman function. \u003cbr /\u003e \u003cstrong\u003eSolution\u003c/strong\u003e: \u003ca href\u003d\"/contest/466/submission/7784662\" title\u003d\"Submission 7784662 by KaiZeR\"\u003e7784662\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["codeforces","266","editorial"]}}