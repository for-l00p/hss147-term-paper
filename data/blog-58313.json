{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1520781979,"rating":2,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1520781979,"id":58313,"title":"\u003cp\u003eNotes on Codeforces Beta Round #123, Div2- A, B, C, D, E\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/195/problem/A\" title\u003d\"Codeforces Round 123 (Div. 2)\"\u003e195A - Let\u0027s Watch Football\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe can solve this by building an x-y coordinate, where the horizonal coordinate denotes the time and the vertical one denotes the quantity that we have downloaded or watched. One can simply draw two lines to describe the “download behavior” and “watch behavior”. We should find out the minimum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e so that the “download behavior” line is always above the other line.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/195/problem/B\" title\u003d\"Codeforces Round 123 (Div. 2)\"\u003e195B - After Training\u003c/a\u003e\u003c/p\u003e\u003cp\u003eA straightforward implementation problem.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/195/problem/C\" title\u003d\"Codeforces Round 123 (Div. 2)\"\u003e195C - Try and Catch\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe main framework is to adopt a “stack” to match every “try” with the correct “match” (just like the classical “bracket matching problem”). Then, we find out the “nearest” try-catch pair that has the same “exception name”. Be careful of the processing of string parsing.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/195/problem/D\" title\u003d\"Codeforces Round 123 (Div. 2)\"\u003e195D - Analyzing Polyline\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst note that we can omit any \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e \u003d \u003ci\u003ekx\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d 0\u003c/span\u003e, as they have no effect on the result (they just move the whole polyline in the vertical direction). Then, we deal with each function according to the sign of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, i.e., we divide them into two types, one containing positive \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e while the other containing negative \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNext, we implement a “duplicate elements removing” operation, for positive \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e and negative \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, respectively. Suppose that we have two functions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e \u003d \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e \u003d \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e, and they satisfy \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u003d \u003ci\u003ec\u003c/i\u003e × \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u003d \u003ci\u003ec\u003c/i\u003e × \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e is a positive constant. This means that these two functions have the same “turning point”, and we can add them together to form a new single function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e \u003d (\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003ci\u003ex\u003c/i\u003e + (\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e while having no effect on the final result. \u003c/p\u003e\u003cp\u003eAfter the above operations, we can count the number of different “turning points”, and this is just the final answer.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/195/problem/E\" title\u003d\"Codeforces Round 123 (Div. 2)\"\u003e195E - Building Forest\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe main idea is disjoint set union (dsu), with path compression (I am not sure of this name, but the target is to avoid the degradation from a tree to a single link with quite large depth). One can search this on the internet. \u003c/p\u003e\u003cp\u003eFor this problem, we should also maintain an extra array to store the distance from some node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to its current root node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. One can check the codes shown in the tutorials.\u003c/p\u003e\u003c/div\u003e","tags":[]}}