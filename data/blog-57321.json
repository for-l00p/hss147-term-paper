{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1516809078,"rating":0,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1516809078,"id":57321,"title":"\u003cp\u003eNotes on Codeforces Beta Round #111, Div2- A, B, C, D (tarjan\u0027s algorithm to find bridges), E\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/160/problem/A\" title\u003d\"Codeforces Round 111 (Div. 2)\"\u003e160A - Twins\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe sort the array in a decreasing order, and calculate the prefix sum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e. Our target is to find the minimum index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e so that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] × 2\u003c/span\u003e is strictly larger than the total sum.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/160/problem/B\" title\u003d\"Codeforces Round 111 (Div. 2)\"\u003e160B - Unlucky Ticket\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAfter dividing the given sequence into the first half and second half, we sort both of them in an increasing order, and compare the elements with the same indices, one by one. We should check whether the first half has strictly larger or smaller elements than the second half, at each position.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/160/problem/C\" title\u003d\"Codeforces Round 111 (Div. 2)\"\u003e160C - Find Pair\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe general idea is to first sort the given array in an increasing order, denoted as \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e. Then, the required sequence should be \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e), (\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e), ...(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e), (\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e), (\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e), ...(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e), (\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e), ...(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e. For instance, for (1, 2, 3), we have (1, 1), (1, 2), (1, 3),(2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3). However this is not correct if we have elements with the same value. For instance, for (1, 2, 2), it should be (1, 1), (1, 2), (1, 2),(2, 1), (2, 1), (2, 2), (2, 2), (2, 2), (2, 2).\u003c/p\u003e\u003cp\u003eNevertheless, the above idea still works after some slight modification. Note that the first element can always be determined by calculating \u003cspan class\u003d\"tex-span\"\u003e⌈ \u003ci\u003ek\u003c/i\u003e / \u003ci\u003en\u003c/i\u003e⌉ \u003c/span\u003e (index starts from 0), no matter whether we have same values or not. Suppose that the first element is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Then, we find the number of elements that are strictly smaller than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, denoted as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, and also the total number of elements that are equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, denoted as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e. Now, the problem is reduced to finding out the \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e - \u003ci\u003es\u003c/i\u003e × \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e-th pair in all the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e × \u003ci\u003en\u003c/i\u003e\u003c/span\u003e pairs, which have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e as the first element. Moreover, the second element of these \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e × \u003ci\u003en\u003c/i\u003e\u003c/span\u003e pairs must be ordered as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, ...\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e, ...\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, i.e., any \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e has been repeated \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e times. Thus, it is straightforward to compute the \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e - \u003ci\u003es\u003c/i\u003e × \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e-th element in this sequence.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/160/problem/D\" title\u003d\"Codeforces Round 111 (Div. 2)\"\u003e160D - Edges in MST\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis problem involves several classic techniques, such as disjoint set, kruskal\u0027s algorithm to find minimum spanning tree (MST), tarjan\u0027s algorithm to find bridges in graph, and so on.\u003c/p\u003e\u003cp\u003eSuppose that we have obtained an MST, and we should note that it is possible to replace some edges with other ones which have the same weight, but definitely impossible to use an edge to replace another one with different weight, since we will either obtain a smaller MST (but this is contradictory to our assumption) or a larger MST (this is not an MST!).\u003c/p\u003e\u003cp\u003eTherefore, we can sort the edges in an increasing order of their weight, and adopt the framework of Kruskal\u0027s algorithm, but deal with all the edges which have the same weight at the same time. Suppose that edges \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e, ..., \u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e have the same weight, and now we start enumerating from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, and we will have the following two cases.\u003c/p\u003e\u003cp\u003e1) we find that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e connects one of the already connected components (remember that disjoint set is used in kruskal\u0027s algorithm), then it is definitely not included in any MST. The reason is that this edge must form a cycle with some other edges which have smaller weight, and if it is included in some MST, we can immediately replace it with any edge from “some other edges” and obtain a smaller MST. \u003c/p\u003e\u003cp\u003e2) we find that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e connects two different connected components. Then, it is possible that this edge must be included in any MST, since it might be the unique edge that connects these two components, which is also referred to as Bridge. On the other hand, it might be only included in some MSTs. The reason is that we may find other edges with the same weight and they also connect these two components.\u003c/p\u003e\u003cp\u003eThus, we consider the connected components as “nodes” and build a “graph”, and adopt tarjan\u0027s algorithm to find out all the bridges. However, this “graph” may contain multiple edges, for instance, several edges connect the same two components. Be careful to handle these multiple edges when using tarjan\u0027s algorithm.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/160/problem/E\" title\u003d\"Codeforces Round 111 (Div. 2)\"\u003e160E - Buses and People\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe construct a segment tree to solve this problem (do not forget compressing the original data into smaller range so that we can obtain a segment tree with feasible size). Each node “manages” a time interval \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e, and stores the index of the bus which falls into the current time interval and reaches the farthest distance (also stores this distance). \u003c/p\u003e\u003cp\u003eNext, we sort both buses and passengers all together, in an increasing order of their starting positions (by sorting them together, we can guarantee that whenever we are enumerating a passenger, all the buses that have starting positions ahead of him have been inserted into the segment tree, since only these buses have the potential to send the current passenger to his destination), and enumerate the sorted result one by one. When we meet a bus, we insert it into the segment tree, i.e., we visit the nodes from top to bottom, and update the farthest distance stored at each node (also bus index). When we meet a passenger, we check the segment tree to see whether there exists a bus that can take him to the destination.\u003c/p\u003e\u003cp\u003eI think several issues should be clarified when we try to “query” the segment tree.\u003c/p\u003e\u003cp\u003e1) I think the query complexity is not \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elogN\u003c/i\u003e\u003c/span\u003e. Instead, it may be quite large. Thus, we might need adopt some “pruning” techniques to reduce the search space.\u003c/p\u003e\u003cp\u003e2) Whenever we find that the farthest distance at the current node is strictly less than the passenger\u0027s destination, we should immediately stop the search, since no bus can take the current passenger to his destination; otherwise, whenever we reach some leaf node, we directly return the bus index (since this means that the correct bus has been found); otherwise, we first try to visit the right child node and if it does not return a reasonable bus index, then we continue to visit the left child node (of course the premise condition is that the passenger\u0027s time falls into the time interval of the left child node).\u003c/p\u003e\u003c/div\u003e","tags":[]}}