{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1427896568,"rating":49,"authorHandle":"Klein","modificationTimeSeconds":1427896568,"id":17235,"title":"\u003cp\u003eBigNum arithmetic in Java — Let\u0027s outperform BigInteger!\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eLong story short, I\u0027ve created a class called \u003ca href\u003d\"https://github.com/bwakell/Huldra\"\u003eBigInt\u003c/a\u003e purely written in Java, which is pretty neat and outperforms \u003ccode\u003eBigInteger\u003c/code\u003e. There are most likely (many) bugs, but since it\u0027s pretty basic at the moment, it\u0027ll be a great opportunity for the Codeforces community to learn how to do arbitrary-precision arithmetic. ^^\u003c/p\u003e\u003ch3\u003eIntroduction\u003c/h3\u003e\u003cp\u003eThe standard library \u003ccode\u003eBigInteger\u003c/code\u003e class in Java is known to be notoriously slow (at least for Java 7 and earlier, and I doubt Java 8 is any different). There are faster alternatives like Gnu Classpath providing support for GMP (which is optimized beyond infinity), but this is probably not a viable option for competitive programming. When it comes to pure Java we also have the \u003ccode\u003eApint\u003c/code\u003e class provided by the \u003ca href\u003d\"http://www.apfloat.org/apfloat_java/\"\u003eApfloat library\u003c/a\u003e and the \u003ccode\u003eLargeInteger\u003c/code\u003e class provided by the \u003ca href\u003d\"http://jscience.org/\"\u003eJScience library\u003c/a\u003e, but these two are probably not only clunky for competitive programming usage, they are also not that much faster than \u003ccode\u003eBigInteger\u003c/code\u003e (in many cases they\u0027re slower, see section comparison below).\u003c/p\u003e\u003cp\u003eAs a matter of fact I once had a conversation regarding the Quadratic Sieve with \u003ca href\u003d\"https://gmplib.org/~tege/\"\u003eTorbjörn Granlund\u003c/a\u003e (the principal author of GMP) where we touched upon the issues of implementing QS in Java since \u003ccode\u003eBigInteger\u003c/code\u003e is so slow. Upon this he said something like \u003cem\u003e\u0026quot;Yeah BigInteger is really shitty. I can\u0027t understand why no one makes something better. I mean it would only take about 4 to 5 hours\u0026quot;\u003c/em\u003e. This might be true for Torbjörn, but most likely not for the rest of us. However, the thought of creating my own kick-ass \u003ccode\u003eBigInt\u003c/code\u003e class stayed with me since that day, and now I\u0027ve finally (kind of) done it.\u003c/p\u003e\u003cp\u003eIn my experience, in competitive programming or problem solving like Project Euler, we come in contact with big numbers in the form of cumulative results caused by many operations with operands of small magnitude (e.g. 1337 factorial). So my first design choice with this in mind, and in direct contrast to the \u003ccode\u003eBigInteger\u003c/code\u003e class, was to make my \u003ccode\u003eBigInt\u003c/code\u003e class mutable.\u003c/p\u003e\u003ch3\u003eExample\u003c/h3\u003e\u003cp\u003eLet\u0027s have a look at how to calculate \u003ccode\u003e1337!\u003c/code\u003e using \u003ccode\u003eBigInteger\u003c/code\u003e and \u003ccode\u003eBigInt\u003c/code\u003e respectively.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eBigInteger fac \u003d BigInteger.ONE;\nfor(int i \u003d 1; i\u0026lt;\u003d1337; i++) fac \u003d fac.multiply(BigInteger.valueOf(i));\n\nBigInt myFac \u003d new BigInt(1);\nfor(int i \u003d 1; i\u0026lt;\u003d1337; i++) myFac.umul(i); //umul is unsigned multiplication\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNot only is the ways of \u003ccode\u003eBigInt\u003c/code\u003e less verbose, it\u0027s also way faster. Since \u003ccode\u003eBigInteger\u003c/code\u003e is immutable it must allocate a new array for the results, convert the \u003ccode\u003eint\u003c/code\u003e to a \u003ccode\u003eBigInteger object\u003c/code\u003e, perform the multiplication (using a general algorithm), create a new object and return it. The overhead is massive and unnecessary. \u003ccode\u003eBigInt\u003c/code\u003e on the other hand just performs the operation directly on the internal array used to store the digits (in base \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e32\u003c/sup\u003e\u003c/span\u003e) and grows the array (similar to \u003ccode\u003eArrayList\u003c/code\u003e) should it run out of capacity. (There are better algorithms for calculating big factorials, but that\u0027s not the point in this example...)\u003c/p\u003e\u003cp\u003eSo \u003ccode\u003eBigInteger\u003c/code\u003e is not suitable for many small operations. Is it suitable for operations using larger operands? As it turns out, no it\u0027s not.\u003c/p\u003e\u003ch3\u003eComparison\u003c/h3\u003e\u003cp\u003eThe following time measurements are a results of some benchmarks run on my shitty 1.65GHz Dual Core computer. ^^\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eParsing\u003c/strong\u003e: Converting two strings of length 500000 representing numbers in base \u003cspan class\u003d\"tex-span\"\u003e10\u003c/span\u003e to the internal representation.\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003eAdd\u003c/strong\u003e: Adding a \u003cspan class\u003d\"tex-span\"\u003e100000\u003c/span\u003e decimal digit number to another equally sized number, \u003cspan class\u003d\"tex-span\"\u003e100000\u003c/span\u003e times. (MidBig-size cumulative benchmark.)\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003eSub\u003c/strong\u003e: Same as the addition experiment, but with subtractions.\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003eMidMul\u003c/strong\u003e: Multiplying a \u003cspan class\u003d\"tex-span\"\u003e300\u003c/span\u003e decimal digit number to a growing product, initially a \u003cspan class\u003d\"tex-span\"\u003e300\u003c/span\u003e decimal digit number. (Mid-size cumulative benchmark.)\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003eTinyMul\u003c/strong\u003e: The naive straightforward way to calculate \u003cspan class\u003d\"tex-span\"\u003e50000!\u003c/span\u003e (Small-size cumulative benchmark.)\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003eBigMul\u003c/strong\u003e: Multiplication of two \u003cspan class\u003d\"tex-span\"\u003e500000\u003c/span\u003e decimal digit numbers. (Big-size benchmark.)\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003eMidDiv\u003c/strong\u003e: Dividing a \u003cspan class\u003d\"tex-span\"\u003e400000\u003c/span\u003e decimal digit number by a \u003cspan class\u003d\"tex-span\"\u003e4000\u003c/span\u003e decimal digit number a \u003cspan class\u003d\"tex-span\"\u003e1000\u003c/span\u003e times. (Mid-size cumulative benchmark.)\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003eBigDiv\u003c/strong\u003e: Dividing a \u003cspan class\u003d\"tex-span\"\u003e400000\u003c/span\u003e decimal digit number by a \u003cspan class\u003d\"tex-span\"\u003e200000\u003c/span\u003e decimal digit number. (Big-size benchmark.)\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003etoString\u003c/strong\u003e: Converting the internal representation (having in decimal \u003cspan class\u003d\"tex-span\"\u003e213237\u003c/span\u003e digits) to a decimal number string.\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003eTest        BigInteger    BigInt    Apint     LargeInteger\n----------------------------------------------------------\nParsing     31.602s       8.497s    0.049s    14.054s\nAdd         6.394s        3.006s    27.279s   6.322s\nSub         5.618s        2.243s    24.35s    6.026s\nMidMul      2.676s        2.259s    40.433s   3.176s\nTinyMul     10.683s       1.468s    35.535s   6.879s\nBigMul      12.332s       0.655s    0.289s    1.266s\nMidDiv      9.936s        7.558s    297.022s  3239.432s\nBigDiv      3.647s        2.536s    0.563s    5.335s\ntoString    16.912s       4.614s    0.029s    15.116s\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003eComments\u003c/h4\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eParsing\u003c/strong\u003e: \u003cem\u003eApint\u003c/em\u003e is by far the fastest parser, this because it internally (probably) uses a power of \u003cspan class\u003d\"tex-span\"\u003e10\u003c/span\u003e as base. \u003cem\u003eBigInteger\u003c/em\u003e is by far the slowest.\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003eAdd\u003c/strong\u003e: \u003cem\u003eBigInt\u003c/em\u003e is fastest due to its mutability. \u003cem\u003eApint\u003c/em\u003e is by far the slowest, since it uses a power of \u003cspan class\u003d\"tex-span\"\u003e10\u003c/span\u003e base.\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003eSub\u003c/strong\u003e: The same goes here. \u003cem\u003eApint\u003c/em\u003e is slow when it comes to simple arithmetic operations.\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003eMidMul\u003c/strong\u003e: A bit surprisingly \u003cem\u003eApint\u003c/em\u003e is the slowest here, while \u003cem\u003eBigInt\u003c/em\u003e is the fastest.\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003eTinyMul\u003c/strong\u003e: Not surprisingly \u003cem\u003eBigInt\u003c/em\u003e is the fastest (since it\u0027s designed around this user case) and \u003cem\u003eApint\u003c/em\u003e the slowest.\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003eBigMul\u003c/strong\u003e: \u003cem\u003eBigInteger\u003c/em\u003e is by far the slowest since it utilizes a naive \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e algorithm, whereas \u003cem\u003eBigInt\u003c/em\u003e uses (a parallel) Karatsuba, and \u003cem\u003eApint\u003c/em\u003e probably uses FFT making it the fastest.\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003eMidDiv\u003c/strong\u003e: What the heck happened to \u003cem\u003eLargeInteger\u003c/em\u003e!? 50 minutes runtime!? Well that\u0027s simply unacceptable. \u003cem\u003eBigInt\u003c/em\u003e and \u003cem\u003eBigInetger\u003c/em\u003e are the fastest here. \u003cem\u003eApint\u003c/em\u003e (and definitely \u003cem\u003eLargeInteger\u003c/em\u003e) probably makes unwise algorithm choices.\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003eBigDiv\u003c/strong\u003e: \u003cem\u003eLargeInteger\u003c/em\u003e is the slowest, but by no means bad. \u003cem\u003eApint\u003c/em\u003e is once again fastest, this is really the area where it shines.\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003etoString\u003c/strong\u003e: Both \u003cem\u003eBigInteger\u003c/em\u003e and \u003cem\u003eLargeInteger\u003c/em\u003e are just slow. \u003cem\u003eLargeInteger\u003c/em\u003e also uses for some unknown reason a recursive approach, which could cause Stackoverflow if you don\u0027t increase your stack size (terrible design choice indeed...). Once again \u003cem\u003eApint\u003c/em\u003e is the fastest due to its internal representation.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThis survey is by no means comprehensive, but it gives a hint and its verdict is clear. \u003ccode\u003eBigInteger\u003c/code\u003e is good if you want a bug free (I guess ^^) and foolproof class. \u003ccode\u003eLargeInteger\u003c/code\u003e isn\u0027t good for anything. \u003ccode\u003eApint\u003c/code\u003e is good if your program frequently parses and prints decimal numbers, it\u0027s also as of today the fastest implementation when it comes to multiplication and division of big numbers (although that will probably change soon ;D ). Otherwise \u003ccode\u003eBigInt\u003c/code\u003e really is your choice, sure there\u0027s not much else to it than the \u0026quot;4 basic operations\u0026quot; and since it\u0027s mutable it\u0027s a bit risky (please be careful if start putting it into trees etc.).\u003c/p\u003e\u003cp\u003eThe code for \u003ccode\u003eBigInt\u003c/code\u003e can be found through the link at the top leading to the \u0026quot;Huldra project\u0026quot; (a reference to a forest creature in Scandinavian folklore) and I\u0027ll hope you might learn something from it. Most tutorials out there just teach you how to do it in base 10^9 which is a bit noobish.\u003c/p\u003e \u003chr /\u003e\u003c/div\u003e","tags":["arithmetic","bignum","comparison","bigint","biginteger","apint","largeinteger","karatsuba","fft"]}}