{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1457334564,"rating":10,"authorHandle":"maradonah","modificationTimeSeconds":1457364118,"id":43628,"title":"\u003cp\u003eSet Lower Bounds in Java\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello,\u003c/p\u003e\u003cp\u003eDuring my practice, I wanted to solve the problem \u003ca href\u003d\"//codeforces.com/contest/629/problem/D\"\u003eDiv 2 343, D: Babaei and Birthday Cake\u003c/a\u003e. In summary, we are given a sequence \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e positive numbers and we should find a strictly increasing subsequence of this sequence with maximum sum. A straightforward dynamic programming solution defines a state \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e as the maximum sum of an increasing subsequence ending at element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(0) \u003d 0\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e) \u003d \u003ci\u003emax\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1 ≤ \u003ci\u003ej\u003c/i\u003e \u0026lt; \u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ej\u003c/i\u003e) + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. The editorial explains how to implement this dynamic programming solution using segment trees in O(n log n) time.\u003c/p\u003e\u003cp\u003eAnother solution that is also well known is to use binary search with a little modified dp recurrence. One such recurrence is to define \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e as the maximum sum of a strictly increasing subsequence whose end is at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. One can consider the elements in the order of their appearance. For element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, the algorithm finds the largest previous element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e \u0026lt; \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (can be done using std::set::lower_bound) and we would have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e) \u003d \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e) + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. We then remove all elements \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e \u0026gt; \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u0026lt; \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e) ≤ \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eI implemented the solution in C++ \u003ca href\u003d\"//codeforces.com/contest/629/submission/16561046\"\u003ehere\u003c/a\u003e. I tried to implement the solution in Java but I was not able to find a good equivalent of the \u003ca href\u003d\"http://www.cplusplus.com/reference/set/set/lower_bound/\"\u003estd::set::lower_bound\u003c/a\u003e. The equivalent I know about is the \u003ca href\u003d\"https://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html#ceiling%28E%29\"\u003eceiling method\u003c/a\u003e in TreeSet class however this method returns the value of the element other than an iterator to it. I wonder whether anybody knows an equivalent to std::set::lower_bound in Java.\u003c/p\u003e\u003cp\u003eSorry for the long post :)\u003c/p\u003e\u003c/div\u003e","tags":["lower bound","java","dp"]}}