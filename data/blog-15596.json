{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1420440041,"rating":-4,"authorHandle":"Matrix.code","modificationTimeSeconds":1420440041,"id":15596,"title":"\u003cp\u003eSegment Tree Update Too Slow\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThe problem is about bracket matching . \u003ca href\u003d\"http://www.spoj.com/problems/BRCKTS/\"\u003elink\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI have solved it. Didn\u0027t thought it would pass the time limit . I used segment tree. My update function seems too slow to me, but couldn\u0027t think of other way Please Help to optimise \u003c/p\u003e \u003cpre\u003e\u003ccode\u003estruct dta {\n        vector\u0026lt;char\u0026gt; V; // Using vector , stack may be the best\n        dta(){}\n        dta(char n){V.push_back(n);}\n        \n}T[3 * MX];\n\n\nvoid init( int node , int b , int e)\n{\n        if(b \u003d\u003d e ){\n                T[node] \u003d dta(str[b]);\n                return;\n        }\n        int mid \u003d ( b + e ) / 2;\n        init(node * 2, b, mid);\n        init(node *2 +1 , mid + 1, e);\n        T[node].V \u003d T[node *2].V;\n        int top \u003d T[node].V.size() - 1;\n\n        // merging the two segments \n\n        for(int i \u003d 0 ; i\u0026lt; T[node *2+ 1].V.size(); i ++ ){\n                if(top\u0026gt;\u003d0 \u0026amp;\u0026amp; T[node *2+ 1].V[i] \u003d\u003d \u0027)\u0027 \u0026amp;\u0026amp; T[node].V[top] \u003d\u003d \u0027(\u0027){\n                        T[node].V.pop_back();\n                        top -- ;\n                }\n                else {\n                        T[node].V.push_back(T[node *2+ 1].V[i]);\n                        top ++;\n                }\n        }\n        \n}\n\nvoid upd ( int node, int b , int e , int pos )\n{\n        if(b \u003d\u003d e ){\n                T[node] \u003d dta(str[b]);\n                return;\n        }\n        int mid \u003d ( b + e ) / 2;\n        if(pos \u0026lt;\u003d mid ){\n                upd(node * 2, b, mid, pos);\n        }\n        else upd(node *2 +1, mid +1 ,e, pos);\n        T[node].V \u003d T[node *2].V;\n        int top \u003d (int)T[node].V.size() - 1;\n        \n        // Update \u0026amp; merge The left \u0026amp; right segment\n\n        for(int i \u003d 0 ; i\u0026lt; T[node *2+ 1].V.size(); i ++ ){\n                if(top\u0026gt;\u003d0 \u0026amp;\u0026amp; T[node *2+ 1].V[i] \u003d\u003d \u0027)\u0027 \u0026amp;\u0026amp; T[node].V[top] \u003d\u003d \u0027(\u0027){\n                        T[node].V.pop_back();\n                        top -- ;\n                }\n                else {\n                        T[node].V.push_back(T[node *2+ 1].V[i]);\n                        top ++;\n                }\n        }\n        \n        \n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eBut storing the whole segments and update is too heavy, Don\u0027t know the complexity of update operation ( may be n lg n )\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e","tags":["segment tree","data structures"]}}