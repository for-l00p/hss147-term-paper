{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1435821839,"rating":0,"authorHandle":"match","modificationTimeSeconds":1435821839,"id":19027,"title":"\u003cp\u003eCOOK53 Expectation problem [RRPLAYER]\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"http://www.codechef.com/COOK53/problems/RRPLAYER\"\u003ehttp://www.codechef.com/COOK53/problems/RRPLAYER\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is the problem link. I have one doubt here.\u003c/p\u003e\u003cp\u003eAlthough I agree with the states mentioned in the editorial. But, when I was trying to solve it on my own. I create the states as F(i,j) meaning i songs have not been played even once and j songs have been played atleast once. With this, I can have the following recurrence relations\u003c/p\u003e\u003cp\u003eThese are some base cases.\u003c/p\u003e\u003cp\u003ef(0,i) \u003d 0.0 //all songs have been played once. f(i,0) \u003d [1 + f(n-1,1)]/i \u003c/p\u003e\u003cp\u003eNow, lets derive for other (i,j)\u003c/p\u003e\u003cp\u003ef(i,j) \u003d [1 + f(i,j)]/j + [1 + f(i-1,j)]/i\u003c/p\u003e\u003cp\u003ef(i,j) \u003d 1/i + 1/j + f(i,j)/j + f(i-1,j)/i\u003c/p\u003e\u003cp\u003ef(i,j)[1-1/j] \u003d [i + j + j*f(i-1,j)]/(i*j)\u003c/p\u003e\u003cp\u003ef(i,j)*(j-1)/j \u003d [i + j + j*f(i-1,j)]/(i*j)\u003c/p\u003e\u003cp\u003eCancelling j from both sides on denominator\u003c/p\u003e\u003cp\u003e\u003cstrong\u003ef(i,j) \u003d [i + j + j*f(i-1,j)]/(i*(j-1))\u003c/strong\u003e //final recurrence relation\u003c/p\u003e\u003cp\u003eBut if you see, this becomes undefined for f(i,1) because in denominator there is a term for (j-1). What am I missing here?\u003c/p\u003e\u003c/div\u003e","tags":["codechef","cookoff"]}}