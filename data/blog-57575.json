{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1517899765,"rating":-3,"authorHandle":"Akikaze","modificationTimeSeconds":1517899937,"id":57575,"title":"\u003cp\u003eEditorial — ProPTIT Contest (Feb 04, 2018)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eChân thành cảm ơn tới \u003ca class\u003d\"rated-user user-green\" href\u003d\"/profile/duonglee\" title\u003d\"Pupil duonglee\"\u003eduonglee\u003c/a\u003e, \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/thanthoai999999999\" title\u003d\"Specialist thanthoai999999999\"\u003ethanthoai999999999\u003c/a\u003e, \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/nghiatd_16\" title\u003d\"Specialist nghiatd_16\"\u003enghiatd_16\u003c/a\u003e, \u003ca class\u003d\"rated-user user-green\" href\u003d\"/profile/lananh98.ptit\" title\u003d\"Pupil lananh98.ptit\"\u003elananh98.ptit\u003c/a\u003e và Hồ Anh Khoa vì đã đóng góp đề, và cảm ơn tới \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/neko_nyaa\" title\u003d\"Expert neko_nyaa\"\u003eneko_nyaa\u003c/a\u003e đã giúp mình với vai trò tester. ;)\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eBài A - Giveaway\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTác giả: Hồ Anh Khoa\u003c/p\u003e\u003cp\u003eEditorial: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Akikaze\" title\u003d\"Expert Akikaze\"\u003eAkikaze\u003c/a\u003e\u003c/p\u003e\u003cp\u003eNguyên tắc cho bài toán này thật sự rất đơn giản: ta tìm giá trị min của các giá trị cận dưới và giá trị max của giá trị cận trên. Do không có 2 khoảng nào trùng nhau, nên nếu bất kỳ khoảng nào có cận dưới bằng với giá trị min và cận trên bằng với giá trị max, ta có thể in ra thứ tự của khoảng nó và kết thúc chương trình luôn. \u003c/p\u003e\u003cp\u003eĐương nhiên là nếu không có đáp án thì ta sẽ in ra \u0026quot;-1\u0026quot;\u003c/p\u003e\u003cp\u003eLời giải của \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/neko_nyaa\" title\u003d\"Expert neko_nyaa\"\u003eneko_nyaa\u003c/a\u003e: \u003ca href\u003d\"https://ideone.com/SX7bJY\"\u003eSubmission\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eBài B - Số 7 may mắn\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTác giả: \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/thanthoai999999999\" title\u003d\"Specialist thanthoai999999999\"\u003ethanthoai999999999\u003c/a\u003e\u003c/p\u003e\u003cp\u003eEditorial: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/neko_nyaa\" title\u003d\"Expert neko_nyaa\"\u003eneko_nyaa\u003c/a\u003e, \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Akikaze\" title\u003d\"Expert Akikaze\"\u003eAkikaze\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTrước hết mình muốn xin lỗi các bạn, vì đã test không kĩ mà đã gây ra vấn đề trong quá trình thi đấu. :(\u003c/p\u003e\u003cp\u003eCó lẽ đây là bài khó nhất trong 6 bài của contest. Có một số bạn đã làm khá tốt trong bài này và được 90 điểm. \u003c/p\u003e\u003cp\u003eVậy 10 điểm còn lại nằm ở những tests nào? Đó là các tests mà toàn bộ xâu chỉ gồm các chữ số 7.\u003c/p\u003e\u003cp\u003eVậy nên, dãy chữ số 7 liên tiếp dài nhất của xâu S có thể có độ dài lên tới |S|, tức là tối đa 10^6. Điều này khiến các thuật toán có độ phức tạp O(N^2) hoặc cao hơn không thể ghi điểm tối đa.\u003c/p\u003e\u003cp\u003eTa có thể giải bài toán này với độ phức tạp O(N), dựa trên một nhận xét như sau:\u003c/p\u003e\u003cp\u003eXét một dãy các chữ số 7 liên tiếp có độ dài i. Nếu ta thêm vào sau dãy 1 chữ số 7, thì số các dãy chữ số 7 độ dài x (1 \u0026lt;\u003d x \u0026lt;\u003d i+1) sẽ đều tăng lên 1 đơn vị.\u003c/p\u003e\u003cp\u003eTừ đây, nguyên lý sẽ được vẽ ra: ta duyệt tuyến tính từ trái sang phải xâu chữ số, sử dụng 1 biến nguyên tạm thời để lưu độ dài của xâu chữ số 7 đang xét. Với mỗi vị trí, nếu độ dài xâu 7 là một số nguyên dương (ta gọi là y) thì ta cộng vào biến đếm số dãy độ dài từ 1 tới y, mỗi biến 1 đơn vị.\u003c/p\u003e\u003cp\u003eNhưng tới đây làm sao để mỗi thao tác cộng này chỉ có độ phức tạp O(1)? Ta sẽ tận dụng mảng cộng dồn ở đây. Có 2 cách xử lý mảng cộng dồn:\u003c/p\u003e\u003cp\u003eCách 1: Vì chắc chắn các biến được tăng luôn bắt đầu từ 1, ta có thể +1 vào đúng vị trí y. Sau khi kết thúc việc duyệt tuyến tính xâu, ta duyệt lại mảng đếm từ phải sang trái: giá trị của mỗi phần tử được duyệt đến sẽ được cộng dồn vào phần tử liền trước nó.\u003c/p\u003e\u003cp\u003eCách 2 (tổng quát hơn): Giả sử trong một mảng, ta muốn cộng vào các phần tử từ vị trí thứ i tới vị trí thứ j 1 đơn vị. Ta có thể thực hiện bằng cách +1 vào phần tử thứ i, -1 vào phần tử thứ (j+1). Sau đó ta thực hiện cộng dồn từ trái sang phải.\u003c/p\u003e\u003cp\u003eLời giải (mảng cộng dồn 1) (\u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/neko_nyaa\" title\u003d\"Expert neko_nyaa\"\u003eneko_nyaa\u003c/a\u003e): \u003ca href\u003d\"https://ideone.com/p3KyoC\"\u003eSubmission\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLời giải (mảng cộng dồn 2) (\u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Akikaze\" title\u003d\"Expert Akikaze\"\u003eAkikaze\u003c/a\u003e): \u003ca href\u003d\"https://ideone.com/uUMYEq\"\u003eSubmission\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eBài C - U23 Việt Nam vs U23 Qatar\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTác giả: \u003ca class\u003d\"rated-user user-green\" href\u003d\"/profile/duonglee\" title\u003d\"Pupil duonglee\"\u003eduonglee\u003c/a\u003e\u003c/p\u003e\u003cp\u003eEditorial: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/neko_nyaa\" title\u003d\"Expert neko_nyaa\"\u003eneko_nyaa\u003c/a\u003e\u003c/p\u003e\u003cp\u003eHầu hết các bạn đều đã làm được bài này một cách dễ dàng. Những bạn không làm được thì có lẽ là do lười copy-paste (?) :p Vậy chúng ta sẽ mở rộng câu hỏi, bài này có thể giải quyết như thế nào sẽ nhanh và gọn nhất?\u003c/p\u003e\u003cp\u003eVì dung lượng dữ liệu vào nhỏ, nên ta có thể duyệt trâu bài toán này bằng nhiều cách. Có bạn sẽ sử dụng if else tất cả các trường hợp, có bạn sẽ lưu danh sách các cầu thủ dưới dạng một array,...\u003c/p\u003e\u003cp\u003eRiêng mình, mình thích lưu tất cả vào một xâu thật lớn và dùng hàm find.\u003c/p\u003e\u003cp\u003eHàm find, dùng để tìm một xâu có phải là xâu con của một xâu khác hay không, có giá trị trả về là vị trí xuất hiện đầu tiên của xâu con cần tìm. Hàm này sẽ rất hữu dụng trong bài khi đề đã cho sẵn vị trí chơi các cầu thủ ở phía sau tên. Khi này việc copy-paste trở nên dễ dàng hơn nhiều :D\u003c/p\u003e\u003cp\u003eLời giải sử dụng array lưu dữ liệu (\u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/neko_nyaa\" title\u003d\"Expert neko_nyaa\"\u003eneko_nyaa\u003c/a\u003e): \u003ca href\u003d\"https://ideone.com/wOcPay\"\u003eSubmission\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLời giải sử dụng string::find (\u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/neko_nyaa\" title\u003d\"Expert neko_nyaa\"\u003eneko_nyaa\u003c/a\u003e): \u003ca href\u003d\"https://ideone.com/JLjtwj\"\u003eSubmission\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eBài D - Việt Nam vô địch\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTác giả: \u003ca class\u003d\"rated-user user-green\" href\u003d\"/profile/lananh98.ptit\" title\u003d\"Pupil lananh98.ptit\"\u003elananh98.ptit\u003c/a\u003e\u003c/p\u003e\u003cp\u003eEditorial: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/neko_nyaa\" title\u003d\"Expert neko_nyaa\"\u003eneko_nyaa\u003c/a\u003e\u003c/p\u003e\u003cp\u003eVới kích thước dữ liệu n \u0026lt;\u003d 1000, các bạn hoàn toàn có thể sử dụng các thuật toán sắp xếp O(N^2) như insertion sort hay bubble sort. Có vẻ như hầu hết các bạn thích sử dụng bubble sort. Riêng mình thì mình lại thích selection sort :p\u003c/p\u003e\u003cp\u003eLời giải của \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/neko_nyaa\" title\u003d\"Expert neko_nyaa\"\u003eneko_nyaa\u003c/a\u003e: \u003ca href\u003d\"https://ideone.com/mci5Ep\"\u003eSubmission\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eBài E - U23 Việt Nam – U23 Iraq\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTác giả: \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/nghiatd_16\" title\u003d\"Specialist nghiatd_16\"\u003enghiatd_16\u003c/a\u003e\u003c/p\u003e\u003cp\u003eEditorial: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/neko_nyaa\" title\u003d\"Expert neko_nyaa\"\u003eneko_nyaa\u003c/a\u003e\u003c/p\u003e\u003cp\u003eBài toán này có 2 phần: tạo các số nguyên tố, và tạo vòng xoắn gồm các số nguyên tố đó.\u003c/p\u003e\u003cp\u003eĐể tạo ra n*m số nguyên tố, ta có thể sử dụng \u003ca href\u003d\"http://vnoi.info/wiki/translate/he/Number-Theory-2#s%C3%A0ng-eratosthenes-sieve-of-eratosthenes\"\u003esàng Eratosthenes.\u003c/a\u003e. Đây là một thuật toán rất hay và kinh điển dùng để giải các bài toán về số nguyên tố và phân tích thừa số nguyên tố.\u003c/p\u003e\u003cp\u003eVới n, m \u0026lt;\u003d 300, ma trận khung thành của ta có thể có lên đến 90000 số khác nhau. Mảng dùng để sàng số nguyên tố cần có kích thước lớn hơn 10^6 để có thể sàng hiệu quả toàn bộ các số đó. (Bonus: số nguyên tố thứ 100000 có giá trị là 1299709).\u003c/p\u003e\u003cp\u003eViệc còn lại là việc tạo vòng xoắn, không phải quá khó khăn, nhưng việc code thành công tương đối vất vả. Ở đây thì mình không có lời khuyên gì hơn là practice makes perfect :D luyện tập tốt là sẽ làm được\u003c/p\u003e\u003cp\u003eLời giải của \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/neko_nyaa\" title\u003d\"Expert neko_nyaa\"\u003eneko_nyaa\u003c/a\u003e: \u003ca href\u003d\"https://ideone.com/ZsPEGk\"\u003eSubmission\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eBài F - Trước trận chung kết\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTác giả: Hồ Anh Khoa\u003c/p\u003e\u003cp\u003eEditorial: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/neko_nyaa\" title\u003d\"Expert neko_nyaa\"\u003eneko_nyaa\u003c/a\u003e\u003c/p\u003e\u003cp\u003eVâng, tác giả bài này là anh Hồ Anh Khoa :p các bạn có gạch đá gì cứ quăng anh ấy nhé hihihihihi.\u003c/p\u003e\u003cp\u003eCó lẽ trap chính ở bài này thì ai cũng biết rồi :)) đó là việc bạn phải sắp xếp các tên theo thứ tự từ điển trước khi bắt đầu giải bài toán. Như vậy bài toán của chúng ta có 2 phần: sắp xếp, và tìm thứ tự tên được gọi lần thứ k.\u003c/p\u003e\u003cp\u003eVề phần sắp xếp, với kích thước dữ liệu lên đến 10^6, các thuật toán sắp xếp như bubble sort không thể chạy kịp trong 3 giây. Các bạn phải sử dụng hàm sort trong STL có độ phức tạp O(NlogN). \u003c/p\u003e\u003cp\u003eVề phần tìm tên được gọi, ta có thể nhận xét rất đơn giản như sau: Người thứ nhất sẽ gọi lên 1 cái tên, người thứ hai sẽ gọi lên 2 cái tên, ..., người thứ i sẽ gọi lên i cái tên.\u003c/p\u003e\u003cp\u003eNhư vậy, ta có thể trừ dần k cho 1, 2, 3, 4, ... đến khi nó gần xuống 0. Con số còn lại sẽ chính là số thứ tự của cái tên được gọi, cũng là đáp án của đề bài. \u003c/p\u003e\u003cp\u003eLời giải của \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/neko_nyaa\" title\u003d\"Expert neko_nyaa\"\u003eneko_nyaa\u003c/a\u003e: \u003ca href\u003d\"https://ideone.com/jZGaHe\"\u003eSubmission\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}