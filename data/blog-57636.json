{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1518127735,"rating":1,"authorHandle":"Lena19","modificationTimeSeconds":1518127735,"id":57636,"title":"\u003cp\u003eGraphs. Part I. Разбор задач\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eЗадача А. Предок\u003c/h1\u003e\u003cp\u003eВ задаче дано дерево, для которого необходимо обработать \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e ≤ 100000\u003c/span\u003e запросов вида \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, проверяя, что вершина \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e является непосредственным или косвенным предком вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. Для решения данной задачи необходимо построить дерево, корректно обработав входные данные. Каждое ребро этого дерева представляет собой упорядоченную пару \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, 1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e — последовательность элементов, находящихся во второй строке входного файла. На построенном дереве необходимо запустить DFS из корня, во время обхода сохраняя времена входа и выхода для каждой вершины. Утверждается, что если вершина \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e является предком вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e в дереве, то при обходе DFS время входа в вершину \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e будет меньше, чем время входа в вершину \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, а время выхода из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e будет больше, чем время выхода из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. Предварительно сохранив все времена входа и выхода в массивы \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etin\u003c/i\u003e[]\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etout\u003c/i\u003e[]\u003c/span\u003e, на каждый запрос можно отвечать за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eЗамечание: в задаче довольно объемный ввод и вывод, поэтому их нужно оптимизировать. Это можно сделать следующим образом: в main() в самом начале написать ios::sync_with_stdio(0); cin.tie(0); а при выводе вместо endl использовать \u0027\\n\u0027. Либо вместо cin, cout использовать scanf и printf.\u003c/p\u003e\u003ch1\u003eЗадача B. Поиск цикла\u003c/h1\u003e\u003cp\u003eВ задаче дан ориентированный граф без кратных ребер (может содержать петли, при этом петля также является циклом). Для каждой непосещенной вершины графа необходимо запустить поиск в глубину, во время которого в массив \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[]\u003c/span\u003e будет записываться номер вершины, из которой мы пришли в текущую. Представим, что изначально граф раскрашен в белый цвет. Когда DFS заходит в какую-то белую вершину, он перекрашивает её в серый цвет. Далее для всех вершин \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e , смежных с текущей вершиной \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, необходимо проверить их цвет. \u003c/p\u003e \u003cul\u003e   \u003cli\u003eЕсли цвет вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e серый, это сигнализирует о том, что графе есть цикл, и ребро \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e принадлежит этому циклу. Чтобы \u0026quot;закольцевать\u0026quot; цикл, вершину \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e нужно сделать предком вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, а вершину \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e запомнить как старт цикла.\u003c/li\u003e   \u003cli\u003eИначе, если цвет вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e белый, нужно продолжить обход из вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eВ конце DFS при выходе из вершины ее нужно перекрасить в черный цвет, закончив таким образом ее обработку.\u003c/p\u003e\u003cp\u003eВосстановление цикла (если он есть в графе). Для восстановления цикла заведем вектор, первым элементом которого будет найденная при DFS вершина \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Теперь можно подниматься вверх по массиву \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[]\u003c/span\u003e, пока снова не упремся в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Поскольку мы восстанавливали цикл по обратным ребрам, а вывести его необходимо в прямом порядке обхода, то элементы вектора надо вывести в обратном порядке. Учитывайте, что \u0026quot;закольцовывать\u0026quot; цикл при выводе не нужно. \u003c/p\u003e\u003cp\u003eПример кода для восстановления цикла:\u003c/p\u003e \u003cpre\u003evector\u0026lt;int\u0026gt; cycle;\ncycle.emplace_back(start);\nint curvertex \u003d p[start];\nwhile(curvertex !\u003d start) {\n    cycle.emplace_back(curvertex);\n    curvertex \u003d p[curvertex];\n}\u003c/pre\u003e\u003ch1\u003eЗадача C. Противопожарная безопасность\u003c/h1\u003e\u003cp\u003eЗадачу можно переформулировать следующим образом: необходимо найти такое минимальное по размеру подмножество вершин графа, что из всех вершин графа можно прийти хотя бы в одну из вершин данного подмножества.\u003c/p\u003e\u003cp\u003eРассмотрим граф из трех вершин, заданный ориентированными ребрами \u003cspan class\u003d\"tex-span\"\u003e(1, 2), (2, 3)\u003c/span\u003e. Допустим, мы решили взять в итоговое подмножество вершину \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Тогда из \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e достижима \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, но из \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e ничего не достижимо. Добавим в итоговое подмножество вершину \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e. Тогда из \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e становится достижима \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e, и \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e можно удалить из итогового подмножества. Для \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e достижимой не является ни одна вершина, тогда \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e нужно включить в итоговое подмножество. Теперь \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e достижима из всех трех вершин, а \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e можно удалить.\u003c/p\u003e\u003cp\u003eМожно заметить, что для вершин-стоков единственными достижимыми вершинами являются они сами, поэтому они обязательно должны быть включены в итоговое подмножество. Также можно заметить, что любая вершина достижима из всех своих предков. Еще один факт: если вершина \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e достижима из всех своих предков, а вершина \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e достижима из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, то все предки вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e также являются предками \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e. Пусть количество предков вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e равно \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e. Тогда \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e достижима из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e вершин, а \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e достижима из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e + 1\u003c/span\u003e вершины. Таким образом, в итоговое подмножество не выгодно брать ни одну вершину, у которой есть хотя бы один потомок. \u003c/p\u003e\u003cp\u003eВ рамках цикла или же сильносвязной компоненты все вершины будут достижимы друг из друга, поэтому в итоговое подмножество достаточно будет взять одну любую вершину компоненты. \u003c/p\u003e\u003cp\u003eДля полного решения задачи необходимо построить конденсацию графа, и взять в итоговое подмножество все вершины-стоки конденсации.\u003c/p\u003e\u003cp\u003e//может быть позже появится код\u003c/p\u003e\u003ch1\u003eЗадача D. Обход в ширину\u003c/h1\u003e\u003cp\u003eВ данной задаче необходимо аккуратно реализовать поиск в ширину, запустив его из вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e. Можно перестроить граф на списки смежности, а можно оставить матрицу смежности и работать с ней в исходном виде. Пример работы с матрицей смежности:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ebool adj[N][N];\nint dist[N];\n\nvoid bfs(int S) {\n    fill(dist, dist + N, -1); //данная конструкция аналогична циклу for(int i \u003d 0; i \u0026lt; N; i++) dist[i] \u003d 1;\n    queue\u0026lt;int\u0026gt; q;\n    q.push(S);\n    d[S] \u003d 0;\n    while(!q.empty()) {\n        int v \u003d q.top();\n        q.pop();\n        for(int i \u003d 0; i \u0026lt; N; i++) {\n            //adj[v][i] - проверяем что между вершинами v и i есть ребро       \n            //d[v][i] \u003d\u003d -1 сигнализирует о том, что ранее вершина i не посещалась и для нее еще нет ответа            \n            if(adj[v][i] \u0026amp;\u0026amp; d[i] \u003d\u003d -1) {\n                d[i] \u003d d[v] + 1;\n                q.push(i);\n            }\n        }\n    }                \n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбратите внимание, что нумерация вершин в графе начинается с единицы, а нумерация в массиве, задающем матрицу смежности — с нуля. Для корректной работы алгоритма можно уменьшить \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003c/span\u003e на 1, таким образом переводя нумерацию вершин графа в 0-base. Также обратите внимание, что ответ в этой задаче не всегда существует. В условии написано, что при этом необходимо вывести.\u003c/p\u003e\u003ch1\u003eЗадача Е. Кратчайший путь коня\u003c/h1\u003e\u003cp\u003eЭта задача, как и предыдущая, на поиск в ширину. Здесь необходимо грамотно представить шахматную доску как граф. Это удобно делать динамически параллельно ходам коня. Изначально есть одна вершина (в которой стоит конь) с координатами \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ex\u003c/i\u003e;\u003ci\u003ey\u003c/i\u003e]\u003c/span\u003e. Из этой клетки можно перейти во все клетки с координатами \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ex\u003c/i\u003e ± 1;\u003ci\u003ey\u003c/i\u003e ± 2]\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ex\u003c/i\u003e ± 2;\u003ci\u003ey\u003c/i\u003e ± 1]\u003c/span\u003e, если координаты не вылетают за пределы доски. Тогда между исходной клеткой и каждой из представленных появляется ребро. Все эти клетки после их появления нужно положить в очередь BFS, аналогично обрабатывая каждую из них, пока какая-либо из найденных клеток не окажется целевой. Для восстановления пути в процессе BFS для каждой вершины нужно запомнить ее вершину-родителя. Пример восстановления пути разобран в задаче B.\u003c/p\u003e\u003cp\u003eСоветы по представлению графа: Вершину можно задать парой ее координат, к примеру с помощью структуры pair\u0026lt;int, int\u0026gt;, предварительно переведя букву клетки в числовое представление (int coord \u003d letter — \u0027a\u0027 + 1;). Чтобы не перебирать все восемь вариантов хода вручную, смещения для \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e можно занести в отдельный массив пар, к примеру pair\u0026lt;int, int\u0026gt; shift[] \u003d {{1, 2}, {-1, 2}, {1, -2}, {-1, -2}, {2, 1}, {2, -1}, {-2, 1}, {-2, -1}}. Тогда все координаты, достижимые из текущей вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e можно найти с помощью цикла\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor(int i \u003d 0; i \u0026lt; 8; i++) {\n    pair\u0026lt;int, int\u0026gt; newcoord \u003d {v.first + shift[i].first, v.second + shift[i].second};\n    //проверить, что вершина в пределах доски, и если все хорошо, добавить ее в очередь\n}   \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДлину пути можно считать либо с помощью двумерного массива (тогда d[newcoord.first][newcoord.second] \u003d d[coord.first][coord.second] + 1), либо с помощью ассоциативного массива map\u0026lt;pair\u0026lt;int, int\u0026gt;, int\u0026gt;\u0026gt; (тогда d[newcoord] \u003d d[coord] + 1).\u003c/p\u003e\u003ch1\u003eЗадача F. Расстояние от корня\u003c/h1\u003e\u003cp\u003eПостроить граф по входным данным. Это построение почти аналогично тому, которое описано в задаче A. Запустить DFS или BFS от корня, в процессе сохраняя найденные расстояния. Если из вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e есть ребро в вершину \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, то \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] \u003d \u003ci\u003ed\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e] + 1\u003c/span\u003e. После того, как алгоритм обхода обработал весь граф, необходимо найти в массиве d максимальное значение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emaxd\u003c/i\u003e\u003c/span\u003e, посчитать количество раз, которое оно встречается, вывести эти значения и вывести все такие \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, что \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d \u003ci\u003emaxd\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003ch1\u003eЗадача G. Праздник\u003c/h1\u003e\u003cp\u003eКаждого начальника \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e и каждого подчиненного \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e можно представить как некоторую вершину графа. Граф ориентирован, и все его ребра идут от начальников к подчиненным и имеют вид \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eb\u003c/i\u003e, \u003ci\u003es\u003c/i\u003e)\u003c/span\u003e. Более того, у каждого подчиненного не более одного начальника, поэтому граф является деревом, а точнее лесом, поскольку деревьев может быть несколько. \u003c/p\u003e\u003cp\u003eРассмотрим одно дерево и попытаемся разбить его на некоторое минимальное количество подмножеств так, чтобы ни один начальник не находился в одном подмножестве со своим подчиненным. Корень дерева — главный начальник и все вершины дерева являются его подчиненными. Тогда этого начальника нужно обособить и удалить из дерева. После удаления корня оставшееся дерево распадается на несколько меньших деревьев, каждое из которых также имеет свой корень, который является начальником всего поддерева. Тогда всех начальников этого уровня также нужно оторвать от своих подчиненных. Но начальники одного уровня не связаны между собой никаким отношением, поэтому для уменьшения количества групп их всех можно объединить в одну группу. Таким образом, всех сотрудников, которые находятся на одинаковом расстоянии от корня, можно объединять в одну группу. \u003c/p\u003e\u003cp\u003eОбобщая задачу на несколько деревьев, можно сказать, что всех сотрудников одного уровня (уровень — расстояние от корня) можно определить в одну группу, потому что они никак не связаны друг с другом. Тогда ответом на задачу будет значение, равное расстоянию от корня до максимально удаленной вершины. \u003c/p\u003e\u003cp\u003eДля реализации подходит как поиск в глубину, так и поиск в ширину. \u003c/p\u003e\u003ch1\u003eЗадача H. Новогодняя перестановка\u003c/h1\u003e\u003cp\u003eОсновная идея задачи состоит в том, что если элемент, находящийся на месте \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, можно менять с элементом, находящимся на месте \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, а элемент на месте \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e можно менять с элементом на месте \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, то за некоторое конечное число обменов элемент на месте \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e можно поменять с элементом на месте \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Таким образом, все элементы, прямо или косвенно объединенные, можно менять между собой. Необходимо определить, на какие подмножества, в рамках которых элементы можно менять как угодно, разбивается исходное множество. Это можно сделать, представив все позиции как вершины графа, а отношения, позволяющие прямой обмен, — как ребра графа. После этого с помощью DFS или BFS найти компоненты связности этого графа. \u003c/p\u003e\u003cp\u003eВ рамках одной компоненты связности вершины можно переставлять каким угодно образом, но по условию оптимальным порядком является лексикографически минимальный. Тогда для каждой компоненты связности необходимо переставить элементы, находящиеся на местах, номера которых заданы вершинами графа, в порядке от меньшего к большему. Это можно сделать следующим образом: Все элементы, соответствущие текущей компоненте, выделить в отдельный вектор \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eelems\u003c/i\u003e\u003c/span\u003e и отсортировать его от меньшего к большему. Отсортировать компоненту от меньшего к большему. Расставить элементы на места (нечто вроде \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e[\u003ci\u003ecomp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]] \u003d \u003ci\u003eelems\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e ). Тогда в рамках одной компоненты связности будет соблюдаться условие: чем меньше номер позиции, на которой находится элемент, тем меньше сам элемент. Этот порядок является лексикографически минимальным в рамках только одной компоненты, но поскольку элементы между различными компонентами менять нельзя, лучшего глобального ответа достичь невозможно. \u003c/p\u003e\u003c/div\u003e","tags":[]}}