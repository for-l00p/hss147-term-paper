{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1494855472,"rating":1,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1494945476,"id":52006,"title":"\u003cp\u003eSolutions to Codeforces Beta Round #44, A, B, C, D(Branch and Bound)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA. Triangular numbers\u003c/p\u003e\u003cp\u003eAn integer n is a triangular number if we can find such an integer m that n\u003dm*(m+1)/2. As n is not larger than 500, we can enumerate all integers from 1 to 1000 (not necessarily 1000, for instance 500 is also enough) and check whether we can find such an integer m or not.\u003c/p\u003e\u003cp\u003eB. Coins\u003c/p\u003e\u003cp\u003eIf a team T wins against another one, we can add one point for team T. Thus, for team A, B and C, if they have points with forms of {0,1,2}, the results are not contradictory; otherwise this is impossible.\u003c/p\u003e\u003cp\u003eC. Crossword\u003c/p\u003e\u003cp\u003eA little bit complicated problem for me..\u003c/p\u003e\u003cp\u003eAs there are only 6 words, we can enumerate all the feasible 6!\u003d720 patterns and check if they can form a reasonable crossword puzzle. Without loss of generality, we denote the 6 strings as s[6], and further assume that s[0], s[2], s[4] are parallelly placed while the other three strings are vertically placed. Thus, a reasonable crossword puzzle should satisfy the following several conditions:\u003c/p\u003e\u003cp\u003e1) The total length of s[0] and s[4] is exactly the same as that of s[2], and the total length of s[1] and s[5] is the same as that of s[3] as well;\u003c/p\u003e\u003cp\u003e2) s[0], s[2], s[4] can be connected one by one, i.e., the last letter of the former one is exactly the same as the first letter of the latter one (so as s[1], s[3] and s[5]);\u003c/p\u003e\u003cp\u003e3) The first letters of s[0] and s[1] are the same while the last letters of s[4] and s[5] are the same;\u003c/p\u003e\u003cp\u003e4) The common letters of s[2] and s[3] are the same;\u003c/p\u003e\u003cp\u003eIf all the above conditions can be satisfied, we have obtained a reasonable crossword puzzle, and by storing the lexicographically minimum one, we obtain the answer.\u003c/p\u003e\u003cp\u003eD. Safe\u003c/p\u003e\u003cp\u003eThis problem can be solved by using a tree search algorithm with branch and bound, i.e., only some of the nodes in the tree are visited while the others are not visited by cutting off some branches (or subtrees). \u003c/p\u003e\u003cp\u003eWe actually try to enumerate all the feasible code patterns, whose number is at most 2^35, a huge amount. Specifically, we start from the leftmost position, and for each feasible value (in fact only 0 or 1), we move on to the next position and select one feasible value as well (also 0 or 1) until the rightmost position is determined. At each position, we also check all the given m attempts. For each attempt, if the value is \u0026quot;correct\u0026quot;, we decrease the system\u0027s reponse by 1 while do nothing if it is \u0026quot;incorrect\u0026quot;. Note that if some of the system\u0027s responses are reduced to some negative integers, it means that the current code pattern, although there may still exist several positions that have not been enumerated, can definitely not be a feasible one since contradictions have been observed. Therefore, the current enumeration can be immediately terminated. In fact, the enumeration of code patterns can be viewed as a search in a complete binary tree with 2^n leaf nodes, and these leaf nodes just correspond to all the candidate code patterns. The termination mentioned above is equivalent to cutting off branches when we are implementing search in the binary tree, so that we can avoid visiting some of the leaf nodes and possibly some intermediate nodes. As a result, the complexity may be less than 2^n. \u003c/p\u003e\u003cp\u003eThe complexity for the worst case is difficult to analyze, since the cutting off of branches is an implicit process and it depends on the specific structures of each attempt. However, for each attempt, due to its constraints on the code patterns, at most C(n,k) ones are feasible, where C(n,k) means n!/(n-k)!/k!. Therefore, we have at most m*C(n,k)\u0026lt;\u003d10*C(35,6) code patterns that can serve as feasible ones. Intuitively, this implies that the complexity may be about 10*C(35,6), however this is just my guess... The solution based on this idea has been accepted, so I think that at least the test cases are not \u0026quot;difficult\u0026quot; ones for such a solution, but I cannot guarantee that there exist no test cases that this solution will fail or give a \u0026quot;Time Limited Error\u0026quot;.\u003c/p\u003e\u003c/div\u003e","tags":[]}}