{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1501415690,"rating":0,"authorHandle":"Light","modificationTimeSeconds":1501415690,"id":53559,"title":"\u003cp\u003eWeek 2 Discussion\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello everyone, hope you\u0027re training well! :D\u003c/p\u003e\u003cp\u003eFirst thing we learned about was vectors, defined as: \u003ccode\u003evector\u0026lt;data type\u0026gt; name;\u003c/code\u003e, you can read more about vectors here: \u003ca href\u003d\"http://www.cplusplus.com/reference/vector/vector/\"\u003ehttp://www.cplusplus.com/reference/vector/vector/\u003c/a\u003e\u003c/p\u003e \u003cul\u003e   \u003cli\u003eThen we took a problem about finding the K\u0027th smallest number in an array, in which we found that it\u0027s best solved by sorting the array first, and then checking the K-1\u0027th index in the array.\u003c/li\u003e \u003c/ul\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\nusing namespace std;\nint n, q, A[100001];\nvector\u0026lt;int\u0026gt; B;\nint main(){\n\tcin\u0026gt;\u0026gt;n;\n\tfor(int x,i\u003d0; i\u0026lt;n; ++i){\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;x);\n\t\tA[i]\u003dx;\n\t\tB.push_back(x);\n\t}\n\tsort(A, A+n);\n\tsort(B.begin(), B.end());\n\tcin\u0026gt;\u0026gt;q;\n\tfor(int x,i\u003d0; i\u0026lt;q; ++i){\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;x);\n\t\tprintf(\u0026quot;Smallest Element #%d \u003d %d\\n\u0026quot;, x, A[x-1]); //or B[x-1]\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eYou can read more about the \u0026quot;sort\u0026quot; function from here: \u003ca href\u003d\"http://www.cplusplus.com/reference/algorithm/sort/\"\u003ehttp://www.cplusplus.com/reference/algorithm/sort/\u003c/a\u003e\u003c/p\u003e \u003cul\u003e   \u003cli\u003eNext thing was finding if two given strings are Anagrams (same words but rearranged letters), we\u0027ve found an O(n^2) solution which connects each letter in the first string with a corresponding one in the second string. Then, we\u0027ve found an even better O(nlogn) solution that works by sorting both the strings and comparing if they\u0027re equal (try it out!). Then at last, we\u0027ve found an even better O(n) solution that works by counting the frequency of each character in both strings, and comparing them. (Anagrams should have an equal frequency for all characters)\u003c/li\u003e \u003c/ul\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string\u0026gt;\nusing namespace std;\nint frequency1[128], frequency2[128];\nstring a,b;\n\nint main(){\n\tcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\n\tfor(int i\u003d0; i\u0026lt;a.size(); ++i)\n\t\t++frequency1[a[i]];\n\n\tfor(int i\u003d0; i\u0026lt;b.size(); ++i)\n\t\t++frequency2[b[i]];\n\t\n\tfor(int i\u003d0; i\u0026lt;128; ++i)\n\t\tif(frequency1[i] !\u003d frequency2[i]){\n\t\t\tcout\u0026lt;\u0026lt;\u0026quot;NO\\n\u0026quot;;\n\t\t\treturn 0;\n\t\t}\n\tcout\u0026lt;\u0026lt;\u0026quot;YES\\n\u0026quot;;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cul\u003e   \u003cli\u003eThen we\u0027ve solved a few other problems (I\u0027ve added a new contest of them check it out!), the one problem I wanna discuss was !Hasan. It was about Moath and Saif wanting to prepare PCs for the next programming contest, given that Moath takes X minutes to prepare one PC, and Saif takes Y minutes to prepare one PC, what is the \u003cstrong\u003eminimum\u003c/strong\u003e time needed to prepare N PCs?\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eAs we said in class, the key to this problem is the fact that: if I can\u0027t prepare the PCs in X minutes, then for sure I can\u0027t do it in less than X minutes. And if I can prepare the PCs in X minutes, then for sure I can do it in more than X minutes.\u003c/p\u003e\u003cp\u003eThis observation leads us that we can use Binary Search to find the correct answer, in which we first have a big range of possible solutions, but in each iteration we erase half of the range by the observation I mentioned above. Such solution takes no more than O(logn) which is really small even for really big numbers.\u003c/p\u003e\u003cp\u003e(An exercise is to try implementing it yourself before checking the code)\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string\u0026gt;\nusing namespace std;\nlong long n,x,y;\n\nbool can(long long tm){\n\tlong long num \u003d tm/x + tm/y;\n\tif(num\u0026gt;\u003dn)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\nint main(){\n\tcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\n\tlong long lo\u003d1, hi\u003d1e18, md, bst\u003d1e18;\n\twhile(lo\u0026lt;\u003dhi){\n\t\tmd\u003d(lo+hi)/2;\n\t\tif(can(md)){\n\t\t\tbst\u003dmd;\n\t\t\thi\u003dmd-1;\n\t\t}else\n\t\t\tlo\u003dmd+1;\n\t}\n\tcout\u0026lt;\u0026lt;bst\u0026lt;\u0026lt;endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eYou can read more about Binary Search from here:\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://www.topcoder.com/community/data-science/data-science-tutorials/binary-search/\"\u003ehttps://www.topcoder.com/community/data-science/data-science-tutorials/binary-search/\u003c/a\u003e\u003c/p\u003e\u003cp\u003eYou can read more about Complexity Analysis from here:\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://www.topcoder.com/community/data-science/data-science-tutorials/computational-complexity-section-1/\"\u003ehttps://www.topcoder.com/community/data-science/data-science-tutorials/computational-complexity-section-1/\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThat\u0027s all! Please remember to try solving all the problems we have in the group, and participate in every contest you can from: \u003ca href\u003d\"//codeforces.com/contests\"\u003ehttp://codeforces.com/contests\u003c/a\u003e \u003c/p\u003e\u003cp\u003eAnd if you have any question please send me a private message here on Codeforces and I will help you :D Good luck.\u003c/p\u003e\u003c/div\u003e","tags":[]}}