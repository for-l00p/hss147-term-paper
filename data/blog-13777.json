{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1410629921,"rating":55,"authorHandle":"Nickolas","modificationTimeSeconds":1410635731,"id":13777,"title":"\u003cp\u003eSurprise Language Round #7: editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/470/problem/A\" title\u003d\"Surprise Language Round 7\"\u003e470A - Crystal Ball Sequence\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eAs usual, the first problem tests competitors\u0027 ability to do basic math, and in this case it is even easier than the sample — without any loops.\u003c/p\u003e \u003cpre\u003e^\u00270-\n$ 1+*3*1+.\u003c/pre\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/470/problem/B\" title\u003d\"Surprise Language Round 7\"\u003e470B - Hexakosioihexekontahexaphobia\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eThis problem uses more advanced language concepts — loop, conditional execution and even named variables! Variables are convenient to use as loop counters and result accumulators, so as to avoid stack manipulations for the same purpose. An if-then-else in FALSE looks like this:\u003c/p\u003e \u003cpre\u003e(true/false condition on top of stack) $ \n    [(then statements)] ?\n  ~ [(else statements)] ?\u003c/pre\u003e\u003cp\u003eSolution:\u003c/p\u003e \u003cpre\u003e0n:    {number of 6s found uninterrupted so far}\n0r:    {true, if 666 found}\n[^$ 1_\u003d~]\n[ \u00276\u003d $ [n; 1+ n:] ?\n      ~ [0n:] ?\n  n; 2 \u0026gt; r; | r: \n]\n#\n%\nr; $ [\u0026quot;YES\u0026quot;] ?\n   ~ [\u0026quot;NO\u0026quot;] ?\u003c/pre\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/470/problem/C\" title\u003d\"Surprise Language Round 7\"\u003e470C - Eval\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eThis problem can be solved in two ways. You could read numbers, store them to named variables and depending on the operator use one of the operations on them. Or else you could do the other way around, store necessary operation as a function into a named variable (FALSE allows to store functions as variables) and apply it to numbers stored in stack. Here is the code of the second approach:\u003c/p\u003e \u003cpre\u003e[0[^ $$ 47\u0026gt; \\58\\\u0026gt; \u0026amp;][\u00270- \\ 10*+]#]\nr:\n\nr;!\n\n$\u0027+\u003d[[+]f:]?\n$\u0027-\u003d[[-]f:]?\n$\u0027*\u003d[[*]f:]?\n$\u0027/\u003d[[/]f:]?\n$\u0027%\u003d[[\\$@$@\\/*-]f:]?\n%\n\nr;!\n%\nf;!.\u003c/pre\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/470/problem/D\" title\u003d\"Surprise Language Round 7\"\u003e470D - Caesar Cipher\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eThis problem combines elements of previous problems: reading long int, reading a string and doing modulo operation (could be replaced with conditional subtraction).\u003c/p\u003e \u003cpre\u003e0[^ $$ 47\u0026gt; \\58\\\u0026gt; \u0026amp;][\u00270- \\ 10*+]#% k:   {read the key}\n\n[^$ 10\u003d~]\n[ \u0027A- k;+ $ 25\u0026gt; [26-] ? \u0027A+ ,]\n#%\u003c/pre\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/470/problem/E\" title\u003d\"Surprise Language Round 7\"\u003e470E - Chessboard\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eAll of a sudden this problem turned out to be easier than C and D; probably a double-for loop is more simple than reading till end of line, especially with all the confusion with ends of line :-)\u003c/p\u003e \u003cpre\u003e0[^ $$ 47\u0026gt; \\58\\\u0026gt; \u0026amp;][\u00270- \\ 10*+]#%\nn:\n\n[\\ $ @ $ @\\/*-]\np:\n\n0i:\n[n;i;\u0026gt;]\n[0j:\n [n;j;\u0026gt;]\n [j;i;+ 2p;!\n  11* 46 \\- ,\n  j;1+j:]\n #\n\u0026quot;\n\u0026quot;\ni;1+i:]\n#\u003c/pre\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/470/problem/F\" title\u003d\"Surprise Language Round 7\"\u003e470F - Pairwise Sums\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eNext two problems use a new language construct — operator ø (a.k.a. O, not to be confused with 0), which allows random read access to stack elements. To calculate pairwise sums, one had to first read all array elements into the stak, then calculate indices of necessary elements, read them and add them up.\u003c/p\u003e \u003cpre\u003e[0[^ $$ 47\u0026gt; \\58\\\u0026gt; \u0026amp;][\u00270- \\ 10*+]#%] r:\n\nr;! n:   {read the number of elements in array}\n\n0i:\n[n;i;\u0026gt;]\n[r;! i;1+i:]\n#        {read the elements of the array}\n\n0i:\n[n;i;\u0026gt;]\n[$ n;O + . \u0026quot; \u0026quot; n;1-O i;1+i:]\n#\n\n0i:\n[n;2*i;\u0026gt;]\n[% i;1+i:]\n#\u003c/pre\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/470/problem/G\" title\u003d\"Surprise Language Round 7\"\u003e470G - Hamming Distance\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eSame principle as in the previous problem — read characters of two strings into the stack (store the length of the strings into a named variable), then extract pairs of corresponding characters from it and accumulate the result in another named variable.\u003c/p\u003e \u003cpre\u003e0n:\n[^ $ 10\u003d~]\n[n;1+n:]\n#%\n\n[^ $ 1_\u003d~]\n[]\n#%\n\n0i:\n0d:\n[n;i;\u0026gt;]\n[n;i;-1- O\n n;n;+i;- O\n \u003d~ [d;1+d:] ?\n i;1+i:]\n#\n\n0i:\n[n;2*i;\u0026gt;]\n[% i;1+i:]\n#\n\nd;. \u003c/pre\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/470/problem/H\" title\u003d\"Surprise Language Round 7\"\u003e470H - Array Sorting\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eSame as the regular sorting task, this problem can be solved in many ways.\u003c/p\u003e\u003cp\u003eYou could write a \u0026quot;simple counting sort\u0026quot;, as recommended by \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Egor\" title\u003d\"Grandmaster Egor\"\u003eEgor\u003c/a\u003e: do an outer loop from 1 to 100, in the inner loop iterate over all array elements and print each element that equals the counter of the outer loop. Here is the \u003ca href\u003d\"http://codeforces.ru/contest/470/submission/7786917\"\u003ecode\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eOr you could store array elements in named variables (since there are very few of them) and generate a code which would compare pairs of variables and swap them if needed. Thus, instead of a[0] you use variable a, instead of a[1] — b etc. The first such solution I\u0027ve seen was \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/nab\" title\u003d\"Candidate Master nab\"\u003enab\u003c/a\u003e\u0027s: \u003ca href\u003d\"http://codeforces.ru/contest/470/submission/7786384\"\u003ethe code\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eI chose yet another approach: read array elements into a stack and use selection sort, but each time you need a swap, copy the whole array (with elements swapped already) onto the top of the stack. After at most n swaps the top of the stack will hold a sorted array. Unfortunately, stack size is limited, and with n around 20 it overflows. So I reduced array size a lot, which also allowed other approaches :-)\u003c/p\u003e \u003cpre\u003e[0[^ $$ 47\u0026gt; \\58\\\u0026gt; \u0026amp;][\u00270- \\ 10*+]#%] r:\n\nr;! n:   {read the number of elements in array}\n\n0i:\n[n;i;\u0026gt;]\n[r;! i;1+i:]\n#        {read the elements of the array}\n\n1s:      {# of array copies stored in memory}\n\n0i:\n[n;1-i;\u0026gt;]\n[ i;m:          {index of min element between i and n-1, inclusive}\n  i;1+j:\n  [n;j;\u0026gt;]\n  [ n;m;-1- O   {extract a[m]}\n    n;j;- O     {extract a[j], knowing that a[m] is on top}\n    \u0026gt;\n    [j;m:] ?    {if a[j] \u0026gt; a[m], m :\u003d j}\n    j;1+j:\n  ]#\n\n  i;m;\u003d~\n  [ 0k:\n    [n;k;\u0026gt;]\n    [ k;e:     {index of element we\u0027re extracting now}\n      k;i;\u003d\n         [m;e:] ?\n      k;m;\u003d\n         [i;e:] ?\n      n;k;+e;-1- O\n      k;1+k:\n    ]#\n    s;1+s:      {+1 copy of array in memory}\n  ] ?           {if i !\u003d m, copy all elements, while swapping a[i] and a[m]}\n   \n  i;1+i:]\n#\n\n0i:\n[n;i;\u0026gt;]\n[n;i;-1- O . \u0026quot; \u0026quot;\n i;1+i:]\n#\n\n0i:\n[n;s;*i;\u0026gt;]\n[% i;1+i:]\n#\u003c/pre\u003e\u003c/div\u003e","tags":["surprise language round","unknown language round"]}}