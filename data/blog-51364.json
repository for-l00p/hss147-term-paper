{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1491038827,"rating":0,"authorHandle":"TripleM5da","modificationTimeSeconds":1491038879,"id":51364,"title":"\u003cp\u003eFloyd–Warshall\u0027s Algorithm Fe Capsule.\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eFloyd–Warshall\u0027s Algorithm is used to find the shortest paths between between all pairs of nodes in a graph where each edge in a graph has a weight the biggest advantage for using this algorithm is that it uses \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e memory and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e time to compute all shortest paths.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eHow it actually works\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eFor a graph with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e nodes.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003einitialize a \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e array where all it\u0027s elements are equal to infinity (aka. a very large value).\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eFind all pairs of shortest paths that use 0 intermediate nodes, then the ones that uses 1 node the 2 nodes and 2 so on.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eMinimize the shortest paths between any 2 pairs in the previous operation.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eFor any 2 nodes \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e one should minimize the distance between this pair using the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e nodes so the shortest path will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edist\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e \u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003edist\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e], \u003ci\u003edist\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e] + \u003ci\u003edist\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e])\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eWhere \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edist\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e represents the shortest path that only uses the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e nodes, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edist\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e represents the shortest path between the pair of nodes \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e, will the shortest path will be the shortest path from i to k and from k to j.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eImplementation\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003efor(int k \u003d 1; k \u0026lt;\u003d n; k++) {\n\n    for(int i \u003d 1; i \u0026lt;\u003d n; i++) {\n\n        for(int j \u003d 1; j \u0026lt;\u003d n; j++) {\n\n            dist[i][j] \u003d min( dist[i][j], dist[i][k] + dist[k][j] );\n        }\n    }\n}\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}