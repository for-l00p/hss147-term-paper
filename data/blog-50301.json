{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1486468730,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1486468730,"id":50301,"title":"\u003cp\u003eСтруктура простой программы на Java\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eВ \u003ca href\u003d\"//codeforces.com/group/BGHKBS1Kvt/blog/entry/2080\"\u003eпредыдущей записи\u003c/a\u003e рассказывалось, как создать простейшую программу на Java в среде Eclipse. Посмотрим на эту программу внимательно и проанализируем её составляющие. \u003c/p\u003e\u003cp\u003e\u003cem\u003eСразу скажем, что этот анализ будет совершенно неформальным и не придерживающимся строгости определений и описаний. Его цель — обрисовать структуру программы на Java в самых общих чертах.\u003c/em\u003e \u003cbr /\u003e \u003cbr /\u003e Напомним, что наша первая программа считывала с клавиатуры два вещественных числа, складывала их и выводила результат на экран. Также приведём ещё раз текст этой программы, в котором для удобства занумерованы строки.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e01\tpackage first;\n02\t\n03\timport java.util.Locale;\n04\timport java.util.Scanner;\n05\t\n06\tpublic class AplusB {\n07\t\n08\t\tpublic static void main(String[] args) {\n09\t\t\tABSumma absum \u003d new ABSumma();\n10\t\t\tabsum.solve();\n11\t\t\tabsum.print();\n12\t\t}\n13\t\n14\t}\n15\t\n16\tclass ABSumma {\n17\t\n18\t\tABSumma() {\n19\t\t\tScanner in \u003d new Scanner(System.in);\n20\t\t\tin.useLocale(Locale.US);\n21\t\t\ta \u003d in.nextDouble();\n22\t\t\tb \u003d in.nextDouble();\n23\t\t\tin.close();\n24\t\t}\n25\t\n26\t\tdouble sum(double x, double y) {\n27\t\t\tdouble res \u003d x + y; \n28\t\t\treturn res;\n29\t\t}\n30\t\n31\t\tvoid solve() {\t\t\n32\t\t\ts \u003d sum(a, b);\n33\t\t}\n34\t\n35\t\tvoid print() {\n36\t\t\tSystem.out.println(s);\n37\t\t}\n38\t\n39\t\tdouble a;\n40\t\tdouble b;\n41\t\tdouble s;\n42\t}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e1\u003c/strong\u003e. В строке 01 указано имя пакета. Пакет можно считать структурной единицей, способной содержать один или несколько Java-классов. Эти классы могут находиться как в одном, так и в нескольких файлах. Также пакеты могут содержать другие пакеты.\u003c/p\u003e\u003cp\u003eГруппировка классов в пакеты решает несколько задач. \u003cbr /\u003e Во-первых, как правило, в пакет объединяются классы, которые имеют некоторое общее «логическое» назначение. Например, в одном пакете могут содержаться составляющие какого-то большого проекта. Также в один пакет могут быть объединены классы, обеспечивающие реализацию каких-либо сходных действий. Примером тому являются пакеты java.io (классы, организующие ввод / вывод), javax.swing (классы, содержащие иерархию платформенно-независимых компонентов для графического интерфейса пользователя) и ряд других. \u003cbr /\u003e Во-вторых, пакеты избавляют программиста от забот об уникальности имён классов: полное имя каждого класса начинается с имени пакета, а уникальность имени пакета обеспечить значительно проще. Можно сказать, что пакеты обеспечивают пространства имён: в одном пространстве все имена должны быть уникальны, а в разных пространствах они могут быть совпадающими (с точностью до имени пакета). \u003c/p\u003e\u003cp\u003eПример обращения к классу, находящемуся в пакете, мы можем видеть в строках 03 и 04. Эти строки являются предложениями импорта, весьма простыми по своей структуре: сначала пишется зарезервированное слово \u003ccode\u003eimport\u003c/code\u003e, а затем — имя класса, который нужно использовать в программе. В данном случае имя класса указано полностью, начиная с имени пакета, который его содержит. Этот пакет входит в JDK, так что виртуальная машина уже \u0026quot;знает\u0026quot;, где его искать. Предложение импорта может иметь и другой вид; мы обсудим этот вопрос, как только в этом возникнет потребность. В ближайшее время Вы можете вполне доверять механизму завершения ввода в Eclipse, который автоматически дописывает предложение импорта в Вашу программу.\u003c/p\u003e\u003cp\u003eКак уже говорилось, можно не определять пакет для Вашей программы — в этом случае Java включает класс в так называемый пакет по умолчанию (default package). Нужно помнить, что все классы рабочей области среды, которые не включены в собственный пакет, будут включаться в один и тот же пакет по умолчанию. Это далеко не всегда удобно. \u003c/p\u003e\u003cp\u003eВместе с тем есть довод «за» использование пакета по умолчанию — многие проверяющие системы (в частности, те, которые используются на Codeforces, на Timus) требуют, чтобы программы на Java, отправляемые на проверку, не использовали собственный пакет. Чтобы Ваша программа была помещена в пакет по умолчанию, нужно при создании класса (п.4 в первой записи) не указывать никакого имени пакета (в строке Package; если же это поле диалогового окна оказалось автоматически заполненным — то очистить его). \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2\u003c/strong\u003e. Строки с 06 по 14 содержат описание класса \u003ccode\u003eAplusB\u003c/code\u003e, а строки с 16 по 42 — описание класса \u003ccode\u003eABSumma\u003c/code\u003e. Класс — это основная структурная единица языка Java. Можно сказать, что класс — это совокупность некоторых данных (именуемых полями) и методов их обработки. Никакие данные и методы не могут существовать вне классов. \u003c/p\u003e\u003cp\u003e\u003cem\u003eКонечно, если в том есть необходимость, методы могут обрабатывать и данные, не принадлежащие классу. Классы, фактически, тоже вносят свою лепту в реализацию пространств имён: внутри класса имена обязаны быть уникальными, но в разных классах могут содержаться методы и данные с одинаковыми именами.\u003c/em\u003e \u003c/p\u003e\u003cp\u003eСами по себе классы являются в некотором смысле «схемами», «чертежами», по которым создаются объекты — экземпляры этих классов. Данные внутри каждого объекта считаются уникальными, характеризующими этот конкретный объект. Не очень часто, но возникает необходимость включать в состав класса какие-то данные, которые не меняются от объекта к объекту. Например, число \u003cspan class\u003d\"tex-span\"\u003eπ\u003c/span\u003e включено в состав класса \u003ccode\u003ejava.lang.Math\u003c/code\u003e (и обозначено в нём \u003ccode\u003ePI\u003c/code\u003e). \u003c/p\u003e\u003cp\u003eМетоды, входящие в состав класса, можно классифицировать по-разному, и в том числе по их «отношению» к данным. Если метод обращается только к данным, которые не меняются от объекта к объекту, то нет необходимости создавать экземпляр объекта для вызова этого метода. В случае же, когда метод обращается к данным, характеризующим конкретный объект, обязательно нужно создать объект и лишь потом вызывать из этого объекта этот метод. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e3\u003c/strong\u003e. Обратите внимание, что класс \u003ccode\u003eAplusB\u003c/code\u003e объявлен с модификатором \u003cstrong\u003epublic\u003c/strong\u003e (строка 06), а у класса \u003ccode\u003eABSumma\u003c/code\u003e такого модификатора нет. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e06\tpublic class AplusB {\n...\n\n16\tclass ABSumma {\n...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ каждом файле может быть и должен быть ровно один класс, объявленный с модификатором \u003cstrong\u003epublic\u003c/strong\u003e. Имя этого класса должно в точности совпадать с именем файла, в котором этот класс содержится.\u003c/p\u003e\u003cp\u003eТакже в файле может содержаться сколько угодно классов, не имеющих модификатора \u003cstrong\u003epublic\u003c/strong\u003e (в том числе их может и не быть в файле вовсе). \u003cbr /\u003e Важно то, что при обращении к пакету доступны будут только \u003cstrong\u003epublic\u003c/strong\u003e-классы; все остальные классы пакета решают вспомогательные задачи (таким образом можно, к примеру, скрыть реализацию каких-то методов, которая в дальнейшем может быть пересмотрена). \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e4\u003c/strong\u003e. Строка 08 содержит объявление специального метода \u003ccode\u003emain()\u003c/code\u003e. \u003c/p\u003e\u003cp\u003e\u003cem\u003eЗдесь и далее мы всегда будем писать после имени метода круглые скобки, чтобы визуально отличать имя метода от имени переменной или класса. Параметры в скобках будут указываться лишь тогда, когда нужно избежать двусмысленности и т.п.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eЭтот метод позволяет виртуальной машине Java (JVM, Java Virtual Machine) запускать Вашу программу на выполнение.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e08\t\tpublic static void main(String[] args) {\n...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗаголовок этого метода (если более точно, сигнатура — т. е. заголовок вкупе со списком параметров) предопределён и не может меняться: JVM будет отыскивать в Вашей программе именно этот заголовок (мы не говорим об апплетах), после чего будет исполнять то, что записано в теле этого метода, в том порядке, в котором это записано. В частности, в нашем случае в теле метода \u003ccode\u003emain()\u003c/code\u003e записаны три действия: создать объект класса \u003ccode\u003eABSumma\u003c/code\u003e с именем \u003ccode\u003eabsum\u003c/code\u003e, вызвать метод \u003ccode\u003esolve()\u003c/code\u003e этого объекта, а затем вызвать метод \u003ccode\u003eprint()\u003c/code\u003e этого объекта (вызовом метода называют обращение к этому методу).\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e08\t\tpublic static void main(String[] args) {\n09\t\t\tABSumma absum \u003d new ABSumma();\n10\t\t\tabsum.solve();\n11\t\t\tabsum.print();\n12\t\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНо, прежде чем обсуждать, что произойдет при выполнении этих действий, скажем ещё несколько слов про метод \u003ccode\u003emain()\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eВо-первых, он может быть помещён в класс с любым именем (причём необязательно даже, чтобы этот класс имел модификатор \u003cstrong\u003epublic\u003c/strong\u003e, но пока мы не будем обсуждать такие тонкости). \u003c/p\u003e\u003cp\u003eВо-вторых, он имеет модификатор \u003cstrong\u003epublic\u003c/strong\u003e — это делает его доступным «вне собственного пакета» (в том числе доступным для JVM). \u003c/p\u003e\u003cp\u003eВ третьих, он помечен как \u003cstrong\u003estatic\u003c/strong\u003e — и это значит, что он может вызываться без создания экземпляра класса, в который он помещён. \u003c/p\u003e\u003cp\u003e\u003cem\u003eВероятно, здесь нужно более подробное пояснение. \u003cbr /\u003e Чуть выше мы говорили, что если метод обращается только к данным, которые не меняются от объекта к объекту (или не обращается вовсе ни к каким данным), то нет необходимости создавать для вызова этого метода объект. Такие методы могут быть помечены модификатором \u003cstrong\u003estatic\u003c/strong\u003e. Если Вы попытаетесь внутри \u003cstrong\u003estatic\u003c/strong\u003e-метода обратиться к каким-либо данным, которые зависят от объекта, среда разработки (Eclipse, да и любая другая) сообщит Вам об ошибке. \u003cbr /\u003e В нашем случае всё выглядит достаточно просто: в классе \u003ccode\u003eAplusB\u003c/code\u003e вообще не объявлены никакие поля, так что он содержит единственный метод \u003ccode\u003emain()\u003c/code\u003e. Вся «содержательная логика» программы вынесена в класс \u003ccode\u003eABSumma\u003c/code\u003e, экземпляр которого создается внутри \u003ccode\u003emain()\u003c/code\u003e и над которым опять же внутри \u003ccode\u003emain()\u003c/code\u003e выполняются какие-то действия.\u003c/em\u003e \u003c/p\u003e\u003cp\u003eВ-четвёртых, перед именем метода \u003ccode\u003emain()\u003c/code\u003e указан тип \u003cstrong\u003evoid\u003c/strong\u003e. Вы уже знакомы с этим типом и знаете, что метод такого типа не возвращает никакого значения (т. е. просто выполняет свою работу). \u003c/p\u003e\u003cp\u003eНаконец, \u003ccode\u003emain()\u003c/code\u003e — это имя метода, а \u003ccode\u003eString[] args\u003c/code\u003e — список параметров, которые этот метод может «принимать извне». Поскольку этот метод «общается» с JVM, то и параметры в него могут попадать при вызове исполняющейся программы в командной строке. Эти параметры имеют самый общий вид — массив строк (массив здесь следует понимать как индексированный список строк). Разумеется, передавать какие-либо параметры в метод \u003ccode\u003emain()\u003c/code\u003e совершенно не обязательно (разве что этого потребует логика программы, но в ближайшее время мы с такими программами не столкнёмся). \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e5\u003c/strong\u003e. Теперь посмотрим внимательно на класс \u003ccode\u003eABSumma\u003c/code\u003e. В строках 39 — 41 содержатся описания трёх полей этого класса — вещественных переменных \u003ccode\u003ea\u003c/code\u003e, \u003ccode\u003eb\u003c/code\u003e и \u003ccode\u003es\u003c/code\u003e. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e39\t\tdouble a;\n40\t\tdouble b;\n41\t\tdouble s;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНикаких других данных этот класс не содержит. Однако он содержит четыре метода. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e6\u003c/strong\u003e. Первый из них — конструктор. Конструктор класса всегда называется так же, как и сам класс. \u003c/p\u003e\u003cp\u003e\u003cem\u003eУ одного класса может быть несколько конструкторов, но в этом случае они должны отличаться списком параметров. Вообще говоря, можно и не описывать никаких конструкторов в классе — в этом случае создание экземпляра такого класса обеспечит конструктор класса Object, который является предком по отношению к любому классу Java. Однако чаще всего есть действия, которые имеет смысл выполнить именно в конструкторе.\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e18\t\tABSumma() {\n19\t\t\tScanner in \u003d new Scanner(System.in);\n20\t\t\tin.useLocale(Locale.US);\n21\t\t\ta \u003d in.nextDouble();\n22\t\t\tb \u003d in.nextDouble();\n23\t\t\tin.close();\n24\t\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПодробное описание того, что происходит в конструкторе, Вы можете найти в п.8 предыдущей записи. Здесь же мы кратко скажем, что конструктор решает задачу инициализации (установки начальных значений) для полей \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e посредством чтения соответствующих значений со стандартного потока ввода (клавиатуры). \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e7\u003c/strong\u003e. Метод \u003ccode\u003esum()\u003c/code\u003e класса \u003ccode\u003eABSumma\u003c/code\u003e возвращает вещественное значение, равное сумме значений \u003ccode\u003ex\u003c/code\u003e и \u003ccode\u003ey\u003c/code\u003e, которые должны быть переданы в этот метод. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e26\t\tdouble sum(double x, double y) {\n27\t\t\tdouble res \u003d x + y; \n28\t\t\treturn res;\n29\t\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбратите внимание, что этот метод имеет два параметра; кроме того, в нём объявлена переменная \u003ccode\u003eres\u003c/code\u003e, которая существует только внутри него. Вы не можете обратиться к этой переменной из другого метода, однако в другом методе Вы можете объявить \u003cem\u003eдругую\u003c/em\u003e переменную с \u003cem\u003eтаким же\u003c/em\u003e именем (если Вы подумали о концепции пространств имён, Вы совершенно правы). \u003cbr /\u003e Поскольку метод имеет тип \u003cem\u003edouble\u003c/em\u003e, то он обязан вернуть (по завершении своего выполнения) некоторое вещественное число. Именно это и происходит в строке 28: оператор \u003ccode\u003ereturn\u003c/code\u003e указывает, что именно должно быть возвращено в качестве результата выполнения метода. \u003c/p\u003e\u003cp\u003eЗаметим, что оператор \u003ccode\u003ereturn\u003c/code\u003e действует «немедленно»; если после него будут записаны ещё какие-либо операторы, они никогда не будут выполнены — как только в ходе выполнения метода произойдёт обращение к оператору \u003ccode\u003ereturn\u003c/code\u003e, выполнение метода будет прервано.\u003c/p\u003e\u003cp\u003e\u003cem\u003eВообще говоря, оператор \u003ccode\u003ereturn\u003c/code\u003e без операнда (значения, которое следует возвратить) может использоваться и в \u003cstrong\u003evoid\u003c/strong\u003e-методах, если в этом есть необходимость.\u003c/em\u003e \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e8\u003c/strong\u003e. У метода \u003ccode\u003esolve()\u003c/code\u003e нет параметров и он не возвращает какого-либо значения. Он обращается к полям \u003ccode\u003ea\u003c/code\u003e, \u003ccode\u003eb\u003c/code\u003e и \u003ccode\u003es\u003c/code\u003e, которые описаны в классе \u003ccode\u003eABSumma\u003c/code\u003e. Эти данные не требуют дополнительной передачи в метод: поскольку они принадлежат тому же классу, что и метод, он он них \u0026quot;знает\u0026quot;.\u003c/p\u003e\u003cp\u003eВ методе \u003ccode\u003esolve()\u003c/code\u003e происходит вызов метода \u003ccode\u003esum()\u003c/code\u003e, в который передаются в качестве фактических значений его параметров значения полей \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e, а результат вычислений, проведённых методом \u003ccode\u003esum()\u003c/code\u003e, записывается в поле \u003ccode\u003es\u003c/code\u003e. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e9\u003c/strong\u003e. Наконец, в методе \u003ccode\u003eprint()\u003c/code\u003e, который отвечает за печать результата, происходит обращение к стандартному потоку вывода, с помощью метода \u003ccode\u003eprintln()\u003c/code\u003e которого выводится значение поля \u003ccode\u003es\u003c/code\u003e. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e35\t\tvoid print() {\n36\t\t\tSystem.out.println(s);\n37\t\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e10\u003c/strong\u003e. Теперь «соберём» всё вместе — вернёмся к методу \u003ccode\u003emain()\u003c/code\u003e класса \u003ccode\u003eAplusB\u003c/code\u003e. \u003cbr /\u003e Как мы уже говорили, в первой строке тела метода (строка 09) происходит создание экземпляра класса \u003ccode\u003eABSumma\u003c/code\u003e, который назван \u003ccode\u003eabsum\u003c/code\u003e. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e08\t\tpublic static void main(String[] args) {\n09\t\t\tABSumma absum \u003d new ABSumma();\n10\t\t\tabsum.solve();\n11\t\t\tabsum.print();\n12\t\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЭто делается при помощи оператора \u003ccode\u003enew\u003c/code\u003e, за которым следует обращение к конструктору класса \u003ccode\u003eABSumma\u003c/code\u003e. Вызов конструктора приводит к обращению к строкам 19 — 23 (выполняется код, записанный в них). \u003cbr /\u003e Далее, в строке 10 вызывается метод \u003ccode\u003esolve()\u003c/code\u003e объекта \u003ccode\u003eabsum\u003c/code\u003e. Он выполняет код, записанный в строке 32, что, в свою очередь, приводит к обращению к коду, записанному в строках 27 — 28. В результате работы этого кода своё значение обретает поле \u003ccode\u003es\u003c/code\u003e. \u003cbr /\u003e Затем в строке 11 вызывается метод \u003ccode\u003eprint()\u003c/code\u003e объекта \u003ccode\u003eabsum\u003c/code\u003e. Этот вызов приводит к обращению к строке 36. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eЗавершение выполнения метода \u003ccode\u003eprint()\u003c/code\u003e, который является последним, вызванным в методе \u003ccode\u003emain()\u003c/code\u003e, означает и завершение выполнения программы. \u003c/p\u003e\u003cp\u003eЗаметим, что такая реализация — не единственно возможная; ниже мы покажем, как можно изменить класс \u003ccode\u003eABSumma\u003c/code\u003e. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e11\u003c/strong\u003e. А сейчас продемонстрируем, как можно было ещё написать эту программу. Мы оставим прежним наименование пакета, а вместо классов \u003ccode\u003eAplusB\u003c/code\u003e и \u003ccode\u003eABSumma\u003c/code\u003e напишем классы \u003ccode\u003eAplusB2\u003c/code\u003e и \u003ccode\u003eABSumma2\u003c/code\u003e (Вы можете создать новый класс в пакете \u003ccode\u003efirst\u003c/code\u003e, назвать его \u003ccode\u003eAplusB2\u003c/code\u003e и воспроизвести этот код):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e01\tpackage first;\n02\n03      import java.util.Locale;\n04      import java.util.Scanner;\n05\n06\tpublic class AplusB2 {\n07\n08\t\tpublic static void main(String[] args) {\n09\t\t\tABsumma2 absum \u003d new ABSumma2();\n10\t\t\tabsum.solve();\n11\t\t\tabsum.print();\n12\t\t}\n13\n14\t}\n15\n16\tclass ABsumma2 {\n17\n18\t\tABsumma2() {\n19\t\t\tScanner in \u003d new Scanner(System.in);\n20\t\t\tin.useLocale(Locale.US);\n21\t\t\ta \u003d in.nextDouble();\n22\t\t\tb \u003d in.nextDouble();\n23\t\t\tin.close();\n24\t\t}\n25\n26\n27\t\tvoid solve() {\n28\t\t\tres \u003d a + b; \n29\t\t}\n30\n31\t\tvoid print() {\n32\t\t\tSystem.out.println(s);\n33\t\t}\n34\n35\t\tdouble a;\n36\t\tdouble b;\n37\t\tdouble s;\n38\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОтличий у класса \u003ccode\u003eABSumma2\u003c/code\u003e от \u003ccode\u003eABSumma\u003c/code\u003e немного. В классе \u003ccode\u003eABSumma2\u003c/code\u003e мы избавились от метода \u003ccode\u003esum()\u003c/code\u003e, перенеся всю его логику в метод \u003ccode\u003esolve()\u003c/code\u003e. При этом метод \u003ccode\u003esolve()\u003c/code\u003e не приобрёл ни параметров: нам требуется только сложить \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e, никаких обобщений не нужно, ни возвращаемого типа: результат по-прежнему заносится в поле \u003ccode\u003es\u003c/code\u003e. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003emain()\u003c/code\u003e класса \u003ccode\u003eAplusB2\u003c/code\u003e в точности совпадает с методом \u003ccode\u003emain()\u003c/code\u003e класса \u003ccode\u003eAplusB\u003c/code\u003e — создается объект, вызывается его метод \u003ccode\u003esolve()\u003c/code\u003e (реализация у \u003ccode\u003esolve()\u003c/code\u003e уже другая), затем его метод \u003ccode\u003eprint()\u003c/code\u003e. Заметим, что если не выполнить вызов метода \u003ccode\u003esolve()\u003c/code\u003e \u003cem\u003eперед\u003c/em\u003e методом \u003ccode\u003eprint()\u003c/code\u003e, то в качестве ответа при любых значениях \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e будет напечатано 0.0.\u003c/p\u003e\u003cp\u003e\u003cem\u003eПо умолчанию все поля и многие переменные (здесь есть тонкости, о которых позже), которым ещё не присвоено никакого значения, считаются установленными в 0 в смысле того типа, к которому они относятся. Если переменная целая — её значением будет считаться 0, если вещественная — 0.0, если булева — \u003ccode\u003efalse\u003c/code\u003e.\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e","tags":["java","eclipse"]}}