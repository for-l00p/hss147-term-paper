{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1432378306,"rating":354,"authorHandle":"Al.Cash","modificationTimeSeconds":1445672645,"id":18051,"title":"\u003cp\u003eEfficient and easy segment trees\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThis is my first attempt at writing something useful, so your suggestions are welcome.\u003c/p\u003e\u003cp\u003eMost participants of programming contests are familiar with segment trees to some degree, especially having read this articles \u003ca href\u003d\"//codeforces.com/blog/entry/15890\"\u003ehttp://codeforces.com/blog/entry/15890\u003c/a\u003e, \u003ca href\u003d\"http://e-maxx.ru/algo/segment_tree\"\u003ehttp://e-maxx.ru/algo/segment_tree\u003c/a\u003e (Russian only). If you\u0027re not — don\u0027t go there yet. I advise to read them after this article for the sake of examples, and to compare implementations and choose the one you like more (will be kinda obvious).\u003c/p\u003e\u003ch1\u003eSegment tree with single element modifications\u003c/h1\u003e\u003cp\u003eLet\u0027s start with a brief explanation of segment trees. They are used when we have an array, perform some changes and queries on continuous segments. In the first example we\u0027ll consider 2 operations:\u003c/p\u003e \u003col\u003e   \u003cli\u003emodify one element in the array;\u003c/li\u003e   \u003cli\u003efind the sum of elements on some segment. .\u003c/li\u003e \u003c/ol\u003e\u003ch3\u003ePerfect binary tree\u003c/h3\u003e\u003cp\u003eI like to visualize a segment tree in the following way: \u003ca href\u003d\"http://i.imgur.com/GGBmcEP.png\"\u003eimage link\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/0f/52/0f52998b96c8a0f55d379fd5c990e5d2d66d1ab2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eNotation is \u003cem\u003enode_index: corresponding segment\u003c/em\u003e (left border included, right excluded). At the bottom row we have our array (0-indexed), the leaves of the tree. For now suppose it\u0027s length is a power of 2 (16 in the example), so we get perfect binary tree. When going up the tree we take pairs of nodes with indices \u003cspan class\u003d\"tex-span\"\u003e(2 * \u003ci\u003ei\u003c/i\u003e, 2 * \u003ci\u003ei\u003c/i\u003e + 1)\u003c/span\u003e and combine their values in their parent with index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. This way when we\u0027re asked to find a sum on interval \u003cspan class\u003d\"tex-span\"\u003e[3, 11)\u003c/span\u003e, we need to sum up only values in the nodes 19, 5, 12 and 26 (marked with bold), not all 8 values inside the interval. Let\u0027s jump directly to implementation (in C++) to see how it works:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003econst int N \u003d 1e5;  // limit for array size\nint n;  // array size\nint t[2 * N];\n\nvoid build() {  // build the tree\n  for (int i \u003d n - 1; i \u0026gt; 0; --i) t[i] \u003d t[i\u0026lt;\u0026lt;1] + t[i\u0026lt;\u0026lt;1|1];\n}\n\nvoid modify(int p, int value) {  // set value at position p\n  for (t[p +\u003d n] \u003d value; p \u0026gt; 1; p \u0026gt;\u0026gt;\u003d 1) t[p\u0026gt;\u0026gt;1] \u003d t[p] + t[p^1];\n}\n\nint query(int l, int r) {  // sum on interval [l, r)\n  int res \u003d 0;\n  for (l +\u003d n, r +\u003d n; l \u0026lt; r; l \u0026gt;\u0026gt;\u003d 1, r \u0026gt;\u0026gt;\u003d 1) {\n    if (l\u0026amp;1) res +\u003d t[l++];\n    if (r\u0026amp;1) res +\u003d t[--r];\n  }\n  return res;\n}\n\nint main() {\n  scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n  for (int i \u003d 0; i \u0026lt; n; ++i) scanf(\u0026quot;%d\u0026quot;, t + n + i);\n  build();\n  modify(0, 1);\n  printf(\u0026quot;%d\\n\u0026quot;, query(3, 11));\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat\u0027s it! Fully operational example. Forget about those cumbersome recursive functions with 5 arguments!\u003c/p\u003e\u003cp\u003eNow let\u0027s see why this works, and works very efficient.\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eAs you could notice from the picture, leaves are stored in continuous nodes with indices starting with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, element with index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e corresponds to a node with index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. So we can read initial values directly into the tree where they belong.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eBefore doing any queries we need to build the tree, which is quite straightforward and takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time. Since parent always has index less than its children, we just process all the internal nodes in decreasing order. In case you\u0027re confused by bit operations, the code in \u003cem\u003ebuild()\u003c/em\u003e is equivalent to \u003ccode\u003et[i] \u003d t[2*i] + t[2*i+1]\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eModifying an element is also quite straightforward and takes time proportional to the height of the tree, which is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e. We only need to update values in the parents of given node. So we just go up the tree knowing that parent of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e / 2\u003c/span\u003e or \u003ccode\u003ep\u0026gt;\u0026gt;1\u003c/code\u003e, which means the same. \u003ccode\u003ep^1\u003c/code\u003e turns \u003cspan class\u003d\"tex-span\"\u003e2 * \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e into \u003cspan class\u003d\"tex-span\"\u003e2 * \u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e and vice versa, so it represents the second child of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e\u0027s parent.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eFinding the sum also works in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e time. To better understand it\u0027s logic you can go through example with interval \u003cspan class\u003d\"tex-span\"\u003e[3, 11)\u003c/span\u003e and verify that result is composed exactly of values in nodes 19, 26, 12 and 5 (in that order).\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eGeneral idea is the following. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e, the left interval border, is odd (which is equivalent to \u003ccode\u003el\u0026amp;1\u003c/code\u003e) then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e is the right child of its parent. Then our interval includes node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e but doesn\u0027t include it\u0027s parent. So we add \u003ccode\u003et[l]\u003c/code\u003e and move to the right of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e\u0027s parent by setting \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d (\u003ci\u003el\u003c/i\u003e + 1) / 2\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e is even, it is the left child, and the interval includes its parent as well (unless the right border interferes), so we just move to it by setting \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d \u003ci\u003el\u003c/i\u003e / 2\u003c/span\u003e. Similar argumentation is applied to the right border. We stop once borders meet.\u003c/p\u003e\u003cp\u003eNo recursion and no additional computations like finding the middle of the interval are involved, we just go through all the nodes we need, so this is very efficient.\u003c/p\u003e\u003ch3\u003eArbitrary sized array\u003c/h3\u003e\u003cp\u003eFor now we talked only about an array with size equal to some power of 2, so the binary tree was perfect. The next fact may be stunning, so prepare yourself.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eThe code above works for any size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eExplanation is much more complex than before, so let\u0027s focus first on the advantages it gives us.\u003c/p\u003e \u003col\u003e   \u003cli\u003eSegment tree uses exactly \u003cspan class\u003d\"tex-span\"\u003e2 * \u003ci\u003en\u003c/i\u003e\u003c/span\u003e memory, not \u003cspan class\u003d\"tex-span\"\u003e4 * \u003ci\u003en\u003c/i\u003e\u003c/span\u003e like some other implementations offer.\u003c/li\u003e   \u003cli\u003eArray elements are stored in continuous manner starting with index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eAll operations are very efficient and easy to write.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eYou can skip the next section and just test the code to check that it\u0027s correct. But for those interested in some kind of explanation, here\u0027s how the tree for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 13\u003c/span\u003e looks like: \u003ca href\u003d\"http://i.imgur.com/cwKpYH1.png\"\u003eimage link\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/52/3e/523e873ebb079a80c9538c4205c8c243c66058ed.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eIt\u0027s not actually a single tree any more, but a set of perfect binary trees: with root \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e and height 4, root \u003cspan class\u003d\"tex-span\"\u003e7\u003c/span\u003e and height 2, root \u003cspan class\u003d\"tex-span\"\u003e12\u003c/span\u003e and height 2, root \u003cspan class\u003d\"tex-span\"\u003e13\u003c/span\u003e and height 1. Nodes denoted by dashes aren\u0027t ever used in \u003cem\u003equery\u003c/em\u003e operations, so it doesn\u0027t matter what\u0027s stored there. Leaves seem to appear on different heights, but that can be fixed by cutting the tree before the node \u003cspan class\u003d\"tex-span\"\u003e13\u003c/span\u003e and moving its right part to the left. I believe the resulting structure can be shown to be isomorphic to a part of larger perfect binary tree with respect to operations we perform, and this is why we get correct results.\u003c/p\u003e\u003cp\u003eI won\u0027t bother with formal proof here, let\u0027s just go through the example with interval [0, 7). We have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d 13, \u003ci\u003er\u003c/i\u003e \u003d 20\u003c/span\u003e, \u003ccode\u003el\u0026amp;1 \u003d\u0026gt; add t[13]\u003c/code\u003e and borders change to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d 7, \u003ci\u003er\u003c/i\u003e \u003d 10\u003c/span\u003e. Again \u003ccode\u003el\u0026amp;1 \u003d\u0026gt; add t[7]\u003c/code\u003e, borders change to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d 4, \u003ci\u003er\u003c/i\u003e \u003d 5\u003c/span\u003e, and suddenly nodes are at the same height. Now we have \u003ccode\u003er\u0026amp;1 \u003d\u0026gt; add t[4 \u003d --r]\u003c/code\u003e, borders change to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d 2, \u003ci\u003er\u003c/i\u003e \u003d 2\u003c/span\u003e, so we\u0027re finished.\u003c/p\u003e\u003ch2\u003eModification on interval, single element access\u003c/h2\u003e\u003cp\u003eSome people begin to struggle and invent something too complex when the operations are inverted, for example:\u003c/p\u003e \u003col\u003e   \u003cli\u003eadd a value to all elements in some interval;\u003c/li\u003e   \u003cli\u003ecompute an element at some position.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eBut all we need to do in this case is to switch the code in methods \u003cem\u003emodify\u003c/em\u003e and \u003cem\u003equery\u003c/em\u003e as follows:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid modify(int l, int r, int value) {\n  for (l +\u003d n, r +\u003d n; l \u0026lt; r; l \u0026gt;\u0026gt;\u003d 1, r \u0026gt;\u0026gt;\u003d 1) {\n    if (l\u0026amp;1) t[l++] +\u003d value;\n    if (r\u0026amp;1) t[--r] +\u003d value;\n  }\n}\n\nint query(int p) {\n  int res \u003d 0;\n  for (p +\u003d n; p \u0026gt; 0; p \u0026gt;\u0026gt;\u003d 1) res +\u003d t[p];\n  return res;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf at some point after modifications we need to inspect all the elements in the array, we can push all the modifications to the leaves using the following code. After that we can just traverse elements starting with index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. This way we reduce the complexity from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e similarly to using \u003cem\u003ebuild\u003c/em\u003e instead of n modifications.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid push() {\n  for (int i \u003d 1; i \u0026lt; n; ++i) {\n    t[i\u0026lt;\u0026lt;1] +\u003d t[i];\n    t[i\u0026lt;\u0026lt;1|1] +\u003d t[i];\n    t[i] \u003d 0;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNote, however, that code above works only in case the order of modifications on a single element doesn\u0027t affect the result. Assignment, for example, doesn\u0027t satisfy this condition. Refer to section about lazy propagation for more information.\u003c/p\u003e\u003ch2\u003eNon-commutative combiner functions\u003c/h2\u003e\u003cp\u003eFor now we considered only the simplest combiner function — addition. It is commutative, which means the order of operands doesn\u0027t matter, we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e \u003d \u003ci\u003eb\u003c/i\u003e + \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. The same applies to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/span\u003e, so we can just change all occurrences of \u003ccode\u003e+\u003c/code\u003e to one of those functions and be fine. But don\u0027t forget to initialize query result to infinity instead of 0.\u003c/p\u003e\u003cp\u003eHowever, there are cases when the combiner isn\u0027t commutative, for example, in the problem \u003ca href\u003d\"/contest/380/problem/C\" title\u003d\"Codeforces Round 223 (Div. 1)\"\u003e380C - Sereja and Brackets\u003c/a\u003e, tutorial available here \u003ca href\u003d\"//codeforces.com/blog/entry/10363\"\u003ehttp://codeforces.com/blog/entry/10363\u003c/a\u003e. Fortunately, our implementation can easily support that. We define structure \u003ccode\u003eS\u003c/code\u003e and \u003cem\u003ecombine\u003c/em\u003e function for it. In method \u003cem\u003ebuild\u003c/em\u003e we just change \u003ccode\u003e+\u003c/code\u003e to this function. In \u003cem\u003emodify\u003c/em\u003e we need to ensure the correct ordering of children, knowing that left child has even index. When answering the query, we note that nodes corresponding to the left border are processed from left to right, while the right border moves from right to left. We can express it in the code in the following way:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid modify(int p, const S\u0026amp; value) {\n  for (t[p +\u003d n] \u003d value; p \u0026gt;\u0026gt;\u003d 1; ) t[p] \u003d combine(t[p\u0026lt;\u0026lt;1], t[p\u0026lt;\u0026lt;1|1]);\n}\n\nS query(int l, int r) {\n  S resl, resr;\n  for (l +\u003d n, r +\u003d n; l \u0026lt; r; l \u0026gt;\u0026gt;\u003d 1, r \u0026gt;\u0026gt;\u003d 1) {\n    if (l\u0026amp;1) resl \u003d combine(resl, t[l++]);\n    if (r\u0026amp;1) resr \u003d combine(t[--r], resr);\n  }\n  return combine(resl, resr);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch1\u003eLazy propagation\u003c/h1\u003e\u003cp\u003eNext we\u0027ll describe a technique to perform both range queries and range modifications, which is called lazy propagation. First, we need more variables:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint h \u003d sizeof(int) * 8 - __builtin_clz(n);\nint d[N];  \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e is a height of the tree, the highest significant bit in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. \u003ccode\u003ed[i]\u003c/code\u003e is a delayed operation to be propagated to the children of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e when necessary (this should become clearer from the examples). Array size if only \u003ccode\u003eN\u003c/code\u003e because we don\u0027t have to store this information for leaves — they don\u0027t have any children. This leads us to a total of \u003cspan class\u003d\"tex-span\"\u003e3 * \u003ci\u003en\u003c/i\u003e\u003c/span\u003e memory use.\u003c/p\u003e\u003cp\u003ePreviously we could say that \u003ccode\u003et[i]\u003c/code\u003e is a value corresponding to it\u0027s segment. Now it\u0027s not entirely true — first we need to apply all the delayed operations on the route from node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to the root of the tree (parents of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e). We assume that \u003ccode\u003et[i]\u003c/code\u003e already includes \u003ccode\u003ed[i]\u003c/code\u003e, so that route starts not with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e but with its direct parent.\u003c/p\u003e\u003cp\u003eLet\u0027s get back to our first example with interval \u003cspan class\u003d\"tex-span\"\u003e[3, 11)\u003c/span\u003e, but now we want to modify all the elements inside this interval. In order to do that we modify \u003ccode\u003et[i]\u003c/code\u003e and \u003ccode\u003ed[i]\u003c/code\u003e at the nodes 19, 5, 12 and 26. Later if we\u0027re asked for a value for example in node 22, we need to propagate modification from node 5 down the tree. Note that our modifications could affect \u003ccode\u003et[i]\u003c/code\u003e values up the tree as well: node 19 affects nodes 9, 4, 2 and 1, node 5 affects 2 and 1. Next fact is critical for the complexity of our operations:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eModification on interval \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e affects \u003ccode\u003et[i]\u003c/code\u003e values only in the parents of border leaves: \u003ccode\u003el+n\u003c/code\u003e and \u003ccode\u003er+n-1\u003c/code\u003e (except the values that compose the interval itself — the ones accessed in \u003cem\u003efor\u003c/em\u003e loop).\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe proof is simple. When processing the left border, the node we modify in our loop is always the right child of its parent. Then all the previous modifications were made in the subtree of the left child of the same parent. Otherwise we would process the parent instead of both its children. This means current direct parent is also a parent of leaf \u003ccode\u003el+n\u003c/code\u003e. Similar arguments apply to the right border.\u003c/p\u003e\u003cp\u003eOK, enough words for now, I think it\u0027s time to look at concrete examples.\u003c/p\u003e\u003ch3\u003eIncrement modifications, queries for maximum\u003c/h3\u003e\u003cp\u003eThis is probably the simplest case. The code below is far from universal and not the most efficient, but it\u0027s a good place to start.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid apply(int p, int value) {\n  t[p] +\u003d value;\n  if (p \u0026lt; n) d[p] +\u003d value;\n}\n\nvoid build(int p) {\n  while (p \u0026gt; 1) p \u0026gt;\u0026gt;\u003d 1, t[p] \u003d max(t[p\u0026lt;\u0026lt;1], t[p\u0026lt;\u0026lt;1|1]) + d[p];\n}\n\nvoid push(int p) {\n  for (int s \u003d h; s \u0026gt; 0; --s) {\n    int i \u003d p \u0026gt;\u0026gt; s;\n    if (d[i] !\u003d 0) {\n      apply(i\u0026lt;\u0026lt;1, d[i]);\n      apply(i\u0026lt;\u0026lt;1|1, d[i]);\n      d[i] \u003d 0;\n    }\n  }\n}\n\nvoid inc(int l, int r, int value) {\n  l +\u003d n, r +\u003d n;\n  int l0 \u003d l, r0 \u003d r;\n  for (; l \u0026lt; r; l \u0026gt;\u0026gt;\u003d 1, r \u0026gt;\u0026gt;\u003d 1) {\n    if (l\u0026amp;1) apply(l++, value);\n    if (r\u0026amp;1) apply(--r, value);\n  }\n  build(l0);\n  build(r0 - 1);\n}\n\nint query(int l, int r) {\n  l +\u003d n, r +\u003d n;\n  push(l);\n  push(r - 1);\n  int res \u003d -2e9;\n  for (; l \u0026lt; r; l \u0026gt;\u0026gt;\u003d 1, r \u0026gt;\u0026gt;\u003d 1) {\n    if (l\u0026amp;1) res \u003d max(res, t[l++]);\n    if (r\u0026amp;1) res \u003d max(t[--r], res);\n  }\n  return res;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLet\u0027s analyze it one method at a time. The first three are just helper methods user doesn\u0027t really need to know about.\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eNow that we have 2 variables for every internal node, it\u0027s useful to write a method to \u003cem\u003eapply\u003c/em\u003e changes to both of them. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e \u0026lt; \u003ci\u003en\u003c/i\u003e\u003c/span\u003e checks if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is not a leaf. Important property of our operations is that if we increase all the elements in some interval by one value, maximum will increase by the same value.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003cem\u003ebuild\u003c/em\u003e is designed to update all the parents of a given node.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003cem\u003epush\u003c/em\u003e propagates changes from all the parents of a given node down the tree starting from the root. This parents are exactly the prefixes of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e in binary notation, that\u0027s why we use binary shifts to calculate them.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eNow we\u0027re ready to look at main methods.\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eAs explained above, we process increment request using our familiar loop and then updating everything else we need by calling \u003cem\u003ebuild\u003c/em\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eTo answer the query, we use the same loop as earlier, but before that we need to push all the changes to the nodes we\u0027ll be using. Similarly to \u003cem\u003ebuild\u003c/em\u003e, it\u0027s enough to push changes from the parents of border leaves.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eIt\u0027s easy to see that all operations above take \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e time.\u003c/p\u003e\u003cp\u003eAgain, this is the simplest case because of two reasons:\u003c/p\u003e \u003col\u003e   \u003cli\u003eorder of modifications doesn\u0027t affect the result;\u003c/li\u003e   \u003cli\u003ewhen updating a node, we don\u0027t need to know the length of interval it represents.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eWe\u0027ll show how to take that into account in the next example.\u003c/p\u003e\u003ch3\u003eAssignment modifications, sum queries\u003c/h3\u003e\u003cp\u003eThis example is inspired by problem \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d2042\"\u003eTimus 2042\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAgain, we\u0027ll start with helper functions. Now we have more of them:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid calc(int p, int k) {\n  if (d[p] \u003d\u003d 0) t[p] \u003d t[p\u0026lt;\u0026lt;1] + t[p\u0026lt;\u0026lt;1|1];\n  else t[p] \u003d d[p] * k;\n}\n\nvoid apply(int p, int value, int k) {\n  t[p] \u003d value * k;\n  if (p \u0026lt; n) d[p] \u003d value;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThese are just simple \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e functions to calculate value at node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and to apply a change to the node. But there are two thing to explain:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eWe suppose there\u0027s a value we never use for modification, in our case it\u0027s \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. In case there\u0027s no such value — we would create additional boolean array and refer to it instead of checking \u003ccode\u003ed[p] \u003d\u003d 0\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eNow we have additional parameter \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, which stands for the lenght of the interval corresponding to node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e. We will use this name consistently in the code to preserve this meaning. Obviously, it\u0027s impossible to calculate the sum without this parameter. We can avoid passing this parameter if we precalculate this value for every node in a separate array or calculate it from the node index on the fly, but I\u0027ll show you a way to avoid using extra memory or calculations.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eNext we need to update \u003cem\u003ebuild\u003c/em\u003e and \u003cem\u003epush\u003c/em\u003e methods. Note that we have two versions of them: one we introduces earlier that processes the whole tree in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e, and one from the last example that processes just the parents of one leaf in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e. We can easily combine that functionality into one method and get even more.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid build(int l, int r) {\n  int k \u003d 2;\n  for (l +\u003d n, r +\u003d n-1; l \u0026gt; 1; k \u0026lt;\u0026lt;\u003d 1) {\n    l \u0026gt;\u0026gt;\u003d 1, r \u0026gt;\u0026gt;\u003d 1;\n    for (int i \u003d r; i \u0026gt;\u003d l; --i) calc(i, k);\n  }\n}\n\nvoid push(int l, int r) {\n  int s \u003d h, k \u003d 1 \u0026lt;\u0026lt; (h-1);\n  for (l +\u003d n, r +\u003d n-1; s \u0026gt; 0; --s, k \u0026gt;\u0026gt;\u003d 1)\n    for (int i \u003d l \u0026gt;\u0026gt; s; i \u0026lt;\u003d r \u0026gt;\u0026gt; s; ++i) if (d[i] !\u003d 0) {\n      apply(i\u0026lt;\u0026lt;1, d[i], k);\n      apply(i\u0026lt;\u0026lt;1|1, d[i], k);\n      d[i] \u003d 0;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBoth this methods work on any interval in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e) + |\u003ci\u003er\u003c/i\u003e - \u003ci\u003el\u003c/i\u003e|)\u003c/span\u003e time. If we want to transform some interval in the tree, we can write code like this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epush(l, r);\n...  // do anything we want with elements in interval [l, r)\nbuild(l, r);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLet\u0027s explain how they work. First, note that we change our interval to closed by doing \u003ccode\u003er +\u003d n-1\u003c/code\u003e in order to calculate parents properly. Since we process our tree level by level, is\u0027t easy to maintain current interval level, which is always a power of 2. \u003cem\u003ebuild\u003c/em\u003e goes bottom to top, so we initialize \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e to 2 (not to 1, because we don\u0027t calculate anything for the leaves but start with their direct parents) and double it on each level. \u003cem\u003epush\u003c/em\u003e goes top to bottom, so \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e\u0027s initial value depends here on the height of the tree and is divided by 2 on each level.\u003c/p\u003e\u003cp\u003eMain methods don\u0027t change much from the last example, but \u003cem\u003emodify\u003c/em\u003e has 2 things to notice:\u003c/p\u003e \u003col\u003e   \u003cli\u003eBecause the order of modifications is important, we need to make sure there are no old changes on the paths from the root to all the nodes we\u0027re going to update. This is done by calling \u003cem\u003epush\u003c/em\u003e first as we did in \u003cem\u003equery\u003c/em\u003e.\u003c/li\u003e   \u003cli\u003eWe need to maintain the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e \u003c/ol\u003e \u003cpre\u003e\u003ccode\u003evoid modify(int l, int r, int value) {\n  if (value \u003d\u003d 0) return;\n  push(l, l + 1);\n  push(r - 1, r);\n  int l0 \u003d l, r0 \u003d r, k \u003d 1;\n  for (l +\u003d n, r +\u003d n; l \u0026lt; r; l \u0026gt;\u0026gt;\u003d 1, r \u0026gt;\u0026gt;\u003d 1, k \u0026lt;\u0026lt;\u003d 1) {\n    if (l\u0026amp;1) apply(l++, value, k);\n    if (r\u0026amp;1) apply(--r, value, k);\n  }\n  build(l0, l0 + 1);\n  build(r0 - 1, r0);\n}\n\nint query(int l, int r) {\n  push(l, l + 1);\n  push(r - 1, r);\n  int res \u003d 0;\n  for (l +\u003d n, r +\u003d n; l \u0026lt; r; l \u0026gt;\u0026gt;\u003d 1, r \u0026gt;\u0026gt;\u003d 1) {\n    if (l\u0026amp;1) res +\u003d t[l++];\n    if (r\u0026amp;1) res +\u003d t[--r];\n  }\n  return res;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOne could notice that we do 3 passed in \u003cem\u003emodify\u003c/em\u003e over almost the same nodes: 1 down the tree in \u003cem\u003epush\u003c/em\u003e, then 2 up the tree. We can eliminate the last pass and calculate new values only where it\u0027s necessary, but the code gets more complicated:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid modify(int l, int r, int value) {\n  if (value \u003d\u003d 0) return;\n  push(l, l + 1);\n  push(r - 1, r);\n  bool cl \u003d false, cr \u003d false;\n  int k \u003d 1;\n  for (l +\u003d n, r +\u003d n; l \u0026lt; r; l \u0026gt;\u0026gt;\u003d 1, r \u0026gt;\u0026gt;\u003d 1, k \u0026lt;\u0026lt;\u003d 1) {\n    if (cl) calc(l - 1, k);\n    if (cr) calc(r, k);\n    if (l\u0026amp;1) apply(l++, value, k), cl \u003d true;\n    if (r\u0026amp;1) apply(--r, value, k), cr \u003d true;\n  }\n  for (--l; r \u0026gt; 0; l \u0026gt;\u0026gt;\u003d 1, r \u0026gt;\u0026gt;\u003d 1, k \u0026lt;\u0026lt;\u003d 1) {\n    if (cl) calc(l, k);\n    if (cr \u0026amp;\u0026amp; (!cl || l !\u003d r)) calc(r, k);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBoolean flags denote if we already performed any changes to the left and to the right. Let\u0027s look at an example: \u003ca href\u003d\"http://i.imgur.com/CG6aftV.png\"\u003eimage link\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/e3/d2/e3d2b2814d185dcb1f3f170414933e8b4c79df27.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eWe call \u003cem\u003emodify\u003c/em\u003e on interval \u003cspan class\u003d\"tex-span\"\u003e[4, 13)\u003c/span\u003e:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d 20, \u003ci\u003er\u003c/i\u003e \u003d 29\u003c/span\u003e, we call \u003cem\u003eapply(28)\u003c/em\u003e;\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d 10, \u003ci\u003er\u003c/i\u003e \u003d 14\u003c/span\u003e, we call \u003cem\u003ecalc(14)\u003c/em\u003e — first node to the right of current interval is exactly the parent of last modified node;\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d 5, \u003ci\u003er\u003c/i\u003e \u003d 7\u003c/span\u003e, we call \u003cem\u003ecalc(7)\u003c/em\u003e and then \u003cem\u003eapply(5)\u003c/em\u003e and \u003cem\u003eapply(6)\u003c/em\u003e;\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d 3, \u003ci\u003er\u003c/i\u003e \u003d 3\u003c/span\u003e, so the first loop finishes.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eNow you should see the point of doing \u003ccode\u003e--l\u003c/code\u003e, because we still need to calculate new values in nodes 2, 3 and then 1. End condition is \u003ccode\u003er \u0026gt; 0\u003c/code\u003e because it\u0027s possible to get \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d 1, \u003ci\u003er\u003c/i\u003e \u003d 1\u003c/span\u003e after the first loop, so we need to update the root, but \u003ccode\u003e--l\u003c/code\u003e results in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d 0\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eCompared to previous implementation, we avoid unnecessary calls \u003cem\u003ecalc(10)\u003c/em\u003e, \u003cem\u003ecalc(5)\u003c/em\u003e and duplicate call to \u003cem\u003ecalc(1)\u003c/em\u003e.\u003c/p\u003e\u003c/div\u003e","tags":["efficiency","segment trees"]}}