{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1496485055,"rating":3,"authorHandle":"MrTEK","modificationTimeSeconds":1502989875,"id":52355,"title":"\u003cp\u003eEDITORIAL\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA ve B soruları basit implementation soruları.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/A2c3aE26AD/contest/213885/problem/C\"\u003eC Macar Usulü Evlilik\u003c/a\u003e\u003c/p\u003e\u003cp\u003en tane adam olsun. i. adamı evlendirene kadar bazı kadınları evlendirdik. Bu kadınlardan evlendirilenlere değer olarak 1 evlendirilmeyenlere değer olarak 0 diyelim. 1.kadından n. kadına kadar olan Kadınların değerleri dizildiğinde elimize 2 lik tabanda bir sayı geçer ve elimizdeki durumu sayıya dönüştürmüş oluruz. Bu sayıyı 10 luk tabana çevirir, bu durumdan sonra gelebilecek durumların en iyi cevabını dinamik programlama ile saklar ve tekrar tekrar hesaplama yapmak yerine bu cevabı üst durumlara döndürürsek sorumuz çözülmüş olur. Bu dinamik programlama tekniğine Bitmask denmektedir.\u003c/p\u003e\u003cp\u003eZaman Karmaşıklığı : O(2^N) --\u0026gt; Şuanki durum için herbir kadın ya evlendirilmiştir ya da evlendirilmemiştir.\u003c/p\u003e\u003cp\u003eChallange: TSP(Travelling Salesman Problem) Bitmask Yöntemi ile çözülür mü? Haydi düşünelim... Örnek Kod:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\n#define N 23\n#define inf 1000000000\nusing namespace std;\n\nint n,a[N][N],dp[1\u0026lt;\u0026lt;(N+1)],vis[N];\n\nint dfs(int node,int bm) {\n  int ret\u003dinf;\n  if(node\u0026gt;n) return dp[bm]\u003d0;\n  if(~dp[bm]) return dp[bm];\n  for(int i\u003d1;i\u0026lt;\u003dn;i++) {\n    if(!vis[i]) {\n      vis[i]\u003d1;\n      ret\u003dmin(ret,dfs(node+1,bm+(1\u0026lt;\u0026lt;(i-1)))+a[node][i]);\n      vis[i]\u003d0;\n    }\n  }\n  return dp[bm]\u003dret;\n}\n\nint main() {\n  memset(dp,-1,sizeof(dp));\n  scanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\n  for(int i\u003d1;i\u0026lt;\u003dn;i++) {\n    for(int j\u003d1;j\u0026lt;\u003dn;j++) {\n      scanf(\u0026quot;%d\u0026quot;,\u0026amp;a[i][j]);\n    }\n  }\n  dfs(1,0);\n  printf(\u0026quot;%d\u0026quot;,dp[0]);\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/A2c3aE26AD/contest/213885/problem/D\"\u003eD Palindrom\u003c/a\u003e\u003c/p\u003e\u003cp\u003eÖncelikle Soru dinamik sorusu. Şimdi elimizde bir string olsun bu string\u0027i palindromik bir string yapabilmek için stringe eklenemsi gereken minumum karakteri şu şekilde hesaplayalım :\u003c/p\u003e\u003cp\u003eEğer stringin ilk ve son elemanı aynı ise cevabımız ilk ve son elemanlarını çıkardığımız string ile aynıdır. örn\u003d dinamik(abdbxa)\u003ddinamik(bdbx).\u003c/p\u003e\u003cp\u003eFarklı ise cevabımız şu iki durumun minumum değeridir:  1-Stringin sonuna ilk elamanı eklicez ve ilk elemanı çıkadığımız stringin sonucu ile toplıcaz. örn\u003d stringimiz \u0026quot;ahdsab\u0026quot; ise bu durumda cevap dinamik(hdsab)+1.\u003c/p\u003e\u003cp\u003e2-Stringin başına sonuncu elamanı eklicez ve son elemanı çıkadığımız stringin sonucu ile toplıcaz. örn\u003d stringimiz \u0026quot;ahdsab\u0026quot; ise bu durumda cevap dinamik(ahdsa)+1.\u003c/p\u003e\u003cp\u003e2 durumdan gelen minumum değer cevabımız olucak. örnek kod:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nint n,dp[limit][limit];\nchar ar[limit];\nint main()\n{\n\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\n\tfor(int i\u003d1;i\u0026lt;\u003dn;i++)\n\t\tscanf(\u0026quot; %c\u0026quot;,ar+i);\n\tfor(int i\u003dn;i\u0026gt;0;i--)\n\t{\n\t\tfor(int j\u003di+1;j\u0026lt;\u003dn;j++)\n\t\t{\n\t\t\tif(ar[i]\u003d\u003dar[j])\n\t\t\t\tdp[i][j]\u003ddp[i+1][j-1];\n\t\t\telse\n\t\t\t\tdp[i][j]\u003d1+min(dp[i+1][j],dp[i][j-1]);\n\t\t}\n\t}\n\tprintf(\u0026quot;%d\\n\u0026quot;,dp[1][n]);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/A2c3aE26AD/contest/213885/problem/E\"\u003eE Planet\u003c/a\u003e\u003c/p\u003e\u003cp\u003eplanetleri graph gibi düşünürsek ve herhangi bir bekleme yapmadan 1. şehirden n. şehire en az maliyetle varış isteniyorsa Dijkstra shortest path algoritması soruyu çözmek için yeterli olacaktır. Ancak girdinin ikinci kısmındaki n tane satırda bize sunduğu şartlar dolayısı ile Dijkstra algoritmasına ekleme yapmak gerekecektir. Şart ise eğer i. şehire seninle aynı zamanda varan birisi var ise (t\u003dzaman diyelim) 1 saniye beklemek ve eğer t+1 . zamanda varan bir kişi yoksa yola devam etmek var ise olmayana kadar beklemek. Bu şart dahilinde soru çözümünde her seferinde t anında i şehrinde birisi var mı ve ne kadar bekleyeceğini hesaplamak zorundayız. Bu işlemi for çekerek yapabiliriz ama en kötü durumda O(N) e varacağından bizim için daha hızlı bir yöntem gerekli. Bu da binary search algoritması olacak. Zaten bir şehre varacak insanların geliş zamanları artan sırada olacağından sıralama işlemi yapmamıza gerek kalmayacak. öncelikle binary search algoritmasını kullanarak t anında herhangi biri i sehrine uğruyor mu bunu bulacağız. eğer varan yoksa o zaman bekleme yapmadan geçeceğiz. Var ise o zaman ne kadar beklediğimizi bulacağız. Örneğin t+z anına kadar beklememiz gerekti. Bu durumda yine binary search kullanarak t+z anını bulacağız. Çünkü r\u0026lt;z olan her t+r anında beklememiz gerekecek. Bizde eğer t+r anında bekleyeceksek şansımızı zorlayarak r den büyük bir değer deniyoruz. Beklemeyeceksek de r den daha küçük bir değer deniyoruz ve böylece z yi bularak bir sonraki planete giderken geçen zamana ekliyoruz.\u003c/p\u003e\u003cp\u003eÖzel bir durum: n. şehire vardığımızda bekleme yapmadan bitiriyoruz ve yine 1. şehirde de bekleme yapılabilir.\u003c/p\u003e\u003cp\u003eZaman Karmaşıklığı : O(N * log(N) * log(N)) \u003c/p\u003e\u003cp\u003eÖrnek Kod:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\n#define N 100005\n#define st first\n#define nd second\n#define mp make_pair\n#define pii pair\u0026lt;int,int\u0026gt;\nusing namespace std;\n\nint n,m,x,y,z,k,t,vis[N];\nvector\u0026lt;pii\u0026gt; v[N];\nvector\u0026lt;int\u0026gt; art[N];\npriority_queue\u0026lt;pii\u0026gt; q;\n\nint f(int node,int tm) {\n  int bas\u003d0,son\u003dart[node].size()-1;\n  while(bas\u0026lt;\u003dson) {\n    int ort\u003d(bas+son)/2;\n    if(art[node][ort]\u0026gt;tm) son\u003dort-1;\n    else bas\u003dort+1;\n  }\n  if(son\u0026lt;0 || art[node][son]!\u003dtm) return 0;\n  int tut\u003dson;\n  bas\u003dson+1;son\u003dart[node].size()-1;\n  while(bas\u0026lt;\u003dson) {\n    int ort\u003d(bas+son)/2;\n    if(art[node][ort]\u003d\u003dort-tut+art[node][tut]) bas\u003dort+1;\n    else son\u003dort-1;\n  }\n  return son-tut+1;\n}\n\nint main() {\n  scanf(\u0026quot;%d %d\u0026quot;,\u0026amp;n,\u0026amp;m);\n  for(int i\u003d1;i\u0026lt;\u003dm;i++) {\n    scanf(\u0026quot;%d %d %d\u0026quot;,\u0026amp;x,\u0026amp;y,\u0026amp;z);\n    v[x].push_back(mp(y,z));\n    v[y].push_back(mp(x,z));\n  }\n  for(int i\u003d1;i\u0026lt;\u003dn;i++) {\n    scanf(\u0026quot;%d\u0026quot;,\u0026amp;k);\n    for(int j\u003d1;j\u0026lt;\u003dk;j++) {\n      scanf(\u0026quot;%d\u0026quot;,\u0026amp;t);\n      art[i].push_back(t);\n    }\n  }\n  q.push(mp(0-f(1,0),1));\n  while(!q.empty()) {\n    pii x\u003dq.top();\n    q.pop();\n    if(vis[x.nd]) continue ;\n    if(x.nd\u003d\u003dn) {\n      printf(\u0026quot;%d\u0026quot;,-x.st);\n      return 0;\n    }\n    vis[x.nd]\u003d1;\n    for(int i\u003d0;i\u0026lt;v[x.nd].size();i++) {\n      pii y\u003dx;\n      y.st-\u003dv[x.nd][i].nd;\n      y.nd\u003dv[x.nd][i].st;\n      if(y.nd!\u003dn) {\n        y.st-\u003df(y.nd,-y.st);\n      }\n      q.push(y);\n    }\n  }\n  printf(\u0026quot;-1\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}