{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1408370561,"rating":-1,"authorHandle":"caioaao","modificationTimeSeconds":1408423636,"id":13440,"title":"\u003cp\u003eLine segment sorting\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eNotice: this is a piece of a bigger problem I\u0027m trying to solve, but I could figure the rest out, and I think this part would be a good resource for the community in general, as I couldn\u0027t find anywhere.\u003c/p\u003e\u003cp\u003eThe problem: I have an origin point O and a set of several line segments that never crosses each other. I know the line segments have a common angle interval in which they all appear. This angle is measured according to a line parallel to X axis and that contains point O. I need to sort this set of line segments according to the distance from the origin point, meaning that in the angle interval that the line segments appear, if line A is always closer to the point O, A comes first in the set. This comparison must be made without floating point operations!\u003c/p\u003e\u003cp\u003eHere is a tiny (horribly made) pic to illustrate the problem:\u003c/p\u003e\u003cp\u003e\u003cimg src\u003d\"/predownloaded/bb/3a/bb3a77e445ec0659abeaf1e9531dfcc191ad55d3.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThe section between the dashed line is the region of interest. The expected result would be line 0 coming first and line 1 coming second.\u003c/p\u003e\u003cp\u003eImportant notes:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eThe line segments never crosses\u003c/li\u003e   \u003cli\u003eNo three points are collinear (point O and the endings of the line segments)\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eI couldn\u0027t come up with anything that works, can anyone help me out?\u003c/p\u003e\u003cp\u003eIf anyone is interested in the full problem, here is a link to it (though i UVa this sorting isn\u0027t necessary — weak test cases): \u003ca href\u003d\"http://uva.onlinejudge.org/index.php?option\u003dcom_onlinejudge\u0026amp;Itemid\u003d8\u0026amp;category\u003d24\u0026amp;page\u003dshow_problem\u0026amp;problem\u003d4413\"\u003eUVa 12675 — Hide and seek\u003c/a\u003e\u003c/p\u003e\u003cp\u003eEDIT: I\u0027ve managed to make it work! :D Here is the final comparison function:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003einline bool cmpActive(line a, line b){\n  if(a \u003d\u003d b) return false; // if lines are the same, ignore\n\n  // checks if b.p1 is in the sector defined by a.p1 and a.p2\n  if(ccw(origin, a.p1, b.p1) \u0026amp;\u0026amp; !ccw(origin, a.p2, b.p1)){\n    // if it is, checks if b.p1 is on the same side of line a as origin\n    return ccw(a.p1, a.p2, b.p1) !\u003d  ccw(a.p1, a.p2, origin);\n  }\n  else if(ccw(origin, a.p1, b.p2) \u0026amp;\u0026amp; !ccw(origin, a.p2, b.p2)){\n    // if b.p1 isn\u0027t in the sector, but b.p2 is\n    return ccw(a.p1, a.p2, b.p2) !\u003d  ccw(a.p1, a.p2, origin);\n  }\n  else{\n    // this was missing: when interval A is completely inside B, so we can\n    // choose any point of A we want\n    return ccw(b.p1, b.p2, a.p1) \u003d\u003d  ccw(b.p1, b.p2, origin);\n  }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn this pseudocode, ccw(A,B,C) refers to testing wether C is in clockwise direction from B, taking A as it\u0027s rotation center\u003c/p\u003e\u003cp\u003eI\u0027d like to thank \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/brunoja\" title\u003d\"Кандидат в мастера brunoja\"\u003ebrunoja\u003c/a\u003e for the help he provided!\u003c/p\u003e\u003c/div\u003e","tags":["computational geometry","sorting"]}}