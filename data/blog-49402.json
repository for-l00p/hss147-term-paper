{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1483048348,"rating":53,"authorHandle":"Kerpoo","modificationTimeSeconds":1483100653,"id":49402,"title":"\u003cp\u003eEdmond\u0027s blossom C++ Implementation\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI love this implementation of Edmond\u0027s Blossoms :-)\u003c/p\u003e\u003cp\u003eEdmond\u0027s Blossoms algorithm give a maximum matching in general graphs (non-bipartite)\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCODE\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e/*\nGETS:\nV-\u0026gt;number of vertices\nE-\u0026gt;number of edges\npair of vertices as edges (vertices are 1..V)\n\nGIVES:\noutput of edmonds() is the maximum matching\nmatch[i] is matched pair of i (-1 if there isn\u0027t a matched pair)\n */\n\n#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int M\u003d500;\nstruct struct_edge{int v;struct_edge* n;};\ntypedef struct_edge* edge;\nstruct_edge pool[M*M*2];\nedge top\u003dpool,adj[M];\nint V,E,match[M],qh,qt,q[M],father[M],base[M];\nbool inq[M],inb[M],ed[M][M];\nvoid add_edge(int u,int v)\n{\n  top-\u0026gt;v\u003dv,top-\u0026gt;n\u003dadj[u],adj[u]\u003dtop++;\n  top-\u0026gt;v\u003du,top-\u0026gt;n\u003dadj[v],adj[v]\u003dtop++;\n}\nint LCA(int root,int u,int v)\n{\n  static bool inp[M];\n  memset(inp,0,sizeof(inp));\n  while(1)\n    {\n      inp[u\u003dbase[u]]\u003dtrue;\n      if (u\u003d\u003droot) break;\n      u\u003dfather[match[u]];\n    }\n  while(1)\n    {\n      if (inp[v\u003dbase[v]]) return v;\n      else v\u003dfather[match[v]];\n    }\n}\nvoid mark_blossom(int lca,int u)\n{\n  while (base[u]!\u003dlca)\n    {\n      int v\u003dmatch[u];\n      inb[base[u]]\u003dinb[base[v]]\u003dtrue;\n      u\u003dfather[v];\n      if (base[u]!\u003dlca) father[u]\u003dv;\n    }\n}\nvoid blossom_contraction(int s,int u,int v)\n{\n  int lca\u003dLCA(s,u,v);\n  memset(inb,0,sizeof(inb));\n  mark_blossom(lca,u);\n  mark_blossom(lca,v);\n  if (base[u]!\u003dlca)\n    father[u]\u003dv;\n  if (base[v]!\u003dlca)\n    father[v]\u003du;\n  for (int u\u003d0;u\u0026lt;V;u++)\n    if (inb[base[u]])\n      {\n\tbase[u]\u003dlca;\n\tif (!inq[u])\n\t  inq[q[++qt]\u003du]\u003dtrue;\n      }\n}\nint find_augmenting_path(int s)\n{\n  memset(inq,0,sizeof(inq));\n  memset(father,-1,sizeof(father));\n  for (int i\u003d0;i\u0026lt;V;i++) base[i]\u003di;\n  inq[q[qh\u003dqt\u003d0]\u003ds]\u003dtrue;\n  while (qh\u0026lt;\u003dqt)\n    {\n      int u\u003dq[qh++];\n      for (edge e\u003dadj[u];e;e\u003de-\u0026gt;n)\n        {\n\t  int v\u003de-\u0026gt;v;\n\t  if (base[u]!\u003dbase[v]\u0026amp;\u0026amp;match[u]!\u003dv)\n\t    if ((v\u003d\u003ds)||(match[v]!\u003d-1 \u0026amp;\u0026amp; father[match[v]]!\u003d-1))\n\t      blossom_contraction(s,u,v);\n\t    else if (father[v]\u003d\u003d-1)\n\t      {\n\t\tfather[v]\u003du;\n\t\tif (match[v]\u003d\u003d-1)\n\t\t  return v;\n\t\telse if (!inq[match[v]])\n\t\t  inq[q[++qt]\u003dmatch[v]]\u003dtrue;\n\t      }\n        }\n    }\n  return -1;\n}\nint augment_path(int s,int t)\n{\n  int u\u003dt,v,w;\n  while (u!\u003d-1)\n    {\n      v\u003dfather[u];\n      w\u003dmatch[v];\n      match[v]\u003du;\n      match[u]\u003dv;\n      u\u003dw;\n    }\n  return t!\u003d-1;\n}\nint edmonds()\n{\n  int matchc\u003d0;\n  memset(match,-1,sizeof(match));\n  for (int u\u003d0;u\u0026lt;V;u++)\n    if (match[u]\u003d\u003d-1)\n      matchc+\u003daugment_path(u,find_augmenting_path(u));\n  return matchc;\n}\nint main()\n{\n  int u,v;\n  cin\u0026gt;\u0026gt;V\u0026gt;\u0026gt;E;\n  while(E--)\n    {\n      cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v;\n      if (!ed[u-1][v-1])\n\t{\n\t  add_edge(u-1,v-1);\n\t  ed[u-1][v-1]\u003ded[v-1][u-1]\u003dtrue;\n\t}\n    }\n  cout\u0026lt;\u0026lt;edmonds()\u0026lt;\u0026lt;endl;\n  for (int i\u003d0;i\u0026lt;V;i++)\n    if (i\u0026lt;match[i])\n      cout\u0026lt;\u0026lt;i+1\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;match[i]+1\u0026lt;\u0026lt;endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003ethanks a lot to \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/boleyn.su\" title\u003d\"Кандидат в мастера boleyn.su\"\u003eboleyn.su\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["graphs","matchings","implementation","c++"]}}