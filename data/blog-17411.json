{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1429086336,"rating":5,"authorHandle":"Karan2116","modificationTimeSeconds":1429086424,"id":17411,"title":"\u003cp\u003eOptimized Sieve\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI came across the following method of generating primes using an optimized sieve.\u003cbr /\u003e I know the naive sieve of eratosthenes and its implementation but am not able to understand the \u003cbr /\u003e following code :\u003cbr /\u003e how does it work ?(the use of bitwise operators) \u003cbr /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e#define N 51000000\nunsigned int prime[N / 64];\n#define gP(n) (prime[n\u0026gt;\u0026gt;6]\u0026amp;(1\u0026lt;\u0026lt;((n\u0026gt;\u0026gt;1)\u0026amp;31)))\n#define rP(n) (prime[n\u0026gt;\u0026gt;6]\u0026amp;\u003d~(1\u0026lt;\u0026lt;((n\u0026gt;\u0026gt;1)\u0026amp;31)))\nvoid sieve()\n{\n    memset( prime, -1, sizeof( prime ) );\n\n    unsigned int i;\n    unsigned int sqrtN \u003d ( unsigned int )sqrt( ( double )N ) + 1;\n    for( i \u003d 3; i \u0026lt; sqrtN; i +\u003d 2 ) if( gP( i ) )\n    {\n        unsigned int i2 \u003d i + i;\n        for( unsigned int j \u003d i * i; j \u0026lt; N; j +\u003d i2 ) rP( j );\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["sieve of eratosthenes","number theory"]}}