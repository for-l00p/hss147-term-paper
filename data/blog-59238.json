{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1525403682,"rating":-25,"authorHandle":"CodingKnight","modificationTimeSeconds":1525444712,"id":59238,"title":"\u003cp\u003eC++ class for (mod P) modular arithmetic\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThe following is a C++ class \u003ccode\u003emodulo\u003c/code\u003e for (mod P) modular arithmetic, where P is a prime number and all numbers are normalized to the interval [0,P-1]. The modular division operation y / x is performed by means of multiplying the modulo number y times the modular multiplicative inverse of x computed using the modular power function. \u003c/p\u003e\u003cp\u003eThe class has been used in \u003ca href\u003d\"/contest/964/submission/37874808\" title\u003d\"Submission 37874808 by CodingKnight\"\u003e37874808\u003c/a\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\n#ifndef __modulo__\n#define __modulo__\n\ntypedef long long ll;\n\nclass modulo\n{\n    static int P, Q; int value;\n\n    modulo normalize( const ll new_value )\n    {\n        if ( ( value \u003d new_value % P ) \u0026lt; 0 )\n            value +\u003d P;\n\n        return *this;\n    }\n\npublic:\n\n    modulo( ll x \u003d 0 ) { normalize( x ); }\n\n    static void radix( const int p ) { P \u003d p, Q \u003d p - 2; }\n\n    static int radix() { return P; }\n\n    // overloaded operators\n\n    ll operator () () const { return value; }\n\n    modulo operator \u003d  (     ll x ) { return normalize( x ); }\n    modulo operator \u003d  ( modulo x ) { return value \u003d x.value, *this; }\n\n    modulo operator +\u003d ( modulo x ) { return normalize( ll( value ) + x.value ); }\n    modulo operator -\u003d ( modulo x ) { return normalize( ll( value ) - x.value ); }\n    modulo operator *\u003d ( modulo x ) { return normalize( ll( value ) * x.value ); }\n    modulo operator /\u003d ( modulo x ) { return *this *\u003d x.power( Q ); }\n\n    modulo operator +\u003d ( ll x ) { return normalize( ll( value ) + x ); }\n    modulo operator -\u003d ( ll x ) { return normalize( ll( value ) - x ); }\n    modulo operator *\u003d ( ll x ) { return normalize( ll( value ) * x ); }\n    modulo operator /\u003d ( ll x ) { modulo y( x ); return *this *\u003d y.power( Q ); }\n\n    // prefix ++ and -- operators\n\n    modulo operator ++ () { return normalize( value + 1 ); }\n    modulo operator -- () { return normalize( value - 1 ); }\n\n    // postfix ++ and -- operators\n\n    modulo operator ++ ( int unused ) { ll z \u003d value; return normalize( z + 1 ), modulo( z ); }\n    modulo operator -- ( int unused ) { ll z \u003d value; return normalize( z - 1 ), modulo( z ); }\n\n\n    // relational operators\n\n    bool operator \u003d\u003d ( modulo x ) const { return value \u003d\u003d x.value; }\n    bool operator !\u003d ( modulo x ) const { return value !\u003d x.value; }\n\n    bool operator \u003d\u003d ( ll x ) const { return value \u003d\u003d x; }\n    bool operator !\u003d ( ll x ) const { return value !\u003d x; }\n   \n    modulo power( ll p ) const // p is strictly positive\n    {\n        modulo y \u003d 1;\n\n        if ( value \u003d\u003d 0 )\n        {\n            if ( p \u0026lt;\u003d 0 )\n                throw domain_error( \u0026quot;modulo(0).power(p) p cannot be zero or negative\u0026quot; );\n            else\n                return modulo( 1 );\n        }\n        else if ( value \u0026gt; 1 )\n                for( modulo x \u003d *this; p \u0026gt; 0 \u0026amp;\u0026amp; y \u0026gt; 0; x *\u003d x, p \u0026gt;\u0026gt;\u003d 1 )\n                    if ( p \u0026amp; 1 )\n                        y *\u003d x;\n        return y;\n    }\n\n    friend modulo operator +( modulo x, modulo y ) { return x +\u003d y; }\n    friend modulo operator *( modulo x, modulo y ) { return x *\u003d y; }\n    friend modulo operator -( modulo x, modulo y ) { return x -\u003d y; }\n    friend modulo operator /( modulo x, modulo y ) { return x /\u003d y; }\n\n    friend modulo operator +( modulo x, ll y ) { return x +\u003d y; }\n    friend modulo operator *( modulo x, ll y ) { return x *\u003d y; }\n    friend modulo operator -( modulo x, ll y ) { return x -\u003d y; }\n    friend modulo operator /( modulo x, ll y ) { return x /\u003d y; }\n\n    friend modulo operator +( ll x, modulo y ) { return y +\u003d x; }\n    friend modulo operator *( ll x, modulo y ) { return y *\u003d x; }\n    friend modulo operator -( ll x, modulo y ) { modulo z( x ); return z -\u003d y; }\n    friend modulo operator /( ll x, modulo y ) { modulo z( x ); return z /\u003d y; }\n\n    friend istream\u0026amp; operator \u0026gt;\u0026gt; ( istream\u0026amp; input, modulo \u0026amp;x )\n    {\n        input \u0026gt;\u0026gt; x.value, x.normalize( x.value ); return input;\n    }\n\n    friend ostream\u0026amp; operator \u0026lt;\u0026lt; ( ostream\u0026amp; output, const modulo x )\n    {\n        return output \u0026lt;\u0026lt; x.value;\n    }\n};\n\nint modulo::P \u003d 1e9+9, modulo::Q \u003d P - 2;\n\n#endif // __modulo__\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis can be used by Codeforces as any other shared library in the public domain.\u003c/p\u003e\u003cp\u003eThank you.\u003c/p\u003e\u003c/div\u003e","tags":[]}}