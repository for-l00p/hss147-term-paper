{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1516640142,"rating":28,"authorHandle":"Jakube","modificationTimeSeconds":1516642272,"id":57286,"title":"\u003cp\u003eRMQ with DSU in almost constant time?\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eOn the e-maxx website about the Disjoint Set Union data structure there is a paragraph about computing range minimum queries offline using DSU. (\u003ca href\u003d\"http://e-maxx.ru/algo/dsu#15\"\u003ehttp://e-maxx.ru/algo/dsu#15\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eIt is claimed that it works in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(α(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e time per query on average (\u003cspan class\u003d\"tex-span\"\u003eα\u003c/span\u003e is the inverse Ackerman function). \u003c/p\u003e\u003cp\u003eMy Russian is terrible at best, and the Google/Yandex translations also is quite hard to understand for this paragraph. So I didn\u0027t really understand the complete idea and have some questions about this one.\u003c/p\u003e\u003cp\u003eFrom what I can understand using Google translate is the following:\u003c/p\u003e \u003cul\u003e   \u003cli\u003ethis only works if the elements are actually a permutation of 1 to n (otherwise we would have to sort the elements beforehand)\u003c/li\u003e   \u003cli\u003efor each index in the array we store the reference to the closest query that ends right of the index.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eFrom this information I was able to construct this tree/forest structure. (red are the range queries, blue arrows are the references that point to the parent)\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/56/14/5614f0d7a425522e6419afd685123be06f4de55c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eNow the algorithm then goes as follows:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eWe start with the empty array.\u003c/li\u003e   \u003cli\u003eWe insert the smallest number 1 and follow the references. In that way we visit all range queries where 1 is the answer. Therefore we can answer those, and shorten some of the paths via path compression and Union by rank (the typical DSU optimizations).\u003c/li\u003e   \u003cli\u003eThe repeat the procedure with the other elements in increasing order.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eI\u0027m pretty sure I know how to create the data structure in linear time [first store every query (left, right) at left, then do walk through it and store the queries at right (this assures that multiple queries that end in the same element are sorted by size in descending order). Then iterate over those in reversed order keeping a stack with the current biggest/active queries.]\u003c/p\u003e\u003cp\u003eSo everything looks quite lovely and fine. \u003c/p\u003e\u003cp\u003eBut now I have one main concern. \u003c/p\u003e\u003cp\u003eI\u0027m pretty sure that I can create test cases in which a query takes O(n) time on average. E.g. take the sorted array 1, 2, 3, ..., n, and taking n/3 queries of the type [1, 2n/3], [2, 2n/3], [3, 2n/3], ..., and the add n/3 queries of the type [n/3, 2n/3], [n/3+1, 2n/3+1], [n/3+2, 2n/3] ... For each inserted element we would have to iterate over all n/3 queries of the second type to be sure that none of these has the current element as answer. Because theoretically they could all start at the index 1 of the array.\u003c/p\u003e\u003cp\u003eSo my question: Have I completely misunderstood what the Russian explanation says? Do I have to structure the DSU differently? Or is the explanations wrong and doing RMQ with a DSU in that time actually impossible?\u003c/p\u003e\u003cp\u003eBtw, searching for this algorithm / implemenation / papers produced nothing. It seems that this is only documented on e-maxx.ru. \u003c/p\u003e\u003c/div\u003e","tags":[]}}