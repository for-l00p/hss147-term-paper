{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1487625220,"rating":32,"authorHandle":"vntshh","modificationTimeSeconds":1488628302,"id":50550,"title":"\u003cp\u003eEditorial Divide by Zero and Codeforces Round #399 (Div. 1+2, combined)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/768/problem/A\"\u003e768A. Oath of the Night\u0027s Watch\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSet and Editorial by: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/vntshh\" title\u003d\"Expert vntshh\"\u003evntshh\u003c/a\u003e\u003c/p\u003e\u003cp\u003eYou just have to find the number of elements greater than the minimum number occurring in the array and less than the maximum number occurring in the array. This can be done in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e by traversing the array once and finding the minimum and maximum of the array, and then in another traversal, find the good numbers.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity\u003c/strong\u003e: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint a[100005];\nint main()\n{\n\tint n,c1\u003d0,c2\u003d0,mx\u003d0,mn\u003d1000000007;\n\tcin\u0026gt;\u0026gt;n;\n\tfor(int i\u003d0;i\u0026lt;n;i++) \n\t{\n\t\tcin\u0026gt;\u0026gt;a[i];\n\t\tmx\u003dmax(mx,a[i]),mn\u003dmin(mn,a[i]);\n\t}\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tif(a[i]\u003d\u003dmx) c1++;\n\t\tif(a[i]\u003d\u003dmn) c2++;\n\t}\n\tif(mx\u003d\u003dmn) cout\u0026lt;\u0026lt;0;\n\telse cout\u0026lt;\u0026lt;(n-c1-c2); \n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/768/problem/B\"\u003e768B. Code For 1\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSet and Editorial by: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/killer_bee\" title\u003d\"Expert killer_bee\"\u003ekiller_bee\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIt is easy to see that the total number of elements in the final list will be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/37/4e/374e85bc73146866383eaee063d8c6c6520d1e11.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e . The problem can be solved by locating each element in the list and checking whether it is \u003cspan class\u003d\"tex-span\"\u003e\u00271\u0027\u003c/span\u003e .The \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eth\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e element can be located in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogn\u003c/i\u003e)\u003c/span\u003e by using Divide and Conquer strategy. Answer is the total number of all such elements which equal \u003cspan class\u003d\"tex-span\"\u003e\u00271\u0027\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity\u003c/strong\u003e : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003er\u003c/i\u003e - \u003ci\u003el\u003c/i\u003e + 1) * \u003ci\u003elogn\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nlong long int cnt(long long int temp) //returns the length of final list \n{\n  long long int x\u003d1;\n  while(temp\u0026gt;1)\n  {\n    temp/\u003d2;\n    x*\u003d2;\n  }\n  return x;\n}\nint is_one(long long int pos,long long int target,long long int num)\n{ \n  if(num\u0026lt;2)\n    return num;\n  if(pos+1\u003d\u003d2*target)\n  {\n    return num%2;\n  }\n  num/\u003d2;\n  pos/\u003d2;   \n  if(target\u0026gt;pos+1)\n      target-\u003d(pos+1);      \n  return is_one(pos,target,num);\n}\nint main()\n{\n  long long int l,r,n,x,ans\u003d0,i;\n  cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r;\n  x\u003dcnt(n);\n  x\u003d2*x-1;\n  for(i\u003dl; i\u0026lt;\u003dr; i++)  ans+\u003dis_one(x,i,n);\n  cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;  \n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/768/problem/C\"\u003e768C. Jon Snow and his Favourite Number\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSet and Editorial by: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/vntshh\" title\u003d\"Expert vntshh\"\u003evntshh\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe range of strengths of any ranger at any point of time can be [0,1023]. This allows us to maintain a frequency array of the strengths of the rangers. Now, the updation of the array can be done in the following way: Make a copy of the frequency array. If the number of rangers having strength less than a strength \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e is even, and there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efreq\u003c/i\u003e[\u003ci\u003ey\u003c/i\u003e]\u003c/span\u003e rangers having strength y, ceil(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efreq\u003c/i\u003e[\u003ci\u003ey\u003c/i\u003e] / 2\u003c/span\u003e) rangers will be updated and will have strengths \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e^\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, and the remaining will retain the same strength. If the number of rangers having strength less than a strength \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e is odd,and there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efreq\u003c/i\u003e[\u003ci\u003ey\u003c/i\u003e]\u003c/span\u003e rangers having strength y, floor(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efreq\u003c/i\u003e[\u003ci\u003ey\u003c/i\u003e] / 2\u003c/span\u003e) rangers will be updated and will have strengths \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e^\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, and remaining will have the same strength. This operation has to be done \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e times, thus the overall complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1024 * \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity\u003c/strong\u003e: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e * 2\u003csup class\u003d\"upper-index\"\u003e10\u003c/sup\u003e)\u003c/span\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\n#define rep(i,start,lim) for(int i\u003dstart;i\u0026lt;lim;i++)\nusing namespace std;\n#define N 100005\nint freq[1100],tmp[1024];\nint main()\n{\n\tint n,k,maxm\u003d0,minm\u003dINT_MAX,p,x;\n\tcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;x;\n\trep(i,0,n) cin\u0026gt;\u0026gt;p,freq[p]++;\n\trep(i,0,k)\n\t{\n\t\trep(j,0,1024) tmp[j]\u003dfreq[j];\n\t\tint par\u003d0;\n\t\trep(j,0,1024)\n\t\t{\n\t\t\tif(freq[j]\u0026gt;0)\n\t\t\t{\n\t\t\t\tint curr \u003d (j^x),change \u003d (freq[j]/2);\n\t\t\t\tif(par\u003d\u003d0) change+\u003d(freq[j]\u0026amp;1);\n\t\t\t\ttmp[j]-\u003dchange;\n\t\t\t\ttmp[curr]+\u003dchange;\n\t\t\t\tpar^\u003d(freq[j]\u0026amp;1);\n\t\t\t}\n\t\t}\n\t\trep(j,0,1024) freq[j]\u003dtmp[j]; \n\t}\n\trep(i,0,1024) if(freq[i]\u0026gt;0) minm\u003dmin(minm,i),maxm\u003dmax(maxm,i);\n\tcout\u0026lt;\u0026lt;maxm\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;minm;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/768/problem/D\"\u003e768D. Jon and Orbs\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSet and Editorial by: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/arnabsamanta\" title\u003d\"Expert arnabsamanta\"\u003earnabsamanta\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis problem can be solve using inclusion-exclusion principle but precision errors need to be handled. Therefore, we use the following dynamic programming approach to solve this problem.\u003c/p\u003e\u003cp\u003eOn \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e day there are two possibilities, \u003cbr /\u003eCase-1 : Jon doesn\u0027t find a new orb then the probability of it is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/47/63/4763deacc2f48e5b152286fe7743575956cc1a5b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003cbr /\u003eCase-2 : Jon does find a new orb then the probability of it is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/42/84/428459cbf6531fcf2c16216062f3d8c446fd2ec7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eTherefore,  \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d3/98/d39856f3ca27641114a1c04b59cc02a323132c44.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cbr /\u003eWe need to find the minimum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e such that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ea/f0/eaf048f63376d6c81dbefdba8a69775102e484ff.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cbr /\u003ewhere, \u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e \u003d number of days Jon waited. \u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e \u003d number of distinct orbs Jon have till now. \u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e][\u003ci\u003ex\u003c/i\u003e]\u003c/span\u003e \u003d probability of Jon having \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e distinct orbs in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e days. \u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e \u003d Total number of distinct orbs possible.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nconst int N \u003d 1004;\nconst double eps \u003d 1e-7;\ndouble dp[N];\nint ans[N];\n\nint main(){\n\tint k, q, d \u003d 1;\n\tcin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; q;\n\tdp[0] \u003d 1;\n\tfor(int n \u003d 1; d \u0026lt;\u003d 1000; ++n){\n\t\tfor(int x \u003d k; x \u0026gt; 0; --x){\n\t\t\tdp[x] \u003d (x * dp[x] + (k - x + 1) * dp[x - 1]) / k;\n\t\t}\n\t\twhile(d \u0026lt;\u003d 1000 \u0026amp;\u0026amp; 2000 * dp[k] \u0026gt;\u003d (d - eps)){\n\t\t\tans[d] \u003d n;\n\t\t\td++;\n\t\t}\n\t\tdp[0] \u003d 0;\n\t}\n\twhile(q--){\n\t\tint x;\n\t\tcin \u0026gt;\u0026gt; x;\n\t\tcout \u0026lt;\u0026lt; ans[x] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003ePS:The \u003cspan class\u003d\"tex-span\"\u003eε\u003c/span\u003e was added so that the any solution considering the probability in the given range \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/52/c7/52c739bb161aeaa93ee2aeeee76e3694c3fd922e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e passes the system tests.\u003c/strong\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/768/problem/E\"\u003e768E. Game of Stones\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSet and Editorial by: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/AakashHanda\" title\u003d\"Expert AakashHanda\"\u003eAakashHanda\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis problem can be solved using \u003cem\u003eDP with Bitmasks\u003c/em\u003e to calculate the grundy value of piles. Let us have a 2-dimensional dp table, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e, where the first dimension is for number of stones in the pile and second dimension is for bitmask. The bitmask has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e-th bit set if we are allowed to remove \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e stones from the pile.\u003c/p\u003e\u003cp\u003eNow, to calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e we need to iterate over all possible moves allowed and find the \u003cem\u003emex\u003c/em\u003e. \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003edp[0][0] \u003d 0;\n\nfor(i\u003d1 ; i\u0026lt;N ; ++i){\n    for(j\u003d0 ; j\u0026lt;(1\u0026lt;\u0026lt;N)-1 ; ++j){\n        vector\u0026lt;bool\u0026gt; found(N, false);\n\n        for(k\u003d0 ; k\u0026lt;i ; ++k){\n            if(((j\u0026gt;\u0026gt;k)\u0026amp;1) !\u003d 1)\n                continue;\n            found[dp[i-k-1][j^(1\u0026lt;\u0026lt;k)]] \u003d true;\n        }\n\n        for(k\u003d0 ; k\u0026lt;N ; ++k){\n            if(!found[k]){\n                dp[i][j] \u003d k;\n                break;\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eFinally for the game, we use the grundy values stored in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e - 1]\u003c/span\u003e for a pile of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. We take the xor of grundy values of all piles sizes. If it is 0, then Jon wins, otherwise Sam wins.\u003c/p\u003e\u003cp\u003eThe complexity of this solution is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ff/b5/ffb5d551c77dee092ec8b2beb5bf71c1566e7604.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. This will not be accepted. We can use the following optimizations for this problem:\u003c/p\u003e \u003col\u003e   \u003cli\u003eUse a top-down approach to calculate the values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e - 1]\u003c/span\u003e, hence calculating only those values that are required.\u003c/li\u003e   \u003cli\u003eSince we can only remove at most i stones from a pile, as stated above, we need to store values from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e in range \u003cspan class\u003d\"tex-span\"\u003e[0, 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e - 1]\u003c/span\u003e.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eSo we can rewrite the above code to incorporate these change. Hence, the final solution is as follows\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\ntypedef long long ll;\n\nmap\u0026lt;pair\u0026lt;int, ll\u0026gt;, int\u0026gt; grundy;\nmap\u0026lt;pair\u0026lt;int, ll\u0026gt;, bool\u0026gt; mp;\n\nint retgrundy(int ps, ll bm, int prev \u003d 63){\n    for(int i\u003dps ; i\u0026lt;prev ; ++i){\n        if(((bm\u0026gt;\u0026gt;i)\u0026amp;1LL) \u003d\u003d 1LL)\n            bm ^\u003d (1LL\u0026lt;\u0026lt;i);\n    }\n    if(mp[{ps, bm}])\n        return grundy[{ps, bm}];\n    vector\u0026lt;bool\u0026gt; marked(63, false);\n    for(int k\u003d0 ; k\u0026lt;ps ; ++k){\n        if(((bm\u0026gt;\u0026gt;k)\u0026amp;1LL) \u003d\u003d 0)\n            continue;\n        marked[retgrundy(ps-k-1LL, (bm^(1LL\u0026lt;\u0026lt;k)), ps)] \u003d true;\n    }\n    int ret;\n    for(int i\u003d0 ; i\u0026lt;63 ; ++i){\n        if(marked[i])\n            continue;\n        grundy[{ps, bm}] \u003d i;\n        ret \u003d i;\n        break;\n    }\n    mp[{ps, bm}] \u003d true;\n    return ret;\n}\n\nint main(){\n    int n, in, x\u003d0;\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\n    grundy[{0, 0}] \u003d 0;\n    mp[{0, 0}] \u003d true;\n    vector\u0026lt;int\u0026gt; gr(70, 0);\n\n    for(int i\u003d0 ; i\u0026lt;\u003d60 ; ++i)\n        gr[i] \u003d retgrundy(i, (1LL\u0026lt;\u0026lt;i)-1LL);\n\n    while(n--){\n        scanf(\u0026quot;%d\u0026quot;, \u0026amp;in);\n        x ^\u003d gr[in];\n    }\n\n    if(x \u003d\u003d 0)\n        printf(\u0026quot;YES\u0026quot;);\n    else\n        printf(\u0026quot;NO\u0026quot;);\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eBonus: Try to find and prove the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e formula for grundy values\u003c/strong\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/768/problem/F\"\u003e768F. Barrels and boxes\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSet and Editorial by: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/arnabsamanta\" title\u003d\"Expert arnabsamanta\"\u003earnabsamanta\u003c/a\u003e, \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/apoorv_kulsh\" title\u003d\"Candidate Master apoorv_kulsh\"\u003eapoorv_kulsh\u003c/a\u003e\u003c/p\u003e\u003cp\u003eEvery arrangement of stacks can expressed in the form of linear arrangement. In this linear arrangement, every contiguous segment of wine barrels are separated by food boxes. For the arrangement to be liked by Jon each of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e + 1\u003c/span\u003e partitions created by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e food boxes must contain either \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e or greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e wine barrels.\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e out of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e + 1\u003c/span\u003e partitions have non-zero wine barrels then the remaining \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e + 1 - \u003ci\u003eu\u003c/i\u003e\u003c/span\u003e partitions must have \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e wine barrels..\u003c/p\u003e\u003cp\u003eTotal number of arrangements with exactly u stacks of wine barrels are  \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/75/e3/75e3aa80e8fe1bbb26bbd2ad749af6a87bcfa0a1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e  \u003cbr /\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cc/eb/ccebfd63f39ea76c07de8b60d7761f3fab44e7a6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is the number of ways of choosing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e partitions out of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e + 1\u003c/span\u003e partitions.  \u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e is the number of ways to place \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e wine barrels in these \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e partitions which is equal to the coefficient of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e{\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eh\u003c/i\u003e + 1\u003c/sup\u003e·(1 + \u003ci\u003ex\u003c/i\u003e + ...)}\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. Finally we sum it up for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e + 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSo the time complexity becomes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ew\u003c/i\u003e)\u003c/span\u003e with pre-processing of factorials. \u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e \u003d 0\u003c/span\u003e was the corner case for which the answer was \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. \u003cbr /\u003eWe did not anticipate it will cause so much trouble. Not placing it in the pretests was a rookie mistake.\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nconst int N \u003d 212345;\nconst int mod \u003d 1000000007;\nint fac[N], ifac[N], inv[N];\n\nvoid prep(){\n    fac[0] \u003d ifac[0] \u003d inv[1] \u003d 1;\n    for(int i \u003d 1; i \u0026lt; N; ++i)\n        fac[i] \u003d 1LL * i * fac[i - 1] % mod;\n    for(int i \u003d 2; i \u0026lt; N; ++i) \n        inv[i] \u003d mod - 1LL * (mod / i) * inv[mod % i] % mod;\n    for(int i \u003d 1; i \u0026lt; N; ++i) \n        ifac[i] \u003d 1LL * inv[i] * ifac[i - 1] % mod;\n}\n\nint C(int n, int r){\n    if(r \u0026lt; 0 || n \u0026lt; r) return 0;\n    return 1LL * fac[n] * ifac[n - r] % mod * ifac[r] % mod; \n}\n\nint num(int r, int b, int k){\n    if(b \u003d\u003d 0) return 1;\n    int ans \u003d 0;\n    for(int u \u003d 1; u \u0026lt;\u003d r + 1 \u0026amp;\u0026amp; (k \u003d\u003d 0 || u \u0026lt;\u003d (b - 1) / k); ++u){\n        ans +\u003d 1LL * C(r + 1,u) * C(b - k * u - 1, u - 1) % mod;\n        ans %\u003d mod;\n    }\n    return ans;\n}\n\nint pwr(int b, int p){\n    int r \u003d 1;\n    while(p){\n        if(p \u0026amp; 1) r \u003d 1LL * r * b % mod;\n        b \u003d 1LL * b * b % mod;\n        p \u0026gt;\u0026gt;\u003d 1;\n    }\n    return r;\n}\n\nint finv(int x){\n    return pwr(x, mod - 2);\n}\n\nint main(){\n    prep();\n    int f, w, h;\n    cin \u0026gt;\u0026gt; f \u0026gt;\u0026gt; w \u0026gt;\u0026gt; h;\n    int sn \u003d num(f, w, h);\n    int sd \u003d C(f + w, w);\n    cout \u0026lt;\u0026lt; 1LL * sn * finv(sd) % mod \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/768/problem/G\"\u003e768G. The Winds of Winter\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSet and Editorial by: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/apoorv_kulsh\" title\u003d\"Candidate Master apoorv_kulsh\"\u003eapoorv_kulsh\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe are given a tree. We remove one node from this tree to form a forest. Strength of forest is defined as the size of largest tree in forest. We need to minimize the strength by changing the parent of atmost one node to some other node such that number of components remain same.\u003c/p\u003e\u003cp\u003eTo find the minimum value of strength we do a binary search on strength. It is possible to attain Strength \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e if \u003cbr /\u003e1. There is less than one component with size greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e. \u003cbr /\u003e2. There exists a node in maximum component with subtree size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e such that, \u003cbr /\u003e \u003cspan class\u003d\"tex-span\"\u003e \u003ci\u003eM\u003c/i\u003e - \u003ci\u003eY\u003c/i\u003e ≤ \u003ci\u003eS\u003c/i\u003e \u003c/span\u003e (Here \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e is size of maximum component and m is size of minimum component) \u003cbr /\u003e \u003cspan class\u003d\"tex-span\"\u003e \u003ci\u003em\u003c/i\u003e + \u003ci\u003eY\u003c/i\u003e ≤ \u003ci\u003eS\u003c/i\u003e\u003c/span\u003e. \u003cbr /\u003eThen we can change the parent of this node to some node in smallest component.\u003c/p\u003e\u003cp\u003e\u003cbr /\u003eThe problem now is to store Subtree_size of all nodes in the maximum component and perform binary search on them. We can use Stl Map for this. \u003cbr /\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e be the node which is removed and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003esize\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be its subtree size There are two cases now -: \u003cbr /\u003e1. When max size tree is child of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e. \u003cbr /\u003e2. When max size tree is the tree which remains when we remove subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e from original tree.(We refer to this as outer tree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eIn the second case the subtree sizes of nodes on path from root to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e will change when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e is removed. Infact their subtree size will decrease exactly by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003esize\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. While performing binary search on these nodes there will be an offset of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003esize\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. So we store them seperately. Now we need to maintain \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e Maps, \u003cbr /\u003ewhere \u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003echildren\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e : Stores the Subtree_size of all nodes present in heaviest child of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e. \u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eparent\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e : Stores the Subtree_size of all nodes on the path from root to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e. \u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eouter\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e : Stores the Subtree_size of all nodes in outer tree which are not on path from root to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cbr /\u003eGo through this blog post before reading further \u003ca href\u003d\"//codeforces.com/blog/entry/44351\"\u003e(http://codeforces.com/blog/entry/44351)\u003c/a\u003e. \u003cbr /\u003e \u003cbr /\u003eMaintaining the Maps \u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003echildren\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eparent\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e are initialised to empty while \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eouter\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e contains Subtree_size of all nodes in the tree.\u003cbr /\u003e \u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eparent\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e : This can be easily maintained by inserting the Subtree_size of node in map when we enter a node in dfs and remove it when we exit it. \u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003echildren\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003echildren\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e can be maintained by using the dsu on tree trick mentioned in blogpost. \u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eouter\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e : When we insert a node\u0027s subtree_size in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003echildern\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eparent\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e we can remove the same from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eouter\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and similarly when we insert a node\u0027s Subtree_size in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003echildern\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eparent\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e we can remove the same from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eouter\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cbr /\u003eRefer to HLD style implementation in blogpost for easiest way of maintaining \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eouter\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. \u003cbr /\u003eRefer to code below for exact point of insertions and deletions into above mentioned \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e maps.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nconst int N \u003d 100005;\nvector\u0026lt;int\u0026gt; adj[N];\nint sz[N], ans[N];\nint n, root;\nbool big[N];\nmap\u0026lt;int,int\u0026gt; mp, mpo, par;\n\nvoid getsz(int s){\n    sz[s] \u003d 1;\n    ans[s] \u003d n - 1;\n    for(auto it : adj[s]){\n        getsz(it);\n        sz[s] +\u003d sz[it];\n    }\n    mpo[sz[s]]++;\n}\n\nvoid bs(map\u0026lt;int, int\u0026gt; \u0026amp;mp1, int l, int r, int mi, int s, int off){\n    if(mi \u003d\u003d n - 1) return;\n    int ma \u003d r;\n    while(r - l \u0026gt; 1){\n        int mid \u003d (r + l) / 2;\n        auto it \u003d mp1.lower_bound(ma - mid + off);\n        if(it \u003d\u003d mp1.end()) \n            l \u003d mid;\n        else if(mi + it-\u0026gt;first \u0026lt;\u003d mid + off) \n            r \u003d mid;\n        else \n            l \u003d mid;\n    }\n    ans[s] \u003d min(ans[s], r);\n}\n\nvoid add(int s){\n    mp[sz[s]]++;\n    if(mpo[sz[s]] \u003d\u003d 1)\n        mpo.erase(sz[s]);\n    else\n        mpo[sz[s]]--;\n    for(auto it:adj[s])\n        if(!big[it]) add(it);\n}\n\nvoid rem(int s){\n    mpo[sz[s]]++;\n    if(mp[sz[s]] \u003d\u003d 1)\n        mp.erase(sz[s]);\n    else\n        mp[sz[s]]--;\n    for(auto it:adj[s])\n        if(!big[it]) rem(it);\n}\n\nvoid dfs(int s, bool isbig){\n    par[sz[s]]++;\n    if(mpo[sz[s]] \u003d\u003d 1)\n        mpo.erase(sz[s]);\n    else\n        mpo[sz[s]]--;\n    int ma \u003d -1, sma \u003d -1, mac \u003d -1, mi \u003d n - 1;\n    for(auto it:adj[s]){\n        if(sz[it]\u0026gt;ma){\n            sma \u003d ma;\n            ma \u003d sz[it];\n            mac \u003d it;\n        }\n        else if(sz[it]\u003d\u003dma)\n            sma \u003d ma;\n        else\n            sma \u003d max(sma,sz[it]);\n        mi \u003d min(mi,sz[it]);\n    }\n    if(s !\u003d root)\n        mi \u003d min(mi,n-sz[s]);\n    for(auto it:adj[s]){\n        if(it!\u003dmac)\n            dfs(it,0);\n    }\n    if(mac !\u003d -1){\n        big[mac]\u003dtrue;\n        dfs(mac,1);\n    }\n    if(ma \u0026gt;\u003d n - sz[s]){\n        sma \u003d max(sma, n - sz[s]);\n        bs(mp, sma - 1, ma, mi, s, 0);\n    }\n    mpo[sz[s]]++;\n    add(s);\n    if(par[sz[s]] \u003d\u003d 1)\n        par.erase(sz[s]);\n    else\n        par[sz[s]]--;\n    if(n-sz[s] \u0026gt; ma){\n        sma \u003d ma;\n        bs(mpo, sma - 1, n - sz[s], mi, s, 0);\n        bs(par, sma - 1, n - sz[s], mi, s, sz[s]);\n    }\n    if(mac !\u003d -1)\n        big[mac] \u003d false;\n    if(!isbig) rem(s);\n}\n\nint main(){\n    int i, u, v;\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    for(i \u003d 0; i \u0026lt; n; ++i){\n        scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;u ,\u0026amp;v);\n        if(u \u003d\u003d 0) root \u003d v - 1;\n        else\n            adj[u - 1].push_back(v - 1);\n    }\n    getsz(root);\n    dfs(root, 1);\n    for(i \u003d 0; i \u0026lt; n; ++i)\n        printf(\u0026quot;%d\\n\u0026quot;, ans[i]);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cbr /\u003e \u003cstrong\u003eComplexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e","tags":["#editorial"]}}