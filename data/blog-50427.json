{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1487081034,"rating":-4,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1487082885,"id":50427,"title":"\u003cp\u003eSolutions to Codeforces Beta Round #25, A, B, C, D\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA. IQ test\u003c/p\u003e\u003cp\u003eFor a given array consisting of positive integers, the problem asks to find out the unique number which is different from all the other ones after implementing modulo-2 operations. We can count the number of odd integer and even integer as num_o and num_e, respectively, while storing any arbitrary positions at which an odd number and an even number appear. As the \u0026quot;unique\u0026quot; number only appears one single time, we can find out num_o\u003d\u003d1 or num_e\u003d\u003d1, and output the stored positions as the answer.\u003c/p\u003e\u003cp\u003eB. Phone numbers\u003c/p\u003e\u003cp\u003eThis problem can be solved through a classification based on the value of n modulo 3, which contains the following cases:\u003c/p\u003e\u003cp\u003e1) n%3\u003d\u003d0; the phone number can be seperated into groups of 3 digits;\u003c/p\u003e\u003cp\u003e2) n%3\u003d\u003d1; we can seperate the first 4 digits into 2 groups of 2 digits, while the following digits can be seperated into groups of 3 digits;\u003c/p\u003e\u003cp\u003e3) n%3\u003d\u003d2; the first 2 digits of the phone number is output, and the following digits can be seperated into groups of 3 digits\u003c/p\u003e\u003cp\u003eC. Roads in Berland\u003c/p\u003e\u003cp\u003eThe solution is similar to the famous Floyd Algorithm. For two given cities S and T, let us consider how their minimum distance can be altered if a new road between A and B is built. We can imagine that there is a map which describes the roads between each pair of cities (if they exist), although this map is not explicitly known or given. For any given route from S to T, if this route does not use the newly built road betwwen A and B, the minimum distance between S and T stays the same, since nothing changes. Thus, the minimum distance might be updated if and only if the newly built road betwwen A and B is used. Then, the distance between S and T, d_m[S,T] can be divided into three independent parts, S to A, A to B and B to T. Note that according to the Minimum-Distance-Table, the minimum distance between S and T is d_m[S,A]+d_new[A,B]+d_m[B,T] for the current route, where d_new[A,B] denotes the length of the newly built road between A and B. Be careful that there is another feasible route which uses the newly built road as follows: S to B, B to A and A to T, which contributes a distance of d_m[S,B]+d_new[B,A]+d_m[A,T].\u003c/p\u003e\u003cp\u003eFinally, we should also notice that the newly built road may be \u0026quot;farther\u0026quot; then the old one. Therefore, the minimum distance between S and T should be d_m[S,T]\u003dMIN{d_m[S,T], d_m[S,A]+d_new[A,B]+d_m[B,T], d_m[S,B]+d_new[B,A]+d_m[A,T]}. We have to implement the above operations for every pair of cities, which gives complexity O(n^2). As K roads are newly built, the total complexity is O(n^2*k). A last question to consider is the range of the final answer. Let us construct a worst case. Suppose that the cities form a linked list, where each node has exactly one single father node (except for the head node) and one child node (except for the tail node). Then, the largest answer can be \u003c/p\u003e\u003cp\u003e1000*(n*(n-1)/2+(n-1)*(n-2)/2+...+2*1/2)\u003d1000/2*( (n-1)^2+(n-1)+(n-2)^2+(n-2)+...+1^1+1 )\u003d1000/2*n*(n-1)*(n+1)/3\u0026gt;2^32 (choosing n\u003d1000). Therefore, we should adopt the \u0026quot;long long int\u0026quot; type to compute the final answer.\u003c/p\u003e\u003cp\u003eD. Roads not only in Berland\u003c/p\u003e\u003cp\u003eI think perhaps I have used a little bit complicated method. One can refer to Union-Find (I am not sure of this terminology) for another simpler solution.\u003c/p\u003e\u003cp\u003eI adopt DFS (depth first search) for this problem. During DFS, when wemeet a node that has been visited, it means that this edge (might be referred to as backward edge) is not necessary to keep the current component connected, and thus this edge can be removed. However, there are seceral details that should be considered (all the following arguments are based on DFS).\u003c/p\u003e\u003cp\u003e1) Suppose that node A is the parent node of node B, and node B is the currently processed node. As the edge is not directed, node A will be visited again, but we cannot say that this edge is not necessary. The edge is not necessary if and only if the following two conditions are satisfied: a) a node that has been visited is met; b) this node is not the parent node of the currently processed node;\u003c/p\u003e\u003cp\u003e2) Any backward edge may be visited twice. Thus, they should be stored only once when it is visited for the first time;\u003c/p\u003e\u003cp\u003e3) As the graph may consist of several connnected components, it is likely to implement the DFS for several times. Whenever a new DFS is implemented, we can select any one single node belonging to this component as the \u0026quot;delegate\u0026quot;;\u003c/p\u003e\u003cp\u003e4) Store all the backward edges and all the \u0026quot;delegates\u0026quot;. The final answer is: remove all the backward edges and build new edges to connect every connected-component.\u003c/p\u003e\u003c/div\u003e","tags":["dfs","floyd","union-find"]}}