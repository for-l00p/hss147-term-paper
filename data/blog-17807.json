{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1431195843,"rating":3,"authorHandle":"dorellin","modificationTimeSeconds":1431318159,"id":17807,"title":"\u003cp\u003eGEMA Beta Round #2 — Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eParabéns a todos que participaram do [contest:203159]. Os pontos já foram atualizados e podem ser vistos aqui: \u003ca href\u003d\"http://gemaicmc.github.io/\"\u003ehttp://gemaicmc.github.io/\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eResultado final: [standings:203159]\u003c/p\u003e\u003cp\u003eNo momento, os três primeiros colocados são:\u003c/p\u003e\u003cp\u003e\u003ca class\u003d\"rated-user user-black\" href\u003d\"/profile/samuelfgs96\" title\u003d\"Unrated, samuelfgs96\"\u003esamuelfgs96\u003c/a\u003e \u003cbr /\u003e \u003ca class\u003d\"rated-user user-black\" href\u003d\"/profile/BolachaICMC\" title\u003d\"Unrated, BolachaICMC\"\u003eBolachaICMC\u003c/a\u003e \u003cbr /\u003e \u003ca class\u003d\"rated-user user-black\" href\u003d\"/profile/vcandiani\" title\u003d\"Unrated, vcandiani\"\u003evcandiani\u003c/a\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eA prova tinha 6 problemas, alguns muito mais complicados que outros. Segue uma análise de cada um deles. \u003cbr /\u003e\u003c/p\u003e\u003ch4\u003eProblema A: O Mais Secreto Lugar de Todos\u003c/h4\u003e\u003cp\u003e\u003cem\u003eCriador\u003c/em\u003e: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/lfdorelli\" title\u003d\"Expert lfdorelli\"\u003elfdorelli\u003c/a\u003e\u003c/p\u003e\u003cp\u003eA idéia desse problema era trabalhar com matrizes. Algumas pessoas se confundiram no enunciado, com o conceito de olhar para direita, trás, frente e esquerda. As direções são assim: direita (\u0026gt;), esquerda (\u0026lt;), trás (^) e frente (V). \u003c/p\u003e\u003cp\u003eMuitas pessoas usaram \u003cstrong\u003ealocação dinâmica\u003c/strong\u003e na prova. Era mais simples alocar espaço pra matriz da entrada assim:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003econst int N \u003d 101;\nchar in[N][N];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNotem o N \u003d 101. Isso porque uma das formas mais simples de ler a entrada desse problema era:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (int i \u003d 0; i \u0026lt; n; ++i)\n    scanf(\u0026quot;%s\u0026quot;, in[i]); // ou cin \u0026gt;\u0026gt; in[i];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eUm erro bem comum foi utilizar \u003cstrong\u003ebreak\u003c/strong\u003e dentro do for mais interno. Quando se utiliza break, apenas o for exatamente acima é quebrado. Então, no exemplo abaixo, o break interrompe apenas o loop em j, e o código continua executando o for externo.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (int i \u003d 0; i \u0026lt; n; ++i)\n  for (int j \u003d 0; j \u0026lt; m; ++j) {\n      if (bla bla ...) {\n        break;\n      }\n  }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEm relação ao problema em si: a solução esperada era passar por todas as posições da matriz, e marcar em algum lugar (pode ser uma matriz auxiliar) as posição que são vistas. Algo nessa linha:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (int i \u003d 0; i \u0026lt; n; ++i)\n  for (int j \u003d 0; j \u0026lt; m; ++j)\n    if (in[i][j] \u003d\u003d \u0027D\u0027) {\n      // \u0027D\u0027 marca todas as posições à direita... (j+k)\n      for (int k \u003d j; j \u0026lt; m; ++k) ans[i][j + k] \u003d 1;\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eUma solução que usa essa idéia, tem complexidade \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e. Para entender isso, lembrem do seguinte código: \u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (int i \u003d 0; i \u0026lt; n; ++i)\n  for (int j \u003d i + 1; j \u0026lt; n; ++j)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eA complexidade desse loop, apesar de j começar de i+1, é \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e, o que não é uma melhora substancial em relação ao código com j começando de 0. Isso é porque o for de dentro será executado \u003cspan class\u003d\"tex-span\"\u003e1 + 2 + .. + \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e vezes, que é \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e. Fica exercício entender porque o pior caso desse problema é similar a essa situação. \u003c/p\u003e\u003cp\u003eO problema C caía na mesma situação, mas lá não era possível passar no tempo. Aqui, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e \u003d 100\u003c/span\u003e, e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e, que é mais que suficiente para resolver o problema em 1s. \u003c/p\u003e\u003cp\u003eSe vocês precisarem de mais uma leitura sobre complexidade, recomendo o \u003ca href\u003d\"https://www.topcoder.com/community/data-science/data-science-tutorials/computational-complexity-section-1/\"\u003eTutorial do Topcoder\u003c/a\u003e\u003c/p\u003e\u003ch4\u003eProblema C: A Grande Escada de Acreland\u003c/h4\u003e\u003cp\u003e\u003cem\u003eCriador\u003c/em\u003e: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/tomasf\" title\u003d\"Expert tomasf\"\u003etomasf\u003c/a\u003e\u003c/p\u003e\u003cp\u003eNeste problema era necessário contar os degraus em que Roberterson podia tirar a foto do jeito que ele queria. Sendo que um degrau de altura \u003cstrong\u003eX\u003c/strong\u003e deveria ser contado se existisse um degrau anterior com altura \u003cstrong\u003eY\u003c/strong\u003e tal que \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e + \u003ci\u003eP\u003c/i\u003e \u003d \u003ci\u003eX\u003c/i\u003e + \u003ci\u003eH\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eMuitas pessoas tentaram uma solução \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e durante o contest, que está correta, maaas não é rápida o suficiente pois a entrada podia conter até \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e degraus.\u003c/p\u003e\u003cp\u003ePara resolver este problema de forma mais rápida, era necessário notar que se o Roberterson está na posição \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, e um degrau na posição \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e é muito baixo para colocar o pedestal, então ele também será muito baixo se o Roberterson estiver na posição \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/span\u003e, pois a altura do degrau na posição \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/span\u003e é maior que a do degrau na posição \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. Ou seja, uma vez que um degrau fica baixo demais, ele não precisa ser mais verificado.\u003c/p\u003e\u003cp\u003ePara implementar uma solução baseada nesta ideia, uma possibilidade é usar duas variáveis que guardam o índice de duas posições no vetor de altura dos degraus (vetor v). Podemos chamar estas variáveis de p1 e p2. Primeiramente, p1 e p2 podem ser inicializados com os valores 0 e 1.\u003c/p\u003e\u003cp\u003eA partir daí, existem apenas 3 casos:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003e\u003cstrong\u003ev[p1] + P \u003d v[p2] + H\u003c/strong\u003e : Isso significa que o degrau em p2 é um degrau válido, então a resposta pode ser incrementada. Como já sabemos que o degrau em p2 é válido, então p2 também pode ser incrementado.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003cstrong\u003ev[p1] + P \u0026lt; v[p2] + H\u003c/strong\u003e : Isso significa que o degrau em p1 é baixo demais, então devemos incrementar p1.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003cstrong\u003ev[p1] + P \u0026gt; v[p2] + H\u003c/strong\u003e : Isso significa que o degrau em p2 é baixo demais, então devemos incrementar p2.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eIsso deve ser feito até que p2 saia dos limites do vetor.\u003c/p\u003e\u003cp\u003eTá aí um exemplo de implementação:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint p1 \u003d 0;\nint p2 \u003d 1;\nint resposta \u003d 0;\nwhile(p2 \u0026lt; v.size()){\n\tif(v[p1] + P \u003d\u003d v[p2] + H){\n\t\tresposta++;\n\t\tp2++;\n\t}else if(v[p1] + P \u0026lt; v[p2] + H){\n\t\tp1++;\n\t}else if(v[p1] + P \u0026gt; v[p2] + H){\n\t\tp2++;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eA complexidade deste algoritmo é \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e, pois p1 e p2 são incrementados em toda iteração e o algoritmo para quando p2 chega no fim do vetor.\u003c/p\u003e\u003cp\u003eEste método é chamado de \u003cstrong\u003etwo-pointers\u003c/strong\u003e e não é difícil achar problemas que precisam dele para serem resolvidos.\u003c/p\u003e\u003cp\u003eEsse problema também podia ser resolvido com soluções baseadas em ordenação ou busca binária que têm complexidade \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e, também rápido o suficiente.\u003c/p\u003e\u003ch4\u003eProblemas B e D: Lubuntu(inho) e a (Des)Criptografia\u003c/h4\u003e\u003cp\u003e\u003cem\u003eCriador\u003c/em\u003e: \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/rodz\" title\u003d\"Specialist rodz\"\u003erodz\u003c/a\u003e\u003c/p\u003e\u003cp\u003eApesar de haver mais de uma maneira de resolver esses dois problemas, existe uma ideia de solução que pode ser utilizada para ambos e, assim, o código que resolve um problema pode passar a resolver o outro com apenas uma alteração.\u003c/p\u003e\u003cp\u003eConsidere o problema B — queremos criptografar uma palavra dividindo-a em colunas de tamanho \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e sendo um divisor do tamanho da palavra. Iremos iterar sobre as letras da palavra de forma a percorrer (e imprimir) suas letras diretamente na ordem criptografada. \u003c/p\u003e\u003cp\u003eÉ certo que as primeiras \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e letras (as letras de índice \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e) estarão na primeira coluna, as próximas \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e (índices de \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e a \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e) na segunda coluna, e assim por diante. Queremos imprimir as colunas lendo-as \u0026quot;linha por linha\u0026quot;. Ou seja, primeiro a primera letra da primeira coluna (índice \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e), depois a primeira letra da segunda coluna (índice \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e), ..., segunda letra da primeira coluna (índice \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e), segunda letra da segunda coluna (índice \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + 1\u003c/span\u003e), e assim por diante. Isso pode ser feito com dois laços aninhados. O mais externo será relativo a que posição das colunas queremos imprimir (da posição \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e até a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e), e o mais interno será responsável por \u0026quot;andar\u0026quot; pelas colunas. \u003c/p\u003e\u003cp\u003eO código abaixo exemplifica essa solução:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint N;\nstring s;\nint i, j;\ncin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; s;\nint jump \u003d N;\nfor (j \u003d 0; j \u0026lt; jump; j++)  //para cada posição j nas colunas...\n{\n\tfor (i \u003d 0; i+j \u0026lt; s.size(); i+\u003djump)    //...passar por todas as colunas imprimindo o caractere em sua posição j.\n\t\tcout \u0026lt;\u0026lt; s[i+j];\n}\ncout \u0026lt;\u0026lt; \u0027\\n\u0027;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eUm raciocínio perfeitamente análogo pode ser aplicado, agora, para o problema D. No caso dele, temos uma palavra a qual precisamos dividir em \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u0027\u003c/span\u003e linhas e depois ler essas linhas \u0026quot;coluna por coluna\u0026quot;. Se, nos parágrafos acima, as palavras \u0026quot;linha\u0026quot; forem substituídas por \u0026quot;coluna\u0026quot; e vice-versa, será possível perceber que a explicação passará a se encaixar justamente na resolução do problema D. É importante ressaltar que, assim como precisávamos conhecer o tamanho da coluna no problema B, precisamos conhecer o tamanho da linha no problema D (pois a \u0026quot;linha\u0026quot; agora é o que era a \u0026quot;coluna\u0026quot; antes). Como o problema nos dá a quantidade de linhas e sabemos que todas as linhas tem o mesmo tamanho (pois o tamanho da palavra é múltiplo de \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u0027\u003c/span\u003e), para obter tal tamanho basta dividir o tamanho da palavra por \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u0027\u003c/span\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint N;\nstring s;\nint i, j;\ncin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; s;\nint jump \u003d s.size()/N;\nfor (j \u003d 0; j \u0026lt; jump; j++)  //para cada posição j nas colunas...\n{\n\tfor (i \u003d 0; i+j \u0026lt; s.size(); i+\u003djump)    //...passar por todas as colunas imprimindo o caractere em sua posição j.\n\t\tcout \u0026lt;\u0026lt; s[i+j];\n}\ncout \u0026lt;\u0026lt; \u0027\\n\u0027;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}