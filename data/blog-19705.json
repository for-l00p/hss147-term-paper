{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1439232348,"rating":110,"authorHandle":"Um_nik","modificationTimeSeconds":1439234066,"id":19705,"title":"\u003cp\u003eCodeforces Round #315 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/569/problem/A\" title\u003d\"Codeforces Round 315 (Div. 2)\"\u003e569A - Music\u003c/a\u003e\u003c/p\u003e\u003cp\u003eSuppose we have downloaded \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e seconds of the song and press the \u0027play\u0027 button. Let\u0027s find how many seconds will be downloaded when we will be forced to play the song once more. \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cd/86/cd86b5195a224e39f71c832929521f774f85a098.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Hence \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003eqS\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSolution: let\u0027s multiply \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e while \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u0026lt; \u003ci\u003eT\u003c/i\u003e\u003c/span\u003e. The answer is the amount of operations.\u003c/p\u003e\u003cp\u003eComplexity — \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3b/ed/3bed93a5b5ee703d68655ae08ca6fd45244cd20c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/569/problem/B\" title\u003d\"Codeforces Round 315 (Div. 2)\"\u003e569B - Inventory\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s look at the problem from another side: how many numbers can we leave unchanged to get permutation? It is obvious: these numbers must be from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and they are must be pairwise distinct. This condition is necessary and sufficient.\u003c/p\u003e\u003cp\u003eThis problem can be solved with greedy algorithm. If me meet the number we have never met before and this number is between \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, we will leave this number unchanged. To implement this we can use array where we will mark used numbers.\u003c/p\u003e\u003cp\u003eAfter that we will look over the array again and allocate numbers that weren\u0027t used.\u003c/p\u003e\u003cp\u003eComplexity — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/568/problem/A\" title\u003d\"Codeforces Round 315 (Div. 1)\"\u003e568A - Primes or Palindromes?\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIt is known that amount of prime numbers non greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is about \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/66/45/66454496b141b3f3afce3e12c6e44c9163b8111f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eWe can also found the amount of palindrome numbers with fixed length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e — it is about \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9e/27/9e2757d1169af957b9d782353ef1f83de938af92.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e which is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eTherefore the number of primes asymptotically bigger than the number of palindromic numbers and for every constant \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e there is an answer. Moreover, for this answer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e the next condition hold: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f8/03/f803d639be28ee1797db379bbd978729e54aba16.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. In our case \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u0026lt; 10\u003csup class\u003d\"upper-index\"\u003e7\u003c/sup\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFor all numbers smaller than \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e7\u003c/sup\u003e\u003c/span\u003e we can check if they are primes (via sieve of Eratosthenes) and/or palindromes (via trivial algorithm or compute reverse number via dynamic approach). Then we can calculate prefix sums (\u003cspan class\u003d\"tex-span\"\u003eπ(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003erub\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e) and find the answer using linear search.\u003c/p\u003e\u003cp\u003eFor \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e ≤ 42\u003c/span\u003e answer is smaller than \u003cspan class\u003d\"tex-span\"\u003e2·10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eComplexity — \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/2e/06/2e06d40b595c7ad9129b20b28073d069c9e15ad5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/568/problem/B\" title\u003d\"Codeforces Round 315 (Div. 1)\"\u003e568B - Symmetric and Transitive\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s find Johnny\u0027s mistake. It is all right in his proof except ``If \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cd/48/cd489cc594adbebb5e67b3e699f58e8db3bd5ac8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u0027\u0027 part. What if there is no such \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e for an given \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e? Then obviously \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/31/59/31597ba081ec3d6b256786d371884668f1335900.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e otherwise we\u0027ll take \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe can see that our binary relation is some equivalence relation which was expanded by some \u0026quot;empty\u0026quot; elements. For \u0026quot;empty\u0026quot; element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e there is no such \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cd/48/cd489cc594adbebb5e67b3e699f58e8db3bd5ac8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eThus we can divide our solution into two parts:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eCount the number of equivalence relations on sets of size \u003cspan class\u003d\"tex-span\"\u003e0, 1, ..., \u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eFor every size count the number of ways to expand it with some \u0026quot;empty\u0026quot; elements.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eWe can define equivalence relation using its equivalence classes.\u003c/p\u003e\u003cp\u003eSo first part can be solved using dynamic programming: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eelems\u003c/i\u003e][\u003ci\u003eclasses\u003c/i\u003e]\u003c/span\u003e — the numbers of ways to divide first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eelems\u003c/i\u003e\u003c/span\u003e elements to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eclasses\u003c/i\u003e\u003c/span\u003e equivalence classes. When we handle next element we can send it to one of the existing equivalence classes or we can create new class.\u003c/p\u003e\u003cp\u003eLet\u0027s solve second part. Consider set of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e. We have found that there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eeq\u003c/i\u003e[\u003ci\u003em\u003c/i\u003e]\u003c/span\u003e ways to build equivalence relation on this set. We have to add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003em\u003c/i\u003e\u003c/span\u003e \u0026quot;empty\u0026quot; elements to this set. The number of ways to choose their positions is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. We can calculate all the binomial coefficients using Pascal\u0027s triangle.\u003c/p\u003e\u003cp\u003eSo the answer to the problem is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cc/bb/ccbbbb7188eb46d736aa40228a2125f819b3173d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eComplexity — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/568/problem/C\" title\u003d\"Codeforces Round 315 (Div. 1)\"\u003e568C - New Language\u003c/a\u003e\u003c/p\u003e\u003cp\u003eSuppose we have fixed letters on some positions, how can we check is there a way to select letters on other positions to build a word from the language? The answer is 2-SAT. Let\u0027s see: for every position there is two mutually exclusive options (vowel or consonant) and the rules are consequences. Therefore we can do this check in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e time.\u003c/p\u003e\u003cp\u003eLet\u0027s decrease the length of the prefix which will be the same as in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e. Then the next letter must be strictly greater but all the next letters can be any. We can iterate over all greater letters and then check if we can made this word the word from the language (via 2-SAT). Once we have found such possibilty we have found the right prefix of the answer. After that we can increase the length of the fixed prefix in a similar way. This solution works in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003eΣ )\u003c/span\u003e time. We can divide this by \u003cspan class\u003d\"tex-span\"\u003eΣ\u003c/span\u003e simply try not all the letter but only the smallest possible vowel and the smallest possible consonant.\u003c/p\u003e\u003cp\u003eAnd you should remember about the case when all the letters are vowel (or all the letters are consonant).\u003c/p\u003e\u003cp\u003eComplexity — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/568/problem/D\" title\u003d\"Codeforces Round 315 (Div. 1)\"\u003e568D - Sign Posts\u003c/a\u003e\u003c/p\u003e\u003cp\u003eSuppose, that solution exist. In case \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≤ \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e we can put one signpost on each road. In other case let\u0027s choose any \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e roads. By the Dirichlet\u0027s principle there are at least two roads among selected, which have common signpost. Let\u0027s simple iterate over all variants with different two roads. After choosing roads \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, we will remove all roads, intersecting with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e in common points and reduce \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e in our problem. This recursive process solves the problem (if solution exist).\u003c/p\u003e\u003cp\u003eComplexity of this solution — \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f0/63/f063d9ad3a9050c9b731027bce26d74a3a7581cf.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. If implement this solution carefully — you will get AC \u003d)\u003c/p\u003e\u003cp\u003eBut in case of TL we can add one improvement to our solution. Note, that if we find point, which belongs to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e or more roads, then we must include this point to out answer. For sufficiently large \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e (for example, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u0026gt; 30\u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e) this point always exist and we can find it using randomize algorithm. If solution exist, probability that two arbitrary roads are intersects in such a point not less than \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a5/31/a5319ec7c549e39ea9c941167f1023b5b6172656.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Because of it, if we \u003cspan class\u003d\"tex-span\"\u003e100\u003c/span\u003e times pick two random roads, then with probability \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/71/55/71559c2544d27da13c128afa8b38a5c0dcf3c6fe.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e such a point will be found and we can decrease \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eAll operations better to do in integers.\u003c/p\u003e\u003cp\u003eComplexity — \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/16/42/16428edf91593afebcb2b424419d2868b413f7bc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/568/problem/E\" title\u003d\"Codeforces Round 315 (Div. 1)\"\u003e568E - Longest Increasing Subsequence\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s calculate array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e[\u003ci\u003elen\u003c/i\u003e]\u003c/span\u003e — minimal number that can complete increasing subsequence of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e. (This is one of the common solution for LIS problem).\u003c/p\u003e\u003cp\u003eElements of this array are increasing and we can add new element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e to processed part of sequence as follows:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003efind such index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] ≤ \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1] ≥ \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003elet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1] \u003d \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eWe can process this action in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time.\u003c/p\u003e\u003cp\u003eWhen we handle a gap, we must try to insert all numbers from set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. If we sort elements of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e in advance, then we can move with two iterators along arrays \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e and relax all needed values as explained above. This case requires \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e time.\u003c/p\u003e\u003cp\u003eAuthors implied solution with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e space complexity for answer restoring. We can do this in the following way:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eTogether with array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e we will store array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eindex\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003elen\u003c/i\u003e]\u003c/span\u003e — index of element, which complete optimal increasing subsequence of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e. If this subsequence ends in a gap — we will store \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eAlso, we will store for every not gap — length of LIS(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elenLIS\u003c/i\u003e[\u003ci\u003epos\u003c/i\u003e]\u003c/span\u003e), which ends in this position (this is simply calculating while processing array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e) and position(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eprevIndex\u003c/i\u003e[\u003ci\u003epos\u003c/i\u003e]\u003c/span\u003e) of previous element in this subsequence (if this elements is gap, we store \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e)\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eNow we will start recovery the answer with this information.\u003c/p\u003e\u003cp\u003eWhile we are working with not gaps — it\u0027s all right. We can simply restore LIS with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eprevIndex\u003c/i\u003e[\u003ci\u003epos\u003c/i\u003e]\u003c/span\u003e array. The main difficulty lies in processing gaps. If value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eprevIndex\u003c/i\u003e[\u003ci\u003epos\u003c/i\u003e]\u003c/span\u003e in current position equal to \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e — we know, that before this elements must be one or more gaps. And we can determine which gaps and what values from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e we must put in them as follows:\u003c/p\u003e\u003cp\u003eLet suppose that we stand at position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e (and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eprevIndex\u003c/i\u003e[\u003ci\u003er\u003c/i\u003e] \u003d  - 1\u003c/span\u003e). Now we want to find such position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e (which is not gap), that we can fill exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elenLIS\u003c/i\u003e[\u003ci\u003er\u003c/i\u003e] - \u003ci\u003elenLIS\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e]\u003c/span\u003e gaps between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e with increasing numbers from interval \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e]..\u003ci\u003ea\u003c/i\u003e[\u003ci\u003er\u003c/i\u003e])\u003c/span\u003e. Position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e we can simply iterates from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e - 1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e and with it calculating gaps between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e. Check the condition described above we can produce via two binary search query to array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFew details:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eHow do we know, that between positions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e we can fill gaps in such a way, that out answer still the best?\u003cbr /\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecountSkip\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e — count gaps on interval \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003el\u003c/i\u003e..\u003ci\u003er\u003c/i\u003e)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecountBetween\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e — count different numbers from set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, lying in the range \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e..\u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e.\u003cbr /\u003eThen, positions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e are good only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elenLIS\u003c/i\u003e[\u003ci\u003er\u003c/i\u003e] - \u003ci\u003elenLIS\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e] \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003ecountSkip\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e), \u003ci\u003ecountBetween\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e], \u003ci\u003ea\u003c/i\u003e[\u003ci\u003er\u003c/i\u003e]))\u003c/span\u003e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecountSkip\u003c/i\u003e\u003c/span\u003e we can calculate while iterates position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecountBetween\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e) \u003d \u003ci\u003emax\u003c/i\u003e(0, \u003ci\u003elower\u003c/i\u003e_\u003ci\u003ebound\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e) - \u003ci\u003eupper\u003c/i\u003e_\u003ci\u003ebound\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e))\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eWhat to do, is LIS ends or begins in gaps?\u003cbr /\u003eThis case we can solve by simply adding \u003cspan class\u003d\"tex-span\"\u003e - ∞\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e + ∞\u003c/span\u003e in begin and end of out array.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eComplexity — \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/68/4b/684b01421968cc606af9975108d14bda7a941962.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Memory — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e","tags":[]}}