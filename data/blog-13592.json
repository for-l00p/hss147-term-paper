{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1409203271,"rating":3,"authorHandle":"LouisCK","modificationTimeSeconds":1409203271,"id":13592,"title":"\u003cp\u003eHow do I optimize my solution for Restore Graph? (404 â€” C)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThis is my \u003ca href\u003d\"//codeforces.com/contest/404/submission/7610732\"\u003esolution\u003c/a\u003e to this problem \u003ca href\u003d\"//codeforces.com/contest/404/problem/C\"\u003eRestore Graph\u003c/a\u003e. I have used an approach which seems similar to that suggested in the editorial (which I translated from Russian) but I can\u0027t really understand it. Here\u0027s what I have done\u003c/p\u003e\u003cp\u003e1) Created a HashMap that maps distances from roots to nodes. For example, if I put in map[1], it will give me a list of nodes that are at distance 1 from the root. \u003c/p\u003e\u003cp\u003e2) Start from the root vertex for which D[start] \u003d 0. I do a DFS search from the root. For each node, which is at distance dist, I check for neighbours that are at distance dist + 1 and visit only k of them if not already visited. Each time I visit another node, I add (current_node, neighbour) to the answer set.\u003c/p\u003e\u003cp\u003e3) That\u0027s about it. At the end, I check if the size of the visited map is not equal to n, then output -1. Otherwise I output the answers.\u003c/p\u003e\u003cp\u003eI am getting TLE on the 7th test case which has a considerable input size and I am using Java 8. Is my algorithm too slow or is it because of the language?\u003c/p\u003e\u003cp\u003eThanks!\u003c/p\u003e\u003c/div\u003e","tags":["tle","help","optimization"]}}