{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1504818582,"rating":8,"authorHandle":"1am","modificationTimeSeconds":1505157614,"id":54399,"title":"\u003cp\u003eTutorial ACM ICPC 2011–2012, NEERC \u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eC — Cube Coloring\u003c/h1\u003e\u003cp\u003eThis problem can be solved by brute forcing the 6 faces of the cube with their corresponding string. The check function is to see if the string that represents that face has the correct adjacent faces.\u003c/p\u003e\u003cp\u003eIf the arrangement works, that cube is a possible solution. However, the problem requires you to output a maximum of 2 unique cubes, such that a rotation of one does not equal the other. So after we get one solution, rotate that cube in all 24 orientations, and add them into a set of strings to guarantee uniqueness. \u003c/p\u003e\u003cp\u003eHere are two similar solutions, but each with a different implementation to rotate the cube: \u003cbr /\u003e \u003ca href\u003d\"https://ideone.com/owthAe\"\u003ehttps://ideone.com/owthAe\u003c/a\u003e \u003cbr /\u003e \u003ca href\u003d\"https://ideone.com/3hhaMW\"\u003ehttps://ideone.com/3hhaMW\u003c/a\u003e \u003cbr /\u003e and \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Vendetta.\" title\u003d\"Candidate Master Vendetta.\"\u003eVendetta.\u003c/a\u003e\u0027s code: \u003ca href\u003d\"https://ideone.com/XOkRMn\"\u003ehttps://ideone.com/XOkRMn\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eH — High Security\u003c/h1\u003e\u003cp\u003eFor every index, change the current character to a \u0027#\u0027 or keep it the same (2 ^5). Keep a map for the frequency of every string, then get TLE and hash the string into an integer.\u003c/p\u003e\u003cp\u003eLet ans[0] equal the number of strings that equal current.\u003c/p\u003e\u003cp\u003eGet ans[1] from map (frequency of all strings generated using one hash). You will notice that you added a string that equals the current one 5 times, even though they don\u0027t differ at all.\u003c/p\u003e\u003cp\u003eThat is because there are (5 choose 1) ways of putting a \u0027#\u0027 on a string that equals current one. So from ans[1] decrease ans[0]* (5 choose 1). \u003c/p\u003e\u003cp\u003eGet ans[2] using map again, and decrease from it ans[1] * (4 choose 1) and ans[0] * (5 choose 2).\u003c/p\u003e\u003cp\u003eContinue this process for ans [3], ans[4], and ans[5]. And then for all strings.\u003c/p\u003e\u003cp\u003eHere are two different implementations: \u003cbr /\u003e \u003ca href\u003d\"https://ideone.com/gpVewS\"\u003ehttps://ideone.com/gpVewS\u003c/a\u003e \u003cbr /\u003e \u003ca href\u003d\"https://ideone.com/k2G6SH\"\u003ehttps://ideone.com/k2G6SH\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eJ — John’s Inversions\u003c/h1\u003e\u003cp\u003eSort one face, count the number of inversions in the second using segment tree, BIT, or merge sort :p\u003c/p\u003e\u003cp\u003eWe explained proof, I don\u0027t feel like writing it. If you want it, write a comment.\u003c/p\u003e\u003cp\u003eSegment tree code with compression and unnecessary stuff : \u003ca href\u003d\"https://ideone.com/m8HBS5\"\u003ehttps://ideone.com/m8HBS5\u003c/a\u003e \u003cbr /\u003e BIT Code : \u003ca href\u003d\"https://ideone.com/x0CIxx\"\u003ehttps://ideone.com/x0CIxx\u003c/a\u003e \u003cbr /\u003e \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Vendetta.\" title\u003d\"Candidate Master Vendetta.\"\u003eVendetta.\u003c/a\u003e\u0027s magical merge sort code: \u003ca href\u003d\"https://ideone.com/gyGdpM\"\u003ehttps://ideone.com/gyGdpM\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eG — Galaxy Interconnection\u003c/h1\u003e\u003cp\u003eWe should talk about it Sunday, but here is a hint if anyone wants it: \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003ethe solution is O(n) greedy, try to color the nodes in a certain pattern that should always work.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eupdate: the solution goes like this: \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003efirst we color the cycle like color[i] \u003d i.\u003cbr /\u003enow move to a vertex that has at least one colored neighbor.\u003cbr /\u003efor every colored neighbor add (color[neighbor] % k + 1) to a set.\u003cbr /\u003enow our color is any color in the set that no neighbor of ours has it.\u003cbr /\u003ego to another vertex and repeat.\u003cbr /\u003ethe proof of why this works is left is an exercise to the reader.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003ch1\u003eI — Immediate Delivery\u003c/h1\u003e\u003cp\u003eWe first do a normal travelling sales man dp (or dijkstra) for one person moving in the graph dp[visited nodes mask][last node visited].\u003cbr /\u003ethen we try every possible subsets of nodes that the first person will travel and find the minimum time needed for the second person to visit the rest of the nodes.\u003cbr /\u003eto find the minimum fast, we do another dp in which we store for every subset of nodes the subset that includes our subset and has minimum time.\u003cbr /\u003e\u003ca href\u003d\"https://ideone.com/Fms3Ba\"\u003ehttps://ideone.com/Fms3Ba\u003c/a\u003e\u003cbr /\u003e\u003ca href\u003d\"https://ideone.com/CrWcph\"\u003ehttps://ideone.com/CrWcph\u003c/a\u003e \u003c/p\u003e\u003ch1\u003eK — Kids Like Cakes\u003c/h1\u003e\u003cp\u003eGet small triangle from 3 adjacent points. Store minimum 4 triangles, just in case 3 vertices of large triangle use midpoint of 3 smallest triangles, ill take the 4th. \u003c/p\u003e\u003cp\u003eThen try every pair of points as an edge of larger triangle. Now we need to choose a third point that maximizes the height of the triangle where the height is the perpendicular line of the line between the two points. \u003c/p\u003e\u003cp\u003eWe can do ternary search for the third point in O(n^2*logn), but to do it in O(n^2), we can use the method of 2 pointers, we start with three consecutive points, our left pointer is the point in the middle and our right pointer is the right point. \u003c/p\u003e\u003cp\u003eAlso check if the middle point is the same place as the smallest triangle. If so, then check the point above and below the middle point as a possible third point for our large triangle. \u003c/p\u003e\u003cp\u003eRemember to use only long long. to calculate the triangles area we can use the cross product. \u003c/p\u003e\u003cp\u003eUseful link: \u003ca href\u003d\"https://stackoverflow.com/questions/1621364/how-to-find-largest-triangle-in-convex-hull-aside-from-brute-force-search\"\u003ehttps://stackoverflow.com/questions/1621364/how-to-find-largest-triangle-in-convex-hull-aside-from-brute-force-search\u003c/a\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"https://ideone.com/BXvEQX\"\u003ehttps://ideone.com/BXvEQX\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}