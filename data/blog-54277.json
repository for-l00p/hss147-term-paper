{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1504448052,"rating":0,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1504448052,"id":54277,"title":"\u003cp\u003eNotes on Codeforces Beta Round #74, A, B, C, D, E(Orthogonal List)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/90/problem/A\" title\u003d\"Codeforces Beta Round 74 (Div. 2 Only)\"\u003e90A - Cableway\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThere are at most 300 students, and thus we can directly simulate the whole process, i.e., what happens in each minute. The simulation terminates when no students are left.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/90/problem/B\" title\u003d\"Codeforces Beta Round 74 (Div. 2 Only)\"\u003e90B - African Crossword\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe implementation is straightforward. We can enumerate each letter, and only those that appear exactly once in the corresponding row and column should be output.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/90/problem/C\" title\u003d\"Codeforces Beta Round 74 (Div. 2 Only)\"\u003e90C - Robbery\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAn interesting problem. \u003c/p\u003e\u003cp\u003eSuppose that \u003cspan class\u003d\"tex-span\"\u003eΔ \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e elements are taken away. To guarantee that the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e sums keep the same, the changing quantity for each element must be \u003cspan class\u003d\"tex-span\"\u003e - Δ \u003ci\u003ex\u003c/i\u003e, Δ \u003ci\u003ex\u003c/i\u003e,  - Δ \u003ci\u003ex\u003c/i\u003e, Δ \u003ci\u003ex\u003c/i\u003e, ...\u003c/span\u003e. Therefore, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is an even number, it is impossible to take away any elements, since the total sum can not be changed. For an odd number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, it can be seen that to take away \u003cspan class\u003d\"tex-span\"\u003eΔ \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e elements, we have to carry out \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bb/b8/bbb8a0ef876b2733c5b68beaceae7280af54945b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e moves. For each minute, at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e moves can be conducted, and thus \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1b/87/1b879d964af579f814394fc6a64e88c81bc3eeac.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Given \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e minutes, we can carry out at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ed/0b/ed0b1064d806dac9f99133422e869a9d39286c39.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e moves. However, the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e[1], \u003ci\u003ea\u003c/i\u003e[3], ...\u003ci\u003ea\u003c/i\u003e[2\u003ci\u003en\u003c/i\u003e + 1])\u003c/span\u003e has provided an upper bound (the index starts from 1), and thus the answer should be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003eT\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/90/problem/D\" title\u003d\"Codeforces Beta Round 74 (Div. 2 Only)\"\u003e90D - Widget Library\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe description is long but it turns out to be a traversal on a q-ary tree, which can be solved by using DFS. One important trick is to store the results that have been obtained at each node to avoid TLE.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/90/problem/E\" title\u003d\"Codeforces Beta Round 74 (Div. 2 Only)\"\u003e90E - Chip Play\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe trick is how to find out the next position with constant complexity so that the total complexity is \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e × \u003ci\u003em\u003c/i\u003e × \u003ci\u003en\u003c/i\u003e × \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e. For each position with an arrow, we assign four links to denote the nearest four positions with arrows that it can reach, in left, right, up and down directions, respectively. This process can be completed with complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e × \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e, by using the prefix and suffix idea. \u003c/p\u003e\u003cp\u003eWhen we move from the current position to the next one, we should update the links assigned to the four nearest arrows as well, since after moving, the current arrow will disappear. Suppose that the current position is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e, and its four links are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e[\u003ci\u003eL\u003c/i\u003e], \u003ci\u003eP\u003c/i\u003e[\u003ci\u003eR\u003c/i\u003e], \u003ci\u003eP\u003c/i\u003e[\u003ci\u003eU\u003c/i\u003e], \u003ci\u003eP\u003c/i\u003e[\u003ci\u003eD\u003c/i\u003e]\u003c/span\u003e, denoting that the nearest left, right, up and down arrows. When \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e disappears, the nearest right arrow of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e[\u003ci\u003eL\u003c/i\u003e]\u003c/span\u003e should be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e[\u003ci\u003eR\u003c/i\u003e]\u003c/span\u003e, and the nearest left arrow of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e[\u003ci\u003eR\u003c/i\u003e]\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e[\u003ci\u003eL\u003c/i\u003e]\u003c/span\u003e, and the nearest upside arrow of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e[\u003ci\u003eD\u003c/i\u003e]\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e[\u003ci\u003eU\u003c/i\u003e]\u003c/span\u003e, and the nearest downside arrow of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e[\u003ci\u003eU\u003c/i\u003e]\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e[\u003ci\u003eD\u003c/i\u003e]\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eAfter the above updating, we can always find out the next arrow with constant complexity. Remember to restore the initial links after every time we complete DFS. \u003c/p\u003e\u003c/div\u003e","tags":[]}}