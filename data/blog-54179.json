{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1504102717,"rating":66,"authorHandle":"Glebodin","modificationTimeSeconds":1504107074,"id":54179,"title":"\u003cp\u003eTutorial Codeforces Round #430 (Div. 2)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/842/problem/A\" title\u003d\"Codeforces Round 430 (Div. 2)\"\u003e842A - Kirill And The Game\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eLet\u0027s denote the potion\u0027s amount of experience as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eexp\u003c/i\u003e\u003c/span\u003e and its cost as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecost\u003c/i\u003e\u003c/span\u003e. We want to know if there is a potion such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eexp\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecost\u003c/i\u003e\u003c/span\u003e meet the following condition: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f7/fb/f7fb32b51fadf092401133887d01825f94f0a138.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. To do this, we can iterate on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecost\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e and check that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eexp\u003c/i\u003e \u003d \u003ci\u003ek\u003c/i\u003e·\u003ci\u003ecost\u003c/i\u003e\u003c/span\u003e is not less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and not greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://ideone.com/a8syda\"\u003ehttps://ideone.com/a8syda\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/842/problem/B\" title\u003d\"Codeforces Round 430 (Div. 2)\"\u003e842B - Gleb And Pizza\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eTo understand whether some piece of sausage intersects with pizza, we can check if their borders intersect. And to check this, since their borders are circles, we are interested in their radii and the distance between their centers. \u003c/p\u003e\u003cp\u003eTo check if a piece of sausage is inside the crust, we firstly check that it is inside the pizza \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/16/57/16573514c71612258260ef8c86f6aa0d0e5f0259.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e), and secondly check that it is completely outside the central part of the pizza \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0c/8f/0c8f9c1e551137701e57453df1409df6413c459e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e).\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://ideone.com/Jd66XL\"\u003ehttps://ideone.com/Jd66XL\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/842/problem/C\" title\u003d\"Codeforces Round 430 (Div. 2)\"\u003e842C - Ilya And The Tree\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eIt\u0027s easy to see that if the number written on some vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is not equal to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, then its beauty will be some divisor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Also if the number written on the root is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e then the beauty of each vertex can be easily calculated. Otherwise beauty of each vertex will be a divisor of the number in the root.\u003c/p\u003e\u003cp\u003eLet\u0027s calculate the beauty of each vertex if the number in the root is 0. This can be done by traversing the tree, and the beauty of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egcd\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eans\u003c/i\u003e[\u003ci\u003epar\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e])\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIf the number in the root is not \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, then possible values of beauty for each vertex are among divisors of this number. For each of these divisors we can maintain how many numbers on the path from the root to current vertex are divisible by that divisor. When we enter or leave some vertex, we need to update this information by iterating on divisors of the number in the root. If we maintain it and current depth \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e, then we can calculate the possible beauty of current vertex. It is equal to greatest divisor such that there are at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e - 1\u003c/span\u003e numbers on the path that are divisible by this divisor.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://ideone.com/uQNFX3\"\u003ehttps://ideone.com/uQNFX3\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/842/problem/D\" title\u003d\"Codeforces Round 430 (Div. 2)\"\u003e842D - Vitya and Strange Lesson\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eIf the last query was \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and then we receive a query \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e, then we can leave the original array unchanged and use the number \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/38/28/3828aca7744a702c1819bfdf37cd1225e0a2e316.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e as the second query. So we will maintain current xor of queries instead of changing the array.\u003c/p\u003e\u003cp\u003eIt\u0027s easy to see that if the array contains all numbers from zero to \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e - 1\u003c/span\u003e and the number in the query is less than \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e, then the array will still contain all those numbers.\u003c/p\u003e\u003cp\u003eLet\u0027s store all numbers from the array in binary trie and maintain the number of leaves in each subtree.\u003c/p\u003e\u003cp\u003eTo answer each query, we will descend the trie. We need to get the lowest possible answer, so if current bit of the number in the query equals \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u003d 0\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u003d 1\u003c/span\u003e), so we firstly check the subtree that corresponds to bit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. We will descend into the vertex only if the subtree is not a complete binary tree (so there exists a number that would belong to this subtree but is not included in the array). When we try to descend into an empty subtree, then we set all remaining bits in the answer to zero.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://ideone.com/gVE1kC\"\u003ehttps://ideone.com/gVE1kC\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/842/problem/E\" title\u003d\"Codeforces Round 430 (Div. 2)\"\u003e842E - Nikita and game\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eThe vertices in the answer are the endpoints of some diameter of the tree. \u003c/p\u003e\u003cp\u003eLet\u0027s consider diameter (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e), where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e are its endpoints, and we add a new vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eс\u003c/i\u003e\u003c/span\u003e. Then the length of diameter either remains the same or increases by one (then new endpoints are vertices (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e) or (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e)). \u003c/p\u003e\u003cp\u003eWe have to maintain current centers of the tree (there are not more than two centers). If the length of diameter increases, then the number of centers changes (but there will always exist a vertex that was the center before the query and remains the center after the query).\u003c/p\u003e\u003cp\u003eLet\u0027s build a segment tree on the eulerian tour of the tree. The vertex that maintains the segment \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e will store current maximal distance to the center and the number of vertices that have this distance. Then the answer for the query will be stored in the root of the segment tree.\u003c/p\u003e\u003cp\u003eWhen we add a new vertex, we need to check whether the length of diameter increases; this can be done with LCA. If the diameter increases, we update centers and distances to them. \u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://ideone.com/5tXC92\"\u003ehttps://ideone.com/5tXC92\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["#codeforces","round #430","editorial"]}}