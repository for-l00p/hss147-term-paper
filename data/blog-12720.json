{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1403098213,"rating":8,"authorHandle":"1k_trash","modificationTimeSeconds":1403098213,"id":12720,"title":"\u003cp\u003eПоиск мостов -- помогите найти тест, который завалит вот такую реализацию\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eПривет.\u003c/p\u003e\u003cp\u003eНа емаксе лежит вот такая реализация алгоритма поиска мостов:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid dfs (int v, int p \u003d -1) {\n\tused[v] \u003d true;\n\ttin[v] \u003d fup[v] \u003d timer++;\n\tfor (size_t i\u003d0; i\u0026lt;g[v].size(); ++i) {\n\t\tint to \u003d g[v][i];\n\t\tif (to \u003d\u003d p)  continue;\n\t\tif (used[to])\n\t\t\tfup[v] \u003d min (fup[v], tin[to]);\n\t\telse {\n\t\t\tdfs (to, v);\n\t\t\tfup[v] \u003d min (fup[v], fup[to]);\n\t\t\tif (fup[to] \u0026gt; tin[v])\n\t\t\t\tIS_BRIDGE(v,to);\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВопрос: а что если, когда попытаемся пройти по обратному ребру, в строчке 8 мы обновим fup[v] следующим образом: \u003c/p\u003e \u003cpre\u003e\u003ccode\u003efup[v] \u003d min (fup[v], fup[to])    ?\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВроде интуитивно понятно, что все смежные вершины to могли еще быть не посещены поиском в глубину и fup[to] будет не готов, но всё же. Какой тест завалит реализацию с таким единственным изменением? Пробовал погонять на своих тестах -- вроде отрабатывает.\u003c/p\u003e\u003cp\u003eСпасибо.\u003c/p\u003e\u003c/div\u003e","tags":[]}}