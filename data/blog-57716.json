{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1518433544,"rating":7,"authorHandle":"sadman.rizwan","modificationTimeSeconds":1518433544,"id":57716,"title":"\u003cp\u003eDP + Combinatorics\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eSuppose, I have \u003cstrong\u003eN\u003c/strong\u003e \u003cstrong\u003edistinct\u003c/strong\u003e integers. I have to make \u003cstrong\u003eM non-empty sets\u003c/strong\u003e using these integers. An integer may not present in any of the sets and an integer can present in only one of the M sets. I have to print all possible ways to make \u003cstrong\u003eM\u003c/strong\u003e sets using these \u003cstrong\u003eN\u003c/strong\u003e integers.\u003c/p\u003e\u003cp\u003eFor example, if I have \u003cstrong\u003eN \u003d 3\u003c/strong\u003e integers which are \u003cstrong\u003e1\u003c/strong\u003e, \u003cstrong\u003e2\u003c/strong\u003e and \u003cstrong\u003e3\u003c/strong\u003e, then there are \u003cstrong\u003e6\u003c/strong\u003e possible ways to make \u003cstrong\u003eM \u003d 2\u003c/strong\u003e sets:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e1. {1} {2}\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2. {1} {3}\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e3. {2} {3}\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e4. {1,2} {3}\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e5. {1,3} {2}\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e6. {1} {2,3}\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eHow can I find out the number of ways to make \u003cstrong\u003eM\u003c/strong\u003e sets using \u003cstrong\u003eN\u003c/strong\u003e distinct integers according to the rule given above? What is the most efficient way to print all the possible ways?\u003c/p\u003e\u003cp\u003eI tried to solve this problem using dynamic programming, but I am having trouble to define DP states.\u003c/p\u003e\u003c/div\u003e","tags":[]}}