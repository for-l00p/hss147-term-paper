{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1456553226,"rating":21,"authorHandle":"mkrjn99","modificationTimeSeconds":1459087661,"id":43392,"title":"\u003cp\u003eManthan, Codefest 16: Editorials\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eProblem A: Ebony Ivory\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe problem is to find if there exists a solution to the equation:  \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eax\u003c/i\u003e + \u003ci\u003eby\u003c/i\u003e \u003d \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e where x and y are both positive integers. The limits are small enough to try all values of x and correspondingly try if such a y exists. The question can also be solved more efficiently using the fact that an integral solution to this problem exists iff \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egcd\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)|\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e. We just have to make one more check to ensure a positive integral solution.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003emin\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e))\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem B: A Trivial Problem\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eWe know how to calculate number of zeros in the factorial of a number. For finding the range of numbers having number of zeros equal to a constant, we can use binary search. Though, the limits are small enough to try and find the number of zeros in factorial of all numbers of the given range.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem C: Spy Syndrome 2\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe given encrypted string can be reversed initially. Then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e can be defined as the index at which the next word should start such that the given string can be formed using the given dictionary. Rabin Karp hashing can be used to compute \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e efficiently.\u003c/p\u003e\u003cp\u003eAlso, care must be taken that in the answer the words have to be printed in the correct casing as they appear in the dictionary.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e * \u003ci\u003ew\u003c/i\u003e)\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is the length of the encrypted string, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e is the maximum length of any word in the dictionary.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem D: Fibonacci-ish\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe key to the solution is that the complete Fibonacci-ish sequence is determined by the first two terms. Another thing to note is that for the given constraints on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e, the length of the Fibonacci-ish sequence is of logarithmic order (the longest sequence possible under current constraints was of length~90) except for the case where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e] \u003d 0\u003c/span\u003e, where the length can become as long as the length of the given sequence. Thus, the case for 0 has to be handled separately.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e * \u003ci\u003en\u003c/i\u003e * \u003ci\u003el\u003c/i\u003e)\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is the length of the given sequence and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e is the length of the longest Fibonacci-ish subsequence.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem E: Startup funding\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eLet us denote the number of visitors in the ith week by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e and the revenue in the ith week by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLet us define \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d \u003ci\u003emax\u003c/i\u003e(\u003ci\u003emin\u003c/i\u003e( 100 * \u003ci\u003emax\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e...\u003ci\u003ej\u003c/i\u003e]), \u003ci\u003emin\u003c/i\u003e(\u003ci\u003ec\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e...\u003ci\u003ej\u003c/i\u003e]))) \u003ci\u003efor\u003c/i\u003e \u003ci\u003eall\u003c/i\u003e (\u003ci\u003ej\u003c/i\u003e \u0026gt;  \u003d \u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e. Note that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e...\u003ci\u003ej\u003c/i\u003e])\u003c/span\u003e is an increasing function in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e...\u003ci\u003ej\u003c/i\u003e])\u003c/span\u003e is a decreasing function in j. Thus, for all i, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e can be computed using RMQ sparse table in combination with binary search.\u003c/p\u003e\u003cp\u003eThus the question reduces to selecting \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e values randomly from the array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e. Let us suppose we select these \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e values and call the minimum of these values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Now, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is the random variable whose expected value we need to find. If we sort \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e in non-decreasing order:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eE\u003c/i\u003e(\u003ci\u003eX\u003c/i\u003e) \u003d (\u003ci\u003ez\u003c/i\u003e[1] * \u003ci\u003eC\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e - 1, \u003ci\u003ek\u003c/i\u003e - 1) + \u003ci\u003ez\u003c/i\u003e[2] * \u003ci\u003eC\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e - 2, \u003ci\u003ek\u003c/i\u003e - 1) + \u003ci\u003ez\u003c/i\u003e[3] * \u003ci\u003eC\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e - 3, \u003ci\u003ek\u003c/i\u003e - 1)....) / (\u003ci\u003eC\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e))\u003c/span\u003e\u003c/p\u003e\u003cp\u003ewhere \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e is the number of ways of selecting \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e objects out of n. Since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e will be big values, we should not compute \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e explicitly and just write them as ratios of the previous terms. Example: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e - 1, \u003ci\u003ek\u003c/i\u003e - 1) / \u003ci\u003eC\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e) \u003d \u003ci\u003ek\u003c/i\u003e / \u003ci\u003en\u003c/i\u003e\u003c/span\u003e and so on.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e * \u003ci\u003elgn\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem F: The Chocolate Spree\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe problem boils down to computing the maximum sum of two disjoint weighted paths in a tree (weight is on the nodes not edges). It can be solved applying DP as in the given solution : \u003ca href\u003d\"http://pastebin.com/L8NNLF3f\"\u003ehttp://pastebin.com/L8NNLF3f\u003c/a\u003e (Thanks to \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/GlebsHP\" title\u003d\"Гроссмейстер GlebsHP\"\u003eGlebsHP\u003c/a\u003e for the solution!)\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is the number of nodes in the tree.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem G: Yash and Trees\u003c/strong\u003e\u003c/p\u003e\u003cp\u003ePerform an euler tour (basically a post/pre order traversal) of the tree and store it as an array. Now, the nodes of the subtree are stored are part of the array as a subarray (contiguous subsequence). Query Type 2 requires you to essentially answer the number of nodes in the subtree such that their value modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e is a prime. Since, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e ≤ 1000\u003c/span\u003e, we can build a segment tree(with lazy propagation) where each node has a bitset, say \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e is on iff a value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e exists in the segment represented by that node, such that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c3/01/c30190fb18cd32729079c2e862636e00ace82927.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. The addition operations then are simply reduced to bit-rotation within the bitset of the node.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e * \u003ci\u003elgn\u003c/i\u003e * \u003ci\u003ef\u003c/i\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is the cardinality of the vertices of the tree, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e is a small factor denoting the time required for conducting bit rotations on a bitset of size 1000. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem H: Fibonacci-ish II\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe problem can be solved by taking the queries offline and using a square-root decomposition trick popularly called as “Mo’s algorithm”. Apart from that, segment tree(with lazy propagation) has to be maintained for the Fibonacci-ish potential of the elements in the current [l,r] range. The fact used in the segment tree for lazy propagation is:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e + 1) * (\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e * \u003ci\u003eF\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e) + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e * \u003ci\u003eF\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e + 1)...) + \u003ci\u003eF\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e) * (\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e * \u003ci\u003eF\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e - 1) + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e * \u003ci\u003eF\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e) + ....) \u003d (\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e * \u003ci\u003eF\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e) + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e * \u003ci\u003eF\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e + 1)....)\u003c/span\u003e\u003c/p\u003e\u003cp\u003eExample: Suppose currently the array is [100,400,500,100,300]. Using Mo\u0027s algorithm, currently the segment tree is configured for the answer of the segment [3,5]. The segment tree\u0027 node [4,5] will store answer\u003d500*F(2)\u003d1000. In general, the node \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e]\u003c/span\u003e of segment tree will contain answer for the values in the current range of \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e]\u003c/span\u003e of Mo\u0027s for the values that have rank in sorted array \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e]\u003c/span\u003e. The answer will thus be of the form \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e * \u003ci\u003eF\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e) + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e * \u003ci\u003eF\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e + 1)...\u003c/span\u003e. We maintain an invariant that apart from the answer, it will also store answer for one step back in Fibonacci, i.e., \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e * \u003ci\u003eF\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e - 1) + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e * \u003ci\u003eF\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)...\u003c/span\u003e. Now, when values are added (or removed) in the segment tree, the segments after the point after which the value is added have to be updated. For this we maintain a lazy count parameter (say \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e). Thus, when we remove the laziness of the node, we use the above stated formula to remove the laziness in O(1) time. Refer our implementation for details: \u003ca href\u003d\"http://pastebin.com/MbQYtReX\"\u003ehttp://pastebin.com/MbQYtReX\u003c/a\u003e\u003c/p\u003e\u003cp\u003eComplexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ab/f9/abf90d0140650c078717b4adad558bef71af2d46.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}