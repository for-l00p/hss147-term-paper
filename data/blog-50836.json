{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1488817944,"rating":0,"authorHandle":"SAeed","modificationTimeSeconds":1488822487,"id":50836,"title":"\u003cp\u003eAdvanced Contest #1 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e \u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/212257/problem/Green\"\u003eGreen. Duff and Meat\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eGreedy\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eConsider the day number 5 for example. The cheapest way to buy meat for the 5th day, is to buy it on the cheapest day among days number:1, 2, 3, 4, 5. So in general in order to buy meat for the day number i with the cheapest price, we should buy it in the cheapest day among days 1, 2, ..., i-1, i.\u003c/p\u003e\u003cp\u003eWe can easily do this by iterating through the days, while keeping the value of the cheapest day so far.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(N)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint main()\n{\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n\tint n; cin \u0026gt;\u0026gt; n;\n\tint MinimumPrice \u003d 1e9;\n\tint ans \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\tint amount, price;\n\t\tcin \u0026gt;\u0026gt; amount \u0026gt;\u0026gt; price;\n\t\tMinimumPrice \u003d min(MinimumPrice, price);\n\t\tans +\u003d MinimumPrice * amount;\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/212257/problem/Blue\"\u003eBlue. Queries about less or equal elements\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eBinary Search\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe naive solution would be to go through the whole array \u003ccode\u003ea\u003c/code\u003e for each element in \u003ccode\u003eb\u003c/code\u003e. However, if we sorted the array \u003ccode\u003ea\u003c/code\u003e we can notice that the answer for each element will be all the elements from the beginning, to the first element which is greater than the current element. The naive solution has a complexity of N*N. To calculate the answer faster we can use \u003ccode\u003eupper_bound\u003c/code\u003e and get the first element which is greater than the current element in a reasonable time. then the answer would simply be \u003ccode\u003eupper_bound - begin\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(M x Log(N))\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint a[200100];\nint b[200100];\n\nint main()\n{\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n\tint n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i];\n\tfor (int i \u003d 0; i \u0026lt; m; i++) cin \u0026gt;\u0026gt; b[i];\n\tsort(a, a + n);\n\tfor (int i \u003d 0; i \u0026lt; m; i++){\n\t\tif (i) cout \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n\t\tcout \u0026lt;\u0026lt; upper_bound(a, a + n, b[i]) - a;\n\t}\n\tcout \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/212257/problem/Red\"\u003eRed. Fixing Typos\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAdHoc + Greedy\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eFirst of all, if we have any character repeated more than 2 consecutive times, we should delete all the extra characters and keep at most 2 consecutive characters of the same type. Now the resulting string would be something like this \u003ccode\u003eaabbccddee\u003c/code\u003e. Now we have 2 options, either to delete \u003ccode\u003ea\u003c/code\u003e+\u003ccode\u003ec\u003c/code\u003e+\u003ccode\u003ee\u003c/code\u003e making the string \u003ccode\u003eabbcdde\u003c/code\u003e, or to delete \u003ccode\u003eb\u003c/code\u003e+\u003ccode\u003ed\u003c/code\u003e making the string \u003ccode\u003eaabccdee\u003c/code\u003e. Obviously the second solution is better. This can also be understood that when we have the substring \u003ccode\u003eaabb\u003c/code\u003e then deleting \u003ccode\u003eb\u003c/code\u003e is better than deleting \u003ccode\u003ea\u003c/code\u003e, because when we delete \u003ccode\u003eb\u003c/code\u003e that means we can now put 2 consecutive characters after \u003ccode\u003eb\u003c/code\u003e, while if we deleted \u003ccode\u003ea\u003c/code\u003e we will still have 2 consecutive \u003ccode\u003eb\u003c/code\u003e in the end which will make further conflicts with the next letters.\u003c/p\u003e\u003cp\u003eThe code is not very complicated. We just need to keep 2 variables: \u003ccode\u003ecnt\u003c/code\u003e indicating how many characters we used from the current type, and \u003ccode\u003eLastCnt\u003c/code\u003e indicating how many characters we used from the previous type.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(N)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint main()\n{\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n\tstring s; cin \u0026gt;\u0026gt; s;\n\tstring ans;\n\tans.push_back(s[0]);\n\tint cnt \u003d 1, LastCnt \u003d 0;\n\tfor (int i \u003d 1; i \u0026lt; s.size(); i++){\n\t\tif (s[i] \u003d\u003d ans[ans.size() - 1]){\n\t\t\tif (LastCnt \u003d\u003d 2 || cnt \u003d\u003d 2) continue;\n\t\t\tans.push_back(s[i]);\n\t\t\tcnt++;\n\t\t}\n\t\telse{\n\t\t\tans.push_back(s[i]);\n\t\t\tLastCnt \u003d cnt;\n\t\t\tcnt \u003d 1;\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\t\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/212257/problem/Yellow\"\u003eYellow. Hexadecimal\u0027s Numbers\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eRecursion\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eWe have to calculate all the numbers which are less than or equal to \u003ccode\u003en\u003c/code\u003e, and its representation contains only zeros and ones. We can do this using a simple recursion, where we start from the number \u003ccode\u003e1\u003c/code\u003e, and in each time we try to add either \u003ccode\u003e0\u003c/code\u003e or \u003ccode\u003e1\u003c/code\u003e to the number. We just need the number of such integers regardless of the value of these numbers themselves, so we can just make a variable \u003ccode\u003eans\u003c/code\u003e and increase it by one in each step through the recursion.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(2^9)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\ntypedef long long ll;\nint n;\nint ans \u003d 0;\nvoid GenerateBinary(ll x){\n\tif (x \u0026gt; n) return;\n\tans++;\n\tGenerateBinary(x * 10 + 0);\n\tGenerateBinary(x * 10 + 1);\n}\n\nint main()\n{\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n\tcin \u0026gt;\u0026gt; n;\n\tGenerateBinary(1);\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/212257/problem/Silver\"\u003eSilver. Little Elephant and Problem\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eSorting + AdHoc\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s think about this problem in a different way. He had a sorted array \u003ccode\u003ea\u003c/code\u003e, and then we swapped 2 elements from this array. What does this mean? It means that if sorted the array, there shall be no more than 2 elements not in their right place, then we can simply swap these 2 elements and get our sorted array back.\u003c/p\u003e\u003cp\u003eLet\u0027s keep two arrays \u003ccode\u003ea\u003c/code\u003e containing the given array and \u003ccode\u003eb\u003c/code\u003e containing the sorted version of array \u003ccode\u003ea\u003c/code\u003e. Now we must simply iterate over the array \u003ccode\u003ea\u003c/code\u003e and count the number of elements which are no in their right place.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(N x Log(N))\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\nint a[100100];\nint b[100100];\n\nint main()\n{\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n\tcin \u0026gt;\u0026gt; n;\n\tint diffs \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\tcin \u0026gt;\u0026gt; a[i];\n\t\tb[i] \u003d a[i];\n\t}\n\tsort(b, b + n);\n\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\tif (a[i] !\u003d b[i]) diffs++;\n\t}\n\tif (diffs \u0026gt; 2) cout \u0026lt;\u0026lt; \u0026quot;NO\u0026quot; \u0026lt;\u0026lt; endl;\n\telse cout \u0026lt;\u0026lt; \u0026quot;YES\u0026quot; \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/212257/problem/Black\"\u003eBlack. Kefa and Company\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003e2 Pointers\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eFirst, let\u0027s store the input in pairs, where \u003ccode\u003efirst\u003c/code\u003e is the money this person has, and \u003ccode\u003esecond\u003c/code\u003e is the friendship factor of this person. Now the problem becomes much more easier, why is that?\u003c/p\u003e\u003cp\u003eBecause the groups we can form now are continuous. The first group will contain the people from the first person, up to the last person whose money is more than the first person by less than \u003ccode\u003ed\u003c/code\u003e (note that we can\u0027t add any other people to this group because this will make the first person feel poor). The second group will contain the people from the second person, up to the person whose money is more than the second person by less than \u003ccode\u003ed\u003c/code\u003e. And so on..\u003c/p\u003e\u003cp\u003eTo solve this problem we can keep 2 variables: \u003ccode\u003estart\u003c/code\u003e indicating the first person of the current group, and \u003ccode\u003eend\u003c/code\u003e indicating the last person of the current group. For each \u003ccode\u003estart\u003c/code\u003e try moving \u003ccode\u003eend\u003c/code\u003e as far as you can, calculate the answer of the current group and compare it with the best found answer so far. This solution is O(NxN).\u003c/p\u003e\u003cp\u003eTo make this solution faster notice that we shouldn\u0027t start the variable \u003ccode\u003eend\u003c/code\u003e from \u003ccode\u003estart\u003c/code\u003e and move it forward. Instead we must try moving the variable \u003ccode\u003eend\u003c/code\u003e forward starting from the last position it was in. So in overall variable \u003ccode\u003estart\u003c/code\u003e will iterate from \u003ccode\u003e0\u003c/code\u003e to \u003ccode\u003eN\u003c/code\u003e, and variable \u003ccode\u003eend\u003c/code\u003e will iterate from \u003ccode\u003e0\u003c/code\u003e to \u003ccode\u003eN\u003c/code\u003e independently from the variable \u003ccode\u003estart\u003c/code\u003e making the total complexity O(2N).\u003c/p\u003e\u003cp\u003eKeep a variable \u003ccode\u003ecnt\u003c/code\u003e which has the sum of all the people in the previous group. Now when we move \u003ccode\u003estart\u003c/code\u003e one step forward we actually delete the person at position \u003ccode\u003estart\u003c/code\u003e from the group. Also we will try to move \u003ccode\u003eend\u003c/code\u003e as far as possible, meaning that we add these people to the current group. So each time we subtract the person at \u003ccode\u003estart\u003c/code\u003e from \u003ccode\u003ecnt\u003c/code\u003e, and also we add all the people at \u003ccode\u003eend\u003c/code\u003e to \u003ccode\u003ecnt\u003c/code\u003e. Of course don\u0027t forget to check the optimality of the current solution with the best solution you have found so far.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(N)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\ntypedef long long ll;\n\npair\u0026lt;ll, ll\u0026gt; a[100100];\n\nint main()\n{\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n\tint n; cin \u0026gt;\u0026gt; n;\n\tll d; cin \u0026gt;\u0026gt; d;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i].first \u0026gt;\u0026gt; a[i].second;\n\tsort(a, a + n);\n\tint end \u003d 0; // last friend I can take with the current start\n\tll cnt \u003d 0; // current amount of friendship factor\n\tll maxi \u003d 0; // best answer\n\tfor (int start \u003d 0; start \u0026lt; n; start++){\n\t\twhile (end \u0026lt; n \u0026amp;\u0026amp; a[end].first - a[start].first \u0026lt; d){ //move end as far as you can\n\t\t\tcnt +\u003d a[end].second;\n\t\t\tend++;\n\t\t}\n\t\tmaxi \u003d max(maxi, cnt);\n\t\tcnt -\u003d a[start].second; // erase the current friend\n\t}\n\tcout \u0026lt;\u0026lt; maxi \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eI really hope you enjoyed this contest, and wish to see better results next time for all of you. If you have any question please leave a comment here to make other students who have the same question see it ;)\u003c/p\u003e\u003c/div\u003e","tags":["#editorial"]}}