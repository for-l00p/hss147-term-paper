{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1483544157,"rating":21,"authorHandle":"gepardo","modificationTimeSeconds":1483554508,"id":49573,"title":"\u003cp\u003eПодготовка к областной олимпиаде с Федосом [3]. Разбор задач\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eЗдесь я постарался как можно подробнее описать свои решения и доказать, почему они работают. Думаю, разбор получился достаточно подробным. Коды решений прилагаются. Итак, разбор:\u003c/p\u003e\u003cp\u003e[problem:210970A]\u003c/p\u003e\u003cp\u003e[problem:210970B]\u003c/p\u003e\u003cp\u003eЭто была самая простая задача контеста. Давайте создадим отдельный массив \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e означает количество коров, которые имеют номер \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Теперь мы можем просто перебрать корову, для которой мы считаем количество касаний и просто найти это количество. Нетрудно заметить, что оно будет равно сумме \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e для всех \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, которые делятся нацело на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Не забудем также отнять от этого количества единицу, так корова сама себя касаться не будет.\u003c/p\u003e\u003cp\u003eАсимптотика решения — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e + \u003ci\u003en\u003c/i\u003e * \u003ci\u003esqrt\u003c/i\u003e(10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e))\u003c/span\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eКод\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003econst int maxNum \u003d (int)1.1e6;\nint n \u003d get\u0026lt;int\u0026gt;();\nvi a \u003d getVector\u0026lt;int\u0026gt;(n);\nint b[maxNum] \u003d {};\n\nsigned main() {\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        b[a[i]]++;\n    }\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        int ans \u003d 0;\n        for (int j \u003d 1; j * j \u0026lt;\u003d a[i]; j++) {\n\t\t\tif (a[i] % j \u003d\u003d 0) {\n\t\t\t\tint d1 \u003d j, d2 \u003d a[i] / j;\n\t\t\t\tans +\u003d b[d1];\n\t\t\t\tif (d1 !\u003d d2) {\n\t\t\t\t\tans +\u003d b[d2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n        putLn(ans-1);\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e[problem:210970C]\u003c/p\u003e\u003cp\u003e[problem:210970D]\u003c/p\u003e\u003cp\u003eДля начала заметим, что антисимметричные строки могут иметь только чётную длину. Докажем это. Давайте рассмотрим антисимметричную строку \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e. Тогда символ посередине у строк \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e будет одинаковым, так как средний символ при перевороте строки никуда не двигается. Тогда у \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d0/5c/d05c0bc399e958d5e524ff764c42e33069fbda30.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e это будет другой символ, и, следовательно, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e3/be/e3bec7988c60638623b3eec9c40103f0c0ebba03.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Значит, эта строка не является антисимметричной.\u003c/p\u003e\u003cp\u003eПоэтому все антисимметричные строки будут иметь четную длину. Давайте переберем \u0026quot;серединку\u0026quot; нашей подстроки (два символа, находящиеся посередине) и найдем бинарным поиском, сколько символов слева и справа от \u0026quot;серединки\u0026quot; может находиться в нашей подстроке. Это можно сделать бинарным поиском, так как если у нас есть \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e символов слева и справа и наша строка антисимметрична, то строка с \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e символами слева и справа тоже будет антисимметричной (т. к если мы удалим по одному символу с двух сторон, то она останется антисимметричной). Теперь мы можем легко найти самую длинную антисимметричную строку около нашей \u0026quot;серединки\u0026quot;, и затем, исходя из этого, найти общее количество таких подстрок около нее. Понятно, что ответ будет равен сумме количеств подстрок вокруг всех \u0026quot;серединок\u0026quot;.\u003c/p\u003e\u003cp\u003eТеперь осталось понять, как быстро (за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e) проверять, является ли некоторая подстрока \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e антисимметричной. Для начала заметим, что \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e является подстрокой \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, а \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/83/b5/83b5ba4975b353d2bdfee2793d475c00a6796a58.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e — подстрокой \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d0/5c/d05c0bc399e958d5e524ff764c42e33069fbda30.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Поэтому будем хранить строки \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e и \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d0/5c/d05c0bc399e958d5e524ff764c42e33069fbda30.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Чтобы сравнить две их подстроки, можно воспользоваться хэшированием.\u003c/p\u003e\u003cp\u003eАсимптотика решения — \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a0/51/a05162d63a3e8478458a94c927428426fcd60782.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e на перебор \u0026quot;серединок\u0026quot;, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/45/08/4508cb79890bcc7701cc92868426b7ce70a0362f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e на бинпоиск).\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eКод\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003estruct Hash {\n    ull _1, _2;\n};\n\nconst ull p1 \u003d 257,\n          p2 \u003d 263,\n          m1 \u003d 1834537897,\n          m2 \u003d 1234567891;\n\nint n \u003d get\u0026lt;int\u0026gt;();\nstring s \u003d get\u0026lt;string\u0026gt;();\nstring rs;\nvector\u0026lt;Hash\u0026gt; pows(n+1), hs(n+1), hrs(n+1);\n\nvoid calcHashes() {\n    pows[0] \u003d {1, 1};\n    hs[0] \u003d hrs[0] \u003d {0, 0};\n    for (int i \u003d 1; i \u0026lt;\u003d n; i++) {\n        pows[i] \u003d {(pows[i-1]._1 * p1) % m1,\n                   (pows[i-1]._2 * p2) % m2};\n        hs[i]   \u003d {(hs [i-1]._1 + pows[i]._1 *  s[i-1]) % m1,\n                   (hs [i-1]._2 + pows[i]._2 *  s[i-1]) % m2};\n        hrs[i]  \u003d {(hrs[i-1]._1 + pows[i]._1 * rs[i-1]) % m1,\n                   (hrs[i-1]._2 + pows[i]._2 * rs[i-1]) % m2};\n    }\n}\n\ninline bool compareSubstrs(int b1, int b2, int len) {\n    if (b1 + len \u0026gt; n || b2 + len \u0026gt; n) {\n        return false;\n    }\n    if (len \u003d\u003d 0) {\n        return true;\n    }\n    Hash h1 \u003d {(m1 + hs [b1 + len]._1 - hs [b1]._1) % m1,\n               (m2 + hs [b1 + len]._2 - hs [b1]._2) % m2};\n    Hash h2 \u003d {(m1 + hrs[b2 + len]._1 - hrs[b2]._1) % m1,\n               (m2 + hrs[b2 + len]._2 - hrs[b2]._2) % m2};\n    if (b1 \u0026lt; b2) {\n        h1._1 \u003d (h1._1 * pows[b2 - b1]._1) % m1;\n        h1._2 \u003d (h1._2 * pows[b2 - b1]._2) % m2;\n    } else {\n        h2._1 \u003d (h2._1 * pows[b1 - b2]._1) % m1;\n        h2._2 \u003d (h2._2 * pows[b1 - b2]._2) % m2;\n    }\n    return (h1._1 \u003d\u003d h2._1) \u0026amp;\u0026amp; (h1._2 \u003d\u003d h2._2);\n}\n\nsigned main() {\n    rs \u003d s;\n    reverse(rs.begin(), rs.end());\n    for (int i \u003d 0; i \u0026lt; sz(rs); i++) {\n        if (rs[i] \u003d\u003d \u00270\u0027) {\n            rs[i] \u003d \u00271\u0027;\n        } else {\n            rs[i] \u003d \u00270\u0027;\n        }\n    }\n    calcHashes();\n    ll ans \u003d 0;\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        int l \u003d 0, r \u003d n;\n        int pivot1 \u003d i, pivot2 \u003d n - i;\n        while (l \u0026lt; r) {\n            int m \u003d (l + r + 1) / 2;\n            if (compareSubstrs(pivot1, pivot2, m)) {\n                l \u003d m;\n            } else {\n                r \u003d m-1;\n            }\n        }\n        ans +\u003d l;\n    }\n    putLn(ans);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e[problem:210970E]\u003c/p\u003e\u003cp\u003e[problem:210970F]\u003c/p\u003e\u003cp\u003eПонятно, что если мы \u0026quot;заблокируем\u0026quot; какую-либо вершинку, то граф распадется на несколько компонент связности (или не распадется). Чтобы восстановить ответ, мы должны для каждой вершины узнать, на компоненты связности какого размера распадется наш граф при удалении этой вершины.\u003c/p\u003e\u003cp\u003eДля того, чтобы это найти, модифиуируем немного алгоритм поиска точек сочленения. Кроме \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etin\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efup\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, мы будем считать ещё и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003est\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — поддерево вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e (если строить дерево по прямым ребрам в dfs-е). Это можно считать обычной динамикой:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003est\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e \u003d 1 + \u003ci\u003est\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eto\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sub\u003e + \u003ci\u003est\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eto\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sub\u003e + ... + \u003ci\u003est\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eto\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eto\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eto\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003eto\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — вершины, в которые мы пошли по прямому ребру из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eТеперь, можно сказать, что если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efup\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eto\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003etin\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, то, значит, при удалении вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e от графа \u0026quot;отколется\u0026quot; компонента связности размером \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003est\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eto\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (в оригинальном алгоритме поиска точек сочленения мы просто помечали, что это точка сочленения). Теперь мы знаем, какие компоненты связности отделились от графа и легко можем вычислить размер оставшейся компоненты связности.\u003c/p\u003e\u003cp\u003eЗная, на какие компоненты связности распадется граф при удалении каждой вершины, легко вычислить число невозможных визитов. Оно будет равно\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003en\u003c/i\u003e·(\u003ci\u003en\u003c/i\u003e - 1) - \u003ci\u003esz\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, 1\u003c/sub\u003e·(\u003ci\u003esz\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, 1\u003c/sub\u003e - 1), \u003ci\u003esz\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, 2\u003c/sub\u003e·(\u003ci\u003esz\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, 2\u003c/sub\u003e - 1), ..., \u003ci\u003esz\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e·(\u003ci\u003esz\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e - 1)\u003c/span\u003e\u003c/p\u003e\u003cp\u003eгде \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esz\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, 1\u003c/sub\u003e, \u003ci\u003esz\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, 2\u003c/sub\u003e, ..., \u003ci\u003esz\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — размеры компонент связности, на которые распадётся граф при удалении вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eАсимптотика решения — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eКод\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eint n \u003d get\u0026lt;int\u0026gt;(), m \u003d get\u0026lt;int\u0026gt;();\nvpii edges \u003d getVector\u0026lt;pii\u0026gt;(m);\nvector\u0026lt;vi\u0026gt; g(n);\nvi used(n, false), tin(n), fup(n), st(n), ans(n);\nint cnt \u003d n * (n-1);\nint timer \u003d 0;\n\nvoid dfs(int v, int p \u003d -1) {\n    tin[v] \u003d fup[v] \u003d timer++;\n    used[v] \u003d true;\n    st[v] \u003d 1;\n    int newCnt \u003d 0, csc \u003d 1;\n    for (int i \u003d 0; i \u0026lt; sz(g[v]); i++) {\n        int to \u003d g[v][i];\n        if (to \u003d\u003d p) {\n            continue;\n        }\n        if (used[to]) {\n            fup[v] \u003d min(fup[v], tin[to]);\n        } else {\n            dfs(to, v);\n            st[v] +\u003d st[to];\n            fup[v] \u003d min(fup[v], fup[to]);\n            if (fup[to] \u0026gt;\u003d tin[v]) {\n                csc +\u003d st[to];\n                newCnt +\u003d st[to] * (st[to] - 1);\n            }\n        }\n    }\n    int lastCmp \u003d n - csc;\n    newCnt +\u003d lastCmp * (lastCmp - 1);\n    ans[v] \u003d cnt - newCnt;\n}\n\nsigned main() {\n    for (int i \u003d 0; i \u0026lt; m; i++) {\n        g[edges[i].F-1].pb(edges[i].S-1);\n        g[edges[i].S-1].pb(edges[i].F-1);\n    }\n    dfs(0);\n    delim \u003d endl;\n    putLn(ans);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e[problem:210970G]\u003c/p\u003e\u003cp\u003eЭто самая сложная и, пожалуй, самая интересная задача. Для того, чтобы понять ее решение, надо сначала рассмотреть несколько случаев. Для упрощения понимания будем также считать случаи, когда одна из групп может быть пуста (эти случаи потом можно будет просто отнять).\u003c/p\u003e\u003cp\u003e\u003cu\u003eСлучай 1.\u003c/u\u003e Граф полный (между каждой парой вершин есть ребро).\u003c/p\u003e\u003cp\u003eЭтот случай самый простой, в нем не может быть более одного конспирата (т. к. если бы два человка были бы конспиратами, они были бы связаны ребром, что невозможно). Значит, всего существует \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + 1\u003c/span\u003e случай, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e — размер графа. Это верно т. к. мы учли все \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e случаев, когда есть один конспират и \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e случай, когда нет ни одного конспирата.\u003c/p\u003e\u003cp\u003e\u003cu\u003eСлучай 2.\u003c/u\u003e Граф пустой (нет ребер вообще)\u003c/p\u003e\u003cp\u003eЭтот случай тоже простой, в нем нет более одного помощника (т. к. если бы два человека были бы помощниками, они не были бы связаны ребром, что невозможно). Тут аналогично есть \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + 1\u003c/span\u003e случай.\u003c/p\u003e\u003cp\u003e\u003cu\u003eСлучай 3.\u003c/u\u003e Граф не полный, не пустой, и в нем есть вершина, соединенная со всеми остальными.\u003c/p\u003e\u003cp\u003eВ этом случае эта вершина является помощником, и ее можно удалить. Докажем это от противного. Пусть эта вершина — конспират. Тогда все остальные вершины — помощники (конспиратами они быть не могут, так как они соединены с конспиратом). Тогда оказывается, что помощники соденинены друг с другом и с конспиратом (т. е. со всеми вершинами), а также конспират соединен со всеми вершинами. Следовательно, граф полный, что противоречит нашему условию.\u003c/p\u003e\u003cp\u003e\u003cu\u003eСлучай 4.\u003c/u\u003e Граф не полный, не пустой, и в нем есть вершина, ни с кем не соединенная.\u003c/p\u003e\u003cp\u003eВ этом случае эта вершина является конспиратом, и ее можно удалить. Доказывается аналогично третьему случаю.\u003c/p\u003e\u003cp\u003e\u003cu\u003eСлучай 5.\u003c/u\u003e Граф не полный, не пустой, и не подпадает под случаи 1-4.\u003c/p\u003e\u003cp\u003eТогда докажем, что вершина, соединенная с максимальным числом других вершин, будет помощником. Чтобы доказать это, предположим обратное. Пусть вершина, соединенная с максимальным числом других вершин (пусть это число будет равно \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e, будет конспиратом. Тогда она будет соединена только с \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e помощниками. Помощников будет ровно \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e (если помощников больше, скажем, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e + 1\u003c/span\u003e, то помощник, соединенный с конспиратом, будет соединен с \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e + 1\u003c/span\u003e вершиной, а конспират — только \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e вершинами, следовательно, он не будет соединен с максимальным числом вершин). Тогда все помощники и этот конспират образуют полный подграф размера \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e + 1\u003c/span\u003e. Остальные вершины — конспираты, и не соединены с помощниками (иначе какой-нибудь помощник был бы соединен с \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e + 1\u003c/span\u003e вершиной). Тогда граф попадает под случай 4. Если таких одиночных вершин нету, тогда граф полный, следовательно, попадает под случай 1. Получили противоречие. Следовательно, вершина, соединенная с максимальным числом других вершин, будет помощником.\u003c/p\u003e\u003cp\u003eВ пятом случае, мы помечаем вершину, соединенную с максимальным числом других вершин, и запускаем поиск в глубину, который помечает, какие вершины однозначно помощники, а какие — конспираты. Как такой поиск в глубину работает? \u003c/p\u003e\u003cp\u003eЕсли вершина, в которой мы стоим — помощник, то все вершины, с которыми она не соединена — конспираты. Помечаем их как конспиратов и запускаем от них поиск в глубину. \u003c/p\u003e\u003cp\u003eЕсли же вершина, в которой мы стоим — конспират, то все вершины, с которыми она соединена — помощники. Помечаем их и запускаем из них поиск в глубину.\u003c/p\u003e\u003cp\u003eЕсли когда нибудь получили противоречие (вершина одновременно и конспират, и помощник), тогда ответ равен нулю. Также, могут остаться непомеченные вершины. Эти вершины могут быть как конспиратами, так и помощниками. Поэтому давайте удалим все помеченные вершины, а из непомеченных вершин будет составлен граф поменьше. Таким образом мы уменьшим наш граф.\u003c/p\u003e\u003cp\u003eИсходя из разбора всех пяти случаев, можно построить итоговый алгоритм. На каждой фазе он будет удалять одну или несколько вершин, до тех пор, пока граф не станет полным или пустым (или в нем не останется вершин). Он будет выглядеть примерно так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eпока граф не полный, не пустой и в нем есть вершины\n\tесли есть вершина, не соединенная ни с кем\n\t\tудаляем ее\n\t\tcontinue;\n\tесли есть вершина, соединенная со всеми\n\t\tудаляем ее\n\t\tcontinue;\n\tнаходим вершину, соединенную с максимальным числом других вершин\n\tзапускаем из нее поиск в глубину\n\tесли есть вершина, являющаяся и конспиратом, и помощником одновременно\n\t\tответ \u003d 0\n\t\treturn 0;\n\tудаляем все помеченные вершины\nответ \u003d размер графа + 1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЕсли аккуратно реализовать этот алгоритм, можно добиться квадратичной асимптотики. Как это сделать? Во-первых, надо хранить степень каждой вершины и суммарное количество ребер (для нахождения вершины с максимальной степенью и проверки, является ли граф полным или пустым). Во-вторых, надо уметь пересчитывать это при удалении за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eАсимптотика решения — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eКод\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eint n;\nint a[5000][5000] \u003d {};\nint cnt[5000];\nint totCnt \u003d 0;\nbool used[5000];\nint mark[5000];\nint left;\n\nvoid del(int v) {\n    if (!used[v]) {\n        return;\n    }\n    used[v] \u003d false;\n    totCnt -\u003d cnt[v];\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        if (used[i]) {\n            cnt[i] -\u003d a[v][i];\n            totCnt -\u003d a[v][i];\n        }\n    }\n    left--;\n}\n\nbool isFullOrEmpty() {\n    if (totCnt \u003d\u003d 0) {\n        return true;\n    }\n    if (totCnt \u003d\u003d left * (left-1)) {\n        return true;\n    }\n    return false;\n}\n\nvoid dfs(int v) {\n    if (mark[v] \u003d\u003d 3) {\n        return;\n    }\n    bool conspirat \u003d (mark[v] \u003d\u003d 2);\n    int newMark \u003d conspirat ? 1 : 2;\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        if (used[i] \u0026amp;\u0026amp; v !\u003d i) {\n            if ((!conspirat) \u003d\u003d a[v][i]) {\n                int wasMark \u003d mark[i];\n                mark[i] |\u003d newMark;\n                if (wasMark !\u003d mark[i]) {\n                    dfs(i);\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    n \u003d getInt();\n    left \u003d n;\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        int q \u003d getInt();\n        cnt[i] +\u003d q;\n        totCnt +\u003d q;\n        for (int j \u003d 0; j \u0026lt; q; j++) {\n            int k \u003d getInt() - 1;\n            a[i][k] \u003d 1;\n        }\n    }\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        mark[i] \u003d 0;\n        used[i] \u003d true;\n    }\n    if (isFullOrEmpty()) {\n        putInt(n);\n        return 0;\n    }\n    while (!isFullOrEmpty()) {\n        bool delSmth \u003d false;\n        for (int i \u003d 0; i \u0026lt; n; i++) {\n            if (used[i]) {\n                if (cnt[i] \u003d\u003d 0 || cnt[i] \u003d\u003d left-1) {\n                    del(i);\n                    delSmth \u003d true;\n                    break;\n                }\n            }\n        }\n        if (delSmth) {\n            continue;\n        }\n        int val \u003d -1, k \u003d -1;\n        for (int i \u003d 0; i \u0026lt; n; i++) {\n            if (used[i]) {\n                if (cnt[i] \u0026gt; val) {\n                    val \u003d cnt[i];\n                    k \u003d i;\n                }\n            }\n        }\n        mark[k] |\u003d 2;\n        dfs(k);\n        for (int i \u003d 0; i \u0026lt; n; i++) {\n            if (mark[i] \u003d\u003d 3) {\n                putInt(0);\n                return 0;\n            } else if (mark[i] !\u003d 0) {\n                del(i);\n            }\n        }\n    }\n    putInt(left + 1);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["разбор","федя","долго читать","подготовка к области"]}}