{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1500466427,"rating":0,"authorHandle":"metatron","modificationTimeSeconds":1500652838,"id":53380,"title":"\u003cp\u003eConcurs Dimecres: Solucions\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eAquí teniu les solucions de cada problema:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblema A\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eSimplement havíeu de comptar quants elements de l\u0027array que us donaven eren divisibles per \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nint main(){\n    int a, x, compt \u003d 0;\n    cin \u0026gt;\u0026gt; x;\n    while (cin \u0026gt;\u0026gt; a){\n        if (a % x \u003d\u003d 0) ++compt;\n    }\n    cout \u0026lt;\u0026lt; compt \u0026lt;\u0026lt; endl;    \n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblema B\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eVolem veure si \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e és producte de dos primers diferents. Podem veure-ho de dos maneres diferents.\u003c/p\u003e\u003cp\u003ea) Aprofitant que el primer divisor que us trobeu és primer (el perquè està explicat a la solució del problema D del concurs de divendres), un cop trobat aquest divisor \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, és fàcil veure que \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e és producte de dos primers diferents si i només si \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e / \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e també és primer. Noteu que el bucle no arriba a \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/90/d5/90d5a6cd550a25d4a1e92f4f6e6a222c64aa7a2e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, ja que si \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/90/d5/90d5a6cd550a25d4a1e92f4f6e6a222c64aa7a2e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e fos un enter i el primer divisor de \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, llavors \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e seria el quadrat d\u0027un primer, i per tant no seria producte de dos primers diferents.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nbool primer(int n){\n    if (n \u0026lt;\u003d 1) return false;\n    for (int i \u003d 2; i*i \u0026lt;\u003d n; ++i){\n        if (n % i \u003d\u003d 0) return false;\n    }\n    return true;\n}\n\nint main(){\n    int n;\n    while (cin \u0026gt;\u0026gt; n){\n        int i \u003d 2;\n        while (i*i \u0026lt; n and n % i !\u003d 0) ++i;\n        if (i*i \u0026lt; n and primer(n/i)) cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026quot;: si\u0026quot; \u0026lt;\u0026lt; endl;\n        else cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026quot;: no\u0026quot; \u0026lt;\u0026lt; endl;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eb) És fàcil veure que \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e és producte de dos primers diferents si i només si hi ha un sol divisor (diferent de 1) menor que \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/90/d5/90d5a6cd550a25d4a1e92f4f6e6a222c64aa7a2e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Penseu per què. Aquí, compteu quants divisors menors que \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/90/d5/90d5a6cd550a25d4a1e92f4f6e6a222c64aa7a2e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e teniu, Si \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e és divisor de \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e però \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e * \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e també, sumem 1 al comptador per a obtenir que no tenim un producte de primers.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nint main(){\n    int n;\n    while (cin \u0026gt;\u0026gt; n){\n        int c \u003d 0;\n        for (int i \u003d 2; i*i \u0026lt; n and c \u0026lt; 2; ++i){\n            if (n % i \u003d\u003d 0){\n                if (n % (i*i) \u003d\u003d 0) c++;\n                c++;\n            }\n        }\n        if (c \u003d\u003d 1) cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026quot;: si\u0026quot; \u0026lt;\u0026lt; endl;\n        else cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026quot;: no\u0026quot; \u0026lt;\u0026lt; endl;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblema C\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eComproveu que es pot construir un triangle no degenerat, és a dir, que la suma de les longituds de dos dels seus costats sigui major que la de l\u0027altre. Si el Teorema de Pitàgores es compleix, escriviu l\u0027àrea del triangle.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nint main(){\n    int a, b, c;\n    while (cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c){\n        if (a + b \u0026gt; c and a + c \u0026gt; b and b + c \u0026gt; a){\n            if(a*a + b*b \u003d\u003d c*c) cout \u0026lt;\u0026lt; a*b/2 \u0026lt;\u0026lt; endl;\n            else if (a*a + c*c \u003d\u003d b*b) cout \u0026lt;\u0026lt; a*c/2 \u0026lt;\u0026lt; endl;\n            else if (b*b + c*c \u003d\u003d a*a) cout \u0026lt;\u0026lt; b*c/2 \u0026lt;\u0026lt; endl;\n            else cout \u0026lt;\u0026lt; \u0026quot;yes\u0026quot; \u0026lt;\u0026lt; endl;\n        }\n        else cout \u0026lt;\u0026lt; \u0026quot;no\u0026quot; \u0026lt;\u0026lt; endl;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblema D\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eHeu de buscar el dígit més freqüent en base b. És fàcil comptar quants cops apareix cada dígit amb un bucle, i després itereu sobre els dígits per saber quin és el més freqüent, tenint en compte que en cas d\u0027empat escriurem el més gran. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n\nusing namespace std;\n\nint main(){\n    int n, b;\n    while (cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; b){\n        vector\u0026lt;int\u0026gt; comptador(b, 0);\n        while (n !\u003d 0){\n            ++comptador[n%b];\n            n \u003d n/b;\n        }\n        int maxim \u003d 0;\n        for (int i \u003d 1; i \u0026lt; b; ++i) if(comptador[i] \u0026gt;\u003d comptador[maxim]) maxim \u003d i;\n        cout \u0026lt;\u0026lt; maxim \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; comptador[maxim] \u0026lt;\u0026lt; endl;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblema E\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eDues possibles solucions. \u003c/p\u003e\u003cp\u003ea) Com que \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/af/25/af25231cc5704a476d62576bfdacbd25069f6428.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, busqueu el valor de \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e que faci que el nombre \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e que us donen sigui \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3c/0a/3c0ab6589f24796df0c57a24ad23ad652c52fbc4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Això es fa resolent l\u0027equació de segon grau. Prenent \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u003d ⌈ \u003ci\u003ex\u003c/i\u003e⌉\u003c/span\u003e (l\u0027enter més petit que sigui més gran o igual que \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e), la nostra solució serà \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f2/8b/f28ba4068b6f7938ed97735849c44a99596595c3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n\nusing namespace std;\n\nint main(){\n    long long n;\n    while (cin \u0026gt;\u0026gt; n){\n        long long i \u003d ceil((sqrt(1+8*n)-1)/2);\n        cout \u0026lt;\u0026lt; i*(i+1)/2 \u0026lt;\u0026lt; endl;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eb) Com que \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/af/d1/afd16dccfa01bc6d70df0318d8c31a6f1bce6d2c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e és creixent en \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, Anem mirant amb quins resultats ens passem o ens quedem curts, usant una cerca binaria, fins que l\u0027interval que tenim contingui un sol element. Aquí, la solució està entre \u003ccode\u003el\u003c/code\u003e i \u003ccode\u003er\u003c/code\u003e, ambdós inclosos.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\nusing namespace std;\n\nint main() {\n\tint n;\n\twhile (cin \u0026gt;\u0026gt; n) {\n\t\tlong long int l \u003d 0, r \u003d 2000000000;\n\t\twhile (r - l \u0026gt;\u003d 1){\n\t\t\tlong long int m \u003d (l+r)/2;\n\t\t\tif (m*(m+1)/2 \u0026lt; n) l \u003d m + 1;\n\t\t\telse if (m*(m+1)/2 \u003d\u003d n){\n\t\t\t\tl \u003d m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse r \u003d m;\n\t\t}\n\t\tcout \u0026lt;\u0026lt; l*(l+1)/2 \u0026lt;\u0026lt; endl;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblema F\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nint gcd(int a, int b){\n\tif (b \u003d\u003d 0) return a;\n\treturn gcd(b, a % b);\n}\n\nint main(){\n\tint a, b;\n\twhile(cin \u0026gt;\u0026gt; b \u0026gt;\u0026gt; a){\n        int ample \u003d 2*gcd(a - 1, b - 1);\n        for (int i \u003d 0; i \u0026lt; a + 2; i++) cout \u0026lt;\u0026lt; \u0026quot;#\u0026quot;;\n        cout \u0026lt;\u0026lt; endl;\n        for (int i \u003d 0; i \u0026lt; b; i++){\n            cout \u0026lt;\u0026lt; \u0026quot;#\u0026quot;;\n            for (int j \u003d 0; j \u0026lt; a; j++){\n                if((i - j)%ample \u003d\u003d 0 or (i + j)%ample \u003d\u003d 0) cout \u0026lt;\u0026lt; 0;\n                else cout \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n            }\n            cout \u0026lt;\u0026lt; \u0026quot;#\u0026quot; \u0026lt;\u0026lt; endl;\n        }\n        for (int i \u003d 0; i \u0026lt; a + 2; i++) cout \u0026lt;\u0026lt; \u0026quot;#\u0026quot;;\n        cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblema G\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eSupertrivial veure que guanyava en Tourist si i només si \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e era potència de 2.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nint main(){\n    int n;\n    while (cin \u0026gt;\u0026gt; n){\n        bool potencia \u003d true;\n        while (n !\u003d 1 and potencia){\n            if (n % 2 \u003d\u003d 0) n /\u003d 2;\n            else potencia \u003d false;\n        }\n        if (potencia) cout \u0026lt;\u0026lt; \u0026quot;Tourist\u0026quot; \u0026lt;\u0026lt; endl;\n        else cout \u0026lt;\u0026lt; \u0026quot;Petr\u0026quot; \u0026lt;\u0026lt; endl;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}