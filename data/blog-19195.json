{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1436793608,"rating":0,"authorHandle":"oi111","modificationTimeSeconds":1436793679,"id":19195,"title":"\u003cp\u003eSGU 379. Elevator\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003col\u003e   \u003cli\u003eElevator\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eTime limit per test: 0.75 second(s) Memory limit: 65536 kilobytes input: standard output: standard\u003c/p\u003e\u003cp\u003eThere is only one elevator in the tall building with N floors. The parking for this building is at the basement floor which is located under the first floor. All floors are enumerated from 1 to N, growing up. At i-th floor there are Ai people who wish to descend from the floor to parking. You know that the elevator is unable to carry more than C people at any time. Descending or ascending one floor takes P seconds. Your task is to find the maximum possible number of people the elevator may deliver to parking within T seconds of operation, if it is located at the parking in the beginning. You may assume that stopping at a stage to load or unload people is done instantly.\u003c/p\u003e\u003cp\u003eInput In the first line of input file there are four integers N, C, P, T (1 ≤ N ≤ 100, 1 ≤ C ≤ 109, 1 ≤ P ≤ 109, 1 ≤ T ≤ 109). The second line contains the sequence of N integers A1, A2,..., AN (0 ≤ Ai ≤ 109). The sum of all Ai does not exceed 109 too.\u003c/p\u003e\u003cp\u003eOutput Output the maximum possible number of people who can reach the parking.\u003c/p\u003e\u003cp\u003eExample(s) sample input sample output 4 5 2 15 0 1 2 3 3\u003c/p\u003e\u003cp\u003esample input sample output 4 5 2 18 0 1 2 3 5\u003c/p\u003e\u003cp\u003esample input sample output 3 2 1 9 1 1 1 3\u003c/p\u003e\u003cp\u003eOnline Contester Team © 2002 — 2010. All rights reserved.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e\u003cbr /\u003e#include \u0026lt;iostream\u0026gt;\n#include\u0026lt;stdio.h\u0026gt;\nusing namespace std;\nlong long a[1000],b[1000],n,c,p,t;\nbool dog(int num)\n{\n    long long peo,i,j,tot,floor,t1;\n    for(i\u003d1;i\u0026lt;\u003dn;i++)\n        if (b[i]\u0026gt;\u003dnum) break;\n    floor\u003di;\n    peo\u003dnum-b[i-1];\n    tot\u003d0;\n    for(i\u003dfloor;i\u0026gt;\u003d1;)\n    {\n        tot\u003dtot+(peo%c\u003d\u003d0?peo/c:peo/c+1)*2*p*i;\n        if (tot\u0026gt;t) return false;\n        t1\u003dpeo%c;\n        if (t1\u003d\u003d0)\n        {\n            i\u003di-1;\n            peo\u003da[i];\n            continue;\n        }\n        for(j\u003di-1;j\u0026gt;\u003d1;j--)\n            if (a[j]+t1\u0026gt;\u003dc) break;\n            else\n                t1+\u003da[j];\n        peo\u003da[j]-(c-t1);\n        i\u003dj;\n    }\n    if (tot\u0026lt;\u003dt) return true;\n    return false;\n}\nint main()\n{\n    long long i,left,right,ans,mid;\n    while(scanf(\u0026quot;%lld%lld%lld%lld\u0026quot;,\u0026amp;n,\u0026amp;c,\u0026amp;p,\u0026amp;t)!\u003dEOF)\n    {\n        for(i\u003d1;i\u0026lt;\u003dn;i++)\n            scanf(\u0026quot;%lld\u0026quot;,\u0026amp;a[i]);\n        b[0]\u003d0;\n        a[0]\u003d0;\n        for(i\u003d1;i\u0026lt;\u003dn;i++)\n            b[i]\u003db[i-1]+a[i];\n        left\u003d0;\n        right\u003db[n];\n        ans\u003d0;\n        while(left\u0026lt;\u003dright)\n        {\n            mid\u003d(left+right)/2;\n            if (dog(mid))\n            {\n                ans\u003dmid;\n                left\u003dmid+1;\n            }\n            else\n                right\u003dmid-1;\n        }\n        printf(\u0026quot;%lld\\n\u0026quot;,ans);\n    }\n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}