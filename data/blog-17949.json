{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1431942662,"rating":3,"authorHandle":"sidchelseafan","modificationTimeSeconds":1431943736,"id":17949,"title":"\u003cp\u003eMAY Long Codechef — CHEFCK\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello, The May Long contest just concluded. I need some help regarding the problem CHEFCK. Unfortunately I couldn\u0027t solve it , even though I tried it for 4-5 days :( .\u003c/p\u003e\u003cp\u003e(\u003ca\u003ehttp://www.codechef.com/MAY15/problems/CHEFCK)\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eI would describe my approach(es) to this problem and would appreciate it if someone could tell me where my thought process was slow/wrong. All of my codes are correct, I couldn\u0027t clear the 3rd subtask of the problem.\u003c/p\u003e\u003ch1\u003e1st Approach\u003c/h1\u003e\u003cp\u003eI initially , tried solving it by using A segment tree. The time was O(n + Q*log(2*k)), it timed out.\u003c/p\u003e\u003cp\u003ethe link — \u003ca href\u003d\"http://www.codechef.com/viewsolution/6912313\"\u003ehttp://www.codechef.com/viewsolution/6912313\u003c/a\u003e.\u003c/p\u003e\u003ch1\u003e2nd Approach\u003c/h1\u003e\u003cp\u003eI then got to know about Range Minimum Query from Topcoder. I read the article and then built the sparse table as described. Even that timed out. I divide the table into blocks of size log(n) and create a ST on the block minimums and then create ST for each and every block. Even this timed out.\u003c/p\u003e\u003cp\u003eThe Link -; \u003ca href\u003d\"http://www.codechef.com/viewsolution/6928522\"\u003ehttp://www.codechef.com/viewsolution/6928522\u003c/a\u003e\u003c/p\u003e\u003ch1\u003e3rd Approach\u003c/h1\u003e\u003cp\u003eFurther optimization, I banged my head a little bit more and got to know about Cartesian Trees from Stanford CS166. I learn that there are only a limited number of block types for RMQ for a size b, there are 4^b rmq structures possible and that can be calculated using Cartesian Trees. I did that too. I calculate Cartesian tree number for each block and if it hasn\u0027t been calculated before, I calculate and memoize it in a table otherwise I reuse the already calculated RMQ structure. Unfortunately Even this timed out. I coded the approach given here and it was O(n*log(log(n) + (n/log(n))*(log(n/log(n)) + (4^b)*b*b)\u003c/p\u003e\u003cp\u003e(\u003ca href\u003d\"http://web.stanford.edu/class/archive/cs/cs166/cs166.1146/lectures/01/Slides01.pdf\"\u003ehttp://web.stanford.edu/class/archive/cs/cs166/cs166.1146/lectures/01/Slides01.pdf\u003c/a\u003e)\u003c/p\u003e\u003cp\u003e[submission link] — (\u003ca\u003ehttp://www.codechef.com/viewsolution/6960288)http://www.codechef.com/viewsolution/6960288\u003c/a\u003e\u003c/p\u003e\u003ch1\u003e4th and Final Approach\u003c/h1\u003e\u003cp\u003eI then realized that the pseudo random generator was periodic (duh!) and the same block was repeating in the array A. I also got to know about Sliding Range Minimum Query , I implemented a solution but cleared just one testcase of the 3rd subtask. [Submission] — (\u003ca\u003ehttp://www.codechef.com/viewsolution/6971896)\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eCould someone tell me What I failed to observe to solve this problem. Also, could someone brief me on how and when I should be using the Sliding RMQ method, The WCIPeg website is very brief about it. Would appreciate if someone could also tell me how they implemented the approach given on Topcoder using Euler Tour of the Cartesian Tree and so forth. I am reading the codes and the editorial and trying to understand now and would appreciate some help.\u003c/p\u003e\u003cp\u003eSorry for the long post and not using latex for posting complexities. Thanks :)\u003c/p\u003e\u003c/div\u003e","tags":["codechef","long challenge","rmq","cartesian tree"]}}