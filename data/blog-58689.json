{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1522655151,"rating":1,"authorHandle":"zscoder","modificationTimeSeconds":1522655578,"id":58689,"title":"\u003cp\u003eApril Fools Contest 2018 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHere\u0027s a brief summary of the solutions :\u003c/p\u003e\u003ch2\u003eA. Guess The Sequence\u003c/h2\u003e\u003cp\u003eThe joke here is that the given modulo was wrong. The given sequence is in fact the Fibonacci sequence. Once you guessed that the modulo is wrong, you can find it easily by taking the last sample. Subtract the sample output from the actual 50th Fibonacci number, and find all its divisors (there are \u003cspan class\u003d\"tex-span\"\u003e8\u003c/span\u003e). Then, just try all of them (in fact we can ignore those \u003cspan class\u003d\"tex-span\"\u003e ≤ 610\u003c/span\u003e) and see which one works. (the actual modulo is \u003cspan class\u003d\"tex-span\"\u003e63169\u003c/span\u003e).\u003c/p\u003e\u003ch2\u003eB. Game\u003c/h2\u003e\u003cp\u003eThe answer is P1 win if all elements are \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, P2 win if all elements are \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e and Unclear otherwise, because it\u0027s not stated that both players play optimally.\u003c/p\u003e\u003ch2\u003eC. Smallest Common Divisor\u003c/h2\u003e\u003cp\u003eThe smallest common divisor of two integers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e is clearly \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9d/35/9d35350b0c7c07b146ecbd8ea4d0ce2ad8d95cf6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. However, the samples show that the answer is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e3, 5\u003c/span\u003e. The joke here is that the sample shown is actually wrong and the answer is indeed \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9d/35/9d35350b0c7c07b146ecbd8ea4d0ce2ad8d95cf6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003ch2\u003eD. A+B\u003c/h2\u003e\u003cp\u003eApril Fools Day is the day people fail on A+B problem. This year, the entire problem is the joke and your output is correct if and only if it\u0027s an integer and it\u0027s NOT equal to the sum of the two integers in the input. (for example, printing \u003cspan class\u003d\"tex-span\"\u003e2018\u003c/span\u003e works).\u003c/p\u003e\u003ch2\u003eE. Secret\u003c/h2\u003e\u003cp\u003eThe statement is encrypted using substitution cipher. After decryption, it will lead to the following link : \u003ca href\u003d\"https://drive.google.com/file/d/1G4eTL1mT_5Iz0tvgf41twbVOdkSCT3iW/view?usp\u003dsharing\"\u003ehttps://drive.google.com/file/d/1G4eTL1mT_5Iz0tvgf41twbVOdkSCT3iW/view?usp\u003dsharing\u003c/a\u003e\u003c/p\u003e\u003cp\u003eHere you will find a textfile with \u003cspan class\u003d\"tex-span\"\u003e100000\u003c/span\u003e integers. However, the source code limit for CF is small, so you can\u0027t hardcode the answer for all values. If you google the numbers, you will find that they actually appeared as the input for some other problems before. If you look more closely, you will find this \u003ca href\u003d\"https://github.com/ArunEworld/Computer_Programming/blob/master/C/Examples/Random_Number_Generator/AEW_RandomNumberGenerator.c\"\u003elink\u003c/a\u003e. From here, we can see that the numbers are generated with the C++ default rand() function without specifying a seed, so we can just reproduce it in our code.\u003c/p\u003e\u003ch2\u003eF. Evil\u003c/h2\u003e\u003cp\u003eAs usual, the problem has nothing to do with English words.\u003c/p\u003e\u003cp\u003eNote that all words in the input only consists of \u0027a\u0027 to \u0027f\u0027. Let\u0027s view them as a hexadecimal number. You should output Evil if the number is an \u003ca href\u003d\"https://en.wikipedia.org/wiki/Evil_number\"\u003eEvil Number\u003c/a\u003e and Not Evil otherwise.\u003c/p\u003e\u003ch2\u003eG. Art\u003c/h2\u003e\u003cp\u003eThe horrible drawing is actually trying to say something about a 3D walk returning to the starting point.\u003c/p\u003e\u003cp\u003eA simple googling gives something about \u003ca href\u003d\"http://mathworld.wolfram.com/PolyasRandomWalkConstants.html\"\u003ePolya\u0027s Theorem\u003c/a\u003e. In the article, it is mentioned that the probability for 3D random walks to return to their initial point is \u003cspan class\u003d\"tex-span\"\u003e \u0026lt; 1\u003c/span\u003e, and the constant is also given. In this problem, you\u0027re given \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and you should output the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e-th digit in the decimal expansion of that probability (hinted by the output is less than \u003cspan class\u003d\"tex-span\"\u003e10\u003c/span\u003e note). It\u0027s also a sequence in oeis : \u003ca href\u003d\"http://oeis.org/A086230\"\u003elink\u003c/a\u003e\u003c/p\u003e\u003ch2\u003eH. 2E91ZdB\u003c/h2\u003e\u003cp\u003eThis problem is actually very similar to E. If you google the title, you will find some random search results. However, if you look closely, one of them contains a bit.ly link which contains the title string (with different cases). This suggests that the title is actually part of a link and we get \u003ca href\u003d\"bit.ly/2E91ZdB\"\u003ebit.ly/2E91ZdB\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eAgain, we see a text file with \u003cspan class\u003d\"tex-span\"\u003e100000\u003c/span\u003e numbers. However, this time the numbers doesn\u0027t have a clear pattern. There are only \u003cspan class\u003d\"tex-span\"\u003e10\u003c/span\u003e testcases (excluding samples), so the intended solution is to extract information from the test data using CF judge responses. The traditional way is to binary search the input with asserts, but that takes \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/81/94/8194ae37d7c0ea57fd3c308569b6c0be5b8f08f0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e tries, which is quite slow. A faster way is to abuse the time usage and memory usage and we can extract a lot of data per run. However, the memory usage part might be a bit inconsistent and it\u0027s harder to extract data using it so it\u0027s recommended to just use time usage (for instance, print \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/60/10/601032a6392e5091cae31f16f855ecd344312b74.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e numbers or something like that to get the first few digits of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, and do it again for the last few digits). With a good implementation, each testcase can be extracted in at most \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e tries, so \u003cspan class\u003d\"tex-span\"\u003e20\u003c/span\u003e tries is sufficient.\u003c/p\u003e\u003c/div\u003e","tags":[]}}