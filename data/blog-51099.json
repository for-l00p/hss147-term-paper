{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1489984494,"rating":39,"authorHandle":"usernameson","modificationTimeSeconds":1490059284,"id":51099,"title":"\u003cp\u003eFunction Range Trick\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003eDisclaimer\u003c/h4\u003e\u003cp\u003eI do not know if this technique has another name. I came up with it to solve specific types of problems but it probably has been done by many others before.\u003c/p\u003e\u003ch4\u003eThe situation\u003c/h4\u003e\u003cp\u003eAssume we are given a sequence of numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and we have a function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e that is well defined for all sequences of numbers with the property \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, ..., \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e) \u003d \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, ..., \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/sub\u003e), \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e for any sequence b and the range of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e has size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e, which is relatively small. Our goal is to rearrange the numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e so that when the sequence is entered into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e in this order the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e is optimised (minimised or maximised).\u003c/p\u003e\u003ch4\u003eThe solution\u003c/h4\u003e\u003cp\u003eIf we try to brute force all permutations of the sequence there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e!\u003c/span\u003e options which is usually too slow. However what we can do is use dynamic programming and for each sequence ending in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e with m terms store all possible values of f. Since we know the range of f is K at each step we are storing at most K terms. \u003c/p\u003e\u003ch4\u003eCost analysis\u003c/h4\u003e\u003cp\u003eTo calculate all possible values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e for a sequence ending in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e + 1\u003c/span\u003e terms given we have calculated all possible values for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e with sequence with m terms we need at most \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e - 1)\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e calculations. Doing this for each term to calculate all possible values for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e with a sequence of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e + 1\u003c/span\u003e terms gives at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e - 1)\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e calculations. Doing it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e times since we need sequences of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e gives at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e(\u003ci\u003en\u003c/i\u003e - 1)\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e. Finally to find the optimised value requires at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enK\u003c/i\u003e\u003c/span\u003e more calculations. So at worst we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e(\u003ci\u003en\u003c/i\u003e - 1)\u003ci\u003eK\u003c/i\u003e + \u003ci\u003enK\u003c/i\u003e\u003c/span\u003e calculations. \u003c/p\u003e\u003ch4\u003eNoticing the situation\u003c/h4\u003e\u003cp\u003eThe nature of the function is what determines whether this situation occurs. If the function is based on bitwise operations and the values of the sequence are small there is a good chance that this technique applies. Also if the function is based on arithmetic modulo N where N is small this technique might also apply.\u003c/p\u003e\u003ch4\u003eWorked Example\u003c/h4\u003e\u003cp\u003eI used this technique to solve the problem trysail from topcoder. \u003ca href\u003d\"https://community.topcoder.com/stat?c\u003dproblem_statement\u0026amp;pm\u003d14307\"\u003ehttps://community.topcoder.com/stat?c\u003dproblem_statement\u0026amp;pm\u003d14307\u003c/a\u003e. The general idea of the question is you have a sequence of at most 50 numbers that are between 0 and 255 and you want to split them into three non-empty groups so that when you take the xor of each group and sum them the result is maximised. \u003c/p\u003e\u003cp\u003eMy approach: First we note when we xor any group of elements the result will be an integer between 0 and 255 inclusive. Next xor clearly satisfies the property required for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e given above. These are strong hints that we can use the function range trick. Next we need to figure out a way to deal with three groups. Since the numbers are small we can store the xor of each group in an int letting the first 8 bits store group 1, the next 8 bits store group 2 and the next 8 bits store group 3. We also note since we are only concerned with maximising the sum we can treat certain groupings as equivalent to reduce the number of cases to consider.\u003c/p\u003e\u003cp\u003eNow assume for the first i elements we have stored all the xors of all possible groupings and we want to add the i+1th element and get the xors of all possible groupings with first i+1 elements. Turns out for each possible grouping there are six ways to do this up to equivalence, we either add the new element to one of the existing groups or give the new element its own group and combine the three previous groups into two. This is where the function range trick comes into play. Even though it looks like we are generating a lot of new groups every time we add a new element since the range of xor is limited many of these new groupings result in the same value for xor. Implementation wise we can use a set for storage so repeated elements will only be stored once. \u003c/p\u003e\u003cp\u003eCode\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;set\u0026gt;\n#include\u0026lt;vector\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n#include\u0026lt;iostream\u0026gt;\nusing namespace std;\n\nclass TrySail{\n        \n    public:\n    int get(vector\u0026lt;int\u0026gt; v){\n        set\u0026lt;int\u0026gt; prev; \n        \n        //put the first three elements in a separate group\n        prev.insert(v[0]+(v[1]\u0026lt;\u0026lt;8)+(v[2]\u0026lt;\u0026lt;16));\n\n        //given all possible xors when i elements are grouped\n        //store all possible xors when i+1 elements are grouped\n        for(int i\u003d3; i\u0026lt;v.size(); i++){\n            set\u0026lt;int\u0026gt; next;\n            \n            for(int j:prev){\n                next.insert(j^v[i]);\n                next.insert(j^(v[i]\u0026lt;\u0026lt;8));\n                next.insert(j^(v[i]\u0026lt;\u0026lt;16));\n                \n                int x\u003dj%(1\u0026lt;\u0026lt;8);\n                int y\u003d(j\u0026gt;\u0026gt;8)%(1\u0026lt;\u0026lt;8);\n                int z\u003dj\u0026gt;\u0026gt;16;\n                next.insert(v[i]+((x^y)\u0026lt;\u0026lt;8)+(z\u0026lt;\u0026lt;16));\n                next.insert(v[i]+((x^z)\u0026lt;\u0026lt;8)+(y\u0026lt;\u0026lt;16));\n                next.insert(v[i]+((y^z)\u0026lt;\u0026lt;8)+(x\u0026lt;\u0026lt;16));\n            }\n            prev\u003dnext;\n        }\n        int ans\u003d0;\n\n        //find the largest answer\n        for(int i:prev){\n            int x\u003di%(1\u0026lt;\u0026lt;8);\n            int y\u003d(i\u0026gt;\u0026gt;8)%(1\u0026lt;\u0026lt;8);\n            int z\u003di\u0026gt;\u0026gt;16;\n            \n            \n            int sum\u003dx+y+z;\n            ans\u003dmax(ans,sum);\n        }\n        \n        return ans;\n    }\n};\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs a final note this code passes the system tests but it gets quite close to the time limit for certain inputs with 50 elements. \u003c/p\u003e\u003c/div\u003e","tags":["dp","math"]}}