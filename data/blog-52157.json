{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1495641232,"rating":41,"authorHandle":"Xellos","modificationTimeSeconds":1497050783,"id":52157,"title":"\u003cp\u003eQTDDTOB\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eQuestions That Don\u0027t Deserve Their Own Blog — I guess it\u0027d be good to have something like this as a place to ask random questions about problems (\u0026quot;I accidentally my code, wat do?\u0026quot;) without having your blog post get downvotebombed?\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eold question\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eI have a question about \u003ca href\u003d\"https://contest.yandex.ru/algorithm2015/contest/1299/problems/E/\"\u003eYandex.Algorithm 2015 round 2.2E\u003c/a\u003e: the problem can be reduced to computing the min. bipartite vertex cover \u003cem\u003ethat can\u0027t fully cover one side\u003c/em\u003e and since the dual of min. vertex cover is max. matching, I tried to find the dual of this problem.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/f0/3a/f03a57748478f863fac18235ba73490ddef68a9b.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eI mean, that vertex cover can be described as a linear programming problem \u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/06/f0/06f0ec4361f9d70355b12cceb9b8c2d1e9269279.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≥ 0\u003c/span\u003e\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e + \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e ≥ 1\u003c/span\u003e for each edge \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u003d (\u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e), 1 ≤ \u003ci\u003ej\u003c/i\u003e ≤ \u003ci\u003eE\u003c/i\u003e\u003c/span\u003e\u003c/li\u003e   \u003cli\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/72/3e/723e3d1df2833beff68e6160e1745167598fb6c1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eIts dual should be\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1c/07/1c07514481bb43e798e7390ed2d2613a855d81fe.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/li\u003e   \u003cli\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/67/5a/675a19436fb09937bc5711b78d56434cb0aef81f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/li\u003e   \u003cli\u003efor \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b0/04/b00483c4c83ed4e51fb11ffb2bd4a46f27e56a3c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (sum over edges incident on vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e in the left part)\u003c/li\u003e   \u003cli\u003efor \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e + 1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003eN\u003c/i\u003e + \u003ci\u003eM\u003c/i\u003e\u003c/span\u003e, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/12/51/125130778e298db52362aee3e67ad8667834bf08.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (same as above for the right part)\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e are variables assigned to edges (flow through them); \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9b/4e/9b4e4b27ae674007eacba8947c6b3addb678681a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e are assigned to the left and right part of the graph and if they\u0027re fixed, finding the optimal \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is just bipartite matching/flow. However, this gives the optimal solution as \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ac/43/ac439424015b3b7fbe1948b8791dd3064911600b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for example for an almost complete bipartite graph \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eN\u003c/i\u003e, \u003ci\u003eN\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e that\u0027s missing just one edge, which doesn\u0027t make sense.\u003c/p\u003e\u003cp\u003eWhat am I missing here?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eNext: I was upsolving DCJ problems during the second practice round (which ended yesterday). The only non-final problem I didn\u0027t manage to solve in time was highest_mountain and only because it gives me weird RE.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026quot;highest_mountain.h\u0026quot;\n// iostream is too mainstream\n#include \u0026lt;cstdio\u0026gt;\n// bitch please\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;list\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;iomanip\u0026gt;\n#include \u0026lt;time.h\u0026gt;\n#include \u0026lt;message.h\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE \u003dCAKE.begin(); LIE !\u003d CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x \u0026lt; 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\n#define MASTER_NODE 0\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(10);\n\tint nodes \u003dNumberOfNodes(), my_id \u003dMyNodeId();\n\tint N \u003dNumberOfPeaks();\n\n\tvector\u0026lt;int\u0026gt; ilen(nodes,N/nodes);\n\tfor(int i \u003d0; i \u0026lt; N%nodes; i++) ilen[i]++;\n\tint L \u003d0, R \u003d0;\n\tfor(int i \u003d0; i \u0026lt; my_id; i++) L +\u003dilen[i];\n\tfor(int i \u003d0; i \u0026lt;\u003d my_id; i++) R +\u003dilen[i];\n\n\tvector\u0026lt; pair\u0026lt;cat,int\u0026gt; \u0026gt; H;\n\tH.dibs(R-L);\n\tfor(int i \u003dL; i \u0026lt; R; i++) {\n\t\tcat h \u003dGetHeight(i);\n\t\tint s \u003dH.size();\n\t\twhile(s \u0026gt;\u003d 2 \u0026amp;\u0026amp; (H[s-1].ff-h)*(H[s-2].ss-i) \u0026gt; (H[s-2].ff-h)*(H[s-1].ss-i)) {\n\t\t\tH.pop_back();\n\t\t\ts--;}\n\t\tH.push_back(make_pair(h,i));}\n\tint Hs \u003dH.size();\n\n\tvector\u0026lt;int\u0026gt; comp1;\n\tint K \u003d2000;\n\tfor(int i \u003d0; i \u0026lt; Hs; i +\u003dK) comp1.push_back(H[i].ss);\n\tif(Hs \u0026gt; 0 \u0026amp;\u0026amp; comp1.back() !\u003d H[Hs-1].ss) comp1.push_back(H[Hs-1].ss);\n\tPutInt(MASTER_NODE,comp1.size());\n\tALL_THE(comp1,it) PutInt(MASTER_NODE,*it);\n\tSend(MASTER_NODE);\n\n\tif(my_id \u003d\u003d MASTER_NODE) {\n\t\tvector\u0026lt; pair\u0026lt;cat,int\u0026gt; \u0026gt; Hcomp;\n\t\tHcomp.dibs(nodes*2000);\n\t\tvector\u0026lt; pair\u0026lt;int,int\u0026gt; \u0026gt; I(nodes,make_pair(N+1,-1));\n\t\tvector\u0026lt; pair\u0026lt;int,int\u0026gt; \u0026gt; I2(nodes,make_pair(N+1,-1));\n\t\tvector\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; V(nodes);\n\t\tfor(int i \u003d0; i \u0026lt; nodes; i++) {\n\t\t\tReceive(i);\n\t\t\tint l \u003dGetInt(i);\n\t\t\tV[i].resize(l);\n\t\t\tfor(int j \u003d0; j \u0026lt; l; j++) {\n\t\t\t\tV[i][j] \u003dGetInt(i);\n\t\t\t\tI[i].ff \u003dmin(I[i].ff,V[i][j]);\n\t\t\t\tI[i].ss \u003dmax(I[i].ss,V[i][j]);}\n\t\t\t}\n\t\tfor(int i \u003d0; i \u0026lt; nodes; i++) {\n\t\t\tfor(int j \u003d0; j \u0026lt; (int)V[i].size(); j++) {\n\t\t\t\tint a \u003dV[i][j];\n\t\t\t\tcat h \u003dGetHeight(a);\n\t\t\t\tint s \u003dHcomp.size();\n\t\t\t\twhile(s \u0026gt;\u003d 2 \u0026amp;\u0026amp; (Hcomp[s-1].ff-h)*(Hcomp[s-2].ss-a) \u0026gt; (Hcomp[s-2].ff-h)*(Hcomp[s-1].ss-a)) {\n\t\t\t\t\tHcomp.pop_back();\n\t\t\t\t\ts--;}\n\t\t\t\tHcomp.push_back(make_pair(h,a));}\n\t\t\tfor(int j \u003d(int)Hcomp.size()-1; j \u0026gt;\u003d 0; j--) {\n\t\t\t\tif(Hcomp[j].ss \u0026lt; I[i].ff) break;\n\t\t\t\tI2[i].ff \u003dHcomp[j].ss;}\n\t\t\t}\n\t\tHcomp.clear();\n\t\tfor(int i \u003dnodes-1; i \u0026gt;\u003d 0; i--) {\n\t\t\tfor(int j \u003d(int)V[i].size()-1; j \u0026gt;\u003d 0; j--) {\n\t\t\t\tint a \u003dV[i][j];\n\t\t\t\tcat h \u003dGetHeight(a);\n\t\t\t\tint s \u003dHcomp.size();\n\t\t\t\twhile(s \u0026gt;\u003d 2 \u0026amp;\u0026amp; (Hcomp[s-1].ff-h)*(Hcomp[s-2].ss-a) \u0026lt; (Hcomp[s-2].ff-h)*(Hcomp[s-1].ss-a)) {\n\t\t\t\t\tHcomp.pop_back();\n\t\t\t\t\ts--;}\n\t\t\t\tHcomp.push_back(make_pair(h,a));}\n\t\t\tfor(int j \u003d(int)Hcomp.size()-1; j \u0026gt;\u003d 0; j--) {\n\t\t\t\tif(Hcomp[j].ss \u0026gt; I[i].ss) break;\n\t\t\t\tI2[i].ss \u003dHcomp[j].ss;}\n\t\t\t}\n\t\tfor(int i \u003d0; i \u0026lt; nodes; i++) {\n\t\t\tPutInt(i,I2[i].ff);\n\t\t\tPutInt(i,I2[i].ss);\n\t\t\tSend(i);}\n\t\t}\n\n\tReceive(MASTER_NODE);\n\tint mi \u003dGetInt(MASTER_NODE);\n\tint mx \u003dGetInt(MASTER_NODE);\n\tint l \u003d0, r \u003dHs-1;\n\twhile(l \u0026lt; Hs \u0026amp;\u0026amp; H[l].ss \u0026lt; mi) l++;\n\twhile(r \u0026gt;\u003d 0 \u0026amp;\u0026amp; H[r].ss \u0026gt; mx) r--;\n\tvector\u0026lt;int\u0026gt; comp2l,comp2r;\n\tfor(int i \u003dmax(0,l-K); i \u0026lt;\u003d min(Hs-1,r+K); i++) {\n\t\tif(i \u0026lt;\u003d l+K) comp2l.push_back(H[i].ss);\n\t\tif(i \u0026gt;\u003d r-K) comp2r.push_back(H[i].ss);\n\t\t}\n\tfor(int i \u003d0; i \u0026lt; my_id; i++) {\n\t\tPutInt(i,comp2l.size());\n\t\tALL_THE(comp2l,it) PutInt(i,*it);\n\t\tSend(i);}\n\tfor(int i \u003dmy_id+1; i \u0026lt; nodes; i++) {\n\t\tPutInt(i,comp2r.size());\n\t\tALL_THE(comp2r,it) PutInt(i,*it);\n\t\tSend(i);}\n\n\tvector\u0026lt;int\u0026gt; Pi;\n\tPi.dibs(Hs+nodes*5000);\n\tvector\u0026lt; pair\u0026lt;cat,int\u0026gt; \u0026gt; Hi;\n\tHi.dibs(Hs+nodes*5000);\n\tfor(int i \u003d0; i \u0026lt; nodes; i++) {\n\t\tif(i \u003d\u003d my_id) ALL_THE(H,it) Pi.push_back(it-\u0026gt;ss);\n\t\telse {\n\t\t\tReceive(i);\n\t\t\tl \u003dGetInt(i);\n\t\t\tfor(int j \u003d0; j \u0026lt; l; j++) Pi.push_back(GetInt(i));\n\t\t\t}\n\t\t}\n\tALL_THE(Pi,it) {\n\t\tint a \u003d*it;\n\t\tcat h \u003dGetHeight(a);\n\t\tint s \u003dHi.size();\n\t\twhile(s \u0026gt;\u003d 2 \u0026amp;\u0026amp; (Hi[s-1].ff-h)*(Hi[s-2].ss-a) \u0026gt; (Hi[s-2].ff-h)*(Hi[s-1].ss-a)) {\n\t\t\tHi.pop_back();\n\t\t\ts--;}\n\t\tHi.push_back(make_pair(h,a));}\n\tint inH \u003d0;\n\tALL_THE(Hi,it) if(it-\u0026gt;ss \u0026gt;\u003d L \u0026amp;\u0026amp; it-\u0026gt;ss \u0026lt; R) inH++;\n\tPutInt(MASTER_NODE,inH);\n\tSend(MASTER_NODE);\n\n\tif(my_id \u003d\u003d MASTER_NODE) {\n\t\tint ans \u003d0;\n\t\tfor(int i \u003d0; i \u0026lt; nodes; i++) {\n\t\t\tReceive(i);\n\t\t\tans +\u003dGetInt(i);}\n\t\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;}\n\t}\n\n// look at my code\n// my code is amazing\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eI\u0027m merging \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enodes\u003c/i\u003e)\u003c/span\u003e small convex hulls of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e / \u003ci\u003enodes\u003c/i\u003e)\u003c/span\u003e by sending only every \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e-th point in each hull, merging them in master and sending back the range that remains in the merged convex hull; then, each node sends just the smallest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e / \u003ci\u003enodes\u003c/i\u003e / \u003ci\u003eK\u003c/i\u003e)\u003c/span\u003e leftmost or rightmost points of this range to each other node and each node recomputes the convex hull of its own \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e / \u003ci\u003enodes\u003c/i\u003e)\u003c/span\u003e points plus all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e / \u003ci\u003eK\u003c/i\u003e)\u003c/span\u003e points it got sent.\u003c/p\u003e\u003cp\u003eI proved that this is correct and it passes the small subproblem (with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e \u003d 10, \u003ci\u003enodes\u003c/i\u003e \u003d 10, \u003ci\u003eN\u003c/i\u003e \u003d 1000\u003c/span\u003e), while slightly incorrect implementations don\u0027t, so it really should be correct. I also verified that it passes at least one official maxtest, but gives RE later.\u003c/p\u003e\u003cp\u003eThe cause of RE should not be too much stuff sent, since each node sends/receives only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e / \u003ci\u003eK\u003c/i\u003e)\u003c/span\u003e of data (numerically 2-3 MB, I tried \u0026quot;if this array is too large then return 0\u0026quot; checks and it changed nothing too). The memory limit shouldn\u0027t be exceeded too.\u003c/p\u003e\u003cp\u003eAny ideas? Btw don\u0027t forget about GCJ/DCJ last online rounds this weekend.\u003c/p\u003e\u003c/div\u003e","tags":["random","programming","questions"]}}