{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1400175750,"rating":54,"authorHandle":"HolkinPV","modificationTimeSeconds":1400442631,"id":12310,"title":"\u003cp\u003eCodeforces Round #246 (Div. 2) Editorial \u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/432/problem/A\" title\u003d\"Codeforces Round 246 (Div. 2)\"\u003e432A - Choosing Teams\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eIn this problem you should count number of students who can participate in ACM, divide it by 3 and round down. It could be done like this:\u003c/p\u003e \u003cpre\u003eint cnt \u003d 0;\n\nfor(int i \u003d 0; i \u0026lt; n; i++)\n    if (5 - a[i] \u0026gt;\u003d k)\n        cnt++;\n\nint ans \u003d cnt / 3;\u003c/pre\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/432/problem/B\" title\u003d\"Codeforces Round 246 (Div. 2)\"\u003e432B - Football Kit\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eCount for every team number of games in home kit. For team \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e it equals to sum of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e games at home and some away games with such teams which home kit color equals away kit color of team \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. To count number of such away games you could calc array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e — number of teams with home color kit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. The solution could be implemented in this wasy:\u003c/p\u003e \u003cpre\u003efor(int i \u003d 0; i \u0026lt; n; i++)\n    cnt[ x[i] ]++;\n\nfor(int i \u003d 0; i \u0026lt; n; i++)\n{\n    ans_home[i] \u003d n - 1;\n    ans_home[i] +\u003d cnt[ y[i] ];\n\n    ans_away[i] \u003d 2 * (n - 1) - ans_home[i];\n}\u003c/pre\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/432/problem/C\" title\u003d\"Codeforces Round 246 (Div. 2)\"\u003e432C - Prime Swaps\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe solution can be described by pseudo-code:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eConsider elements of permutation from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eWhile current element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is not sutiated on position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eLet the position of element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e equals \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eFind maximum prime integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e which is less or equal than $pos — i + 1\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eSwap element in positions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e - \u003ci\u003ep\u003c/i\u003e + 1\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eIt could be proved that such algorithm makes less than \u003cspan class\u003d\"tex-span\"\u003e4\u003ci\u003en\u003c/i\u003e\u003c/span\u003e swaps (for example, by implementing the algorithm)\u003c/p\u003e\u003cp\u003eThis algorithm should be implemented optimally. You should maintain positions of elements of permutation. Swap function in author\u0027s solution: \u003c/p\u003e \u003cpre\u003evoid doSwap(int i, int j){\n    int x \u003d a[i], y \u003d a[j];\n    a[j] \u003d x, pos[x] \u003d j;\n    a[i] \u003d y, pos[y] \u003d i;\n    result.push_back(make_pair(i, j));\n}\u003c/pre\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/432/problem/D\" title\u003d\"Codeforces Round 246 (Div. 2)\"\u003e432D - Prefixes and Suffixes\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem could be solved using different algorithms with z and prefix functions. Let\u0027s describe the solution with prefix function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e of string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e.\u003cbr /\u003eCalc prefix function and create a tree where vertices — integers from \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003es\u003c/i\u003e|\u003c/span\u003e, edges — from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e for every \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. The root of the tree is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. For every vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e calc the number of values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e — that is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e. Then for every \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e calc the sum all values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e for every \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e in to subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eThe general answer to the problem is:\u003c/p\u003e\u003cp\u003eFind all lenghts of the prefixes which matches the suffixes — these values are \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003es\u003c/i\u003e|\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[|\u003ci\u003es\u003c/i\u003e|]\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e[|\u003ci\u003es\u003c/i\u003e|]]\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e[|\u003ci\u003es\u003c/i\u003e|]]]\u003c/span\u003e... For every such length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e the answer to the problem is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e[\u003ci\u003eL\u003c/i\u003e] + 1\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/432/problem/E\" title\u003d\"Codeforces Round 246 (Div. 2)\"\u003e432E - Square Tiling\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThis is popular test 6 :)\u003c/p\u003e \u003cpre\u003e13 5\n\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nAAACA\nAAABB\nAAABB\u003c/pre\u003e\u003cp\u003eThe problem could be solved in a standard way — try to fill the table from the first cell to the last and try to put the miminum letter.\u003c/p\u003e\u003cp\u003eConsider the first row. Obviously it begins from some letters A (to be exact \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e letters A). When we put some letters A in the first row, we should put several letters A in some next rows to make a square. The next letter could be only B.\u003c/p\u003e\u003cp\u003eDescribe the solution in general. Assume that we have already considered some rows. Consider row \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Some cells in this row could be already painted. Consider unpainted cells from left to the right. For every such cell consider its color from A to Z. Two cases should be considered:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003ePut in this cell the minimum possible letter (neighbours have no such letter)\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf the previous cell in this row was not painted at the beginning of considering row \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, now it is already painted. We should try to merge the current cell with the square of the previous cell.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eChoose the best case from these cases. Try to get the answer on test \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 13\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e \u003d 5\u003c/span\u003e to understand the algorithm better.\u003c/p\u003e\u003c/div\u003e","tags":["codeforces","246","tutorial"]}}