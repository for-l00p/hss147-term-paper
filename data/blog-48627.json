{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1480115915,"rating":2,"authorHandle":"Sazzon","modificationTimeSeconds":1480173560,"id":48627,"title":"\u003cp\u003eContest da semana #1\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eOlá todos! \u003c/p\u003e\u003cp\u003eEsse é o primeiro editorial feito pelos alunos da UECE no Codeforces. Esse contest foi criado como um treino do grupo de estudos da maratona. A seleção das questões do UVa, organização do contest foi feita com muito empenho pelo \u003ca class\u003d\"rated-user user-gray\" href\u003d\"/profile/alissonrgs\" title\u003d\"Newbie alissonrgs\"\u003ealissonrgs\u003c/a\u003e. Obrigado especial aos que ajudaram a fazer este editorial: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/wjoao\" title\u003d\"Expert wjoao\"\u003ewjoao\u003c/a\u003e, \u003ca class\u003d\"rated-user user-black\" href\u003d\"/profile/Lamartinec\" title\u003d\"Unrated, Lamartinec\"\u003eLamartinec\u003c/a\u003e e novamente ao \u003ca class\u003d\"rated-user user-gray\" href\u003d\"/profile/alissonrgs\" title\u003d\"Newbie alissonrgs\"\u003ealissonrgs\u003c/a\u003e.\u003c/p\u003e\u003cp\u003ePor favor, leiam as questões, tentem fazer, se não conseguirem leiam o editorial. \u003cstrong\u003eEm último caso\u003c/strong\u003e vejam o código.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSorry for the lack of translation, we are from Brazil and the group is closed. Don\u0027t downvote this post just because you don\u0027t understand the language. We are using the platform to communicate internally. Please be nice !\u003c/strong\u003e :-)\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"https://uva.onlinejudge.org/external/116/11661.pdf\"\u003eBurguer Time?\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003ePré-requisitos:\u003c/strong\u003e Nenhum\u003c/p\u003e\u003cp\u003eO problema é facilmente resolvido se pensarmos que se houver um restaurante e uma farmácia no mesmo local (se houver um caractere \u0027Z\u0027 na string) a distância mínima já vai ser 0. Se não houver, basta iterar por toda a string guardando a posição da última aparição de \u0027R\u0027 e \u0027D\u0027. Quando uma nova posição aparecer, verificar se a distância entre os 2 atuais é menor do que a anteriormente calculada.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\n#define FOR(i, a, n) for(int i \u003d (int)(a); i \u0026lt; (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define LSOne(S) (S \u0026amp; (-S))\n\ntypedef unsigned long long llu;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int INF \u003d 0x3f3f3f3f;\n\nusing namespace std;\n\nint main(){\n  int l;\n  while(scanf(\u0026quot;%d%*c\u0026quot;, \u0026amp;l) \u0026amp;\u0026amp; l){\n  \tchar c;\n  \tint res \u003d INF, d \u003d -1, r \u003d -1;\n  \tREP(i, l){\n  \t\tscanf(\u0026quot;%c\u0026quot;, \u0026amp;c);\n  \t\tif(c \u003d\u003d \u0027R\u0027){\n  \t\t\tr \u003d i;\n  \t\t\tif(d !\u003d -1) res \u003d min(res, abs(r-d));\n  \t\t} else if(c \u003d\u003d \u0027D\u0027){\n  \t\t\td \u003d i;\n  \t\t\tif(r !\u003d -1) res \u003d min(res, abs(r-d));\n  \t\t} else if(c \u003d\u003d \u0027Z\u0027) res \u003d 0;\n  \t}\n  \tcout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl;\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eComplexidade :\u003c/strong\u003e O(n)\u003c/p\u003e\u003cp\u003e*\u003cem\u003en sendo o valor de L na questão\u003c/em\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eAutor :\u003c/strong\u003e Filipe Herculano Rocha\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"https://uva.onlinejudge.org/external/1/195.pdf\"\u003eAnagram\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003ePré-requisitos:\u003c/strong\u003e \u003ca href\u003d\"http://www.cplusplus.com/reference/algorithm/next_permutation/\"\u003enext_permutation\u003c/a\u003e\u003c/p\u003e\u003cp\u003ePara resolver essa questão vou usar dois métodos da biblioteca padrão: sort() e next_permutation(). O sort vai fazer a primeira string e o next_permutation vai gerar a próxima permutação da string inicial, na ordem lexicográfica. O problema é que a questão quer em ordem alfabética, então “Ba” virá antes de “aB”, dando resposta errada. Meu truque foi fazer um vetor com valores relativos aos caracteres, de modo que a string AaBbCc… vire o vetor {0,1,2,3,4,5...}. Daí, uso sort e next_permutation nesse vetor. Na hora de imprimir, verifico se o valor é par. Se for, então é maiúsculo. Senão, minúsculo.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\nusing namespace std;\n\nint main(){\n    \n    vector\u0026lt;int\u0026gt; v;\n    string s;\n    int n,i,x;\n    \n    cin\u0026gt;\u0026gt;n;\n    while(n--){\n        v.clear();\n        \n        cin\u0026gt;\u0026gt;s;\n        for(i\u003d0; i\u0026lt;s.size(); i++){\n            if(s[i]\u0026lt;\u0027a\u0027) x \u003d (s[i]-\u0027A\u0027)*2;\n            else x \u003d (s[i]-\u0027a\u0027)*2 + 1;\n            v.push_back(x);\n        }\n        sort(v.begin(), v.end());\n        \n        do{\n            for(i\u003d0; i\u0026lt;s.size(); i++){\n                if(v[i]%2\u003d\u003d0) cout\u0026lt;\u0026lt;(char)(v[i]/2 + \u0027A\u0027);\n                else cout\u0026lt;\u0026lt;(char)(v[i]/2 + \u0027a\u0027);\n            } cout\u0026lt;\u0026lt;endl;\n        } while( next_permutation(v.begin(), v.end()) );\n    }\n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eComplexidade :\u003c/strong\u003e O(n!)\u003c/p\u003e\u003cp\u003e*\u003cem\u003en sendo o tamanho da string.\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eAutor :\u003c/strong\u003e Lamartine Cabral\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"https://uva.onlinejudge.org/external/101/10104.pdf\"\u003eEuclid Problem\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003ePré-requisito:\u003c/strong\u003e Algoritmo de Euclides extendido\u003c/p\u003e\u003cp\u003eEsse problema é a aplicação prática do \u003ca href\u003d\"https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\"\u003ealgoritmo de Euclides extendido\u003c/a\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\n#define FOR(i, a, n) for(int i \u003d (int)(a); i \u0026lt; (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define LSOne(S) (S \u0026amp; (-S))\n\ntypedef unsigned long long llu;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int INF \u003d 0x3f3f3f3f;\n\nusing namespace std;\n\nll x, y, d;\n\nvoid euclid(ll a, ll b){\n  if(b \u003d\u003d 0){\n    x \u003d 1;\n    y \u003d 0;\n    d \u003d a;\n    return; \n  }\n  euclid(b, a%b);\n  ll x1 \u003d y;\n  ll y1 \u003d x - (a / b) * y;\n  x \u003d x1;\n  y \u003d y1;\n}\n\nint main(){\n  ll a, b;\n  while(~scanf(\u0026quot;%lld %lld\u0026quot;, \u0026amp;a, \u0026amp;b)){\n    euclid(a, b);\n    printf(\u0026quot;%lld %lld %lld\\n\u0026quot;, x, y, d);\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eComplexidade :\u003c/strong\u003e O(log n)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eAutor:\u003c/strong\u003e Filipe Herculano Rocha\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"https://uva.onlinejudge.org/external/116/11683.pdf\"\u003eLaser Sculpture\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003ePré-requisitos:\u003c/strong\u003e Nenhum\u003c/p\u003e\u003cp\u003eCom uma simples passada por todo o vetor com as alturas finais dos blocos, nós conseguimos o resultado. Dado uma altura de um bloco \u003cstrong\u003ei\u003c/strong\u003e \u003cstrong\u003e(0 \u0026lt;\u003d i \u0026lt; C)\u003c/strong\u003e em um vetor \u003cstrong\u003ev\u003c/strong\u003e, se o bloco for o primeiro, deve-se somar ao contador \u003cstrong\u003eabs(A-v[i])\u003c/strong\u003e . Caso i não seja o primeiro, deve-se verificar se ele é menor que o bloco anterior e se for soma-se ao contador \u003cstrong\u003eabs(v[i]-v[i-1])\u003c/strong\u003e . O motivo é que raios são comuns em alturas superiores à direita, porém não são comuns quando a altura é menor.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\n#define FOR(i, a, n) for(int i \u003d (int)(a); i \u0026lt; (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define LSOne(S) (S \u0026amp; (-S))\n\ntypedef unsigned long long llu;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int INF \u003d 0x3f3f3f3f;\n\nusing namespace std;\n\nint main(){\n  int a, c;\n  while(scanf(\u0026quot;%d\u0026quot;, \u0026amp;a) \u0026amp;\u0026amp; a){\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;c);\n    int v[c], cnt \u003d 0;\n    REP(i, c) scanf(\u0026quot;%d\u0026quot;, \u0026amp;v[i]);\n    REP(i, c){\n\t    if(i) {\n\t\t    if(v[i] \u0026lt; v[i-1]) cnt +\u003d abs(v[i]-v[i-1]);\n\t    } else cnt +\u003d abs(a-v[i]);\n    }\n    cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl;\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eComplexidade :\u003c/strong\u003e O(n)\u003c/p\u003e\u003cp\u003e*\u003cem\u003en sendo o valor de C na questão.\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eAutor :\u003c/strong\u003e Filipe Herculano Rocha \u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"https://uva.onlinejudge.org/external/110/11059.pdf\"\u003eMaximum Product\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003ePré-requisitos:\u003c/strong\u003e Nenhum\u003c/p\u003e\u003cp\u003eComo o tamanho máximo do vetor é \u003cstrong\u003eN \u003d 18\u003c/strong\u003e (bem pequeno), uma solução possível era testar todos os conjuntos existentes. Com um loop para representar o tamanho do conjunto a ser testado \u003cstrong\u003e(1 \u0026lt;\u003d i \u0026lt;\u003d N)\u003c/strong\u003e, bastava realizar mais dois loops com os valores do vetor, um de \u003cstrong\u003e(0 \u0026lt;\u003d j \u0026lt; N)\u003c/strong\u003e e o outro com o tamanho do conjunto \u003cstrong\u003e(j \u0026lt;\u003d k \u0026lt; j + i)\u003c/strong\u003e, multiplicava os valores do conjunto e no final testava se o valor era maior.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#define NMAX 18\n#define ll long long\nusing namespace std;\n\nint v[NMAX+1];\n\nint main() {\n   int n, _case \u003d 1;\n   \n   while( ~scanf( \u0026quot;%d\u0026quot;, \u0026amp;n ) \u0026amp;\u0026amp; n ) {\n      for( int i \u003d 0; i \u0026lt; n; i++ )\n         scanf( \u0026quot;%d\u0026quot;, \u0026amp;v[i] );\n      \n      ll maxp \u003d 0;\n      for( int i \u003d 1; i \u0026lt;\u003d n; i++ ) {\n         for( int j \u003d 0; j \u0026lt; n; j++ ) {\n            ll p \u003d 1;\n            for( int k \u003d j; k \u0026lt; j + i \u0026amp;\u0026amp; k \u0026lt; n; k++ )\n               p *\u003d v[k];\n            maxp \u003d max( maxp, p );\n         }\n      }\n   \n      printf( \u0026quot;Case #%d: The maximum product is %Ld.\\n\\n\u0026quot;, _case++, maxp );\n   }\n\n   return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eComplexidade:\u003c/strong\u003e O(N^3)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eAutor:\u003c/strong\u003e Alisson Soares\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"https://uva.onlinejudge.org/external/104/10474.pdf\"\u003eWhere is the Marble?\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003ePré-requisitos:\u003c/strong\u003e Ordenação, \u003ca href\u003d\"https://pt.wikipedia.org/wiki/Pesquisa_bin%C3%A1ria\"\u003ebusca binária\u003c/a\u003e, \u003ca href\u003d\"http://www.cplusplus.com/reference/algorithm/lower_bound/\"\u003elower_bound\u003c/a\u003e\u003c/p\u003e\u003cp\u003ePara achar a solução da questão, tinha que receber os N elementos, e ordená-los. Após isso receber Q consultas, cada uma delas, tinha que retornar o índice do número e se existir mais de um número igual, pegar o menor índice, no vetor ordenado. \u003c/p\u003e\u003cp\u003ePara se ordenar um vetor, pode-se usar a função sort. \u003c/p\u003e \u003cpre\u003eEx: int vetor[n]; sort(vetor, vetor+n);\u003c/pre\u003e\u003cp\u003ePara realizar a busca binária em um vetor ordenado, você pode usar o lower_bound do cpp:\u003c/p\u003e \u003cpre\u003eEx: int *p \u003d lower_bound(vetor, vetor+n, valor_buscado);\u003c/pre\u003e\u003cp\u003eObs: Detalhe que o lower_bound retorna um ponteiro para a posição do vetor, onde está o elemento encontrato, e caso ele não exista, ele retorna para algum número menor que o número buscado, e o mais próximo dele. Logo ao fazer o lower_bound, é necessário verificar se o valor de *p é igual ao valor da busca. Se for igual é porque foi achado e é necessário achar o indice e para isso é necessário apenas fazer uma operação de ponteiros, diminuindo p por vetor( A posição atual do ponteiro no meio do vetor, menos a posição do ponteiro inicial do vetor ) e o resultado disso é o indice, baseado em 0. Caso não fosse igual, o elemento não teria sido achado.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexidade :\u003c/strong\u003e O(n*log n + q*log n)\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCódigo com busca binária\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\n#define FOR(i, a, n) for(int i \u003d (int)(a); i \u0026lt; (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define LSOne(S) (S \u0026amp; (-S))\n\ntypedef unsigned long long llu;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int INF \u003d 0x3f3f3f3f;\n\nusing namespace std;\n\nint bs(vector\u0026lt;int\u0026gt; v, int num){\n\tint head \u003d 0, tail \u003d v.size()-1, body;\n\twhile(head \u0026lt;\u003d tail){\n\t\tbody \u003d (head+tail)/2;\n\t\tif(v[body] \u003d\u003d num){\n\t\t\tif(body \u003d\u003d 0 || v[body-1] !\u003d v[body]) return body;\n\t\t\telse tail \u003d body-1;\n\t\t} else if(v[body] \u0026gt; num) tail \u003d body-1;\n\t\telse head \u003d body+1;\n\t}\n\treturn -1;\n}\n\nint main(){\n\tint n, q, caso \u003d 1;\n\twhile(scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;n, \u0026amp;q) \u0026amp;\u0026amp; (n || q)){\n\t\tint index;\n\t\tvector\u0026lt;int\u0026gt; v(n);\n\t\tREP(i, n) scanf(\u0026quot;%d\u0026quot;, \u0026amp;v[i]);\n\t\tsort(all(v));\n\t\tprintf(\u0026quot;CASE# %d:\\n\u0026quot;, caso++);\n\t\tREP(i, q){\n\t\t\tint temp;\n\t\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;temp);\n\t\t\tindex \u003d bs(v, temp);\n\t\t\tif(index \u003d\u003d -1) printf(\u0026quot;%d not found\\n\u0026quot;, temp);\n\t\t\telse printf(\u0026quot;%d found at %d\\n\u0026quot;, temp, index+1);\n\t\t}\n\t}\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eAutor :\u003c/strong\u003e Filipe Herculano Rocha\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCódigo com lower_bound\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\n\n\nusing namespace std;\n\n\nint numeros[10100];\nint n, m, a, t \u003d1;\n\n\nint main(){\n    while( cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026amp;\u0026amp; n ){\n        for(int i \u003d 0; i \u0026lt; n; i++){\n            cin \u0026gt;\u0026gt; a;\n            numeros[i] \u003d a;\n        }\n    \n    \n        sort(numeros, numeros + n);\n        cout \u0026lt;\u0026lt; \u0026quot;CASE# \u0026quot;\u0026lt;\u0026lt; t++ \u0026lt;\u0026lt; \u0026quot;:\u0026quot; \u0026lt;\u0026lt; endl;\n        for(int i \u003d 0; i \u0026lt; m; i++){\n            cin \u0026gt;\u0026gt; a;\n            int * it \u003d lower_bound(numeros, numeros+n, a);\n            \n            if( it \u003d\u003d numeros+n ){ // O numero pesquisado era maior do que todos existentes\n                cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot; not found\u0026quot; \u0026lt;\u0026lt; endl;\n            }else{\n                int peso \u003d *it;\n                if( peso \u003d\u003d a ){ // Verifica se o numero encontrato é igual ao pesquisado\n                    cout \u0026lt;\u0026lt; peso \u0026lt;\u0026lt; \u0026quot; found at \u0026quot; \u0026lt;\u0026lt; (int)(it-numeros)+1 \u0026lt;\u0026lt; endl;\n                }else{\n                    cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot; not found\u0026quot; \u0026lt;\u0026lt; endl;\n                }\n            }\n        }\n    }\n\n\n\n\n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eAutor:\u003c/strong\u003e João Vitor\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"https://uva.onlinejudge.org/external/103/10324.pdf\"\u003eZeros and Ones\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003ePré-requisitos:\u003c/strong\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Prefix_sum\"\u003ePrefix Sum\u003c/a\u003e\u003c/p\u003e\u003cp\u003eComo a string tinha apenas 1s e 0s era possível aplicar a soma de prefixos, assim usando um vetor, bastava passar uma única vez por toda a string e ir somando o valor da posição da string com a posição anterior do vetor \u003cstrong\u003e( sum[ i ] \u003d str[ i ] + sum[ i-1 ] )\u003c/strong\u003e. Feito isso as consultas ficam O(1), pois para uma consulta de \u003cstrong\u003ei\u003c/strong\u003e até \u003cstrong\u003ej\u003c/strong\u003e com \u003cstrong\u003ej\u003c/strong\u003e \u0026gt; \u003cstrong\u003ei\u003c/strong\u003e, basta calcular \u003cstrong\u003e( sum[ j ]-sum[ i ] + s[ i ] )\u003c/strong\u003e, se for igual a diferença dos índices \u003cstrong\u003e( j — i + 1 )\u003c/strong\u003e é porque todos os valores na string são 1s, e caso for 0 é porque todos os valores na string são 0s.\u003c/p\u003e\u003cp\u003eEsse problema também era possível com força bruta, a cada consulta bastava fazer um ‘for’ verificando se uma posição no vetor era diferente da anterior, caso fosse é porque a sequência não é de mesmos dígitos, caso contrário sim.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#define NMAX 1000000\nusing namespace std;\n\nint sum[NMAX+1];\n\nint ctoi( char c ) { return (int)( c - \u00270\u0027 ); }\n\nint main() {\n    string s;\n    int q, i, j, _case \u003d 1;\n   \n    while( cin \u0026gt;\u0026gt; s ) {\n        sum[0] \u003d ctoi( s[0] );\n        for( int k \u003d 1; k \u0026lt; (int)s.size(); k++ )   \n            sum[k] \u003d sum[k-1] + ctoi( s[k] );\n   \n        cin \u0026gt;\u0026gt; q;\n        cout \u0026lt;\u0026lt; \u0026quot;Case \u0026quot; \u0026lt;\u0026lt; _case++ \u0026lt;\u0026lt; \u0026quot;:\u0026quot; \u0026lt;\u0026lt; endl;\n        while( q-- ) {\n            cin \u0026gt;\u0026gt; i \u0026gt;\u0026gt; j;\n            if( i \u0026gt; j ) swap( i, j );\n         \n            int v \u003d sum[j] - sum[i] + ctoi( s[i] );\n            if( v \u003d\u003d j-i+1 || v \u003d\u003d 0 )\n                cout \u0026lt;\u0026lt; \u0026quot;Yes\u0026quot; \u0026lt;\u0026lt; endl;\n            else\n                cout \u0026lt;\u0026lt; \u0026quot;No\u0026quot; \u0026lt;\u0026lt; endl;\n      }\n   }\n\n   return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eComplexidade:\u003c/strong\u003e O(n+q)\u003c/p\u003e\u003cp\u003e*\u003cem\u003en sendo o tamanho da string e q sendo a quantidade de queries\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eAutor:\u003c/strong\u003e Alisson Soares\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"https://uva.onlinejudge.org/external/120/12086.pdf\"\u003ePontentiometers\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003ePré-requisitos:\u003c/strong\u003e \u003ca href\u003d\"https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/\"\u003eBit — Fenwick Tree\u003c/a\u003e\u003c/p\u003e\u003cp\u003eUtilização básica da bit. Usa-se o operador de Update em um ponto. e de Query para saber o resultado da soma entre intervalos.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\n\n\n#define MAXN 200005 \n\n\nint n, a, b, t\u003d 1;\nint Bit[MAXN];\nchar op[10];\n \nvoid Update(int p, int v){\n    while(p \u0026lt; MAXN){\n        Bit[p] +\u003d v;\n        p +\u003d p \u0026amp; -p;\n    }   \n}\n \nint Query(int p){\n    int ans \u003d 0;\n    while(p \u0026gt; 0){\n        ans +\u003d Bit[p];\n        p -\u003d p \u0026amp; -p;\n    }\n    return ans;\n}\n\n\n\n\nint main(){\n    while( scanf(\u0026quot; %d\u0026quot;, \u0026amp;n) \u0026amp;\u0026amp; n){\n        memset(Bit, 0, sizeof Bit);\n        for(int i \u003d 1; i \u0026lt;\u003d n; i++){\n            scanf(\u0026quot;%d\u0026quot;, \u0026amp;a);\n            Update(i, a);\n        }\n        if( t !\u003d 1 ) printf(\u0026quot;\\n\u0026quot;);\n        printf(\u0026quot;Case %d:\\n\u0026quot;, t++);\n        while( scanf(\u0026quot; %s\u0026quot;, op) \u0026amp;\u0026amp; op[0] !\u003d \u0027E\u0027 ){\n            if( op[0] \u003d\u003d \u0027S\u0027 ){\n                scanf(\u0026quot; %d%d\u0026quot;, \u0026amp;a, \u0026amp;b);\n                int atual \u003d Query(a) - Query(a-1);\n                Update(a, b - atual);\n            }else if( op[0] \u003d\u003d \u0027M\u0027 ){\n                scanf(\u0026quot; %d%d\u0026quot;, \u0026amp;a, \u0026amp;b);\n                printf(\u0026quot;%d\\n\u0026quot;, Query(b)-Query(a-1));\n            }\n        }\n    }\n    \n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eComplexidade:\u003c/strong\u003e O(n*logn + q*logn)\u003c/p\u003e\u003cp\u003e*\u003cem\u003eq sendo a quantidade de queries na BIT.\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eAutor:\u003c/strong\u003e João vitor\u003c/p\u003e\u003c/div\u003e","tags":[]}}