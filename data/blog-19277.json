{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1437086950,"rating":13,"authorHandle":"Xellos","modificationTimeSeconds":1461516522,"id":19277,"title":"\u003cp\u003eAndrew Stankevich Contest 37 editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/gym/100431\"\u003eContest link.\u003c/a\u003e Main ideas:\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"#A\"\u003eA. Achromatic Number\u003c/a\u003e: reduction to Eulerian circuit.\u003cbr /\u003e \u003ca href\u003d\"#B\"\u003eB. Binary Search\u003c/a\u003e: dynamic programming over states \u003ccode\u003e(n, a[0] \u0026lt;\u003d\u0026gt; x)\u003c/code\u003e for every \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e.\u003cbr /\u003e \u003ca href\u003d\"#C\"\u003eC. Blind Flibs\u003c/a\u003e (no code): the only part from the flib\u0027s \u003ci\u003eprediction\u003c/i\u003e that matters is a sufficiently short string of our choice infinitely repeated.\u003cbr /\u003e \u003ca href\u003d\"#D\"\u003eD. Bubble Sort\u003c/a\u003e: the network permutes elements in the input array in a fixed way.\u003cbr /\u003e \u003ca href\u003d\"#E\"\u003eE. Word Cover\u003c/a\u003e: a lot of things, suffix array + KMP \u0026quot;last prefix\u0026quot; array + reduction to a tree problem.\u003cbr /\u003e \u003ca href\u003d\"#F\"\u003eF. Permutations with Monotonic Segments\u003c/a\u003e: dynamic programming over states \u003ccode\u003e(suffix of a[], first number in \u0026amp;pi;)\u003c/code\u003e.\u003cbr /\u003e \u003ca href\u003d\"#G\"\u003eG. Persistent Queue\u003c/a\u003e: each queue is a vertex in a rooted tree; each operation is an edge in that tree.\u003cbr /\u003e \u003ca href\u003d\"#H\"\u003eH. Sea Port\u003c/a\u003e: simulation using priority queues over objects \u0026quot;crane becomes free\u0026quot; and \u0026quot;ship arrives\u0026quot;.\u003cbr /\u003e \u003ca href\u003d\"#I\"\u003eI. Shooting Game\u003c/a\u003e (no code): Relevant points for Alice: plane -\u0026gt; lines passing through input points -\u0026gt; their intersections (+ nearby points). How to find the answer is we know Alice\u0027s point?\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eNotation note: I\u0027ll be using original letters with code formatting and replace them with capital letters with LaTeX formatting. For aesthetic reasons.\u003c/p\u003e\u003ch3\u003e\u003ca name\u003d\"A\"\u003eA. Achromatic Number\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eLet\u0027s say that our chosen achromatic number is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e. We can direct the cycle in some way and merge vertices with the same colour — while allowing multiple edges between any two vertices, even if they\u0027re directed the same way. What we just got is an Eulerian circuit of a graph with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e vertices, each corresponding to a colour. Achromatism requires this graph to contain (after ignoring the edges\u0027 directions) a complete graph \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e as its subgraph. And finally, the colouring being proper means the graph contains no self-loops.\u003c/p\u003e\u003cp\u003eThat means we can view the problem of constructing a desired colouring using \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e colours this way: take a complete graph \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, add some edges to it (let\u0027s call this graph \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e) in a way that gives it an Eulerian circuit of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, and construct this circuit — tada, the sequence of colours on it gives the colouring of our cycle! The problem of constructing Eulerian circuits is well-known, so we won\u0027t get into detail; the only question that remains is checking whether a desired graph \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e exists for given \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and constructing it if it does exist.\u003c/p\u003e\u003cp\u003eThere are two main cases, depending on the parity of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLet\u0027s do odd \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e first. Recall that a graph has an Eulerian circuit iff it\u0027s connected (which it is) and each of its vertices has an even degree. Since the degree of each vertex in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e - 1\u003c/span\u003e, the second condition is also satisfied, but we want it to have exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e edges, too! If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e - 1) / 2 \u0026gt; \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, we obviously fail, because \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e has more edges already and we can\u0027t remove any from it. We also fail if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e - 1) / 2 + 1 \u003d \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e — we need to add one edge to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, but then there\u0027ll be two vertices with odd degrees. In all other cases, we can construct the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e by adding a cycle \u003ccode\u003e1-2-3-1\u003c/code\u003e (if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - \u003ci\u003eA\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e - 1) / 2\u003c/span\u003e is odd) and then a suitable number of cycles \u003ccode\u003e1-2-1\u003c/code\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWhat about even \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e? Now, each vertex in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e has an odd degree; luckily (\u003ca href\u003d\"https://proofwiki.org/wiki/Handshake_Lemma\"\u003eand unsurprisingly\u003c/a\u003e), there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e / 2\u003c/span\u003e pairs of vertices, so we can add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e / 2\u003c/span\u003e edges and give each vertex an even degree. That means the least possible number of edges in it is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e - 1) / 2 + \u003ci\u003eA\u003c/i\u003e / 2 \u003d \u003ci\u003eA\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e / 2\u003c/span\u003e and if this number is greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, we fail. One might think there\u0027s a similar case as before if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e / 2 + 1 \u003d \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, but that\u0027s not true here — if adding edges between disjoint pairs of vertices leads us to this situation, we can add two edges \u003ccode\u003e1-3-2\u003c/code\u003e instead of one edge \u003ccode\u003e1-2\u003c/code\u003e, which makes the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e constructed so far have the same parity of the number of its edges as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, and we can finish up by adding a suitable number of cycles \u003ccode\u003e1-2-1\u003c/code\u003e to make our final \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e for even \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNote that these constructions work properly when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e ≥ 3\u003c/span\u003e; \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e \u003d 2\u003c/span\u003e isn\u0027t an achromatic number when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e is odd.\u003c/p\u003e\u003cp\u003eWe\u0027ve just described the construction. Checking whether \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e is a possible achromatic number doesn\u0027t require actually constructing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e, though — we can just check whether \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e - 1) / 2 ≤ \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e ≠ \u003ci\u003eN\u003c/i\u003e - 1\u003c/span\u003e (for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e odd) or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e / 2 ≤ \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e (for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e even); since trivially \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e ≤ \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, we can try all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e ≥ 2\u003c/span\u003e and choose the largest possible one.\u003c/p\u003e\u003cp\u003eLastly, let\u0027s remark that an achromatic proper colouring always exists — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e \u003d 3\u003c/span\u003e works for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e ≠ 4\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e \u003d 2\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e \u003d 4\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eTime complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e, memory: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://ideone.com/PyxhpM\"\u003ecode\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca name\u003d\"B\"\u003eB. Binary Search\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThis problem requires bigints — the answer for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e \u003d 100\u003c/span\u003e has over 100 digits already. The simplest way to deal with it is to use Python, which is slow, but not too slow (my code barely passes on the first attempt).\u003c/p\u003e\u003cp\u003eWe\u0027re asked to compute the number of pairs \u003ccode\u003e(a,x)\u003c/code\u003e that satisfy a given property. Since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e is reasonably small, we can try all possible \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-s and compute the number of possible arrays \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e for each one.\u003c/p\u003e\u003cp\u003eOkay, what\u0027s the first step of the binsearch? It looks at a specific element. If this element is \u003cspan class\u003d\"tex-span\"\u003e \u0026gt; \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, all the elements to the right of it — including it — are discarded. If it\u0027s \u003cspan class\u003d\"tex-span\"\u003e ≤ \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, all elements to the left of it — excluding it — are discarded. In the second case, we continue by running the binsearch on the subarray of non-discarded elements. Fortunately, whenever the binsearch is ran on some subarray, only the first element of this subarray can be predetermined this way (proof by induction), so we only need to add information about the first element to subarray length (its position doesn\u0027t affect what the binsearch does) to make suitable states for DP. \u003c/p\u003e\u003cp\u003eEach step of the binsearch splits the current subarray into two disjoint parts; one part is discarded and the algorithm is ran on the other. In the discarded part, all elements except possibly the first one can be completely arbitrary, so if there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e such elements, then it gives \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e ways to choose them. For the non-discarded part, the number of ways is computed recursively by the same DP. We stop in a state with array length 1; if the first element of this array is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, the number of ways is 1, otherwise it\u0027s 0. Otherwise, we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e choices of our central element; we should try them all and sum up the number of ways for each.\u003c/p\u003e\u003cp\u003eThe part which we discard doesn\u0027t depend on what the central element is, only on its sign on comparison to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Afterwards, this element sometimes becomes the first and may be discarded in the DP at some point (particularly the condition for arrays of length 1), which doesn\u0027t depend on anything but this sign, either, so the only information we need is the comparison sign of the first element of the current subarray and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e (\u003ccode\u003ea[0] \u0026lt; / \u003d / \u0026gt; x\u003c/code\u003e). That means we have \u003cspan class\u003d\"tex-span\"\u003e3\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e states for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and from each of them, we have 3 ways to move to the next state, depending on which sign we choose for the central element. Of course, if we choose \u003ccode\u003e\u0026lt;\u003c/code\u003e or \u003ccode\u003e\u0026gt;\u003c/code\u003e, the number of ways must be multiplied by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - 1\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, respectively, since there are that many choices of the central element hidden behind this choice of sign.\u003c/p\u003e\u003cp\u003eThe DP is pretty clear and easy to implement. The time complexity may seem to be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e, which is too big, but subarray length decreases quickly — there are just 3 states with length \u003cspan class\u003d\"tex-span\"\u003e \u003d \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, at most 6 more with length \u003cspan class\u003d\"tex-span\"\u003e ≥ \u003ci\u003eN\u003c/i\u003e / 2\u003c/span\u003e, etc. at most \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e more with length \u003cspan class\u003d\"tex-span\"\u003e ≥ \u003ci\u003eN\u003c/i\u003e / (2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e, which gives a better bound of roughly \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/50/f5/50f569c1460b0cfb4ec5311b369b5e122b4a409e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e states (think sum of \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e up to a number such that \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e \u003d \u003ci\u003eN\u003c/i\u003e / (2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e, e.g. \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/81/f381a867c035d8ab67dd362b509e4d7f78b7a087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e) for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Even with Python and bigints, a time complexity of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5e/d4/5ed4b36617ad3dee52cd70f1505971c5860f5e8e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (if we consider bigints to be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e, which isn\u0027t correct, but it\u0027s enough for the sake of an estimate) was sufficient for me to pass on the first try. The fact that most states have smaller subarray length and those hold smaller bigints also helps. Memory: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e in order to remember the states easily; we can actually afford \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e time and memory for constructing the array holding numbers of ways for each state, since it\u0027s not much compared to what bigint operations cost.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://ideone.com/UPUOVG\"\u003ecode\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca name\u003d\"C\"\u003eC. Blind Flibs\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eLooking at a flib as a directed graph with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e vertices and \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e edges isn\u0027t the best choice; we should look at it as a graph with \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e vertices and \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e edges, where each vertex corresponds to the pair (state of the flib, last printed character), which is just another kind of state. The reason is that a graph where each vertex has exactly one outgoing edge can be viewed as a union of cycles with trees connected to their vertices; each of those trees is directed towards the cycle. And we have a lot of freedom here — we can choose any such graph as the flib, only limited by the number of vertices it may have.\u003c/p\u003e\u003cp\u003eWith such a graph, it\u0027s clear what the string printed by the flib will be: we start at some vertex and keep moving along edges from it; when taking an edge, we always print the character associated with it (the vertex we start at and the first edge we take correspond to state 1 and the first arbitrary printed character from the problem statement). At some point, we\u0027ll reach one cycle and keep moving along it forever, repeatedly printing the same string. In terms of limits, of course, all that matters is this string the flib keeps printing after it reaches that cycle — the rest is finitely small and its contribution to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e approaches zero in the limit. In fact, since we can number the flib\u0027s states in any way, we can choose to start on any vertex of the cycle and completely ignore the fact that we could reach it along some path. The rest of the graph doesn\u0027t matter at all, so we can just focus on this one cycle.\u003c/p\u003e\u003cp\u003eLet\u0027s suppose that the flib prints a string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e on the cycle. It\u0027s be nice if we could match positions in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e to positions in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003c/span\u003e, but that\u0027s generally not possible if \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eR\u003c/i\u003e|\u003c/span\u003e doesn\u0027t divide \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, since the \u003ci\u003efuture\u003c/i\u003e word and the flib\u0027s prediction word aren\u0027t periodic in the same way. However, they\u0027ll always have a common period of \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eW\u003c/i\u003e||\u003ci\u003eR\u003c/i\u003e|\u003c/span\u003e (actually even \u003c/p\u003e\u003cp\u003eUnable to parse markup [type\u003dCF_TEX]\u003c/p\u003e, but we don\u0027t need this small optimisation here), so we can just repeat \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eR\u003c/i\u003e|\u003c/span\u003e times and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eW\u003c/i\u003e|\u003c/span\u003e times to make two different strings; in the limit, the \u003ci\u003efuture\u003c/i\u003e word will look like the first one infinitely repeated and the \u003ci\u003eprediction\u003c/i\u003e word like the second one repeated. And since those repeated strings have the same length, the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e will be the same whether we only consider them once or infinitely repeated.\u003cp\u003eOh look, we\u0027ve just reduced the problem to finding the string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e that gives the maximum prediction level \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e (calculated over finite and pretty short strings) with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003c/span\u003e this way! We don\u0027t have any restrictions on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e except that its length can\u0027t exceed \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e; as long as we have it, our graph can be just a cycle that it\u0027s read along from the starting vertex and some trash vertices+edges to make the flib have the desired number of states (even if we add states, we won\u0027t reach them at all and stay on the desired cycle).\u003c/p\u003e\u003cp\u003eLet\u0027s try all values of \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eR\u003c/i\u003e|\u003c/span\u003e and find the maximum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e for each of them. This way, even if we don\u0027t know the characters of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e, we can find out all characters of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003c/span\u003e it\u0027s compared to when calculating \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eE\u003c/i\u003e()\u003c/span\u003e (of course, since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e are repeated, any character of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e can be compared to any character of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003c/span\u003e multiple times). Then, we can independently choose each character of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e as the one that\u0027s equal to more of the characters it\u0027s compared to, since it gives larger \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eE\u003c/i\u003e()\u003c/span\u003e. Calculating \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e when we know \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e is easy.\u003c/p\u003e\u003cp\u003eThen, for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, we just need to take the maximum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e from all \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eR\u003c/i\u003e| ≤ 2\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e. Since there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003eW\u003c/i\u003e|)\u003c/span\u003e choices of \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eR\u003c/i\u003e|\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e for each can be computed in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003eW\u003c/i\u003e|\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e time, the total time complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003eW\u003c/i\u003e|\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e; memory can be reduced to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003eW\u003c/i\u003e|)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca name\u003d\"D\"\u003eD. Bubble Sort\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThis is probably the simplest problem in this contest. The only observation we need is that the network performs a series of fixed swaps (generally not in fixed order, but if several swaps are performed \u0026quot;at once\u0026quot;, their order doesn\u0027t matter), so if we give it an array, it\u0027ll throw out a fixed permutation of its elements.\u003c/p\u003e\u003cp\u003eWe can just give the network an identity permutation and simulate the swaps done on it in the network (not based on min-max properties, just the 0/1-s we\u0027re given); when we get a permutation \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e as the result, we know that the only possible input that gives an identity permutation as an output is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e - 1\u003c/sup\u003e\u003c/span\u003e, the permutation inverse to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e. The only thing to watch out for may be the order of swaps — for example, we can first process the first comparator in each row, then the second comparator (if it exists) in each row etc.\u003c/p\u003e\u003cp\u003eNow that we have the only possible answer, we have to check if the swaps actually happen when between a smaller lower element and a larger upper one. That requires running the input array through the network once again.\u003c/p\u003e\u003cp\u003eTime complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e, memory: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://ideone.com/c5oiu6\"\u003ecode\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca name\u003d\"E\"\u003eE. Word Cover\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eMy solution may be overcomplicated, but bear with it — this was the second hardest problem of the whole contest, after all.\u003c/p\u003e\u003cp\u003eObservation 1: if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e covers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e is a prefix (and a suffix) of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e. Therefore, we only need to find the shortest prefix of the input string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e that covers each prefix of it.\u003c/p\u003e\u003cp\u003eObservation 2: let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e be a prefix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e; find all occurrences of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e as a substring, in sorted order, and then the first of these occurrences (call it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e\u003c/span\u003e) that starts more than \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eP\u003c/i\u003e|\u003c/span\u003e characters before the next one. Then, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e matches a prefix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e iff that prefix ends at the same place as an occurrence that\u0027s \u003cspan class\u003d\"tex-span\"\u003e ≤ \u003ci\u003eo\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe can find the first such \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e\u003c/span\u003e for each \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eP\u003c/i\u003e|\u003c/span\u003e using suffix arrays. A suffix array is a sorted array of suffixes (we won\u0027t go into details of its construction here, there\u0027s a fairly simple one in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/44/4f/444f5650f8f9de80540894d0bf33cb667ec90df3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e), of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e in this case. Let\u0027s look at some prefix \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e of the longest suffix (the whole \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e). Then, the suffixes whose prefix is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e, i.e. positions where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e occurs in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e, form a continuous range in the suffix array; also, each of these ranges for a longer prefix is a subrange of any range for a shorter prefix. Therefore, if you construct the LCP-array for this suffix array, you can find those ranges by simply decreasing \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eP\u003c/i\u003e|\u003c/span\u003e and extending the current range until you hit a situation where the first LCP above and below it are both shorter than \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eP\u003c/i\u003e|\u003c/span\u003e. (You can also use hashing and binsearch.)\u003c/p\u003e\u003cp\u003eWe still haven\u0027t computed those last good occurrences \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e\u003c/span\u003e for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e. We can do it in parallel with extending the current range — we just need to maintain a sorted list of occurrences in the current range (for example as an STL map\u0026lt;\u0026gt;) and another list (set\u0026lt;\u0026gt;) of occurrences by distance. Adding an occurrence means just removing up to one distance and adding up to two. After we\u0027ve updated the current range, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e\u003c/span\u003e is the minimum occurrence among those with distance from the next one \u003cspan class\u003d\"tex-span\"\u003e \u0026gt; |\u003ci\u003eP\u003c/i\u003e|\u003c/span\u003e, so we need to keep one more list (set\u0026lt;\u0026gt;) of occurrences corresponding to distances \u003cspan class\u003d\"tex-span\"\u003e \u0026gt; |\u003ci\u003eP\u003c/i\u003e|\u003c/span\u003e and find the first one in it.\u003c/p\u003e\u003cp\u003eNow, we\u0027re able to check if a prefix \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e of some length covers another prefix \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e just by checking if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e is a suffix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e and if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e ends early enough (at a position \u003cspan class\u003d\"tex-span\"\u003e ≤ \u003ci\u003ep\u003c/i\u003e(|\u003ci\u003eP\u003c/i\u003e|)\u003c/span\u003e). The problem is that there can be many prefixes covering other ones, so we can\u0027t just try all such pairs. But there\u0027s an algorithm for finding the largest prefix that\u0027s a suffix of each prefix: the well-known KMP.\u003c/p\u003e\u003cp\u003eWe can view KMP as constructing a tree. Each vertex corresponds to a prefix of the input string; its parent is the largest prefix that\u0027s also its suffix. Going along the path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e to the root (the empty prefix \u003cspan class\u003d\"tex-span\"\u003eε\u003c/span\u003e), we find all prefixes that are suffixes of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e. Let\u0027s assign one number to each vertex: the length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e of the longest prefix it can cover. By observation 2, for each vertex (with prefix \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e) of this tree, we want to find its topmost ancestor whose number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e ≥ |\u003ci\u003eP\u003c/i\u003e|\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFor this, we can simply DFS over the tree while maintaining the visited prefixes/vertices above the current one in a minimum segment tree; for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e, we record the corresponding prefix length in the segment tree. When going up or down a vertex, we add/remove \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e corresponding to the added/removed vertex in the segment tree (it has to support separate adding and removing; a good approach is storing a list of values in each leaf and minima only in other vertices); when we want to find the minimum length of a prefix with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e greater than the current prefix length, it\u0027s just one query to the segment tree.\u003c/p\u003e\u003cp\u003eFinally, our long journey is over. Since we\u0027ve only used DS with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/28/a3/28a3e1ebf443830c2b8d35cc88c49444739ab741.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time of updates/queries (let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e \u003d |\u003ci\u003eS\u003c/i\u003e|\u003c/span\u003e), KMP runs in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e time and suffix array construction in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/44/4f/444f5650f8f9de80540894d0bf33cb667ec90df3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, the total time complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/44/4f/444f5650f8f9de80540894d0bf33cb667ec90df3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Memory: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://ideone.com/DOvdiW\"\u003ecode\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca name\u003d\"F\"\u003eF. Permutations with Monotonic Segments\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThis is yet another DP problem. Suppose that we chose the numbers in the last segment; those numbers can then be removed from the permutation, the remaining numbers in the permutation compressed into \u003ccode\u003e[1..n\u0027]\u003c/code\u003e and the only thing that matters from the last segment is the relative position of its first element with respect to the compressed permutation — the number \u003ccode\u003ek\u003c/code\u003e in \u0026quot;the next-to-last segment can only end with numbers \u003ccode\u003e[1..k]\u003c/code\u003e from the range \u003ccode\u003e[1..n\u0027]\u003c/code\u003e\u0026quot;. The DP states are therefore (last unprocessed segment, number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e of choices for the last element).\u003c/p\u003e\u003cp\u003eThe numbers \u003ccode\u003en\u0027\u003c/code\u003e are given directly as prefix sums of the array \u003ccode\u003ea[]\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eWhen processing the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th segment with given \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, we can try all choices for the first element of this segment (up to \u003ccode\u003en\u0027\u003c/code\u003e). If it\u0027s \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, then the number of ways to choose the remaining elements of the current segment is the number of subsets of numbers from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e - 1\u003c/span\u003e (we know that they must be in monotonous order), with the condition that the smallest element must be \u003cspan class\u003d\"tex-span\"\u003e ≤ \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. If we knew the smallest element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e ≤ \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e as well, the number of ways to choose them is obviously \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/84/a4/84a4302c703ee4f09b211b149ebf5724a0ee8b2d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003c/p\u003e\u003cp\u003eGenerally, we need to sum up the binomial coefficients for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e \u003d 1..\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Since the constraints are small, we can precompute all relevant binomial coefficients and their column prefix sums, from which we can find the sum of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bc/fd/bcfd4ac51bfc9a23ed8035edac0be9a75c93f76c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. The new value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e - 1 - (\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - 1) \u003d \u003ci\u003ej\u003c/i\u003e - \u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNote that this doesn\u0027t work for a segment with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 1\u003c/span\u003e, but that case is trivial (we only need to try all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eThe time complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e. Memory: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://ideone.com/IgWJv8\"\u003ecode\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca name\u003d\"G\"\u003eG. Persistent Queue\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eA good way to view this persistent structure is not as a queue, but a rooted tree, in which each vertex is some version of that queue (the root is the initial version) and the edge that leads to it from its parent describes the operation during which it was created. Therefore, what that version looks like is given implicitly by the path from the root.\u003c/p\u003e\u003cp\u003eConstructing this tree online is trivial, the only question is how to answer queries. We\u0027re always asked to print the first element of the version in some vertex. Note that this number doesn\u0027t matter on when we make the pops while constructing this version \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e of the queue, only on how many there are. We could imagine that we only construct \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e by pushes along the path from the root to vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and if we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e pops on that path, the answer will be the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e + 1\u003c/span\u003e-st pushed element. \u003c/p\u003e\u003cp\u003eAs we construct the tree, we can calculate the number of pops and pushes made on the path to each added vertex based on these numbers for its parent. For answering queries, we always need to find the topmost vertex above \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e that has a given number of pushes above it and print the element which was pushed to it when it was constructed (if it was constructed by a pop, it won\u0027t be the topmost).\u003c/p\u003e\u003cp\u003eWe can use what\u0027s a standard approach to LCA — the \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e-th ancestors for all reasonably small \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e (up to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/70/76/707601b5ffd68670d7f4f166f4178d009d7e7e67.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e). They can be computed for each vertex when it\u0027s constructed and since the number of pushes is non-decreasing as we move away from the root, we can simply start at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and, as long as we aren\u0027t in the desired vertex, move to the \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e ancestor for the largest possible \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e for which we don\u0027t move above the desired vertex (the number of pushes above it isn\u0027t too small).\u003c/p\u003e\u003cp\u003eSince we never move up the same \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e edges twice, we can only do it \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/28/a3/28a3e1ebf443830c2b8d35cc88c49444739ab741.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e times per query. Constructing the arrays of \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e-th ancestors also works in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/28/a3/28a3e1ebf443830c2b8d35cc88c49444739ab741.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e per vertex and constructing the rest of the tree in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e per vertex, so the time complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/44/4f/444f5650f8f9de80540894d0bf33cb667ec90df3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Memory is also \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/44/4f/444f5650f8f9de80540894d0bf33cb667ec90df3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://ideone.com/x7D86K\"\u003ecode\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca name\u003d\"H\"\u003eH. Sea Port\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eA classic ACM problem: \u0026quot;you\u0027re given a lot of rules, implement it efficiently\u0026quot;.\u003c/p\u003e\u003cp\u003eFor each cargo type, we will sort the ships as pairs (arrival day, ship number). We will store the cranes in a priority queue as pairs (the last time it became idle, crane number).\u003c/p\u003e\u003cp\u003eThe program always looks at the first crane in the priority queue and look for the ship it will be assigned to. Those ships must carry one of the cargo types the crane can unload; among them, we choose the first ship that hasn\u0027t been assigned to a crane yet. The time when that crane starts unloading it is max(ship arrival time, crane idle time); the problem statement tells us how long until the crane becomes idle again.\u003c/p\u003e\u003cp\u003eThis allows us to compute the cranes assigned to all ships. The time complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/be/ae/beae48b694c1e4650ee75cd13dae3c6b7e3b82cf.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, since we pop/push a crane in the priority queue \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e times and for each crane, we check the ships with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eC\u003c/i\u003e)\u003c/span\u003e types of cargo. Memory: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e + \u003ci\u003eM\u003c/i\u003e + \u003ci\u003eC\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://ideone.com/3VxOH7\"\u003ecode\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca name\u003d\"I\"\u003eI. Shooting Game\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eGeometry. Ow. General rule (remember, rules do have exceptions, like when you have a geometry master on your team): geometric problems are the last ones to solve. At least this one has low constraints...\u003c/p\u003e\u003cp\u003eIf we knew the point Alice selected, it\u0027s not hard to find the maximum number of obstacles Bob can hide behind: if he hides far enough, then only the angle under which Alice sees him matters, and each obstacle blocks a range of such angles. We just need to find the maximum number of those ranges which intersect at some angle. That can be done by sweeping from some angle in some direction (e.g. from \u003cspan class\u003d\"tex-span\"\u003e - π\u003c/span\u003e ccw to \u003cspan class\u003d\"tex-span\"\u003eπ\u003c/span\u003e), adding/removing ranges when encountering their starting/ending points and recalculating the number of currently \u0026quot;open\u0026quot; ranges. It takes just \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/44/4f/444f5650f8f9de80540894d0bf33cb667ec90df3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time, since we need to sort the ranges\u0027 starting and ending points first.\u003c/p\u003e\u003cp\u003eThe problem is that there\u0027s an infinite amount of points to test this way — we need to reduce it to a finite number. \u003c/p\u003e\u003cp\u003eLet\u0027s consider some point \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e. If we moved to an arbitrarily close point \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a0/ef/a0efccb423384f5a270da9195b6e6a132008fa9d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, would the order in which we encountered the ranges\u0027 closing points above change? If at least two points swapped in that order, then we must have crossed the line connecting them; however, if we\u0027re not on that line, we can move arbitrarily close to it without crossing it! The only possibility is that we were exactly on that line — which also means that there wasn\u0027t a unique order, so saying that the points \u0026quot;swapped\u0026quot; in that order isn\u0027t really correct. So if we moved from a point which doesn\u0027t lie on any line connecting some two points from the input, then the maximum number of obstacles Bob can hide behind doesn\u0027t change until we reach one of those lines.\u003c/p\u003e\u003cp\u003eNote that Alice does not want to choose one of those points — the obstacles are closed segments, so the maximum number of intersecting ranges can only increase when reaching a line connecting them. Instead, it suffices to consider points that are very close to those lines.\u003c/p\u003e\u003cp\u003eThat\u0027s still an infinite number of points. We can repeat the same thought process by moving only parallel to one of those lines; once again, the answer only changes when we reach another line. That means we only need to consider the intersection points of those lines, and points very close to them.\u003c/p\u003e\u003cp\u003eWhat does \u0026quot;very close\u0026quot; mean, really? Any two intersecting lines \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e intersecting at a point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e split the plane into 4 \u0026quot;wedges\u0026quot;. We should choose some distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e and try one point at a distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e inside each of those wedges. A decent approach would be finding two points at a distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e; for each pair of those four points, we can find Bob\u0027s maximum if Alice chooses the point in the middle between them. Since the input points can only be on integer coordinates, the distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e doesn\u0027t matter as long as it\u0027s much smaller than the input coordinates.\u003c/p\u003e\u003cp\u003eWe now have a finite number of points to test — to be precise, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e)\u003c/span\u003e, since they\u0027re the intersection points of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e lines. The answer is the minimum of Bob\u0027s maxima over them and the total time complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/87/06/8706865b6562f59190e7231faa335ab24cde4e47.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003c/div\u003e","tags":["andrew","stankevich","contest","editorial"]}}