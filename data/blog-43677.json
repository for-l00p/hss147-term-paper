{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1457513143,"rating":116,"authorHandle":"romanandreev","modificationTimeSeconds":1457557747,"id":43677,"title":"\u003cp\u003eCodeforces Round #345: editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/651/problem/A\" title\u003d\"Codeforces Round 345 (Div. 2)\"\u003e651A - Joysticks\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eIdea author: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/fcspartakm\" title\u003d\"Candidate Master fcspartakm\"\u003efcspartakm\u003c/a\u003e, preparation: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/fcspartakm\" title\u003d\"Candidate Master fcspartakm\"\u003efcspartakm\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eMain idea is that each second we need to charge the joystick with lowest power level. We can just emulate it or get an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e formula, because process is very simple.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/651/problem/B\" title\u003d\"Codeforces Round 345 (Div. 2)\"\u003e651B - Beautiful Paintings\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eIdea author: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/fcspartakm\" title\u003d\"Candidate Master fcspartakm\"\u003efcspartakm\u003c/a\u003e, preparation: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/fcspartakm\" title\u003d\"Candidate Master fcspartakm\"\u003efcspartakm\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eLets look at the optimal answer. It will contain several segment of increasing beauty and between them there will be drops in the beautifulness. Solution is greedy. Lets sort all paintings and lets select which of them will be in the first increasing segment. We just go from left to right and select only one painting from each group of several paintings with the fixed beauty value. We continue this operation while there is at least one painting left.\u003c/p\u003e\u003cp\u003eWith the careful implementation we will get \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e solution.\u003c/p\u003e\u003cp\u003eBut this solution gives us the whole sequence, but the problem was a little bit easier — to determine number of such segments. From the way we construct answer it is easy to see that the number of segments always equal to the maximal number of copies of one value. Obviously we can\u0027t get less segments than that and our algorithm gives us exactly this number. This solution is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/651/problem/C\" title\u003d\"Codeforces Round 345 (Div. 2)\"\u003e651C - Watchmen\u003c/a\u003e/\u003ca href\u003d\"/contest/650/problem/A\" title\u003d\"Codeforces Round 345 (Div. 1)\"\u003e650A - Watchmen\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eIdea author: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/ipavlov\" title\u003d\"Candidate Master ipavlov\"\u003eipavlov\u003c/a\u003e, preparation: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/ipavlov\" title\u003d\"Candidate Master ipavlov\"\u003eipavlov\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eWhen Manhattan distance equals to Euclidean distance?\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eeu\u003c/i\u003e\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e \u003d (\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e + (\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e - \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003emh\u003c/i\u003e\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e \u003d (|\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e| + |\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e - \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e|)\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e \u003d (\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e + 2|\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e||\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e - \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e| + (\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e - \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eSo it is true only when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u003d \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e. This means that to count the number of such pair we need to calculate number of points on each horizontal line and each vertical line. We can do that easily with the use of std::map/TreeMap/HashMap/Dictionary, or just by sorting all coordinates. \u003c/p\u003e\u003cp\u003eIf we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e points on one horizontal or vertical line they will add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e - 1) / 2\u003c/span\u003e pairs to the result. But if we have several points in one place we will count their pairs twice, so we need to subtract from answer number of pairs of identical points which we can calculate with the same formula and using the same method of finding equal values as before.\u003c/p\u003e\u003cp\u003eIf we use TreeMap/sort then solution will run in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and if unordered_map/HashMap then in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/651/problem/D\" title\u003d\"Codeforces Round 345 (Div. 2)\"\u003e651D - Image Preview\u003c/a\u003e/\u003ca href\u003d\"/contest/650/problem/B\" title\u003d\"Codeforces Round 345 (Div. 1)\"\u003e650B - Image Preview\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eIdea author: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/fcspartakm\" title\u003d\"Candidate Master fcspartakm\"\u003efcspartakm\u003c/a\u003e, preparation: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/fcspartakm\" title\u003d\"Candidate Master fcspartakm\"\u003efcspartakm\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eWhat photos we will see in the end? Some number from the beginning of the gallery and some from the end. There are 4 cases:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eWe always go right.\u003c/li\u003e   \u003cli\u003eWe always go left.\u003c/li\u003e   \u003cli\u003eWe initially go right, then reverse direction, go through all visited photos and continue going left.\u003c/li\u003e   \u003cli\u003eWe initially go left, then reverse direction, go through all visited photos and continue going right.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eFirst two cases are straightforward, we can just emulate them. Third and fourth cases can be done with the method of two pointers. Note that if we see one more picture to the right, we spend more time on the right side and the number of photos seen to the left will decrease.\u003c/p\u003e\u003cp\u003eThis solution will run in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eAlternative solution is to fix how many photos we\u0027ve seen to the right and search how many we can see to the left with binary search. For this method we will need to precompute times of seeing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e pictures to the right and to the left. But this is solution is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, which is slightly worse then previous one, but maybe it is easier for somebody.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/651/problem/E\" title\u003d\"Codeforces Round 345 (Div. 2)\"\u003e651E - Table Compression\u003c/a\u003e/\u003ca href\u003d\"/contest/650/problem/C\" title\u003d\"Codeforces Round 345 (Div. 1)\"\u003e650C - Table Compression\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eIdea author: \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/LHiC\" title\u003d\"International Grandmaster LHiC\"\u003eLHiC\u003c/a\u003e, preparation: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/iskhakovt\" title\u003d\"Candidate Master iskhakovt\"\u003eiskhakovt\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eFirst we will solve our problem when all values are different. We will construct a graph, where vertices are cells \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e,  \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e and there is an edge between two of them if we know that one is strictly less then the other and this relation should be preserved. This graph obviously has no cycles, so we can calculate answer as dynamic programming on the vertices: \u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor ( (u, v) : Edges) {\n\tdp[v] \u003d max(dp[v], dp[u] + 1);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe can do this with topological sort or with lazy computations.\u003c/p\u003e\u003cp\u003eBut if we will construct our graph naively then it will contain \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e))\u003c/span\u003e edges. To reduce this number we will sort each row and column and add edges only between neighbours in the sorted order. Now we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e)\u003c/span\u003e edges and we compute them in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/98/00/980070b1403754914f0d6166a2f383ad5ebfefad.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time.\u003c/p\u003e\u003cp\u003eBut to solve the problem completely in the beginning we need to compress all equal values which are in the same rows and columns. We can construct second graph with edges between equal cells in the same way as before and find all connected components in it. They will be our new vertices for the first graph.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/650/problem/D\" title\u003d\"Codeforces Round 345 (Div. 1)\"\u003e650D - Zip-line\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eIdea author: \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/LHiC\" title\u003d\"International Grandmaster LHiC\"\u003eLHiC\u003c/a\u003e, preparation: \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/LHiC\" title\u003d\"International Grandmaster LHiC\"\u003eLHiC\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eWe need to find the longest increasing subsequence (LIS) after each change if all changes are independent.\u003c/p\u003e\u003cp\u003eFirst lets calculate LIS for the initial array and denote its length as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. While calculating it we will store some additional information: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e — maximal length of LIS ending on this element. Also we will need \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e — maximal length of LIS starting from this element (we can calc it when searching longest decreasing sequence on reversed array).\u003c/p\u003e\u003cp\u003eLets solve the case when we take our new element in the resulting LIS. Then we just calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003ea\u003c/i\u003e, \u003ci\u003eh\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u0026lt; \u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003elen\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ei\u003c/i\u003e]) + 1 + \u003ci\u003emax\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e \u0026gt; \u003ci\u003ea\u003c/i\u003e, \u003ci\u003eh\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e] \u0026gt; \u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003elen\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ej\u003c/i\u003e])\u003c/span\u003e. It can be done online with persistent segment tree or offline with scanline with regular segment tree in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time. This is the only case when answer can be larger then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, and it can be only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e to be exact. Second case is when we change our element and ruin all LIS of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Then answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e. Otherwise we will have at least one not ruined LIS of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e and it is the answer.\u003c/p\u003e\u003cp\u003eLets calculate number of different LIS by some modulo. It can be done with the same dynamic programming with segment tree as just finding LIS. Then we can check if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eliscount\u003c/i\u003e \u003d \u003ci\u003eliscount\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eleft\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ea\u003c/i\u003e] * \u003ci\u003eliscount\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eright\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ea\u003c/i\u003e]\u003c/span\u003e. This exactly means that all sequences go through our element.\u003c/p\u003e\u003cp\u003eBut if you don\u0027t want the solution with such \u0026quot;hashing\u0026quot; there is another approach. For each element we can calc if it can be in LIS. If so then we know on which position it will go (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e). Then for each position we will know if there are several elements wanting to go on that position or only one. If only one then it means that all LIS are going through that element.\u003c/p\u003e\u003cp\u003eOverall complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eP.S. We can solve this without segment tree, just using alternative approach to calculating LIS with dynamic programming and binary search.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/650/problem/E\" title\u003d\"Codeforces Round 345 (Div. 1)\"\u003e650E - Clockwork Bomb\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eIdea author: \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Zlobober\" title\u003d\"International Grandmaster Zlobober\"\u003eZlobober\u003c/a\u003e, preparation: \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Zlobober\" title\u003d\"International Grandmaster Zlobober\"\u003eZlobober\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eFirst idea is that answer is always equals to the number of edges from the first tree, which are not in the second one. This means that if we have an edge in both trees we will never touch it. So if we have such edge we can remove this edge and merge its two vertices together, nothing will change.\u003c/p\u003e\u003cp\u003eSecond idea that if we will take any edge from the first tree there always exists some edge from the second tree, which we can swap (otherwise second graph is not connected, but the tree is always connected). So the order of adding edges from the first tree can be arbitrary. \u003c/p\u003e\u003cp\u003eThird idea is that if we will select leaf node in the first tree, then cut its only edge, then we can add instead of it any edge going from this vertex in the second tree.\u003c/p\u003e\u003cp\u003eOverall algorithm: we store linked lists of edges in vertices, when edge is in both trees we use disjoint-set union to merge vertices and join their lists. We can simply traverse first tree to get any order of edges in which the current edge will always contain leaf as one of its vertices.\u003c/p\u003e\u003cp\u003eComplexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003eα)\u003c/span\u003e, which in practice is almost linear.\u003c/p\u003e\u003c/div\u003e","tags":[]}}