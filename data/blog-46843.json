{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1472532754,"rating":115,"authorHandle":"cjtoribio","modificationTimeSeconds":1472641203,"id":46843,"title":"\u003cp\u003eUnknown Data Structure — (Sqrt Fragmented Tree)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eBlock Tree\u003c/h1\u003e\u003ch2\u003eStory\u003c/h2\u003e\u003cp\u003eI was trying to solve \u003ca href\u003d\"//codeforces.com/gym/100589/problem/A\"\u003ethis\u003c/a\u003e problem from the gym and I struggled to find the solution. Finally, I came up with a very interesting data structure capable of handling any subtree update and really don\u0027t know if someone else has seen it before, but I will post it here since I could not find its name (if it has) in google. My solution was able to solve the problem with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e memory, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e in creation, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/50/f5/50f569c1460b0cfb4ec5311b369b5e122b4a409e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e per query. When I saw the editorial I saw that it had another interesting approach with an update buffer which solved the problem in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ff/d9/ffd94fda8977c577a25c7c4405a65380419586a3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, for my surprise my solution was \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9e/f2/9ef2e39c1a0f823296ea02a6b36771d0a54ef70e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e summing the creation and queries, and I saw conveniently the author used \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e \u0026lt;  \u003d 10\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e\u003c/span\u003e so probably the author didn\u0027t know about my approach.\u003c/p\u003e\u003cp\u003eAfter analyzing my approach and reading one of the comments in the same problem, I saw that the problem could be also solvable using Square Root Decomposition in the Euler Tour Technique. Then I analyzed my approach and it seems that they are 90% the same, but the difference is in how the decomposition is stored. As some can see the relationship between KMP and AhoCorasick (Matching in Array — Matching in Tree), I see this as (Sqrt Decomposition Array — Sqrt Decomposition in a Tree). So, after posting this structure I search in what cases is my data structure better than the Euler Trick, then I thought of a new feature that can be implemented. I found it, it can dynamically change (be cut, and joined). Well, I probably have bored with this story, so let\u0027s go to the point.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUpdate\u003c/strong\u003e — After posting this algorithm I received a comment with the name of this structure, it is called block-tree for those who don\u0027t know. I tried to find something on the internet but with no success.\u003c/p\u003e\u003ch2\u003eConstruction\u003c/h2\u003e\u003cp\u003eThe idea is not very hard, first do a dfs to compute subtree size and depth of each node. Order all nodes by depth in reverse order, this can be done in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e using counting sort. We will now create what I called fragment, we will collect small tree-like portions of the tree and assign them to fragments. The subtree size will be modified in each iteration it will count how many subtree nodes are not inside assigned to a fragment. So, each time we start with a node we shall update its subtree size, after that iterate its children again and count how many children are not assigned to a fragment, after this count reaches \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/81/f381a867c035d8ab67dd362b509e4d7f78b7a087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, we create a special node and assign the children to this new node and remove the children from the previous parent. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor(int u : orderedNodes){\n    SZ[u] \u003d 1;\n    for(int v : adj[u]){\n        SZ[u] +\u003d SZ[v];\n    }\n    newAdj \u003d []\n    temp \u003d []\n    spNodes \u003d []\n    int sum \u003d 0;\n    for(int v : adj[u]){\n        if( sum \u0026gt; sqrt(N) ){\n            int sp \u003d createSpecialNode(u, temp);\n            spNodes.push_back(sp);\n            temp \u003d [];\n            SZ[u] -\u003d sum;\n            sum \u003d 0;\n        }\n    }\n    adj[u] \u003d concat(temp, spNodes);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg alt\u003d\"Special Node creation\" src\u003d\"/predownloaded/c2/d8/c2d8ba66de47ccc76827e9527d167293c1e053c2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eAfter this I will end up with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/81/f381a867c035d8ab67dd362b509e4d7f78b7a087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e groups. \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Built Fragmented Tree\" src\u003d\"/predownloaded/8c/31/8c31839db890a62ae5859cbe1cf92263e68e3483.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003ehere each special node needs to be able to answer any query or update in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e. Since the fragment is very small \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8a/28/8a287bfbde842bd129db7aaa3fc1d53737d8ee94.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e is not possible, any other structure used in that subtree will be relatively efficient since it will be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f9/3c/f93cabd3a20523172b3f011e2b9755e345ef43da.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e or \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ce/0a/ce0ad41a3fe0ce2246ab3dcee420678d3db1e739.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, although the time constraint will be very tight. \u003c/p\u003e\u003cp\u003eSo, after this decomposition, we create a new adjacency list \u003cstrong\u003eadjacencyList\u003c/strong\u003e with these new nodes in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e, and there will be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/81/f381a867c035d8ab67dd362b509e4d7f78b7a087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e extra nodes. After that another adjacency list \u003cstrong\u003esubAdjacencyList\u003c/strong\u003e will be created in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/50/f5/50f569c1460b0cfb4ec5311b369b5e122b4a409e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e with the tree only consisting of the special nodes.\u003c/p\u003e\u003ch2\u003eProof of correct segmentation\u003c/h2\u003e\u003cp\u003eI don\u0027t have a formal proof for correct segmentation, but in the construction above the ONLY way that I create a segment is only if by adding the subtree to the list it goes over \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/81/f381a867c035d8ab67dd362b509e4d7f78b7a087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, and since the two groups of subtrees I am adding are less than \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/81/f381a867c035d8ab67dd362b509e4d7f78b7a087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (if not they would have merged before) then each time I create a fragment it will be of size \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/34/15/34154efa1fad7905403faec8be47946dbe608451.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e since ALL fragments have size \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6f/cb/6fcba0f35601a6266f7eeaf9bff5d8a6231abc6f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e then the total number of fragments will be \u003c/p\u003e\u003cp\u003eUnable to parse markup [type\u003dCF_TEX]\u003c/p\u003e. So segmentation is proven. If I am wrong in this informal proof, I am open to comments.\u003ch2\u003eQuery\u003c/h2\u003e\u003cp\u003eAfter the construction each query of subtree can be easily answered will be answered with a specialized dfs. The dfs will start on \u003cstrong\u003eu\u003c/strong\u003e and do one of two. If the node is special, then query the fragment in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e and recursively add the answers returned by dfs(specialChild) using the \u003cem\u003esubAdjacencyList\u003c/em\u003e. If the node is non-special node, then apply any pending update in the fragment this node belong and query each individual node recursively using \u003cstrong\u003eadjacencyList\u003c/strong\u003e. It is not hard to prove that the fragment \u003cstrong\u003eu\u003c/strong\u003e belongs will be updated completely in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/81/f381a867c035d8ab67dd362b509e4d7f78b7a087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e [as lazy propagation] then it will visit at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/81/f381a867c035d8ab67dd362b509e4d7f78b7a087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e nodes in that same fragment and then it will query at most all the fragments. This leads to 3 time \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/81/f381a867c035d8ab67dd362b509e4d7f78b7a087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e leaving a complexity of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/50/f5/50f569c1460b0cfb4ec5311b369b5e122b4a409e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. This code is something like this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// G         : fragment u belongs\n// leader()  : returns the leader of the fragment\nLong getSum(int u){\n\tif(leader(u) \u003d\u003d u){\n                int fragId \u003d fragmentOf[u];\n\t\tLong w \u003d frags[ fragId ].queryFragment();\n\t\tfor(int g : subAdjacencyList[ fragId ]){\n\t\t\tw +\u003d getSum( frags[g].leader );\n\t\t}\n\t\treturn w;\n\t}else{\n\t\tfrags[ G[u] ].updateAllNodesIfPendingChanges();\n\t\tLong w \u003d u \u0026gt;\u003d N ? 0 :V[ L[u] ] ;\n\t\tfor(int v : adjacencyList[u]){\n\t\t\tw +\u003d getSum(v);\n\t\t}\n\t\treturn w;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eUpdate\u003c/h2\u003e\u003cp\u003eIf the update is in one subtree it can be done similar as the Query function with lazy updates in the fragments and active updates in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/81/f381a867c035d8ab67dd362b509e4d7f78b7a087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e nodes. If the update is in all the nodes that are at distance L from the root (as in this problem), it is slightly different. For that we only need to iterate each fragment and update a value per level we have in that fragment (at most of size \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/81/f381a867c035d8ab67dd362b509e4d7f78b7a087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e) like this \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003evalueInLevel\u003c/i\u003e[\u003ci\u003eL\u003c/i\u003e - \u003ci\u003eleader\u003c/i\u003e.\u003ci\u003elevel\u003c/i\u003e]\u003c/span\u003e and update the value representing the whole fragment, in this case \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efragmentSum\u003c/i\u003e +  \u003d \u003ci\u003enodesInLevel\u003c/i\u003e[\u003ci\u003eL\u003c/i\u003e - \u003ci\u003eleader\u003c/i\u003e.\u003ci\u003elevel\u003c/i\u003e]\u003c/span\u003e. this will be done in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time, for each fragment. This later update will be seen like this.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid update(int LVL, Long v){\n\tV[LVL] +\u003d v;\n\tfor(Fragment \u0026amp;f : frags){\n\t\tf.update(LVL, v);\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eCut/Join\u003c/h2\u003e\u003cp\u003eEverything above is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/81/f381a867c035d8ab67dd362b509e4d7f78b7a087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e per query, cut/join in a node is not that hard to do. For cut we will only split one fragment and add a new parentless special node. And for join we will assign a parent to that special node. This sounds as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e, but since we need to update the old(in cut) or new(in join) parent of the cut node this will probably cost \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/81/f381a867c035d8ab67dd362b509e4d7f78b7a087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. This sounds amazing, but there is one problem, each cut creates one special node. and the complexity of this whole structure is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003especialNodeCount\u003c/i\u003e)\u003c/span\u003e for query and update. So probably we will lose the efficiency with many cuts. To solve this, we take advantage of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e creation time. Each time the whole tree has been cut \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/81/f381a867c035d8ab67dd362b509e4d7f78b7a087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e times, we will rebuild the tree in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e, so that it will recover again the optimal amount of special nodes.\u003c/p\u003e\u003ch3\u003eNotes:\u003c/h3\u003e \u003cul\u003e   \u003cli\u003eThe whole code can be seen in my submission \u003ca href\u003d\"//codeforces.com/gym/100589/submission/20273231\"\u003ehere\u003c/a\u003e or \u003ca href\u003d\"https://github.com/cjtoribio/Algorithms/blob/master/Trees/FragmentedTree.cpp\"\u003ehere\u003c/a\u003e to the problem. Any tip or something wrong in this post, just leave a comment..\u003c/li\u003e   \u003cli\u003eWas said in comments that \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/mugurelionut\" title\u003d\"International master mugurelionut\"\u003emugurelionut\u003c/a\u003e \u003ca href\u003d\"https://arxiv.org/ftp/arxiv/papers/1303/1303.5481.pdf\"\u003epaper\u003c/a\u003e was the same, i thought that but then i read it carefully and they solve different problems.\u003c/li\u003e   \u003cli\u003eIt seems there are people that knows this, waiting for some sources.\u003c/li\u003e \u003c/ul\u003e\u003c/div\u003e","tags":["#trees","fragmented_tree","decomposition","sqrt_decomposition"]}}