{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1481391976,"rating":6,"authorHandle":"ebanner","modificationTimeSeconds":1524283919,"id":48986,"title":"\u003cp\u003eTutorial: Simulating recursion with a stack\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cem\u003eFun fact: from beginning to end this blog post took me 16 months!\u003c/em\u003e\u003c/p\u003e\u003cp\u003eThis will be a tutorial on simulating recursion with a stack. I developed this tutorial after using this technique to solve \u003ca href\u003d\"/contest/472/problem/B\" title\u003d\"Codeforces Round 270\"\u003e472B - Уроки дизайна задач: учимся у жизни\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eConsider the following recursive definition of the \u003ccode\u003efactorial()\u003c/code\u003e function.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003edef factorial(n):\n   return n*factorial(n-1) if n\u0026gt;1 else 1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis definition is compact, concise, and mirrors the definition that appears in math textbooks very closely. In many ways it is the most natural way to define \u003ccode\u003efactorial()\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eHowever, there is a problem. For very large values of \u003ccode\u003en\u003c/code\u003e, you will see that we will get a \u003ccode\u003eStackOverflowError\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eTo understand why this is the case, you must understand that recursion is implemented in Python (and most other languages) as growing and shrinking a \u003ca href\u003d\"https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29\"\u003estack\u003c/a\u003e in memory. \u003c/p\u003e\u003cp\u003eFor example, consider the following simulation of the computation of \u003ccode\u003efactorial(3)\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/72/28/722844cdf7a89a5137ecc2da736565cd31280369\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThat is, to compute \u003ccode\u003efactorial(3)\u003c/code\u003e, we need to compute \u003ccode\u003efactorial(2)\u003c/code\u003e and then multiply the result by \u003ccode\u003e3\u003c/code\u003e. Since we have very specific instructions to perform after computing \u003ccode\u003efactorial(2)\u003c/code\u003e (i.e. multiplying by \u003ccode\u003e3\u003c/code\u003e), we need to save these instructions so we can come back to them after computing \u003ccode\u003efactorial(2)\u003c/code\u003e. This is accomplished by saving our local state (e.g. local variables) on a stack and then shifting our focus to \u003ccode\u003efactorial(2)\u003c/code\u003e. We repeat this process until the values of \u003ccode\u003efactorial(2)\u003c/code\u003e is computed.\u003c/p\u003e\u003cp\u003eTo more closely mirror the stack simulation, we can rewrite our definition of \u003ccode\u003efactorial()\u003c/code\u003e as follows.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/0a/4e/0a4e6068a395bdb9466e061fb09871742d1608e9\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eHere, it is more clear as to the order of operations. We have distinct regions of code corresponding to first checking for the base case, then making the recursive call if that condition is not met, and instructions after the recursive call (as well as instructions for computing the base case).\u003c/p\u003e\u003cp\u003eIf we wish to convert our recursive definition to an iterative one we can do so with the following transformation.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/8d/da/8dda6f2be619f03663d3a93dc4e6de6cebe04408\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eAnd here is what it looks like.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/81/25/8125e47264f4a66527c8b9b742b64a5d2c98a18b\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eNote that the \u003ccode\u003eRESULT\u003c/code\u003e above the table refers to a global variable \u0026quot;outside\u0026quot; of the stack.\u003c/p\u003e\u003cp\u003eHow this proceeds is that while there is something on the stack we pop it off and perform the action that\u0027s associated with it. The first entry on the stack should be intuitive. Our goal is to compute \u003ccode\u003efactorial(3)\u003c/code\u003e so we put a call to \u003ccode\u003efactorial(3)\u003c/code\u003e on the stack.\u003c/p\u003e\u003cp\u003eIn the \u003cem\u003eCALL\u003c/em\u003e case, we unpack the associated data in that entry (i.e. the function arguments) and execute the body of the function. If we hit the base case we \u0026quot;return\u0026quot; by setting a global variable which can be checked by the \u0026quot;caller\u0026quot;. If we hit the recursive case we do something fancier.\u003c/p\u003e\u003cp\u003eIn the recursive case we put entries on the stack to simulate recursion. That is, the next time we pop an entry from the stack, we should find a function call. If that is the base case, then the next time we pop from the stack we should get the value from that function call and resume execution. That is exactly what is going on here.\u003c/p\u003e\u003cp\u003eWhat if we had multiple recursive calls in our function? The only change we would have to make multiple return actions (i.e. \u003ccode\u003eRESUME1\u003c/code\u003e, \u003ccode\u003eRESUME2\u003c/code\u003e, ...) for the number of recursive calls in our function.\u003c/p\u003e\u003cp\u003eWhat about code before checking for the base or recursive case? That code would go right above the case check (in the body of the \u003ccode\u003eaction \u003d\u003d CALL\u003c/code\u003e conditional).\u003c/p\u003e\u003cp\u003eI hope you enjoyed it!\u003c/p\u003e\u003c/div\u003e","tags":[]}}