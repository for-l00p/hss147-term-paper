{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1421848420,"rating":0,"authorHandle":"supercharger","modificationTimeSeconds":1421853099,"id":15924,"title":"\u003cp\u003eRange Minimum Query, For Top 2 Min Elements in single range\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eCan we tweak RMQ for finding Top 2 or 3 Elements with in a single range ( like using another Data structure to augment) .\u003c/p\u003e\u003cp\u003eA Naive RMQ algorithm looks like below, \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e//M[][][0] contains the top min element, and M[][][1] is the second min\nprivate void computeRMQ(int M[][][], int A[], int N) {\n\t\tfor (int i \u003d 0; i \u0026lt; A.length; i++) {\n\t\t\tM[i][i][0] \u003d i;\n\t\t\tM[i][i][1] \u003d i;\n\t\t}\n\t\tfor (int i \u003d 0; i \u0026lt; A.length; i++) {\n\t\t\tfor (int j \u003d i + 1; j \u0026lt; A.length; j++) {\t\t\n\t\t\t\tif (A[M[i][j - 1][0]] \u0026lt; A[j]) {\n\t\t\t\t\tM[i][j][1] \u003d M[i][j][0];\n                                        M[i][j][0] \u003d M[i][j - 1][0];\n\t\t\t\t} else {\n                                        M[i][j][1] \u003d M[i][j][0];\n\t\t\t\t\tM[i][j][0] \u003d j;\n\t\t\t\t}\n                                //some cases ignored\n\t\t\t}\n\t\t}\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut, for the Can you help with any pointers for the standard O(N), O(logN) implentation....\u003c/p\u003e\u003c/div\u003e","tags":[]}}