{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1413098317,"rating":71,"authorHandle":"I_love_Hoang_Yen","modificationTimeSeconds":1413282814,"id":14233,"title":"\u003cp\u003e[GYM] ACM ICPC Vietnam National First Round 2014 — Solutions\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eFollowing are unofficial solutions for all problems.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100499/problem/A\" title\u003d\"2014 ACM-ICPC Vietnam National First Round\"\u003e100499A - Cool number\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eSolution 1\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe most obvious solution for this problem is to brute force all numbers, and check if it is a cool number. \u003ca href\u003d\"http://ideone.com/S5T6en\"\u003eMy code\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAfter running this code for several minutes, you should be able to get results for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e ≤ 9\u003c/span\u003e. The only result for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e \u003d 7\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e3211000\u003c/span\u003e, for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e \u003d 8\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e42101000\u003c/span\u003e and for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e \u003d 9\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e521001000\u003c/span\u003e. From these results, you should be able to guess the result for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e \u003d 10\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e6210001000\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSolution 2\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThere are many ways to optimize the above solution. The most standard way is to see that the sum of all digits is equal to K, thus if you restrict your brute force to exit when sum of digit is greater than K, you should get a solution which runs in around a few seconds.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100499/problem/B\" title\u003d\"2014 ACM-ICPC Vietnam National First Round\"\u003e100499B - K smallest numbers\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSince all numbers are at most \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e7\u003c/sup\u003e\u003c/span\u003e, you can count number of occurrence of each value.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/hwyGZg\"\u003eMy code\u003c/a\u003e.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100499/problem/C\" title\u003d\"2014 ACM-ICPC Vietnam National First Round\"\u003e100499C - Grid city\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eI don\u0027t know how to solve this problem, but following are some ideas from tester:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eFor each query, \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e, consider following lines:\u003c/p\u003e   \u003cul\u003e     \u003cli\u003eNearest North lines from \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e\u003c/li\u003e   \u003c/ul\u003e   \u003cul\u003e     \u003cli\u003eNearest South lines from \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e\u003c/li\u003e   \u003c/ul\u003e   \u003cul\u003e     \u003cli\u003eNearest East lines from \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e\u003c/li\u003e   \u003c/ul\u003e   \u003cul\u003e     \u003cli\u003eNearest West lines from \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e\u003c/li\u003e   \u003c/ul\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eSo we have 8 lines from \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003c/span\u003e and 8 lines from \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e. Consider all intersections of these lines (there are 64 of them). Then we can use Floyd to find shortest path in this new grid.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThis problem has many implementation details that need to be taken care of, for example, the points in queries can be on locations that are not intersections.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/yYnzoF\"\u003eAccepted code\u003c/a\u003e from \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/yenthanh.t7\" title\u003d\"Master yenthanh.t7\"\u003eyenthanh.t7\u003c/a\u003e who implemented this idea.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100499/problem/D\" title\u003d\"2014 ACM-ICPC Vietnam National First Round\"\u003e100499D - Pairwise Coprime Set\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eTo solve this problem, you must observe that the solution is always the set of primes less than or equal to N. This can be proved mathematically, but you can also observe this from playing with small cases. \u003c/p\u003e\u003cp\u003eTo find all primes that is at most N, you can use \u003ca href\u003d\"http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\"\u003eSieve of Eratosthenes\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/mHopHM\"\u003eMy code\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100499/problem/E\" title\u003d\"2014 ACM-ICPC Vietnam National First Round\"\u003e100499E - Binary Search Tree\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eDisclaimer: I haven\u0027t coded this problem, so not sure the following will work correctly.\u003c/p\u003e\u003cp\u003eSince a connected component of a binary tree is also a binary tree, the only necessary condition for it to be a binary search tree is that the keys should be in increasing order.\u003c/p\u003e\u003cp\u003eWe write a method dfs(Node u) that returns the maximum binary search tree rooted at node u. The outline of the algorithm looks like following:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eTree dfs(Node u) {\n    Tree left \u003d dfs(left_child(u))\n    Tree right \u003d dfs(right_child(u))\n\n    return build_result(left, right)\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThere are still two things that need to be taken care of:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eHow to represent a tree efficiently? Since we know that it is always a binary tree, and only the order is important, you can represent it with an array of integers, containing the keys of the tree.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eHow to build result for Node u from result of its left child and right child? To contain node u, we can only use nodes in left subtree having keys less than node u. Similarly, we can only use nodes in right subtree that have keys greater than node u. So, from the result of left subtree, we remove all nodes that have keys greater or equal to node u. Similar for right subtree, and then we can combine these keys to get the result for node u.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eNow, we have something that can run in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e. To optimize it to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e * \u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e, you can do the following:\u003c/p\u003e\u003cp\u003eWhen you get the 2 arrays from left subtree and right subtree, reuse the bigger one (adding necessary values to the other one, and return that array)\u003c/p\u003e\u003cp\u003eCode from team ThanQ+: \u003ca href\u003d\"http://ideone.com/fZGfnJ\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100499/problem/F\" title\u003d\"2014 ACM-ICPC Vietnam National First Round\"\u003e100499F - Tree again\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLet\u0027s look closely at the pre-order traversal of the tree. You can see that for every subtree rooted at vertex u, all of its nodes are at adjacent positions! Using this information, the queries become:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eMaintain the pre-order traversal of the tree\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eFor query type 1, cut the segment of the pre-order traversal of sub-tree u, and put it after pre-order traversal of sub-tree v.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eFor query type 2, print the i-th node in the pre-order traversal.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThus, the main idea is to use a balanced binary search tree, such as splay tree to maintain this pre-order traversal. However, there are still some implementation details that need to be take care of: For query 1 to work, you must also maintain the end-point of pre-order traversal of each subtree. This turns out to be very hard to implement.\u003c/p\u003e\u003cp\u003eA trick to work around this is to modify the pre-order traversal a bit: We add each vertex twice, one when entering the pre_order_traversal method, one before exiting the pre_order_traversal method. With this, you can easily maintain the end-point of pre-order traversal of each subtree, but query 2 needs some modification to work.\u003c/p\u003e\u003cp\u003eYou can see \u003ca href\u003d\"http://ideone.com/pldsNB\"\u003emy code\u003c/a\u003e for more details.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100499/problem/G\" title\u003d\"2014 ACM-ICPC Vietnam National First Round\"\u003e100499G - Visual Illusion\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eThis is the most simple problem in the constest. You just need to print the board as shown in the problem statement.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/FyOjLi\"\u003eCode\u003c/a\u003e from team ThanQ+\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100499/problem/H\" title\u003d\"2014 ACM-ICPC Vietnam National First Round\"\u003e100499H - CCTV\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eIdea:\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eConsider only camera 1, located at \u003cspan class\u003d\"tex-span\"\u003e(0, 0)\u003c/span\u003e. Divide the room into smaller triangles. For each triangle, the area that is visible from camera 1 should also be a triangle.\u003c/p\u003e\u003cp\u003eThe most difficult part in this problem is how to divide the room into smaller triangles. One way is to sort all corners of glass cases in clockwise order. Let\u0027s call these points P1, P2, ..., Pk. Now consider triangle formed by 2 rays: \u003cspan class\u003d\"tex-span\"\u003e(0, 0)\u003c/span\u003e — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(0, 0)\u003c/span\u003e — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003c/sub\u003e(\u003ci\u003ei\u003c/i\u003e + 1)\u003c/span\u003e. The viewable area of this triangle is also a triangle. Thus, you only need to consider all edges of glass cases, and see which edge is closest to the camera.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/0SOrWG\"\u003eMy code.\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100499/problem/I\" title\u003d\"2014 ACM-ICPC Vietnam National First Round\"\u003e100499I - Fraction\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSome observation:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e0.12345 \u003d 12345 / 100000\u003c/span\u003e\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e0.(123) \u003d 123 / 999\u003c/span\u003e\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e0.0(123) \u003d 123 / 9990\u003c/span\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSo, to solve this problem, you need to split the number into three parts: Integer, fraction and repeated fraction. Then add these parts together. When add these fractions together, you must be careful to avoid overflow. One way to be sure is to use Java BigInteger.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/M6UC2s\"\u003eMy code\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100499/problem/J\" title\u003d\"2014 ACM-ICPC Vietnam National First Round\"\u003e100499J - Healthy Recipes\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eThis is a \u003ca href\u003d\"http://en.wikipedia.org/wiki/Knapsack_problem\"\u003eknapsack\u003c/a\u003e problem, which can be solved using dynamic programming. However, there is one small trick in this problem: The number of meals can be exponential, and thus in the dp function, you need to reset the dp value to K when it exceeds K. See \u003ca href\u003d\"http://ideone.com/B7mkkD\"\u003eauthor solution\u003c/a\u003e for more details.\u003c/p\u003e\u003c/div\u003e","tags":["acm","solution"]}}