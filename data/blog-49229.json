{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1482384798,"rating":5,"authorHandle":"zscoder","modificationTimeSeconds":1482825166,"id":49229,"title":"\u003cp\u003eChristmas Contest 2016 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eProblem A\u003c/h2\u003e\u003cp\u003eThis problem is direct implementation. You just have to follow what the problem tells you to do. If you are having trouble, you can refer to the code below.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin\u0026gt;\u0026gt;n;\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; n - i - 1; j++)\n\t\t{\n\t\t\tcout\u0026lt;\u0026lt;\u0027 \u0027;\n\t\t}\n\t\tfor(int j \u003d 0; j \u0026lt; 2*i+1; j++)\n\t\t{\n\t\t\tcout\u0026lt;\u0026lt;\u0027*\u0027;\n\t\t}\n\t\tcout\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t}\t\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; n - 1; j++)\n\t\t{\n\t\t\tcout\u0026lt;\u0026lt;\u0027 \u0027;\n\t\t}\n\t\tcout\u0026lt;\u0026lt;\u0026quot;*\u0026quot;;\n\t\tcout\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003eProblem B\u003c/h2\u003e\u003cp\u003eThis problem is again another implementation problem. However, it\u0027s slightly harder than Problem A. Here\u0027s one way to do it. First, we translate the month from words to number. Then, if the date is after Christmas, during Christmas or 1 day before Christmas, we can handle these cases seperately. Otherwise, we can just go through the days 1 by 1 until we reach 25 December. Note that since the year is \u003cspan class\u003d\"tex-span\"\u003e2016\u003c/span\u003e, there are \u003cspan class\u003d\"tex-span\"\u003e29\u003c/span\u003e days in February. People who got WA on test 5 is mostly because of this. You can see the code for the implmentation.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nstring a[12] \u003d {\u0026quot;January\u0026quot;, \u0026quot;February\u0026quot;, \u0026quot;March\u0026quot;, \u0026quot;April\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;June\u0026quot;, \u0026quot;July\u0026quot;, \u0026quot;August\u0026quot;, \u0026quot;September\u0026quot;, \u0026quot;October\u0026quot;, \u0026quot;November\u0026quot;, \u0026quot;December\u0026quot;};\nint days[12] \u003d {31,29,31,30,31,30,31,31,30,31,30,31};\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin \u0026gt;\u0026gt; n;\n\tstring s; cin\u0026gt;\u0026gt;s;\n\tint month \u003d 0;\n\tfor(int i \u003d 0; i \u0026lt; 12; i++)\n\t{\n\t\tif(a[i]\u003d\u003ds)\n\t\t{\n\t\t\tmonth\u003di;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(month\u003d\u003d11\u0026amp;\u0026amp;n\u0026gt;25)\n\t{\n\t\tcout\u0026lt;\u0026lt;\u0026quot;Christmas is Over :(\u0026quot;;\n\t\treturn 0;\n\t}\n\telse if(month\u003d\u003d11\u0026amp;\u0026amp;n\u003d\u003d25)\n\t{\n\t\tcout\u0026lt;\u0026lt;\u0026quot;Merry Christmas!\u0026quot;;\n\t\treturn 0;\n\t}\n\telse if(month\u003d\u003d11\u0026amp;\u0026amp;n\u003d\u003d24)\n\t{\n\t\tcout\u0026lt;\u0026lt;\u0026quot;It\u0027s Christmas Eve!\u0026quot;;\n\t\treturn 0;\n\t}\n\tint ans \u003d 0;\n\twhile(month\u0026lt;11||(month\u003d\u003d11\u0026amp;\u0026amp;n\u0026lt;25))\n\t{\n\t\tans++;\n\t\tn++;\n\t\tif(n\u0026gt;days[month])\n\t\t{\n\t\t\tmonth++;\n\t\t\tn\u003d1;\n\t\t}\n\t}\n\tcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026quot; days to Christmas!\u0026quot;;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003eProblem C\u003c/h2\u003e\u003cp\u003eThis problem is just a simple application of DFS/BFS. We treat the town as a graph, where each house is a vertex and there is an edge between any two adjacent houses which are both nonempty. Now, we just have to do a DFS starting from vertex (1, 1) and see if we can reach all other nonempty houses. However, we still need to know how to find the actual route. Fortunately, that\u0027s not tough. We write dfs as a recursive function. When you go to the next house from your current house, you output the direction you\u0027re moving to. Then, call dfs on the next house. When the dfs on the next house ends, output the direction from the next house to the current house. Again, you can see the details in the code. This solution will run fast and will make much less than \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e moves.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nchar a[51][51];\nint dx[4] \u003d {1,-1,0,0};\nint dy[4] \u003d {0,0,1,-1};\nint n, m;\nbool visited[51][51];\nstring s;\nchar dir[4] \u003d {\u0027D\u0027,\u0027U\u0027,\u0027R\u0027,\u0027L\u0027};\n \nbool isvalid(int x, int y)\n{\n\tif(x\u0026gt;\u003d0\u0026amp;\u0026amp;x\u0026lt;n\u0026amp;\u0026amp;y\u0026gt;\u003d0\u0026amp;\u0026amp;y\u0026lt;m\u0026amp;\u0026amp;a[x][y]!\u003d\u0027X\u0027) return 1;\n\treturn 0;\n}\n\nvoid dfs(int x, int y)\n{\n\tvisited[x][y]\u003d1;\n\tfor(int i \u003d 0; i \u0026lt; 4; i++)\n\t{\n\t\tint x2 \u003d x+dx[i]; int y2 \u003d y+dy[i];\n\t\tif(isvalid(x2,y2)\u0026amp;\u0026amp;!visited[x2][y2])\n\t\t{\n\t\t\ts+\u003ddir[i];\n\t\t\tdfs(x2,y2);\n\t\t\ts+\u003ddir[(i^1)];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; m; j++)\n\t\t{\n\t\t\tcin\u0026gt;\u0026gt;a[i][j];\n\t\t}\n\t}\n\tif(a[0][0]\u003d\u003d\u0027X\u0027)\n\t{\n\t\tcout\u0026lt;\u0026lt;\u0026quot;Impossible\u0026quot;;\n\t\treturn 0;\n\t}\n\tdfs(0,0);\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; m; j++)\n\t\t{\n\t\t\tif(!visited[i][j]\u0026amp;\u0026amp;a[i][j]!\u003d\u0027X\u0027)\n\t\t\t{\n\t\t\t\tcout\u0026lt;\u0026lt;\u0026quot;Impossible\u0026quot;;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout\u0026lt;\u0026lt;s;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003eProblem D\u003c/h2\u003e\u003cp\u003eOnce we understand the problem, we know that it is asking us to find an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and a permutation of \u003cspan class\u003d\"tex-span\"\u003e(1, 2, ..., \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e which has exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e increasing subsequences. However, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≤ 150\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e\u003c/span\u003e. This suggests that the answer might be related to the binary representation of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e) ≈ 60\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFrom now, we\u0027ll treat the empty set as a subsequence too. Thus, in the beginning, we\u0027ll increment \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIndeed, let\u0027s take a closer look at what we can do. Suppose we already have a permutation \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e that have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e increasing subsequences. What if we add an element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + 1\u003c/span\u003e to the back of it? Then, the number of increasing subsequences becomes \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Why? Because any increasing subsequence in the new array either contains \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + 1\u003c/span\u003e or doesn\u0027t. Also, any increasing subsequence of the old array corresponds to two different increasing subsequences in the new array (add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + 1\u003c/span\u003e or don\u0027t add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + 1\u003c/span\u003e.) Thus, we can add one element to turn the number of increasing subsequences from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWhat if we add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + 1\u003c/span\u003e to the front. Then, the number of increasing subsequences increases by exactly \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, since there is only \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e new increasing subsequence, which is \u003cspan class\u003d\"tex-span\"\u003e{\u003ci\u003en\u003c/i\u003e + 1}\u003c/span\u003e. Thus, we can add one element to turn the number of increasing subsequences from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWith this in mind, the solution is now obvious. We start with \u003cspan class\u003d\"tex-span\"\u003e{1}\u003c/span\u003e, which has \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e increasing subsequences. Then, we can write \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e in its binary representation and keep applying \u003cspan class\u003d\"tex-span\"\u003e × 2\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e + 1\u003c/span\u003e operations until we reach \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. This will produce a permutation of at most \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003elog\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e) ≈ 120\u003c/span\u003e elements.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\ndeque\u0026lt;int\u0026gt; dq;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll x; cin\u0026gt;\u0026gt;x;\n\tx++;\n\tint cur \u003d 1;\n\tvi vec;\n\twhile(x)\n\t{\n\t\tif(x\u0026amp;1) vec.pb(1);\n\t\telse vec.pb(0);\n\t\tx\u0026gt;\u0026gt;\u003d1;\n\t}\n\treverse(vec.begin(),vec.end());\n\tdq.pb(cur++);\n\tif(vec[1]\u003d\u003d1)\n\t{\n\t\tdq.push_front(cur++);\n\t}\n\tfor(int i \u003d 2; i \u0026lt; vec.size(); i++)\n\t{\n\t\tdq.pb(cur++);\n\t\tif(vec[i]\u003d\u003d1)\n\t\t{\n\t\t\tdq.push_front(cur++);\n\t\t}\n\t}\n\tcout\u0026lt;\u0026lt;dq.size()\u0026lt;\u0026lt;\u0027\\n\u0027;\n\tfor(int i \u003d 0; i \u0026lt; dq.size(); i++)\n\t{\n\t\tcout\u0026lt;\u0026lt;dq[i]\u0026lt;\u0026lt;\u0027 \u0027;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003eProblem E\u003c/h2\u003e\u003cp\u003eThis problem looks simple at first glance, but it might seem messy to solve. However, if we apply dynamic programming, this problem is not as messy as it seems.\u003c/p\u003e\u003cp\u003eIndeed, a clean way to do this is set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e as the number of ways to fill the ?s with digits from the i-th digit of every number so that there will be carry to the \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e - 1)\u003c/span\u003eth digit if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e \u003d 1\u003c/span\u003e and no carry if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e \u003d 0\u003c/span\u003e. Then, the dp transitions are quite obvious, as we can just test all possible pairs of digits for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. You can see more details on the dp transition in the code. This solution runs in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(10\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e * \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int MOD \u003d 1e9 + 7;\n\nll dp[200001][2];\nvoid add(ll \u0026amp;x, ll y)\n{\n\tx+\u003dy;\n\tx%\u003dMOD;\n}\n\nbool isok(char c, int d)\n{\n\tif(c\u003d\u003d\u0027?\u0027) return true;\n\tif(c-\u00270\u0027\u003d\u003dd) return true;\n\treturn false;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tstring a, b, c;\n\tcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c;\n\tint n \u003d a.length();\n\tfor(int i \u003d 0; i \u0026lt; 10; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; 10; j++)\n\t\t{\n\t\t\tif(isok(a[n-1],i)\u0026amp;\u0026amp;isok(b[n-1],j))\n\t\t\t{\n\t\t\t\tint sum \u003d (i+j)%10;\n\t\t\t\tint carry \u003d 0;\n\t\t\t\tif(i+j\u0026gt;\u003d10) carry\u003d1;\n\t\t\t\tif(isok(c[n-1],sum)) \n\t\t\t\t{\n\t\t\t\t\tdp[n-1][carry]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i \u003d n - 2; i \u0026gt;\u003d 0; i--)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; 10; j++)\n\t\t{\n\t\t\tfor(int k \u003d 0; k \u0026lt; 10; k++)\n\t\t\t{\n\t\t\t\tfor(int l \u003d 0; l \u0026lt; 2; l++)\n\t\t\t\t{\n\t\t\t\t\tif(isok(a[i],j)\u0026amp;\u0026amp;isok(b[i],k))\n\t\t\t\t\t{\n\t\t\t\t\t\tint sum2,carry;\n\t\t\t\t\t\tcarry\u003d0;\n\t\t\t\t\t\tif(l)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsum2\u003d(j+k+1)%10;\n\t\t\t\t\t\t\tif(j+k+1\u0026gt;\u003d10) carry\u003d1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsum2\u003d(j+k)%10;\n\t\t\t\t\t\t\tif(j+k\u0026gt;\u003d10) carry\u003d1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//cerr\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;k\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;carry\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\t\t\t\t\tif(isok(c[i],sum2)) add(dp[i][carry], dp[i+1][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout\u0026lt;\u0026lt;dp[0][0];\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003eProblem F\u003c/h2\u003e\u003cp\u003eThis is another DP problem. This time, we let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e denote the maximum size a christmas tree with the same color in its interior that can be formed with the top triangle being the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e-th triangle on the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th row. (note that in this case \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e must be odd, or else the triangle is inverted and does not count as a Christmas Tree) Now, the dp transitions are again obvious. The triangles at the bottom have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e] \u003d 1\u003c/span\u003e. When we consider the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e-th triangle on the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th row, we look at the triangles below it, i.e. the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e + 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e + 2\u003c/span\u003e-th triangle on the \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e + 1)\u003c/span\u003e-th row. Note that the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/span\u003e-th triangle will be inverted in this case, since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/span\u003e is even. Now, if they\u0027re not all of the same color as the current triangle, then we can safely say that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e] \u003d 1\u003c/span\u003e, since the triangle cannot be extended anymore. Otherwise, we take \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e] \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1][\u003ci\u003ej\u003c/i\u003e], \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1][\u003ci\u003ej\u003c/i\u003e + 2]) + 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eAfter calculating all the dp values in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e time, we can finish the solution by counting for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, how many dp values are equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, and then we can count the number of christmas tree of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e easily. See the code below for implementation details.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nint a[1001][2222];\nint dp[1001][2222];\nint cnt[1001];\nint cnt2[1001];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin\u0026gt;\u0026gt;n;\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; 2*i + 1; j++)\n\t\t{\n\t\t\tcin\u0026gt;\u0026gt;a[i][j];\n\t\t}\n\t}\n\tfor(int i \u003d 0; i \u0026lt; 2*n - 1; i+\u003d2)\n\t{\n\t\tdp[n-1][i] \u003d 1;\n\t\tif(a[n-1][i]) cnt2[1]++;\n\t\telse cnt[1]++;\n\t}\n\tfor(int i \u003d n - 2; i \u0026gt;\u003d 0; i--)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; 2*i + 1; j+\u003d2)\n\t\t{\n\t\t\tif((a[i][j] \u003d\u003d a[i+1][j])\u0026amp;\u0026amp;(a[i][j]\u003d\u003da[i+1][j+1])\u0026amp;\u0026amp;(a[i][j]\u003d\u003da[i+1][j+2]))\n\t\t\t{\n\t\t\t\tdp[i][j] \u003d min(dp[i+1][j],dp[i+1][j+2])+1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j] \u003d 1;\n\t\t\t}\n\t\t\t//cerr\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;dp[i][j]\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\t\tif(a[i][j])\n\t\t\t{\n\t\t\t\tcnt2[dp[i][j]]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcnt[dp[i][j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i \u003d n - 1; i \u0026gt;\u003d 1; i--)\n\t{\n\t\tcnt[i]+\u003dcnt[i+1];\n\t\tcnt2[i]+\u003dcnt2[i+1];\n\t}\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++)\n\t{\n\t\tcout\u0026lt;\u0026lt;cnt[i]\u0026lt;\u0026lt;\u0027 \u0027;\n\t}\n\tcout\u0026lt;\u0026lt;\u0027\\n\u0027;\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++)\n\t{\n\t\tcout\u0026lt;\u0026lt;cnt2[i]\u0026lt;\u0026lt;\u0027 \u0027;\n\t}\n\tcout\u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003eProblem G\u003c/h2\u003e\u003cp\u003eNote that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(123) ≤ 7\u003c/span\u003e, so maybe we should try using at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e queries. Indeed, this is possible. One way to do this is on the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th query, query the edges between the vertices with its \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th bit in the binary representation equals to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and the vertices with its \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th bit in the binary representation equals to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. Thus, we\u0027ll spend at most \u003cspan class\u003d\"tex-span\"\u003e⌈ \u003ci\u003elog\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(\u003ci\u003en\u003c/i\u003e)⌉\u003c/span\u003e queries. How do we determine if there is an edge between vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e then? It\u0027s simple. Since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e are distinct, we know that one of their bits in the binary representation differs. So, we just refer to the query that focuses on this bit and check if the edge between them exists. This gives a simple solution that asks at most \u003cspan class\u003d\"tex-span\"\u003e7\u003c/span\u003e times.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nbool adj[125][125];\n\nint main()\n{\n\tint n \u003d 123;\n\tfor(int i \u003d 0; i \u0026lt; 7; i++)\n\t{\n\t\tvi l,r;\n\t\tfor(int j \u003d 0; j \u0026lt; n; j++)\n\t\t{\n\t\t\tif(j\u0026amp;(1\u0026lt;\u0026lt;i))\n\t\t\t{\n\t\t\t\tl.pb(j);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr.pb(j);\n\t\t\t}\n\t\t}\n\t\tif(l.empty()||r.empty()) continue;\n\t\tcout\u0026lt;\u0026lt;l.size()\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;r.size()\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\tfor(int i \u003d 0; i \u0026lt; l.size(); i++)\n\t\t{\n\t\t\tcout\u0026lt;\u0026lt;l[i]+1\u0026lt;\u0026lt;\u0027 \u0027;\n\t\t}\n\t\tcout\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\tfor(int i \u003d 0; i \u0026lt; r.size(); i++)\n\t\t{\n\t\t\tcout\u0026lt;\u0026lt;r[i]+1\u0026lt;\u0026lt;\u0027 \u0027;\n\t\t}\n\t\tcout\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\tfflush(stdout);\n\t\tint m; cin\u0026gt;\u0026gt;m;\n\t\tfor(int i \u003d 0; i \u0026lt; m; i++)\n\t\t{\n\t\t\tint u, v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v;\n\t\t\tu--; v--;\n\t\t\tadj[u][v]\u003d1; adj[v][u]\u003d1;\n\t\t}\n\t}\n\tcout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0027\\n\u0027;\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; n; j++)\n\t\t{\n\t\t\tcout\u0026lt;\u0026lt;adj[i][j]\u0026lt;\u0026lt;\u0027 \u0027;\n\t\t}\n\t\tcout\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t}\n\tfflush(stdout);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003eProblem H\u003c/h2\u003e\u003cp\u003eThe minimum number of moves neccesary is \u003cspan class\u003d\"tex-span\"\u003e⌈\u003ci\u003elog\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003ci\u003en\u003c/i\u003e⌉\u003c/span\u003e. First, we prove that this number of moves is neccesary. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d ⌈\u003ci\u003elog\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003ci\u003en\u003c/i\u003e⌉\u003c/span\u003e. Suppose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e moves are used instead. Then, we may encode each vertex with a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e-digit binary number, which denotes which part the vertex is partitioned to on each move. If two vertices have the same number, the edge between them cannot be distinguished. Thus, if only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e queries are used, by pigeonhole principle two vertices will be assigned the same code, and the edge between them can\u0027t be distinguished. Thus, at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e moves are needed.\u003c/p\u003e\u003cp\u003eNow, it remains to actually construct an algorithm that uses at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e queries. There are probably various ways to do this. Note that the idea in Problem G can\u0027t work directly because if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is not a power of \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e, then the two sets might not have equal size. So, we need something different.\u003c/p\u003e\u003cp\u003eMy solution uses Divide and Conquer. Here\u0027s a sketch of the algorithm. We start with the array \u003cspan class\u003d\"tex-span\"\u003e{1, 2, ..., \u003ci\u003en\u003c/i\u003e}\u003c/span\u003e. Then, we divide it into two equal or roughly equal parts (if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is even, then the two parts will have equal size). Then, we also have a global \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e array to store the left and right part of the current query. When we split an array into half, we\u0027ll place one part in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e and the other in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e. Now, after the query, we\u0027ll continue solving the problem on the two halves of the array. Repeat this process \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e times. You can see the code for more details. A problem with this approach is that we need to guarantee the two halves are equal when the length of the current array we\u0027re dealing with is odd. However, this can be solved by noting that the number of arrays with odd length at any time must be even because \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is even. Thus, when we split the array into two unequal parts, we\u0027ll push the larger part into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e half of the time and push the smaller part into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e the other half of the time. This will guarantee that the sizes of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e are equal. Now, we can easily see that after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e steps, all pairs of vertices have been queried at least once and we can determine the whole graph.\u003c/p\u003e\u003cp\u003eSee the code if you can\u0027t understand some of the details.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nvi L, R;\nint n; \nbool child;\nvoid solve(vi \u0026amp;vec, vi \u0026amp;l, vi \u0026amp;r)\n{\n\tint nn \u003d vec.size();\n\tfor(int i \u003d 0; i \u0026lt; nn/2; i++)\n\t{\n\t\tif(child) L.pb(vec[i]);\n\t\telse R.pb(vec[i]);\n\t\tl.pb(vec[i]);\n\t}\n\tfor(int i \u003d nn/2; i \u0026lt; nn; i++)\n\t{\n\t\tif(!child) L.pb(vec[i]);\n\t\telse R.pb(vec[i]);\n\t\tr.pb(vec[i]);\n\t}\n\tif(nn\u0026amp;1) child^\u003d1;\n\treturn ;\n}\n\nint adj[1001][1001];\n\nvoid query()\n{\n\tassert(int(L.size())\u003d\u003dn/2);\n\tassert(int(R.size())\u003d\u003dn/2);\n\tcout\u0026lt;\u0026lt;n/2\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;n/2\u0026lt;\u0026lt;\u0027\\n\u0027;\n\tfor(int i \u003d 0; i \u0026lt; L.size(); i++)\n\t{\n\t\tcout\u0026lt;\u0026lt;L[i]\u0026lt;\u0026lt;\u0027 \u0027;\n\t}\n\tcout\u0026lt;\u0026lt;\u0027\\n\u0027;\n\tfor(int i \u003d 0; i \u0026lt; R.size(); i++)\n\t{\n\t\tcout\u0026lt;\u0026lt;R[i]\u0026lt;\u0026lt;\u0027 \u0027;\n\t}\n\tcout\u0026lt;\u0026lt;\u0027\\n\u0027;\n\tfflush(stdout);\n\tint m; cin\u0026gt;\u0026gt;m;\n\tfor(int i \u003d 0; i \u0026lt; m; i++)\n\t{\n\t\tint u, v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v;\n\t\tu--; v--;\n\t\tadj[u][v]\u003dadj[v][u]\u003d1;\n\t}\n\tL.clear();R.clear();\n}\n\nint main()\n{\n\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\n\tint cnt \u003d 21;\n\twhile(n\u0026lt;\u003d(1\u0026lt;\u0026lt;cnt))\n\t{\n\t\tcnt--;\n\t}\n\tcnt++;\n\tqueue\u0026lt;vi\u0026gt; q;\n\tvi vec;\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++) vec.pb(i);\n\tq.push(vec);\n\tfor(int i \u003d 0; i \u0026lt; cnt; i++)\n\t{\n\t\tqueue\u0026lt;vi\u0026gt; q2;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tvi l,r;\n\t\t\tsolve(q.front(), l, r);\n\t\t\tq.pop();\n\t\t\tq2.push(l);\n\t\t\tq2.push(r);\n\t\t}\n\t\tquery();\n\t\twhile(!q2.empty())\n\t\t{\n\t\t\tq.push(q2.front());\n\t\t\tq2.pop();\n\t\t}\n\t}\n\tprintf(\u0026quot;-1 -1\\n\u0026quot;);\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; n; j++)\n\t\t{\n\t\t\tprintf(\u0026quot;%d \u0026quot;, adj[i][j]);\n\t\t}\n\t\tprintf(\u0026quot;\\n\u0026quot;);\n\t}\n\tfflush(stdout);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003eProblem I\u003c/h2\u003e\u003cp\u003eThis problem combines dynamic programming and binary search. The solution consists of two parts : Finding the length of the string and finding the letters of the string one by one. So, we can binary search the length of the string. However, in order to do so, we need to find the number of nice strings are there with length \u003cspan class\u003d\"tex-span\"\u003e ≤ \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. However, finding the letters of the string one by one is not so easy. We can test all possible letters the current letter can possibly be, but then we need more information. \u003c/p\u003e\u003cp\u003eTo solve this, let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e denote the number of nice strings of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e which starts with exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e consonants if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e \u003d 0\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e vowels if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e \u003d 1\u003c/span\u003e. The dp transitions can be done by considering both cases where the first letter is vowel or consonant and transitioning to the correct dp states. After we precompute the dp values, all our problems can be solved.\u003c/p\u003e\u003cp\u003eTo find the number of nice strings of length \u003cspan class\u003d\"tex-span\"\u003e ≤ \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, just add all the dp values for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e ≤ \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. We can even precompute this value to make the code faster. Thus, we can now find the length of string fast.\u003c/p\u003e\u003cp\u003eNow, we will build the answer string one character at a time, from left to right. We try all possibilties for the current letter from a to z. Suppose we are trying to some character \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e. Then, we find the number of nice strings with that length that start with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e. This is where the dp values comes in. We know the maximum number of consonants and vowels in a row that we can have. So, we just try all possible dp values and add them if the number of consonants in a row or number of vowels in a row doesn\u0027t exceed the given limit. See the code for more details. We iterate through the letters \u0027a\u0027 to \u0027z\u0027 until the total number of strings that are less than the current string is at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. This whole thing will take only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elengthofstring\u003c/i\u003e * 26)\u003c/span\u003e time. For the maximal case, the length of string is less than \u003cspan class\u003d\"tex-span\"\u003e15\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe can repeat this for all queries and this solution will work in time.\u003c/p\u003e\u003cp\u003eAlso note that we can easily reverse the problem and ask for a given nice string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, the index of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e in the list.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nbool vowel[27];\nll dp[201][2][6]; //0 \u003d consonant, 1 \u003d vowel\nll ans[201];\nconst ll INF \u003d ll(2e18);\nll mult(ll x, ll y)\n{\n\tif(y\u003d\u003d0) return 0;\n\tif(x\u0026gt;INF/y) return INF;\n\treturn (x*y);\n}\n\nvoid add(ll \u0026amp;x, ll y)\n{\n\tx+\u003dy;\n\tif(x\u0026gt;\u003dINF) x\u003dINF;\n}\n\nstring solve(ll x)\n{\n\tll lo \u003d 1; ll hi \u003d 20;\n\tll res \u003d 0;\n\twhile(lo\u0026lt;\u003dhi)\n\t{\n\t\tll mid \u003d (lo+hi)\u0026gt;\u0026gt;1;\n\t\tif(x\u0026lt;\u003dans[mid])\n\t\t{\n\t\t\tres\u003dmid;\n\t\t\thi\u003dmid-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlo\u003dmid+1;\n\t\t}\n\t}\n\t//cerr\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;res\u0026lt;\u0026lt;\u0027\\n\u0027;\n\tx-\u003dans[res-1];\n\tstring s(res,\u0027$\u0027);\n\tbool cur \u003d 1; int upto \u003d 0;\n\tfor(int i \u003d 0; i \u0026lt; res; i++)\n\t{\n\t\tll prevsum\u003d0;\n\t\tll sum \u003d 0;\n\t\tfor(int j \u003d 0; j \u0026lt; 26; j++)\n\t\t{\n\t\t\tbool cur2 \u003d 0; \n\t\t\tint upto2 \u003d 0;\n\t\t\tif(cur\u003d\u003dvowel[j])\n\t\t\t{\n\t\t\t\tupto2 \u003d upto+1;\n\t\t\t\tcur2 \u003d cur;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcur2 \u003d cur^1;\n\t\t\t\tupto2 \u003d 1;\n\t\t\t}\n\t\t\tif(cur2\u0026amp;\u0026amp;upto2\u0026gt;2) continue;\n\t\t\tif(!cur2\u0026amp;\u0026amp;upto2\u0026gt;3) continue;\n\t\t\tif(i\u003d\u003dres-1)\n\t\t\t{\n\t\t\t\tif((cur2\u0026amp;\u0026amp;upto2\u0026lt;\u003d2)||(!cur2\u0026amp;\u0026amp;upto2\u0026lt;\u003d3))\n\t\t\t\t{\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int k \u003d 0; k \u0026lt; 2; k++)\n\t\t\t\t{\n\t\t\t\t\tfor(int l \u003d 1; l \u0026lt; 5; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(cur2!\u003dk)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tadd(sum,dp[res-i-1][k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif((!k\u0026amp;\u0026amp;upto2+l\u0026lt;\u003d3)||(k\u0026amp;\u0026amp;upto2+l\u0026lt;\u003d2)) add(sum,dp[res-i-1][k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x\u0026lt;\u003dsum)\n\t\t\t{\n\t\t\t\ts[i] \u003d char(j+\u0027a\u0027);\n\t\t\t\tx-\u003dprevsum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprevsum\u003dsum;\n\t\t}\n\t\tassert(s[i]!\u003d\u0027$\u0027);\n\t\tif(vowel[s[i]-\u0027a\u0027]\u003d\u003dcur)\n\t\t{\n\t\t\tupto++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcur^\u003d1;\n\t\t\tupto\u003d1;\n\t\t}\n\t\t//cerr\u0026lt;\u0026lt;s[i]\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;cur\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;upto\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t}\n\treturn s;\n}\n\nbool good(string \u0026amp;s)\n{\n\tint r \u003d 0;\n\tfor(int i \u003d 0; i \u0026lt; s.length(); i++)\n\t{\n\t\tif(s[i]\u003d\u003d\u0027a\u0027||s[i]\u003d\u003d\u0027e\u0027||s[i]\u003d\u003d\u0027i\u0027||s[i]\u003d\u003d\u0027o\u0027||s[i]\u003d\u003d\u0027u\u0027)\n\t\t{\n\t\t\tr++;\n\t\t\tif(r\u0026gt;2) return false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr\u003d0;\n\t\t}\n\t}\n\tr\u003d0;\n\tfor(int i \u003d 0; i \u0026lt; s.length(); i++)\n\t{\n\t\tif(!(s[i]\u003d\u003d\u0027a\u0027||s[i]\u003d\u003d\u0027e\u0027||s[i]\u003d\u003d\u0027i\u0027||s[i]\u003d\u003d\u0027o\u0027||s[i]\u003d\u003d\u0027u\u0027))\n\t\t{\n\t\t\tr++;\n\t\t\tif(r\u0026gt;3) return false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr\u003d0;\n\t\t}\n\t}\n\treturn true;\n}\n\nll belo(string s)\n{\n\tll lo \u003d 1; ll hi \u003d ll(1e18);\n\tll ans \u003d 0;\n\twhile(lo\u0026lt;\u003dhi)\n\t{\n\t\tll mid \u003d (lo+hi)\u0026gt;\u0026gt;1;\n\t\tstring tmp \u003d solve(mid);\n\t\t//cerr\u0026lt;\u0026lt;mid\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;solve(mid)\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\tif((tmp.length()\u0026lt;s.length())||(tmp.length()\u003d\u003ds.length()\u0026amp;\u0026amp;tmp\u0026lt;s))\n\t\t{\n\t\t\tlo\u003dmid+1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans\u003dmid;\n\t\t\thi\u003dmid-1;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tvowel[0]\u003d1;\n\tvowel[\u0027e\u0027-\u0027a\u0027]\u003d1;\n\tvowel[\u0027i\u0027-\u0027a\u0027]\u003d1;\n\tvowel[\u0027o\u0027-\u0027a\u0027]\u003d1;\n\tvowel[\u0027u\u0027-\u0027a\u0027]\u003d1;\n\tfor(int i \u003d 1; i \u0026lt;\u003d 2; i++) dp[0][1][i]\u003d1;\n\tfor(int i \u003d 1; i \u0026lt;\u003d 3; i++) dp[0][0][i]\u003d1;\n\tdp[1][0][1] \u003d 21;\n\tdp[1][1][1] \u003d 5;\n\tfor(int i \u003d 2; i \u0026lt;\u003d 20; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; 2; j++)\n\t\t{\n\t\t\tfor(int k \u003d 1; k \u0026lt; 5; k++)\n\t\t\t{\n\t\t\t\tif(j\u003d\u003d0\u0026amp;\u0026amp;k\u0026gt;\u003d4) break;\n\t\t\t\tif(j\u003d\u003d1\u0026amp;\u0026amp;k\u0026gt;\u003d3) break;\n\t\t\t\tll cot;\n\t\t\t\tif(j) cot \u003d 5;\n\t\t\t\telse cot \u003d 21;\n\t\t\t\tif(k\u0026gt;1)\n\t\t\t\t{\n\t\t\t\t\tadd(dp[i][j][k], mult(dp[i-1][j][k-1],cot));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor(int l \u003d 1; l \u0026lt; 5; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tadd(dp[i][j][k], mult(cot,dp[i-1][(j^1)][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i \u003d 1; i \u0026lt;\u003d 20; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; 2; j++)\n\t\t{\n\t\t\tfor(int k \u003d 0; k \u0026lt; 5; k++)\n\t\t\t{\n\t\t\t\tadd(ans[i],dp[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i \u003d 2; i \u0026lt;\u003d 20; i++)\n\t{\n\t\tadd(ans[i],ans[i-1]);\n\t}\n\t//cerr\u0026lt;\u0026lt;solve(2448853156LL)\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t//cerr\u0026lt;\u0026lt;belo(\u0026quot;zscoder\u0026quot;)\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t//cerr\u0026lt;\u0026lt;solve(2448853156LL)\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t/*\n\tfor(int i \u003d 1; i \u0026lt;\u003d 20; i++)\n\t{\n\t\tcout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t}\n\t*/\n\t\n\tint q; cin\u0026gt;\u0026gt;q;\n\twhile(q--)\n\t{\n\t\tll x; cin\u0026gt;\u0026gt;x;\n\t\tstring s \u003d solve(x);\n\t\t//cerr\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\tassert(good(s));\n\t\tcout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003eProblem J\u003c/h2\u003e\u003cp\u003eAt first, this problem might tempt you to implement a greedy solution. However, chances are it is incorrect and there were several testcases constructed to fail the greedy solutions. This problem is in fact a simple application of Gaussian Elimination on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eZ\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e60\u003c/sup\u003e\u003c/span\u003e. You can learn about this trick \u003ca href\u003d\"https://www.hackerearth.com/practice/notes/gaussian-elimination/\"\u003ehere\u003c/a\u003e and \u003ca href\u003d\"http://math.stackexchange.com/questions/48682/maximization-with-xor-operator\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eAnyway, this algorithm allows us to reduce the set of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e integers into a set of at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e) ≈ 60\u003c/span\u003e integers which are the basis of the vector space. We are left with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e numbers where the most significant bit of each number is different. (the trick is described in the links given above) Now, a simple greedy solution works. We\u0027ll process each query seperately. Firstly, note that there are \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e possible strengths as the xor of any subset (including the empty set) of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e numbers produces a different number. Now, we sort the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e numbers in decreasing order of the most significant bit. We can choose to take or ignore each number to xor with our current strength. Note that one of these choices will make the currently editable most significant bit become 1 and the other choice will make it 0. Thus, we make the choice according to the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. For example, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e \u003d 3\u003c/span\u003e and you\u0027re deciding whether to make the current bit 1 or 0. Then, you see if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e ≤ 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e - 1\u003c/sup\u003e \u003d 4\u003c/span\u003e holds. If it holds, that means the current bit has to be \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. Otherwise, the current bit has to be \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eAlternatively, after getting the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e numbers by Gaussian Elimination Trick, you can note that the set of numbers formed are all the numbers that has 0 in bit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e such that all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e numbers don\u0027t have bit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e as their most significant bit. There are \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e such numbers and we can easily find out what is the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e-th number by decomposing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e in its binary representation.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nstruct gausselim\n{\n\tint rank;\n\tll cyc[61];\n\tvoid init()\n\t{\n\t\tfor(int i \u003d 0; i \u0026lt; 61; i++)\n\t\t{\n\t\t\tcyc[i] \u003d 0;\n\t\t}\n\t\trank \u003d 0;\n\t}\n\tvoid add(ll x)\n\t{\n\t\tfor(int i \u003d 60; i \u0026gt;\u003d 0; i--)\n\t\t{\n\t\t\tif(x\u0026amp;(1LL\u0026lt;\u0026lt;i))\n\t\t\t{\n\t\t\t\tif(cyc[i]\u003d\u003d0)\n\t\t\t\t{\n\t\t\t\t\tcyc[i] \u003d x;\n\t\t\t\t\trank++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx \u003d min(x, (x^cyc[i]));\n\t\t}\t\n\t}\n};\n\ngausselim ge;\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin\u0026gt;\u0026gt;n;\n\tge.init();\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tll x; cin\u0026gt;\u0026gt;x;\n\t\tge.add(x);\n\t}\n\tvector\u0026lt;pair\u0026lt;ll,ll\u0026gt; \u0026gt; vec;\n\tfor(int i \u003d 60; i \u0026gt;\u003d 0; i--)\n\t{\n\t\tif(ge.cyc[i]\u0026gt;0) vec.pb(mp(ge.cyc[i],i));\n\t}\n\tint q; cin \u0026gt;\u0026gt; q;\n\twhile(q--)\n\t{\n\t\tll k; cin\u0026gt;\u0026gt;k;\n\t\tif(k\u0026gt;(1LL\u0026lt;\u0026lt;ge.rank))\n\t\t{\n\t\t\tcout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\t\tcontinue;\n\t\t}\t\n\t\tll ans \u003d 0;\n\t\tk--;\n\t\tint cnt \u003d vec.size();\n\t\tcnt--;\n\t\tfor(int i \u003d 0; i \u0026lt; vec.size(); i++)\n\t\t{\n\t\t\tll v \u003d vec[i].fi; int power \u003d vec[i].se;\n\t\t\tif(k\u0026lt;(1LL\u0026lt;\u0026lt;cnt))\n\t\t\t{\n\t\t\t\tif(ans\u0026amp;(1LL\u0026lt;\u0026lt;power))\n\t\t\t\t{\n\t\t\t\t\tans^\u003dv;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(ans\u0026amp;(1LL\u0026lt;\u0026lt;power))\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tans^\u003dv;\n\t\t\t\t}\n\t\t\t\tk-\u003d(1LL\u0026lt;\u0026lt;cnt);\n\t\t\t}\n\t\t\tcnt--;\n\t\t}\n\t\tcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003eProblem K\u003c/h2\u003e\u003cp\u003eThis problem looks quite complicated at first, but if you have a \u0026quot;flow mind\u0026quot;, this problem can be considered as trivial. We\u0027ll model this problem as a flow problem. Firstly, note that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e + \u003ci\u003ec\u003c/i\u003e + \u003ci\u003ed\u003c/i\u003e + \u003ci\u003ee\u003c/i\u003e\u003c/span\u003e must be even for the task to even be possible, or else we can\u0027t even split the presents evenly between boys and girls.\u003c/p\u003e\u003cp\u003eNow, consider a flow graph with a source vertex, a terminal vertex, a vertex for each type of present and a vertex for each elf. Now, we have a few constraints :\u003c/p\u003e \u003cul\u003e   \u003cli\u003eTotal number of presents of each type must be equal to some predetermined value.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThis can be done by adding an edge connecting the source vertex to each present type vertex with cost 0 and capacity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e (the number of presents of that type)\u003c/p\u003e \u003cul\u003e   \u003cli\u003eTotal number of presents received by each elf of type \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e cannot exceed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e for some \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e and factoring in the cost of elf.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThis is probably the hardest part. Note that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ 20\u003c/span\u003e, so we can afford to create \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e edges from the present vertex to the corresponding elf vertex. Why don\u0027t we just create an edge with capacity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e? This is where the cost function comes in. If the cost was fixed instead of scaling with the amount of flow passing through it, we could\u0027ve just made one edge. However, now the cost function depends on the amount of flow that pass through the edge. Thus, the solution is to create \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e different edges of capacity \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, and the cost will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is the difference between the cost for the elf to take \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e presents and the cost for the elf to take \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/span\u003e presents. Now, we can easily see that this will ensure the cost function to be satisfied as the min cost flow algorithm will pick the edges with smaller cost first.\u003c/p\u003e \u003cul\u003e   \u003cli\u003eTotal number of presents given by boys and girls should be equal.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThis is not hard. We create two auxillary sinks and connect odd-numbered elf vertices to the first and the rest to the second. Now, we set the cost of these edges as \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e and the capacity should be equal to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/97/fd/97fd772f32d7be05489081a148b9aa6cc4f832c4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e\u003c/span\u003e is the total number of presents. This ensures that the number of presents each gender gets are equal.\u003c/p\u003e\u003cp\u003eFinally, connect the two auxillary sinks to the main sink with capacity \u003cspan class\u003d\"tex-span\"\u003e∞\u003c/span\u003e. Now, run the Min Cost Flow algorithm and if the maximum flow is less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e\u003c/span\u003e, the task is impossible. Otherwise, we can figure out the cost and reconstruct the solution from the flow graph. See the code for the details.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nstruct Edge{\n    int u, v;\n    long long cap, cost;\n\n    Edge(int _u, int _v, long long _cap, long long _cost){\n        u \u003d _u; v \u003d _v; cap \u003d _cap; cost \u003d _cost;\n    }\n};\n\nstruct MinCostFlow{\n    int n, s, t;\n    long long flow, cost;\n    vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; graph;\n    vector\u0026lt;Edge\u0026gt; e;\n    vector\u0026lt;long long\u0026gt; dist;\n    vector\u0026lt;int\u0026gt; parent;\n\n    MinCostFlow(int _n){\n        // 0-based indexing\n        n \u003d _n;\n        graph.assign(n, vector\u0026lt;int\u0026gt; ());\n    }\n\n    void addEdge(int u, int v, long long cap, long long cost, bool directed \u003d true){\n        graph[u].push_back(e.size());\n        e.push_back(Edge(u, v, cap, cost));\n\n        graph[v].push_back(e.size());\n        e.push_back(Edge(v, u, 0, -cost));\n\n        if(!directed)\n            addEdge(v, u, cap, cost, true);\n    }\n\n    pair\u0026lt;long long, long long\u0026gt; getMinCostFlow(int _s, int _t){\n        s \u003d _s; t \u003d _t;\n        flow \u003d 0, cost \u003d 0;\n\n        while(SPFA()){\n            flow +\u003d sendFlow(t, 1LL\u0026lt;\u0026lt;62);\n        }\n\n        return make_pair(flow, cost);\n    }\n\n    // not sure about negative cycle\n    bool SPFA(){\n        parent.assign(n, -1);\n        dist.assign(n, 1LL\u0026lt;\u0026lt;62);        dist[s] \u003d 0;\n        vector\u0026lt;int\u0026gt; queuetime(n, 0);    queuetime[s] \u003d 1;\n        vector\u0026lt;bool\u0026gt; inqueue(n, 0);     inqueue[s] \u003d true;\n        queue\u0026lt;int\u0026gt; q;                   q.push(s);\n        bool negativecycle \u003d false;\n\n\n        while(!q.empty() \u0026amp;\u0026amp; !negativecycle){\n            int u \u003d q.front(); q.pop(); inqueue[u] \u003d false;\n\n            for(int i \u003d 0; i \u0026lt; graph[u].size(); i++){\n                int eIdx \u003d graph[u][i];\n                int v \u003d e[eIdx].v, w \u003d e[eIdx].cost, cap \u003d e[eIdx].cap;\n\n                if(dist[u] + w \u0026lt; dist[v] \u0026amp;\u0026amp; cap \u0026gt; 0){\n                    dist[v] \u003d dist[u] + w;\n                    parent[v] \u003d eIdx;\n\n                    if(!inqueue[v]){\n                        q.push(v);\n                        queuetime[v]++;\n                        inqueue[v] \u003d true;\n\n                        if(queuetime[v] \u003d\u003d n+2){\n                            negativecycle \u003d true;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return dist[t] !\u003d (1LL\u0026lt;\u0026lt;62);\n    }\n\n    long long sendFlow(int v, long long curFlow){\n        if(parent[v] \u003d\u003d -1)\n            return curFlow;\n        int eIdx \u003d parent[v];\n        int u \u003d e[eIdx].u, w \u003d e[eIdx].cost;\n\n        long long f \u003d sendFlow(u, min(curFlow, e[eIdx].cap));\n\n        cost +\u003d f*w;\n        e[eIdx].cap -\u003d f;\n        e[eIdx^1].cap +\u003d f;\n\n        return f;\n    }\n};\n\nll a[11];\nconst int C \u003d 5;\nll cap[10001][11];\nll cost[10001][11];\nconst int N \u003d 1001;\nconst ll INF \u003d ll(1e9);\nint cnt[10001][11];\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll sum \u003d 0;\n\tfor(int i \u003d 0; i \u0026lt; C; i++)\n\t{\n\t\tcin\u0026gt;\u0026gt;a[i];\n\t\tsum+\u003da[i];\n\t}\n\tif(sum\u0026amp;1)\n\t{\n\t\tcout\u0026lt;\u0026lt;-1;\n\t\treturn 0;\n\t}\n\tint n; cin\u0026gt;\u0026gt;n;\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; C; j++)\n\t\t{\n\t\t\tcin\u0026gt;\u0026gt;cap[i][j];\n\t\t}\n\t\tfor(int j \u003d 0; j \u0026lt; C; j++)\n\t\t{\n\t\t\tcin\u0026gt;\u0026gt;cost[i][j];\n\t\t}\n\t}\n\tMinCostFlow mcmf(n+30);\n\t//0 - n - 1 reserved for elves\n\t//n - n + C - 1 reserved for colors\n\tint odd \u003d n + C;\n\tint even \u003d n + C + 1;\n\tint s \u003d n + C + 2;\n\tint e \u003d n + C + 3;\n\tfor(int i \u003d 0; i \u0026lt; C; i++)\n\t{\n\t\tmcmf.addEdge(s,n+i,a[i],0);\n\t}\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; 5; j++)\n\t\t{\n\t\t\tll pre \u003d 0;\n\t\t\tfor(int k \u003d 0; k \u0026lt; cap[i][j]; k++)\n\t\t\t{\n\t\t\t\tll cur \u003d cost[i][j]*(k+1)*(k+1);\n\t\t\t\tmcmf.addEdge(n+j,i,1,cur-pre);\n\t\t\t\tpre\u003dcur;\n\t\t\t}\n\t\t}\n\t\tif(i\u0026amp;1) mcmf.addEdge(i,even,INF,0);\n\t\telse mcmf.addEdge(i,odd,INF,0);\n\t}\n\tmcmf.addEdge(even,e,sum/2,0);\n\tmcmf.addEdge(odd,e,sum/2,0);\n\tii tmp \u003d mcmf.getMinCostFlow(s,e);\n\tif(tmp.fi !\u003d sum)\n\t{\n\t\tcout\u0026lt;\u0026lt;-1;\n\t\treturn 0;\n\t}\n\tcout\u0026lt;\u0026lt;tmp.se\u0026lt;\u0026lt;\u0027\\n\u0027;\n\tfor(int i \u003d 0; i \u0026lt; mcmf.e.size(); i++)\n\t{\n\t\tint u \u003d mcmf.e[i].u; int v \u003d mcmf.e[i].v;\n\t\tint cap \u003d mcmf.e[i].cap;\n\t\tif(u\u0026gt;\u003dn\u0026amp;\u0026amp;u\u0026lt;n+C\u0026amp;\u0026amp;v\u0026gt;\u003d0\u0026amp;\u0026amp;v\u0026lt;n)\n\t\t{\n\t\t\tif(cap\u003d\u003d0)\n\t\t\t{\n\t\t\t\tcnt[v][u-n]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; C; j++)\n\t\t{\n\t\t\tcout\u0026lt;\u0026lt;cnt[i][j]\u0026lt;\u0026lt;\u0027 \u0027;\n\t\t}\n\t\tcout\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003eProblem L\u003c/h2\u003e\u003cp\u003eThis problem can be solved if you know some game theory theorems. We\u0027ll apply Sprague Grundy Theorem here, since the game given is clearly an impartial game with normal play. (If you\u0027re not familiar with it, please google and read the explanations of it as it\u0027s very helpful and essential to solve impartial games)\u003c/p\u003e\u003cp\u003eFirstly, we must calculate the grundy numbers for each vertex. Player 1 wins if the grundy number of the current game is nonzero and Player 2 wins otherwise. The grundy number of the leaves are \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. Now, we will do a simple dfs to find the grundy numbers of each node. To do so, we consider a node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and all its childrens \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. We find the grundy values of all its children. A move consists of removing one of the child and then resume the game on all the other childs. \u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e be the grundy value of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. It is well known that the grundy number of a set of games is equal to the xor of all the grundy numbers of the games. So, the state that can be reached are \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a5/da/a5da378e0ffca85eaee79f68f65c13b97e0613d8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and so on. Let \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/77/ae/77ae3342e11d148fe0f68d9ce3f030e9481cbb15.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Note that these values are equivalent to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3e/6b/3e6b2716183b773da35e863ab6b5d117baf9a3a5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for all \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Now, the grundy value of the node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is the mex of these numbers (mex stands for minimum excluded value, which means the minimum nonnegative number that does not exist in the set), by another well-known property of Grundy Numbers. Thus, this step can be done in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c7/7c/c77c78ffc89c04437f13f51674b32048df6f507d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and the entire DFS takes \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5d/1f/5d1f29f648247e77966a5b1703590aea2a6a75b6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time.\u003c/p\u003e\u003cp\u003eNow that we have the grundy values of all the nodes, it\u0027s time to convert this into a winning algorithm. Note that from this you can immediately determine the winner of the game, which is Player 1 if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[0] ≠ 0\u003c/span\u003e and Player 2 otherwise. Thus, you know which side you should choose. The question is : How to find which move to play in time?\u003c/p\u003e\u003cp\u003eFirstly, you want to have a nonzero grundy number as your game state before you move and leave a game state with grundy number 0 for the opponent. Thus, your move should be the one that turns the grundy number of the current state to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFor convenience, denote \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exr\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e as the xor of the dp values of all childrens of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTo do this, we\u0027ll store a set of moves you can make and also store the current xor of the entire game state. Then, suppose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e is the xor of the current state. If we pick a vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and its children \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e will be xored by \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/07/a9/07a964d54754a5042f9a43fe052bcf2f30e55de6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Thus, if \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/79/51/795143f901c5d6718f5306476b036225edf4c357.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, we can pick such \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e will become zero, as desired. Thus, we just have to quickly find the move \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/79/51/795143f901c5d6718f5306476b036225edf4c357.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eHowever, this is not hard. When storing the set of available moves, we also store the value \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/07/a9/07a964d54754a5042f9a43fe052bcf2f30e55de6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. In fact, it\u0027s easier to create an array of sets and when we have a new game state, we store the state into the set with index equal to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/07/a9/07a964d54754a5042f9a43fe052bcf2f30e55de6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Similarly, we remove it when the game state doesn\u0027t exist anymore. Now, searching for the game move takes \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time and this solution will always beat Santa. The detailed code is below.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nint par[100001];\nvi adj[100001];\nint dp[100001];\nint xr[100001];\n\nint grundy(vi \u0026amp;vec)\n{\n\tint ans \u003d 0;\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end());\n\tfor(int i \u003d 0; i \u0026lt; vec.size(); i++)\n\t{\n\t\tif(vec[i]\u003d\u003dans)\n\t\t{\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn ans;\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid dfs(int u, int p)\n{\n\tint x \u003d 0;\n\tvi vec;\n\tfor(int i \u003d 0; i \u0026lt; adj[u].size(); i++)\n\t{\n\t\tint v \u003d adj[u][i];\n\t\tdfs(v, u);\n\t\tx^\u003ddp[v];\n\t}\n\txr[u] \u003d x;\n\tfor(int i \u003d 0; i \u0026lt; adj[u].size(); i++)\n\t{\n\t\tint v \u003d adj[u][i];\n\t\tvec.pb((x^dp[v]));\n\t}\n\tdp[u] \u003d grundy(vec);\n}\n\nset\u0026lt;int\u0026gt; s[222222];\nset\u0026lt;int\u0026gt; available;\nint movecnt;\nint X;\n\nvoid del(int x)\n{\n\tint p \u003d par[x];\n\tX^\u003ddp[p];\n\tfor(int i \u003d 0; i \u0026lt; adj[p].size(); i++)\n\t{\n\t\tint v \u003d adj[p][i];\n\t\tassert(available.find(v)!\u003davailable.end());\n\t\tavailable.erase(v);\n\t\tassert(s[(dp[v]^xr[p]^dp[p])].find(v)!\u003ds[(dp[v]^xr[p]^dp[p])].end());\n\t\ts[(dp[p]^xr[p]^dp[v])].erase(v);\n\t\tmovecnt--;\n\t}\n}\n\nvoid ins(int x)\n{\n\tX^\u003ddp[x];\n\tfor(int i \u003d 0; i \u0026lt; adj[x].size(); i++)\n\t{\n\t\tint v \u003d adj[x][i];\n\t\tassert((dp[x]^dp[v]^xr[x])!\u003d0);\n\t\ts[(dp[x]^dp[v]^xr[x])].insert(v);\n\t\tavailable.insert(v);\n\t\t//cerr\u0026lt;\u0026lt;\u0026quot;XOR : \u0026quot;\u0026lt;\u0026lt;(dp[x]^dp[v])\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;v\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\tmovecnt++;\n\t}\n}\n\nint main()\n{\n\tint n; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\tfor(int i \u003d 1; i \u0026lt;\u003d n - 1; i++)\n\t{\n\t\tscanf(\u0026quot;%d\u0026quot;, par+i);\n\t\tpar[i]--;\n\t\tadj[par[i]].pb(i);\n\t}\n\tdfs(0,-1);\n\t\n\tint ma\u003d0;\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tma\u003dmax(ma,dp[i]);\n\t}\n\t//cerr\u0026lt;\u0026lt;\u0026quot;MAX GRUNDY : \u0026quot;\u0026lt;\u0026lt;ma\u0026lt;\u0026lt;\u0027\\n\u0027;\n\tbool turn\u003d0;\n\tif(dp[0]\u003d\u003d0)\n\t{\n\t\tprintf(\u0026quot;2\\n\u0026quot;);\n\t\tfflush(stdout);\n\t}\n\telse\n\t{\n\t\tturn\u003d1;\n\t\tprintf(\u0026quot;1\\n\u0026quot;);\n\t\tfflush(stdout);\n\t}\n\tmovecnt\u003d0;\n\tX\u003d0;\n\tins(0);\n\tint moves\u003d0;\n\twhile(1)\n\t{\n\t\t//cerr\u0026lt;\u0026lt;\u0026quot;MOVES : \u0026quot;\u0026lt;\u0026lt;movecnt\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;X\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\tmoves++;\n\t\t//cerr\u0026lt;\u0026lt;\u0026quot;MOVE \u0026quot; \u0026lt;\u0026lt;moves\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\tassert(movecnt\u003d\u003dint(available.size()));\n\t\tif(movecnt\u003d\u003d0)\n\t\t{\n\t\t\tif(turn)\n\t\t\t{\n\t\t\t\treturn 0; //lose\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn 0; //win\n\t\t\t}\n\t\t}\n\t\tif(turn)\n\t\t{\n\t\t\tassert(!s[X].empty());\n\t\t\tint tmp \u003d (*s[X].begin());\n\t\t\tassert(available.find(tmp)!\u003davailable.end());\n\t\t\tprintf(\u0026quot;%d %d\\n\u0026quot;, par[tmp]+1, tmp+1);\n\t\t\tdel(tmp);\n\t\t\t//cerr\u0026lt;\u0026lt;X\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\t\tfor(int i \u003d 0; i \u0026lt; adj[par[tmp]].size(); i++)\n\t\t\t{\n\t\t\t\tif(adj[par[tmp]][i]!\u003dtmp) \n\t\t\t\t{\n\t\t\t\t\tins(adj[par[tmp]][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cerr\u0026lt;\u0026lt;\u0026quot;PLAYER : \u0026quot;\u0026lt;\u0026lt;par[tmp]\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;tmp\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\t\t//cerr\u0026lt;\u0026lt;X\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\t\t//assert(X\u003d\u003d0);\n\t\t\tfflush(stdout);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//cerr\u0026lt;\u0026lt;X\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\t\tint u, v;\n\t\t\tscanf(\u0026quot;%d %d\u0026quot;, \u0026amp;u, \u0026amp;v);\n\t\t\tu--; v--;\n\t\t\tassert(par[v]\u003d\u003du);\n\t\t\tassert(available.find(v)!\u003davailable.end());\n\t\t\tdel(v);\n\t\t\tfor(int i \u003d 0; i \u0026lt; adj[u].size(); i++)\n\t\t\t{\n\t\t\t\tif(adj[u][i]!\u003dv) ins(adj[u][i]);\n\t\t\t}\n\t\t\t//cerr\u0026lt;\u0026lt;u\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;v\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;X\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\t\tassert(X!\u003d0);\n\t\t}\n\t\tturn^\u003d1;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}