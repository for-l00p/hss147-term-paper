{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1494190189,"rating":570,"authorHandle":"tourist","modificationTimeSeconds":1494324809,"id":51883,"title":"\u003cp\u003eVK Cup 2017 Round 3 + Codeforces Round #412 -- Tutorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHere is the tutorial of VK Cup 2017 Round 3 and Codeforces Round #412. Enjoy!\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eIs it rated?\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"807A\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003en \u003d int(input())\nresults \u003d []\nfor i in range(n):\n    results.append(list(map(int, input().split())))\n\nfor r in results:\n    if r[0] !\u003d r[1]:\n        print(\u0026quot;rated\u0026quot;)\n        exit()\n\nfor i in range(n):\n    for j in range(i):\n        if results[i][0] \u0026gt; results[j][0]:\n            print(\u0026quot;unrated\u0026quot;)\n            exit()\n\nprint(\u0026quot;maybe\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eT-Shirt Hunt\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"807B\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eMore efficient code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint main() {\n  int p, x, y;\n  cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n  for (int s \u003d y; ; s++) {\n    if (s % 50 !\u003d x % 50) {\n      continue;\n    }\n    bool me \u003d false;\n    int i \u003d s / 50 % 475;\n    for (int j \u003d 0; j \u0026lt; 25; j++) {\n      i \u003d (i * 96 + 42) % 475;\n      if (i + 26 \u003d\u003d p) {\n        me \u003d true;\n        break;\n      }\n    }\n    if (me) {\n      printf(\u0026quot;%d\\n\u0026quot;, (max(0, s - x) + 50) / 100);\n      break;\n    }\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eLess efficient code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003ep, x, y \u003d map(int, input().split())\n\ndef check(s):\n    i \u003d (s // 50) % 475\n    for t in range(25):\n        i \u003d (i * 96 + 42) % 475\n        if 26 + i \u003d\u003d p:\n            return True\n    return False\n\nfor up in range(500):\n    for down in range(500):\n        if x + 100 * up - 50 * down \u0026gt;\u003d y and check(x + 100 * up - 50 * down):\n            print(up)\n            exit()\n\nassert(False)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSuccess Rate\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"806A\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eBinary search solution code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\ntypedef long long ll;\n\nbool check(ll x, ll y, ll p, ll q, ll t) {\n  return p * t \u0026gt;\u003d x \u0026amp;\u0026amp; q * t - p * t \u0026gt;\u003d y - x;\n}\n\nvoid solve() {\n  ll x, y, p, q;\n  scanf(\u0026quot;%lld%lld%lld%lld\u0026quot;, \u0026amp;x, \u0026amp;y, \u0026amp;p, \u0026amp;q);\n\n  ll l \u003d -1;\n  ll r \u003d (ll) 1e9;\n\n  if (!check(x, y, p, q, r)) {\n    printf(\u0026quot;-1\\n\u0026quot;);\n    return;\n  }\n\n  while (r - l \u0026gt; 1) {\n    ll m \u003d (l + r) / 2;\n    if (check(x, y, p, q, m)) {\n      r \u003d m;\n    } else {\n      l \u003d m;\n    }\n  }\n\n  printf(\u0026quot;%lld\\n\u0026quot;, r * q - y);\n}\n\nint main() {\n  int t;\n  scanf(\u0026quot;%d\u0026quot;, \u0026amp;t);\n\n  while (t--) {\n    solve();\n  }\n\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eFormula solution code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint main() {\n  int tt;\n  cin \u0026gt;\u0026gt; tt;\n  while (tt--) {\n    int x, y, p, q;\n    cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; p \u0026gt;\u0026gt; q;\n    if (p \u003d\u003d 0) {\n      cout \u0026lt;\u0026lt; (x \u003d\u003d 0 ? 0 : -1) \u0026lt;\u0026lt; endl;\n      continue;\n    }\n    if (p \u003d\u003d q) {\n      cout \u0026lt;\u0026lt; (x \u003d\u003d y ? 0 : -1) \u0026lt;\u0026lt; endl;\n      continue;\n    }\n    int t1 \u003d (x + p - 1) / p;\n    int t2 \u003d ((y - x) + (q - p) - 1) / (q - p);\n    cout \u0026lt;\u0026lt; (q * 1LL * max(t1, t2) - y) \u0026lt;\u0026lt; endl;\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eDynamic Problem Scoring\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"806B\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nconst int N \u003d 123456;\nconst int m \u003d 5;\nconst int k \u003d 6;\n\nint a[N][m];\nint score[N];\nint cost[m];\nint solved[m];\n\nint main() {\n  int n;\n  scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n  for (int i \u003d 0; i \u0026lt; n; i++) {\n    for (int j \u003d 0; j \u0026lt; m; j++) {\n      scanf(\u0026quot;%d\u0026quot;, a[i] + j);\n      if (a[i][j] !\u003d -1) {\n        solved[j]++;\n      }\n    }\n  }\n  for (int bots \u003d 0; bots \u0026lt;\u003d ((1 \u0026lt;\u0026lt; (k - 1)) - 1) * n; bots++) {\n    for (int j \u003d 0; j \u0026lt; m; j++) {\n      int total \u003d n + bots;\n      int cur \u003d solved[j];\n      if (a[0][j] !\u003d -1 \u0026amp;\u0026amp; a[1][j] !\u003d -1 \u0026amp;\u0026amp; a[0][j] \u0026gt; a[1][j]) {\n        cur +\u003d bots;\n      }\n      cost[j] \u003d 500;\n      while (cost[j] \u0026lt; 500 * k \u0026amp;\u0026amp; 2 * cur \u0026lt;\u003d total) {\n        cur *\u003d 2;\n        cost[j] +\u003d 500;\n      }\n    }\n    for (int i \u003d 0; i \u0026lt; 2; i++) {\n      score[i] \u003d 0;\n      for (int j \u003d 0; j \u0026lt; m; j++) {\n        if (a[i][j] !\u003d -1) {\n          score[i] +\u003d cost[j] / 250 * (250 - a[i][j]);\n        }\n      }\n    }\n    if (score[0] \u0026gt; score[1]) {\n      printf(\u0026quot;%d\\n\u0026quot;, bots);\n      return 0;\n    }\n  }\n  printf(\u0026quot;%d\\n\u0026quot;, -1);\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ePrairie Partition\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"806C\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode with the second optimization\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003en \u003d int(input())\na \u003d sorted(list(map(int, input().split())))\n\nmaxe \u003d max(a)\ncnt \u003d []\ncur \u003d 1\nk \u003d 0\ni \u003d 0\nwhile i \u0026lt; n:\n    cnt.append(0)\n    while i \u0026lt; n and a[i] \u0026lt; cur:\n        cnt[2 * k] +\u003d 1\n        i +\u003d 1\n    cnt.append(0)\n    while i \u0026lt; n and a[i] \u003d\u003d cur:\n        cnt[2 * k + 1] +\u003d 1\n        i +\u003d 1\n    k +\u003d 1\n    cur *\u003d 2\ncnt.append(0)\ncnt.append(0)\nmaxe \u003d len(cnt) - 1\n\nmaxk \u003d cnt[1]\nwas \u003d False\nfor l in range(maxk):\n    cur \u003d 1\n    while cnt[cur] \u0026gt; 0:\n        cnt[cur] -\u003d 1\n        cur +\u003d 2\n    cnt[cur] -\u003d 1\n    cursum \u003d 0\n    ok \u003d True\n    for t in range(maxe, 0, -1):\n        cursum +\u003d cnt[t]\n        if cursum \u0026gt; 0:\n            ok \u003d False\n            break\n    if ok:\n        print(l + 1, end\u003d\u0026quot; \u0026quot;)\n        was \u003d True\n\nif not was:\n    print(-1)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode with both optimizations\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nconst int MAX \u003d 66;\n\nint power[MAX + 10];\nint between[MAX + 10];\nint extra[MAX + 10];\nint ende[MAX + 10];\n\nint main() {\n  int n;\n  cin \u0026gt;\u0026gt; n;\n  for (int i \u003d 0; i \u0026lt; n; i++) {\n    long long foo;\n    cin \u0026gt;\u0026gt; foo;\n    int cc \u003d 0;\n    bool good \u003d true;\n    while (foo \u0026gt; 1) {\n      if (foo \u0026amp; 1) {\n        good \u003d false;\n      }\n      cc++;\n      foo \u0026gt;\u0026gt;\u003d 1;\n    }\n    if (good) {\n      power[cc]++;\n    } else {\n      between[cc]++;\n    }\n  }\n  int low \u003d 1, high \u003d power[0] + 1;\n  while (low \u0026lt; high) {\n    int mid \u003d (low + high) \u0026gt;\u0026gt; 1;\n    int cur \u003d mid;\n    for (int i \u003d 0; i \u0026lt; MAX; i++) {\n      extra[i] \u003d power[i] - cur;\n      int new_cur \u003d min(cur, power[i + 1]);\n      ende[i] \u003d cur - new_cur;\n      cur \u003d new_cur;\n    }\n    bool fail \u003d false;\n    int open \u003d 0;\n    for (int i \u003d MAX - 1; i \u0026gt;\u003d 0; i--) {\n      open +\u003d ende[i];\n      open -\u003d between[i];\n      open -\u003d extra[i + 1];\n      if (open \u0026lt; 0) {\n        fail \u003d true;\n        break;\n      }\n    }\n    open -\u003d extra[0];\n    if (open \u0026lt; 0) {\n      fail \u003d true;\n    }\n    if (fail) {\n      low \u003d mid + 1;\n    } else {\n      high \u003d mid;\n    }\n  }\n  if (low \u0026gt; power[0]) {\n    cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl;\n    return 0;\n  }\n  for (int i \u003d low; i \u0026lt;\u003d power[0]; i++) {\n    cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n  }\n  cout \u0026lt;\u0026lt; endl;\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ePerishable Roads\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"806D\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nconst long long inf \u003d (long long) 1e18;\n\nconst int N \u003d 2010;\n\nint a[N][N];\nlong long d[N];\nbool used[N];\n\nint main() {\n  // reading input data\n  int n;\n  scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n  for (int i \u003d 0; i \u0026lt; n; i++) {\n    a[i][i] \u003d 0;\n    for (int j \u003d i + 1; j \u0026lt; n; j++) {\n      scanf(\u0026quot;%d\u0026quot;, a[i] + j);\n      a[j][i] \u003d a[i][j];\n    }\n  }\n  // finding minimum edge weight\n  int min_edge \u003d a[0][1];\n  for (int i \u003d 0; i \u0026lt; n; i++) {\n    for (int j \u003d 0; j \u0026lt; n; j++) {\n      if (i !\u003d j) {\n        min_edge \u003d min(min_edge, a[i][j]);\n      }\n    }\n  }\n  // subtracting minimum edge weight from all edge weights\n  for (int i \u003d 0; i \u0026lt; n; i++) {\n    for (int j \u003d 0; j \u0026lt; n; j++) {\n      if (i !\u003d j) {\n        a[i][j] -\u003d min_edge;\n      }\n    }\n  }\n  // initializing distance array\n  for (int i \u003d 0; i \u0026lt; n; i++) {\n    d[i] \u003d inf;\n    for (int j \u003d 0; j \u0026lt; n; j++) {\n      if (i !\u003d j) {\n        d[i] \u003d min(d[i], 2LL * a[i][j]);\n      }\n    }\n    used[i] \u003d false;\n  }\n  // running Dijkstra\n  for (int it \u003d 0; it \u0026lt; n; it++) {\n    long long min_d \u003d inf;\n    int ver \u003d -1;\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n      if (!used[i] \u0026amp;\u0026amp; d[i] \u0026lt; min_d) {\n        min_d \u003d d[i];\n        ver \u003d i;\n      }\n    }\n    used[ver] \u003d true;\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n      d[i] \u003d min(d[i], d[ver] + a[ver][i]);\n    }\n  }\n  // printing result\n  for (int i \u003d 0; i \u0026lt; n; i++) {\n    cout \u0026lt;\u0026lt; (d[i] + (long long) min_edge * (n - 1)) \u0026lt;\u0026lt; endl;\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eBlog Post Rating\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"806E\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\ninline int signum(int x) {\n  return (x \u0026lt; 0 ? -1 : (x \u0026gt; 0 ? 1 : 0));\n}\n\nconst int inf \u003d (int) 1e9;\n\nconst int N \u003d 500010;\n\npair \u0026lt;int, int\u0026gt; a[N];\nint pos[N];\n\npair \u0026lt;int, int\u0026gt; mn[4 * N];\nint add[4 * N];\n\nvoid push(int x) {\n  add[x + x] +\u003d add[x];\n  mn[x + x].first +\u003d add[x];\n  add[x + x + 1] +\u003d add[x];\n  mn[x + x + 1].first +\u003d add[x];\n  add[x] \u003d 0;\n}\n\nvoid pull(int x) {\n  mn[x] \u003d min(mn[x + x], mn[x + x + 1]);\n}\n\nvoid build(int x, int l, int r) {\n  add[x] \u003d 0;\n  if (l \u003d\u003d r) {\n    mn[x] \u003d make_pair(a[l].first, l);\n    return;\n  }\n  int y \u003d (l + r) \u0026gt;\u0026gt; 1;\n  build(x + x, l, y);\n  build(x + x + 1, y + 1, r);\n  pull(x);\n}\n\nvoid modify(int x, int l, int r, int ll, int rr, int v) {\n  if (ll \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026lt;\u003d rr) {\n    add[x] -\u003d v;\n    mn[x].first -\u003d v;\n    return;\n  }\n  push(x);\n  int y \u003d (l + r) \u0026gt;\u0026gt; 1;\n  if (ll \u0026lt;\u003d y) {\n    modify(x + x, l, y, ll, rr, v);\n  }\n  if (rr \u0026gt; y) {\n    modify(x + x + 1, y + 1, r, ll, rr, v);\n  }\n  pull(x);\n}\n\npair \u0026lt;int, int\u0026gt; find_min(int x, int l, int r, int ll, int rr) {\n  if (ll \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026lt;\u003d rr) {\n    return mn[x];\n  }\n  push(x);\n  int y \u003d (l + r) \u0026gt;\u0026gt; 1;\n  pair \u0026lt;int, int\u0026gt; res \u003d make_pair(inf, -1);\n  if (ll \u0026lt;\u003d y) {\n    res \u003d min(res, find_min(x + x, l, y, ll, rr));\n  }\n  if (rr \u0026gt; y) {\n    res \u003d min(res, find_min(x + x + 1, y + 1, r, ll, rr));\n  }\n  pull(x);\n  return res;\n}\n\nint main() {\n  int n;\n  scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n  for (int i \u003d 0; i \u0026lt; n; i++) {\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i].first);\n    a[i].second \u003d i;\n  }\n  sort(a, a + n);\n  for (int i \u003d 0; i \u0026lt; n; i++) {\n    pos[a[i].second] \u003d i;\n  }\n  build(1, 0, n - 1);\n  set \u0026lt;int\u0026gt; minus, zero, plus;\n  for (int id \u003d 0; id \u0026lt; n; id++) {\n    int i \u003d pos[id];\n    auto p \u003d find_min(1, 0, n - 1, i, i);\n    int vote \u003d signum(p.first);\n    if (vote \u003d\u003d 0) {\n      zero.insert(i);\n    } else {\n      if (vote \u003d\u003d -1) {\n        minus.insert(i);\n        modify(1, 0, n - 1, i, n - 1, -1);\n        int last_minus \u003d *(--minus.end());\n        if (a[last_minus].first \u003d\u003d 1 - (int) minus.size()) {\n          minus.erase(last_minus);\n          modify(1, 0, n - 1, last_minus, n - 1, 1);\n          zero.insert(last_minus);\n        } else {\n          if (!zero.empty()) {\n            int first_zero \u003d *(zero.begin());\n            zero.erase(first_zero);\n            plus.insert(first_zero);\n            modify(1, 0, n - 1, first_zero, n - 1, 1);\n          }\n        }\n      } else {\n        plus.insert(i);\n        modify(1, 0, n - 1, i, n - 1, 1);\n        auto q \u003d find_min(1, 0, n - 1, i, n - 1);\n        if (q.first \u003d\u003d -1) {\n          int pos \u003d q.second;\n          plus.erase(pos);\n          modify(1, 0, n - 1, pos, n - 1, -1);\n          zero.insert(pos);\n        }\n      }\n    }\n    printf(\u0026quot;%d\\n\u0026quot;, (int) plus.size() - (int) minus.size());\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTest Data Generation\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"806F\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nusing ll \u003d long long;\nusing ld \u003d long double;\nusing D \u003d double;\nusing uint \u003d unsigned int;\ntemplate\u0026lt;typename T\u0026gt;\nusing pair2 \u003d pair\u0026lt;T, T\u0026gt;;\n\n#ifdef WIN32\n    #define LLD \u0026quot;%I64d\u0026quot;\n#else\n    #define LLD \u0026quot;%lld\u0026quot;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst long double pi \u003d acos((ld)-1.0);\n\nconst int maxn \u003d 1 \u0026lt;\u0026lt; 16;\n\ntypedef complex\u0026lt;double\u0026gt; comp;\n\ncomp oddc[maxn], evenc[maxn], tmp[maxn];\ncomp w[maxn], invw[maxn];\nll odd[maxn], even[maxn];\nint oldodd[maxn], oldeven[maxn];\nint btr[maxn];\nint n, A, mod;\nint st2;\nint answer;\n\ninline int bitrev(int x)\n{\n    return btr[x];\n}\n\nvoid fft(comp *a, int n, comp *w, comp *res)\n{\n    for (int i \u003d 0; i \u0026lt; n; i++) res[bitrev(i)] \u003d a[i];\n    for (int len \u003d 2; len \u0026lt;\u003d n; len *\u003d 2)\n    {\n        int step \u003d n / len;\n        for (int i \u003d 0; i \u0026lt; n; i +\u003d len)\n        {\n            int curw \u003d 0;\n            for (int j \u003d 0; j \u0026lt; len / 2; j++)\n            {\n                comp x \u003d res[i + j];\n                comp y \u003d res[i + len / 2 + j] * w[curw];\n                res[i + j] \u003d x + y;\n                res[i + len / 2 + j] \u003d x - y;\n                curw +\u003d step;\n            }\n        }\n    }\n}\n\nvoid preparefft(int n)\n{\n    for (int i \u003d 0; i \u0026lt; n; i++)\n    {\n        int cur \u003d i;\n        for (int j \u003d 0; (1 \u0026lt;\u0026lt; j) \u0026lt; n; j++)\n        {\n            btr[i] \u003d (btr[i] \u0026lt;\u0026lt; 1) | (cur \u0026amp; 1);\n            cur \u0026gt;\u0026gt;\u003d 1;\n        }\n    }\n    for (int i \u003d 0; i \u0026lt; n; i++)\n    {\n        w[i] \u003d comp(cos(2 * pi / n * i), sin(2 * pi / n * i));\n        invw[i] \u003d w[i];\n    }\n    reverse(invw + 1, invw + n);\n}\n\nvoid conv(ll *from, comp *to)\n{\n    for (int i \u003d n + 1; i \u0026lt; st2; i++) tmp[i] \u003d 0;\n    for (int i \u003d 0; i \u0026lt;\u003d n; i++) tmp[i] \u003d from[i];\n    fft(tmp, st2, w, to);\n}\n\nvoid convback(comp *from, ll *to)\n{\n    fft(from, st2, invw, tmp);\n    for (int i \u003d 0; i \u0026lt; st2; i++) tmp[i] /\u003d st2;\n    for (int i \u003d 0; i \u0026lt;\u003d n; i++)\n    {\n        to[i] \u003d (ll)(tmp[i].real() + 0.5);\n        assert(abs(tmp[i].imag()) \u0026lt; 0.1);\n    }\n}\n\nvoid addans()\n{\n    for (int i \u003d 1; i \u0026lt;\u003d n; i +\u003d 2) answer \u003d (answer + odd[i]) % mod;\n}\n\nvoid go(int A)\n{\n    if (A \u003d\u003d 1)\n    {\n        even[0] \u003d 1;\n        odd[0] \u003d 0;\n        odd[1] \u003d 1;\n        addans();\n        return;\n    }\n    go(A / 2);\n\n    for (int i \u003d 0; i \u0026lt;\u003d n; i++) oldodd[i] \u003d odd[i];\n    for (int i \u003d 0; i \u0026lt;\u003d n; i++) oldeven[i] \u003d even[i];\n    conv(even, evenc);\n    conv(odd, oddc);\n    for (int i \u003d 0; i \u0026lt; st2; i++)\n    {\n        if ((A / 2) % 2 \u003d\u003d 0)\n        {\n            tie(oddc[i], evenc[i])  \u003d make_pair((oddc[i] + evenc[i]) * oddc[i], (oddc[i] + evenc[i]) * (evenc[i] - (comp)1));\n        } else\n        {\n            tie(evenc[i], oddc[i])  \u003d make_pair((oddc[i] + evenc[i]) * oddc[i], (oddc[i] + evenc[i]) * (evenc[i] - (comp)1));\n        }\n    }\n    convback(oddc, odd);\n    convback(evenc, even);\n    for (int i \u003d n + 1; i \u0026lt;\u003d 2 * n; i++)\n    {\n        odd[i] \u003d 0;\n        even[i] \u003d 0;\n    }\n    for (int i \u003d 0; i \u0026lt;\u003d n; i++)\n    {\n        odd[i] \u003d (odd[i] + oldodd[i]) % mod;\n        even[i] \u003d (even[i] + oldeven[i]) % mod;\n    }\n    if (A % 2 \u003d\u003d 1)\n    {\n        for (int i \u003d n; i \u0026gt;\u003d 1; i--)\n        {\n            odd[i] \u003d (odd[i] + odd[i - 1] + even[i - 1]) % mod;\n        }\n    }\n    addans();\n}\n\nint main()\n{\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; A \u0026gt;\u0026gt; mod;\n    if (A \u003d\u003d 1)\n    {\n        cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl;\n        return 0;\n    }\n    st2 \u003d 0;\n    while ((1 \u0026lt;\u0026lt; st2) \u0026lt;\u003d n) st2++;\n    st2++;\n    st2 \u003d 1 \u0026lt;\u0026lt; st2;\n    preparefft(st2);\n    go(A / 2);\n    cout \u0026lt;\u0026lt; answer \u0026lt;\u0026lt; endl;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}