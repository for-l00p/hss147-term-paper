{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1468234297,"rating":30,"authorHandle":"loser21","modificationTimeSeconds":1468236714,"id":45987,"title":"\u003cp\u003eGoogle APAC 2017 Round A Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eSince Google APAC is one of the few contests where there is no official editorial/analysis available, I decided to write a short editorial for Round A of Google APAC 2017. You can read the problem statements from this \u003ca href\u003d\"https://code.google.com/codejam/contest/11274486/dashboard\"\u003elink\u003c/a\u003e.\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003eProblem A\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eYou need to find the number of distinct uppercase English alphabets in each of the given strings. Out of all those strings who have the maximum number of distinct alphabets, simply output the smallest one in the lexicographic order. Be careful while taking input for the large test data as the strings might contain spaces too. \u003ca href\u003d\"http://pastebin.com/7iV1uEEg\"\u003eCode\u003c/a\u003e\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003eProblem B\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eTo solve this problem, iterate from the smallest height to the largest height. For a given height h, find all connected component of cells where all cells have height h using BFS/DFS. Now for a particular connected component of height h, look at all neighbours of cell in this connected component (not of height h) and find the neighbour with minimum height say x. If x \u0026gt; h, update all cells in the component to height x. Time Complexity: \u003cstrong\u003eO(R*C*max(H[i][j])\u003c/strong\u003e per test case. \u003ca href\u003d\"http://pastebin.com/ARsdy14Y\"\u003eCode\u003c/a\u003e\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003eProblem C\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eDivide the entire expression by \u003cspan class\u003d\"tex-span\"\u003e(1 + \u003ci\u003er\u003c/i\u003e)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. The expression becomes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e \u003d \u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e / (1 + \u003ci\u003er\u003c/i\u003e) + \u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e / (1 + \u003ci\u003er\u003c/i\u003e)\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e + ...\u003c/span\u003e. Note that the RHS of the expression is a decreasing function in r. Use binary search to find out the value of r such that the expression on RHS \u003d LHS. Make sure you run your binary search for enough iterations so that the error is small enough. Time Complexity: \u003cstrong\u003eO(M*(Number of Iterations of Binary search))\u003c/strong\u003e per test case. \u003ca href\u003d\"http://pastebin.com/NDX8j45G\"\u003eCode\u003c/a\u003e\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003eProblem D\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eTo solve the small dataset, a DP approach can work where the state is dp[i][p] which stores the minimum number of coins to achieve power p using updates on first i cards only . However this approach will time out for the large data set as it is O(N*(Max Possible Total Power)). Code \u003ca href\u003d\"http://pastebin.com/Rj9z84VG\"\u003eCode\u003c/a\u003e To solve the large dataset, a meet in the middle approach works. (Use the search engine of your choice to find out more about meet in the middle approach in case you want to read about it). The idea is to consider all N choose 8 combination of cards and then divide the 8 cards into two groups of 4 cards each. Now for each of the two groups use brute force to find out all possible combination of power and the minimum number of coins to achieve that power using a map/dictionary. Eliminate all entries in a map where there is a smaller number of coins to achieve a larger power. Now iterate through all entries in a map, suppose for a particular entry you can achieve power p using k coins. Use binary search on the second map to find the max power you can get using atmost m-k coins. This approach works is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((12\u003ci\u003echoose\u003c/i\u003e8) * (10\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e) * \u003ci\u003elog\u003c/i\u003e(10\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e)\u003c/span\u003e per test case. This took a couple of minutes on my machine to run. \u003ca href\u003d\"http://pastebin.com/Gh703Dqt\"\u003eCode\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIn case if something is incorrect or unclear, please feel free to point it out either through a PM or a comment on this post. It would be great to read alternate approaches for any of the problems. Apologies in advance for any error that I might have made while writing this post.\u003c/p\u003e\u003c/div\u003e","tags":["apac","google","editorial","meet in the middle"]}}