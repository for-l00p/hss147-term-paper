{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1413652626,"rating":13,"authorHandle":"Los_Angelos_Laycurse","modificationTimeSeconds":1413654390,"id":14332,"title":"\u003cp\u003eLets discuss this problem 100025B Almost Average(I think insanely hard)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI think it is a insanely hard and interesting problem(at least to me),if I\u0027m not miss something: I \u003c/p\u003e \u003cdl\u003e\u003cdt\u003ehave came up with a idea of complexity O(m*sqrt(n)*log(n)*log(answer))\u003c/dt\u003e\u003cdd\u003e\u003cp\u003ethis is my anlanysis:\u003c/p\u003e\u003c/dd\u003e \u003c/dl\u003e\u003cp\u003ewe want to find the maximum almost everage number between [a,b] in the \u003c/p\u003e\u003cp\u003einterval (L,R), if the answer \u0026gt;\u003d0 ,then we can conclude the length of the \u003c/p\u003e\u003cp\u003elength of [a,b] is either 2 or 3,so we just need to build a segment tree \u003c/p\u003e\u003cp\u003erecord maximum (ai+a(i+1)+a(i+2))/2 and (ai+ai+1). if the result of query of [L,R] is non-negative ,then this is the answer, but if it is negative,then \u003c/p\u003e\u003cp\u003eit is more and more complex: we need to binary search the answer x. we need \u003c/p\u003e\u003cp\u003eto check if there is almost average number \u0026gt;\u003dx. we just need to check if there is \u003c/p\u003e\u003cp\u003e[a,b] v[a]-x+v[a+1]-x+...+v[b]-x\u0026gt;\u003d-x , right part is positive. if we split \u003c/p\u003e\u003cp\u003ethe interval into two part and have already checked left part and right part \u003c/p\u003e\u003cp\u003eboth are \u0026lt;-x,then we need to check the maximum sum of v[i]-x of the suffix \u003c/p\u003e\u003cp\u003eof left part of interval and maximum sum of v[i]-x of prefix of right part \u003c/p\u003e\u003cp\u003eof interval,and check the sum of suffix and prefix.but how to find them \u003c/p\u003e\u003cp\u003eefficiently. we can obersive we need to check prefix and suffix if and only \u003c/p\u003e\u003cp\u003eif the both of the sum of them are positive,that is to say the the slope \u003c/p\u003e\u003cp\u003esuffix sum of left part (i.e. (v[i+1]+..+v[j])/(j-i))\u0026gt;x i.e. (sum[j]-sum[i])/(j-i) and the slope prefix sum of right part \u0026gt;x, so we just need to find a data \u003c/p\u003e\u003cp\u003estructure to record all the suffix convex hull(decreasing index and \u003c/p\u003e\u003cp\u003edecreasing slope) of and interval and all the prefix convex hull(increasing \u003c/p\u003e\u003cp\u003eindex and decreasing slope) of interval(of course we also need to know the \u003c/p\u003e\u003cp\u003econvexhull of whole interval),if we know the covexhull, we just need to use \u003c/p\u003e\u003cp\u003ebinary search to find the position of slope that is closest to x(after this position,slope of sum \u0026lt;x i.e.sum of v[i]-x is negative just abandon them). the data \u003c/p\u003e\u003cp\u003estructure to preserve the prefix and suffix of convexhull, squarelist is what I can \u003c/p\u003e\u003cp\u003ethink of.because this problem denied any off-line approach.we need to build \u003c/p\u003e\u003cp\u003estatic squarlist. and for each squarelist we need to record the almost \u003c/p\u003e\u003cp\u003eaverage number(brute force to find) of this interval and all the prefix and \u003c/p\u003e\u003cp\u003esuffix convexhull of this interval. the whole process of build squarelist is N*sqrt(N). then for each query, if split the query inteval in to O(sqrt(N))interval for each interval that is not cover the whole of one sqarelist,just brute \u003c/p\u003e\u003cp\u003eforce to find the value,and maximum sum of v[i]-x,if it is cover the \u003c/p\u003e\u003cp\u003esqarelist then find the position of prefix covexhull whose slope closest to \u003c/p\u003e\u003cp\u003ex and the position of suffix convexhull of previous squarelist,sum it up to \u003c/p\u003e\u003cp\u003eand compare it to -x.\u003c/p\u003e\u003cp\u003ethis is the approach but I think the complexity is too high,I don\u0027t know \u003c/p\u003e\u003cp\u003emuch about Functional segment tree, but feel it can also implement this \u003c/p\u003e\u003cp\u003eidea,but it is more and more complex..\u003c/p\u003e\u003cp\u003eif you know much better idea or find some error of this approach, please discuss it.\u003c/p\u003e\u003c/div\u003e","tags":[]}}