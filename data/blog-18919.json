{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1435435045,"rating":84,"authorHandle":"Lord_F","modificationTimeSeconds":1437278067,"id":18919,"title":"\u003cp\u003eCodeforces Round #310 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello, everyone!\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/556/problem/A\" title\u003d\"Codeforces Round 310 (Div. 2)\"\u003e556A - Case of the Zeros and Ones\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIf there still exist at least one \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e and at least one \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e in the string then there obviously exists either substring \u003cspan class\u003d\"tex-span\"\u003e01\u003c/span\u003e or substring \u003cspan class\u003d\"tex-span\"\u003e10\u003c/span\u003e (or both) and we can remove it. The order in which we remove substrings is unimportant: in any case we will make \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(#\u003ci\u003ezeros\u003c/i\u003e, #\u003ci\u003eones\u003c/i\u003e)\u003c/span\u003e such operations. Thus the answer is \u003cspan class\u003d\"tex-span\"\u003e#\u003ci\u003eones\u003c/i\u003e + #\u003ci\u003ezeros\u003c/i\u003e - 2\u003ci\u003emin\u003c/i\u003e(#\u003ci\u003eones\u003c/i\u003e, #\u003ci\u003ezeros\u003c/i\u003e) \u003d |#\u003ci\u003eones\u003c/i\u003e - #\u003ci\u003ezeros\u003c/i\u003e|\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTime: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/556/problem/B\" title\u003d\"Codeforces Round 310 (Div. 2)\"\u003e556B - Case of Fake Numbers\u003c/a\u003e\u003c/p\u003e\u003cp\u003eNotice that after pressing the button \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e times gears return to initial state. So the easiest solution is to simulate the process of pressing the button \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e times and if at some step the active teeth sequence is \u003cspan class\u003d\"tex-span\"\u003e0, 1, ... , \u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e output \u0026quot;Yes\u0026quot; else \u0026quot;No\u0026quot;. But this solution can be improved. For instance, knowing the active tooth of the first gear you can quickly determine how many times pressing the button is necessary, go to that state and check the sequence only once.\u003c/p\u003e\u003cp\u003eTime: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e; solutions: \u003ca href\u003d\"http://paste.ubuntu.com/11788578/\"\u003eO(n)\u003c/a\u003e and \u003ca href\u003d\"http://paste.ubuntu.com/11788583/\"\u003eO(n^2)\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/555/problem/A\" title\u003d\"Codeforces Round 310 (Div. 1)\"\u003e555A - Case of Matryoshkas\u003c/a\u003e\u003c/p\u003e\u003cp\u003eSuppose we don\u0027t need to disassemble some sequence of dolls. Then no doll can be inserted into no doll from this chain. So we don\u0027t need to disassemble a sequence of dolls only if they are consecutive and start from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Let the length of this chain be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e. Then we will need to get one doll from another \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e - \u003ci\u003el\u003c/i\u003e + 1\u003c/span\u003e times. Now we have a sequence \u003cspan class\u003d\"tex-span\"\u003e1 → 2 → ... → \u003ci\u003el\u003c/i\u003e\u003c/span\u003e and all other dolls by themselves. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003el\u003c/i\u003e + 1\u003c/span\u003e chains in total so we need to put one doll into another \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003el\u003c/i\u003e\u003c/span\u003e times. \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003en\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e - 2\u003ci\u003el\u003c/i\u003e + 1\u003c/span\u003e operations in total.\u003c/p\u003e\u003cp\u003eTime: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e; \u003ca href\u003d\"http://paste.ubuntu.com/11788588/\"\u003esolution\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/555/problem/B\" title\u003d\"Codeforces Round 310 (Div. 1)\"\u003e555B - Case of Fugitive\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe can put a bridge between bridges \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e if its length lies in the segment \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e - \u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e;\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e - \u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e]\u003c/span\u003e. Now we have a well-known problem: there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e segments and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e points on a plane, for every segment we need to assign a point which lies in it to this segment and every point can be assigned only once. \u003c/p\u003e\u003cp\u003eLet\u0027s call a segment open if no point is assigned to it. Let\u0027s go through all points from left to right and at every moment keep all open segments that contain current point in a BST (std::set). When processing a point it should be assigned to the segment (from our set) that has the leftmost right end.\u003c/p\u003e\u003cp\u003eThis algorithm will find the answer if there is one. Suppose this solution is wrong and suppose there is a solution in which point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e is assigned to another open segment (there\u0027s no sense in skipping this point). Then some point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e is assigned to the segment which \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e was assigned to. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e is to the right of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e so we can swap them and come to our answer again. \u003c/p\u003e\u003cp\u003eTime: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e))\u003c/span\u003e; \u003ca href\u003d\"http://paste.ubuntu.com/11788596/\"\u003esolution\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/555/problem/C\" title\u003d\"Codeforces Round 310 (Div. 1)\"\u003e555C - Case of Chocolate\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s solve this problem with two segment trees: we\u0027ll keep the lowest eaten piece for each column in one of them and the leftmost eaten piece for each row in another. Suppose we have a query \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. Position where we\u0027ll stop eating chocolate is stored in the row segment tree so we can easily find the number of eaten pieces. After that we need to update both segment trees.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is rather big in this problem. One way to deal with it is to use coordinate compression. Another is to use implicit segment trees.\u003c/p\u003e\u003cp\u003eTime: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eqlogq\u003c/i\u003e)\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eqlogn\u003c/i\u003e)\u003c/span\u003e; solutions: \u003ca href\u003d\"http://paste.ubuntu.com/11788606/\"\u003e1\u003c/a\u003e and \u003ca href\u003d\"http://paste.ubuntu.com/11788614/\"\u003e2\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/555/problem/D\" title\u003d\"Codeforces Round 310 (Div. 1)\"\u003e555D - Case of a Top Secret\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI call the length of the part of the rope from the weight to the last met peg the active length (denoted as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e). After each met peg active length is reduced. Let\u0027s process queries separately: at each step we can find next peg with using binary search. If active length becomes at least two times shorter \u003cem\u003eor current step is the first one\u003c/em\u003e we proceed to the next step. Otherwise say current peg is peg \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and the next one is peg \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e (without loss of generality \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e). Then after peg \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e the rope will again touch peg \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and the weight will again rotate around peg \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Indeed, \u003cspan class\u003d\"tex-span\"\u003e2(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e) ≤ \u003ci\u003eL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e so the weight will rotate around a peg not to the right to peg \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. And either \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u003d 1\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e so it won\u0027t also rotate around a peg to the left to peg \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. As long as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e ≥ \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e the weight will rotate around these two pegs so we can skip through several steps momentarily. This way active length is shortened at least twice so there will be no more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elogL\u003c/i\u003e\u003c/span\u003e steps.\u003c/p\u003e\u003cp\u003eTime: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003emlogLlogn\u003c/i\u003e)\u003c/span\u003e; \u003ca href\u003d\"http://paste.ubuntu.com/11788623/\"\u003esolution\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/555/problem/E\" title\u003d\"Codeforces Round 310 (Div. 1)\"\u003e555E - Case of Computer Network\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst of all, let\u0027s reduce this problem to a problem on a tree. In order to achieve this let\u0027s orient edges in all biconnected components according to a DFS-order. We\u0027ll get a strongly connected component. Suppose it\u0027s false. Then this component can be divided into parts \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e such that there\u0027s no edge from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e. As initially there are at least two edges between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e this situation is impossible because after entering \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e in our DFS we\u0027ll have to exit via one of these edges. Contradiction. We can compress all biconnected components.\u003c/p\u003e\u003cp\u003eNow we need to handle several queries \u0026quot;orient edges on a simple path in a tree\u0026quot; and to check if there are no conflicts. For this let\u0027s hang our tree and find LCA\u0027s for queries\u0027 pairs of vertices. Start another DFS and for every subtree count vertices in this subtree that are beginnings of queries\u0027 paths (call it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e), that are ends of queries\u0027 paths (call it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e) and that are precalculated LCAs (call it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e). Now we can orient the edge connecting the root of the subtree and its parent: if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e - \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e is positive then it should be oriented up, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e - \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e is positive then it should be oriented down, if both are positive there\u0027s no solution, if both are zeros the direction does not matter.\u003c/p\u003e\u003cp\u003eTime: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003eql\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is the time of calculating LCA per query; \u003ca href\u003d\"http://paste.ubuntu.com/11902227/\"\u003esolution\u003c/a\u003e that uses slightly other method for the last part.\u003c/p\u003e\u003c/div\u003e","tags":[]}}