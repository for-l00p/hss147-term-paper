{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1475033790,"rating":25,"authorHandle":"tenshi_kanade","modificationTimeSeconds":1475033939,"id":47390,"title":"\u003cp\u003eGeneralized Suffix Tree\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003ePrologue:\u003c/h2\u003e\u003cp\u003eOK, so I finally decided to learn \u003cstrong\u003eSuffix Tree\u003c/strong\u003e. It\u0027s a monster I\u0027d never dared to look in the eyes, I had always gotten away with using Suffix Array with the tail between my legs until now. The thing is that some problems require a more efficient data structure, so I decided to leave my fears behind and learn it once and for all.\u003c/p\u003e\u003cp\u003eFirst of all, I read about it in a few books and some papers online. When I understood its final structure and how to work with it, I searched an implementation online (no, I didn\u0027t plan on coding everything from scratch). I found a good and efficient implementation on Geeks for Geeks, but unfortunately it was written in C and it worked with native types.\u003c/p\u003e\u003ch2\u003eThe tweaking and testing:\u003c/h2\u003e\u003cp\u003eI worked with the code and tweaked it here and there. I removed unnecessary comments and upgraded the code to C++ to make it work with strings instead of char pointers. I also added some extra functionality that didn\u0027t originally come with the implementation \u003cem\u003e(Longest Common Substring, Longest Repeated Substring, Occurence Count, etc.).\u003c/em\u003e I finally wrapped everything into a class and went on to testing.\u003c/p\u003e\u003cp\u003eEverything worked fine and very fast too. I solved a few problems, but then I came across some other ones that couldn\u0027t be solved \u0027cause I realized that the class I had in my hands worked only with one single string. A lot of problems that are solved with Suffix Trees require a different kind of data structure, one that supports working with multiple strings. That data structure, I learned, is called \u003cstrong\u003eGeneralized Suffix Tree\u003c/strong\u003e. This is where the problems began.\u003c/p\u003e\u003ch2\u003eGeneralized Suffix Tree:\u003c/h2\u003e\u003cp\u003eI searched online about it, but all the papers and articles I found built it by adding a different delimiter character for each word. The problem with this implementation is that you can work with a very small number of words. A lot of problems give you 500, 100 or even \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e\u003c/span\u003e strings. There aren\u0027t that many characters.\u003c/p\u003e\u003cp\u003eMy idea was to use a single delimiter character for every word, but then do a DFS and count how many delimiters I pass along the way. When I reach a leaf, I know what word this suffix belongs to by the amount of delimiters I passed.\u003c/p\u003e\u003cp\u003eSo the problem boils down to this: \u003cstrong\u003eWe have a tree with numbers written on the leaves. How do we efficiently compute for every inner node how many different numbers are written on the leaves in its subtree?\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eMy workaround (the best idea that crossed my mind) was to do a DFS and maintain a set for each node with the numbers I found on its subtree. By merging smaller sets into bigger ones and upgrading pointers instead of moving everything from one place to another, I was able to achieve something in the lines of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003elog\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/sub\u003e\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e, but the problem is that \u003cem\u003eSuffix Array + LCP + Range Query\u003c/em\u003e ends up being faster than this Generalized Suffix Tree. That\u0027s not very nice after all the effort I put into it. But I still have hopes, I think there has to be a better way out there.\u003c/p\u003e\u003ch1\u003eFinal question:\u003c/h1\u003e\u003cp\u003e\u003cstrong\u003eHow do you guys implement a Generalized Suffix Tree and how do you efficiently compute for every inner node, how many words this suffix belongs to?\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThanks very much in advance.\u003c/p\u003e\u003c/div\u003e","tags":["#trees","string suffix structures","suffix tree","data structures"]}}