{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1508137248,"rating":7,"authorHandle":"coding_is_fun","modificationTimeSeconds":1508137248,"id":55217,"title":"\u003cp\u003eCounting Triplets \u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI found a similar type of problem as last csacademy problem \u003ca href\u003d\"https://csacademy.com/contest/archive/task/sum-triplets/\"\u003eSum of Triplets\u003c/a\u003e but slightly different : \u003c/p\u003e\u003cp\u003eHere they said find triplets such as A[i] + A[j] \u003d A[k] where i\u0026lt;j\u0026lt;k . \u003cstrong\u003e1 \u0026lt;\u003d Array size is \u0026lt;\u003d 10^5\u003c/strong\u003e . \u003cstrong\u003e1 \u0026lt;\u003d Array values \u0026lt; 2^16\u003c/strong\u003e .\u003c/p\u003e\u003cp\u003eTime limit : 12 second .\u003c/p\u003e\u003cp\u003eproblem link : \u003ca href\u003d\"https://toph.co/p/counting-triplets\"\u003ehttps://toph.co/p/counting-triplets\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eHow to solve this problem without n^2 loop ? I am getting TLE .\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMy solution\u003c/strong\u003e :\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehere\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\u003c/p\u003e\u003cp\u003eusing namespace std;\u003c/p\u003e\u003cp\u003eint tc,n,ar[123456],i,j,k,cas;\u003c/p\u003e\u003cp\u003eint main()\u003c/p\u003e\u003cp\u003e{\u003c/p\u003e \u003cpre\u003ecin\u0026gt;\u0026gt;tc;\n\n for(cas\u003d1; cas\u0026lt;\u003dtc; cas++)\n {\n\n    unordered_map\u0026lt;int,int\u0026gt; mxindex;\n\n    scanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\n\n    for(i\u003d1; i\u0026lt;\u003dn; i++)\n        scanf(\u0026quot;%d\u0026quot;,\u0026amp;ar[i]);\n\n    for(j\u003dn; j\u0026gt;\u003d1; j--)\n        if(mxindex.count(ar[j])\u003d\u003d0)\n            mxindex[ar[j]]\u003dj;\n\n    long long ans\u003d0;\n\n    for(i\u003d1; i\u0026lt;\u003dn; i++)\n        for(int j\u003di+1; j\u0026lt;\u003dn; j++)\n            if(mxindex.count(ar[i]+ar[j]))\n            {\n                if(j+1\u0026lt;\u003dmxindex[ar[i]+ar[j]])\n                    ans++;\n            }\n\n    cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0027\\n\u0027;\n\n }\n\n\nreturn 0;\u003c/pre\u003e\u003cp\u003e}\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eSince they said \u0026quot;A[i] + A[j] \u003d A[k] where i\u0026lt;j\u0026lt;k \u0026quot; so i can not sort the data . I have to work as the given input . \u003c/p\u003e\u003cp\u003eAt first I declare a map\u0026lt;int,int\u0026gt; mxIndex ; Then i store the maximum index of each data in this map .\u003c/p\u003e\u003cp\u003eThen I run a n^2 loop for every A[i] + A[j] , i search this sum in map . If found then i check the maximum index of A[i] + A[j] . If that index \u0026gt;\u003d j+1 . That means found a triplet i \u0026lt; j \u0026lt; k so , ans++ . \u003cstrong\u003eI know i will get WA . But i am getting TLE for n^2 loop\u003c/strong\u003e . How can i do it efficiently ?\u003c/p\u003e\u003c/div\u003e","tags":["time limit exceeded","help"]}}