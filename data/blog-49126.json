{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1481953545,"rating":88,"authorHandle":"lewin","modificationTimeSeconds":1482039165,"id":49126,"title":"\u003cp\u003eCodeforces Round #385 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eShort solutions:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eDiv2A: How many times do we need to do a cyclic shift to consider all possible ones? Afterwards, what data structure allows us to easily check number of distinct elements?\u003c/li\u003e   \u003cli\u003eDiv2B: Imagine the process in reverse. What types of identical shapes can I get if I cut a rectangle into two pieces? Remember, pieces cannot be rotated or flipped.\u003c/li\u003e   \u003cli\u003eDiv2C / Div1A: How do we handle components with special nodes? What do we do with the ones without special nodes?\u003c/li\u003e   \u003cli\u003eDiv2D / Div1B: We don\u0027t get many questions, so is there a way to \u0026quot;parallelize\u0026quot; questions? Another approach, can we split up the condition i !\u003d j somehow using bits?\u003c/li\u003e   \u003cli\u003eDiv2E / Div1C: First, somehow reduce it so r_i,b_i \u0026lt;\u003d n. Now, we can bound the excess tokens by a small number, so we can do bitmask dp from here.\u003c/li\u003e   \u003cli\u003eDiv1D: The optimal circle must touch a blue point. Now, either consider the inversion, or do a binary search\u003c/li\u003e   \u003cli\u003eDiv1E: What makes a list good? How fast can we do this check, and how many times do we need to do this check?\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eLong solutions:\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/745/problem/A\"\u003eHongcow Learns the Cyclic Shift\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eWe only need to consider at most |s| cyclic shifts (since |s| cyclic shifts returns us back to the original string).\u003c/p\u003e\u003cp\u003eSo, we can put these all in a set, and return the size of the set.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eprint (lambda s: len(set(s[i:] + s[:i] for i in range(len(s)))))(raw_input())\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/745/problem/B\"\u003eHongcow Solves A Puzzle\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eI really apologize for the ambiguity of this problem. We worked hard to make it concise and accurate, but we left out too many details.\u003c/p\u003e\u003cp\u003eBasically, the idea is we want to overlay two of these pieces together so that no square has more than 1 X, and the region of X\u0027s forms a rectangle.\u003c/p\u003e\u003cp\u003eNow for the solution:\u003c/p\u003e\u003cp\u003eFirst, let\u0027s look at it backwards. I have a rectangle, and I cut it in two pieces. These two pieces have the same exact shape. What shapes can I form?\u003c/p\u003e\u003cp\u003eA necessary and sufficient condition is that the piece itself is a rectangle itself! There are a few ways to check this. One is, find the min/max x/y coordinates, and make sure the number of X\u0027s match the bounding box of all the points.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003en,m \u003d map(int, raw_input().split())\npiece \u003d [raw_input().rstrip() for i in range(n)]\n\nmaxx, minx, maxy, miny \u003d -1, n, -1, m\ncount \u003d 0\nfor i in range(n):\n\tfor j in range(m):\n\t\tif piece[i][j] \u003d\u003d \u0027X\u0027:\n\t\t\tmaxx \u003d max(maxx, i)\n\t\t\tminx \u003d min(minx, i)\n\t\t\tmaxy \u003d max(maxy, j)\n\t\t\tminy \u003d min(miny, j)\n\t\t\tcount +\u003d 1\n\n\nprint ((maxx - minx + 1) * (maxy - miny + 1) \u003d\u003d count) * \u0026quot;YES\u0026quot; or \u0026quot;NO\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/744/problem/A\"\u003eHongcow Builds a Nation\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eFirst, let\u0027s make all connected components cliques. This graph is still stable.\u003c/p\u003e\u003cp\u003eNow, there are some components without special nodes. Where should we connect them?\u003c/p\u003e\u003cp\u003eIf there is a component with size A and a component with size B, we can add A*B edges if we connect these two components. So, it makes sense to choose the largest component.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003en,m,k \u003d map(int, raw_input().split())\nspecial \u003d map(int, raw_input().split())\n\nroot \u003d range(n+1)\n\ndef par(p):\n\tif p !\u003d root[p]:\n\t\troot[p] \u003d par(root[p])\n\treturn root[p]\n\ndef c2(n):\n\treturn n * (n - 1) / 2\n\nfor __ in xrange(m):\n\tu,v \u003d map(par, map(int, raw_input().split()))\n\troot[v] \u003d u\n\nsz \u003d [0 for i in range(n+1)]\nfor i in range(n+1):\n\tsz[par(i)] +\u003d 1\n\nleftover \u003d n\nans \u003d 0\nlargest \u003d 0\nfor x in special:\n\td \u003d par(x)\n\tlargest \u003d max(largest, sz[d])\n\tans +\u003d c2(sz[d])\n\tleftover -\u003d sz[d]\n\nans -\u003d c2(largest)\nans +\u003d c2(largest + leftover)\nans -\u003d m\n\nprint ans\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/744/problem/B\"\u003eHongcow\u0027s Game\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eFor the bits solution: We want to create 20 questions where for every i !\u003d j, there exists a question\u003c/p\u003e\u003cp\u003ethat contains j and not i, and also a qusetion that contains i and not j. If we can do this, we can find the min for each row.\u003c/p\u003e\u003cp\u003eNote that i !\u003d j implies that there exists a bit index where i and j differ.\u003c/p\u003e\u003cp\u003eSo, let\u0027s ask 2 questions for each bit position, one where all indices have a value of 0 in that position, and one where all indices have a value of 1 in that position. This is a total of at most 20 questions, and we can show that this satisfies the condition above, so this solves the problem.\u003c/p\u003e\u003cp\u003eParallelization will basically reduce to the above solution, but is another way of looking at the problem.\u003c/p\u003e\u003cp\u003eFirst, let\u0027s ask {1,2,...,n/2} and {n/2+1,...,n} This handles the case where the min lies on the opposite half.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e[\nOOOOXXXX\nOOOOXXXX\nOOOOXXXX\nOOOOXXXX\nXXXXOOOO\nXXXXOOOO\nXXXXOOOO\nXXXXOOOO\n]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFor example, this handles the case where the min lies in the X part of the matrix, and we split it into two identical problems of size n/2 within the O matrix.\u003c/p\u003e\u003cp\u003eNow, we can ask questions for each submatrix, but we can notice that these two don\u0027t interact so we can combine all the questions at this level.\u003c/p\u003e\u003cp\u003eHowever, we should ask the questions in parallel, as we don\u0027t have that many questions For example, for n\u003d8, we should ask\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eFirst level:\n[1,2,3,4]\n[5,6,7,8]\n\nSecond level\n[1,2],[5,6] (i.e. ask 1,2,5,6 all together, but this is actually two different subproblems, one for the top left, and one for the bottom right).\n[3,4],[7,8]\n\nThird level\n[1],[3],[5],[7]\n[2],[4],[6],[8]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs you can see, this reduces to the bit approach above if N is a power of 2.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class HiddenMatrix {\n    public static void main (String[] args) {\n        Scanner in \u003d new Scanner(System.in);\n        PrintWriter out \u003d new PrintWriter(System.out);\n        int n \u003d in.nextInt();\n        int[] min \u003d new int[n+1];\n        Arrays.fill(min, 1 \u0026lt;\u0026lt; 30);\n        for (int bit \u003d 0; bit \u0026lt; 10; bit++) {\n            for (int val \u003d 0; val \u0026lt;\u003d 1; val++) {\n                ArrayList\u0026lt;Integer\u0026gt; query \u003d new ArrayList\u0026lt;\u0026gt;();\n                for (int i \u003d 1; i \u0026lt;\u003d n; i++) {\n                    if (((i \u0026gt;\u0026gt; bit) \u0026amp; 1) \u003d\u003d val) {\n                        query.add(i);\n                    }\n                }\n                if (query.size() !\u003d n \u0026amp;\u0026amp; query.size() !\u003d 0) {\n                    out.println(query.size());\n                    for (int j \u003d 0; j \u0026lt; query.size(); j++) {\n                        if (j !\u003d 0) out.print(\u0026quot; \u0026quot;);\n                        out.print(query.get(j));\n                    }\n                    out.println();\n                    out.flush();\n\n                    for (int i \u003d 1; i \u0026lt;\u003d n; i++) {\n                        int d \u003d in.nextInt();\n                        if (((i \u0026gt;\u0026gt; bit) \u0026amp; 1) \u003d\u003d 1 - val) {\n                            min[i] \u003d Math.min(min[i], d);\n                        }\n                    }\n                }\n            }\n        }\n\n        out.println(-1);\n        for (int i \u003d 1; i \u0026lt;\u003d n; i++) {\n            if (i !\u003d 1) out.print(\u0026quot; \u0026quot;);\n            out.print(min[i]);\n        }\n        out.println();\n        out.flush();\n        System.exit(0);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/744/problem/C\"\u003eHongcow Buys a Deck of Cards\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAlso note that if r_i or b_i \u0026gt;\u003d n, we need to collect tokens no matter what since those costs can\u0027t be offset. So, we can assume that r_i, b_i \u0026lt;\u003d n.\u003c/p\u003e\u003cp\u003eLet\u0027s only buy tokens when we need them. Note that after buying a card, you will have either 0 red tokens or 0 blue tokens, so our dp state can be described by [mask][which one is zero][how many of the other] The dimensions of this dp table are 2^n * 2 * (n^2) (n^2 because the costs to buy cards is at most n).\u003c/p\u003e\u003cp\u003eSee the code for more details on how to update this dp.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class RedAndBlueCards {\n    public static int n;\n    public static char[] color;\n    public static int[] r,b;\n    public static int[] countred, countblue;\n    public static void main (String[] args) {\n        Scanner in \u003d new Scanner(System.in);\n        n \u003d in.nextInt();\n        color \u003d new char[n];\n        r \u003d new int[n];\n        b \u003d new int[n];\n        int base \u003d 0;\n        int needred \u003d 0, needblue \u003d 0;\n        for (int i \u003d 0; i \u0026lt; n; i++) {\n            color[i] \u003d in.next().charAt(0);\n            r[i] \u003d in.nextInt();\n            b[i] \u003d in.nextInt();\n            needred +\u003d Math.max(0, r[i] - n);\n            needblue +\u003d Math.max(0, b[i] - n);\n            r[i] \u003d Math.min(n, r[i]);\n            b[i] \u003d Math.min(n, b[i]);\n        }\n        base \u003d Math.max(needred, needblue);\n\n        countred \u003d new int[1\u0026lt;\u0026lt;n];\n        countblue \u003d new int[1\u0026lt;\u0026lt;n];\n        for (int i \u003d 1; i \u0026lt; 1 \u0026lt;\u0026lt; n; i++) {\n            int lowbit \u003d Integer.numberOfTrailingZeros(i \u0026amp; -i);\n            countred[i] \u003d countred[i ^ (1 \u0026lt;\u0026lt; lowbit)];\n            countblue[i] \u003d countblue[i ^ (1 \u0026lt;\u0026lt; lowbit)];\n            if (color[lowbit] \u003d\u003d \u0027R\u0027) countred[i]++;\n            else countblue[i]++;\n        }\n\n        dp \u003d new int[2][n*n+1][1\u0026lt;\u0026lt;n];\n        for (int[][] x : dp) for (int[] y : x) Arrays.fill(y, -1);\n\n        int ans \u003d base + n;\n        if (needred \u0026lt; needblue) {\n            ans +\u003d solve(0, 0, needblue - needred);\n        } else {\n            ans +\u003d solve(0, 1, needred - needblue);\n        }\n        System.out.println(ans);\n        System.exit(0);\n    }\n\n    public static int[][][] dp;\n    public static int solve(int mask, int redempty, int other) {\n        other \u003d Math.min(other, n*n);\n        if (mask \u003d\u003d (1\u0026lt;\u0026lt;n)-1) return 0;\n        if (dp[redempty][other][mask] !\u003d -1) return dp[redempty][other][mask];\n        int ret \u003d 1 \u0026lt;\u0026lt; 29;\n        for (int i \u003d 0; i \u0026lt; n; i++) {\n            if (((mask\u0026gt;\u0026gt;i)\u0026amp;1) \u003d\u003d 1) continue;\n            int pmask \u003d mask | (1 \u0026lt;\u0026lt; i);\n            int havered \u003d redempty \u003d\u003d 1 ? 0 : other;\n            int haveblue \u003d redempty \u003d\u003d 0 ? 0 : other;\n            int cardred \u003d countred[mask], cardblue \u003d countblue[mask];\n\n            int nred \u003d Math.max(0, r[i]-(cardred+havered));\n            int nblue \u003d Math.max(0, b[i]-(cardblue+haveblue));\n            int needmoves \u003d Math.max(nred, nblue);\n            int nextred \u003d havered + needmoves - Math.max(0, r[i] - cardred);\n            int nextblue \u003d haveblue + needmoves - Math.max(0, b[i] - cardblue);\n\n            if (nextred \u003d\u003d 0) {\n                ret \u003d Math.min(ret, needmoves + solve(pmask, 1, nextblue));\n            }\n            if (nextblue \u003d\u003d 0) {\n                ret \u003d Math.min(ret, needmoves + solve(pmask, 0, nextred));\n            }\n        }\n        return dp[redempty][other][mask] \u003d ret;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/744/problem/D\"\u003eHongcow Draws a Circle\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eFirst to check if an answer can be arbitrarily large, we can see if there is any red point that is on the convex hull of all our points. So from now on, we can assume the answer is finite.\u003c/p\u003e\u003cp\u003eWe can show that the optimal circle must touch a blue point. To see this, consider any optimal circle that doesn\u0027t touch a blue point. We can make it slightly bigger so that it does touch one.\u003c/p\u003e\u003cp\u003eSo, let\u0027s binary search for the answer. However, you have to very careful and notice that the binary search isn\u0027t monotonic if we only consider circles touching blue points. However, if we consider circles that touch either a red or blue point, then the binary search is monontonic, so everything works out.\u003c/p\u003e\u003cp\u003eTo check if a radius works, we can do a angle sweep around our center point. We have a fixed radius and fixed center, so each other point has at most two angles where it enters and exits the circle as we rotate it about the center point. We can keep track of these events and find an interval where the circle only contains red points.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode for binary search\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class RedAndBluePoints {\n    public static double EPS \u003d 1e-9;\n    public static int PENALTY \u003d 1000000;\n    public static int n,m;\n    public static long[] x, y;\n    public static double[][] d;\n    public static void main (String[] args) {\n        InputReader in \u003d new InputReader(System.in);\n        PrintWriter out \u003d new PrintWriter(System.out, true);\n\n        n \u003d in.nextInt();\n        m \u003d in.nextInt();\n        x \u003d new long[n+m];\n        y \u003d new long[n+m];\n        d \u003d new double[n+m][n+m];\n        Point[] ps \u003d new Point[n+m];\n        for (int i \u003d 0; i \u0026lt; n+m; i++) {\n            x[i] \u003d in.nextInt();\n            y[i] \u003d in.nextInt();\n            ps[i] \u003d new Point(x[i], y[i]);\n        }\n        ps \u003d convexHull(ps);\n        for (int i \u003d 0; i \u0026lt; n; i++) {\n            for (int j \u003d 0; j \u0026lt; ps.length; j++) {\n                if (onSegment(ps[j], ps[(j+1)%ps.length], new Point(x[i],y[i]))) {\n                    out.println(-1);\n                    out.close();\n                    System.exit(0);\n                }\n            }\n        }\n\n\n        for (int i \u003d 0; i \u0026lt; n+m; i++) {\n            for (int j \u003d 0; j \u0026lt; n+m; j++) {\n                d[i][j] \u003d (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);\n            }\n        }\n\n        double lower \u003d 0;\n        for (int startpoint \u003d 0; startpoint \u0026lt; n+m; startpoint++) {\n            if (!ok(startpoint, lower)) continue;\n            double add \u003d 20;\n            int iter \u003d 30;\n            while (ok(startpoint, lower+2*add)) {\n                add *\u003d 2;\n                iter++;\n            }\n            double lo \u003d lower;\n            double hi \u003d lower+2*add;\n            while (hi - lo \u0026gt; 1e-8 \u0026amp;\u0026amp; iter--\u0026gt;0) {\n                double mid \u003d (lo + hi) / 2.0;\n                if (ok(startpoint, mid)) lo \u003d mid;\n                else hi \u003d mid;\n            }\n            lower \u003d lo;\n        }\n        out.printf(\u0026quot;%.10f\\n\u0026quot;, lower);\n    }\n\n    public static boolean ok(int center, double rad) {\n        ArrayList\u0026lt;State\u0026gt; w \u003d new ArrayList\u0026lt;\u0026gt;();\n        int cur \u003d center \u0026lt; n ? 1 : 0;\n        for (int j \u003d 0; j \u0026lt; n+m; j++) {\n            if (j \u003d\u003d center) continue;\n            double reach \u003d 2 * rad;\n            if (reach * reach \u0026lt; d[center][j] + EPS) continue;\n\n            double[] q \u003d getAngles(center, j, rad);\n            int add \u003d j \u0026lt; n ? 1 : -PENALTY;\n            if (q[1] \u0026lt; q[0]) cur +\u003d add;\n            w.add(new State(q[0] - EPS, add));\n            w.add(new State(q[1] + EPS, -add));\n        }\n        Collections.sort(w);\n        int res \u003d cur;\n        for (State s : w) {\n            cur +\u003d s.inc;\n            res \u003d Math.max(res, cur);\n        }\n        return res \u0026gt;\u003d 1;\n    }\n\n    // returns two angles tangent to point i1 and point i2 with radius.\n    public static double[] getAngles(int i1, int i2, double rad) {\n        double D \u003d d[i1][i2];\n        double c \u003d D/2.0;\n        double b \u003d Math.sqrt(D*rad*rad-c*c);\n        double nx \u003d (x[i2] - x[i1]) / D, ny \u003d (y[i2] - y[i1]) / D;\n        double bx \u003d -ny * b, by \u003d nx * b;\n        double ax \u003d nx * c, ay \u003d ny * c;\n\n        return new double[] {\n                Math.atan2(ay - by, ax - bx),\n                Math.atan2(ay + by, ax + bx),\n        };\n    }\n\n    public static class Point {\n        public final long x, y;\n\n        public Point(long x, long y) {\n            this.x \u003d x;\n            this.y \u003d y;\n        }\n    }\n    public static Point[] convexHull(Point[] p) {\n        int n \u003d p.length;\n        if (n \u0026lt;\u003d 1)\n            return p;\n        Arrays.sort(p, (a, b) -\u0026gt; Long.compare(a.x, b.x) !\u003d 0 ? Long.compare(a.x, b.x) : Long.compare(a.y, b.y));\n        Point[] h \u003d new Point[n * 2];\n        int cnt \u003d 0;\n        for (int i \u003d 0; i \u0026lt; n; h[cnt++] \u003d p[i++])\n            while (cnt \u0026gt; 1 \u0026amp;\u0026amp; cross(h[cnt - 2], h[cnt - 1], p[i]) \u0026gt;\u003d 0)\n                --cnt;\n        for (int i \u003d n - 2, t \u003d cnt; i \u0026gt;\u003d 0; h[cnt++] \u003d p[i--])\n            while (cnt \u0026gt; t \u0026amp;\u0026amp; cross(h[cnt - 2], h[cnt - 1], p[i]) \u0026gt;\u003d 0)\n                --cnt;\n        return Arrays.copyOf(h, cnt - 1 - (h[0].x \u003d\u003d h[1].x \u0026amp;\u0026amp; h[0].y \u003d\u003d h[1].y ? 1 : 0));\n    }\n\n    static long cross(Point a, Point b, Point c) {\n        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    }\n\n    public static boolean onSegment(Point a, Point b, Point c) {\n        // does c lie on segment ab\n        return c.x \u0026gt;\u003d Math.min(a.x, b.x) \u0026amp;\u0026amp; c.x \u0026lt;\u003d Math.max(a.x, b.x) \u0026amp;\u0026amp;\n                c.y \u0026gt;\u003d Math.min(a.y, b.y) \u0026amp;\u0026amp; c.y \u0026lt;\u003d Math.max(a.y, b.y) \u0026amp;\u0026amp;\n                (c.x - a.x) * (c.y - b.y) \u003d\u003d (c.x - b.x) * (c.x - a.y);\n    }\n\n\n    static class State implements Comparable\u0026lt;State\u0026gt; {\n        public double angle;\n        public int inc;\n        public State (double angle, int inc) {\n            this.angle \u003d angle;\n            this.inc \u003d inc;\n        }\n\n        public int compareTo(State other) {\n            if (angle \u0026lt; other.angle) return -1;\n            if (angle \u0026gt; other.angle) return 1;\n            return 0;\n        }\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader \u003d new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer \u003d null;\n        }\n\n        public String next() {\n            while (tokenizer \u003d\u003d null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer \u003d new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eFor the inversion solution, let\u0027s fix the blue point that our circle touches. Then, let\u0027s take the inversion around this point (i.e. \u003ca\u003ehttps://en.wikipedia.org/wiki/Inversive_geometry)\u003c/a\u003e. Now, circles that pass through our center points become lines, and the interior of those circles are in the halfplane not containing the center point. The radius of the circle is inversely proportional to the distance between our center point to the line after inversion.\u003c/p\u003e\u003cp\u003eSo, we can say we want to solve the following problem after inversion. Find the closest line that contains no blue points in the halfplane facing away from our center point and at least one red point. We can notice that we only need to check lines that contain a blue point on the convex hull after inversion.\u003c/p\u003e\u003cp\u003eTo make implementation easier, you can make the additional observation that the sum of all convex hull sizes will be linear through the process of the algorithm. Some intuition behind this observation is that only adjacent nodes in a delaunay triangluation can appear on the convex hull after inversion, so the sum is bounded by the number of edges in such a triangulation (of course, we do not need to explicitly find the triangulation).\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode for inversion\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#pragma comment(linker, \u0026quot;/STACK:1000000000\u0026quot;)\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;list\u0026gt;\n#include \u0026lt;deque\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;sstream\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define double long double\n\nconst double pi \u003d acos(-1.0);\nconst double eps1 \u003d 1e-7;\nconst double eps2 \u003d 1e-14;\n\ndouble sqr(double x) {\n    return x * x; \n}\n\nstruct pt {\n\tdouble x, y;\n\n    pt(double x_ \u003d 0.0, double y_ \u003d 0.0) : x(x_), y(y_) {}\n};\n\npt operator + (const pt\u0026amp; a, const pt\u0026amp; b) {\n\treturn pt(a.x + b.x, a.y + b.y);\n}\n\npt operator - (const pt\u0026amp; a, const pt\u0026amp; b) {\n\treturn pt(a.x - b.x, a.y - b.y);\n}\n\npt operator * (const pt\u0026amp; a, double k) {\n\treturn pt(a.x * k, a.y * k);\n}\n\nstruct line {\n\tdouble a, b, c;\n\tline(double a_ \u003d 1.0, double b_ \u003d 0.0, double c_ \u003d 0.0): a(a_), b(b_), c(c_) {\n\t\tnorm();\n    }\n\n\tline(const pt\u0026amp; p1, const pt\u0026amp; p2) {\n\t\ta \u003d p2.y - p1.y;\n\t\tb \u003d p1.x - p2.x;\n\t\tc \u003d -a * p1.x - b * p1.y;\n\n\t\tnorm();\n\t}\n\n\tvoid norm() {\n\t\tdouble k \u003d sqrt(sqr(a) + sqr(b));\n\t\ta /\u003d k;\n\t\tb /\u003d k;\n\t\tc /\u003d k;\n\t}\n\n\tdouble dist(const pt\u0026amp; p) const {\n\t\treturn a * p.x + b * p.y + c;\n\t}\n};\nbool cmp (pt a, pt b) {\n\treturn (a.x \u0026lt; b.x) || (a.x \u003d\u003d b.x \u0026amp;\u0026amp; a.y \u0026lt; b.y);\n}\n\nbool cw (pt a, pt b, pt c) {\n\treturn a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y) \u0026lt; -eps2;\n}\n\nbool ccw (pt a, pt b, pt c) {\n\treturn a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y) \u0026gt; eps2;\n}\n\nvoid convex_hull (vector\u0026lt;pt\u0026gt; \u0026amp; a) {\n\tif (a.size() \u003d\u003d 1)  return;\n    if (a.size() \u003d\u003d 2) return;\n\tsort (a.begin(), a.end(), \u0026amp;cmp);\n\tpt p1 \u003d a[0],  p2 \u003d a.back();\n\tvector\u0026lt;pt\u0026gt; up, down;\n\tup.push_back (p1);\n\tdown.push_back (p1);\n\tfor (size_t i\u003d1; i\u0026lt;a.size(); ++i) {\n\t\tif (i\u003d\u003da.size()-1 || cw (p1, a[i], p2)) {\n\t\t\twhile (up.size()\u0026gt;\u003d2 \u0026amp;\u0026amp; !cw (up[up.size()-2], up[up.size()-1], a[i]))\n\t\t\t\tup.pop_back();\n\t\t\tup.push_back (a[i]);\n\t\t}\n\t\tif (i\u003d\u003da.size()-1 || ccw (p1, a[i], p2)) {\n\t\t\twhile (down.size()\u0026gt;\u003d2 \u0026amp;\u0026amp; !ccw (down[down.size()-2], down[down.size()-1], a[i]))\n\t\t\t\tdown.pop_back();\n\t\t\tdown.push_back (a[i]);\n\t\t}\n\t}\n\ta.clear();\n\tfor (size_t i\u003d0; i\u0026lt;up.size(); ++i)\n\t\ta.push_back (up[i]);\n\tfor (size_t i\u003ddown.size()-2; i\u0026gt;0; --i)\n\t\ta.push_back (down[i]);\n}\n\nint sign(double x) {\n    if (fabs(x) \u0026lt; eps2)\n        return 0;\n    if (x \u0026gt; 0)\n        return 1;\n    return -1;\n}\n\nint main() {\n    //freopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n    //freopen(\u0026quot;output.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n    int n, m;\n\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\n    vector \u0026lt;pt\u0026gt; red(n), blue(m);\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        cin \u0026gt;\u0026gt; red[i].x \u0026gt;\u0026gt; red[i].y;\n    }\n\n    for (int i \u003d 0; i \u0026lt; m; i++) {\n        cin \u0026gt;\u0026gt; blue[i].x \u0026gt;\u0026gt; blue[i].y;\n    }\n\n    if (m \u003d\u003d 1) {\n        cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl;\n        return 0;\n    }\n    vector \u0026lt;pt\u0026gt; cvx_blue \u003d blue;\n    convex_hull(cvx_blue);\n    int k \u003d cvx_blue.size();\n        \n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        bool flag \u003d true;\n        for (int j \u003d 0; j \u0026lt; k; j++) {\n            line hl(cvx_blue[j % k], cvx_blue[(j + 1) % k]);\n            if (hl.dist(red[i]) \u0026gt; eps1) {\n               flag \u003d false;    \n            }\n        }\n\n        if (flag) { \n            cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl;\n    \n            return 0;\n        }\n\n    }\n\n\n    double ans \u003d 0.0;\n\n    for (int i \u003d 0; i \u0026lt; m; i++) {\n        vector \u0026lt;pt\u0026gt; new_blue;\n        for (int j \u003d 0; j \u0026lt; i; j++) {\n            new_blue.pb(blue[j] - blue[i]);\n            double d \u003d sqr(new_blue.back().x) + sqr(new_blue.back().y);\n            new_blue.back().x /\u003d d;\n            new_blue.back().y /\u003d d;\n        }\n\n        new_blue.pb(pt(0.0, 0.0));\n\n        for (int j \u003d i + 1; j \u0026lt; m; j++) {\n            new_blue.pb(blue[j] - blue[i]);\n            double d \u003d sqr(new_blue.back().x) + sqr(new_blue.back().y);\n            new_blue.back().x /\u003d d;\n            new_blue.back().y /\u003d d;\n        }\n\n        vector \u0026lt;pt\u0026gt; new_red;\n        for (int j \u003d 0; j \u0026lt; n; j++) {\n            new_red.pb(red[j] - blue[i]);\n            double d \u003d sqr(new_red.back().x) + sqr(new_red.back().y);\n            new_red.back().x /\u003d d;\n            new_red.back().y /\u003d d;        \n        }\n\n        convex_hull(new_blue);\n\n        int k \u003d new_blue.size();\n        int p \u003d new_red.size();\n\n        for (int j \u003d 0; j \u0026lt; k; j++) {\n            bool flag \u003d false;\n            line hl(new_blue[j], new_blue[(j + 1) % k]);\n           \n            for (int q \u003d 0; q \u0026lt; p; q++) {\n                if (hl.dist(new_red[q]) \u0026lt; eps2)\n                    flag \u003d true;            \n            }            \n\n            if (flag) {\n                if (abs(hl.dist(pt(0.0, 0.0))) \u0026lt; eps2) {\n                    cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl;\n                    \n                    return 0;\n                }\n    //            cerr \u0026lt;\u0026lt; hl.dist(pt(0.0, 0.0)) \u0026lt;\u0026lt; endl;\n                /*\n                if (fabs(hl.dist(pt(0.0, 0.0))) \u0026lt; eps) {\n                    cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl;\n                    return 0;\n                }\n                */\n                ans \u003d max(ans, 1.0 / abs(hl.dist(pt(0.0, 0.0))));\n            }\n        }\n\n        for (int q \u003d 0; q \u0026lt; p; q++) {\n            for (int j \u003d 0; j \u0026lt; k; j++) {\n                line hl(new_red[q], new_blue[j]);\n                if (sign(hl.dist(new_blue[(j + 1) % k])) * sign(hl.dist(new_blue[(j + k - 1) % k])) \u0026gt;\u003d 0) {\n                    if (abs(hl.dist(pt(0.0, 0.0))) \u0026lt; eps2) {\n                        cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl;\n                \n                        return 0;\n                    }\n\n  //                  cerr \u0026lt;\u0026lt; hl.dist(pt(0.0, 0.0)) \u0026lt;\u0026lt; endl;\n                    ans \u003d max(ans, 1.0 / abs(hl.dist(pt(0.0, 0.0))));\n                }\n            }\n        }\n    }\n\n    cout.precision(20);\n    cout \u0026lt;\u0026lt; ans / 2.0 \u0026lt;\u0026lt; endl; \n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/744/problem/E\"\u003eHongcow Masters the Cyclic Shift\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLet M denote the total number of characters across all strings. \u003c/p\u003e\u003cp\u003eConsider how long it takes to compute f(L) for a single list.\u003c/p\u003e\u003cp\u003eConsider a graph where nodes are suffixes of strings. This means we already spelled out the prefix, and still need to spell out the suffix.\u003c/p\u003e\u003cp\u003eThere are at most M nodes in this graph. Now, draw at most N edges connecting suffixes to each other. We can find the edges efficiently by doing suffix arrays or z algorithm or hashes.\u003c/p\u003e\u003cp\u003eNow, we claim is the list is good if and only if there is no cycle in this graph. You can notice that a cycle exists \u003d\u0026gt; we can construct a bad word. Also, if a bad word exists \u003d\u0026gt; we can form a cycle. So, we can check if there is a cycle, which takes O(N*M) time.\u003c/p\u003e\u003cp\u003eNext step is to notice that extending a bad list will never make it good. So we can do two pointers to find all good intervals, which requires O(n) calls to the check function. So, overall this runs in O(N^2*M) time.\u003c/p\u003e\u003cp\u003eYou might be wondering why this problem asks for sublists rather than the entire list. To be honest, it\u0027s just to make tests slightly stronger (i.e. I get ~30^2x the number of tests in the same amount of space).\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class CyclicShiftsAgainAgain {\n    public static int n;\n    public static String[] s;\n    public static int[] len;\n    public static void main (String[] args) {\n        InputReader in \u003d new InputReader(System.in);\n        PrintWriter out \u003d new PrintWriter(System.out, true);\n        n \u003d in.nextInt();\n        s \u003d new String[n+1];\n        len \u003d new int[n+1];\n        s[0] \u003d \u0026quot;\u0026quot;;\n        len[0] \u003d 0;\n        for (int i \u003d 1; i \u0026lt;\u003d n; i++) {\n            s[i] \u003d in.next();\n            len[i] \u003d len[i-1] + s[i].length();\n        }\n\n        int ans \u003d 0;\n        int front \u003d 0;\n        for (int i \u003d 1; i \u0026lt;\u003d n; i++) {\n            while (!isGood(front+1, i)) front++;\n            ans +\u003d i - front;\n        }\n\n        out.println(ans);\n        out.close();\n        System.exit(0);\n    }\n\n    public static boolean isGood(int from, int to) {\n        if (from \u0026gt; to) return true;\n        int numnodes \u003d len[to] - len[from - 1];\n        ArrayList\u0026lt;Integer\u0026gt;[] graph \u003d new ArrayList[numnodes+1];\n        for (int i \u003d 0; i \u0026lt;\u003d numnodes; i++) graph[i] \u003d new ArrayList\u0026lt;\u0026gt;();\n        for (int startword \u003d from; startword \u0026lt;\u003d to; startword++) {\n            graph[numnodes].add(len[startword-1] - len[from-1]);\n            StringBuilder sb \u003d new StringBuilder();\n            sb.append(s[startword]);\n            sb.append(\u0026quot;$\u0026quot;);\n            for (int k \u003d from; k \u0026lt;\u003d to; k++) {\n                if (k \u003d\u003d startword) continue;\n                sb.append(s[k]);\n                sb.append(\u0026quot;#\u0026quot;);\n            }\n            int[] z \u003d zz(sb.toString().toCharArray());\n\n            int curchar \u003d 0;\n            for (int i \u003d 1; i \u0026lt; s[startword].length(); i++) {\n                if (z[i] + i \u0026gt;\u003d s[startword].length()) {\n                    graph[i + len[startword-1] - len[from -1]].add(z[i] + len[startword-1] - len[from-1]);\n                }\n            }\n            int curword \u003d startword \u003d\u003d from ? (from+1) : from;\n            for (int i \u003d s[startword].length()+1; i+1 \u0026lt; z.length; i++) {\n                if (sb.charAt(i) \u003d\u003d \u0027#\u0027) {\n                    i++;\n                    curword++;\n                    if (curword \u003d\u003d startword) curword++;\n                    curchar \u003d 0;\n                }\n\n                int curnode \u003d curchar + len[curword-1] - len[from-1];\n                if (z[i] + curchar \u0026gt;\u003d s[curword].length()) {\n                    if (z[i] \u003d\u003d s[startword].length()) {\n                        if (curchar !\u003d 0) graph[curnode].add(numnodes);\n                    } else {\n                        graph[curnode].add(z[i] + len[startword-1] - len[from-1]);\n                    }\n                } else if (z[i] \u003d\u003d s[startword].length()) {\n                    graph[curnode].add(curnode + z[i]);\n                }\n                curchar++;\n            }\n\n        }\n        return isDAG(graph);\n    }\n\n    public static int[] zz(char[] let) {\n        int N \u003d let.length;\n        int[] z \u003d new int[N];\n        int L \u003d 0, R \u003d 0;\n        for (int i \u003d 1; i \u0026lt; N; i++) {\n            if (i \u0026gt; R) {\n                L \u003d R \u003d i;\n                while (R \u0026lt; N \u0026amp;\u0026amp; let[R - L] \u003d\u003d let[R])\n                    R++;\n                z[i] \u003d R - L;\n                R--;\n            } else {\n                int k \u003d i - L;\n                if (z[k] \u0026lt; R - i + 1)\n                    z[i] \u003d z[k];\n                else {\n                    L \u003d i;\n                    while (R \u0026lt; N \u0026amp;\u0026amp; let[R - L] \u003d\u003d let[R])\n                        R++;\n                    z[i] \u003d R - L;\n                    R--;\n                }\n            }\n        }\n        z[0] \u003d N;\n        return z;\n    }\n\n    private static boolean isDAG(ArrayList\u0026lt;Integer\u0026gt;[] graph) {\n        int n \u003d graph.length;\n        int[] indeg \u003d new int[n];\n        for (int i \u003d 0; i \u0026lt; n; i++) for (int x : graph[i]) indeg[x]++;\n        int[] queue \u003d new int[n];\n        int front \u003d 0, back \u003d 0, idx \u003d 0;\n\n        for (int i \u003d 0; i \u0026lt; indeg.length; i++)\n            if (indeg[i] \u003d\u003d 0)\n                queue[back++] \u003d i;\n\n        while (front !\u003d back) {\n            int node \u003d queue[front++];\n            for (int next : graph[node]) {\n                if (--indeg[next] \u003d\u003d 0) {\n                    queue[back++] \u003d next;\n                }\n            }\n        }\n\n        return front \u003d\u003d n;\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader \u003d new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer \u003d null;\n        }\n\n        public String next() {\n            while (tokenizer \u003d\u003d null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer \u003d new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}