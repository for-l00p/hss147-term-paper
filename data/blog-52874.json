{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1498315131,"rating":0,"authorHandle":"just_solve_it","modificationTimeSeconds":1498320348,"id":52874,"title":"\u003cp\u003eЧто нам стоит дом построить (Декартово дерево)\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eТут я расскажу немного о такой структуре данных как Декартово Дерево. Как водится, с примерами кода и обоснованием того что это и зачем. Начнём, пожалуй, с самого начала:\u003c/p\u003e\u003ch1\u003eДекартово дерево\u003c/h1\u003e\u003cp\u003eЗадача, которую мы будем пытаться решать состоит в том, чтобы каким-нибудь грамотным образом строить бинарное дерево поиска (или что-то вроде) с не очень большой глубиной (читай сбалансированное бинарное дерево). Основной идеей поддержания оптимальной глубины нашего дерева в том, что оно будет дополнительно кучей. \u003c/p\u003e\u003cp\u003eДекартовым деревом (дуча \u003d (дерево + куча) или дирамида \u003d (дерево + пирамида)) будем называть бинарное дерево, в вершинах которого находятся пары (ключ, приоритет) такие, что если рассматривать только ключи, то перед нами бинарное дерево поиска, а если только приоритеты, то куча.\u003c/p\u003e\u003ch3\u003eЛемма\u003c/h3\u003e\u003cp\u003eДуча по данным парам (ключ, приоритет) единственна (в предположении, что все приоритеты различны).\u003c/p\u003e\u003ch3\u003eДоказательство\u003c/h3\u003e\u003cp\u003eБудем доказывать это по индукции по количеству вершин в дуче. Сперва отметим, что утверждение про бучи с одной или нулем вершин очевидны. Пусть мы теперь умеем показывать это при всех значениях количества меньших \u003ccode\u003en\u003c/code\u003e, докажем теперь и для \u003ccode\u003en\u003c/code\u003e:\u003c/p\u003e\u003cp\u003eВо первых, заметим, что вершина с наименьшим приоритетом обязана быть корнем. Далее, все вершины с меньшим ключом лежат в левом поддереве, а с большим — в правом. Таким образом, по предположению индукции, как левое, так и правое дерево восстанавливаются однозначно. Лемма доказана.\u003c/p\u003e\u003ch1\u003eОперации\u003c/h1\u003e\u003cp\u003eОсновными операциями в дуче являются \u003ccode\u003eSplit\u003c/code\u003e и \u003ccode\u003eMerge\u003c/code\u003e. Давайте разберемся с тем как они работают и что из себя представляют. Для начала условимся, что ключи имеют тип \u003ccode\u003eKey\u003c/code\u003e, а приоритеты — \u003ccode\u003ePriority\u003c/code\u003e, а также, что их можно сравнивать простым \u003ccode\u003e\u0026lt;\u003c/code\u003e. Таким образом, будем предполагать, что наши вершины хранят:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estruct Node {\n  Key key;\n  Priority priority;\n  Node left, right;\n};\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eSplit\u003c/h2\u003e\u003cp\u003eОперация \u003ccode\u003eSplit\u003c/code\u003e разделяет дучу на две такие, что в первой все ключи меньше данного, а во второй — больше, если ключ совпадает с данным, предлагается его просто убирать. Это можно сделать довольно легко рекурсивно — если ключ по которому мы хотим разделить находится в левом поддереве, то дуча в которой ключи меньше тоже является его частью, а значит мы можем сперва разделить по этому ключу левое поддерево, а потом на текующую вершину подвесить правую часть разбиения, это очевидно, и приведет нас к желаемому. Внимание, псевдокод:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e(Node, Node) Split(Node node, Key key) {\n  if node \u003d\u003d nullptr {\n    return (nullptr, nullptr)\n  }\n  \n  if key \u0026lt; node.key {\n    (left, pre_right) \u003d Split(node.left, key)\n    node.left \u003d pre_right\n    return (left, node)\n  }\n\n  if key \u0026gt; node.key {\n    (pre_left, right) \u003d Split(node.right, key)\n    node.right \u003d pre_left\n    return (node, pre_right)\n  }\n\n  if key \u003d\u003d node.key {\n    return (node.left, node.right)\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eMerge\u003c/h2\u003e\u003cp\u003eОперация \u003ccode\u003eMerge\u003c/code\u003e сливает две дучи в предположении что все элементы левой дучи меньше всех элементов правой. Тут нам пригождается условие на кучу: если у левой вершины (корень левого поддерева) приоритет меньше, чем у правой, то она является корнем, а вместо ее правого сына мы должны ей подвесить объединение этого правого сына и правого поддерева. В остальных случаях аналогично. Внимание, псевдокод:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eNode Merge(Node left, Node right) {\n  if left \u003d\u003d nullptr { return right }\n  if right \u003d\u003d nullptr { return left }\n\n  if left.priority \u0026lt; right.priority {\n    left.right \u003d Merge(left.right, right)\n    return left\n  } else {\n    right.left \u003d Merge(left, right.left)\n    return right\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКазалось бы — классные операции и конкурсы интересные, но зачем это всё? Оказывается, этого достаточно, чтобы лешим движением руки превратить это в невероятно мощную структуру данных. Перейдем к примерам.\u003c/p\u003e\u003ch1\u003eПримеры\u003c/h1\u003e\u003cp\u003eИсходя из леммы и здравого смысла, нетрудно заключить, что если мы будем предоставлять пользователю доступ и к ключам и к приоритетам, то он может сам себе все сломать и добиться огромной глубины. Это не есть хорошо, поэтому либо то, либо другое будет деталями реализации. Давайте для начала реализуем аналог \u003ccode\u003estd::set\u003c/code\u003e делая приоритеты случайными.\u003c/p\u003e\u003ch2\u003eSet\u003c/h2\u003e\u003cp\u003eТут, к сожалению, или к счастью, будет код на C++, а не псевдокод, но вас это смутить не должно. Для начала, в каждой вершине будут храниться данные о элементе, приоритет (который будет задаваться при инициализации) и указатели на левую и правую вершины:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eВершина\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003estruct Node {\n  Value data;\n  const int priority;\n  std::unique_ptr\u0026lt;Node\u0026gt; left, right;\n  Node(Value data) : data(data), priority(rand()) {}\n};\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eДалее, нам нужны прототипы операций \u003ccode\u003eSplit\u003c/code\u003e и \u003ccode\u003eMerge\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epair\u0026lt;Node*, Node*\u0026gt; Split(Node* node, const Value\u0026amp; key);\nNode* Merge(Node* left, Node* right);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНу и корень мы будем хранить как указатель на вершину (потому что в случае пустого \u003ccode\u003eSet\u003c/code\u003e нам в \u003ccode\u003ethis-\u0026gt;root\u003c/code\u003e нужно что-то хранить) — \u003ccode\u003estd::unique_ptr\u0026lt;Node\u0026gt; root\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eТеперь давайте поддерживать следующие операции: вставка, удаление, проверка на принадлежность (еще можно было бы добавить \u003ccode\u003elower_bound\u003c/code\u003e), размер и проверку на пустоту. Ну, что уж там:\u003c/p\u003e\u003cp\u003eДля добавления вершины (в случае если её еще нет) нужно разделить дерево по данному ключу, потом создать вершину с данным ключом и объединить всё в нужном порядке:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eInsert\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003evoid Insert(Value data) {\n  if (Contains(data)) { return; }\n\n  Node* node \u003d new Node(data);\n  auto splited \u003d Split(root.release(), data);\n\n  node \u003d Merge(splited.first, node);\n  node \u003d Merge(node, splited.second);\n\n  root.reset(node);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eДля удаления данного ключа (если он присутствует) требуется всего-лишь разделить дерево по нему, а потом слить части обратно — благо при операции \u003ccode\u003eSplit\u003c/code\u003e мы его выкинем:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eErase\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003evoid Erase(Value key) {\n  if (!Contains(key)) {\n    return;\n  }\n\n  auto splited \u003d Split(root.release(), key);\n  root.reset(Merge(splited.first, splited.second));\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eПроверки на принадлежность, пустоту и размер довольно просты и останутся за рамками данного обсуждения. Реализации \u003ccode\u003eSplit\u003c/code\u003e и \u003ccode\u003eMerge\u003c/code\u003e:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSplit\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003estd::pair\u0026lt;Node*, Node*\u0026gt; Split(Node* node, const Value\u0026amp; key) {\n  if (node \u003d\u003d nullptr) {\n    return { nullptr, nullptr };\n  }\n\n  if (compare(key, node-\u0026gt;data)) {\n    auto pre_division \u003d Split(node-\u0026gt;left.release(), key);\n    node-\u0026gt;left.reset(pre_division.second);\n    return { pre_division.first, node };\n  }\n\n  if (compare(node-\u0026gt;data, key)) {\n    auto pre_division \u003d Split(node-\u0026gt;right.release(), key);\n    node-\u0026gt;right.reset(pre_division.first);\n    return { node, pre_division.second };\n  }\n\n  auto answer \u003d std::make_pair(node-\u0026gt;left.release(), node-\u0026gt;right.release());\n  delete node;\n\n  return answer;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eMerge\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eNode* Merge(Node *left, Node *right) {\n  if (left \u003d\u003d nullptr) {\n    return right;\n  }\n\n  if (right \u003d\u003d nullptr) {\n    return left;\n  }\n\n  if (left-\u0026gt;priority \u0026lt; right-\u0026gt;priority) {\n    left-\u0026gt;right.reset(Merge(left-\u0026gt;right.release(), right));\n    return left;\n  } else {\n    right-\u0026gt;left.reset(Merge(left, right-\u0026gt;left.release()));\n    return right;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eВспоминаем, что мы хотим делать много чего, поэтому давайте добавим в шаблон несколько интересной информации вроде типа хранимых значений к компаратора:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eИнтерфейс\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;functional\u0026gt;\n#include \u0026lt;memory\u0026gt;\n#include \u0026lt;utility\u0026gt;\n\nusing std::pair;\n\ntemplate \u0026lt;class Value, class Compare \u003d std::less\u0026lt;Value\u0026gt;\u0026gt;\nclass Set {\n private:\n  struct Node {\n    Node(Value data) : data(data), priority(rand()) {}\n\n    Value data;\n    const int priority;\n    std::unique_ptr\u0026lt;Node\u0026gt; left, right;\n  };\n\n  pair\u0026lt;Node*, Node*\u0026gt; Split(Node* node, const Value\u0026amp; key);\n  Node* Merge(Node* left, Node* right);\n\n  std::unique_ptr\u0026lt;Node\u0026gt; root;\n  Compare compare;\n\n public:\n  Set(Compare cmp \u003d Compare()) : compare(cmp) {}\n\n  void Insert(Value data);\n  void Erase(Value key);\n  bool Contains(const Value\u0026amp; key) const;\n\n  size_t Size() const;\n  bool Empty() const;\n};\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eРеализация\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cbr /\u003etemplate \u0026lt;class Value, class Compare\u0026gt;\nusing SetNode \u003d typename Set\u0026lt;Value, Compare\u0026gt;::Node;\n\ntemplate \u0026lt;class Value, class Compare\u0026gt;\nusing SetNodes \u003d pair\u0026lt;SetNode\u0026lt;Value, Compare\u0026gt;*, SetNode\u0026lt;Value, Compare\u0026gt;*\u0026gt;;\n\ntemplate \u0026lt;class Value, class Compare\u0026gt;\nvoid Set\u0026lt;Value, Compare\u0026gt;::Erase(Value key) {\n  if (!Contains(key)) {\n    return;\n  }\n\n  auto splited \u003d Split(root.release(), key);\n  root.reset(Merge(splited.first, splited.second));\n}\n\ntemplate \u0026lt;class Value, class Compare\u0026gt;\nvoid Set\u0026lt;Value, Compare\u0026gt;::Insert(Value data) {\n  if (Contains(data)) {\n    return;\n  }\n\n  Node* node \u003d new Node(data);\n  auto splited \u003d Split(root.release(), data);\n\n  node \u003d Merge(splited.first, node);\n  node \u003d Merge(node, splited.second);\n\n  root.reset(node);\n}\n\ntemplate \u0026lt;class Value, class Compare\u0026gt;\nbool Set\u0026lt;Value, Compare\u0026gt;::Contains(const Value\u0026amp; key) const {\n  Node* node \u003d root.get();\n\n  while (node !\u003d nullptr) {\n    if (compare(key, node-\u0026gt;data)) {\n      node \u003d node-\u0026gt;left.get();\n      continue;\n    }\n\n    if (compare(node-\u0026gt;data, key)) {\n      node \u003d node-\u0026gt;right.get();\n      continue;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\ntemplate \u0026lt;class Value, class Compare\u0026gt;\nSetNodes\u0026lt;Value, Compare\u0026gt; Set\u0026lt;Value, Compare\u0026gt;::Split(Node* node,\n                                                    const Value\u0026amp; key) {\n  if (node \u003d\u003d nullptr) {\n    return { nullptr, nullptr };\n  }\n\n  if (compare(key, node-\u0026gt;data)) {\n    auto pre_division \u003d Split(node-\u0026gt;left.release(), key);\n    node-\u0026gt;left.reset(pre_division.second);\n    return { pre_division.first, node };\n  }\n\n  if (compare(node-\u0026gt;data, key)) {\n    auto pre_division \u003d Split(node-\u0026gt;right.release(), key);\n    node-\u0026gt;right.reset(pre_division.first);\n    return { node, pre_division.second };\n  }\n\n  auto answer \u003d std::make_pair(node-\u0026gt;left.release(), node-\u0026gt;right.release());\n  delete node;\n\n  return answer;\n}\n\ntemplate \u0026lt;class Value, class Compare\u0026gt;\nSetNode\u0026lt;Value, Compare\u0026gt;* Set\u0026lt;Value, Compare\u0026gt;::Merge(Node *left, Node *right) {\n  if (left \u003d\u003d nullptr) {\n    return right;\n  }\n\n  if (right \u003d\u003d nullptr) {\n    return left;\n  }\n\n  if (left-\u0026gt;priority \u0026lt; right-\u0026gt;priority) {\n    left-\u0026gt;right.reset(Merge(left-\u0026gt;right.release(), right));\n    return left;\n  } else {\n    right-\u0026gt;left.reset(Merge(left, right-\u0026gt;left.release()));\n    return right;\n  }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003eArray\u003c/h2\u003e\u003cp\u003eДавайте теперь реализуем функционал обычного массива, но позже. Нашей целью будет реализация операций: вернуть ссылку на данные по индексу, вставить на позицию элемент, удалить элемент на позиции. В отличие от вектора, у нас это будет работать не за \u003ccode\u003eO(1)\u003c/code\u003e, \u003ccode\u003eO(n)\u003c/code\u003e, \u003ccode\u003eO(n)\u003c/code\u003e соответственно, а за \u003ccode\u003eO(log n)\u003c/code\u003e всё.\u003c/p\u003e\u003cp\u003eЗвучит неплохо, но для этого нам нужно познакомиться с такой структурой данных как Декартово дерево по неявному ключу. Основная идея состоит в том, что ключами мы хотим сделать индексы в массиве, но это сложно — при любом добавлении нам нужно будет во всех последующих вершинах увеличить их на 1, а это уже \u003ccode\u003eO(n)\u003c/code\u003e, Поэтому в каждой вершине мы будем хранить просто размер поддерева в ней. Но, спрашивается, и что дальше? \u003c/p\u003e\u003cp\u003eА дальше нужно понять, что все операции, которые мы обсуждали ранее (аж \u003ccode\u003eSplit\u003c/code\u003e и \u003ccode\u003eMerge\u003c/code\u003e) проводятся точно так же. Но начнем мы с того, что же мы будем хранить в вешрине. Как и ранее, нам нужно сохранить приоритет и значение. По сколько ключ неявный, то мы будем хранить размер всего поддерева. Заметим, что этого достаточно — для того, чтобы найти номер корневой вершины в массиве, нам достаточно посмотреть на размер левого поддерева. Все индексы правого поддерева просто больше на некоторую константу (размер левого поддерева + 1) чем если бы мы их вручную считали.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eВершина\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003estruct Node {\n  Value data;\n  size_t size;\n  const int priority;\n\n  std::unique_ptr\u0026lt;Node\u0026gt; left, right;\n  Node(Value data) : data(data), size(1), priority(rand()) {}\n\n  inline size_t LeftSize() const { return (left \u003d\u003d nullptr) ? 0 : left-\u0026gt;size; }\n  inline size_t RightSize() const { return (right \u003d\u003d nullptr) ? 0 : right-\u0026gt;size; }\n};\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ccode\u003eSplit\u003c/code\u003e\u003c/h3\u003e\u003cp\u003eТут мы будем делить не по ключу (он же неявный) а по размерам, то есть \u003ccode\u003eSplit\u003c/code\u003e будет делить наше дерево на два, размеры которых мы будем передавать. В месте передачи, неплохо было бы гарантировать то, что сумма этих размеров совпадает с размером поддерева. \u003c/p\u003e\u003cp\u003eДля того, чтобы разделить дерево на два, нам всего-то нужно понять где должен происходить разрез — слева от вершины, или справа, а потом делить соответствующее поддерево. Одну из частей поддерева нам просто нужно будет переподвесить:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSplit\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003epair\u0026lt;Node*, Node*\u0026gt; Split(Node* node, size_t left, size_t right) {\n  if (left \u003d\u003d 0) {\n    return {nullptr, node};\n  }\n\n  if (right \u003d\u003d 0) {\n    return {node, nullptr};\n  }\n\n  if (node \u003d\u003d nullptr) {\n    return {nullptr, nullptr};\n  }\n\n  size_t left_size \u003d node-\u0026gt;LeftSize();\n  if (left_size \u0026gt;\u003d left) {\n    auto pre_division \u003d Split(node-\u0026gt;left.release(), left, left_size - left);\n    node-\u0026gt;left.reset(pre_division.second);\n    node-\u0026gt;size \u003d node-\u0026gt;LeftSize() + node-\u0026gt;RightSize() + 1;\n    return {pre_division.first, node};\n  }\n\n  size_t right_size \u003d node-\u0026gt;RightSize();\n  if (right_size \u0026gt;\u003d right) {\n    auto pre_division \u003d Split(node-\u0026gt;right.release(), right_size - right, right);\n    node-\u0026gt;right.reset(pre_division.first);\n    node-\u0026gt;size \u003d node-\u0026gt;LeftSize() + node-\u0026gt;RightSize() + 1;\n    return {node, pre_division.second};\n  }\n\n  throw 1;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ccode\u003eMerge\u003c/code\u003e\u003c/h3\u003e\u003cp\u003eТут мы ничем не ограничены, просто как и ранее не забываем про приоритеты и о том, что нужно поддерживать актуальный размер поддерева и дело в шляпе:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eMerge\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eNode* Merge(Node *left, Node *right) {\n  if (left \u003d\u003d nullptr) {\n    return right;\n  }\n\n  if (right \u003d\u003d nullptr) {\n    return left;\n  }\n\n  if (left-\u0026gt;priority \u0026lt; right-\u0026gt;priority) {\n    left-\u0026gt;right.reset(Merge(left-\u0026gt;right.release(), right));\n    left-\u0026gt;size \u003d left-\u0026gt;LeftSize() + left-\u0026gt;RightSize() + 1;\n    return left;\n  } else {\n    right-\u0026gt;left.reset(Merge(left, right-\u0026gt;left.release()));\n    right-\u0026gt;size \u003d right-\u0026gt;LeftSize() + right-\u0026gt;RightSize() + 1;\n    return right;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eОстальные операции (добавление, поиск и удаление) переносятся чуть ли не дословно, за исключением того, что в удалении нам нужно будет разрезать массив на три части, одна из которых размера 1. Последнюю (она будет средней) нужно удалить, а остальные две слить. Итого имеем: \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eИнтерфейс\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;memory\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;utility\u0026gt;\n\nusing std::pair;\n\ntemplate \u0026lt;class Value\u0026gt;\nclass Array {\n private:\n  struct Node {\n    Value data;\n    size_t size;\n    const int priority;\n\n    std::unique_ptr\u0026lt;Node\u0026gt; left, right;\n    Node(Value data) : data(data), size(1), priority(rand()) {}\n\n    inline size_t LeftSize() const { return (left \u003d\u003d nullptr) ? 0 : left-\u0026gt;size; }\n    inline size_t RightSize() const { return (right \u003d\u003d nullptr) ? 0 : right-\u0026gt;size; }\n  };\n\n  pair\u0026lt;Node*, Node*\u0026gt; Split(Node* node, size_t left_size, size_t right_size);\n  Node* Merge(Node* left, Node* right);\n\n  std::unique_ptr\u0026lt;Node\u0026gt; root;\n\n public:\n  void Insert(size_t pos, Value data);\n  void Erase(size_t pos);\n  Value\u0026amp; At(size_t pos);\n\n  size_t Size() const;\n  bool Empty() const;\n};\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eРеализация\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class Value\u0026gt;\nusing Node \u003d typename Array\u0026lt;Value\u0026gt;::Node;\n\ntemplate \u0026lt;class Value\u0026gt;\nusing Nodes \u003d pair\u0026lt;Node\u0026lt;Value\u0026gt;*, Node\u0026lt;Value\u0026gt;*\u0026gt;;\n\ntemplate \u0026lt;class Value\u0026gt;\nValue\u0026amp; Array\u0026lt;Value\u0026gt;::At(size_t pos) {\n  Node* node \u003d root.get();\n\n  while (pos !\u003d node-\u0026gt;LeftSize()) {\n    if (pos \u0026lt; node-\u0026gt;LeftSize()) {\n      node \u003d node-\u0026gt;left.get();\n    } else {\n      pos -\u003d node-\u0026gt;LeftSize() + 1;\n      node \u003d node-\u0026gt;right.get();\n    }\n  }\n\n  return node-\u0026gt;data;\n}\n\ntemplate \u0026lt;class Value\u0026gt;\nvoid Array\u0026lt;Value\u0026gt;::Erase(size_t pos) {\n  size_t all_size \u003d root-\u0026gt;size;\n\n  auto splited_1 \u003d Split(root.release(), pos, all_size - pos);\n  auto splited_2 \u003d Split(splited_1.second, 1, all_size - pos - 1);\n\n  root.reset(Merge(splited_1.first, splited_2.second));\n  delete splited_2.first;\n}\n\ntemplate \u0026lt;class Value\u0026gt;\nvoid Array\u0026lt;Value\u0026gt;::Insert(size_t pos, Value data) {\n  size_t all_size \u003d (root !\u003d nullptr) ? root-\u0026gt;size : 0;\n  auto splited \u003d Split(root.release(), pos, all_size - pos);\n\n  Node* node \u003d new Node(data);\n  node \u003d Merge(splited.first, node);\n  node \u003d Merge(node, splited.second);\n\n  root.reset(node);\n}\n\ntemplate \u0026lt;class Value\u0026gt;\nsize_t Array\u0026lt;Value\u0026gt;::Size() const {\n  return (root !\u003d nullptr) ? root-\u0026gt;size : 0;\n}\n\ntemplate \u0026lt;class Value\u0026gt;\nbool Array\u0026lt;Value\u0026gt;::Empty() const {\n  return root \u003d\u003d nullptr;\n}\n\ntemplate \u0026lt;class Value\u0026gt;\nNode\u0026lt;Value\u0026gt;* Array\u0026lt;Value\u0026gt;::Merge(Node *left, Node *right) {\n  if (left \u003d\u003d nullptr) {\n    return right;\n  }\n\n  if (right \u003d\u003d nullptr) {\n    return left;\n  }\n\n  if (left-\u0026gt;priority \u0026lt; right-\u0026gt;priority) {\n    left-\u0026gt;right.reset(Merge(left-\u0026gt;right.release(), right));\n    left-\u0026gt;size \u003d left-\u0026gt;LeftSize() + left-\u0026gt;RightSize() + 1;\n    return left;\n  } else {\n    right-\u0026gt;left.reset(Merge(left, right-\u0026gt;left.release()));\n    right-\u0026gt;size \u003d right-\u0026gt;LeftSize() + right-\u0026gt;RightSize() + 1;\n    return right;\n  }\n}\n\ntemplate \u0026lt;class Value\u0026gt;\nNodes\u0026lt;Value\u0026gt; Array\u0026lt;Value\u0026gt;::Split(Node* node, size_t left, size_t right) {\n  if (left \u003d\u003d 0) {\n    return {nullptr, node};\n  }\n\n  if (right \u003d\u003d 0) {\n    return {node, nullptr};\n  }\n\n  if (node \u003d\u003d nullptr) {\n    return {nullptr, nullptr};\n  }\n\n  size_t left_size \u003d node-\u0026gt;LeftSize();\n  if (left_size \u0026gt;\u003d left) {\n    auto pre_division \u003d Split(node-\u0026gt;left.release(), left, left_size - left);\n    node-\u0026gt;left.reset(pre_division.second);\n    node-\u0026gt;size \u003d node-\u0026gt;LeftSize() + node-\u0026gt;RightSize() + 1;\n    return {pre_division.first, node};\n  }\n\n  size_t right_size \u003d node-\u0026gt;RightSize();\n  if (right_size \u0026gt;\u003d right) {\n    auto pre_division \u003d Split(node-\u0026gt;right.release(), right_size - right, right);\n    node-\u0026gt;right.reset(pre_division.first);\n    node-\u0026gt;size \u003d node-\u0026gt;LeftSize() + node-\u0026gt;RightSize() + 1;\n    return {node, pre_division.second};\n  }\n\n  throw 1;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch1\u003eПерспективы\u003c/h1\u003e\u003cp\u003eВсе это хорошо, массив и множество — отличные структуры данных, но они частично есть в STL. Что мы можем сделать на этом поприще? На самом деле много чего — например, если в декартовом дереве по неявному ключу грамотно резать, то мы можем кромсать массив на части и объединять их в другом порядке за \u003ccode\u003eO(log n)\u003c/code\u003e на каждую из операций. Еще, при сохранении дополнительной информации в вершинах и обновлении оной мы можем отвечать на запросы на интервале (идея, в целом, схожа с таковой у Дерева отрезков).\u003c/p\u003e\u003c/div\u003e","tags":[]}}