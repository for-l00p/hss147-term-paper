{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1520806102,"rating":80,"authorHandle":"cjtoribio","modificationTimeSeconds":1521060906,"id":58316,"title":"\u003cp\u003eVenice Technique\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eMotivation \u0026amp; Problem\u003c/h2\u003e\u003cp\u003eRecently saw \u003ca href\u003d\"//codeforces.com/problemset/problem/923/B\"\u003ethis\u003c/a\u003e problem. For some this problem might seem like a segment tree problem and it is indeed one. However this problem and others where segment tree does not apply can be solved using another approach. I will rephrase the problem in a simpler way. We want a data structure capable of doing three main update-operations and some sort of query. The three modify operations are:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eadd\u003c/strong\u003e: Add an element to the set.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eremove\u003c/strong\u003e: Remove an element from the set.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eupdateAll\u003c/strong\u003e: This one normally changes in this case subtract X from \u003cstrong\u003eALL\u003c/strong\u003e the elements. For this technique it is completely required that the update is done to \u003cstrong\u003eALL\u003c/strong\u003e the values in the set equally.\u003c/p\u003e\u003cp\u003eAnd also for this problem in particular we may need one query:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003egetMin\u003c/strong\u003e: Give me the smallest number in the set.\u003c/p\u003e\u003cp\u003eObserving this operations we want to handle, \u003cstrong\u003eSegmentTree\u003c/strong\u003e seems legit except for the remove, but we can wave it around by assigning INF to the position we want to remove. However if we don\u0027t have the \u003cstrong\u003eupdateAll\u003c/strong\u003e then we can just use a \u003cstrong\u003eMULTISET\u003c/strong\u003e. And in fact if the remove is only to the minimum element then we can use a \u003cstrong\u003eHEAP\u003c/strong\u003e. However the four operations without any \u0026quot;workaround\u0026quot; can only be managed by a \u003cstrong\u003eDynamicSegmentTree\u003c/strong\u003e which in fact exists but is like using a bazooka to kill a simple mosquito.\u003c/p\u003e\u003ch2\u003eInterface of the Data Structure\u003c/h2\u003e \u003cpre\u003e\u003ccode\u003estruct VeniceSet {\n\tvoid add(int);\n\tvoid remove(int);\n\tvoid updateAll(int); \n\tint getMin(); // custom for this problem\n\tint size();\n};\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eUsage of this methods\u003c/h2\u003e\u003cp\u003eSo imaging we have this four operations, how can we tackle this problem with it. Well i will illustrate it with a simple code in C++ which i hope is self explanatory.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eVeniceSet mySet;\nfor (int i \u003d 0; i \u0026lt; N; ++i) {\n\tmySet.add(V[i]);\n\tmySet.updateAll(T[i]); // decrease all by T[i]\n\tint total \u003d T[i] * mySet.size(); // we subtracted T[i] from all elements\n\t\n\t// in fact some elements were already less than T[i]. So we probbaly are counting \n\t// more than what we really subtracted. So we look for all those elements\n\twhile (mySet.getMin() \u0026lt; 0) {\n\t\t// get the negative number which we really did not subtracted T[i]\n\t\tint toLow \u003d mySet.getMin(); \n\t\t\n\t\t// remove from total the amount we over counted\n\t\ttotal -\u003d abs(toLow);\n\t\t\n\t\t// remove it from the set since I will never be able to substract from it again\n\t\tmySet.remove(toLow);\n\t}\n\tcout \u0026lt;\u0026lt; total \u0026lt;\u0026lt; endl;\n}\ncout \u0026lt;\u0026lt; endl;\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eImplementation of the Technique\u003c/h2\u003e\u003cp\u003eAs the title says I don\u0027t call it a data structure itself but this is a technique almost always backed up by a data structure. And now I am going to explain why I call it Venice technique. Imagine you have an empty land and the government can make queries of the following type: * Make a building with A floors. * Remove a building with B floors. * Remove C floors from all the buildings. (A lot of buildings can be vanished) * Which is the smallest standing building. (Obviously buildings which are already banished don\u0027t count)\u003c/p\u003e\u003cp\u003eThe operations 1,2 and 4 seems very easy with a set, but the 3 is very cost effective probably O(N) so you might need a lot of workers. But what if instead of removing C floors we just fill the streets with enough water (as in venice) to cover up the first C floors of all the buildings :O. Well that seems like cheating but at least those floor are now vanished :). So in order to do that we apart from the SET we can maintain a global variable which is the water level. so in fact if we have an element and want to know the number of floors it has we can just do \u003ccode\u003eheight - water_level\u003c/code\u003e and in fact after water level is for example 80. If we want to make a building of 3 floors we must make it of 83 floors so that it can tough the land. So the implementation of this technique might look like this.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estruct VeniceSet {\n\tmultiset\u0026lt;int\u0026gt; S;\n\tint water_level \u003d 0;\n\tvoid add(int v) {\n\t\tS.insert(v + water_level);\n\t}\n\tvoid remove(int v) {\n\t\tS.erase(S.find(v + water_level));\n\t}\n\tvoid updateAll(int v) {\n\t\twater_level +\u003d v;\n\t}\n\tint getMin() {\n\t\treturn *S.begin() - water_level;\n\t}\n\tint size() {\n\t\treturn S.size();\n\t}\n};\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eVariations\u003c/h2\u003e\u003ch4\u003eTrick With Trie\u003c/h4\u003e\u003cp\u003eProbably you have seen a problem of having a set of numbers and handle queries such as what is the greatest XOR than can be achieved by using one number of the set and the given number. This can be handled with a BinaryTrie. However if we add the operation XOR all the numbers in the set this would be very heavy. But if we maintain a global \u003cstrong\u003ewater_level\u003c/strong\u003e that would XOR any number in and any number out, then it would virtually be XORING all the numbers in the set. Don\u0027t have an example problem yet, but I know I have used it, so any is welcome.\u003c/p\u003e\u003cp\u003eSo as my experience is, this technique is a lightweight modification that can be applied to all DataStructures that support (add, remove and query) and only need the operation (updateAll).\u003c/p\u003e\u003ch2\u003eOther Approaches For This Problem\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eBinary Search\u003c/strong\u003e: This is very fast and simple, however is an offline solution. (Not apply for other operations such as sort)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eEvent Processing\u003c/strong\u003e: Easy to code and fast but still offline and does not apply for other operations such as XOR.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDynamic Segment Tree\u003c/strong\u003e: A little slow in practice, same complexity in theory, and requires heavy code. This is online but requires heavy code. (Dynamic means can insert and delete nodes from the segment tree). Does not apply to other variations of the problem such as XOR.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eImplicit Segment Tree\u003c/strong\u003e: Relativly easy to code, but theoretical complexity of Nlog(MAXVAL) and still requires this technique to work. (Does not apply to other variations such as XOR)\u003c/p\u003e\u003ch2\u003eExample Problems\u003c/h2\u003e \u003cul\u003e   \u003cli\u003e\u003ca href\u003d\"//codeforces.com/contest/842/problem/D\"\u003eD. Vitya and Strange Lesson\u003c/a\u003e — Using the XOR variation\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://www.spoj.com/problems/BDOI16E/\"\u003eBDOI16E — Village Fair\u003c/a\u003e — Multiple Venice Sets\u003c/li\u003e \u003c/ul\u003e\u003c/div\u003e","tags":["#data structure","technique"]}}