{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1435172912,"rating":115,"authorHandle":"lewin","modificationTimeSeconds":1435285617,"id":18842,"title":"\u003cp\u003eCodeforces Round #309 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/554/problem/A\"\u003eDiv2A: Kyoya and Photobooks\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSolving this problem just requires us to simulate adding every character at every position at the string, and removing any duplicates. For instance, we can use a HashSet of Strings in Java to do this (a set in C++ or Python works as well). \u003c/p\u003e\u003cp\u003eBonus: Prove that the number of ways is always (length of string + 1) * 25 + 1.\u003c/p\u003e\u003cp\u003eExample code: \u003ca href\u003d\"//codeforces.com/contest/554/submission/11767578\"\u003ehttp://codeforces.com/contest/554/submission/11767578\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/554/problem/B\"\u003eDiv2B: Ohana Cleans Up\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eFor each row, there is only one set of columns we can sweep so it becomes completely clean. So, there are only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e configurations of sweeping columns to look at. Checking a configuration takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e time to count the number of rows that are completely clean. There are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e configurations in all, so this takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e time total. \u003c/p\u003e\u003cp\u003eAlternatively, another way of solving this problem is finding the maximum number of rows that are all the same.\u003c/p\u003e\u003cp\u003eExample code: \u003ca href\u003d\"//codeforces.com/contest/554/submission/11767576\"\u003ehttp://codeforces.com/contest/554/submission/11767576\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/553/problem/A\"\u003eDiv2C/Div1A: Kyoya and Colored Balls\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the number of ways to solve the problem using only the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e colors. We want to compute \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eInitially, we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e  \u003d  1\u003c/span\u003e, since we only have a single color, and balls of the same color are indistinguishable. Now, to go from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e, we note that we need to put at a ball of color \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e at the very end, but the other balls of color \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e can go anywhere in the sequence. The number of ways to arrange the balls of color \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4c/86/4c869ccef8508ef383e4f8b972b8d6446ec61d81.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (minus one because we need to put one ball at the very end). Using this recurrence, we can solve for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eThus, we need to precompute binomial coefficients then evaluate the product.\u003c/p\u003e\u003cp\u003eExample code: \u003ca href\u003d\"//codeforces.com/contest/553/submission/11767584\"\u003ehttp://codeforces.com/contest/553/submission/11767584\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/553/problem/B\"\u003eDiv2D/Div1B: Kyoya and Permutation\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSolving this requires making the observation that only swaps between adjacent elements are allowed, and all of these swaps must be disjoint. This can be discovered by writing a brute force program, or just noticing the pattern for small \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eHere\u0027s a proof for why this is. Consider the cycle that contains \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is the largest number, it must be the last cycle in the sequence, and it\u0027s the first element of the sequence. If this cycle is length 1, then we\u0027re obviously ok (we can always append \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e to the end). If the cycle is of length 2, we need \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e to be involved in a cycle with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e. Lastly, if the cycle is of length 3 or more, we will see we run into a problem. We\u0027ll only show this for a cycle of length 3 (though this argument does generalize to cycles of larger length). Let \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003enxy\u003c/i\u003e)\u003c/span\u003e be the cycle. So that means, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is replaced by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is replaced by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e is replaced by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. So, in other words, the original permutation involving this cycle must look like\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eposition:   ... y x n\nnumber  :   ... n y x\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHowever, we need it to look like \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003enxy\u003c/i\u003e)\u003c/span\u003e so this case is impossible.\u003c/p\u003e\u003cp\u003eSo, once we know that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is a in a cycle of length \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e, we can ignore the last 1 or 2 elements of the permutation and repeat our reasoning. Thus, the only valid cases are when we swap adjacent elements, and all swaps are disjoint. After making this observation, we can see the number of valid permutations of length n is fib(n+1). (to see this, write try writing a recurrence). \u003c/p\u003e\u003cp\u003eTo reconstruct the kth permutation in the list, we can do this recursively as follows: If k is less than fib(n), then \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e must be the very first element, and append the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003eth permutation on {1,...,n-1} with 1 added everywhere. Otherwise, add \u003cspan class\u003d\"tex-span\"\u003e2, 1\u003c/span\u003e to the very front and append the k-fib(n)th permutation on {1,...,n-2} with 2 added everywhere.\u003c/p\u003e\u003cp\u003eExample code: \u003ca href\u003d\"//codeforces.com/contest/553/submission/11767583\"\u003ehttp://codeforces.com/contest/553/submission/11767583\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/553/problem/C\"\u003eDiv2E/Div1C: Love Triangles\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLet\u0027s look at the graph of characters who love each other. Each love-connected component can be collapsed into a single node, since we know that all characters in the same connected component must love each other.\u003c/p\u003e\u003cp\u003eNow, we claim that the resulting collapsed graph with the hate edges has a solution if and only if the resulting graph is bipartite.\u003c/p\u003e\u003cp\u003eTo show this, suppose the graph is not bipartite. Then, there is an odd cycle. If the cycle is of length 1, it is a self edge, which clearly isn\u0027t allowed (since a node must love itself). For any odd cycle of length more than 1, let\u0027s label the nodes in the cycle \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Then, in general, we must have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e loves \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e(\u003ci\u003ei\u003c/i\u003e + 2)\u003c/sub\u003e\u003c/span\u003e, since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e(\u003ci\u003ei\u003c/i\u003e + 1)\u003c/sub\u003e\u003c/span\u003e hate each other and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e(\u003ci\u003ei\u003c/i\u003e + 1)\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e(\u003ci\u003ei\u003c/i\u003e + 2)\u003c/sub\u003e\u003c/span\u003e hate each other (all indicies taken mod \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e). However, we can use the fact that the cycle is odd and eventually get that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e love each other. However, this is a contradiction, since we said they must originally hate each other.\u003c/p\u003e\u003cp\u003eFor the other direction, suppose the graph is bipartite. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e, \u003ci\u003eY\u003c/i\u003e\u003c/span\u003e be an arbitrary bipartition of the graph. If we let all nodes in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e love each other and all nodes in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e love each other, and every edge between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e hate each other, then we get a solution. (details are omitted, though I can elaborate if needed).\u003c/p\u003e\u003cp\u003eThus, we can see that we have a solution if and only if the graph is bipartite. So, if the graph is not bipartite, the answer is zero. Otherwise, the second part of the proof gives us a way to count. We just need to count the number of different bipartitions of the graph. It\u0027s not too hard to see that this is just simply 2^(number of connected components — 1) (once you fix a node, you fix every node connected to it). \u003c/p\u003e\u003cp\u003eThis entire algorithm takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e + \u003ci\u003eM\u003c/i\u003e)\u003c/span\u003e time. \u003c/p\u003e\u003cp\u003eExample code: \u003ca href\u003d\"//codeforces.com/contest/553/submission/11767582\"\u003ehttp://codeforces.com/contest/553/submission/11767582\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/553/problem/D\"\u003eDiv1D: Nudist Beach\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eThe algorithm idea works as follows:\u003c/p\u003e\u003cp\u003eStart with all allowed nodes. Remove the node with the smallest ratio. Repeat. Take the best ratio over all iterations. It\u0027s only necessary to consider these subsets. Proof for why.\u003c/p\u003e\u003cp\u003eWe say this process finds a ratio of at least p if and only if there exists a subset with ratio at least p.\u003c/p\u003e\u003cp\u003eExists a subset with ratio at least p \u003d\u0026gt; algorithm will find answer of at least p. First, observe that the ratio of any particular node only decreases throughout the algorithm. Thus, all nodes in this subset initally have ratio at least p. Then, the very first node that gets removed from this subset must not have ratio smaller than p, thus the above algorithm will record an answer of at least p.\u003c/p\u003e\u003cp\u003eExists no subset with ratio at least p \u003d\u0026gt; algorithm finds answer at most p. No subset with ratio at least p implies every subset has ratio at most p. Thus, at every iteration of our algorithm, we\u0027ll get an answer of at most p, so we\u0027re done.\u003c/p\u003e\u003cp\u003eThus, we can see these are necessary and sufficient conditions, so we\u0027re done.\u003c/p\u003e\u003cp\u003eNow for efficient implementation, we can use a variant of Dijkstra\u0027s. Recording the best subset must be done a bit more carefully as well.\u003c/p\u003e\u003cp\u003eExample code: \u003ca href\u003d\"//codeforces.com/contest/553/submission/11767581\"\u003ehttp://codeforces.com/contest/553/submission/11767581\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/553/problem/E\"\u003eDiv1E: Kyoya and Train\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eThe Naive solution is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eMT\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003et\u003c/i\u003e)\u003c/span\u003e be the optimal expected time given we are at node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e time units left. Also, let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003et\u003c/i\u003e)\u003c/span\u003e be the optimal expected time given we use edge \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e at time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow, we have\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/86/84/86849a14dd5ef145d4a6b4db53bfb1eac8c44147.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eAnd, if e \u003d (u-\u0026gt;v), we have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5c/47/5c47548dea381c80b35fa952c9c468f9855c78b4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eDoing all this naively takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eMT\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow, we\u0027ll speed this up using FFT. We\u0027ll focus on only a single edge for now. The problem here, however, is that not all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e values are given in advance. Namely, the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e values require us to compute the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e values for all edges at a particular time, and vice versa. So we need some sort of fast \u0026quot;online\u0026quot; version of FFT.\u003c/p\u003e\u003cp\u003eWe do this as follows. Let\u0027s abstract away the original problem, and let\u0027s say we\u0027re given two arrays a,b, where a is only revealed one at a time to us, and b is given up front, and we need to compute c, their convolution (in the original problem b is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, and a is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, and c is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e). Now, when we get the ith value of a, we need to return the ith value of the convolution of c. We can only get the ith value of a when we compute the i-1th values of c for all c.\u003c/p\u003e\u003cp\u003eSplit up b into a block of size 1, a block of size 1, then a block of size 2, then a block of size 4, then 8, and so on.\u003c/p\u003e\u003cp\u003eNow, we get \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e, which will allow us to compute \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, which lets us get \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, which allows us to compute \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e, and so on. \u003c/p\u003e\u003cp\u003eSo, now we have the following:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eb_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe\u0027ll describe the processing of a single \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eWhen we get \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, we will first convolve it with the first two blocks, and add those to the appropriate entry. Now, suppose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is multiple of a \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e for some k. Then, we will convolve \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/sub\u003e\u003c/span\u003e .. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e with the block in b with the same size. \u003c/p\u003e\u003cp\u003eAs an example.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e      b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis gives us \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e, which then allows us to get \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e      b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis gives us \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, which then allows us to get \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e is now a power of 2, so this step will also additionally convolve \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e4\u003c/sub\u003e\u003c/span\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e      b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo, we can see this gives us \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e, which then allowus to get \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e\u003c/span\u003e, and so on and so forth.\u003c/p\u003e\u003cp\u003eThus, this process of breaking into blocks works. As for runtime, we run FFT on a block size of B T/B times, so this term contributes (T/B) * B log B \u003d T log B\u003c/p\u003e\u003cp\u003eSo, we sum T log 2 + T log 4 + ... + T log 2\\^(log T) \u0026lt;\u003d T log\\^2 T\u003c/p\u003e\u003cp\u003eThus, the overall time per edge is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d6/de/d6de933bbb8506579ffa24d9d05f2daa78bab6b8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, which gives us a total runtime of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/fa/8d/fa8d35d9a533cc9833ed6efbb97f5d3177dcca33.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eExample code: \u003ca href\u003d\"//codeforces.com/contest/553/submission/11767579\"\u003ehttp://codeforces.com/contest/553/submission/11767579\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["codeforces","round","309","editorial"]}}