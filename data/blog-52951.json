{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1498631551,"rating":70,"authorHandle":"from_bd_with_depression","modificationTimeSeconds":1498632203,"id":52951,"title":"\u003cp\u003eSolution for 421 Div2C/Div1A\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI believe I have a correct solution for the problem. Of course I know that division 1 red coders tried it for quite sometime and did not manage to come up with a proved solution so I won\u0027t dare give 100 percent guarantee. But anyway I am writing my approach and my proof here. If anyone finds a counter example or mistake in my proof, please tell me so. I am also writing because it could help someone to find a new approach and get a full proved solution. I also know that \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/LLI_E_P_JI_O_K\" title\u003d\"Expert LLI_E_P_JI_O_K\"\u003eLLI_E_P_JI_O_K\u003c/a\u003e explained his approach in the comments of the announcement post and his solution is looking correct. However, if I had understood correctly, he seemed to have attacked the problem case by case and there may be a little chance that he missed some case. Instead, I used a kind of complete search to solve it.\u003c/p\u003e\u003cp\u003eSo, we already know if the segment length is greater than \u003ccode\u003e2*(a+b)\u003c/code\u003e then the answer will be \u003ccode\u003ea+1\u003c/code\u003e ( if \u003ccode\u003eb\u0026gt;\u003da\u003c/code\u003e ) or \u003ccode\u003e2*a-b\u003c/code\u003e (else). Now, if the segment length is smaller than that, first we will find how many \u003ccode\u003e2*(a+b)\u003c/code\u003e segment has appeared before \u003ccode\u003el\u003c/code\u003e-th index. Let there be n such segments. It can be easily shown that Mr B always has a strategy such that he can play through this \u003ccode\u003e2*n*(a+b)\u003c/code\u003e long string such that from the next index the computer will produce the first a alphabets (which was done initially at the game). So we assume that the game is played by that strategy until the string has \u003ccode\u003e2*n*(a+b)\u003c/code\u003e length. After that, we have to generate a string that gives minimum number of distinct character for \u003ccode\u003e[l,r]\u003c/code\u003e range. \u003c/p\u003e\u003cp\u003eThe string we generate will have 4*(a+b) length. This will handle all the possible \u003ccode\u003el\u003c/code\u003e and \u003ccode\u003er\u003c/code\u003e when the segment length is smaller than \u003ccode\u003e2*(a+b)\u003c/code\u003e So, the computer will have 4 moves and Mr B has 4 moves within this string. Now, the computers move is always dependent on the previous suffix and Mr B has options in his choice of character. So different string can only be generated by varying Mr B\u0027s choice. Now, here comes a slight potential drawback in my approach. I believe, its always optimal for Mr B to choose one single character in each of his move. He may select different characters in different moves but when he chooses one character in one of his move he will stick with that character throughout the move to get the best result. (I can\u0027t prove this belief. Its just a very strong intuition. Someone is welcome to give a formal proof or give a counter example to this assumption.)\u003c/p\u003e\u003cp\u003eHence, in each of his 4 moves, Mr B has to choose 4 characters. So in total there can be \u003ccode\u003e26^4\u003c/code\u003e options for him and therefore we will have at most 26^4 different strings. (This can be further optimized by limiting total characters from 26 to \u003ccode\u003emax(a+1,2*a-b)\u003c/code\u003e which can be the maximum answer. However, using 26 also runs within the time limit, I tested it.)\u003c/p\u003e\u003cp\u003eSo, here\u0027s how the solution goes: If segment length is greater than \u003ccode\u003e2*(a+b)\u003c/code\u003e the ans is \u003ccode\u003ea+1\u003c/code\u003e or \u003ccode\u003e2*a-b\u003c/code\u003e depending on the value of a and b. Otherwise, the initial string will be the first \u003ccode\u003ea\u003c/code\u003e characters. So there will be 4 Mr B\u0027s moves and 3 computer moves left. So we keep a vector of length 4 which will store Mr B\u0027s choices of characters for each of his moves, generate the string by appending Mr B\u0027s characters and also computing the computer\u0027s move by passing current string to its algorithm. By varying the vector, we will have a total of around \u003ccode\u003e26^4\u003c/code\u003e strings max. And for each of this string we can count how many distinct characters are there in the range \u003ccode\u003e[l:r]\u003c/code\u003e and we take the minimum of it.\u003c/p\u003e\u003cp\u003eHere is my AC code: \u003ca href\u003d\"/contest/820/submission/28108706\" title\u003d\"Submission 28108706 by from_bd_with_depression\"\u003e28108706\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAnyone is welcome to share his/her opinion.\u003c/p\u003e\u003c/div\u003e","tags":[]}}