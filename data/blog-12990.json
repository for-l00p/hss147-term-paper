{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1404921222,"rating":0,"authorHandle":"m.radwan","modificationTimeSeconds":1407496185,"id":12990,"title":"\u003cp\u003eWeeks 1-2 Write up\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eIf there\u0027s something not clear please give feedback in the comments, also if you have more neat code than the one presented in the editorial / or ideas feel free to share and discuss.\u003c/p\u003e\u003ch4\u003eTree Analysis\u003c/h4\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(\u003ci\u003eT\u003c/i\u003e)\u003c/span\u003e be the class number of tree T, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003c/span\u003e should be equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e if and only if, \u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e{\u003ci\u003eC\u003c/i\u003e(\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e): \u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003ci\u003echild\u003c/i\u003e \u003ci\u003eof\u003c/i\u003e \u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e} ≡ {\u003ci\u003eC\u003c/i\u003e(\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e): \u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u003ci\u003echild\u003c/i\u003e \u003ci\u003eof\u003c/i\u003e \u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e}\u003c/span\u003e\u003c/center\u003e\u003cp\u003eMeaning that two trees are equivalent if their children are equivalent, the multisets of class numbers of their children must be equivalent\u003cbr /\u003e Now we can solve this problem recursively using dfs and a hashmap/treemap which maps a sorted list of children class numbers to the node class number.\u003cbr /\u003e Code: \u003ca href\u003d\"http://pastebin.com/f6TGGHZE\"\u003ehttp://pastebin.com/f6TGGHZE\u003c/a\u003e\u003c/p\u003e\u003ch4\u003eTravel Agency\u003c/h4\u003e\u003cp\u003eFirst we observe that for a node k to be critical on some path between (i, j), it has to be an articulation point in the graph since (i, j) would be disconnected if we remove it\u003c/p\u003e\u003cp\u003eTo solve this problem we study the dfs tree of the undirected graph where the edges are classified as forward/backward edges. \u003cimg alt\u003d\" \" src\u003d\"/predownloaded/d4/0a/d40a67ff6309faa49a0af0fca1d5977cdbb9dd62.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003cbr /\u003e A Node is an articulation point if one of it\u0027s children subtrees does not have back edge to one of it\u0027s ancestors.\u003cbr /\u003e For example Node D is an articulation point, since F does not have a back edge to A or B. While Node B is not an articulation point, since D has a back edge to A.\u003c/p\u003e\u003cp\u003eNow for any node \u003cstrong\u003ei\u003c/strong\u003e that is an articulation point has a child \u003cstrong\u003ej\u003c/strong\u003e where no back edges go from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to ancestors of \u003cstrong\u003ei\u003c/strong\u003e, then all paths that go from any node in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to any node not in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e must pass by \u003cstrong\u003ei\u003c/strong\u003e, we then can use this property to calculate the answer for each node.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://pastebin.com/1iHgEyVL\"\u003ehttp://pastebin.com/1iHgEyVL\u003c/a\u003e Finding Articulation points: \u003ca href\u003d\"http://e-maxx.ru/algo/cutpoints\"\u003ehttp://e-maxx.ru/algo/cutpoints\u003c/a\u003e\u003c/p\u003e\u003ch4\u003eAutomata\u003c/h4\u003e\u003cp\u003eSo we have an m x n board, which is going to be tiled in dominoes, each tiling is represented by as a string of character H, V, S tiling goes column major order.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eWe would like to construct a state machine that takes a tiling for an m x k board (k unknown) as a string and returns whether such a tiling is correct or incorrect.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eFirst observe that we need to remember which row we are currently at so as to know if we are moving to next row or we are moving back to the first row, also observe that we must remember which cells from next column currently filled by dominoes which we\u0027ve put horizontally for example \u003cbr /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eV...\nV...\nHH..\nV...\nC...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e(V \u003d vertical, H \u003d horizontal, C \u003d current cell)\u003cbr /\u003e Here when going to column 2 (1 based), we must remember that the third cell was already filled by placing a horizontal domino piece from column 1.\u003c/p\u003e\u003cp\u003eThis strongly suggests having the states of our state machine as (Current Row Index, Cells Filled from current Column, Cells Filled from next column), this means the number of states is at most \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e10\u003c/sup\u003e * 2\u003csup class\u003d\"upper-index\"\u003e10\u003c/sup\u003e * 10\u003c/span\u003e which is much larger than 20k!.\u003c/p\u003e\u003cp\u003eTo optimize let\u0027s take a look at what\u0027s happening in the two masks when we\u0027re placing a piece at a specific row\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/72/af/72af8ab76d2f7454f8eb9d6d4a7b79e8de92001a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eObserve that in current column the rows already processed (rows before current row) must always be filled with dominoes since we must fill the whole board, and in next column the current row, and rows after current row are all empty since domino pieces are 2x1 and we didn\u0027t put any horizontal pieces yet in rows ≥ current row.\u003c/p\u003e\u003cp\u003eThus the idea is to use a single mask to represent the state of the current and next column, where bits ≥ current row belong to current column and bits \u0026lt; current row belong to next column\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e     Current row -\u0026gt; Next row\n        |\nNEXTCOL VCURRENT COL\n0010000010010100101\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow the number of states become \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e10\u003c/sup\u003e * 10 + 1\u003c/span\u003e, constructing the transitions is obvious from construction.\u003c/p\u003e\u003cp\u003eAcceptance state is the initial state mask \u003d 0, current row \u003d 0, all other states are reject.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://pastebin.com/CZti51CL\"\u003ehttp://pastebin.com/CZti51CL\u003c/a\u003e Other problems that use that trick\u003cbr /\u003e RATTERN on spoj,\u003cbr /\u003e Credit goes to Azazy for telling me about that trick for solving RATTERN!\u003c/p\u003e\u003ch4\u003eSubstring search\u003c/h4\u003e\u003cp\u003eThe constraints suggest that we must use an O(n) or O(nlgn) string matching algorithm, the problem also doesn\u0027t seem easier than the normal string matching, this suggests that we should use a string matching algorithm, or maybe hashing ?\u003c/p\u003e\u003cp\u003eEither way we need to find a new way to represent the string so that we can do the matching, notice that the relation between the characters and each other is more important than the characters itself.\u003c/p\u003e\u003cp\u003eOne way is to do the following, given a string s we transform it into t such that t[i] \u003d distance between i and next occurrence of s[i], if s[i] occurs one more time in the future. t[i] \u003d 0 otherwise.\u003c/p\u003e\u003cp\u003eexample s \u003d{ b, l, a, c, k }, t \u003d { 0, 0, 0, 0, 0}\u003cbr /\u003e s \u003d{ t, r, o, l, o, l, l }, t \u003d {0, 0, 2, 2, 2, 1, 0}\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eNow if we have one string encrypted using the way described in problem statement, the transformed array of the original string will be equal to the transformed array of the encrypted string.\u003c/p\u003e\u003cp\u003eCan we use Kmp now ? No :-( the problem arrises because sometimes we might have extra repeated characters at the end of text, while we don\u0027t have this in the pattern For example: \u003cbr /\u003e text \u003d abcdaabb \u003cbr /\u003e transform(text) \u003d 45001010 \u003cbr /\u003e pattern \u003d love \u003cbr /\u003e transform(pattern) \u003d 0000 \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eTo solve this problem we modify the charAt function such that if the remaining length of the pattern to be matched is less than the value of the character we are currently using then use 0 instead, now when we are matching love with abcdaabb we should see the first a as a zero instead of seeing it as an a.\u003c/p\u003e\u003cp\u003eMy bad code: \u003ca href\u003d\"http://pastebin.com/Ew6QjGrP\"\u003ehttp://pastebin.com/Ew6QjGrP\u003c/a\u003e\u003c/p\u003e\u003ch4\u003eChip construction\u003c/h4\u003e\u003cp\u003eSmells like a max flow problem, but not a maximum flow, at least the constraints and the time limit suggest so somehow, first observe that you can calculate for each row how many 1xh\u0027s \u003cstrong\u003estarting\u003c/strong\u003e at this row, because you know for each row how many 1x1 it contains.\u003c/p\u003e\u003cp\u003eNow starting from first row we know that row i has start[i] 1xh\u0027s, to which columns should we place those ? The most needy, i.e the columns that need most 1xh\u0027s of course you should avoid overlaps. \u003c/p\u003e\u003cp\u003eI believe also less experienced contestants should be able to solve this problem faster because they won\u0027t get stuck forcing maxflow in.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/UnmRuXUn\"\u003ehttp://pastebin.com/UnmRuXUn\u003c/a\u003e\u003c/p\u003e\u003ch4\u003eSqrt-nim\u003c/h4\u003e\u003cp\u003eA state is a winning state if we can put next player into a losing state. A state is a losing state if all next states from current state are winning states. Using this we can calculate winning states for numbers up to 1k for example.\u003c/p\u003e\u003cp\u003eBut what\u0027s more important than winning states is the losing states, now if we print out the losing states up to 1k we still see nothing, however if we print out the difference between the losing states and each we\u0027ll that the differences go like\u003c/p\u003e\u003cp\u003e2 3 3 4 5 5 6 6 7 7 8 9 9 10 10 ...\u003c/p\u003e\u003cp\u003eIt\u0027s an arithmatic sequence where each term is repeated twice except powers of two, now we can tell if a state is winning or losing in O(sqrt(n)) \u003c/p\u003e\u003cp\u003eI tried to prove it, however failed if you have any idea please share with us.\u003c/p\u003e\u003ch4\u003eConvex Permutominoes\u003c/h4\u003e\u003cp\u003eA Dynamic programming problem, we first start by finding a slow solution then we speed it up.\u003c/p\u003e\u003cp\u003eWe start by forming the polygon in this order \u003cbr /\u003e \u003cimg alt\u003d\" \" src\u003d\"/predownloaded/cd/ed/cdeda7379a605cdf554f61b7eed0788ff3de53e6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eWe process rows one by one giving a column to each row, we keep a state (i, l, r, mask) where i is current row l, r are the current columns, and mask indicates which columns are used.\u003c/p\u003e\u003cp\u003eFirst notice that i is not really needed since we can recover it from other parameters, also observe that when we move from one row to the next one we must either change l or r in case l hasn\u0027t yet reached 0 we can decrease l, taking a new column from the unused ones, same goes for r we can increase r by some value taking a new column from the unused ones.\u003c/p\u003e\u003cp\u003eNow if l reaches 0, and r reaches n, we still do have q unused columns, we can distribute those unused columns in q + 1 ways (0 for left part q for right part, 1 for left part q-1 for right part...q for left part 0 for right part)\u003c/p\u003e\u003cp\u003eAlso l might reach 0 alone or r might reach n alone those should be handled accordingly as well.\u003c/p\u003e\u003cp\u003eNow we got a running solution with at most 2^30 * 30 * 30 * 30 operations I believe this might be sufficient if you want to calculate all answers and hard code them in a solution, however it turns out that we can get rid of that mask.\u003c/p\u003e\u003cp\u003eIt turns out that we can replace the mask by variable count which indicates the number of unused columns between l and r, then we keep moving l to the left and r to the right when we skip any columns we increase count accordingly, now once l hits 0 it can start consuming from the columns in the middle decreasing count, same goes for when r hits n.\u003c/p\u003e\u003cp\u003eHere\u0027s the code, Notice that I replaced l by number of columns to my left, and r by number of columns to my right.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/JTS0ut6J\"\u003ehttp://pastebin.com/JTS0ut6J\u003c/a\u003e\u003c/p\u003e\u003ch4\u003eDecoding prefix codes\u003c/h4\u003e\u003cp\u003eThis problem has a taste of hardness, First observe that if you knew the length of every character you can easily recover and verify the codes, Also observe that finding the lengths of each character must satisfy :-\u003cbr /\u003e Sum(freq(i) * length(c(i))) \u003d length(code)\u003c/p\u003e\u003cp\u003eAnd this is also a hard problem when the numbers are large which is not the case here, adding to that I failed to find any other solution that works fast, I decided to go with backtracking\u003c/p\u003e\u003cp\u003eThe problem also has a lot of pruning that seem possible, first observe that each character will get it\u0027s code only once, other times we will only check if the code is the one we chosen before or not.\u003c/p\u003e\u003cp\u003eAlso observe that if one code is a prefix of another we\u0027ll not assign this code to any character, checking if the new code is not a prefix of the old ones can be done quickly using a trie.\u003c/p\u003e\u003cp\u003eAnd that was enough to get an AC.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://pastebin.com/Fii3B9iV\"\u003ehttp://pastebin.com/Fii3B9iV\u003c/a\u003e \u003cbr /\u003e Another code: \u003ca href\u003d\"http://pastebin.com/vCtLLcKr\"\u003ehttp://pastebin.com/vCtLLcKr\u003c/a\u003e\u003c/p\u003e\u003ch4\u003eTruth is in the...\u003c/h4\u003e\u003cp\u003eFirst observe that if there was no statements of type # (# means dollar sign) we can try all possibilities for the first statement finding all possibilities for all other statements.\u003c/p\u003e\u003cp\u003eSince each statement implies the next, it looks like a ring.\u003c/p\u003e\u003cp\u003ethe # statements act as separators which divide the ring into several chains.\u003c/p\u003e\u003cp\u003eABAAABABABBABABA#QQQQ is turned into \u003cbr /\u003e QQQQABAAABABABBABABA# ABA#AA#BB \u003cbr /\u003e is turned into \u003cbr /\u003e BBABA#, AA#\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eNow we separate the given set of statements into chains as described, for each chain we have two possibilities based on the value of the first statement, Also observe that each chain ends with a # statement, for each chain we can count the number of true/false.\u003c/p\u003e\u003cp\u003eAfter doing so we can calculate for each X in #X statement, how many statements will be true if #X is true.\u003c/p\u003e\u003cp\u003ewatch out for special cases as more than # statement with the same value, sorry for bad explanation for this problem, but it was really painful to code maybe someone with a simpler solution can elaborate.\u003c/p\u003e\u003cp\u003eMy Awful code: \u003ca href\u003d\"http://pastebin.com/BwtDwTtt\"\u003ehttp://pastebin.com/BwtDwTtt\u003c/a\u003e\u003c/p\u003e\u003ch4\u003eA Graph game\u003c/h4\u003e\u003cp\u003eOne thing we should think about when we face game theory problems is winning states and losing states, a state is a winning state if one of it\u0027s next states is a losing state, while a state is a losing state if all it\u0027s next states are winning states.\u003c/p\u003e\u003cp\u003eWe often are able to identify winning states and losing states by trying to play several games and several examples \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s check some of them \u003cbr /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ea    b\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003esince both nodes has no edges, thus starting at any of them gives a loss. \u003cbr /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ea----b\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eobviously starting from both positions leads to a win.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ea----b\n \\\n  \\\n   \\c\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003estarting at a gives a win, starting from either b or c gives a loss.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eNow that the graph is bipartite and the constraints should give some intuition that the problem is somehow related to bipartite matching, what we can see from the previous small examples is that:-\u003c/p\u003e\u003cp\u003eIf a node has no edges thus starting at this node is a loss.\u003cbr /\u003e If a node is essential in the maximum matching (i.e if we remove this node the maximum matching will be reduced by 1) then being at this node is a win.\u003cbr /\u003e If a node is not essential in maximum matching (i.e we can remove this node and augmenting the graph such that the maximum matching does not decrease) then this node a loss.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eNow that we have something, time to prove it.\u003c/p\u003e\u003cp\u003ethere exists A winning state\u0027s next is always a losing state, why ? \u003cbr /\u003e If we remove a node X (paired with with some node Y) that is essentially needed to achieve the maximum matching then the maximum matching will decrease by 1, and this node\u0027s pair Y will either have no edges (losing) or will have edges that allows it to be matched but since the matching has already decreased by 1, then Y is not essential in the new maximum matching (i.e Y can be unmatched keeping the new maximum matching as it is)\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eA losing state\u0027s next is always a winning state, why ? \u003cbr /\u003e After we remove a node X that is not essentially needed in maximum matching, the size of the maximum matching will not change, also all nodes adjacent to X will be essentially needed in the maximum matching, why ? because of one of them was not needed then we could match it with the removed X and that contradicts with the matching being maximum.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eThis completes the proof, game theory problems are more of guess and check you can\u0027t do much if you don\u0027t a good guess or it\u0027s a famous game like NIM or something you can apply grundy numbers in.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eAs for the implementation you can use dfs to find which nodes are essentially needed in the matching and mark them here\u0027s the code: \u003ca href\u003d\"http://pastebin.com/jS4dUk2h\"\u003ehttp://pastebin.com/jS4dUk2h\u003c/a\u003e\u003c/p\u003e\u003cp\u003eA node from the left set is not essentially needed in the matching if it\u0027s unmatched or reachable from a non matched node from the left by an alternating path which alternates between edges not in matching, in matching, if we can find such a path then we can augment the matching to unmatch the reachable node while matching the unmatched one.\u003c/p\u003e\u003cp\u003eSimilarly the for right set.\u003c/p\u003e\u003cp\u003eA special case is when you solve this problem on a tree, it\u0027s much easier tho\u003cbr /\u003e \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1045\"\u003ehttp://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1045\u003c/a\u003e\u003c/p\u003e\u003ch4\u003eCasino\u003c/h4\u003e\u003cp\u003eUsing more than one line is useless, since all lines have the same expected gain, so multiple lines is the same as multiplying the answer by n then dividing by n...\u003c/p\u003e\u003cp\u003eCalculating the answer for one line is an easy task, you can calculate the number of ways of winning each pattern, and multiply those by the gain for each pattern, notice that the problem is asking for the expected profit which means PWIN * WIN — PLOSS * LOSS\u003c/p\u003e\u003cp\u003eMy bad code: \u003ca href\u003d\"http://pastebin.com/JXNY5WN2\"\u003ehttp://pastebin.com/JXNY5WN2\u003c/a\u003e\u003c/p\u003e\u003ch4\u003eSpending Budget\u003c/h4\u003e\u003cp\u003eFirst notice that projects which spend more money per day are better than others, since they finish the budget faster and thus will help us finish faster, the sad thing is that we can\u0027t feed the same project from more than one budget.\u003c/p\u003e\u003cp\u003eIf some one told us that there\u0027s a possible way to finish all projects by time X can we know if this is correct ? \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s assume that the last budget given was available at day Y, now if we know that it has ended at X, which project to use ? \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eGreedily we should use the worst available project i such that X-ciel(p/si) is \u0026gt;\u003d Y, this way we are guaranteed to finish before X, and we save the \u0026quot;good\u0026quot; projects for other budgets.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eSo problem can be solved using binary search + greedy algorithm to check whether such a way is possible or not.\u003c/p\u003e\u003cp\u003eEssam has solved this problem completely using a greedy algorithm as well.\u003c/p\u003e\u003cp\u003eFrom what I\u0027ve learned about world finals problems so far is that binary search is essential in many problems and you should think \u0026quot;What can I do with binary search in this problem\u0026quot; while approaching it.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://pastebin.com/6EqiY00K\"\u003ehttp://pastebin.com/6EqiY00K\u003c/a\u003e\u003c/p\u003e\u003ch4\u003eMines\u003c/h4\u003e\u003cp\u003eSo we want to find N vertex disjoint paths, each path starting at some mine, and ending at some mine, we also want the sum of weights of those paths is as small as possible.\u003c/p\u003e\u003cp\u003eWe can find maximum number of vertex disjoint paths between s and t using maximum flow, by splitting each vertex into 2 v_in, v_out and adding an edge with capacity 1 between them, the approach is explained here (\u003ca href\u003d\"https://solveit.quora.com/Flows-cuts-and-matchings\"\u003eFlows, cuts and matchings\u003c/a\u003e).\u003c/p\u003e\u003cp\u003eFinding disjoint paths with minimum weight is just min-cost-max-flow.\u003c/p\u003e\u003cp\u003eThe problem here is that we don\u0027t know where is S and where is T, we don\u0027t know where are the mines which the paths start and where do they end, so we try ALL.\u003c/p\u003e\u003cp\u003eWe partition the set of nodes where the mines are located into two sets of equal size, connect S to the first set with edges of cost 0 and capacity 1, connect the second set with T with edges of cost 0 and capacity 1, then we run min-cost-maxflow if the flow is equal to N then we see if the cost obtained is better than the best so far and minimize, we do this for all possible partitioning ways.\u003c/p\u003e\u003cp\u003eImplementing min-cost-max-flow however cannot be done using bellman ford here since V * E is already large, it can be done with dijkstra however if you use dijkstra with min-cost-max-flow, you must use dijkstra which takes negative weight edges into account.\u003c/p\u003e\u003cp\u003ecode: \u003ca href\u003d\"http://pastebin.com/EmyPMzfw\"\u003ehttp://pastebin.com/EmyPMzfw\u003c/a\u003e\u003c/p\u003e\u003ch4\u003ePermutation Counting\u003c/h4\u003e\u003cp\u003eIf you try to solve this problem while looking at the permutation as a sequence of distinct numbers from 1 to n, you\u0027ll never solve it :(, to solve this problem you need to look at the graph structure in the permutation Let\u0027s construct the permutation graph as follows connect i to p[i]. Example \u003cbr /\u003e \u003cimg alt\u003d\" \" src\u003d\"/predownloaded/a1/6f/a16fd8fb2b3a9999d557b2fdb886439c10424bb8.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003cbr /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ei    :1, 2, 3, 4, 5, 6, 7, 8, 9, 10\np[i] :8, 6, 5, 9, 3,10, 4, 7, 1, 2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe want to count number of permutations with exactly K positions where p[i] \u0026gt; i, p[i] \u0026gt; i means that there are exactly K nodes with their next nodes greater than them.\u003c/p\u003e\u003cp\u003eTo solve this problem we use dynamic programming first let\u0027s add nodes incrementally from smallest to largest, assume we\u0027ve added n-1 nodes so far and we\u0027re currently adding the nth node we have these options for the nth node:-\u003c/p\u003e\u003cp\u003eForm a cycle alone this way we move from f(n, k) to f(n-1, k) since we haven\u0027t done anything yet. Insert the nth node in a previously formed cycle and we\u0027ve two options for this as well:- Insert the nth node between two nodes i, j such that i \u0026lt; j now we\u0027ll i \u0026lt; n \u0026gt; j ,k stayed the same, this way we\u0027re moving from f(n, k) to f(n-1, k) also there\u0027s (k) locations where we can do this. Insert the nth node between two nodes i, j such that i \u0026gt; j now we\u0027ll have i \u0026lt; n, n \u0026gt; j, k has increased by 1 so we\u0027re moving from f(n, k) to f(n-1, k-1), there\u0027s (n-1-(k-1)) \u003d (n-k) locations where we can do this.\u003c/p\u003e\u003cp\u003eThis makes the final recurrence f(n, k) \u003d (k + 1) * f(n-1, k) + (n-k) * f(n-1, k-1) without the help of permutation cycles we wouldn\u0027t have been able to solve this problem. \u003c/p\u003e\u003cp\u003eThis is called \u003ca href\u003d\"http://en.wikipedia.org/wiki/Eulerian_number\"\u003eeulerian number\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://pastebin.com/D1zP8i4z\"\u003ehttp://pastebin.com/D1zP8i4z\u003c/a\u003e\u003c/p\u003e\u003ch4\u003eTransportation\u003c/h4\u003e\u003cp\u003eIt looks like a direct min-cost flow problem, however the cost is proportional to the square of the flow passing through an edge, to work around this we observe the following K^2 \u003d 1 + 3 + 5 + ... Thus we split each edge into C_i edges with capacities 1 and costs a_i, 3 * a_i, ....\u003c/p\u003e\u003cp\u003eTo find the answer we do K iterations of the successive shortest path algorithm for min-cost max flow, other algorithms might not work e.g cycle cancelling.\u003c/p\u003e\u003cp\u003eIt\u0027s easy to see that we can never use an edge with cost a_i * (2K+1) without using the edge with cost a_i * (2K-1) since we want to find the \u003cem\u003emin-cost\u003c/em\u003e flow, this makes our solution correct.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://pastebin.com/E17BrPDs\"\u003ehttp://pastebin.com/E17BrPDs\u003c/a\u003e\u003c/p\u003e\u003ch4\u003eEntmoot\u003c/h4\u003e\u003cp\u003eLet\u0027s do a binary search for the minimum time t, if we draw a circle around each point where we can reach from this point to anywhere in the circle, then for all Ents to reach some point after t units of time the intersection of all those circles has to be none empty (it could have zero area but there must be a common point).\u003c/p\u003e\u003cp\u003eBut finding the region of intersection of multiple circles is a painful tasks, however we know for sure that this region is bounded by some arcs and some points, and those points are points of circle circle intersection, thus to solve the problem we do circle circle intersection for all pairs of circles we drawn, then we check if there\u0027s a point of intersection that is inside/or on boundary of ALL circles, if so then All the Ents can reach this point within time t.\u003c/p\u003e\u003cp\u003eIslam has solved this problem using nested ternary search here\u0027s his code: \u003ca href\u003d\"http://pastebin.com/mwjrg0k8\"\u003ehttp://pastebin.com/mwjrg0k8\u003c/a\u003e\u003c/p\u003e\u003ch4\u003eMove to front\u003c/h4\u003e\u003cp\u003eMove to front works as follows, create a list of integers from 1 to max(a[0]), now start at 0 to encode a[0] we find it\u0027s position in the list we created, this is it\u0027s encoding, then we move a[i] to front in this list\u003cbr /\u003e for example\u003cbr /\u003e a \u003d 3 2 3 1\u003cbr /\u003e created list 1, 2, 3 \u003cbr /\u003e a[1] \u003d 3, position \u003d 3, encoded as 3 then move to front \u003cbr /\u003e created list 3, 1, 2 \u003cbr /\u003e a[2] \u003d 2, position \u003d 3, encoded as 3 then move to front \u003cbr /\u003e created list 2, 3, 1 \u003cbr /\u003e a[3] \u003d 3, position \u003d 2, encoded as 2 then move to front \u003cbr /\u003e created list 3, 2, 1 \u003cbr /\u003e a[4] \u003d 1, position \u003d 3, encoded as 3 then move to front \u003cbr /\u003e thus the resulting encoded array is 3, 3, 2, 3 \u003cbr /\u003e \u003c/p\u003e\u003cp\u003eNow how do we implement this ? I\u0027ll describe to approaches the first uses a treap, treap is a very powerful data structure whatever you can do with a segment tree, plus you can see a treap as a powerful array, where you can do reverse(L, R) or remove(L, R) and append it to the end/front.\u003c/p\u003e\u003cp\u003eA treap is a binary search tree and in same time a heap, where each node has a key and priority, where nodes with higher priority are on top and nodes with lower priority are on the bottom, it was proven that if we assign priorities at random we\u0027ll end up with a random binary search tree achieving logarithmic bounds for search/insertions and deletions.\u003c/p\u003e\u003cp\u003eTo implement the treap we do all operations using two main operations\u003c/p\u003e\u003cp\u003esplit(T, k): splits a binary search tree into two binary search trees one with all keys \u0026lt; k and another with all keys \u0026gt;\u003d k, this can be implemented in O(logn) if the tree is balanced.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003emerge(T_0, T_1): takes two binary search trees such that all nodes in T_0 \u0026lt; k and all nodes in T_1 \u0026gt;\u003d k merges those into a new binary search tree, this can be implemented in O(logn) as well.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eSo far we\u0027ve done nothing interesting, just a boring binary search tree with insertions/deletions and searches, maybe we can add the subtree size in each node and query the kth element or get the rank of some key.\u003c/p\u003e\u003cp\u003eNow observing how split and merge works, first split splits the tree into two trees such that if you append the inorder traversal of the second tree to the inorder traversal of the first tree you get the inorder traversal of the whole tree.\u003c/p\u003e\u003cp\u003eMerge works in the same way, if you merge T_0, with T_1 you get a tree whose inorder traversal is the inorder traversal of T_0 appended to T_1.\u003c/p\u003e\u003cp\u003eNow how to turn this tree into a magical array ? we aim for the following: If we do inorder traversal on the tree we obtain the array. we want to be able to change positions of elements in this array quickly.\u003c/p\u003e\u003cp\u003eThe key idea is to get rid of keys and use implicit keys, the implicit key of the node is it\u0027s index in the array, also the number of elements before this node in the in order traversal of the tree.\u003c/p\u003e\u003cp\u003eNow if we want to change the array by moving the first K elements to the end, we setup a split that splits the binary search tree into two trees where the first tree contains the first K elements, and the second has the rest.\u003c/p\u003e\u003cp\u003eThen we do a merge by merging the second tree with the first tree. You can read more about this on emaxx or ask in comments so I can write more.\u003c/p\u003e\u003cp\u003enow back to the problem we know how to create a magical array where we can change the positions of elements in O(logn), but the problem is how do we find the element we\u0027re looking for ? i.e how do we find the position of 3 for example ? It\u0027s easy when you create a node and write a value 3 in it, save a pointer to this node somewhere, also keep parent pointers in the nodes themselves.\u003c/p\u003e\u003cp\u003eHere\u0027s the code: \u003ca\u003ehttp://pastebin.com/u0nMMPZv\u003cbr /\u003e\u003c/a\u003e Now another and probably easier way to solve this problem is to use a segment tree or a binary indexed tree along with a couple of arrays.\u003c/p\u003e\u003cp\u003eLet\u0027s first compress the input array such that the numbers all range from 0 to 10^5 — 1, also let\u0027s create two arrays, \u003c/p\u003e\u003cp\u003earray X is an array of size max(a[i]) array Y is an array of size n + max(a[i]), and we write numbers from 0 to max(a[i]) in the suffix of that array. X[i] contains the index of i in Y.\u003c/p\u003e\u003cp\u003eNow moving an element to front is as easy as moving it in Y to the first empty place, and changing it\u0027s index in X, but how do we figure out how many elements are before this element ? for this we can use a binary indexed tree or a segment tree with 0\u0027s and 1\u0027s where 0 means no element here, 1 means element here.\u003c/p\u003e\u003ch4\u003eTV Show\u003c/h4\u003e\u003cp\u003eFirst notice that one word suits for two rows then it must be removed since characters in each column must be distinct.\u003c/p\u003e\u003cp\u003eNow the problem becomes a direct 2-sat problem, for each row it can take either this or that, and that might contradict with that... Code: \u003ca\u003ehttp://pastebin.com/5GsXvrDL\u003cbr /\u003e\u003c/a\u003e Another way to solve this problem is greedy method\u003c/p\u003e\u003c/div\u003e","tags":[]}}