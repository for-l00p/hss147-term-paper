{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1429632105,"rating":127,"authorHandle":"Burunduk1","modificationTimeSeconds":1429646896,"id":17507,"title":"\u003cp\u003eПолиномиальные хеши\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eДобрый день.\u003c/p\u003e\u003cp\u003eЭто пост о мелочах в реализации хешей.\u003c/p\u003e\u003cp\u003eСегодня ребята гуглили \u0026quot;как писать полиномиальные хеши\u0026quot;, но нагулили лишь две ссылки на тему \u0026quot;как не надо писать полиномиальные хеши\u0026quot; — \u003ca href\u003d\"http://e-maxx.ru/algo/string_hashes\"\u003ee-maxx\u003c/a\u003e и \u003ca href\u003d\"http://habrahabr.ru/post/142589/\"\u003ehabr\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eА можно писать иначе — \u003ca href\u003d\"http://acm.math.spbu.ru/~sk1/algo/hash/hash.cpp.html\"\u003eshort\u003c/a\u003e и \u003ca href\u003d\"http://acm.math.spbu.ru/~sk1/algo/hash/HashStrComparator_simple.cpp.html\"\u003efull\u003c/a\u003e. Последняя версия устойчива к антихеш тестам, её \u003cstrong\u003eможно копипастить\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eТеперь подробно. Есть два способа. Оба для краткости будут написаны по модулю \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e64\u003c/sup\u003e\u003c/span\u003e, то есть падают на строке \u003ca href\u003d\"http://codeforces.ru/blog/entry/4898\"\u003eТуе-Морса\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eОбщая часть:\u003c/strong\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003econst int P \u003d 239017; // Если брать простой модуль, здесь стоит писать rand()!\n// s - строка, n - её длина\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eПервый способ (я пишу так):\u003c/strong\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// deg[] \u003d {1, P, P^2, P^3, ...}\n// h[] \u003d {0, s[0], s[0]*P + s[1], s[0]*P^2 + s[1]*P + s[2], ...}\nunsigned long long h[n + 1], deg[n + 1];\nh[0] \u003d 0, deg[0] \u003d 1;\nfor (int i \u003d 0; i \u0026lt; n; i++) {\n  h[i + 1] \u003d h[i] * P + s[i];\n  deg[i + 1] \u003d deg[i] * P;\n}\nauto get_hash \u003d [\u0026amp;]( int l, int r ) { // [l..r]\n  return h[r + 1] - h[l] * deg[r - l + 1];\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eВторой способ:\u003c/strong\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// deg[] \u003d {1, P, P^2, P^3, ...}\n// h[] \u003d {s[0], s[0] + s[1]*P, s[0] + s[1]*P + s[2]*P^2, ...}\nunsigned long long h[n], deg[n];\nh[0] \u003d s[0], deg[0] \u003d 1;\nfor (int i \u003d 1; i \u0026lt; n; i++) {\n  deg[i] \u003d deg[i - 1] * P;\n  h[i] \u003d h[i - 1] + s[i] * deg[i];\n}\nauto get_hash \u003d [\u0026amp;]( int l, int r ) { // [l..r]\n  if (l \u003d\u003d 0)\n    return h[r];\n  return h[r] - h[l - 1];\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОтличия здесь два\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eНаправление \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003ci\u003eP\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sup\u003e + \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003ci\u003eP\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - 2\u003c/sup\u003e + ... + \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e или \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e + \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003ci\u003eP\u003c/i\u003e + \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003ci\u003eP\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e + ... + \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e\u003ci\u003eP\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e?\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВ первом способе, чтобы сравнить две строки [l1..r1] и [l2..r2], достаточно написать \u003ccode\u003eget_hash(l1, r1) \u003d\u003d get_hash(l2, r2)\u003c/code\u003e. То есть, функция get_hash честно возвращает хеш. Можно, например, найти количество различных подстрок, положив все хеши в хеш-таблицу.\u003c/p\u003e\u003cp\u003eВо втором случае функция get_hash на самом деле возвращает не хеш, а хеш, домноженный на некоторую степень P, поэтому придётся писать так \u003ccode\u003edeg[r2] * get_hash(l1, r1) \u003d\u003d deg[r1] * get_hash(l2, r2)\u003c/code\u003e (на e-maxx правда чуть страшнее). А использовать хеши иначе не получится. Можно модифицировать функцию \u003ccode\u003eget_hash\u003c/code\u003e, использовать честный хеш \u003ccode\u003etrue_hash(l, r) \u003d deg[n - r - 1] * get_hash(l, r)\u003c/code\u003e, но у такого способа есть минус — мы предполагаем, что знаем максимальную длину строки. Это не всегда удобно, а при онлайн-решениях иногда и не правда.\u003c/p\u003e\u003cp\u003eУ второго способа ещё есть вариация с делением по модулю. Так писать точно не нужно.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eС чего начинать массив \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e? С \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e или с \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[0]\u003c/span\u003e?\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЕсли мы начинаем с \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, мы получаем более короткий и быстрый код (да, да, чтобы if-у выполниться, нужно время!). Оценивая скорость, заметьте, что умножений будет столько же.\u003c/p\u003e\u003cp\u003eЕсли же мы начинаем в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[0]\u003c/span\u003e, то получаем массив длины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, то есть экономим \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e памяти.\u003c/p\u003e\u003cp\u003eКак лучше, решайте сами. Я всем рекламирую первый вариант. Если есть конструктивные замечания или альтернативные версии, буду рад услышать.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eВыбор простого модуля\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eОтдельный привет всем, кто говорит \u0026quot;число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e можно выбирать любым\u0026quot;. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e должно быть больше размера алфавита. Если это так, то хеш, вычисленный без взятия по модулю, как длинное число, инъективен. Иначе уже на этапе вычисления без модуля могут быть коллизии. Примеры, как нельзя делать: алфавит \u0026quot;a..z\u0026quot;, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e \u003d 13\u003c/span\u003e, алфавит ASCII 33..127, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e \u003d 31\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eP.S.\u003c/strong\u003e Кстати, как правильно пишется \u0026quot;хеш\u0026quot;, или \u0026quot;хэш\u0026quot;? Моя версия — \u0026quot;хеш\u0026quot;.\u003c/p\u003e\u003cp\u003eUPD: Подсказывают, что, если писать без unsigned, получится Undefined Behaviour. Спасибо Лёше Левину.\u003c/p\u003e\u003cp\u003eUPD: Чтобы хеш точно нельзя было сломать, можно точку P выбирать как max(Σ, rand()). Версия \u003ca href\u003d\"http://acm.math.spbu.ru/~sk1/algo/hash/HashStrComparator_simple.cpp.html\"\u003efull\u003c/a\u003e пропатчилась. Спасибо \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Kaban-5\" title\u003d\"Международный мастер Kaban-5\"\u003eKaban-5\u003c/a\u003e, \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/nk.karpov\" title\u003d\"Мастер nk.karpov\"\u003enk.karpov\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e","tags":["hash","хеш","хеширование","polynomial hash","красивый код"]}}