{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1413656102,"rating":0,"authorHandle":"PrashantM","modificationTimeSeconds":1413656384,"id":14333,"title":"\u003cp\u003eSSN Coding Contest — 2 (Editorial)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA — IQ Test (\u003ca href\u003d\"//codeforces.com/problemset/problem/25/A\"\u003ehttp://codeforces.com/problemset/problem/25/A\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eFind the number of even and odd numbers. Print the occurence of the even/odd number depending on which occurs only once.\u003c/p\u003e\u003cp\u003eB — Ksusha and Array (\u003ca href\u003d\"//codeforces.com/problemset/problem/299/A\"\u003ehttp://codeforces.com/problemset/problem/299/A\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eFind the minimum number in the array, and check if it divides all numbers in the array.\u003c/p\u003e\u003cp\u003eC — T-primes (\u003ca href\u003d\"//codeforces.com/group/957fuDQyd8/contest/201599/problem/C\"\u003ehttp://codeforces.com/group/957fuDQyd8/contest/201599/problem/C\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eLot of ways to do the problem:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eHave a boolean array filled with 1s and 0s depending on whether the index is a prime number. Can be calculated efficiently using sieve of Eratosthenes (\u003ca\u003ehttp://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\u003c/a\u003e. Now we know the given number has to be a perfect square, and the square root must be a prime. Use this check to find if a number is a perfect square: \u0026quot;(double)(long)sqrt(n) \u003d\u003d sqrt(n)\u0026quot;. And check if sqrt(n) is a prime number from the boolean array.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eAs you use the sieve to calculate primes, store the square of all primes in a set (\u003ca href\u003d\"http://www.cplusplus.com/reference/set/set/\"\u003ehttp://www.cplusplus.com/reference/set/set/\u003c/a\u003e) and as you get numbers, check if the number is present in the set.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eD — Fence (\u003ca href\u003d\"//codeforces.com/problemset/problem/363/B\"\u003ehttp://codeforces.com/problemset/problem/363/B\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eOne way is to calculate prefix sums and calculate minimum segment in linear time. Another is to update the current sum as you move to the next index by subtracting the first height and adding the new height.\u003c/p\u003e\u003cp\u003eE — Suffix Structures (\u003ca href\u003d\"//codeforces.com/problemset/problem/448/B\"\u003ehttp://codeforces.com/problemset/problem/448/B\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eYou want convert string s to t. Have a frequency table(array of size 26 representing \u0027a\u0027 — \u0027z\u0027) for the characters of s and t separately. denote it by sa,ta. if ta[i] \u0026gt; sa[i] for some i, you will need a tree, hence check for this condition first so that you can terminate your program the moment you understand a tree is needed. Other cases: if sa[i] \u0026gt; ta[i] for some i, you will need automaton. Now for \u0026quot;arrays\u0026quot; you need to check if t forms a \u0026quot;subsequence\u0026quot; of s. For this consider the following code: \u003c/p\u003e\u003cp\u003eint ptr \u003d 0;\u003c/p\u003e\u003cp\u003efor(int i \u003d 0;i \u0026lt; s.length();i++){\u003c/p\u003e \u003cpre\u003eif(s[i] \u003d\u003d t[ptr]) {\n        ptr++;\n    }\n    if(ptr \u003d\u003d t.length()) {\n        break;\n    }\n}\u003c/pre\u003e\u003cp\u003eif ptr is less than the length of t, you will need \u0026quot;arrays\u0026quot;. \u003c/p\u003e\u003c/div\u003e","tags":[]}}