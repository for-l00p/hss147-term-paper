{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1467251303,"rating":94,"authorHandle":"M.Mahdi","modificationTimeSeconds":1467656937,"id":45770,"title":"\u003cp\u003eCodeforces Round #360 Editorial [+ Challenges!]\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi again!\u003c/p\u003e\u003cp\u003eIf you notice typos or errors, please send a private message.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/contest/688/problem/A\"\u003e688A: Opponents\u003c/a\u003e\u003c/h3\u003e\u003ch4\u003eSolution\u003c/h4\u003e\u003cp\u003eLet\u0027s find out for each row of the given matrix if it is completely consisting of \u003cem\u003eones\u003c/em\u003e or not. Make another array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecanWin\u003c/i\u003e\u003c/span\u003e, and set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecanWin\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e equal to one if the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th row consists at least one \u003cem\u003ezero\u003c/em\u003e. Then the problem is to find the maximum subsegment of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecanWin\u003c/i\u003e\u003c/span\u003e array, consisting only ones. It can be solved by finding for each element of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecanWin\u003c/i\u003e\u003c/span\u003e, the closest zero to it from left. The complexity of this solution is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003end\u003c/i\u003e)\u003c/span\u003e, but the limits allow you to solve the problem in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003end\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e by iterating over all possible subsegments and check if each one of them is full of \u003cem\u003eones\u003c/em\u003e or not.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\t//     . .. ... .... ..... be name khoda ..... .... ... .. .     \\\\\n\n#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\ninline int in() { int x; scanf(\u0026quot;%d\u0026quot;, \u0026amp;x); return x; }\nconst int N \u003d 202;\n\nint a[N][N];\n\nint main()\n{\n\tint n \u003d in(), d \u003d in();\n\tint ans \u003d 0, cur \u003d 0;\n\tfor(int i \u003d 0; i \u0026lt; d; i++)\n\t{\n\t\tstring s;\n\t\tcin \u0026gt;\u0026gt; s;\n\t\tbool iff \u003d 0;\n\t\tfor(int j \u003d 0; j \u0026lt; n; j++)\n\t\t\tiff |\u003d (s[j] \u003d\u003d \u00270\u0027);\n\t\tif(iff)\n\t\t\tcur++;\n\t\telse\n\t\t\tcur \u003d 0;\n\t\tans \u003d max(ans, cur);\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ePython code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003en, d \u003d map(int, raw_input().split())\ncur \u003d 0\nans \u003d 0\nfor i in range(d):\n    s \u003d raw_input()\n    if (s \u003d\u003d \u00271\u0027 * n):\n        cur \u003d 0\n    else:\n        cur +\u003d 1\n    ans \u003d max(ans, cur)\nprint ans\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/contest/688/problem/B\"\u003e688B: Lovely Palindromes\u003c/a\u003e\u003c/h3\u003e\u003ch4\u003eHint\u003c/h4\u003e\u003cp\u003eTry to characterize even-length palindrome numbers.\u003c/p\u003e\u003ch4\u003eSolution\u003c/h4\u003e\u003cp\u003eFor simplifications, in the following solution we define \u003cem\u003elovely integer\u003c/em\u003e as an even-length positive palindrome number.\u003c/p\u003e\u003cp\u003eAn even-length positive integer is lovely if and only if the first half of its digits is equal to the reverse of the second half.\u003c/p\u003e\u003cp\u003eSo if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e are two different \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e-digit lovely numbers, then the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e digits of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e differ in at least one position.\u003c/p\u003e\u003cp\u003eSo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e is smaller than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e if and only if the first half of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e is smaller than the the first half of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eAnother useful fact: The first half of a a lovely number can be any arbitrary positive integer.\u003c/p\u003e\u003cp\u003eUsing the above facts, it\u0027s easy to find the first half of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e-th lovely number — it exactly equals to integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. When we know the first half of a lovely number, we can concatenate it with its reverse to restore the lovely integer. To sum up, the answer can be made by concatenating \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and it\u0027s reverse together.\u003c/p\u003e\u003cp\u003eThe complexity of this solution is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\t//     . .. ... .... ..... be name khoda ..... .... ... .. .     \\\\\n\n#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\ninline int in() { int x; scanf(\u0026quot;%d\u0026quot;, \u0026amp;x); return x; }\nconst long long N \u003d 2002;\n\nint main()\n{\n\tstring s;\n\tcin \u0026gt;\u0026gt; s;\n\tcout \u0026lt;\u0026lt; s;\n\treverse(s.begin(), s.end());\n\tcout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ePython code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003es \u003d raw_input()\nprint s + \u0027\u0027.join(reversed(s))\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003eChallenge\u003c/h4\u003e\u003cp\u003eWhat if you were asked to find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e-th positive palindrome number? \u003cspan class\u003d\"tex-span\"\u003e(1 ≤ \u003ci\u003en\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e)\u003c/span\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/contest/687/problem/A\"\u003e687A: NP-Hard Problem\u003c/a\u003e\u003c/h3\u003e\u003ch4\u003eHint\u003c/h4\u003e\u003cp\u003eTry to use all of the vertices. Then look at the two vertex covers together in the graph and see how it looks like.\u003c/p\u003e\u003ch4\u003eSolution\u003c/h4\u003e\u003cp\u003eLooking at the two vertex covers in the graph, you see there must be no edge \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003euv\u003c/i\u003e\u003c/span\u003e that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e are in the same vertex cover. So the two vertex covers form a bipartition of the graph, so the graph have to be bipartite. And being bipartite is also sufficient, you can use each part as a vertex cover. Bipartition can be found using your favorite graph traversing algorithm(BFS or DFS). \u003ca href\u003d\"http://stackoverflow.com/questions/30486784/how-to-find-if-a-graph-is-bipartite\"\u003eHere\u003c/a\u003e is a tutorial for bipartition of undirected graphs.\u003c/p\u003e\u003cp\u003eThe complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\t//     . .. ... .... ..... be name khoda ..... .... ... .. .     \\\\\n\n#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\ninline int in() { int x; scanf(\u0026quot;%d\u0026quot;, \u0026amp;x); return x; }\nconst int N \u003d 120021;\n\nvector \u0026lt;int\u0026gt; vc[2];\nvector \u0026lt;int\u0026gt; g[N];\nint mark[N];\n\nbool dfs(int v, int color \u003d 2)\n{\n\tmark[v] \u003d color;\n\tvc[color - 1].push_back(v);\n\tfor(int u : g[v])\n\t{\n\t\tif(!mark[u] \u0026amp;\u0026amp; dfs(u, 3 - color))\n\t\t\t\treturn 1;\n\t\tif(mark[u] !\u003d 3 - color)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint n, m;\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tfor(int i \u003d 0; i \u0026lt; m; i++)\n\t{\n\t\tint u \u003d in() - 1;\n\t\tint v \u003d in() - 1;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t\tif(!mark[i])\n\t\t{\n\t\t     if(g[i].empty())\n\t\t          continue;\n\t\t     if(dfs(i))\n\t\t\t{\n\t\t\t\tcout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tfor(int i \u003d 0; i \u0026lt; 2; i++)\n\t{\n\t\tcout \u0026lt;\u0026lt; vc[i].size() \u0026lt;\u0026lt; endl;\n\t\tfor(int v : vc[i])\n\t\t\tcout \u0026lt;\u0026lt; v + 1 \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n\t\tcout \u0026lt;\u0026lt; endl;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003eChallenge\u003c/h4\u003e\u003cp\u003eIn the same constraints, what if you were asked to give two disjoint edge covers from the given graph? (The edge covers must be edges-disjoint but they can have common vertex.)\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/contest/687/problem/B\"\u003e687B: Remainders Game\u003c/a\u003e\u003c/h3\u003e\u003ch4\u003eHint\u003c/h4\u003e\u003cp\u003eAssume the answer of a test is \u003cem\u003eNo\u003c/em\u003e. There must exist a pair of integers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e such that both of them have the same remainders after dividing by any \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, but they differ in remainders after dividing by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Find more facts about \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e!\u003c/p\u003e\u003ch4\u003eSolution\u003c/h4\u003e\u003cp\u003eConsider the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e from the hint part. We have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e ≡ 0\u003c/span\u003e (\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ff/30/ff30679f15db04b6fa550cd845643b06373c3f5c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e) for each \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eSo:\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/96/bb/96bb95dcf9a92a118e2db84ebd654bbe8851b77a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eWe also have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3f/c9/3fc95e978dc47c6eb29da122a3c871f7ccebee9c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/06/24/062430294b09c23f21879412d86a08b007e234bb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e). As a result:\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ea/27/ea273613a4710e67ed391141bf44963bdf40d35f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eWe\u0027ve found a necessary condition. And I have to tell you it\u0027s also sufficient!\u003c/p\u003e\u003cp\u003eAssume \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ea/27/ea273613a4710e67ed391141bf44963bdf40d35f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, we are going to prove there exists \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e ≡ 0\u003c/span\u003e (\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ff/30/ff30679f15db04b6fa550cd845643b06373c3f5c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e) (for each \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e), and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3f/c9/3fc95e978dc47c6eb29da122a3c871f7ccebee9c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/06/24/062430294b09c23f21879412d86a08b007e234bb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e). \u003c/p\u003e\u003cp\u003eA possible solution is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u003d \u003ci\u003elcm\u003c/i\u003e(\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u003d 2 × \u003ci\u003elcm\u003c/i\u003e(\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e, so the sufficiency is also proved.\u003c/p\u003e\u003cp\u003eSo you have to check if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elcm\u003c/i\u003e(\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e is divisible by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, which could be done using prime factorization of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e values.\u003c/p\u003e\u003cp\u003eFor each integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e smaller than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eMAXC\u003c/i\u003e\u003c/span\u003e, find it\u0027s greatest prime divisor \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egpd\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e using \u003ca href\u003d\"https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\"\u003esieve of Eratosthenes\u003c/a\u003e in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ec/cc/eccc8272c4c95cac2b23b3b5afe0233d8abc168c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003c/p\u003e\u003cp\u003eThen using \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egpd\u003c/i\u003e\u003c/span\u003e array, you can write the value of each coin as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sup\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sup\u003e...\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e\u003c/sup\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is a prime integer and \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e holds. This could be done in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f9/2d/f92dfdecd43e38678fea5548ea4c04a76fbf297f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e by moving from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c9/5e/c95e45a92a40225910363cf7ba61f35995695070.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and adding \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egpd\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e\u003c/span\u003e to the answer. And you can factorize \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e by the same way. Now for every prime \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/53/e9/53e9176be7ae8bb7787fdf3af4de8e20c1badc0a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, see if there exists any coin \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e that the power of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e in the factorization of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is not smaller than the power of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e in the factorization of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eComplexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9b/df/9bdf26702c9ff9ad7902bf2eaae812c4bf1e5ae5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\t//     . .. ... .... ..... be name khoda ..... .... ... .. .     \\\\\n\n#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\ninline int in() { int x; scanf(\u0026quot;%d\u0026quot;, \u0026amp;x); return x; }\nconst long long N \u003d 1200021;\n\nint cntP[N], isP[N];\n\nint main()\n{\n\tfor(int i \u003d 2; i \u0026lt; N; i++)\n\t\tif(!isP[i])\n\t\t\tfor(int j \u003d i; j \u0026lt; N; j +\u003d i)\n\t\t\t\tisP[j] \u003d i;\n\tint n \u003d in(), k \u003d in();\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tint x \u003d in();\n\t\twhile(x \u0026gt; 1)\n\t\t{\n\t\t\tint p \u003d isP[x];\n\t\t\tint cnt \u003d 0;\n\t\t\twhile(x % p \u003d\u003d 0)\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tx /\u003d p;\n\t\t\t}\n\t\t\tcntP[p] \u003d max(cntP[p], cnt);\n\t\t}\n\t}\n\tbool ok \u003d 1;\n\twhile(k \u0026gt; 1)\n\t{\n\t\tok \u0026amp;\u003d (cntP[isP[k]] \u0026gt; 0);\n\t\tcntP[isP[k]]--;\n\t\tk /\u003d isP[k];\n\t}\n\tcout \u0026lt;\u0026lt; (ok ? \u0026quot;Yes\\n\u0026quot; : \u0026quot;No\\n\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eAnd a nice implementation by \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Reyna\" title\u003d\"International Grandmaster Reyna\"\u003eReyna\u003c/a\u003e: \u003ca href\u003d\"/contest/687/submission/18789803\" title\u003d\"Submission 18789803 by Reyna\"\u003e18789803\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/contest/687/problem/C\"\u003e687C: The values you can make\u003c/a\u003e\u003c/h3\u003e\u003ch4\u003eHint\u003c/h4\u003e\u003cp\u003eUse dynamic programming.\u003c/p\u003e\u003ch4\u003eSolution\u003c/h4\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be true if and only if there exists a subset of the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e coins with sum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, that has a subset with sum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. There are 3 cases to handle:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eThe \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th coin is not used in the subsets.\u003c/li\u003e   \u003cli\u003eThe \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th coin is used in the subset to make \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, but it\u0027s not used in the subset of this subset.\u003c/li\u003e   \u003cli\u003eThe \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th coin is used in both subsets.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e \u003ci\u003eOR\u003c/i\u003e \u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1, \u003ci\u003ej\u003c/i\u003e - \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e \u003ci\u003eOR\u003c/i\u003e \u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1, \u003ci\u003ej\u003c/i\u003e - \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ek\u003c/i\u003e - \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enk\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\t\t//\t   - -- --- ---- -----be name khoda----- ---- --- -- -\t\t\\\\\n\n#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\ninline int in() { int x; scanf(\u0026quot;%d\u0026quot;, \u0026amp;x); return x; }\nconst int N \u003d 505;\n\nbool dp[2][N][N];\n\nint main()\n{\n\tint n, k;\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k;\n\tdp[0][0][0] \u003d 1;\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++)\n\t{\n\t\tint now \u003d i % 2;\n\t\tint last \u003d 1 - now;\n\t\tint x \u003d in();\n\t\tfor(int j \u003d 0; j \u0026lt;\u003d k; j++)\n\t\t\tfor(int y \u003d 0; y \u0026lt;\u003d j; y++)\n\t\t\t{\n\t\t\t\tdp[now][j][y] \u003d dp[last][j][y];\n\t\t\t\tif(j \u0026gt;\u003d x)\n\t\t\t\t{\n\t\t\t\t    dp[now][j][y] |\u003d dp[last][j - x][y];\n\t\t\t\t    if(y \u0026gt;\u003d x)\n    \t\t\t\t\tdp[now][j][y] |\u003d dp[last][j - x][y - x];\n\t\t\t\t}\n\t\t\t}\n\t}\n\tvector \u0026lt;int\u0026gt; res;\n\tfor(int i \u003d 0; i \u0026lt;\u003d k; i++)\n\t\tif(dp[n % 2][k][i])\n\t\t\tres.push_back(i);\n\tcout \u0026lt;\u0026lt; res.size() \u0026lt;\u0026lt; endl;\n\tfor(int x : res)\n\t\tcout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n\tcout \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003eChallenge\u003c/h4\u003e\u003cp\u003eIn the same constraints, output the numbers you can never not make! Formally, the values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e such that for every subset of coins with the sum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, there exists a subset of this subset with the sum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/contest/687/problem/D\"\u003e687D: Dividing Kingdom II\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eUnfortunately, our mistake in setting the constrains for this problem made it possible to get Ac with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eqm\u003c/i\u003e)\u003c/span\u003e solution. We hope you accept our apology. \u003c/p\u003e\u003ch4\u003eHint\u003c/h4\u003e\u003cp\u003eConsider the following algorithm to answer a single query: Sort the edges and add them one by one to the graph in decreasing order of their weights. The answer is weight of the first edge, which makes an odd cycle in the graph. Now show that there are only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e effective edges, which removing them may change the answer of the query. Use this idea to optimize your solution.\u003c/p\u003e\u003ch4\u003eSolution\u003c/h4\u003e\u003cp\u003eFirst, let’s solve a single query separately. Sort edges from interval [l, r] in decreasing order of weights. Using \u003cem\u003edsu\u003c/em\u003e, we can find longest prefix of these edges, which doesn’t contains odd cycle. (Graph will be bipartite after adding these edges.) The answer will be weight of the next edge. (We call this edge “bottleneck”).\u003c/p\u003e\u003cp\u003eWhy it\u0027s correct? Because if the answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e, then the we can divide the graph in a way that none of the edges in the same part have value greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e. So the graph induced by the edges with value greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e must be bipartite. And if this graph is bipartite, then we can divide the graph into two parts as the bipartition, so no edge with value greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e will be in the same part, and the answer is at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLet\u0027s have a look at this algorithm in more details. For each vertex, we keep two values in dsu: Its parent and if its part differs from its parent or not. We keep the second value equal to \u0026quot;parity of length of the path in original graph, between this node and its parent\u0026quot;. We can divide the graph anytime into two parts, walking from one vertex to its parent and after reaching the root, see if the starting vertex must be in the same part as the root or not.\u003c/p\u003e\u003cp\u003eIn every connected component, there must not exist any edge with endpoints in the same part.\u003c/p\u003e\u003cp\u003eAfter sorting the edges, there are 3 possible situations for an edge when we are adding it to the graph:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eThe endpoints of this edge are between two different components of the current graph. Now we must merge these two components, and update the part of the root of one of the components.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThe endpoints of this edge are in the same component of the current graph, and they are in different parts of this component. There is nothing to do.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThe endpoints of this edge are in the same component of the current graph, and they are also in the same part of this component. This edge is the \u0026quot;bottleneck\u0026quot; and we can\u0027t keep our graph bipartite after adding it, so we terminate the algorithm.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eWe call the edges of the first and the third type \u0026quot;valuable edges\u0026quot;.\u003c/p\u003e\u003cp\u003eThe key observation is: If we run above algorithm on the valuable edges, the answer remains the same.\u003c/p\u003e\u003cp\u003eProof idea: The edges of the first type are spanning trees of connected components of the graph, and with a spanning tree of a bipartite graph, we can uniquely determine if two vertices are in the same part or not.\u003c/p\u003e\u003cp\u003eSo if we can ignore all other edges and run our algorithm on these valuable edges, we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e edges instead of original \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e and the answer is the same.\u003c/p\u003e\u003cp\u003eWe answer the queries using a segment tree on the edges. In each node of this tree, we run the above algorithm and memorize the valuable edges. By implementing carefully (described \u003ca href\u003d\"//codeforces.com/blog/entry/45770?#comment-303336\"\u003ehere\u003c/a\u003e), making the segment tree could be done in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d8/d9/d8d93fe2e67dbde72ecb63f9b4c968b956c6e9c7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eNow for each query \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e, you can decompose \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e into \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e segments in segment tree and each one has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e valuable edges. Running the naive algorithm on these edges lead to an \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e solution for each query, which fits in time limit.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\t//     . .. ... .... ..... be name khoda ..... .... ... .. .     \\\\\n\n#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\n\ninline int in() { int x; scanf(\u0026quot;%d\u0026quot;, \u0026amp;x); return x; }\nconst int N \u003d 2002, M \u003d (1 \u0026lt;\u0026lt; 20), Q \u003d 1001, S \u003d 2 * M;\n\n#define rank PAP\n\nstruct Edge\n{\n\tint u, v, w;\n\tEdge(int u \u003d 0, int v \u003d 0, int w \u003d 0):v(v), u(u), w(w) { }\n\tbool operator \u0026lt;(const Edge \u0026amp;e) const { return w \u0026lt; e.w; }\n};\n\nstruct Segment\n{\n\tint l, r;\n\tSegment(int l \u003d 0, int r \u003d 0): l(l), r(r) { }\n};\n\ntypedef vector \u0026lt;Edge\u0026gt; Edges;\n\nint n, m, q;\nEdge es[M];\nEdges seg[S];\nSegment range[S];\nint par[N], cost[N], rank[N];\n\nSegment merge(Segment l, Segment r) { return Segment(l.l, r.r); }\n\nvoid clear(Edges \u0026amp;es)\n{\n\tfor(Edge e : es)\n\t{\n\t\tpar[e.v] \u003d par[e.u] \u003d -1;\n\t\tcost[e.v] \u003d cost[e.u] \u003d 0;\n\t\trank[e.v] \u003d rank[e.u] \u003d 1;\n\t}\n}\n\nint root(int v) \n{ \n\tif(par[v] \u003d\u003d -1)\n\t\treturn v;\n\tint u \u003d root(par[v]);\n\tcost[v] ^\u003d cost[par[v]];\n\treturn par[v] \u003d u;\n}\n\nint parity(int v)\n{\n\troot(v);\n\treturn cost[v];\n}\n\nint merge(Edge e)\n{\n\tif(rank[root(e.u)] \u0026gt; rank[root(e.v)])\n\t\tswap(e.u, e.v);\n\tif(root(e.u) \u003d\u003d root(e.v))\n\t{\n\t\tif(parity(e.u) \u003d\u003d parity(e.v))\n\t\t\treturn 2;\n\t\treturn 0;\n\t}\n\tint u \u003d root(e.u);\n\tint v \u003d root(e.v);\n\tcost[u] ^\u003d (parity(e.u) ^ 1 ^ parity(e.v));\n\tpar[u] \u003d root(v);\n\trank[v] +\u003d rank[u];\n\treturn 1;\n}\n\nbool hasOddCycle;\n\nEdges merge(Edges \u0026amp;a, Edges \u0026amp;b)\n{\n\tEdges c;\n\tmerge(a.begin(), a.end(), b.begin(), b.end(), back_inserter(c));\n\tclear(c);\n\tEdges res;\n\tfor(int i \u003d c.size() - 1; i \u0026gt;\u003d 0; i--)\n\t{\n\t\tint x \u003d merge(c[i]);\n\t\tif(x)\n\t\t\tres.push_back(c[i]);\n\t\tif(x \u003d\u003d 2)\n\t\t{\n\t\t\thasOddCycle \u003d 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treverse(res.begin(), res.end());\n\treturn res;\n}\n\nvoid make()\n{\n\tfor(int i \u003d S - 1; i; i--)\n\t{\n\t\tif(i \u0026gt;\u003d M)\n\t\t{\n\t\t\trange[i] \u003d Segment(i - M, i - M + 1);\n\t\t\tif(i - M \u0026lt; m)\n\t\t\t\tseg[i].push_back(es[i - M]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\trange[i] \u003d merge(range[i * 2], range[i * 2 + 1]);\n\t\t\tseg[i] \u003d merge(seg[i * 2], seg[i * 2 + 1]);\n\t\t}\n\t}\n}\n\nint solve(Segment s)\n{\n\tEdges es;\n\thasOddCycle \u003d 0;\n\tfor(int l \u003d s.l + M, r \u003d s.r + M; l \u0026lt; r; l /\u003d 2, r /\u003d 2)\n\t{\n\t\tif(l % 2)\n\t\t\tes \u003d merge(es, seg[l++]);\n\t\tif(r % 2)\n\t\t\tes \u003d merge(es, seg[--r]);\n\t}\n\tif(hasOddCycle)\n\t\treturn es[0].w;\n\treturn -1;\n}\n\nint main()\n{\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q;\n\tfor(int i \u003d 0; i \u0026lt; m; i++)\n\t{\n\t\tes[i].u \u003d in() - 1;\n\t\tes[i].v \u003d in() - 1;\n\t\tes[i].w \u003d in();\n\t}\n\tmake();\n\twhile(q--)\n\t{\n\t\tint l \u003d in() - 1, r \u003d in();\n\t\tcout \u0026lt;\u0026lt; solve(Segment(l, r)) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/contest/687/problem/E\"\u003e687E: TOF\u003c/a\u003e\u003c/h3\u003e\u003ch4\u003eHint: What the actual problem is\u003c/h4\u003e\u003cp\u003eLooking at the code in the statement, you can see only the first edge in \u003ccode\u003eneighbors\u003c/code\u003e of each node is important. So for each vertex with at least one outgoing edge, you have to choose one edge and ignore the others. After this the graph becomes in the shape of some cycles with possible branches, and some paths. The number of \u003ccode\u003edfs\u003c/code\u003e calls equals to \u003cspan class\u003d\"tex-span\"\u003e998 × (\u003c/span\u003e sum of sizes of cycles \u003cspan class\u003d\"tex-span\"\u003e) + \u003ci\u003en\u003c/i\u003e + \u003c/span\u003e number of cycles.\u003c/p\u003e\u003ch4\u003eSolution\u003c/h4\u003e\u003cp\u003eThe goal is to minimize the sum of cycle sizes. Or, to maximize the number of vertices which are not in any cycle. Name them \u003cem\u003egood vertices\u003c/em\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eIf there exists a vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e without any outgoing edge, we can make all of the vertices that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is reachable from them good. Consider the dfs-tree from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in the reverse graph. You can choose the edge \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/19/3f/193f29a2bf83880d00786e9fd9733d318eaf5e3d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e from this tree as the first edge in \u003ccode\u003eneighbors[u]\u003c/code\u003e, in order to make all of these vertices good.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eVertices which are not in the sink strongly connected components could become good too, by choosing the edges from a path starting from them and ending in a sink strongly connected component.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIn a sink strongly connected component, there exists a path from every vertex to others. So we can make every vertex good except a single cycle, by choosing the edges in the paths from other nodes to this cycle and the cycle edges.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSo, every vertices could become good except a single cycle in every sink strongly connected component. And the length of those cycles must be minimized, so we can choose the smallest cycle in every sink strongly connected component and make every other vertices good. Finding the smallest cycle in a graph with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e-vertex and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e edges could be done in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e))\u003c/span\u003e with running a \u003cem\u003eBFS\u003c/em\u003e from every vertex, so finding the smallest cycle in every sink strongly connected component is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e))\u003c/span\u003e overall.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\t//     . .. ... .... ..... be name khoda ..... .... ... .. .     \\\\\n\n#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\n\ninline int in() { int x; scanf(\u0026quot;%d\u0026quot;, \u0026amp;x); return x; }\nconst int N \u003d 5005;\n\nint comp[N], bfsDist[N], bfsPar[N];\nvector \u0026lt;int\u0026gt; g[N], gR[N];\nbool mark[N], inCycle[N];\n\nbool dfs(int v, vector \u0026lt;int\u0026gt; *g, vector \u0026lt;int\u0026gt; \u0026amp;nodes)\n{\n\tmark[v] \u003d 1;\n\tfor(int u : g[v])\n\t\tif(!mark[u])\n\t\t\tdfs(u, g, nodes);\n\tnodes.push_back(v);\n}\n\nint findSmallestCycle(vector \u0026lt;int\u0026gt; vs)\n{\n\tvector \u0026lt;int\u0026gt; cycle;\n\tfor(int root : vs)\n\t{\n\t\tfor(int v : vs)\n\t\t{\n\t\t\tbfsDist[v] \u003d 1e9;\n\t\t\tbfsPar[v] \u003d -1;\n\t\t}\n\t\tbfsDist[root] \u003d 0;\n\t\tqueue \u0026lt;int\u0026gt; q;\n\t\tq.push(root);\n\t\tbool cycleFound \u003d 0;\n\t\twhile(q.size() \u0026amp;\u0026amp; !cycleFound)\n\t\t{\n\t\t\tint v \u003d q.front();\n\t\t\tq.pop();\n\t\t\tfor(int u : g[v])\n\t\t\t{\n\t\t\t\tif(u \u003d\u003d root)\n\t\t\t\t{\n\t\t\t\t\tcycleFound \u003d 1;\n\t\t\t\t\tint curLen \u003d bfsDist[v];\n\t\t\t\t\tif(cycle.empty() || curLen \u0026lt; cycle.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tcycle.clear();\n\t\t\t\t\t\tfor(; v !\u003d -1; v \u003d bfsPar[v])\n\t\t\t\t\t\t\tcycle.push_back(v);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(bfsDist[u] \u0026gt; bfsDist[v] + 1)\n\t\t\t\t{\n\t\t\t\t\tbfsDist[u] \u003d bfsDist[v] + 1;\n\t\t\t\t\tbfsPar[u] \u003d v;\n\t\t\t\t\tq.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cycle.size();\n}\n\nint main()\n{\n\tint n, m;\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tfor(int i \u003d 0; i \u0026lt; m; i++)\n\t{\n\t\tint u \u003d in() - 1;\n\t\tint v \u003d in() - 1;\n\t\tg[u].push_back(v);\n\t\tgR[v].push_back(u);\n\t}\n\tvector \u0026lt;int\u0026gt; order;\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t\tif(!mark[i])\n\t\t\tdfs(i, g, order);\n\n\tfill(mark, mark + n, 0);\n\tfill(comp, comp + n, -1);\n\tint inCycle \u003d 0, nCycle \u003d 0;\n\tfor(; order.size(); order.pop_back())\n\t{\n\t\tint v \u003d order.back();\n\t\tif(mark[v])\n\t\t\tcontinue;\n\t\tvector \u0026lt;int\u0026gt; curComp;\n\t\tdfs(v, gR, curComp);\n\t\tbool isSink \u003d true;\n\t\tfor(int u : curComp)\n\t\t\tcomp[u] \u003d v;\n\t\tfor(int u : curComp)\n\t\t\tfor(int k \u003d 0; k \u0026lt; g[u].size(); k++)\n\t\t\t\tif(comp[g[u][k]] !\u003d v)\n\t\t\t\t\tisSink \u003d false;\n\t\tif(isSink)\n\t\t{\n\t\t\tint x \u003d findSmallestCycle(curComp);\n\t\t\tif(x \u0026gt; 0)\n\t\t\t{\n\t\t\t    nCycle++;\n\t\t\t    inCycle +\u003d x;\n\t\t\t}\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; 999 * inCycle + (n - inCycle) + nCycle \u0026lt;\u0026lt; endl;\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003eChallenge\u003c/h4\u003e\u003cp\u003eWhat if the target function is reversed? It means you have to choose a single outgoing edge from every node with at least one outgoing edge, and maximize the sum of cycle sizes in the chosen graph.\u003c/p\u003e\u003cp\u003eI thought about this one a lot but can\u0027t find any solution. Do you have any idea?\u003c/p\u003e\u003c/div\u003e","tags":["editorial","360"]}}