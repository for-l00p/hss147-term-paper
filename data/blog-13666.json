{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1409682325,"rating":0,"authorHandle":"tom","modificationTimeSeconds":1409739222,"id":13666,"title":"\u003cp\u003eContest #4 — Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThank you for participation. Problems were little bit harder than in previous contests, but I think they\u0027re really interesting. I\u0027ve stuck with problem C and after 1 hour realized, that I was doing another problem (I didn\u0027t understand question properly :D) Anyway, I share with you my 3 solutions (Remaining 2 I even didn\u0027t read, so I\u0027ll finish this editorial tomorrow).\u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eProblem A:\u003cbr /\u003e\u003cbr /\u003e Pretty easy. Count the number of message in each chat. Remember about one fact: employee doesn\u0027t get notification when he post a message (so we have to remember the number of message that user sent in each room as well).\u003cbr /\u003e Complexity: O(n) \u003cbr /\u003e\u003cbr /\u003e Problem B:\u003cbr /\u003e\u003cbr /\u003e Main observations: \u003cbr /\u003e - If number of cells is even, we can\u0027t steal anything.\u003cbr /\u003e - We can grab a diamond only from first or last cell.\u003cbr /\u003e - To do so, we need to \u0026quot;move\u0026quot; diamonds to one of the end: (from 1st cell, to 2nd. Next, from 3rd to 4th, 5th -\u0026gt; 6th and so on...). Notice, that sum of any pair didn\u0027t change except last one (or first, we can do it in opposite direction, too).\u003cbr /\u003e\u003cbr /\u003e The result is minimum of:\u003cbr /\u003e --- odd cells (we can move diamonds until every odd cell has at least one of them).\u003cbr /\u003e --- k * (m / (n/2 + 1)), to grab one diamond we need make n/2 + 1 operation.\u003cbr /\u003e Complexity: O(n)\u003cbr /\u003e \u003cbr /\u003e Problem C:\u003cbr /\u003e\u003cbr /\u003e We can do here (almost) Complete Search solution with memorization. Look, that we can move pile at most 3 piles away, so in one state we need to remember only 4 the rightmost piles and where we are — two pointers a and b.\u003cbr /\u003e Complexity: in pessimistic time O(n * 52^4) \u003d 52^5, but we know it can\u0027t be 52^4 combination in every \u0026quot;segment\u0026quot;.\u003cbr /\u003e How to memorize? I did it by huuuge brute-force :D : I create a map\u0026lt;string, int\u0026gt; and \u0026quot;transform\u0026quot; segment to string: (a+b+cards). It\u0027s quite silly, but effective :D\u003cbr /\u003e\u003cbr /\u003e Problem D:\u003cbr /\u003e\u003cbr /\u003e Just use binary search. My code gets WA on test #12, because my result differs from correct result by 0.00001 :| Weird. Don\u0027t use streams — you got TLE.\u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}