{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1493995226,"rating":0,"authorHandle":"1am","modificationTimeSeconds":1493995226,"id":51855,"title":"\u003cp\u003eDay 7\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eA. Distances to Zero\u003c/h1\u003e\u003cp\u003eTo get the nearest zero to this index, we use two arrays. One array gets the nearest zero to the right, and the other array gets the nearest zero to the left. The answer for each index is the minimum value in both arrays.\u003c/p\u003e\u003cp\u003eTo get the values for one array (lets say right), if i am zero the distance to the nearest zero is 0 (myself). Otherwise, the distance to the nearest zero is 1 + r[i+1], where r[i+1] is the distance to the nearest zero of the index to the right of me.\u003c/p\u003e\u003cp\u003eHere is the code: \u003ca href\u003d\"http://ideone.com/gJQ6eM\"\u003ehttp://ideone.com/gJQ6eM\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eB. Replace To Make Regular Bracket Sequence\u003c/h1\u003e\u003cp\u003eFor this question, we learned about the stack data structure. \u003c/p\u003e\u003cp\u003eFor more details on its built in functions, check this link out: \u003ca href\u003d\"http://www.cplusplus.com/reference/stack/stack/\"\u003ehttp://www.cplusplus.com/reference/stack/stack/\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIn our stack we keep only the opening brackets inside of them, and continue to pile on open brackets on the top of the stack. If we reach a closed bracket and it doesn\u0027t match the top of the stack, we need to change either the close bracket or the open bracket. Either way we increase our answer by one. \u003c/p\u003e\u003cp\u003eIf the top of the stack is an open bracket that matches the closed bracket that i am on, then i don\u0027t increase answer because they match. In both instances i pop from my stack the top element, and continue.\u003c/p\u003e\u003cp\u003eHere is the code: \u003ca href\u003d\"http://ideone.com/Q9maXD\"\u003ehttp://ideone.com/Q9maXD\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eC. Longest k-Good Segment\u003c/h1\u003e\u003cp\u003eHere we want to find the longest good segment that has no more than k different values. For this problem we use two pointers to keep track of the segment we are on, and a frequency array for the elements inside the segment.\u003c/p\u003e\u003cp\u003eIf the number of different values is less than k, then i continue increasing my right pointer. Otherwise i stop. While moving my right pointer, i need to increase the frequency of the element that my right pointer is on. And when i increase my left pointer, i need to decrease the frequency of the element my left pointer is pointing on.\u003c/p\u003e\u003cp\u003eTo keep track of how many unique elements i have, there are two things to note:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eIf the frequency of a number was 0 and then it became 1 when i increased it, that means the number of unique values has increased by one.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf the frequency of a number was 1 and then it became 0 when i decreased it, that means the number of unique values has decreased by one.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eThrough this we can keep track of how many unique values we have so far in our segment, and get the maximum answer while moving our right pointer.\u003c/p\u003e\u003cp\u003eHere is the code: \u003ca href\u003d\"http://ideone.com/c9eZHA\"\u003ehttp://ideone.com/c9eZHA\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eD. Pearls in a Row\u003c/h1\u003e\u003cp\u003eIn this problem, we want to divide our array into the maximum number of good segments, such that each good segment has at least two numbers the same in it.\u003c/p\u003e\u003cp\u003eThe solution to this problem is greedy, keep increasing the segment until you reach a point where two numbers are the same in the segment you are on. Then cut there and start a new segment.\u003c/p\u003e\u003cp\u003eTo keep track if two numbers are the same in the segment you are on, while moving keep a set with you. If you add to the array a number which is already in your set, then you cut the segment there and clear the array. Also keep a variable with you that specifies the start of the segment so that when you cut the segment at index i, you push into a vector of pairs the index of the start of the segment and i.\u003c/p\u003e\u003cp\u003eAll that is left is to make sure that the final segment contains till the final index because every element must be in a segment, so make sure of that.\u003c/p\u003e\u003cp\u003eHere is the code: \u003ca href\u003d\"http://ideone.com/8W0mtH\"\u003ehttp://ideone.com/8W0mtH\u003c/a\u003e\u003c/p\u003e\u003cp\u003eGood luck!\u003c/p\u003e\u003c/div\u003e","tags":[]}}