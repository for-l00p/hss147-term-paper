{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1495735377,"rating":63,"authorHandle":"shahidul_brur","modificationTimeSeconds":1495792262,"id":52183,"title":"\u003cp\u003e[Tutorial] Snake Eating Problem of Codechef Snackdown 2017 Qualification round\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eIn the qualification round of \u003ca href\u003d\"https://www.codechef.com/SNCKQL17\"\u003eCodechef Snackdown 2017\u003c/a\u003e, I was able to solve all the problems and I had a great fun to solve the problem \u003ca href\u003d\"https://www.codechef.com/problems/SNAKEEAT\"\u003eSNAKEEAT\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eI was so much excited that I had given \u003ca href\u003d\"//codeforces.com/blog/entry/52130\"\u003ea post\u003c/a\u003e to express my feeling after solving this problem.\u003c/p\u003e\u003cp\u003eAfter that some people asked me on codeforces or \u003ca href\u003d\"https://www.facebook.com/Shahidul.BRUR\"\u003efacebook\u003c/a\u003e, how I had solved the problem. So, I had decided to write a post regarding my solution idea of this problem.\u003c/p\u003e\u003cp\u003eBefore staring the post, I want to say you that I am not so great programmer, so I may make mistake in my post. And, this is my first tutorial post on codeforces, so forgive me if you find anything wrong. Also, English is not my native language, so I may make some grammatical mistake in my post. So, I beg your forgiveness in advance.\u003c/p\u003e\u003ch2\u003eAbridged problem description:\u003c/h2\u003e\u003cp\u003eGiven the length of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e snakes, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, .........\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e. A snake \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e can eat another snake \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and after eating a snake, it\u0027s length is increased by 1.\u003c/p\u003e\u003cp\u003eGiven \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e queries. Each query contains an integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, you have to tell what is the maximum number of snakes you can get which are of length at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003ch2\u003eSoultion:\u003c/h2\u003e\u003ch3\u003ePrerequisites:\u003c/h3\u003e \u003col\u003e   \u003cli\u003ebinary search\u003c/li\u003e   \u003cli\u003eSTL \u003ca href\u003d\"http://www.cplusplus.com/reference/algorithm/lower_bound/\"\u003elower_bound\u003c/a\u003e\u003c/li\u003e   \u003cli\u003eCumulative sum or prefix sum or range sum\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eIn my post, I won\u0027t discuss about these. I assume that you already know these, if not please learn them first.\u003c/p\u003e\u003cp\u003eLet store the lengths in an array and sort the array in increasing order. Since now the array is sorted we can use binary search or lower bound to search any value in this array.\u003c/p\u003e\u003cp\u003eBefore processing the queries, let first observe something which will be helpful in processing the queries.\u003c/p\u003e\u003cp\u003eObserve that the number of snakes whose length \u003cspan class\u003d\"tex-span\"\u003e ≥ \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e can be added to the answer immediately. For any the other snake of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, it needs to eat \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e snakes to make it\u0027s length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSo, how many snakes are there whose length is \u003cspan class\u003d\"tex-span\"\u003e ≥ \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e ? We can use lower bound to find this. Let this index be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eBut what should we do to find the rest ?\u003c/p\u003e\u003cp\u003eWe might iterate from the index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e and check whether we can increase it\u0027s length to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e or not. From index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e, for each length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e it need to eat \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e snakes to make it\u0027s length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Of course snakes should be eaten from the left side(staring from index \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e). We stop when there is not enough snakes on the left side.\u003c/p\u003e\u003cp\u003eBut this process will get TLE. Because complexity of a single such process can be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eq\u003c/i\u003e * (\u003ci\u003en\u003c/i\u003e + \u003ci\u003elogn\u003c/i\u003e))\u003c/span\u003e in worst case.\u003c/p\u003e\u003cp\u003eSo what to do ?\u003c/p\u003e\u003cp\u003eTheir may be lot of ideas to optimize it. Here I am sharing my solution idea.\u003c/p\u003e\u003cp\u003eI would like to discuss the solution with an example.  Let n\u003d13 and the given lengths(after sorting) are- \u003cimg alt\u003d\"array\" src\u003d\"https://lh3.googleusercontent.com/D0jxpTenFFQ8Ay8JIakefE8f7O4v45-WSuW9wGg2WWYrTgaQzjkuLOKwJsPH51M0O4qZlCk6d0HOGXBk6R_YV1nxOjnljeDKoONy5-ytdvE5WDfQTZUGnlmwM5nyYRSvfKAj0hRoTULRe920t3OHLabUyO4EBVH3IllC7u_ksPYdri42PMPN_ElhR3vAB3pXNivpV9q1A1EZVgbWYAKPHljKf2zqwEqR3qW7UquKWE6o0fW6kdGVtKgdR9osLzNlG9kmgoTbTUrOtHnWyDCH5EqoPAeojzGGT9z6SIv5RvHcP3XFGrb83bpvi2SkdSmJORGYtwjkY-6GCDMgQXvkuR0_ZaeaxMnZwGhM-urDipyMR9BXMG-2n9pzzu_esMDyo9gDniA_v9lsF4C0fmwH96LhRHdMQj67-JAexQH7k_gmt0rCUIsvNPU1LheiG8v5WL7eyU56BTNXPvWz2Qw_b3iis_tZF21bwOKAkJD90UNiHAYXPMB33NDiQbkBkfAR86DgGAy3EC_r0frFuZ1dJ-VDIlstSKkD7ZwTcxDWrMl-m9kEgjn-oSwRtluxf0L0HWGdL2nx1YZOwM12q8nhpTX9xEU0tvEb4jk4fu9h6GSultif\u003dw715-h82-no\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eObserve that for each index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e snakes on it\u0027s left side. Let we are querying for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d 15\u003c/span\u003e. If we use lower_bound for 15, we get the index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e \u003d 10. So there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e \u003d 13 - 10 \u003d 3\u003c/span\u003e snakes whose length is at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, so this value can be added to our answer immediately. So, our current answer is, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e \u003d 3\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow, we have to find how many snakes can be made of size 15 by eating other snakes.\u003c/p\u003e\u003cp\u003eWe have to find how many snakes from index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 1 \u003d 9\u003c/span\u003e, we can make of length 15 by eating other snakes. Index \u003d 9, length \u003d 14, need to eat \u003d 15-14 \u003d 1. total need till now \u003d 1 (possible, 9 snakes left) Index \u003d 8, length \u003d 13, need to eat \u003d 15-13 \u003d 2. total need till now \u003d 3 (possible, 8 snakes left) Index \u003d 7, length \u003d 12, need to eat \u003d 15-12 \u003d 3. total need till now \u003d 6 (possible, 7 snakes left) Index \u003d 6, length \u003d 8, need to eat \u003d 15-8 \u003d 7. total need till now \u003d 13, it is not possible, because there are 6 snakes on the left side of index 6. So, 3 snakes can make their length 15. So, final ans \u003d 3 + 3 \u003d 6.\u003c/p\u003e\u003cp\u003eWe stopped at that index where sum of needed snakes to eat is less than the amount of snakes on the left side of that index. For each query we are finding this index by iterating linearly. So, in worst case it takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time. So, for each query it takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogn\u003c/i\u003e + \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time. Total query processing time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eq\u003c/i\u003e * (\u003ci\u003elogn\u003c/i\u003e + \u003ci\u003en\u003c/i\u003e))\u003c/span\u003e. Sorting takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlogn\u003c/i\u003e)\u003c/span\u003e time. So, total time complexity for each test case is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlogn\u003c/i\u003e + \u003ci\u003eq\u003c/i\u003e * (\u003ci\u003elogn\u003c/i\u003e + \u003ci\u003en\u003c/i\u003e))\u003c/span\u003e. Since \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003en\u003c/i\u003e, \u003ci\u003eq\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e, it must get TLE.\u003c/p\u003e\u003cp\u003eSo, the question is: how can we improve it anyway?\u003c/p\u003e\u003cp\u003eObserve that from the index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e, up to index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, sum of needed snakes is calculated as \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/sub\u003e) + (\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e - 2\u003c/sub\u003e) + (\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e - 3\u003c/sub\u003e) + ......(\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e. If we could know, somehow, for any index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, sum needed snakes to make all the snakes from index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e in O(1), then we could use binary search(or lower_bound) the index up to which we can make their length equals to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eHow can we do it ? It may seems difficult, since for each query the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is changed. But we still can do it by following the below technique.\u003c/p\u003e\u003cp\u003eWe can store the cumulative sum of the difference between each length and and length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e, i.e. the largest length.\u003c/p\u003e\u003cp\u003eAccording to our example, we will store the sum of difference between each length and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e \u003d 20\u003c/span\u003e. The cumulative sum array will be:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"cumulative sum\" src\u003d\"https://lh3.googleusercontent.com/H5wpx2LlWARdlpgF3KLAktHiLS-fnQBNfYqthj-aaZUc_rmqZHb4DVeeaVMTmfGT-R3w81xy6MHOheCfuKy0DLKOSGWfHAGHa3UgGq7ftRgtbWwOXJDMBlZ0cH0gdpFJ7OR4Pmjpx-rhbWWlZgzU1vaZZzqzUG-OPTOPqhwZPk3m-lKwdG2kpkIgsDKcp7y5i9yt_dGdLJc8DvJ-KgJuzGgqfARvz5rzfSqFe4R6cqtQZE85x779wDy-q_dy0oR0eBmFp2MfMPaUnlXOpVxeVFYashyC_LVchHtZGKfsSUnCRfPi0PvsA8qS-spPAHWaPeQ0bwDk9cwFJkhlwpd_s_urPslnnoRaP2lkY6gKKJ5aDrxwesElJbgZBwT69bFDU3nNOxMfI9loWjF2wWDbhh6p6lFvEAEDGB06kw2H1gSojRiThbpKuoC0BMTS9s7ulDjg2rpKm2IjvLi52e7gpTgn8YbxP68tUBC4z2UJSO9l8cTfpMfLZFk7oO54pDSlgF2l6l6Aw6KR4mZbKuYNPtl7oRdcRJdz_2b2ZVAp8JVnFazoUAy2LNWwaHbsx1XovaYkzB92onC8hGCvQKekNx6wmO6iI-n5tnd7FKw304aHeEsr8kjl\u003dw717-h157-no\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003c/p\u003e\u003cp\u003eWe can now calculate the sum from any index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to any index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e), in O(1), by sum[j] — sum[i-1].\u003c/p\u003e\u003cp\u003eBut how to handle, if we query for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d 15\u003c/span\u003e, or any other value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e?\u003c/p\u003e\u003cp\u003eWe calculated the cumulative sum with respect to 20. Difference, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e \u003d 20\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d 15\u003c/span\u003e is 5. So, for each index we added extra \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e \u003d 5\u003c/span\u003e. From \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e) there are total \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e elements. So for this range we added extra sum \u003d \u003cspan class\u003d\"tex-span\"\u003e5 * (\u003ci\u003ej\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e + 1)\u003c/span\u003e So, for any query \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, the difference \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e So, the needed sum of snakes, with respect to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, from any index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to any index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e) is \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003esum\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e] - \u003ci\u003esum\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e - 1]) - \u003ci\u003ed\u003c/i\u003e * (\u003ci\u003ei\u003c/i\u003e - \u003ci\u003ej\u003c/i\u003e + 1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThat\u0027s great !! We can now calculate the needed range sum from index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e up to any index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e by sum[k-1] — sum[i-1].\u003c/p\u003e\u003cp\u003eNow, we have to use binary search(or lower_bound) to find the index up to which the needed sum is greater than or equal to the number of elements at it\u0027s left side. If that index is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and our first lower_bound index is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, then our answer to the query will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e (from lower_bound) \u003cspan class\u003d\"tex-span\"\u003e + \u003ci\u003ek\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e (from the 2nd binary search (or lower_bound).\u003c/p\u003e\u003cp\u003eThat\u0027s all !!\u003c/p\u003e\u003cp\u003eNow the complexity of each query is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogn\u003c/i\u003e + \u003ci\u003elogn\u003c/i\u003e)\u003c/span\u003e So, total complexity for each test case is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlogn\u003c/i\u003e + \u003ci\u003eq\u003c/i\u003e * (\u003ci\u003elogn\u003c/i\u003e + \u003ci\u003elogn\u003c/i\u003e))\u003c/span\u003e \u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlogn\u003c/i\u003e + 2 * \u003ci\u003eq\u003c/i\u003e * \u003ci\u003elogn\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003eFinally, here is the code(in c++):\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode:\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\n#define ll long long\n\nconst int MX \u003d 100005;\nint a[MX], n;\nll sum[MX];\n\nint cal(int x, int last)\n{\n    if(last\u003d\u003d0)\n        return 0;\n    int diff \u003d a[n-1] - x;\n    int l \u003d 0, r \u003d last;\n    int ans \u003d 0;\n    while(l\u0026lt;\u003dr)\n    {\n        int mid \u003d (l+r)/2;\n        if(mid\u003d\u003d0)\n        {\n            l \u003d mid+1;\n            continue;\n        }\n        \n        ll need \u003d (sum[last] - sum[mid-1]) - 1LL*diff*(last - mid + 1);\n        if(mid\u0026gt;\u003dneed)\n        {\n            ans \u003d last-mid+1;\n            r \u003d mid-1;\n        }\n        else l \u003d mid+1;\n    }\n    return ans;\n}\nint main()\n{\n    //ios_base::sync_with_stdio(false); cin.tie(NULL);\n    int t, q, x;\n    cin\u0026gt;\u0026gt;t;\n    while(t--)\n    {\n        cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q;\n        for(int i \u003d 0; i\u0026lt; n; i++)\n        {\n            cin\u0026gt;\u0026gt;a[i];\n        }\n        sort(a, a+n);\n        sum[0] \u003d 0LL;\n        for(int i \u003d 1; i\u0026lt; n; i++)\n            sum[i] \u003d 1LL*sum[i-1] + 1LL*(a[n-1] - a[i]);\n        \n        while(q--)\n        {\n            cin\u0026gt;\u0026gt;x;\n            int cnt \u003d 0;\n            int idx \u003d lower_bound(a, a+n, x) - a;\n            cnt\u003d(n-idx);\n            cnt+\u003dcal(x, idx-1);\n            cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n        }\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eYou also can read this post on my \u003ca href\u003d\"http://shahidul-brur-en.blogspot.com/2017/05/codechef-SNAKEEAT.html\"\u003eblog\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIf you find anything wrong in my post, please let me know. If you face any difficulty to understand any part of my post, feel free to ask me in the comment below. Also, if you have another idea to solve this problem, you can share that in the comment.\u003c/p\u003e\u003cp\u003eThanks to all.\u003c/p\u003e\u003c/div\u003e","tags":["codechef","codechef snackdown 2017","tutorial","binary seach","cumulative sum","lower_bound","editorial"]}}