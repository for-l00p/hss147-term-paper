{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1515694158,"rating":303,"authorHandle":"gepardo","modificationTimeSeconds":1524599075,"id":57046,"title":"\u003cp\u003eSqrt-tree: answering queries in O(1) with O(NloglogN) preprocessing.\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello, Codeforces!\u003c/p\u003e\u003cp\u003eSome time ago I invented an interesting data structure and I\u0027d like to share it with the community. Maybe, it was known before, and if you knew about it before my blog post, please share the link to the source.\u003c/p\u003e\u003ch1\u003eWhat can the data structure do?\u003c/h1\u003e\u003cp\u003eGiven an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e that contains \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e elements and the operation \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eop\u003c/i\u003e\u003c/span\u003e that satisfies associative property: \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e \u003ci\u003eop\u003c/i\u003e \u003ci\u003ey\u003c/i\u003e)\u003ci\u003eop\u003c/i\u003e \u003ci\u003ez\u003c/i\u003e \u003d \u003ci\u003ex\u003c/i\u003e \u003ci\u003eop\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e \u003ci\u003eop\u003c/i\u003e \u003ci\u003ez\u003c/i\u003e)\u003c/span\u003e is true for every \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSo, such operations as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egcd\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/span\u003e, sum, multiplication, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eand\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eor\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exor\u003c/i\u003e\u003c/span\u003e, etc. satisfy these conditions.\u003c/p\u003e\u003cp\u003eAlso we have some queries \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e\u003c/span\u003e. For each query, we need to find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e \u003ci\u003eop\u003c/i\u003e \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e + 1\u003c/sub\u003e \u003ci\u003eop\u003c/i\u003e ... \u003ci\u003eop\u003c/i\u003e \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Let\u0027s call such queries \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eMy data structure can process such queries in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/41/6d/416df23458a6ea90aa624e54449f191728b35345.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e preprocessing time and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/41/6d/416df23458a6ea90aa624e54449f191728b35345.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e memory.\u003c/p\u003e\u003ch1\u003eHow it works?\u003c/h1\u003e\u003ch2\u003e1. Sqrt\u003c/h2\u003e\u003cp\u003eLet\u0027s do a sqrt-decomposition. We divide our array in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/5c/4e5c9f371024ad4e1f5b0f2dfeb967ffe7cb5f4e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e blocks, each block has size \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/5c/4e5c9f371024ad4e1f5b0f2dfeb967ffe7cb5f4e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. For each block, we compute:\u003c/p\u003e \u003col\u003e   \u003cli\u003eAnswers to the queries that lie in the block and begin at the beginning of the block \u003cem\u003e(prefix-op)\u003c/em\u003e\u003c/li\u003e   \u003cli\u003eAnswers to the queries that lie in the block and end at the end of the block \u003cem\u003e(suffix-op)\u003c/em\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eAnd we\u0027ll calculate another one thing:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003ccode\u003ebetween[i, j]\u003c/code\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e -- answer to the query that begins at the start of block \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and ends at the end of block \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. Note that we have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/5c/4e5c9f371024ad4e1f5b0f2dfeb967ffe7cb5f4e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e blocks, so the size of this array will be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/93/df/93dff4db34244a129a149603458e3a222ffa7ec1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eLet\u0027s see the example.\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eop\u003c/i\u003e\u003c/span\u003e be \u003cspan class\u003d\"tex-span\"\u003e + \u003c/span\u003e (we calculate sum on the segment) and we have the following array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e:\u003c/p\u003e\u003cp\u003e\u003ccode\u003e1 2 3 4 5 6 7 8 9\u003c/code\u003e\u003c/p\u003e\u003cp\u003eIt will be divided onto three blocks: \u003ccode\u003e1 2 3\u003c/code\u003e, \u003ccode\u003e4 5 6\u003c/code\u003e and \u003ccode\u003e7 8 9\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eFor first block \u003cem\u003eprefix-op\u003c/em\u003e is \u003ccode\u003e1 3 6\u003c/code\u003e and \u003cem\u003esuffix-op\u003c/em\u003e is \u003ccode\u003e6 5 3\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eFor second block \u003cem\u003eprefix-op\u003c/em\u003e is \u003ccode\u003e4 9 15\u003c/code\u003e and \u003cem\u003esuffix-op\u003c/em\u003e is \u003ccode\u003e15 11 6\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eFor third block \u003cem\u003eprefix-op\u003c/em\u003e is \u003ccode\u003e7 15 24\u003c/code\u003e and \u003cem\u003esuffix-op\u003c/em\u003e is \u003ccode\u003e24 17 9\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebetween\u003c/i\u003e\u003c/span\u003e array is:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e6 21 45\n- 15 39\n-  - 24\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt\u0027s obvious to see that these arrays can be easily calculated in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time and memory.\u003c/p\u003e\u003cp\u003eWe already can answer some queries using these arrays. If the query doesn\u0027t fit into one block, we can divide it onto three parts: suffix of a block, then some segment of contiguous blocks and then prefix of some block. We can answer a query by dividing it into three parts and taking \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eop\u003c/i\u003e\u003c/span\u003e of some value from \u003cem\u003esuffix-op\u003c/em\u003e, then some value from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebetween\u003c/i\u003e\u003c/span\u003e, then some value from \u003cem\u003eprefix-op\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eBut if we have queries that entirely fit into one block, we cannot process them using these three arrays. So, we need to do something.\u003c/p\u003e\u003ch2\u003e2. Tree\u003c/h2\u003e\u003cp\u003eWe cannot answer only the queries that entirely fit in one block. But what \u003cstrong\u003eif we build the same structure as described above for each block?\u003c/strong\u003e Yes, we can do it. And we do it recursively, until we reach the block size of \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e. Answers for such blocks can be calculated easily in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSo, we get a tree. Each node of the tree represents some segment of the array. Node that represents array segment with size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e has \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8b/4f/8b4fd3a13af2e5077b128d028841f0ee2517f32e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e children -- for each block. Also each node contains the three arrays described above for the segment it contains. The root of the tree represents the entire array. Nodes with segment lengths \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e are leaves.\u003c/p\u003e\u003cp\u003eAlso it\u0027s obvious that the radius of this tree is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cd/60/cd609b05b5bc5d82ab32907fda94102d347c048a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, because if some vertex of the tree represents an array with length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, then its children have length \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8b/4f/8b4fd3a13af2e5077b128d028841f0ee2517f32e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/82/84/8284083ba4d10391175fd5d8166c07f9c59b51fd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, so \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ca/ed/caedb7a2f7bb3d5b16a97395b06cbcd09540f447.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e decreases two times every layer of the tree and so its height is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cd/60/cd609b05b5bc5d82ab32907fda94102d347c048a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. The time for building and memory usage will be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/41/6d/416df23458a6ea90aa624e54449f191728b35345.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, because every element of the array appears exactly once on each layer of the tree.\u003c/p\u003e\u003cp\u003eNow we can answer the queries in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cd/60/cd609b05b5bc5d82ab32907fda94102d347c048a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. We can go down on the tree until we meet a segment with length \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e (answer for it can be calculated in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time) or meet the first segment in which our query doesn\u0027t fit entirely into one block. See the first section on how to answer the query in this case.\u003c/p\u003e\u003cp\u003eOK, now we can do \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cd/60/cd609b05b5bc5d82ab32907fda94102d347c048a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e per query. Can it be done faster?\u003c/p\u003e\u003ch2\u003e3. Optimizing the query complexity\u003c/h2\u003e\u003cp\u003eOne of the most obvious optimization is to binary search the tree node we need. Using binary search, we can reach the \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/49/a6/49a6653db1a9de8fb48533a59df400eec520b14a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e complexity per query. Can we do it even faster?\u003c/p\u003e\u003cp\u003eThe answer is yes. Let\u0027s assume the following two things:\u003c/p\u003e \u003col\u003e   \u003cli\u003eEach block size is a power of two.\u003c/li\u003e   \u003cli\u003eAll the blocks are equal on each layer.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eTo reach this, we can add some zero elements to our array so that its size becomes a power of two.\u003c/p\u003e\u003cp\u003eWhen we use this, some block sizes may become twice larger to be a power of two, but it still be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/85/47/8547651c618b71142c60ecd4726c2b1727f155b3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e in size and we keep linear complexity for building the arrays in a segment.\u003c/p\u003e\u003cp\u003eNow, we can easily check if the query fits entirely into a block with size \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. Let\u0027s write the ranges of the query, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e (we use 0-indexation) in binary form. For instance, let\u0027s assume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d 4, \u003ci\u003el\u003c/i\u003e \u003d 39, \u003ci\u003er\u003c/i\u003e \u003d 46\u003c/span\u003e. The binary representation of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e is:\u003c/p\u003e\u003cp\u003e\u003ccode\u003el \u003d 39(10) \u003d 100111(2)\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003er \u003d 46(10) \u003d 101110(2)\u003c/code\u003e\u003c/p\u003e\u003cp\u003eRemember that one layer contains segments of the equal size, and the block on one layer have also equal size (in our case, their size is \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e \u003d 2\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e \u003d 16\u003c/span\u003e. The blocks cover the array entirely, so the first block covers elements \u003cspan class\u003d\"tex-span\"\u003e(0 - 15)\u003c/span\u003e (\u003ccode\u003e000000 - 001111\u003c/code\u003e in binary), the second one covers elements \u003cspan class\u003d\"tex-span\"\u003e(16 - 31)\u003c/span\u003e (\u003ccode\u003e010000 - 011111\u003c/code\u003e in binary) and so on. We see that the indices of the positions covered by one block may differ only in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e (in our case, \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e) last bits. In our case \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e have equal bits except four lowest, so they lie in one block.\u003c/p\u003e\u003cp\u003eSo, we need to check if nothing more that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e smallest bits differ (or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003ci\u003exor\u003c/i\u003e \u003ci\u003er\u003c/i\u003e\u003c/span\u003e doesn\u0027t exceed \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e - 1\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eUsing this observation, we can find a layer that is suitable to answer the query quickly. How to do this:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eFor each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e that doesn\u0027t exceed the array size, we find the highest bit that is equal to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. To do this quickly, we use DP and a precalculated array.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eNow, for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e we find the highest bit of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003ci\u003exor\u003c/i\u003e \u003ci\u003er\u003c/i\u003e\u003c/span\u003e and, using this information, it\u0027s easy to choose the layer on which we can process the query easily. We can also use a precalculated array here.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eFor more details, see the code below.\u003c/p\u003e\u003cp\u003eSo, using this, we can answer the queries in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e each. Hooray! :)\u003c/p\u003e\u003ch1\u003eConclusion\u003c/h1\u003e\u003cp\u003eWe have a data structure that asymptotically answers the queries on a segment very fast. But, the constant of this data structures is big enough. Also it doesn\u0027t support changing the elements. But it can be modified to perform modification queries in something about \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for modifying a single element. But in this case, query complexity becomes \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cd/60/cd609b05b5bc5d82ab32907fda94102d347c048a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. You can think how to do this as an exercise.\u003c/p\u003e\u003ch1\u003eProblems\u003c/h1\u003e\u003cp\u003e\u003ca href\u003d\"https://www.codechef.com/NOV17/problems/SEGPROD\"\u003ehttps://www.codechef.com/NOV17/problems/SEGPROD\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eCode\u003c/h1\u003e\u003cp\u003e\u003ca href\u003d\"https://paste.ubuntu.com/26372378/\"\u003eHere it is\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIf you have some suggestions on how to improve this data structure or how to modify it, or something is written unclear and needs more explanation, feel free to write in the comments.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD\u003c/strong\u003e: As it\u0027s noticed in the \u003ca href\u003d\"#comment-406976\"\u003ecomment\u003c/a\u003e, this algorithm (and some more optimal ones) can be found in \u003ca href\u003d\"https://pdfs.semanticscholar.org/cf74/0240d3a7440e23e92a09bf590cb70544cf4f.pdf\"\u003ethis article\u003c/a\u003e (thanks \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Rafbill\" title\u003d\"Международный гроссмейстер Rafbill\"\u003eRafbill\u003c/a\u003e).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD2\u003c/strong\u003e: As \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/geniucos\" title\u003d\"Международный гроссмейстер geniucos\"\u003egeniucos\u003c/a\u003e described in the \u003ca href\u003d\"#comment-407003\"\u003ecomment\u003c/a\u003e, we can improve the time complexity to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3d/f2/3df27b0626218fe46dbad7f8c2647659cd43717d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for preprocessing if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003ci\u003eop\u003c/i\u003e \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e applies. Let the block size is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, not \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. We use a sparse table instead of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebetween\u003c/i\u003e\u003c/span\u003e array. We will have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/59/fa/59fac7bb591aecf62ec00d7af2b2652db09a3f5b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e blocks and time complexity for building a sparse table will still be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/02/f2/02f2129a5b42716265d748440f16fc780e0efb01.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. The tree will have much smaller layers and we still have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e per query.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD3\u003c/strong\u003e: The code is adjusted to work with non-commutative operations. The commutative property removed from the post.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD4\u003c/strong\u003e: \u003ca href\u003d\"//codeforces.com/blog/entry/59092\"\u003eContinuation of the post\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["data structure","sqrt-decomposition","tree","log log n"]}}