{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1421676956,"rating":322,"authorHandle":"DarthPrince","modificationTimeSeconds":1429243778,"id":15890,"title":"\u003cp\u003eAlgorithm Gym :: Everything About Segment Trees\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eIn the last lecture of \u003cstrong\u003eAlgorithm Gym\u003c/strong\u003e (\u003ca href\u003d\"/blog/entry/15729\"\u003eData Structures\u003c/a\u003e), I introduced you Segment trees.\u003c/p\u003e\u003cp\u003eIn this lecture, I want to tell you more about its usages and we will solve some serious problems together. Segment tree types : \u003c/p\u003e\u003ch2\u003eClassic Segment Tree\u003c/h2\u003e\u003cp\u003eClassic, is the way I call it. This type of segment tree, is the most simple and common type. In this kind of segment trees, for each node, we should keep some simple elements, like integers or boolians or etc.\u003c/p\u003e\u003cp\u003eThis kind of problems don\u0027t have update queries on intervals.\u003c/p\u003e\u003cp\u003eExample 1 (Online):\u003c/p\u003e\u003cp\u003eProblem \u003ca href\u003d\"/contest/380/problem/C\" title\u003d\"Codeforces Round 223 (Div. 1)\"\u003e380C - Sereja and Brackets\u003c/a\u003e :\u003c/p\u003e\u003cp\u003eFor each node (for example \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e), we keep three integers : 1.\u003ccode\u003et[x]\u003c/code\u003e \u003d Answer for it\u0027s interval. 2. \u003ccode\u003eo[x]\u003c/code\u003e \u003d The number of $($s after deleting the brackets who belong to the correct bracket sequence in this interval whit length \u003ccode\u003et[x]\u003c/code\u003e. 3. \u003ccode\u003ec[x]\u003c/code\u003e \u003d The number of $)$s after deleting the brackets who belong to the correct bracket sequence in this interval whit length \u003ccode\u003et[x]\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eLemma : For merging to nodes \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003ex\u003c/i\u003e + 1\u003c/span\u003e (children of node \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003ex\u003c/i\u003e + 1\u003c/span\u003e) all we need to do is this :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etmp \u003d min(o[2 * x], c[2 * x + 1])\nt[x] \u003d t[2 * x] + t[2 * x + 1] + tmp\no[x] \u003d o[2 * x] + o[2 * x + 1] - tmp\nc[x] \u003d c[2 * x] + c[2 * x + 1] - tmp\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo, as you know, first of all we need a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebuild\u003c/i\u003e\u003c/span\u003e function which would be this : (as above) (C++ and \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e is inclusive-outclusive )\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid build(int id \u003d 1,int l \u003d 0,int r \u003d n){\n    if(r - l \u0026lt; 2){\n        if(s[l] \u003d\u003d \u0027(\u0027)\n            o[id] \u003d 1;\n        else\n            c[id] \u003d 1;\n        return ;\n    }\n    int mid \u003d (l+r)/2;\n    build(2 * id,l,mid);\n    build(2 * id + 1,mid,r);\n    int tmp \u003d min(o[2 * id],c[2 * id + 1]);\n    t[id] \u003d t[2 * id] + t[2 * id + 1] + tmp;\n    o[id] \u003d o[2 * id] + o[2 * id + 1] - tmp;\n    c[id] \u003d c[2 * id] + c[2 * id + 1] - tmp;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFor queries, return value of the function should be 3 values : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e, \u003ci\u003eo\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e which is the values I said above for the intersection of the node\u0027s interval and the query\u0027s interval (we consider query\u0027s interval is \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e ), so in C++ code, return value is a \u003ccode\u003epair\u0026lt;int,pair\u0026lt;int,int\u0026gt; \u0026gt;\u003c/code\u003e (\u003ccode\u003epair\u0026lt;t, pair\u0026lt;o,c\u0026gt; \u0026gt;\u003c/code\u003e) :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etypedef pair\u0026lt;int,int\u0026gt;pii;\ntypedef pair\u0026lt;int,pii\u0026gt;   node;\nnode segment(int x,int y,int id \u003d 1,int l \u003d 0,int r \u003d n){\n    if(l \u0026gt;\u003d y || x \u0026gt;\u003d r)   return node(0,pii(0,0));\n    if(x \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026lt;\u003d y)\n        return node(t[id],pii(o[id],c[id]));\n    int mid \u003d (l+r)/2;\n    node a \u003d segment(x,y,2 * id,l,mid), b \u003d segment(x,y,2 * id + 1,mid,r);\n    int T, temp, O, C;\n    temp \u003d min(a.y.x , b.y.y);\n    T \u003d a.x + b.x + temp;\n    O \u003d a.y.x + b.y.x - temp;\n        C \u003d a.y.y + b.y.y - temp;\n    return node(T,pii(O,C));    \n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eExample 2 (Offline): Problem \u003ca href\u003d\"http://www.spoj.com/problems/KQUERY/\"\u003eKQUERY\u003c/a\u003e\u003c/p\u003e\u003cp\u003eImagine we have an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e which, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/48/6b/486b8aca7fba5ed3554387de064d113b860d9399.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 1\u003c/span\u003e if an only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u0026gt; \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, then we can easily answer the query \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e using a simple segment tree (answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e + ... + \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e ).\u003c/p\u003e\u003cp\u003eWe can do this ! We can answer the queries offline.\u003c/p\u003e\u003cp\u003eFirst of all, read all the queries and save them somewhere, then sort them in increasing order of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e and also the array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e in increasing order (compute the permutation \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sub\u003e ≤ \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sub\u003e ≤ ... ≤ \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e\u003c/span\u003e)\u003c/p\u003e\u003cp\u003eAt first we\u0027ll set all array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and we will set all of them to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e one by one.\u003c/p\u003e\u003cp\u003eConsider after sorting the queries in increasing order of their \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, we have a permutation \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (of \u003cspan class\u003d\"tex-span\"\u003e1, 2, ..., \u003ci\u003eq\u003c/i\u003e\u003c/span\u003e) where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sub\u003e ≤ \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sub\u003e ≤ \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sub\u003e ≤ ... ≤ \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e\u003c/span\u003e (we keep the answer to the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e query in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e .\u003c/p\u003e\u003cp\u003ePseudo code : (all 0-based)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epo \u003d 0\nfor j \u003d 0 to q-1\n\twhile po \u0026lt; n and a[p[po]] \u0026lt;\u003d k[w[j]]\n\t\tb[p[po]] \u003d 0, po \u003d po + 1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo, build function would be like this (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e]\u003c/span\u003e is the sum of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e in the interval of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e) :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid build(int id \u003d 1,int l \u003d 0,int r \u003d n){\n\tif(r - l \u0026lt; 2){\n\t\ts[id] \u003d 1;\n\t\treturn ;\n\t}\n\tint mid \u003d (l+r)/2;\n\tbuild(2 * id, l, mid);\n\tbuild(2 * id + 1, mid, r);\n\ts[id] \u003d s[2 * id] + s[2 * id + 1];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eet An update function for when we want to st \u003ccode\u003eb[p[po]] \u003d 0\u003c/code\u003e to update the segment tree: \u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid update(int p,int id \u003d 1,int l \u003d 0,int r \u003d n){\n\tif(r - l \u0026lt; 2){\n\t\ts[id] \u003d 0;\n\t\treturn ;\n\t}\n\tint mid \u003d (l+r)/2;\n\tif(p \u0026lt; mid)\n\t\tupdate(p, 2 * id, l, mid);\n\telse\n\t\tupdate(p, 2 * id + 1, mid, r);\n\ts[id] \u003d s[2 * id] + s[2 * id + 1];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFinally, a function for sum of an interval\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint sum(int x,int y,int id \u003d 1,int l \u003d 0,int r \u003d n){// [x, y)\n\tif(x \u0026gt;\u003d r or l \u0026gt;\u003d y)\treturn 0;// [x, y) intersection [l,r) \u003d empty\n\tif(x \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026lt;\u003d y)\t// [l,r) is a subset of [x,y)\n\t\treturn s[id];\n\tint mid \u003d (l + r)/2;\n\treturn sum(x, y, id * 2, l, mid) +\n\t       sum(x, y, id*2+1, mid, r) ;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo, in main function instead of that pseudo code, we will use this :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ebuild();\nint po \u003d 0;\nfor(int y \u003d 0;y \u0026lt; q;++ y){\n\tint x \u003d w[y];\n\twhile(po \u0026lt; n \u0026amp;\u0026amp; a[p[po]] \u0026lt;\u003d k[x])\n\t\tupdate(p[po ++]);\n\tans[x] \u003d sum(i[x], j[x] + 1); // the interval [i[x], j[x] + 1)\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eLazy Propagation\u003c/h2\u003e\u003cp\u003eI told you enough about lazy propagation in the last lecture. In this lecture, I want to solve ans example .\u003c/p\u003e\u003cp\u003eExample : Problem \u003ca href\u003d\"http://www.spoj.com/problems/POSTERS/\"\u003ePOSTERS\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eWe don\u0027t need all elements in the interval \u003cspan class\u003d\"tex-span\"\u003e[1, 10\u003csup class\u003d\"upper-index\"\u003e7\u003c/sup\u003e]\u003c/span\u003e. The only thing we need is the set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e where for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e in one of the queries.\u003c/p\u003e\u003cp\u003eWe can use interval \u003cspan class\u003d\"tex-span\"\u003e1, 2, ..., \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e instead of that (each query is running in this interval, in code, we use 0-based, I mean \u003cspan class\u003d\"tex-span\"\u003e[0, \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e ). For the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e query, we will paint all the interval \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e whit color \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e (1-based).\u003c/p\u003e\u003cp\u003eFor each interval, if all it\u0027s interval is from the same color, I will keep that color for it and update the nodes using lazy propagation.\u003c/p\u003e\u003cp\u003eSo,we will have a value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elazy\u003c/i\u003e\u003c/span\u003e for each node and there is no any build function (if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elazy\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] ≠ 0\u003c/span\u003e then all the interval of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is from the same color (color \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elazy\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e) and we haven\u0027t yet shifted the updates to its children. Every member of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elazy\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e at first).\u003c/p\u003e\u003cp\u003eA function for shifting the updates to a node, to its children using lazy propagation :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid shift(int id){\n\tif(lazy[id])\n\t\tlazy[2 * is] \u003d lazy[2 * id + 1] \u003d lazy[id];\n\tlazy[id] \u003d 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eUpdate (paint) function (for queries) :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid upd(int x,int y,int color, int id \u003d 0,int l \u003d 0,int r \u003d n){//painting the interval [x,y) whith color \u0026quot;color\u0026quot;\n\tif(x \u0026gt;\u003d r or l \u0026gt;\u003d y)\treturn ;\n\tif(x \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026lt;\u003d y){\n\t\tlazy[id] \u003d color;\n\t\treturn ;\n\t}\n\tint mid \u003d (l+r)/2;\n\tshift(id);\n\tupd(x, y, color, 2 * id, l, mid);\n\tupd(x, y, color, 2*id+1, mid, r);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo, for each query you should call \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eupd\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e + 1, \u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is the query\u0027s 1-base index) where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003el\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003er\u003c/i\u003e\u003c/span\u003e .\u003c/p\u003e\u003cp\u003eAt last, for counting the number of different colors (posters), we run the code below (it\u0027s obvious that it\u0027s correct) :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eset \u0026lt;int\u0026gt; se;\nvoid cnt(int id \u003d 1,int l \u003d 0,int r \u003d n){\n\tif(lazy[id]){\n\t\tse.insert(lazy[id]);\n\t\treturn ; // there is no need to see the children, because all the interval is from the same color\n\t}\n\tif(r - l \u0026lt; 2)\treturn ;\n\tint mid \u003d (l+r)/2;\n\tcnt(2 * id, l, mid);\n\tcnt(2*id+1, mid, r);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd answer will be \u003ccode\u003ese.size()\u003c/code\u003e .\u003c/p\u003e\u003ch2\u003eSegment tree with vectors\u003c/h2\u003e\u003cp\u003eIn this type of segment tree, for each node we have a vector (we may also have some other variables beside this) .\u003c/p\u003e\u003cp\u003eExample : Online approach for problem \u003ca href\u003d\"http://www.spoj.com/problems/KQUERYO/\"\u003eKQUERYO\u003c/a\u003e (I added this problem as the online version of KQUERY):\u003c/p\u003e\u003cp\u003eIt will be nice if for each node, with interval \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003el\u003c/i\u003e ≤ \u003ci\u003er\u003c/i\u003e ≤ \u003ci\u003ej\u003c/i\u003e + 1\u003c/span\u003e and this interval is maximal (it\u0027s parent\u0027s interval is not in the interval \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e + 1)\u003c/span\u003e ), we can count the answer.\u003c/p\u003e\u003cp\u003eFor that propose, we can keep all elements of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e + 1\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e in increasing order and use binary search for counting. So, memory will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e.\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e (each element is in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e nodes ). We keep this sorted elements in verctor \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e node. Also, we don\u0027t need to run sort on all node\u0027s vectors, for node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, we can merge \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e[2 * \u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e[2 * \u003ci\u003eid\u003c/i\u003e + 1]\u003c/span\u003e (like merge sort) .\u003c/p\u003e\u003cp\u003eSo, build function is like below :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid build(int id \u003d 1,int l \u003d 0,int r \u003d n){\n\tif(r - l \u0026lt; 2){\n\t\tv[id].push_back(a[l]);\n\t\treturn ;\n\t}\n\tint mid \u003d (l+r)/2;\n\tbuild(2 * id, l, mid);\n\tbuild(2*id+1, mid, r);\n\tmerge(v[2 * id].begin(), v[2 * id].end(), v[2 * id + 1].begin(), v[2 * id + 1].end(), back_inserter(v[id])); // read more about back_inserter in http://www.cplusplus.com/reference/iterator/back_inserter/\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd function for solving queries : \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint cnt(int x,int y,int k,int id \u003d 1,int l \u003d 0,int r  \u003d n){// solve the query (x,y-1,k)\n\tif(x \u0026gt;\u003d r or l \u0026gt;\u003d y)\treturn 0;\n\tif(x \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026lt;\u003d n)\n\t\treturn v[id].size() - (upper_bound(v[id].begin(), v[id].end(), k) - v[id].begin());\n\tint mid \u003d (l+r)/2;\n\treturn cnt(x, y, k, 2 * id, l, mid) +\n\t\t   cnt(x, y, k, 2*id+1, mid, r) ;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnother example : \u003ca href\u003d\"/gym/100513/problem/C\"\u003eComponent Tree\u003c/a\u003e\u003c/p\u003e\u003ch2\u003eSegment tree with sets\u003c/h2\u003e\u003cp\u003eIn this type of segment tree, for each node we have a \u003ccode\u003eset\u003c/code\u003e or \u003ccode\u003emultiset\u003c/code\u003e or \u003ccode\u003ehash_map\u003c/code\u003e (\u003ca href\u003d\"/blog/entry/15869\"\u003ehere\u003c/a\u003e) or \u003ccode\u003eunorderd_map\u003c/code\u003e or etc (we may also have some other variables beside this) .\u003c/p\u003e\u003cp\u003eConsider this problem : \u003c/p\u003e\u003cp\u003eWe have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e vectors, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and all of them are initially empty. We should perform \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e queries on this vectors of two types :\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e \u003ci\u003ep\u003c/i\u003e \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e Add number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003eat the end of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e \u003ci\u003el\u003c/i\u003e \u003ci\u003er\u003c/i\u003e \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e print the number \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ce/79/ce796c3b12b8a053fb70916abd844cd008c226a1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecount\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e is the number of occurrences of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e .\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eFor this problem, we use a segment tree where each node has a \u003ccode\u003emultiset\u003c/code\u003e, node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e with interval \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e has a \u003ccode\u003emultiset\u003c/code\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e that contains each number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e exactly \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ce/79/ce796c3b12b8a053fb70916abd844cd008c226a1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e times (memory would be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eq\u003c/i\u003e.\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e ) .\u003c/p\u003e\u003cp\u003eFor answer query \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e \u003ci\u003ex\u003c/i\u003e \u003ci\u003ey\u003c/i\u003e \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, we will print the sum of all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e.\u003ci\u003ecount\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e where if the interval of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e ≤ \u003ci\u003el\u003c/i\u003e ≤ \u003ci\u003er\u003c/i\u003e ≤ \u003ci\u003ey\u003c/i\u003e + 1\u003c/span\u003e and its maximal (its parent doesn\u0027t fulfill this condition) .\u003c/p\u003e\u003cp\u003eWe have no build function (because vectors are initially empty). But we need an add function :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid add(int p,int k,int id \u003d 1,int l \u003d 0,int r \u003d n){//\tperform query A p k\n\ts[id].insert(k);\n\tif(r - l \u0026lt; 2)\treturn ;\n\tint mid \u003d (l+r)/2;\n\tif(p \u0026lt; mid)\n\t\tadd(p, k, id * 2, l, mid);\n\telse\n\t\tadd(p, k, id*2+1, mid, r);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd the function for the second query is : \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint ask(int x,int y,int k,int id \u003d 1,int l \u003d 0,int r \u003d n){// Answer query C x y-1 k\n\tif(x \u0026gt;\u003d r or l \u0026gt;\u003d y)\treturn 0;\n\tif(x \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026lt;\u003d y)\n\t\treturn s[id].count(k);\n\tint mid \u003d (l+r)/2;\n\treturn ask(x, y, k, 2 * id, l, mid) + \n\t\t   ask(x, y, k, 2*id+1, mid, r) ;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eSegment tree with other data structures in each node\u003c/h2\u003e\u003cp\u003eFrom now, all the other types of segments, are like the types above.\u003c/p\u003e\u003ch4\u003e\u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e Segment trees\u003c/h4\u003e\u003cp\u003eIn this type of segment tree, for each node we have another segment tree (we may also have some other variables beside this) .\u003c/p\u003e\u003ch4\u003eSegment trees with tries\u003c/h4\u003e\u003cp\u003eIn this type of segment tree, for each node we have a trie (we may also have some other variables beside this) .\u003c/p\u003e\u003ch4\u003eSegment trees with DSU\u003c/h4\u003e\u003cp\u003eIn this type of segment tree, for each node we have a disjoint set (we may also have some other variables beside this) .\u003c/p\u003e\u003cp\u003eExample : Problem \u003ca href\u003d\"/contest/76/problem/A\" title\u003d\"All-Ukrainian School Olympiad in Informatics\"\u003e76A - Gift\u003c/a\u003e, you can read my source code (\u003ca href\u003d\"/contest/76/submission/8613428\" title\u003d\"Submission 8613428 by DarthPrince\"\u003e8613428\u003c/a\u003e) with this type of segment trees .\u003c/p\u003e\u003ch4\u003eSegment trees with Fenwick\u003c/h4\u003e\u003cp\u003eIn this type of segment tree, for each node we have a Fenwick (we may also have some other variables beside this) . Example :\u003c/p\u003e\u003cp\u003eConsider this problem : \u003c/p\u003e\u003cp\u003eWe have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e vectors, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and all of them are initially empty. We should perform \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e queries on this vectors of two types :\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e \u003ci\u003ep\u003c/i\u003e \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e Add number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003eat the end of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e \u003ci\u003el\u003c/i\u003e \u003ci\u003er\u003c/i\u003e \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e print the number \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/31/7c31dc51d6a1308a6d837aef206b96714a3e650f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e ≤ \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecount\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e is the number of occurrences of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e .\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eFor this problem, we use a segment tree where each node has a \u003ccode\u003evector\u003c/code\u003e, node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e with interval \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e has a \u003ccode\u003eset\u003c/code\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e that contains each number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e if and only if \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b9/08/b908d81f046cbc306d1ba6c576842fc9a0947ddb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (memory would be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eq\u003c/i\u003e.\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e ) (in increasing order).\u003c/p\u003e\u003cp\u003eFirst of all, we will read all queries, store them and for each query of type \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e, we will insert \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e for all nodes that contain \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e (and after all of them, we sort these vectors using merge sort and run unique function to delete repeated elements) .\u003c/p\u003e\u003cp\u003eThen, for each node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, we build a vector \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efen\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e with size \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003es\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]|\u003c/span\u003e (initially \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eInsert function :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid insert(int p,int k,int id \u003d 1,int l \u003d 0,int r \u003d n){//\tperform query A p k\n\tif(r - l \u0026lt; 2){\n\t\tv[id].push_back(k);\n\t\treturn ;\n\t}\n\tint mid \u003d (l+r)/2;\n\tif(p \u0026lt; mid)\n\t\tinsert(p, k, id * 2, l, mid);\n\telse\n\t\tinsert(p, k, id*2+1, mid, r);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSort function (after reading all queries) : \u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid SORT(int id \u003d 1,int l \u003d 0,int r \u003d n){\n\tif(r - l \u0026lt; 2)\n\t\treturn ;\n\tint mid \u003d (l+r)/2;\n\tSORT(2 * id, l, mid);\n\tSORT(2*id+1, mid, r);\n\tmerge(v[2 * id].begin(), v[2 * id].end(), v[2 * id + 1].begin(), v[2 * id + 1].end(), back_inserter(v[id])); // read more about back_inserter in http://www.cplusplus.com/reference/iterator/back_inserter/\n\tv[id].resize(unique(v[id].begin(), v[id].end()) - v[id].begin());\n\tfen[id] \u003d vector\u0026lt;int\u0026gt; (v[id].size() + 1, 0);\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen for all queries of type \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e, for each node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e containing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e we will run :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor(int i \u003d a + 1;i \u0026lt; fen[x].size(); i +\u003d i \u0026amp; -i)       fen[x][i] ++;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhere \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e][\u003ci\u003ea\u003c/i\u003e] \u003d \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e . Code :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid upd(int p,int k, int id \u003d 1,int l \u003d 0,int r \u003d n){\n\tint a \u003d lower_bound(v[id].begin(), v[id].end(), k) - v[id].begin();\n\tfor(int i \u003d a + 1; i \u0026lt; fen[id].size(); i +\u003d i \u0026amp; -i )\n\t\tfen[id][i] ++ ;\n\tif(r - l \u0026lt; 2)\treturn;\n\tint mid \u003d (l+r)/2;\n\tif(p \u0026lt; mid)\n\t\tupd(p, k, 2 * id, l, mid);\n\telse\n\t\tupd(p, k, 2*id+1, mid, r);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd now we can easily compute the answer for queries of type \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint ask(int x,int y,int k,int id \u003d 1,int l \u003d 0,int r \u003d n){// Answer query C x y-1 k\n\tif(x \u0026gt;\u003d r or l \u0026gt;\u003d y)\treturn 0;\n\tif(x \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026lt;\u003d y){\n\t\tint a \u003d lower_bound(v[id].begin(), v[id].end(), k) - v[id].begin();\n\t\tint ans \u003d 0;\n\t\tfor(int i \u003d a + 1; i \u0026gt; 0; i -\u003d i \u0026amp; -i)\n\t\t\tans +\u003d fen[id][i];\n\t\treturn ans;\n\t}\n\tint mid \u003d (l+r)/2;\n\treturn ask(x, y, k, 2 * id, l, mid) + \n\t\t   ask(x, y, k, 2*id+1, mid, r) ;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eSegment tree on a rooted tree\u003c/h2\u003e\u003cp\u003eAs you know, segment tree is for problems with array. So, obviously we should convert the rooted tree into an array. You know DFS algorithm and starting time (the time when we go into a vertex, starting from 1). So, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is starting time of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, element number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (in the segment tree) belongs to the vertex number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003emax\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e) + 1\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is in subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, the interval \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e shows the interval of subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e (in the segment tree) .\u003c/p\u003e\u003cp\u003eExample : Problem \u003ca href\u003d\"/contest/396/problem/C\" title\u003d\"Codeforces Round 232 (Div. 1)\"\u003e396C - On Changing Tree\u003c/a\u003e\u003c/p\u003e\u003cp\u003eConsider \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e height if vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e (distance from root).\u003c/p\u003e\u003cp\u003eFor each query of first of type, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is in subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, its value increasing by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + (\u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e) ×  - \u003ci\u003ek\u003c/i\u003e \u003d \u003ci\u003ex\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e(\u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e) \u003d \u003ci\u003ex\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e × \u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ek\u003c/i\u003e × \u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. So for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e is the set of all queries of first type which \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is in the subtree of their \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, answer to query \u003cspan class\u003d\"tex-span\"\u003e2 \u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a9/b6/a9b66a1f53bea1a5b0580cc650aad6f4a17da2db.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, so we should calculate two values \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/24/f0/24f0026799b9813e4667608db30dce93c52837d4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/54/b5/54b5f919a00f8c6470dcbc65a065926f9aec1ec2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, we can answer the queries. So, we for each query, we can store values in all members of its subtree ( \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e ).\u003c/p\u003e\u003cp\u003eSo for each node of segment tree, we will have two variables \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bf/fc/bffcba0c81f78824d6a3f13840991602845950ef.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4b/ef/4bef0837c58ac0587f7a1654694a654a874968ec.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (we don\u0027t need lazy propagation, because we only update maximal nodes).\u003c/p\u003e\u003cp\u003eSource code of update function :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid update(int x,int k,int v,int id \u003d 1,int l \u003d 0,int r \u003d n){\n\tif(s[v] \u0026gt;\u003d r or l \u0026gt;\u003d f[v])\treturn ;\n\tif(s[v] \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026lt;\u003d f[v]){\n\t\thkx[id] \u003d (hkx[id] + x) % mod;\n\t\tint a \u003d (1LL * h[v] * k) % mod;\n\t\thkx[id] \u003d (hkx[id] + a) % mod;\n\t\tsk[id] \u003d (sk[id] + k) % mod;\n\t\treturn ;\n\t}\n\tint mid \u003d (l+r)/2;\n\tupdate(x, k, v, 2 * id, l, mid);\n\tupdate(x, k, v, 2*id+1, mid, r);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFunction for 2nd type query :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint ask(int v,int id \u003d 1,int l \u003d 0,int r \u003d n){\n\tint a \u003d (1LL * h[v] * sk[id]) % mod;\n\tint ans \u003d (hkx[id] + mod - a) % mod;\n\tif(r - l \u0026lt; 2)\treturn ans;\n\tint mid \u003d (l+r)/2;\n\tif(s[v] \u0026lt; mid)\n\t\treturn (ans + ask(v, 2 * id, l, mid)) % mod;\n\t\treturn (ans + ask(v, 2*id+1, mid, r)) % mod;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003ePersistent Segment Trees\u003c/h2\u003e\u003cp\u003eIn the last lecture, I talked about this type of segment trees, now I just want to solve an important example.\u003c/p\u003e\u003cp\u003eExample : Problem \u003ca href\u003d\"http://www.spoj.com/problems/MKTHNUM/\"\u003eMKTHNUM\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst approach : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e).\u003ci\u003elog\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e\u003c/p\u003e\u003cp\u003eI won\u0027t discuss this approach, it\u0027s using binary search an will get TLE.\u003c/p\u003e\u003cp\u003eSecond approach : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e).\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e\u003c/p\u003e\u003cp\u003eThis approach is really important and pretty and too useful :\u003c/p\u003e\u003cp\u003eSort elements of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e to compute permutation \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sub\u003e ≤ \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sub\u003e ≤ ... ≤ \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e where, for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e \u003d \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe have an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (initially 0) and a persistent segment tree on it.\u003c/p\u003e\u003cp\u003eThen \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e step,for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, starting from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, we perform \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e \u003d 1\u003c/span\u003e .\u003c/p\u003e\u003cp\u003eLest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e + 1\u003c/sub\u003e + ... + \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e update (if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d 0\u003c/span\u003e, it equals to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e)\u003c/p\u003e\u003cp\u003eAs I said in the last lecture, we have an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e and the root of the empty segment tree, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eir\u003c/i\u003e\u003c/span\u003e . So for each query \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e, we need to find the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e(1, \u003ci\u003ei\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e) - \u003ci\u003esum\u003c/i\u003e(1, \u003ci\u003ei\u003c/i\u003e, \u003ci\u003el\u003c/i\u003e - 1) \u0026gt; \u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e and answer will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e\u003c/span\u003e. (I\u0027ll explain how in the source code) : \u003c/p\u003e\u003cp\u003eBuild function (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e is the sum of the node\u0027s interval):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid build(int id \u003d ir,int l \u003d 0,int r \u003d n){\n\ts[id] \u003d 0;\n\tif(r - l \u0026lt; 2)\n\t\treturn ;\n\tint mid \u003d (l+r)/2;\n\tL[id] \u003d NEXT_FREE_INDEX ++;\n\tR[id] \u003d NEXT_FREE_INDEX ++;\n\tbuild(L[id], l, mid);\n\tbuild(R[id], mid, r);\n\ts[id] \u003d s[L[id]] + s[R[id]];\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eUpdate function :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint upd(int p, int v,int id,int l \u003d 0,int r \u003d n){\n\tint ID \u003d  NEXT_FREE_INDEX ++; // index of the node in new version of segment tree\n\ts[ID] \u003d s[id] + 1;\n\tif(r - l \u0026lt; 2)\n\t\treturn ID;\n\tint mid \u003d (l+r)/2;\n\tL[ID] \u003d L[id], R[ID] \u003d R[id]; // in case of not updating the interval of left child or right child\n\tif(p \u0026lt; mid)\n\t\tL[ID] \u003d upd(p, v, L[ID], l, mid);\n\telse\n\t\tR[ID] \u003d upd(p, v, R[ID], mid, r);\n\treturn ID;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAsk function (it returns \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, so you should print \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e\u003c/span\u003e :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint ask(int id, int ID, int k, int l \u003d 0,int r \u003d n){// id is the index of the node after l-1-th update (or ir) and ID will be its index after r-th update\n\tif(r - l \u0026lt; 2)\treturn l;\n\tint mid \u003d (l+r)/2;\n\tif(s[L[ID]] - s[L[id]] \u0026gt;\u003d k)// answer is in the left child\u0027s interval\n\t\treturn ask(L[id], L[ID], k, l, mid);\n\telse\n\t\treturn ask(R[id], R[ID], k - (s[L[ID]] - s[L[id]] ), mid, r);// there are already s[L[ID]] - s[L[id]] 1s in the left child\u0027s interval\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs you can see, this problem is too tricky.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eIf there is any error or suggestion let me know.\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e","tags":["segment tree","algorithms","tutorial"]}}