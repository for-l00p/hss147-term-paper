{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1505162900,"rating":0,"authorHandle":"compiler_101","modificationTimeSeconds":1505162900,"id":54478,"title":"\u003cp\u003eTeam Contest-1 Solution\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/group/4h7vHPcFsN/contest/215381/problem/A\" title\u003d\"ACM FCI ICPC Team Formation Contest\"\u003e215381A - Restricted Divisors\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eNote that \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e ≤ \u003ci\u003eb\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e12\u003c/sup\u003e)\u003c/span\u003e are too large to be stored as int data type.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eCode:\n\n    freopen(\u0026quot;divisors.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n    int t;\n    cin \u0026gt;\u0026gt; t;\n    while (t--) {\n        long long a, b;\n        cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n        long long sum \u003d 0;\n        for (long long i \u003d a; i \u0026lt;\u003d b; ++i) \n            sum +\u003d b / i;\n        cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl;\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/group/4h7vHPcFsN/contest/215381/problem/B\" title\u003d\"ACM FCI ICPC Team Formation Contest\"\u003e215381B - Colorful Wall\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eCode:\n\n    freopen(\u0026quot;wall.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q;\n    for (int i \u003d 0; i \u0026lt; n; ++i)\n        cin \u0026gt;\u0026gt; a[i];\n    while (q--) {\n    \tint l, r;\n        cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r;\n    \treverse(a + l - 1, a + r);\n    }\n    for (int i \u003d 0; i \u0026lt; n; ++i) {\n        if (i) cout \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n        cout \u0026lt;\u0026lt; a[i];\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/group/4h7vHPcFsN/contest/215381/problem/C\" title\u003d\"ACM FCI ICPC Team Formation Contest\"\u003e215381C - Mr. Bondok and scientific books\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eDynamic Programming, just like Knapsack problem, except when you pick a node you have to pick the sub-tree rooted at that node. This can be done by pre-calculating the cost and gain of each subtree, then apply \u003cstrong\u003eEuler tour technique\u003c/strong\u003e, so when you pick a subtree you can jump to the next node not included in that subtree.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eCode:\n\n#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\nconst int N \u003d 2e3 + 5;\n\nint n, m, budget, c[N], b[N], memo[N][N];\nvector\u0026lt;int\u0026gt; adj[N];\nvector\u0026lt;int\u0026gt; euler;\nint out[N], subCost[N], subGain[N];\npair\u0026lt;int, int\u0026gt; pre(int node) {\n\teuler.push_back(node);\n\tpair\u0026lt;int, int\u0026gt; ret \u003d {c[node], b[node]};\n\tfor (auto child: adj[node]) {\n\t\tauto subChild \u003d pre(child);\n\t\tret.first +\u003d subChild.first;\n\t\tret.second +\u003d subChild.second;\n\t}\n\tout[node] \u003d euler.size();\n\tsubCost[node] \u003d ret.first;\n\tsubGain[node] \u003d ret.second;\n\treturn ret;\n}\nint go(int i, int cost) {\n\tif (cost \u0026lt; 0)\n\t\treturn -1e9;\n\tif (i \u003d\u003d euler.size())\n\t\treturn 0;\n\tint \u0026amp;ret \u003d memo[i][cost];\n\tif (~ret)\n\t\treturn ret;\n\treturn ret \u003d max(go(out[euler[i]], cost - subCost[euler[i]]) + subGain[euler[i]], go(i + 1, cost));\n}\nint degree[N];\nint main() {\n\tfreopen(\u0026quot;tree.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n#ifndef ONLINE_JUDGE\n\tfreopen(\u0026quot;input.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n#endif\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; budget;\n\tfor (int i \u003d 1; i \u0026lt;\u003d n; ++i)\n\t\tcin \u0026gt;\u0026gt; c[i];\n\tfor (int i \u003d 1; i \u0026lt;\u003d n; ++i)\n\t\tcin \u0026gt;\u0026gt; b[i];\n\twhile (m--) {\n\t\tint u, v;\n\t\tcin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v;\n\t\t++degree[v];\n\t\tadj[u].push_back(v);\n\t}\n\tmemset(memo, -1, sizeof memo);\n\tfor (int i \u003d 1; i \u0026lt;\u003d n; ++i)\n\t\tif (!degree[i])\n\t\t\tpre(i);\n\tcout \u0026lt;\u0026lt; go(0, budget) \u0026lt;\u0026lt; endl;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/group/4h7vHPcFsN/contest/215381/problem/D\" title\u003d\"ACM FCI ICPC Team Formation Contest\"\u003e215381D - Street Lights\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eStore all the segments first and sort them, then reduce them to disjoint segments by merging the overlapped ones. Now, the optimal solution can be reached by trying to add the extra segment just before or after each disjoint segment.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eCode:\n\n#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\nconst int N \u003d 1e5 + 5;\n\nint main() {\n\tfreopen(\u0026quot;lights.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n#ifndef ONLINE_JUDGE\n\tfreopen(\u0026quot;input.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n#endif\n\tint n, l, x;\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; l \u0026gt;\u0026gt; x;\n\tpair\u0026lt;int, int\u0026gt; segment[N];\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) {\n\t\tint a, b;\n\t\tcin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\t\tsegment[i] \u003d {max(0, a - b), min(l, a + b)};\n\t}\n\tsort(segment, segment + n);\n\t\n\tvector\u0026lt;int\u0026gt; left, right;\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) {\n\t\tif (!right.empty() \u0026amp;\u0026amp; right.back() \u0026gt;\u003d segment[i].first)\n\t\t\tright.back() \u003d max(right.back(), segment[i].second);\n\t\telse {\n\t\t\tleft.push_back(segment[i].first);\n\t\t\tright.push_back(segment[i].second);\n\t\t}\n\t}\n\t\n\tint result \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; left.size(); ++i) {\n\t\tint sum \u003d 0;\n\t\tauto it \u003d upper_bound(right.begin(), right.end(), right[i] + 2 * x);\n\t\tif (it \u003d\u003d right.end() || left[it - right.begin()] \u0026gt; right[i] + 2 * x)\n\t\t\tsum \u003d min(right[i] + 2 * x, l) - left[i];\n\t\telse\n\t\t\tsum \u003d *it - left[i];\n\t\tresult \u003d max(result, sum);\n\t\t\n\t\tit \u003d lower_bound(right.begin(), right.end(), left[i] - 2 * x);\n\t\tif (it \u003d\u003d right.end() || left[it - right.begin()] \u0026gt; left[i] - 2 * x)\n\t\t\tsum \u003d right[i] - max(left[i] - 2 * x, 0);\n\t\telse\n\t\t\tsum \u003d right[i] - left[it - right.begin()];\n\t\tresult \u003d max(result, sum);\n\t}\n\tcout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl;\n\treturn 0;\n}\n    \n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/group/4h7vHPcFsN/contest/215381/problem/E\" title\u003d\"ACM FCI ICPC Team Formation Contest\"\u003e215381E - Eid Time\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eCode:\n        freopen(\u0026quot;largest.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\tint t;\n        cin \u0026gt;\u0026gt; t;\n\twhile (t--) {\n\t\tint n, maxi \u003d -1e9;\n                cin \u0026gt;\u0026gt; n;\n\t\tfor (int i \u003d 0; i \u0026lt; n; ++i) {\n\t\t\tint a;\n\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;a);\n\t\t\tmaxi \u003d max(maxi, a);\n\t\t}\n                cout \u0026lt;\u0026lt; maxi \u0026lt;\u0026lt; endl;\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/group/4h7vHPcFsN/contest/215381/problem/F\" title\u003d\"ACM FCI ICPC Team Formation Contest\"\u003e215381F - Magic square\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThe target sum can be found easily by finding a row that doesn\u0027t contain any zeros.\u003c/p\u003e\u003cp\u003eThen find the rows that contain a zero and set the value to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etarget\u003c/i\u003e - \u003ci\u003esumRow\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIf the two zeros were in the same row, then you will have to solve for columns instead of rows. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eCode:\n\n#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\nconst int N \u003d 100 + 5;\n\nint main() {\n\tfreopen(\u0026quot;magic.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n#ifndef ONLINE_JUDGE\n\tfreopen(\u0026quot;input.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n#endif\n\tint t;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;t);\n\twhile (t--) {\n\t\tint n, a[N][N], target \u003d -1;\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\t\tvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; zeros;\n\t\tfor (int i \u003d 0; i \u0026lt; n; ++i) {\n\t\t\tint sum \u003d 0;\n\t\t\tbool perfect \u003d true;\n\t\t\tfor (int j \u003d 0; j \u0026lt; n; ++j) {\n\t\t\t\tscanf(\u0026quot;%d\u0026quot;, a[i] + j);\n\t\t\t\tsum +\u003d a[i][j];\n\t\t\t\tif (!a[i][j]) {\n\t\t\t\t\tzeros.push_back({i, j});\n\t\t\t\t\tperfect \u003d false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (perfect)\n\t\t\t\ttarget \u003d sum;\n\t\t}\n\t\tint x \u003d -1, y;\n\t\tif (zeros[0].first \u003d\u003d zeros[1].first) { // same row\n\t\t\tint sum \u003d 0;\n\t\t\tfor (int k \u003d 0; k \u0026lt; n; ++k)\n\t\t\t\tsum +\u003d a[k][zeros[0].second];\n\t\t\tx \u003d target - sum;\n\t\t\tsum \u003d 0;\n\t\t\tfor (int k \u003d 0; k \u0026lt; n; ++k)\n\t\t\t\tsum +\u003d a[k][zeros[1].second];\n\t\t\ty \u003d target - sum;\n\t\t} else {\n\t\t\tint sum \u003d 0;\n\t\t\tfor (int k \u003d 0; k \u0026lt; n; ++k)\n\t\t\t\tsum +\u003d a[zeros[0].first][k];\n\t\t\tx \u003d target - sum;\n\t\t\tsum \u003d 0;\n\t\t\tfor (int k \u003d 0; k \u0026lt; n; ++k)\n\t\t\t\tsum +\u003d a[zeros[1].first][k];\n\t\t\ty \u003d target - sum;\n\t\t}\n\t\t\n\t\tprintf(\u0026quot;%d %d\\n\u0026quot;, min(x, y), max(x, y));\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/group/4h7vHPcFsN/contest/215381/problem/G\" title\u003d\"ACM FCI ICPC Team Formation Contest\"\u003e215381G - XOR game\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e be the Xor sum of subset \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e of the array, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e be the Xor of the whole array, then \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7e/3a/7e3ae4c562a6d76812ee201c00e161fd0a55fc33.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e equals the Xor sum of the remaining elements in the array that are not included in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNote that the xor sum might be up to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e * 2 - 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe problem can be solved using Dynamic Programming. Generate the xor sum of every possible subset (pick or leave technique).\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eCode:\n\n#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\nconst int N \u003d 100 + 5, MOD \u003d 1e9 + 7;\n\nint n, xorSum, memo[N][N];\nint go(int i, int pop) {\n\tif (i \u003d\u003d n + 1) {\n\t\tint alice \u003d xorSum ^ pop;\n\t\treturn pop \u0026gt; alice;\n\t}\n\tint \u0026amp;ret \u003d memo[i][pop];\n\tif (~ret,2017-09-10)\n\t\treturn ret;\n\treturn ret \u003d (go(i + 1, pop) + go(i + 1, pop ^ i)) % MOD;\n}\nint main() {\n\tfreopen(\u0026quot;sets.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n#ifndef ONLINE_JUDGE\n\tfreopen(\u0026quot;input.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n#endif\n\tint t;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;t);\n\twhile (t--) {\n\t\txorSum \u003d 0;\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\t\tfor (int i \u003d 1; i \u0026lt;\u003d n; ++i)\n\t\t\txorSum ^\u003d i;\n\t\tmemset(memo, -1, sizeof memo);\n\t\tprintf(\u0026quot;%d\\n\u0026quot;, go(1, 0));\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/group/4h7vHPcFsN/contest/215381/problem/H\" title\u003d\"ACM FCI ICPC Team Formation Contest\"\u003e215381H - The Primes Game\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThe problem can be modeled as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e - \u003ci\u003el\u003c/i\u003e + 1\u003c/span\u003e piles, The \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e pile is of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is the number of times where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e occur as a prime factor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e + \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eSo it can be modeled as a \u003cstrong\u003eNim Game\u003c/strong\u003e where the answer is Xor sum of all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eCode:\n\n#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint main() {\n\tfreopen(\u0026quot;primes.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n#ifndef ONLINE_JUDGE\n\tfreopen(\u0026quot;input.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n#endif\n\tint t;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;t);\n\twhile (t--) {\n\t\tint l, r, p, XOR \u003d 0;\n\t\tscanf(\u0026quot;%d %d %d\u0026quot;, \u0026amp;l, \u0026amp;r, \u0026amp;p);\n\t\tfor (int i \u003d l; i \u0026lt;\u003d r; ++i) {\n\t\t\tint x \u003d i;\n\t\t\tint c \u003d 0;\n\t\t\twhile (x % p \u003d\u003d 0) {\n\t\t\t\tx /\u003d p;\n\t\t\t\t++c;\n\t\t\t}\n\t\t\tXOR ^\u003d c;\n\t\t}\n\t\tif (XOR) {\n\t\t\tputs(\u0026quot;First\u0026quot;);\n\t\t} else {\n\t\t\tputs(\u0026quot;Second\u0026quot;);\n\t\t}\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/group/4h7vHPcFsN/contest/215381/problem/I\" title\u003d\"ACM FCI ICPC Team Formation Contest\"\u003e215381I - Primeland\u0027s holy squares \u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eDo a binary search to find the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e black square. To calculate how many black squares before a specific one you need to use \u003cstrong\u003ethe inclusion exclusion principle\u003c/strong\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eCode:\n\n#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint n, k, p[55];\nlong long mid;\nlong long inclusionExclusion(int i, long long lcm, bool odd) {\n\tif (i \u003d\u003d n) {\n\t\tif (odd)\n\t\t\treturn -mid / lcm;\n\t\telse\n\t\t\treturn mid / lcm;\n\t}\n\treturn inclusionExclusion(i + 1, lcm, odd) + inclusionExclusion(i + 1, lcm * p[i], !odd);\n}\n\nint main() {\n\tfreopen(\u0026quot;number.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n#ifndef ONLINE_JUDGE\n\tfreopen(\u0026quot;input.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n#endif\n\tint t;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;t);\n\twhile (t--) {\n\t\tscanf(\u0026quot;%d %d\u0026quot;, \u0026amp;n, \u0026amp;k);\n\t\tfor (int i \u003d 0; i \u0026lt; n; ++i)\n\t\t\tscanf(\u0026quot;%d\u0026quot;, p + i);\n\t\tlong long lower \u003d 1, upper \u003d 1e12, result \u003d -1;\n\t\twhile (lower \u0026lt;\u003d upper) {\n\t\t\tmid \u003d (lower + upper) / 2;\n\t\t\tlong long black \u003d inclusionExclusion(0, 1, false);\n\t\t\tif (black \u0026gt;\u003d k) {\n\t\t\t\tresult \u003d mid;\n\t\t\t\tupper \u003d mid - 1;\n\t\t\t} else {\n\t\t\t\tlower \u003d mid + 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\u0026quot;%lld\\n\u0026quot;, result);\n\t}\n\t\n\treturn 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/group/4h7vHPcFsN/contest/215381/problem/J\" title\u003d\"ACM FCI ICPC Team Formation Contest\"\u003e215381J - Good strings \u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eCode:\n\n\tfreopen(\u0026quot;good.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\tint t;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;t);\n\twhile (t--) {\n\t\tchar s[N];\n\t\tscanf(\u0026quot; %s\u0026quot;, s);\n\t\tset\u0026lt;char\u0026gt; distinct;\n\t\tfor (int i \u003d 0; s[i]; ++i)\n\t\t\tdistinct.insert(s[i]);\n\t\tif (distinct.size() \u003d\u003d strlen(s)) {\n\t\t\tputs(\u0026quot;yes\u0026quot;);\n\t\t} else {\n\t\t\tputs(\u0026quot;no\u0026quot;);\n\t\t}\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/group/4h7vHPcFsN/contest/215381/problem/K\" title\u003d\"ACM FCI ICPC Team Formation Contest\"\u003e215381K - Equality\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThe solution is to brute force on the target value of the array and calculate the needed steps of each target.\u003c/p\u003e\u003cp\u003eNow let\u0027s prove that we only need to find targets \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e ≤ \u003ci\u003etarget\u003c/i\u003e ≤ \u003ci\u003emax\u003c/i\u003e * \u003ci\u003em\u003c/i\u003e - 1\u003c/span\u003e :\u003c/p\u003e\u003cp\u003eAssume that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e * \u003ci\u003em\u003c/i\u003e ≤ \u003ci\u003etarget\u003c/i\u003e\u003c/span\u003e then for every element the added value will be greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e1\u003c/sup\u003e\u003c/span\u003e so we could divide the target by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e and get the same steps (by decrementing \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e form an added power on each element) \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eCode:\n\n#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nconst int N \u003d 100 + 5;\nint m;\nint calc(int target, int num) {\n\tint steps \u003d 0;\n\twhile (target) {\n\t\tint a \u003d num % m;\n\t\tint b \u003d target % m;\n\t\tif (a \u0026gt; b) {\n\t\t\tsteps +\u003d m - a + b;\n\t\t\tnum +\u003d m;\n\t\t} else {\n\t\t\tsteps +\u003d b - a;\n\t\t}\n\t\tnum /\u003d m;\n\t\ttarget /\u003d m;\n\t}\n\treturn steps;\n}\nint main() {\n\tfreopen(\u0026quot;equal.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n#ifndef ONLINE_JUDGE\n\tfreopen(\u0026quot;input.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n#endif\n\tint n, a[N], maxi \u003d 0, result \u003d 1e9;\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) {\n\t\tcin \u0026gt;\u0026gt; a[i];\n\t\tmaxi \u003d max(maxi, a[i]);\n\t}\n\tfor (int target \u003d maxi; target \u0026lt; maxi * m; ++target) {\n\t\tint cost \u003d 0;\n\t\tfor (int i \u003d 0; i \u0026lt; n; ++i)\n\t\t\tcost +\u003d calc(target, a[i]);\n\t\tresult \u003d min(result, cost);\n\t}\n\tcout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}