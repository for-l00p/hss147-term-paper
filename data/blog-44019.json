{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1459058926,"rating":5,"authorHandle":"F.A.H.I.M","modificationTimeSeconds":1459091417,"id":44019,"title":"\u003cp\u003eSPOJ FACT1 (Factorization of 20 digits) discussion\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI tried to solve this problem :\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://www.spoj.com/problems/FACT1/\"\u003eFACT1_SPOJ\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI know since the value of N is upto 10^20, I had to use a generalized algorithm such as pollard rho.. and I did. \u003c/p\u003e\u003cp\u003eStill my verdict is given TLE. Can someone please help me to show the optimization that can be done?\u003c/p\u003e\u003cp\u003eHere is my code \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport java.util.*;\nimport java.math.*;\nimport java.security.*;\n\npublic class Main {\n\tfinal static BigInteger ZERO \u003d new BigInteger(\u0026quot;0\u0026quot;);\n\tfinal static BigInteger ONE \u003d new BigInteger(\u0026quot;1\u0026quot;);\n\tfinal static BigInteger TWO \u003d new BigInteger(\u0026quot;2\u0026quot;);\n\tpublic static BigInteger prm[]\u003dnew BigInteger[10000];\n\tpublic static int l;\n\t\n\tpublic static SecureRandom random \u003d new SecureRandom();\n\t\n\tpublic static BigInteger pollard_rho(BigInteger n)\n\t{\n\t\tBigInteger d;\n\t\tBigInteger k \u003d new BigInteger(n.bitLength(), random);\n\t\tBigInteger x \u003d new BigInteger(n.bitLength(),random);\n\t\tBigInteger y \u003d x;\n\t\twhile(true)\n\t\t{\n\t\t\tx \u003d ((x.multiply(x)).add(k).mod(n));\n\t\t\ty \u003d ((y.multiply(y)).add(k).mod(n));\n\t\t\ty \u003d ((y.multiply(y)).add(k).mod(n));\n\t\t\td \u003d (x.subtract(y).gcd(n));\n\t\t\tif(d.compareTo(ONE) !\u003d 0) break;\n\t\t}\n\t\treturn d;\n\t}\n\tpublic static void factorize(BigInteger n)\n\t{\n\t\tif(n.compareTo(ONE) \u003d\u003d 0) return;\n\t\tif(n.isProbablePrime(30))\n\t\t{\n\t\t\tprm[l++]\u003dn;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tBigInteger d \u003d pollard_rho(n);\n\t\t\n\t\tfactorize(d);\n\t\tfactorize(n.divide(d));\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner scanf \u003d new Scanner(System.in);\n\t\tint i;\n\t\tBigInteger n;\n\t\t\n\t\twhile(scanf.hasNext()) //this means while(input !\u003d EOF)\n\t\t{\n\t\t\tn \u003d scanf.nextBigInteger();\n\t\t\t\n\t\t\tif(n.compareTo(ZERO) \u003d\u003d 0)break;\n\t\t\t\n\t\t\tl \u003d 0;\n\t\t\t\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tif((n.mod(TWO)).compareTo(ZERO) !\u003d 0)break;\n\t\t\t\tn \u003d n.divide(TWO);\n\t\t\t\tprm[l++] \u003d TWO;\n\t\t\t}\n\t\t\tfactorize(n);\n\t\t\t\n\t\t\tif(l \u003d\u003d 0) continue;\n\t\t\t\n\t\t\tArrays.sort(prm, 0, l);\n\t\t\t\n\t\t\tint cnt \u003d 1;\n\t\t\tboolean flag \u003d false;\n\t\t\t\n\t\t\tfor(i \u003d 1; i \u0026lt; l; i++)\n\t\t\t{\n\t\t\t\tif(prm[i].compareTo(prm[i-1]) \u003d\u003d 0)\n\t\t\t\t{\n\t\t\t\t\tcnt++; continue;\n\t\t\t\t}\n\t\t\t\tif(flag) System.out.print(\u0026quot; \u0026quot;);\n\t\t\t\tflag \u003d true;\n\t\t\t\tSystem.out.print(prm[i-1] + \u0026quot;^\u0026quot; + cnt);\n\t\t\t\tcnt \u003d 1;\n\t\t\t}\n\t\t\tif(flag)System.out.print(\u0026quot; \u0026quot;);\n\t\t\tSystem.out.print(prm[i-1] + \u0026quot;^\u0026quot; + cnt);\n\t\t\tSystem.out.println(\u0026quot;\u0026quot;);\n\t\t}\n\t\tscanf.close();\n\t}\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["number theory","prime-factorisation","pollard_rho"]}}