{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1432044047,"rating":20,"authorHandle":"Bekzhan.Kassenov","modificationTimeSeconds":1450538044,"id":17974,"title":"\u003cp\u003eCenter of a graph\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello, CodeForces!\u003c/p\u003e\u003cp\u003eFrom time to time some people ask questions related to center, radius and diameter of graph (I could google only \u003ca href\u003d\"//codeforces.com/blog/entry/3814\"\u003eabout tree\u003c/a\u003e). In this topic you can find their definitions and algorithms for finding them.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem:\u003c/strong\u003e you are given graph \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e \u003d (\u003ci\u003eV\u003c/i\u003e, \u003ci\u003eE\u003c/i\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003c/span\u003e is set of nodes and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eE\u003c/i\u003e\u003c/span\u003e is set of edges. You have to find its center, radius and diameter.\u003c/p\u003e\u003cp\u003eLet\u0027s denote \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e as shortest distance between nodes \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/df/61/df61fd8abc0b142035b6577bf4c5ae7d927a8930.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Then diameter of graph is denoted as the greatest possible among all possible shortest distances between two nodes:\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bd/07/bd07d1b71f7ab808d21c04fa88e854c95cf429fd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eAlso we can define eccentricity of node as maximal distance from that node to other:\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e8/da/e8daff2209421878851c29d1e42a2c3b92ba4761.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eHaving values of eccentricity of all nodes, we can define radius of graph as minimal one among them:\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3d/1a/3d1a1a879b4f1e15ec84ef24dce4688924109330.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eAlso we can observe that diameter of graph is maximal eccentricity of node:\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d6/60/d6605c2a1f420fbfa8b749efc92daa077e9b1ea5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eCenter of graph is set of nodes with eccentricity equal to the radius of graph:\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/44/01/44012dac54cf5f63192bc63f2c61a6973827c608.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eAfter these basic definitions we can find radius, diameter and center of graph using \u003ca href\u003d\"http://e-maxx.ru/algo/floyd_warshall_algorithm\"\u003eFloyd-Warshall\u0027s\u003c/a\u003e algorithm:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003econst int   N \u003d ...; // Number of nodes in graph\nconst int   INF \u003d ...; // Infinity\nint         d[N][N]; // Distances between nodes\nint         e[N]; // Eccentricity of nodes\nset \u0026lt;int\u0026gt;   c; // Center of graph\nint         rad \u003d INF; // Radius of graph\nint         diam; // Diamater of graph\n\n// Floyd-Warshall\u0027s algorithm\nfor (int k \u003d 0; k \u0026lt; N; k++) {\n    for (int j \u003d 0; j \u0026lt; N; j++) {\n        for (int i \u003d 0; i \u0026lt; N; i++) {\n            d[i][j] \u003d min(d[i][j], d[i][k] + d[k][j]);\n        }\n    }\n}\n\n// Counting values of eccentricity\nfor (int i \u003d 0; i \u0026lt; n; i++) {\n    for (int j \u003d 0; j \u0026lt; n; j++) {\n        e[i] \u003d max(e[i], d[i][j]);\n    }\n}\n\nfor (int i \u003d 0; i \u0026lt; n; i++) {\n    rad \u003d min(rad, e[i]);\n    diam \u003d max(diam, e[i]);\n}\n\nfor (int i \u003d 0; i \u0026lt; n; i++) {\n    if (e[i] \u003d\u003d rad) {\n        c.insert(i);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0027s try to change problem statement: suppose that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e is a tree. There is one interesting fact about trees: number of nodes in the center of tree is equal to one or two.\u003c/p\u003e\u003cp\u003ePossible algorithm for finding center of tree is the following: using BFS from any node (denote it as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e1\u003c/span\u003e) find the farthest from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e1\u003c/span\u003e node (denote as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e2\u003c/span\u003e), then run BFS from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e2\u003c/span\u003e, choose the farthest node from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e2\u003c/span\u003e (call it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e3\u003c/span\u003e). Nodes in the middle of the path between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e2\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e3\u003c/span\u003e are center of graph, distance between them is diameter. Radius of graph is half of diameter rounded up: \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ediam\u003c/i\u003e(\u003ci\u003eG\u003c/i\u003e) + 1) / 2\u003c/span\u003e. I will not provide implementation of that algorithm because it look quiet bulky. Instead, I will show another algorithm which is much easier to implement.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eTheorem:\u003c/strong\u003e Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e be set of leaves of G. If \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eV\u003c/i\u003e| ≤ 2\u003c/span\u003e then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e is center of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e, otherwice center of graph remains the same after removing of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e:\u003c/p\u003e \u003ccenter\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c1/34/c134ff149b4b9319cb71ae0c3199c94f6f623f72.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003c/center\u003e\u003cp\u003eThis theorem brings us to the following algorithm: remove leaves, level by level, until there are \u003cspan class\u003d\"tex-span\"\u003e ≤ 2\u003c/span\u003e nodes. These nodes will be center of graph. Implementation of this algorithm is similar to BFS:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003econst int   N \u003d ...; // Number of nodes in graph\nint         maxlevel \u003d 0; // Level of center of graph\nint         level[N]; // Level of node\nint         degree[N]; // Degree of node\nint         g[N][N]; // Adjacency matrix\nset \u0026lt;int\u0026gt;   c; // Center of graph\nqueue \u0026lt;int\u0026gt; q; // Queue for algo\n\n// Start from leaves\nfor (int i \u003d 0; i \u0026lt; N; i++) {\n    if (degree[i] \u003d\u003d 1) {\n        q.push(i);\n    }\n}\n\nwhile (!q.empty()) {\n    int v \u003d q.front();\n    q.pop();\n\n    // Remove leaf and try to add its parent\n    for (int i \u003d 0; i \u0026lt; N; i++) {\n        if (g[v][i]) {\n            degree[i]--;\n            \n            if (degree[i] \u003d\u003d 1) {\n                q.push(i);\n                level[i] \u003d level[v] + 1;\n                maxlevel \u003d max(maxlevel, level[i]);\n            }\n        }\n    }\n}\n\nfor (int i \u003d 0; i \u0026lt; N; i++) {\n    if (level[i] \u003d\u003d maxlevel) {\n        c.insert(i);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt\u0027s not so hard to prove that after running of this algo center of graph will be in \u003ccode\u003ec\u003c/code\u003e, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/28/7a/287a293a997c3a04424c56955c6f2cd28f47499d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003erad\u003c/i\u003e(\u003ci\u003eG\u003c/i\u003e) \u003d (\u003ci\u003ediam\u003c/i\u003e(\u003ci\u003eG\u003c/i\u003e) + 1) / 2\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrike\u003e I could not fin appropriate problems to solve, feel free to post them in comments. \u003c/strike\u003e\u003c/p\u003e\u003cp\u003eProblems to solve:\u003c/p\u003e \u003cul\u003e \u003cli\u003e \u003ca href\u003d\"http://ioinformatics.org/locations/ioi13/contest/index.shtml\"\u003eIOI2013 Dreaming\u003c/a\u003e \u003c/li\u003e \u003cli\u003e \u003ca href\u003d\"/contest/456/problem/E\" title\u003d\"Codeforces Round 260 (Div. 2)\"\u003e456E - Civilization\u003c/a\u003e \u003c/li\u003e \u003cli\u003e \u003ca href\u003d\"/contest/592/problem/D\" title\u003d\"Codeforces Round 328 (Div. 2)\"\u003e592D - Super M\u003c/a\u003e \u003c/li\u003e \u003cli\u003e Problem F from this \u003ca href\u003d\"//codeforces.com/gym/100279/attachments/download/2025/20122013-international-open-olympiad-kpiopen-2013-round-1-en.pdf\"\u003e contest \u003c/a\u003e \u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThank you for attention, you can write about typos to private messages.\u003c/p\u003e\u003c/div\u003e","tags":["graph","tree","radius","diameter","center of tree"]}}