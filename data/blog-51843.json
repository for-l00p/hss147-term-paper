{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1493925872,"rating":0,"authorHandle":"mutreta","modificationTimeSeconds":1520873158,"id":51843,"title":"\u003cp\u003eNumber Theory Algorithms and Techniques\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eNumber Theory Algorithms and Techniques\u003c/h1\u003e\u003cp\u003eGiven the following function, explain the behavior of the code.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint func(int x, int y) {\n  return !y ? x : func(x^y, (x\u0026amp;y) \u0026lt;\u0026lt; 1);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHow to we even start tackling this problem? This is some strange recursive function that does some bit tricks. At first glance, this code does not make any sense. But what happens when we execute it? Let\u0027s look for a pattern:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efunc(1, 0) \u003d\u003d 1;\nfunc(1, 1) \u003d\u003d 2;\nfunc(1, 2) \u003d\u003d 3;\nfunc(1, 4) \u003d\u003d 5;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt appears to be summing the two numbers, strange. Let\u0027s test it more thoroughly.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efunc(2, 2) \u003d\u003d 4;\nfunc(3, 5) \u003d\u003d 8;\nfunc(123, 321) \u003d\u003d 444;\nfunc(2836, 2312) \u003d\u003d 5148;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYeah, it sums the two numbers, but how? The insight here is that the bitwise \u003ccode\u003eXOR\u003c/code\u003e behaves like a sum modulus 2, thus throwing off the carry bit. But the carry only happens when the bit of the same position are 1s, thus when the bitwise \u003ccode\u003eAND\u003c/code\u003e is equal one. After calculating the carry and the sum modulus 2, we need to add then and use the same procedure to do it.\u003c/p\u003e\u003cp\u003eThis procedure is finite and takes at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e iterations, why? \u003cem\u003eHint: look at the second argument.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eNice, now I know how to sum two integers without using the \u003ccode\u003e+\u003c/code\u003e operator, but why is that useful? It should not be. The point is that mathematics is all about finding patterns and making analogies. If you don\u0027t know how to tackle a problem, try to simulate base cases, find the answer for the smallest instances and try to build a intuition about it. With that mindset and the algorithms here present I hope to make problems easier for you.\u003c/p\u003e\u003ch2\u003ePreliminars\u003c/h2\u003e\u003cp\u003eHere we present the most basic algorithms that should be base for the following content.\u003c/p\u003e\u003cp\u003eOne task that is very common is to \u003cstrong\u003eexponentiate\u003c/strong\u003e. When our exponent is a large number this can be very time consuming, here is a better way to do it:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// Fast exponential - O(log(b))\nll exp(ll b, ll e, ll mod) {\n  ll ans \u003d 1;\n  while (e) {\n    if (e\u0026amp;1) ans \u003d ans*b % mod;\n    b \u003d b*b % mod;\n    e /\u003d 2;\n  }\n  return ans;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis algorithm is bases on the fact that we can always write \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e \u003d (\u003ci\u003eb\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003ci\u003ek\u003c/i\u003e + 1\u003c/sup\u003e \u003d \u003ci\u003eb\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. This is also known as \u003ca href\u003d\"https://en.wikipedia.org/wiki/Exponentiation_by_squaring\"\u003eexponentiation by squaring\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eOn number theory (and maybe in the whole mathematics) the oldest and most known \u003ca href\u003d\"https://en.wikipedia.org/wiki/Euclidean_algorithm\"\u003ealgorithm is due to Euclid\u003c/a\u003e. It is used to find the \u003cstrong\u003egreatest common divisor between\u003c/strong\u003e two numbers.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// Euclid Algorithm - O(log(a) + log(b)\nll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eFinding primes\u003c/h2\u003e\u003cp\u003eThere are two simple deterministic ways to find if a number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is prime. The first one is to test if the only (positive) divisors of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e are \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. We can optimize it a little bit checking only if the numbers from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/5c/4e5c9f371024ad4e1f5b0f2dfeb967ffe7cb5f4e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e are divisors.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// Brute Force - O(sqrt(n))\nbool is_prime(int n) {\n  for(int i\u003d2; i*i\u0026lt;\u003dn; ++i) if (n % i \u003d\u003d 0) return false;\n  return true;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnother way to do this is using the \u003ca href\u003d\"https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\"\u003eSieve of Eratosthenes\u003c/a\u003e. Here is the code that implements it, check the above link for a nice graphical demonstration of the algorithm.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// Sieve of Eratosthenes - O(n * logn * log(log(n)))\nint cmp[N]; // Equals 1 if the number is composite\nfor (ll i \u003d 2; i \u0026lt; N; ++i) if (!cmp[i])\n  for (ll j \u003d i*i; j \u0026lt; N; j+\u003di) cmp[j] \u003d 1;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe following two tasks have two basic solutions, one based on the sieve of Eratosthenes and the other on having a list of primes. Both are useful, we have to analyze memory / time constraints to know which one to apply. In the cases that both works, go with the one that you are more comfortable with.\u003c/p\u003e\u003ch2\u003eFactorizing\u003c/h2\u003e\u003cp\u003eHaving a list of primes (that we can get with the sieve), we can just iterate through it and check if the number is divisible:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// Factorize Number - O(sqrt(n)/log(n))\nvector\u0026lt;int\u0026gt; p; // primes\nmap\u0026lt;int, int\u0026gt; factorize(int n) {\n  map\u0026lt;int, int\u0026gt; fact;\n  for(int i\u003d0; p[i]*p[i] \u0026lt;\u003d n; ++i) {\n    if (n % p[i]) continue;\n    while (n % p[i] \u003d\u003d 0) fact[p[i]]++, n /\u003d p[i];\n  }\n  if (n \u0026gt; 1) fact[n]++;\n  return fact;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe can adapt the sieve to find not only if the number is prime, but also to tell us the biggest prime divisor of it. Let us calculate \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/13/fb/13fb38f964899bf9299c8bc2dbf83b953a431626.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is the prime \u003ccode\u003ed[n]\u003c/code\u003e. Since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e \u0026lt; \u003ci\u003en\u003c/i\u003e\u003c/span\u003e we can find one prime factor of it and repeat the process. Iterating like this we can find all factors of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// Sieve of Eratosthenes to find Phi - O(n * logn * log(log(n)))\nint d[N]; // Calculate the biggest divisor of i\nfor (ll i \u003d 2; i \u0026lt; N; ++i) if (!d[i]) {\n  d[i] \u003d i;\n  for (ll j \u003d 2*i; j \u0026lt; N; j+\u003di) d[j] \u003d i;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOnce again, the sieve seems to be the best option in this case. But when we have to find the factorization of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e14\u003c/sup\u003e\u003c/span\u003e, for instance, the sieve is not enough because of memory and time constraints. The best way is to calculate all primes until \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e7\u003c/sup\u003e\u003c/span\u003e and then run the first algorithm of factorization, because it works if we have all primes until \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/5c/4e5c9f371024ad4e1f5b0f2dfeb967ffe7cb5f4e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003ch2\u003eNumber of Coprimes\u003c/h2\u003e\u003cp\u003eWe can use \u003ca href\u003d\"https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle\"\u003einclusion-exclusion principle\u003c/a\u003e to count the amount of numbers from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e that are coprime with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Let\u0027s call this function \u003cspan class\u003d\"tex-span\"\u003eφ(\u003ci\u003en\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e. When \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d \u003ci\u003em\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003eφ(\u003ci\u003en\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e) \u003d φ(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e it is know as \u003ca href\u003d\"https://en.wikipedia.org/wiki/Euler%27s_totient_function\"\u003eEuler\u0027s totient function\u003c/a\u003e. It can be calculated as:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// Phi(n) - O(sqrt(n) / log(n))\nint phi(int n, int m) {\n  map\u0026lt;int, int\u0026gt; fact \u003d factorize(n);\n  for(auto p : fact) m -\u003d m / p.first;\n  return m;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe can adapt the Sieve of Eratosthenes to calculate \u003cspan class\u003d\"tex-span\"\u003eφ(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// Sieve of Eratosthenes to find Phi - O(n * logn * log(log(n)))\nint cmp[N], phi[N];\nfor (ll i \u003d 1; i \u0026lt; N; ++i) phi[i] \u003d i;\nfor (ll i \u003d 2; i \u0026lt; N; ++i) if (!cmp[i]) {\n  phi[i]--;\n  for (ll j \u003d 2*i; j \u0026lt; N; j+\u003di) cmp[j] \u003d 1, phi[j] -\u003d phi[j]/i;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHaving the totient function is easy to calculate the more general one.\u003c/p\u003e\u003ch2\u003eLinear Diophantine Equations\u003c/h2\u003e\u003cp\u003eHow to solve \u003ccode\u003ex*a + y*b \u003d d\u003c/code\u003e? We can use the \u003ca href\u003d\"https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\"\u003eExtended Euclid Algorithm\u003c/a\u003e to do it. More on it can be read \u003ca href\u003d\"http://www.geeksforgeeks.org/basic-and-extended-euclidean-algorithms/\"\u003ehere\u003c/a\u003e. Here we present a more compact version:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid extgcd(int a, int b, int \u0026amp;x, int \u0026amp;y, int \u0026amp;d) {\n  if (b) extgcd(b, a%b, y, x, d), y -\u003d x*(a/b);\n  else x \u003d 1, y \u003d 0, d \u003d a;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eInverses, the Euler theorem and linear Diophantine equations\u003c/h2\u003e\u003cp\u003eWhen \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is prime, is easy to see that we can calculates all inverses \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/99/26/992694fb636a5d36994fbff380bd98a9eda19b3c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e by:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ell inv[N];\n\ninv[1] \u003d 1;\nfor (int i \u003d 2; i \u0026lt; p; ++i)\n  inv[i] \u003d (p - (p/i)*inv[p%i]%p)%p;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eJokes aside, it\u0027s not easy to see that. But if you want to understand it, you can check it out \u003ca href\u003d\"//codeforces.com/blog/entry/5457?#comment-106726\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eWhen the modulus is not prime we need not to worry. Euler comes to our rescue:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eEuler theorem\u003c/strong\u003e: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0b/e8/0be83a23d6affe4e0bbde1f10e6f18965dc88839.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eThis means we can calculate \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/26/d0/26d0146531f7384152d8ea3528b519351d36aea8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e easily (when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egcd\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e) \u003d 1\u003c/span\u003e) just using:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003einv[a] \u003d exp(a, phi[n]-1, n);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eUsually we only use this formula when n is prime, then we get:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003einv[a] \u003d exp(a, p-2, p);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen the mod is not prime, we can find:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ed \u003d gcd(a, n);\ninv[a]*a + k*n \u003d\u003d d // This is always true, for an value of k\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe can find inv[a] solving the linear Diophantine equation, so:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eextgcd(a, b, inv[a], k, d); // k should be ignored\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNotice that in the last code snippet, \u003ccode\u003einv[a]\u003c/code\u003e is the inverse of \u003ccode\u003ea\u003c/code\u003e only when \u003ccode\u003ed \u003d\u003d 1\u003c/code\u003e. The relation that is always true is: \u003ccode\u003einv[a]*a \u003d\u003d d  (mod n)\u003c/code\u003e.\u003c/p\u003e\u003ch2\u003eProblems\u003c/h2\u003e\u003cp\u003eSome selected number theory problems can be found \u003ca href\u003d\"https://docs.google.com/spreadsheets/d/1nE9jycO-OJtdDNlQo3xYvDZsWXWlMQX-_I47E2HPjL4/edit?usp\u003dsharing\"\u003ehere\u003c/a\u003e. I\u0027ll try to add some from other sources and sort by difficulty.\u003c/p\u003e\u003ch2\u003eTODO\u003c/h2\u003e \u003col\u003e   \u003cli\u003eAdd and filter problems (mainly from other sources)\u003c/li\u003e   \u003cli\u003eAdd Chinese Remainder Theorem\u003c/li\u003e   \u003cli\u003eAdd Probabilistic Primality Tests\u003c/li\u003e \u003c/ol\u003e\u003c/div\u003e","tags":[]}}