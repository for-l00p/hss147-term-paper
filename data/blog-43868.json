{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1458333982,"rating":89,"authorHandle":"ksun48","modificationTimeSeconds":1458338937,"id":43868,"title":"\u003cp\u003eEditorial for CROC 2016 Elimination Round\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/645/problem/A\" title\u003d\"CROC 2016 - Elimination Round\"\u003e645A - Amity Assessment\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eIdea:\u003c/strong\u003e \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/yummy\" title\u003d\"International master yummy\"\u003eyummy\u003c/a\u003e\u003c/p\u003e\u003cp\u003eOne solution is to just brute force and use DFS to try all the possibilities. Alternatively, note that two puzzles can be changed to each other if and only if the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e have the same orientation—clockwise or counterclockwise—in the puzzle. A third option, since the number of possibilities is so small, is to simply classify all of the \u003cspan class\u003d\"tex-span\"\u003e4! \u003d 24\u003c/span\u003e configurations by hand.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nstring b, b1, b2, e, e1, e2;\n\nint main(){\n  cin \u0026gt;\u0026gt; b1 \u0026gt;\u0026gt; b2 \u0026gt;\u0026gt; e1 \u0026gt;\u0026gt; e2;\n  swap(b2[0], b2[1]);\n  swap(e2[0], e2[1]);\n  b \u003d b1 + b2;\n  e \u003d e1 + e2;\n  b.erase(b.find(\u0027X\u0027), 1);\n  e.erase(e.find(\u0027X\u0027), 1);\n  if((b + b).find(e) !\u003d string::npos){\n\tcout \u0026lt;\u0026lt; \u0026quot;YESn\u0026quot;;\n  } else {\n\tcout \u0026lt;\u0026lt; \u0026quot;NOn\u0026quot;;\n  }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/645/problem/B\" title\u003d\"CROC 2016 - Elimination Round\"\u003e645B - Mischievous Mess Makers\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eIdea: \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/ksun48\" title\u003d\"Master ksun48\"\u003eksun48\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eLoosely speaking, we’re trying to reverse the array as much as possible.\u003c/p\u003e\u003cp\u003eIntuitively, the optimal solution seems to be to switch the first and last cow, then the second and second-to-last cow, and so on for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e minutes, unless the sequence is reversed already, in which case we are done. But how can we show that these moves give the optimal messiness?\u003c/p\u003e\u003cp\u003eIt is clear when \u003cspan class\u003d\"tex-span\"\u003e2·\u003ci\u003ek\u003c/i\u003e ≥ \u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e that we can reverse the array with this method.\u003c/p\u003e\u003cp\u003eHowever, when \u003cspan class\u003d\"tex-span\"\u003e2·\u003ci\u003ek\u003c/i\u003e \u0026lt; \u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e, there are going to be cows that we must not have not moved a single time. Since in each move we swap at most \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e cows, there must be at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 2·\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e cows that we have not touched, with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Two untouched cows \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e must have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u0026lt; \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, so there must be at least \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0b/87/0b875d2a21dd648d0776bb2ffa75c3ae2d74649f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e pairs of cows which are ordered correctly.\u003c/p\u003e\u003cp\u003eIn fact, if we follow the above process, we get that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d (\u003ci\u003en\u003c/i\u003e + 1) - \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e for the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e and last \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e cows, while \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e for the middle \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 2·\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e cows. From this we can see that the both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u0026lt; \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e happen only when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e are in the middle \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 2·\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e cows. Therefore we know our algorithm is optimal.\u003c/p\u003e\u003cp\u003eAn \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e solution, therefore, is to count how many incorrectly ordered pairs \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e are created at each step and add them up. When we swap cow \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e + 1) - \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e in step \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, this creates \u003cspan class\u003d\"tex-span\"\u003e1 + 2·(\u003ci\u003en\u003c/i\u003e - 2\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e more pairs. So the answer will be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ba/b5/bab5934585adfdc36cf5b2ec6c07ed44df45dc66.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eWe can reduce this to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e by using our earlier observation, that every pair except those \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0b/87/0b875d2a21dd648d0776bb2ffa75c3ae2d74649f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e pairs are unordered, which gives \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a9/a1/a9a1b231e815c9c8ddaedd33d1fada5f83e4933f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e total pairs \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e. Note that this does always not fit in a 32-bit integer.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long LL;\n\nint main(){\n\tLL n, k;\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k;\n\tLL c \u003d max(n-2*k,0LL);\n\tLL a \u003d n*(n-1)/2-c*(c-1)/2;\n\tcout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/645/problem/C\" title\u003d\"CROC 2016 - Elimination Round\"\u003e645C - Enduring Exodus\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eIdea: \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/GlebsHP\" title\u003d\"Grandmaster GlebsHP\"\u003eGlebsHP\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eFirst, observe that the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e rooms that Farmer John books should be consecutive empty rooms. Thus we can loop over all such sets of rooms with a sliding window in linear time. To check the next set of rooms, we simply advance each endpoint of our interval to the next empty room. Every time we do this, we need to compute the optimal placement of Farmer John’s room. We can maintain the position of his room with two pointers—as we slide our window of rooms to the right, the optimal position of Farmer John’s room should always move to the right or remain the same. This solution runs in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eAlternatively, we can use binary search or an STL set to find the best placement for Farmer John’s room as we iterate over the intervals of rooms. The complexity of these approaches is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5d/1f/5d1f29f648247e77966a5b1703590aea2a6a75b6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint N, K, res \u003d 1e9;\nstring S;\n\nint next(int i){ // finds the next empty room\n  do {\n    i +\u003d 1;\n  } while(i \u0026lt; N \u0026amp;\u0026amp; S[i] \u003d\u003d \u00271\u0027);\n  return i;\n}\n\nint main(){\n  cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; K \u0026gt;\u0026gt; S;\n  int l \u003d next(-1), m \u003d l, r \u003d l;\n  for(int i \u003d 0; i \u0026lt; K; i++){ // sets up the sliding window\n    r \u003d next(r);\n  }\n  while(r \u0026lt; N){\n    while(max(m - l, r - m) \u0026gt; max(next(m) - l, r - next(m))){\n      m \u003d next(m);\n    }\n    res \u003d min(res, max(m - l, r - m));\n    l \u003d next(l);\n    r \u003d next(r);\n  }\n  cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0027n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/645/problem/D\" title\u003d\"CROC 2016 - Elimination Round\"\u003e645D - Robot Rapping Results Report\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eIdea: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/abacadaea\" title\u003d\"Candidate Master abacadaea\"\u003eabacadaea\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe robots will become fully sorted if and only if there exists a path with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e vertices in the directed graph defined by the match results. Because it is guaranteed that the results are not contradictory, this graph must be directed and acyclic—a DAG. Thus we can compute the longest path in this DAG via dynamic programming or a toposort.\u003c/p\u003e\u003cp\u003eWe now have two cases. First, if the longest path contains \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e vertices, then it must uniquely define the ordering of the robots. This means the answer is the time at which the last edge was added to this path. Otherwise, if the longest path has fewer than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e vertices, then multiple orderings satisfy the results and you should print \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e. Note that this algorithm runs in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eAnother solution to this problem binary searches on the answer. For some \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, consider only those edges that were added before time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. We can determine if the robots could be totally ordered at time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e by running a toposort and checking if the longest path covers all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e vertices. This might be more intuitive for some, but has a complexity of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nconst int MAXN \u003d 1000005;\nint N, M, dp[MAXN], res[MAXN];\nvector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; adj[MAXN];\n\nint check(int v){\n  if(dp[v]) return dp[v];\n  dp[v] \u003d 1;\n  for(auto p : adj[v]){\n    int n \u003d p.first;\n    if(check(n) + 1 \u0026gt; dp[v]){\n      dp[v] \u003d dp[n] + 1;\n      res[v] \u003d max(res[n], p.second);\n    }\n  }\n  return dp[v];\n}\n\nint main(){\n  scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;N, \u0026amp;M);\n  for(int i \u003d 0; i \u0026lt; M; i++){\n    int a, b;\n    scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;a, \u0026amp;b);\n    a -\u003d 1, b -\u003d 1;\n    adj[a].push_back({b, i + 1});\n  }\n  for(int i \u003d 0; i \u0026lt; N; i++){\n    if(check(i) \u003d\u003d N){\n      printf(\u0026quot;%dn\u0026quot;, res[i]);\n      return 0;\n    }\n  }\n  printf(\u0026quot;-1n\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/645/problem/E\" title\u003d\"CROC 2016 - Elimination Round\"\u003e645E - Intellectual Inquiry\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eIdea: \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/yummy\" title\u003d\"International master yummy\"\u003eyummy\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eFor simplicity, let’s represent the letters by \u003cspan class\u003d\"tex-span\"\u003e1, 2, ..., \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e instead of actual characters. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e denote the number of distinct subsequences of the string that end in the letter \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Appending the letter \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e to a string only changes the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e. Note that the new \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e becomes \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/80/34/8034151c460a41fde17583a0ec7c4ad7dee87fb4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e—we can have the single letter \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, or append \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e to any of our old subsequences.\u003c/p\u003e\u003cp\u003eThe key observation is that no matter what character \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e we choose to append, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e will always end up the same. This suggests a greedy algorithm—always appending the character \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e with the smallest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e. But how do we know which \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e is minimal while maintaining their values modulo \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e + 7\u003c/span\u003e?\u003c/p\u003e\u003cp\u003eThe final observation is that if the last occurrence of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e is after the last occurrence of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u0027\u003c/span\u003e in our string, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e] \u0026gt; \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e\u0027]\u003c/span\u003e. This is true because appending \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e to the string makes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e larger than all other \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e. So instead of choosing the minimum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e, we can always choose the letter that appeared least recently. Since the sequence of letters we append becomes periodic, our solution runs in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5b/e7/5be7f5b4f91e0c4ebffeb1093b14954d00ffa46e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Of course, we can also find the least recently used letter with less efficient approaches, obtaining solutions with complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003eL\u003c/i\u003e + \u003ci\u003en\u003c/i\u003e)\u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD \u003d 1000000007;\nconst int MAXK \u003d 26;\nint N, K, last[MAXK], ord[MAXK];\nll dp[MAXK], sum;\nstring S;\n\nbool comp(int a, int b){\n  return last[a] \u0026lt; last[b];\n}\n\nvoid append(int c){\n  sum \u003d (sum - dp[c] + MOD) % MOD;\n  dp[c] \u003d (dp[c] + sum + 1) % MOD;\n  sum \u003d (sum + dp[c]) % MOD;\n}\n\nint main(){\n  cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; K \u0026gt;\u0026gt; S;\n  fill(last, last + K, -1);\n  for(int i \u003d 0; i \u0026lt; S.size(); i++){\n    int c \u003d S[i] - \u0027a\u0027;\n    last[c] \u003d i;\n    append(c);\n  }\n  iota(ord, ord + K, 0);\n  sort(ord, ord + K, comp);\n  for(int i \u003d 0; i \u0026lt; N; i++){\n    int c \u003d ord[i % K];\n    append(c);\n  }\n  cout \u0026lt;\u0026lt; (sum + 1) % MOD \u0026lt;\u0026lt; \u0027n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/645/problem/F\" title\u003d\"CROC 2016 - Elimination Round\"\u003e645F - Cowslip Collections\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eIdea: \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/desert97\" title\u003d\"Master desert97\"\u003edesert97\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eAfter each query, the problem is essentially asking us to compute the sum of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d0/95/d095600640519eaf9bda9c85e8e44a94bb6cf88f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for each choice of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e flowers. One quickly notes that it is too slow to loop over all choices of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e flowers, as there could be up to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/96/34/96346fbd9682fc23c89fd112d041027cdf202927.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e choices of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e species.\u003c/p\u003e\u003cp\u003eSo how can we compute a sum over \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/96/34/96346fbd9682fc23c89fd112d041027cdf202927.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e terms? Well, we will definitely need to use the properties of the gcd function. If we figure out for each integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e how many times \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/e1/f3e11a62eee63ebd1f5c14b195fa1ff840e8a5e9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e occurs in the sum (let this be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e)\u003c/span\u003e), then our answer will be equal to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9d/60/9d60209126ca4b5223a80e8792d7e17c7a66a00d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e overall all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIt seems that if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e)\u003c/span\u003e is the number of multiples of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e in our sequence, then there are \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/fe/ac/feac085e53c88dd6d057bbf31b9176577cedaa83.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e-tuples which have gcd \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. Yet there is something wrong with this reasoning: some of those \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e-tuples can have gcd \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, or \u003cspan class\u003d\"tex-span\"\u003e3\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, or any multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. In fact, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/50/8f/508f7ecff1a04afc5360229fce06528d0196cba6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, the number of gcds which are a multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eWe will try to write \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9d/60/9d60209126ca4b5223a80e8792d7e17c7a66a00d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e as a sum of these \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d3/fe/d3fe23595be879ccb2ada9a68912c4f15e989cc4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. We’ll take an example, when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e ranges from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e. The sum we wish to compute is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(1) + 2\u003ci\u003eg\u003c/i\u003e(2) + 3\u003ci\u003eg\u003c/i\u003e(3) + 4\u003ci\u003eg\u003c/i\u003e(4)\u003c/span\u003e which can be written as\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eg\u003c/i\u003e(1) + \u003ci\u003eg\u003c/i\u003e(2) + \u003ci\u003eg\u003c/i\u003e(3) + \u003ci\u003eg\u003c/i\u003e(4)) + (\u003ci\u003eg\u003c/i\u003e(2) + \u003ci\u003eg\u003c/i\u003e(4)) + 2(\u003ci\u003eg\u003c/i\u003e(3)) + 2(\u003ci\u003eg\u003c/i\u003e(4)), \u003c/span\u003e\u003c/center\u003e\u003cp\u003eor \u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b3/bb/b3bbbfb91126b5909e89478d2e9b5a17c8d1fd21.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eIn general, we want to find coefficients \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e such that we can write \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9d/60/9d60209126ca4b5223a80e8792d7e17c7a66a00d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e as \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/75/96/75964b87de398d3a0f32362664bab451450c7086.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Equating coefficients of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e)\u003c/span\u003e on both sides, we get that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/13/23/1323c1c2f7e9802b975a8c765b5b1bd673a9cabd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. (The mathematically versed reader will note that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d φ(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e, Euler\u0027s totient function, but this is not necessary to solve the problem.)\u003c/p\u003e\u003cp\u003eWe can thus precalculate all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5e/98/5e986048c24d15950c638ce6078974a20f8e3270.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e using a recursive formula: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f8/28/f828a89147beae7c53385f610e8b8f4fc5f06d6a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. We can also precalculate \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0d/56/0d56300fb438ab57cb7a0a0d49c2316db807d2a8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e ≤ 200000\u003c/span\u003e, so in order to output \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f6/99/f699ede8d3ea19d42a15c023db294cc14266fb7b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e after each query we should keep track of the values of the function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e, the number of multiples of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. When receiving \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e flowers, we only need to update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e for the divisors of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and add \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/af/9e/af9ec677aac86fa32be48f4140151b8ae9b378cb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. If we precompute the list of divisors of every integer using a sieve or sqrt checking, each update requires \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003edivisors\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThus the complexity of this algorithm is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b0/08/b0086d8865d90bd446b39042fa9187547685aa2e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e or \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/20/8c/208c044396e91ceac3153e6e67838c1fe8325939.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e preprocessing, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003en\u003c/i\u003e + \u003ci\u003eq\u003c/i\u003e)·\u003ci\u003emax\u003c/i\u003e(\u003ci\u003edivisors\u003c/i\u003e))\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD \u003d 1000000007;\nconst int MAXN \u003d 200005;\nconst int MAXA \u003d 1000005;\nint N, K, Q, A[MAXN];\nint use[MAXA], phi[MAXA], cnt[MAXA];\nvector\u0026lt;int\u0026gt; divisors[MAXA];\nll bin[MAXN], res;\n\nll inv(ll a, ll p){\n  if(a \u003d\u003d 1) return 1;\n  return (p - p / a) * inv(p % a, p) % p;\n}\n\nvoid read(){\n  scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;N, \u0026amp;K, \u0026amp;Q);\n  for(int i \u003d 0; i \u0026lt; N + Q; i++){\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;A[i]);\n    use[A[i]] \u003d 1;\n  }\n}\n\nvoid init(){\n  iota(phi, phi + MAXA, 0);\n  for(int i \u003d 1; i \u0026lt; MAXA; i++){\n    for(int j \u003d i; j \u0026lt; MAXA; j +\u003d i){\n      if(i !\u003d j) phi[j] -\u003d phi[i];\n      if(use[j]) divisors[j].push_back(i);\n    }\n  }\n  bin[K - 1] \u003d 1;\n  for(int i \u003d K; i \u0026lt; MAXN; i++){\n    bin[i] \u003d bin[i - 1] * i % MOD * inv(i - K + 1, MOD) % MOD;\n  }\n}\n\nint main(){\n  read();\n  init();\n  for(int i \u003d 0; i \u0026lt; N + Q; i++){\n    for(int d : divisors[A[i]]){\n      res \u003d (res + bin[cnt[d]] * phi[d]) % MOD;\n      cnt[d] +\u003d 1;\n    }\n    if(i \u0026gt;\u003d N){\n      printf(\u0026quot;%dn\u0026quot;, res);\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/645/problem/G\" title\u003d\"CROC 2016 - Elimination Round\"\u003e645G - Armistice Area Apportionment\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eIdea: \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/yummy\" title\u003d\"International master yummy\"\u003eyummy\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThanks to \u003ca class\u003d\"rated-user user-legendary\" href\u003d\"/profile/TooDifficuIt\" title\u003d\"Legendary grandmaster TooDifficuIt\"\u003e\u003cspan class\u003d\"legendary-user-first-letter\"\u003eT\u003c/span\u003eooDifficuIt\u003c/a\u003e and \u003ca class\u003d\"rated-user user-legendary\" href\u003d\"/profile/Petr\" title\u003d\"Legendary grandmaster Petr\"\u003e\u003cspan class\u003d\"legendary-user-first-letter\"\u003eP\u003c/span\u003eetr\u003c/a\u003e for sharing a solution with me that is much more intuitive than the one I originally had in mind! It works as follows:\u003c/p\u003e\u003cp\u003eFirst, let’s try to solve the smaller case where we only have two points. Let \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/86/84/8684977e56e9f2b9817d0c41d8143796eef18e29.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e be the line passing through \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. We want to compute the difference of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/86/84/8684977e56e9f2b9817d0c41d8143796eef18e29.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e relative to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e. Define \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e’\u003c/span\u003e as the reflection of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e over \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/86/84/8684977e56e9f2b9817d0c41d8143796eef18e29.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. By the triangle inequality, we have \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003ePX\u003c/i\u003e - \u003ci\u003eQX\u003c/i\u003e| \u003d |\u003ci\u003eP\u003c/i\u003e’\u003ci\u003eX\u003c/i\u003e - \u003ci\u003eQX\u003c/i\u003e| ≤ \u003ci\u003eP\u003c/i\u003e’\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e. Equality can be achieved when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e’\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e are collinear—that is, when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e is the intersection of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/86/84/8684977e56e9f2b9817d0c41d8143796eef18e29.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and line \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e’\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e. (If \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/86/84/8684977e56e9f2b9817d0c41d8143796eef18e29.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e’\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e are parallel, we can imagine that they intersect at infinity.) Therefore, the difference of a line \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/86/84/8684977e56e9f2b9817d0c41d8143796eef18e29.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e relative to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e is the distance from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e’\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe can also think about \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e’\u003c/span\u003e in a different way. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the circle with center \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e that pases through \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e. Then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e’\u003c/span\u003e is the second intersection of the two circles \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Thus our problem of finding a line with minimum difference becomes equivalent to finding the intersection among \u003cspan class\u003d\"tex-span\"\u003e{\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e}\u003c/span\u003e that lies closest to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e. This last part we can do with a binary search.\u003c/p\u003e\u003cp\u003eConsider the problem of checking if two circles \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e intersect at a point within a distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e. In other words, we wish to check if they intersect inside a circle \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e of radius \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e centered at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the arcs of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e contained by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, respectively. Observe that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e intersect inside the circle if and only if the two arcs overlap, but do not contain each other. Thus we can verify this condition for all pairs of points with a radial sweep line along the circle. Due to the binary search and the sorting necessary for the sweep line, this solution runs in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f9/f4/f9f4ed81610d15d508510be4f54be908bfefdf0b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e is the precision required.\u003c/p\u003e\u003cp\u003eOne might also wonder if precision will be an issue with all the calculations that we’re doing. It turns out that it won’t be, since our binary search will always stabilize the problem and get us very close to the answer. \u003c/p\u003e\u003cp\u003eHere’s my original solution using a projective transformation:\u003c/p\u003e\u003cp\u003eWe begin by binary searching on the the minimum possible difference. Thus we wish to solve the decision problem \u0026quot;Can a difference of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e be achieved?\u0026quot; Consider the hyperbola \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003ePX\u003c/i\u003e - \u003ci\u003eQX\u003c/i\u003e| \u003d \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Note that our answer is affirmative if and only if a pair of outposts defines a line that does not intersect the hyperbola.\u003c/p\u003e\u003cp\u003eOur next step is a reduction to an equivalent decision problem on a circle through a projective transformation. We express this transformation as the composition of two simpler operations. The first is an affine map that takes the hyperbola \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003ePX\u003c/i\u003e - \u003ci\u003eQX\u003c/i\u003e| \u003d \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e to the unit hyperbola. The second maps homogenous coordinates \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e, \u003ci\u003ez\u003c/i\u003e)\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ez\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e. Under the latter, the unit hyperbola \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e - \u003ci\u003ey\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e \u003d \u003ci\u003ez\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e goes to the unit circle \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e + \u003ci\u003ey\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e \u003d \u003ci\u003ez\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eBecause projective transformations preserve collinearity, a line intersecting the hyperbola is equivalent to a line intersecting the circle. Thus we want to know if any pair of the outposts\u0027 images defines a line that does not intersect the circle. We now map the image of each outpost to the minor arc on the unit circle defined by its tangents. (We disregard any points lying inside the circle.) Observe that our condition is equivalent to the existence of two intersecting arcs, neither of which contains the other. Verifying that two such arcs exist can be done with a priority queue and a radial sweep line in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5d/1f/5d1f29f648247e77966a5b1703590aea2a6a75b6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eThe total complexity of our solution is therefore \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/15/c3/15c314b65b7edabe85323c5dc31cf1731deefe78.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e is the precision that we need. It turns out that the implementation of this algorithm is actually pretty neat:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\ntypedef long double ld;\n\nconst ld EPS \u003d 1e-12;\nconst ld PI \u003d acos(-1);\nconst int MAXN \u003d 100005;\nint N;\nld A, X[MAXN], Y[MAXN];\n\nbool check(ld m){\n  ld u \u003d m / 2;\n  ld v \u003d sqrt(A * A - u * u);\n  vector\u0026lt;pair\u0026lt;ld,ld\u0026gt;\u0026gt; ev;\n  for(int i \u003d 0; i \u0026lt; N; i++){\n    ld x \u003d 1, y \u003d Y[i] / v, alpha;\n    if(X[i] !\u003d 0){\n      x *\u003d u / X[i], y *\u003d u / X[i];\n      ld r \u003d sqrt(x * x + y * y);\n      if(r \u0026lt; 1) continue;\n      alpha \u003d acos(1 / r);\n    } else {\n      alpha \u003d PI / 2;\n    }\n    ld base \u003d atan2(y, x) - alpha;\n    if(base \u0026lt; 0) base +\u003d 2 * PI;\n    ev.push_back({base, base + 2 * alpha});\n  }\n  priority_queue\u0026lt;ld, vector\u0026lt;ld\u0026gt;, greater\u0026lt;ld\u0026gt;\u0026gt; pq;\n  sort(ev.begin(), ev.end());\n  for(int i \u003d 0; i \u0026lt; 2; i++){\n    for(int j \u003d 0; j \u0026lt; ev.size(); j++){\n      while(pq.size() \u0026amp;\u0026amp; pq.top() \u0026lt; ev[j].first) pq.pop();\n      if(pq.size() \u0026amp;\u0026amp; pq.top() \u0026lt; ev[j].second) return 1;\n      pq.push(ev[j].second);\n      ev[j].first +\u003d 2 * PI;\n      ev[j].second +\u003d 2 * PI;\n    }\n  }\n  return 0;\n}\n\nint main(){\n  ios::sync_with_stdio(0);\n  cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; A;\n  for(int i \u003d 0; i \u0026lt; N; i++){\n    cin \u0026gt;\u0026gt; X[i] \u0026gt;\u0026gt; Y[i];\n  }\n  ld lo \u003d 0, hi \u003d 2 * A;\n  while(hi - lo \u0026gt; EPS){\n    ld mid \u003d (lo + hi) / 2;\n    (check(mid) ? hi : lo) \u003d mid;\n  }\n  cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(10);\n  cout \u0026lt;\u0026lt; (lo + hi) / 2 \u0026lt;\u0026lt; \u0027n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}