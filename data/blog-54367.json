{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1504709725,"rating":3,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1504709725,"id":54367,"title":"\u003cp\u003eNotes on Codeforces Beta Round #75, A, B, C, D(Grouping and sort), E\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/92/problem/A\" title\u003d\"Codeforces Beta Round 75 (Div. 2 Only)\"\u003e92A - Chips\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIt can be observed that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e people will consume \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/18/7e/187e4a128f35b2fc29dd243a2a4e122e88c41eeb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e elements. Thus, we should first compute the remainder \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e%\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, and then find out the maximum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e so that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a8/9b/a89b6b7d8d98edfc171d50eca3a3b899e37aabb8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. The answer is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/82/f3820da2c9c3030e0b043864a0103edc3812df95.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/92/problem/B\" title\u003d\"Codeforces Beta Round 75 (Div. 2 Only)\"\u003e92B - Binary Number\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is a simulation problem. We start from the end of the binary sequence, and enumerate the digit one by one. If we meet a “0”, then do nothing; otherwise we simulate the binary addition of adding “1” to the current position. When the sequence reduces to a single “1”, the number of total operations is just the answer.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/92/problem/C\" title\u003d\"Codeforces Beta Round 75 (Div. 2 Only)\"\u003e92C - Newspaper Headline\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTo construct the second string while using the the minimum number of the first string, we can adopt the greedy algorithm. \u003c/p\u003e\u003cp\u003eSpecifically, we maintain a variable \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e, which is set to \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e initially. For any letter appearing in the second string, we should find the same letter in the first string with the smallest index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e satisfying \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026gt; \u003ci\u003eS\u003c/i\u003e\u003c/span\u003e. Then, we update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u003d \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. When we can not find the required \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, it implies that we have to start from the beginning of the first string again, which will set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u003d  - 1\u003c/span\u003e. This also means that the number of the first string should be added by one.\u003c/p\u003e\u003cp\u003eTo implement the above algorithm, we can store the positions of each letter in previous, in an increasing order. Thus, we can use binary search to find out the smallest index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e satisfying \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026gt; \u003ci\u003eS\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/92/problem/D\" title\u003d\"Codeforces Beta Round 75 (Div. 2 Only)\"\u003e92D - Queue\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is a classic “inversal pair” problem, but asking to find out the farthest “inversal pair”.\u003c/p\u003e\u003cp\u003eThe basic idea is using suffix, specifically, suffix minimum index. For the original array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e]\u003c/span\u003e, we use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e]\u003c/span\u003e to denote its suffix minimum index, i.e., \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e gives the index from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e so that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003eb\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]]\u003c/span\u003e is the minimum value among \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e], \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1], \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 2], ..., \u003ci\u003ea\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e - 1]\u003c/span\u003e. Furthermore, as there may exist duplicate values, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e should be the maximum index if there are several equal minimum values.\u003c/p\u003e\u003cp\u003eNext, to find the farthest inversal pair of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e, we can implement binary search among \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e], \u003ci\u003eb\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1], ..., \u003ci\u003eb\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e - 1]\u003c/span\u003e and find out the largest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e so that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u0026gt; \u003ci\u003ea\u003c/i\u003e[\u003ci\u003eb\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]]\u003c/span\u003e holds. The binary can succeed since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e is a nondecreasing sequence.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/92/problem/E\" title\u003d\"Codeforces Beta Round 75 (Div. 2 Only)\"\u003e92E - Ski Base\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWell, I can only come up with a “not so strict” proof...\u003c/p\u003e\u003cp\u003eWe adopt a variable \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e with initial value equal to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Whenever we find that the currently added edge belongs to a connected component, we multiply \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e (remember to calculate the modulo), and output the answer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e - 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTo prove the correctness of the above formula, we divide all the edges into two types \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e, with the former one containing the edges that do not belong to any components while the latter one containing the edges belonging to some component. If we remove all the edges from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e, then the graph reduces to several unconnected components, and thus no ski base can be built. As we add edges from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e, the graph “begins” to contain at least one component. As we have \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e|\u003ci\u003eT\u003c/i\u003e|\u003c/sup\u003e\u003c/span\u003e ways to choose edges from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e, we can have \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e|\u003ci\u003eT\u003c/i\u003e|\u003c/sup\u003e - 1\u003c/span\u003e ski bases. The term “-1” comes from the empty case, where no edges from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e are selected, since this leads to no ski base.\u003c/p\u003e\u003c/div\u003e","tags":[]}}