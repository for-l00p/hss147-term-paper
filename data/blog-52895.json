{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1498411700,"rating":127,"authorHandle":"send_nodes","modificationTimeSeconds":1499205929,"id":52895,"title":"\u003cp\u003eCodeforces Round #420 (Div. 2) Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eFirst, I really need to apologize for the round. There was a serious problem in D that was even covered in the sample test, that the main solution did not handle correctly. I should have been much more careful with this problem and looked for these kind of cases. Unfortunately, it was a big enough issue that caused the round to be unrated. I know this upset a lot of people, but it\u0027s tricky to find a solution to this kind of problem after the problem has happened.\u003c/p\u003e\u003cp\u003eI still hope the problems were good quality. If you learned something new from the round, or from this editorial, then the round was worth it. I would advise to solve the problems you couldn\u0027t solve during the contest, so you can take away something from the round.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eIf you want any further clarification on a problem, please ask in comments!\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/821/A\"\u003e821A — Okabe and Future Gadget Laboratory\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe can simulate exactly what\u0027s described in the statement: loop over all cells not equal to 1 and check if it doesn\u0027t break the city property. To check if a cell breaks the property, just loop over an element in the same row, and an element in the same column, and see if they can add to give the cell\u0027s number. The complexity is O(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eSidenote: The definition of lab here was actually inspired from a USAMTS problem in 2016.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;queue\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;list\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;deque\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;bitset\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;functional\u0026gt;\n#include \u0026lt;numeric\u0026gt;\n#include \u0026lt;utility\u0026gt;\n#include \u0026lt;sstream\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;iomanip\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n#include \u0026lt;complex\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;climits\u0026gt;\nusing namespace std;\n//macros\ntypedef long long ll;\ntypedef complex\u0026lt;double\u0026gt; point;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef vector\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; vvi;\n\n\n\n\n#define FOR(k,a,b) for(int k\u003d(a); k\u0026lt;\u003d(b); ++k)\n#define REP(k,a) for(int k\u003d0; k\u0026lt;(a);++k)\n#define SZ(a) int((a).size())\n#define ALL(c) (c).begin(),(c).end()\n#define PB push_back\n#define MP make_pair\n#define INF 999999999\n#define INFLONG 1000000000000000000LL\n#define MOD 1000000007\n#define MAX 100\n#define ITERS 100\n#define pi 3.1415926\n#define MAXN 100000\n#define _gcd __gcd\n\nint main()\n{\n    int n;\n    cin \u0026gt;\u0026gt; n;\n    int grid[50][50];\n    REP(i,n){\n        REP(j,n){\n            cin \u0026gt;\u0026gt; grid[i][j];\n        }\n    }\n    REP(i,n){\n        REP(j,n){\n            if(grid[i][j]\u003d\u003d1) continue;\n            bool pass \u003d false;\n            for(int r \u003d 0;r\u0026lt;n;r++){\n                if(r\u003d\u003di) continue;\n                for(int c \u003d 0; c \u0026lt; n; c++){\n                    if(c\u003d\u003dj) continue;\n                    int sum \u003d grid[r][j]+grid[i][c];\n                    if(sum\u003d\u003dgrid[i][j]){\n                        pass\u003dtrue;\n                        break;\n                    }\n                }\n                if(pass)break;\n            }\n            if(!pass){\n                cout \u0026lt;\u0026lt; \u0026quot;No\u0026quot;\u0026lt;\u0026lt;endl;\n                return 0;\n            }\n        }\n    }\n    cout \u0026lt;\u0026lt; \u0026quot;Yes\u0026quot;\u0026lt;\u0026lt;endl;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/821/B\"\u003e821B — Okabe and Banana Trees\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe critical observation to make is that the optimal rectangle should always have a lower-left vertex at the origin. This is due to the fact that the line has positive y-intercept and negative slope: any rectangle which doesn\u0027t have a vertex at the origin could easily be extended to have a vertex at the origin and even more bananas.\u003c/p\u003e\u003cp\u003eThen, we just need to try every x-coordinate for the upper-right corner of the box and pick the maximum y-coordinate without going over the line. We can compute the sum of any rectangle in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e using arithmetic series sums, so this becomes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ebm\u003c/i\u003e)\u003c/span\u003e because the x-intercept can be up to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebm\u003c/i\u003e\u003c/span\u003e. You can make it faster by trying every y-coordinate; this makes the complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e, but this was unnecessary to solve the problem.\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ff/3d/ff3d4d32ecb4144fefbe5376fd90e3e55bc4c109.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e Can you solve the problem with better complexity?\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eO(b) Code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e#include \u0026lt;queue\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;list\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;deque\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;bitset\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;functional\u0026gt;\n#include \u0026lt;numeric\u0026gt;\n#include \u0026lt;utility\u0026gt;\n#include \u0026lt;sstream\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;iomanip\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n#include \u0026lt;complex\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;climits\u0026gt;\nusing namespace std;\n\n//macros\ntypedef long long ll;\ntypedef complex\u0026lt;double\u0026gt; point;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef vector\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; vvi;\n\n\n\n\n#define FOR(k,a,b) for(int k\u003d(a); k\u0026lt;\u003d(b); ++k)\n#define REP(k,a) for(int k\u003d0; k\u0026lt;(a);++k)\n#define SZ(a) int((a).size())\n#define ALL(c) (c).begin(),(c).end()\n#define PB push_back\n#define MP make_pair\n#define INF 999999999\n#define INFLONG 1000000000000000000\n#define MOD 1000000007\n#define MAX 100\n#define ITERS 100\n#define MAXM 200000\n#define MAXN 1000000\n#define _gcd __gcd\n#define eps 1e-9\nll series(ll x){\n\treturn x*(x+1)/2;\n}\nint main() {\n\tint m,b;\n\tcin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; b;\n\tll best \u003d 0;\n\tfor(int y \u003d b; y \u0026gt;\u003d0; y--){\n\t\t//y \u003d -x/m + b\n\t\tll x \u003d m*(b-y);\n\t\tll t \u003d 0;\n\t\tt+\u003d(x+1)*series(y)+(y+1)*series(x);\n\t\tbest \u003d max(best,t);\n\t}\n\tcout \u0026lt;\u0026lt; best \u0026lt;\u0026lt; endl;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/821/C\"\u003e821C — Okabe and Boxes\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIt looks like Daru should only reorder the boxes when he has to (i.e. he gets a remove operation on a number which isn\u0027t at the top of the stack). The proof is simple: reordering when Daru has more boxes is always not worse than reordering when he has less boxes, because Daru can sort more boxes into the optimal arrangement. Therefore, our greedy algorithm is as follows: simulate all the steps until we need to reorder, and then we resort the stack in ascending order from top to bottom.\u003c/p\u003e\u003cp\u003eThis has complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. However, we can speed this up if we note that whenever we reorder boxes, any box currently on the stack can be put in an optimal position and we can pretty much forget about it. So whenever we reorder, we can just clear the stack as well and continue. This gives us \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e complexity because every element is added and removed exactly once.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;vector\u0026gt;\n#include \u0026lt;utility\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;climits\u0026gt;\n#include \u0026lt;deque\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;stack\u0026gt;\nusing namespace std;\n\n#define ll long long\n#define REP(i,a) for(int i \u003d 0; i \u0026lt; (a); i++)\n#define PB push_back\n#define SZ(a) (a).size()\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define fs first\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef pair\u0026lt;int,int\u0026gt; pii;\n\n\n\nint main()\n{\n    int n;\n    cin \u0026gt;\u0026gt; n;\n    stack\u0026lt;int\u0026gt; st;\n    int curr\u003d1;\n    int ans \u003d 0;\n    REP(i,2*n){\n        string str;\n        cin \u0026gt;\u0026gt; str;\n        assert(str[0]\u003d\u003d\u0027a\u0027 || str[0]\u003d\u003d\u0027r\u0027);\n        if(str[0]\u003d\u003d\u0027a\u0027){\n            int x;\n            cin \u0026gt;\u0026gt; x;\n            st.push(x);\n        }else if(str[0]\u003d\u003d\u0027r\u0027){\n            if(!st.empty()){\n                if(st.top()\u003d\u003dcurr){ //last thing added is what we need to remove\n                    st.pop();\n                }else{ //last thing we added is NOT what we need to remove\n                    ans++;\n                    while(!st.empty()) st.pop(); //clears the stack\n                }\n            }\n            curr++;\n        }\n    }\n    cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/821/D\"\u003e821D — Okabe and City\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst, let\u0027s make this problem into one on a graph. The important piece of information is the row and column we\u0027re on, so we\u0027ll create a node like this for every lit cell in the grid. Edges in the graph are 0 between 2 nodes if we can reach the other immediately, or 1 if we can light a row/column to get to it. Now it\u0027s a shortest path problem: we need to start from a given node, and with minimum distance, reach another node.\u003c/p\u003e\u003cp\u003eOnly problem is, number of edges can be large, causing the algorithm to time out. There are a lot of options here to reduce number of transitions. The most elegant one I found is \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Benq\" title\u003d\"Grandmaster Benq\"\u003eBenq\u003c/a\u003e\u0027s solution, which I\u0027ll describe here. From a given cell, you can visit any adjacent lit cells. In addition, you can visit any lit cell with difference in rows at most 2, and any lit cell with difference in columns at most 2. So from the cell (r,c), you can just loop over all those cells.\u003c/p\u003e\u003cp\u003eThe only tricky part is asking whether the current lit row/column should be a part of our BFS state. Since we fill the entire row/col and can then visit anything on that row/col, it doesn\u0027t matter where we came from. This means that you can temporarily light each row/column at most once during the entire BFS search.\u003c/p\u003e\u003cp\u003eSo complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e, with a log factor somewhere for map or priority queue. Interestingly enough, you can remove the priority queue log factor because the BFS is with weights 0 and 1 only, but it performs slower in practice. \u003c/p\u003e\u003cp\u003eYou can see the code implementing this approach below. \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eBenq\u0027s code:\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e/*#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt; \n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;*/\n#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n//using namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef pair\u0026lt;int, int\u0026gt; pii;\n//typedef tree\u0026lt;int,null_type,less\u0026lt;int\u0026gt;,rb_tree_tag,tree_order_statistics_node_update\u0026gt; ordered_set;\n\n#define FOR(i, a, b) for (int i\u003da; i\u0026lt;b; i++)\n#define F0R(i, a) for (int i\u003d0; i\u0026lt;a; i++)\n#define FORd(i,a,b) for (int i \u003d (b)-1; i \u0026gt;\u003d a; i--)\n#define F0Rd(i,a) for (int i \u003d (a)-1; i \u0026gt;\u003d 0; i--)\n \n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\nconst int MOD \u003d 1000000007;\ndouble PI \u003d 4*atan(1);\n\nint dr[10001], dc[10001];\nvi row[10001], col[10001];\npriority_queue\u0026lt;pii\u0026gt; todo;\nvector\u0026lt;pii\u0026gt; lights;\nint dist[10001];\nmap\u0026lt;pii,int\u0026gt; label;\nint xdir[4] \u003d {1,0,-1,0}, ydir[4] \u003d {0,1,0,-1};\nint n,m,k; \n\nvoid filrow(int i, int val){\n    if (i \u0026gt;\u003d 1 \u0026amp;\u0026amp; i \u0026lt;\u003d n \u0026amp;\u0026amp; dr[i] \u003d\u003d 0) {\n        dr[i] \u003d 1;\n        for (int x: row[i]) if (val \u0026lt; dist[x]) {\n            dist[x] \u003d val;\n            todo.push({-dist[x],x});\n        }\n    }\n}\n\nvoid filcol(int i, int val) {\n    if (i \u0026gt;\u003d 1 \u0026amp;\u0026amp; i \u0026lt;\u003d m \u0026amp;\u0026amp; dc[i] \u003d\u003d 0) {\n        dc[i] \u003d 1;\n        for (int x: col[i]) if (val \u0026lt; dist[x]) {\n            dist[x] \u003d val;\n            todo.push({-dist[x],x});\n        }\n    }\n}\n\nvoid ad(int x, int y, int val) {\n    if (label.find({x,y}) !\u003d label.end()) \n        if (dist[label[{x,y}]] \u0026gt; val) {\n            dist[label[{x,y}]] \u003d val;\n            todo.push({-val,label[{x,y}]});\n        }\n}\n\nint main() {\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k;\n    \n    F0R(i,k) {\n        int r,c; cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; c;\n        lights.pb({r,c});\n        row[r].pb(i);\n        col[c].pb(i);\n        label[{r,c}] \u003d i;\n    }\n    \n    F0R(i,10001) dist[i] \u003d MOD;\n    \n    if (label.find({n,m}) \u003d\u003d label.end()) {\n        filrow(n-1,1);\n        filrow(n,1);\n        filcol(m-1,1);\n        filcol(m,1);\n    } else todo.push({0,label[{n,m}]});\n    \n    \n    while (todo.size()) {\n        auto a \u003d todo.top(); todo.pop();\n        a.f \u003d -a.f;\n        if (a.f \u0026gt; dist[a.s]) continue;\n        \n        F0R(i,4) ad(lights[a.s].f+xdir[i],lights[a.s].s+ydir[i],a.f);\n        FOR(i,lights[a.s].f-2,lights[a.s].f+3) filrow(i,a.f+1);\n        FOR(i,lights[a.s].s-2,lights[a.s].s+3) filcol(i,a.f+1);\n    }\n    \n    if (dist[0] !\u003d MOD) cout \u0026lt;\u0026lt; dist[0];\n    else cout \u0026lt;\u0026lt; -1;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eAnother approach to this problem was using \u0026quot;virtual nodes\u0026quot;. Virtual nodes are an easy way to put transitions between related states while keeping number of edges low. In this problem, we can travel to any lit cell if its row differs by \u0026lt;\u003d2, or its column differs by at most 2, but naively adding edges would cause O(k^2) edges.\u003c/p\u003e\u003cp\u003eInstead, for every row, lets make a virtual node. For every lit cell in this row, put an edge between the lit cell and this virtual node with cost 1. We can do something similar for every column.\u003c/p\u003e\u003cp\u003eNow, it\u0027s easy to see that the shortest path in this graph suffices. A minor detail is that we should divide the answer by 2 since every skipping of a row or column ends up costing 2 units of cost.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/821/E\"\u003e821E — Okabe and El Psy Kongroo\u003c/a\u003e\u003c/p\u003e\u003cp\u003eYou can get a naive DP solution by computing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e, the number of ways to reach the point \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e. It\u0027s just \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e - 1, \u003ci\u003ey\u003c/i\u003e + 1) + \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e - 1, \u003ci\u003ey\u003c/i\u003e) + \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e - 1, \u003ci\u003ey\u003c/i\u003e - 1)\u003c/span\u003e, being careful about staying above x axis and under or on any segments.\u003c/p\u003e\u003cp\u003eTo speed it up, note that the transitions are independent of x. This is screaming matrix multiplication! First, if you don\u0027t know the matrix exponentiation technique for speeding up DP, you should learn it from \u003ca href\u003d\"https://www.hackerrank.com/topics/matrix-exponentiation\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eNow, let\u0027s think of the matrix representation. Since the x dimension is the long one and the y dimension is small, lets store a vector of values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is the number of ways to get to a y value of i at the current x value. This will be the initial vector for matrix multiplication.\u003c/p\u003e\u003cp\u003eNow, what about the transition matrix? Since our initial vector has length y and we need a matrix to multiply it with to map it to another vector with length y, we need a y by y matrix. Now, if you think about how matrix multiplication works, you come up with an idea like this: put a 1 in the entry (i,j) if from a y value of i we can reach a y value of j (i.e. \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003ei\u003c/i\u003e - \u003ci\u003ej\u003c/i\u003e| ≤ 1\u003c/span\u003e). Don\u0027t believe me, multiply some vector times a matrix of this form to see how and why the transition works.\u003c/p\u003e\u003cp\u003eYou can then build this matrix quickly and then matrix exponentiate for under every segment and multiply by the initial vector, then make the result as the new initial vector for the next segment. You should make sure to remove values from the vector if the next segment is lower, or add values to the vector if the next segment is higher. This gives complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enh\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003c/span\u003e log \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e) where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e \u003d 16\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e \u003d \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;queue\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;list\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;deque\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;bitset\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;functional\u0026gt;\n#include \u0026lt;numeric\u0026gt;\n#include \u0026lt;utility\u0026gt;\n#include \u0026lt;sstream\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;iomanip\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n#include \u0026lt;complex\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;climits\u0026gt;\n#include \u0026lt;chrono\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n#include \u0026lt;assert.h\u0026gt;\nusing namespace std;\n\n//macros\ntypedef long long ll;\ntypedef complex\u0026lt;double\u0026gt; point;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef vector\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; vvi;\n\n\n\n\n#define FOR(k,a,b) for(int k\u003d(a); k\u0026lt;\u003d(b); ++k)\n#define REP(k,a) for(int k\u003d0; k\u0026lt;(a);++k)\n#define SZ(a) int((a).size())\n#define ALL(c) (c).begin(),(c).end()\n#define PB push_back\n#define MP make_pair\n#define INF 1000000001\n#define INFLONG 1000000000000000000\n#define MOD 1000000007\n#define MAX 100\n#define ITERS 100\n#define MAXM 200000\n#define MAXN 1000000\n#define _gcd __gcd\n#define EPS 1e-7\n#define PI 3.1415926535897932384626\n#define ERR -987654321\n\n//multiplies m1 and m2 and stores in m3\nvector\u0026lt;vector\u0026lt;long long\u0026gt; \u0026gt; matmul(vector\u0026lt;vector\u0026lt;long long\u0026gt; \u0026gt; m1, vector\u0026lt;vector\u0026lt;long long\u0026gt; \u0026gt; m2, vector\u0026lt;vector\u0026lt;long long\u0026gt; \u0026gt; \u0026amp;m3){\n    m3.clear();\n    vector\u0026lt;vector\u0026lt;long long\u0026gt; \u0026gt; ans;\n    REP(i,SZ(m1)){\n        vector\u0026lt;long long\u0026gt; v;\n\n        REP(j,SZ(m2[0])){\n            v.PB(0);\n        }\n        ans.PB(v);\n    }\n\n    REP(r,SZ(m1)){\n        REP(c,SZ(m2[0])){\n            REP(k, SZ(m2)){\n                ans[r][c] +\u003d m1[r][k]*m2[k][c];\n                ans[r][c]%\u003dMOD;\n            }\n        }\n    }\n\n    REP(i,SZ(m1)){\n        vector\u0026lt;long long\u0026gt; cur;\n        REP(j,SZ(m2[0])){\n            cur.PB(ans[i][j]);\n        }\n        m3.PB(cur);\n    }\n    return m3;\n\n\n}\nvector\u0026lt;ll\u0026gt; mymul(vector\u0026lt;ll\u0026gt; vec, vector\u0026lt;vector\u0026lt;ll\u0026gt; \u0026gt; mat, vector\u0026lt;ll\u0026gt; \u0026amp;ret){\n    vector\u0026lt;ll\u0026gt; res;\n    REP(i,SZ(vec)){\n        ll sum \u003d 0;\n        for(int co \u003d 0; co \u0026lt; SZ(mat); co++){\n            sum +\u003d vec[co]*mat[co][i];\n            sum%\u003dMOD;\n        }\n        res.PB(sum);\n    }\n    ret.clear();\n    REP(i,SZ(res)) ret.PB(res[i]);\n    return ret;\n}\nvoid printmat(vector\u0026lt;vector\u0026lt;long long\u0026gt; \u0026gt; matr){\n    REP(i,SZ(matr)){\n        REP(j,SZ(matr[i])){\n            cout \u0026lt;\u0026lt; matr[i][j] \u0026lt;\u0026lt; \u0026quot; \u0026quot; ;\n        }\n        cout \u0026lt;\u0026lt; endl;\n    }\n}\nvector\u0026lt;vector\u0026lt;long long\u0026gt; \u0026gt; matexp(vector\u0026lt;vector\u0026lt;long long\u0026gt; \u0026gt; matr, long long n){\n    vector\u0026lt;vector\u0026lt;long long\u0026gt; \u0026gt; ans;\n    REP(i,SZ(matr)){\n        vector\u0026lt;long long\u0026gt; v;\n        REP(j,SZ(matr[0])){\n            v.PB((i\u003d\u003dj));\n        }\n        ans.PB(v);\n    }\n    long long t \u003d n;\n\n    while(t\u0026gt;0){\n\n        if(t%2\u003d\u003d0){\n            matmul(matr,matr,matr);\n            t/\u003d2;\n        }\n        else{\n            matmul(ans,matr,ans);\n            t--;\n        }\n    }\n\n    return ans;\n}\n\nint main()\n{\n    int n;\n    ll k;\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k;\n    vector\u0026lt;ll\u0026gt; a1,a2,b;\n    REP(i,n){\n        ll a1r, a2r, br;\n        cin \u0026gt;\u0026gt; a1r \u0026gt;\u0026gt; a2r \u0026gt;\u0026gt; br;\n        a1.PB(a1r);\n        a2.PB(a2r);\n        b.PB(br);\n    }\n    vector\u0026lt;ll\u0026gt; ans;\n    ans.PB(1);\n    a2[SZ(a2)-1] \u003d k;\n    REP(i,n){\n        //update ans size\n        while(SZ(ans) \u0026lt; b[i]+1) ans.PB(0);\n        while(SZ(ans) \u0026gt; b[i]+1) ans.erase(prev(ans.end()));\n        vector\u0026lt;vector\u0026lt;ll\u0026gt; \u0026gt; trans;\n        int len \u003d b[i]+1;\n        REP(pr,len){\n            vector\u0026lt;ll\u0026gt; lol;\n            REP(pro,len){\n                lol.PB(0);\n            }\n            trans.PB(lol);\n        }\n        REP(co,len){\n            if(co\u0026gt;0) trans[co-1][co] \u003d 1;\n            trans[co][co] \u003d 1;\n            if(co+1\u0026lt;len) trans[co+1][co] \u003d 1;\n        }\n        mymul(ans,matexp(trans,a2[i]-a1[i]),ans);\n    }\n    cout \u0026lt;\u0026lt; ans[0] \u0026lt;\u0026lt; endl;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}