{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1479308577,"rating":296,"authorHandle":"adamant","modificationTimeSeconds":1496146501,"id":48417,"title":"\u003cp\u003eGeneral ideas\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003e// Finally translated!\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eHi everyone!\u003c/p\u003e\u003cp\u003eDo you like ad hoc problems? I do hate them! That\u0027s why I decided to make a list of ideas and tricks which can be useful in mane cases. Enjoy and add more if I missed something. :) \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e1. Merging many sets in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/2f/10/2f1016d69bf9ff11e9f900cc40acc8199e5e4f45.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e amortized.\u003c/strong\u003e If you have some sets and you often need to merge some of theme, you can do it in naive way but in such manner that you always move elements from the smaller one to the larger. Thus every element will be moved only \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/38/fb/38fb4cb315633ef4d35ba82b8b1e4dafa30fe822.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e times since its new set always will be at least twice as large as the old one. Some versions of DSU are based on this trick. Also you can use this trick when you merge sets of vertices in subtrees while having dfs.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2. Tricks in statements, part 1.\u003c/strong\u003e As you may know, authors can try to hide some special properties of input to make problem less obvious. Once I saw constraints like \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/65/c1/65c1ee8bc5b94ea675955fc740fd31e0776f381e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Ha-ha, nice joke. It is actually \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/28/a0/28a077be1773c2c6dd016ee3608673a378053a69.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e3. \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d9/2f/d92f213042c5c9ccffbfe892fa9a1b0b43daf97f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e on subsegments.\u003c/strong\u003e Assume you have set of numbers in which you add elements one by one and on each step calculate \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d9/2f/d92f213042c5c9ccffbfe892fa9a1b0b43daf97f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e of all numbers from set. Then we will have no more than \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c6/01/c60137130ed75237b2312f1f3bd9091c99b3bff2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e different values of gcd. Thus you can keep compressed info about all \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d9/2f/d92f213042c5c9ccffbfe892fa9a1b0b43daf97f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e on subsegments of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/55/f9/55f91ebf758888bcac4a5ebfc4982160e30f6c15.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e: \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e    int a[n];\n    ...\n    map\u0026lt;int, int\u0026gt; sub_gcd[n];\n    /*\n    Key is gcd,\n    Value is the largest length such that gcd(a[i - len], ..., a[i]) equals to key.\n    */\n    sub_gcd[0][a[0]] \u003d 0;\n    for(int i \u003d 1; i \u0026lt; n; i++)\n    {\n        sub_gcd[i][a[i]] \u003d 0;\n        for(auto it: sub_gcd[i - 1])\n        {\n            int new_gcd \u003d __gcd(it.first, a[i]);\n            sub_gcd[i][new_gcd] \u003d max(sub_gcd[i][new_gcd], it.second + 1);\n        }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e4. From static set to expandable via \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3d/69/3d69cddefba4111def8d5f0157077b36e0fab174.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/strong\u003e Assume you have some static set and you can calculate some function \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6f/83/6f83379c2d4c5ef7000955635aa72bd49cca25ad.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e of the whole set such that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/c5/4ec529bfa1cc9a58e1e56bca37b66cccd7831a48.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6e/41/6e41f00b720c7da389c1080a7e3d26b4c19ea8ff.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is some function which can be calculated fast. For example, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c8/d3/c8d3a8c2f6cade2f7a2cd97360a2073990671746.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e as the number of elements less than \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/de/1e/de1e2205e44a30e53772fe149c5b57c6a7d68415.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/c7/7cc7114a1c736fb5b3f1e9a0bbc4195d6b048d29.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Or \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4f/e5/4fe5729ccf586603164b8207ee7b7fd222632a29.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e as the number of occurences of strings from \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1c/52/1c5277bb6d54839917fcb92ba88fb29273cd218b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e into \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/55/f7/55f72aed8f92602fb812b8f4d343b534fe04c5a0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6e/41/6e41f00b720c7da389c1080a7e3d26b4c19ea8ff.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is a sum again. \u003c/p\u003e\u003cp\u003eWith additional \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/75/5c/755c0e72a8f6c5be4007a41acbae4bf024107b8c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e factor you can also insert elements into your set. For this let\u0027s keep \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/75/5c/755c0e72a8f6c5be4007a41acbae4bf024107b8c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e disjoint sets such that their union is the whole set. Let the size of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7a/f8/7af8359d1848253266356b17c6407451aeee3c77.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e be either \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/48/de/48de3150586164f0222267e7dfe53e547c2a1a09.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e or \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/20/7b/207bcdc7ad58cbd7bc9796bf4b9ef7fb5ebc47ad.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e depending on binary presentation of the whole set size. Now when inserting element you should add it to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9d/ca/9dca8240902e04bbe2472b954f0c3fec3f12817d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e set and rebuild every set keeping said constraint. Thus \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7a/f8/7af8359d1848253266356b17c6407451aeee3c77.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e set will tale \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/83/92/83923970df37ef69eac771b729d23fba32c8a83f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e operations each \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/20/7b/207bcdc7ad58cbd7bc9796bf4b9ef7fb5ebc47ad.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e steps where \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/31/14/31140234f90ec76b1722de079fd2c8a6e4f44065.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is the cost of building set over \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/89/dd/89ddc6febc2878584a5fd8f10e39dad2e8f73de7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e elements from scratch which is usually something about \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/89/dd/89ddc6febc2878584a5fd8f10e39dad2e8f73de7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. I learned about this optimization from \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/burunduk1\" title\u003d\"International Grandmaster burunduk1\"\u003eburunduk1\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e5. \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7b/ea/7beade55e90846d70020a3d03521d3458b66751b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e-subsets.\u003c/strong\u003e Assume you have set of numbers and you have to calculate something considering xors of its subsets. Then you can assume numbers to be vectors in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/de/1e/de1e2205e44a30e53772fe149c5b57c6a7d68415.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e-dimensional space over field \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/15/63/15632c55e89c88ddd4aa952a1ccc31b9f83b279d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e of residues modulo 2. This interpretation useful because ordinary methods of linear algebra work here. For example, here you can see how using gaussian elimination to keep basis in such space and answer queries of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7a/f8/7af8359d1848253266356b17c6407451aeee3c77.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e largest subset xor: \u003ca href\u003d\"http://ideone.com/LLtY4q\"\u003elink\u003c/a\u003e. (\u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/amd\" title\u003d\"Master amd\"\u003eamd\u003c/a\u003e\u0027s problem from Hunger Games)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e6. Cycles in graph as linear space.\u003c/strong\u003e Assume every set of cycles in graph to be vector in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/60/5e/605eaee3beb24aae5448b13537e735be7fd8bf54.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e-dimensional space over \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/15/63/15632c55e89c88ddd4aa952a1ccc31b9f83b279d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e having one if corresponding edge is taken into set or zero otherwise. One can consider combination of such sets of cycles as sum of vectors in such space. Then you can see that basis of such space will be included in the set of cycles which you can get by adding to the tree of depth first search exactly one edge. You can consider combination of cycles as the one whole cycle which goes through \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e-edges odd number of times and even number of times through \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e-edges. Thus you can represent any cycle as combination of simple cycles and any path as combination as one simple path and set of simple cycles. It could be useful if we consider pathes in such a way that going through some edge twice annihilates its contribution into some final value. Example of the problem: \u003ca href\u003d\"/contest/724/problem/G\"\u003e724G - Xor-matic Number of the Graph\u003c/a\u003e. Another example: find path from vertex \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5e/e7/5ee7dafd39be90b8743ef8b57dbad10343efcd8b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0b/19/0b19fff1be60ff43c0025a42773b0e0ebe05de85.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e with minimum xor-sum.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e7. Mo\u0027s algorithm.\u003c/strong\u003e Variant of \u003cem\u003esqrt\u003c/em\u003e-decomposition. Basic idea is that if you can do non-amortized insert of element in the set (i.e. having opportunity to revert it), then you can split array in \u003cem\u003esqrt\u003c/em\u003e blocks and consider queries such that their left ends lie in the same block. Then for each block you can add elements from its end to the end of the array. If you found some right end of query in that block you can add elements from the end of block to left end of query, answer the query since all elements are in the set and revert those changes then.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e8. Dinic\u0027s algorithm in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/10/ea/10eab2cd3e487914f92b789df23b0118fb9b782d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/strong\u003e This algorithm in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/04/f7/04f7212dc2197d5b56186f2804c0a777775f9f45.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is very fast on the majority of testcases. But you can makes its asymptotic better by very few new lines of code. For this you should add scaling idea to your algorithm, i.e. you can iterate powers of \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e and while it is possible to consider only edges having capacity at least \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/20/7b/207bcdc7ad58cbd7bc9796bf4b9ef7fb5ebc47ad.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. This optimization gives you \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/10/ea/10eab2cd3e487914f92b789df23b0118fb9b782d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e complexity. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e9. From expandable set to dynamic via \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/strong\u003e Assume for some set we can make non-amortized insert and calculate some queries. Then with additional \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e factor we can handle erase queries. Let\u0027s for each element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e find the moment when it\u0027s erased from set. Thus for each element we will wind segment of time \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/76/c7/76c71dd483db57c8f0184dfae0a5436aa30c3745.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e such that element is present in the set during this whole segment. Now we can come up with recursive procedure which handles \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b3/a1/b3a15711bbed5a6fce6b164a08471e51a6c03c3a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time segment considering that all elements such that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ee/04/ee040463156bcf19bfa1513ba4606cadee976ccb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e are already included into the set. Now, keeping this invariant we recursively go into \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/50/60/5060e6606ec2006b49dfdb66c746f248ce359d73.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bc/c5/bcc5f4da743bbd2876f6e54bb87f372bec99620c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e subsegments. Finally when we come into segment of length \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e we can handle the query having static set. I learned this idea from \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Burunduk1\" title\u003d\"International Grandmaster Burunduk1\"\u003eBurunduk1\u003c/a\u003e, and there is a separate entry about it (on dynamic connectivity). \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e10. Linear combinations and matrices.\u003c/strong\u003e Often, especially in dynamic programming we have to calculate the value wich is itself linear combination of values from previous steps. Something like \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7d/4e/7d4ea81fdace98fd193a841bd763f2b197293bad.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. In such cases we can write \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d7/7a/d77a6b47861dbc37dfb79bffe22d72c2239cf072.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e into the \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3d/08/3d08d85215011adb48442201065cd4ae6d1d6071.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e matrix and use binary exponentiation. Thus we get \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/15/56/15564c5d90a6de886588c7b0df3e7744294a2f30.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time instead of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/2c/a2/2ca2b1f7a7b42386047810998229b36f87f03456.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e11. Matrix exponentiation optimization.\u003c/strong\u003e Assume we have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3d/08/3d08d85215011adb48442201065cd4ae6d1d6071.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e matrix \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and we have to compute \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9a/7d/9a7df653f7c635ed405ecc881195b9d6b60e0b68.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e several times for different \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e. Naive solution would consume \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/83/8d/838d560d68ae3d1ccd7a9b36d0da424cadadb593.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time. But we can precalculate binary powers of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and use \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e multiplications of matrix and vector instead of matrix and matrix. Then the solution will be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/72/4e/724e985abe3c799d3c469da11097103c01549901.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, which may be significant. I saw this idea in one of \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/AlexanderBolshakov\" title\u003d\"Master AlexanderBolshakov\"\u003eAlexanderBolshakov\u003c/a\u003e\u0027s comments.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e12. Euler tour magic.\u003c/strong\u003e Consider following problem: you have a tree and there are lots of queries of kind add number on subtree of some vertex or calculate sum on the path between some vertices. \u003cem\u003eHLD?\u003c/em\u003e Damn, no! Let\u0027s consider two euler tours: in first we write the vertex when we enter it, in second we write it when we exit from it. We can see that difference between prefixes including subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e from first and second tours will exactly form vertices from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e to the root. Thus problem is reduced to adding number on segment and calculating sum on prefixes. \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Kostroma\" title\u003d\"International Grandmaster Kostroma\"\u003eKostroma\u003c/a\u003e told me about this idea. Woth mentioning that there are alternative approach which is to keep in each vertex linear function from its height and update such function in all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e\u0027s children, but it is hard to make this approach more general.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e13. Tricks in statements, part 2.\u003c/strong\u003e If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e sets are given you should note that the amount of different set sizes is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b7/37/b7379a4c34c521f82db6de42149509ebf531f7bd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e is total size of those sets. There is even stronger statement: no more than \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d7/32/d732a047284a7167489abac2350a7e227e5d8923.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e sets have size greater than \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d7/32/d732a047284a7167489abac2350a7e227e5d8923.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Obvious example is when we are given several strings with total length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e. Less obvious example: in cycle presentation of permutation there are at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/90/d5/90d5a6cd550a25d4a1e92f4f6e6a222c64aa7a2e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e distinct lengthes of cycles. This idea also can be used in some number theory problems. For example we want calculat \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/80/46/80469ff2fa2caebbe77010ce994636f84c36fa66.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Consider two groups: numbers less than \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/78/b1/78b102cce2eeb34659c69e9781bc4a4d3525ceb4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e we can bruteforce and for others we can bruteforce the result of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5f/a2/5fa2ad9c1eb7826d3ae07b724e44f693ca1f966e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e And calculate how many numbers will have such result of division.\u003cbr /\u003e Another interesting application is that in Aho-Corasick algorithm we can consider pathes to the root in suffix link tree using only terminal vertices and every such path will have at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b7/37/b7379a4c34c521f82db6de42149509ebf531f7bd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e vertices.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e14. Convex hull trick.\u003c/strong\u003e Assume we have dp of kind \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/65/55/65558b6abe13c191b6ea107a714c074c4ce995e4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, then we can maintain convex hull of linear functions which we have here and find the maximum with ternary search.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e15. xor-, and-, or-convolutions.\u003c/strong\u003e Consider ring of polynomials in which \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6c/30/6c306522c1b40d587eb41bfb1b70eb32d0509114.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e or \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8f/58/8f58faf07ed815238c6fcfb455b88c039851c9ea.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e or \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7a/4b/7a4b5b9911d9a88244edea4855e3a5f1e8f88777.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Just like in usual case \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9b/17/9b17703ffa2752e0118f95704af50fc6bd0f473a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e we can multiply such polynomials of size \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f0/29/f0291411c7e66abff8b8f1160b484a47cc97a664.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4c/3c/4c3c85cf6e5c0b720e46ad7622f65d11d323b009.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Let\u0027s interpret it as polynomial from \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/de/1e/de1e2205e44a30e53772fe149c5b57c6a7d68415.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e variables such that each variable has power \u003cspan class\u003d\"tex-span\"\u003e ≤ 1\u003c/span\u003e and the set of variables with quotient \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/25/ce/25ce2b538da78a79a025ae685c1f1458593818d5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is determined by binary presentation of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/de/1e/de1e2205e44a30e53772fe149c5b57c6a7d68415.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. For example, instead of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/6c/f36c9dedc6c389236ed43e76264808a64e01f9db.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e we will consider the polynomial \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/37/26/372628c64f9b29ccf9334eeab11eecaba3a0140c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Now note that if we consider values of this polynomial in the vertices of cube \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d8/b1/d8b1d11b8e1a05fc8060f0e80ec78be5f5915dae.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e then due to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/14/f3140d686046d51c94a4dfd2948ffcdbf1706f09.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, we can see that product of such polynomials will use exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exor\u003c/i\u003e\u003c/span\u003e rule in powers. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eor\u003c/i\u003e\u003c/span\u003e-convolution can be done in the same way considering vertices of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/16/31/163108c3aa43a37868ea6adeb2f27d130311de1f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and having \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c8/c6/c8c6703a5a8a77fbcf418f8e07f75a3c5a591a97.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eand\u003c/i\u003e\u003c/span\u003e-convolution you can find yourself as an excercise.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003exor-convolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003evoid transform(int *from, int *to) \n{ \n    if(to - from \u003d\u003d 1) \n        return; \n    int *mid \u003d from + (to - from) / 2; \n    transform(from, mid); \n    transform(mid, to); \n    for(int i \u003d 0; i \u0026lt; mid - from; i++) \n    {\n        int a \u003d *(from + i);\n        int b \u003d *(mid + i);\n        *(from + i) \u003d a + b;\n        *(mid + i) \u003d a - b;\n    }\n} \n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eor-convolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003evoid transform(int *from, int *to) \n{ \n    if(to - from \u003d\u003d 1) \n        return; \n    int *mid \u003d from + (to - from) / 2; \n    transform(from, mid); \n    transform(mid, to); \n    for(int i \u003d 0; i \u0026lt; mid - from; i++) \n        *(mid + i) +\u003d *(from + i); \n} \n\nvoid inverse(int *from, int *to) \n{ \n    if(to - from \u003d\u003d 1) \n        return; \n    int *mid \u003d from + (to - from) / 2; \n    inverse(from, mid); \n    inverse(mid, to); \n    for(int i \u003d 0; i \u0026lt; mid - from; i++) \n        *(mid + i) -\u003d *(from + i); \n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eFinally I may note that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eor\u003c/i\u003e\u003c/span\u003e-convolution is exactly sum over all submasks and that inverse transform for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exor\u003c/i\u003e\u003c/span\u003e-convolution is the same with initial one, except for we have to divide everything by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e in the end. Thanks to \u003ca class\u003d\"rated-user user-legendary\" href\u003d\"/profile/Endagorion\" title\u003d\"Legendary grandmaster Endagorion\"\u003e\u003cspan class\u003d\"legendary-user-first-letter\"\u003eE\u003c/span\u003endagorion\u003c/a\u003e for explaining me such interpretation of Walsh-Hadamard transform. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e16. FFT for two polynomials simultaneously.\u003c/strong\u003e Let \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f4/69/f469c97d10fa3b00ad95f8b5f3028ca651762c53.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e be the polynomials with real quotients. Consider \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1e/39/1e397d93030ca8d54cdddde5e9788f79bc802f8a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Note that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/53/33/53332922d3e672a1f83d8f9cbc9a7319b746abc8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, thus \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a0/e9/a0e999adb2807cc2be6976c9fec9fec9f862c79c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eNow backwards. Assume we know values of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e1/95/e195170dfc86d0765d4f7772e0308d07844ba874.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and know they have real quotients. Calculate inverse FFT for \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/55/2d/552d7e39f01c9cd4cb138e573293f096432d7502.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Quotients for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e will be real part and quotients for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e will be imaginary part.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e17. Modulo product of two polynomials with real-valued FFT.\u003c/strong\u003e If mod is huge we can lack accuracy. To avoid this consider \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/23/14/2314bc4c6725be7954ab241d2e2d8d7da7902068.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and calculate \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bf/18/bf18867608e38261592ba2b4316190f041e45c76.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Using the previous point it can be done in total of two forward and two backward FFT.\u003c/p\u003e\u003c/div\u003e","tags":[]}}