{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1524745169,"rating":0,"authorHandle":"GabrielCamargo","modificationTimeSeconds":1524745477,"id":59116,"title":"\u003cp\u003eSTL\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eÁ pedidos, segue um resumão de STL, vou colocar bastante código já que a maioria é exemplo prático Lembrando que todos os O(log) desse tutorial são na verdade O(log2) :p\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://www.cplusplus.com/reference/stl/\"\u003eReferencias C++\u003c/a\u003e\u003c/p\u003e\u003ch3\u003ecin/cout/vector/string\u003c/h3\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint n;\nstring x;\nvector\u0026lt;string\u0026gt; v;\n\nint main()\n{\n    ios :: sync_with_stdio(false); //para deixar o cin e o cout mais rapidos\n    cin \u0026gt;\u0026gt; n;\n    for (int i \u003d 0; i \u0026lt; n; ++i)\n\t{\n    \tcin \u0026gt;\u0026gt; x;\n    \tv.push_back(x); //adiciona a string x no fim do vector\n\t}\n\n\tfor (int i \u003d 0; i \u0026lt; v.size(); ++i) //v.size() eh o tamanho do vetor, O(1)\n\t{\n\t\tcout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n\t}\n    \n\n    if (v[0] \u003d\u003d v[1]) //compara se as duas primeiras strings sao iguais\n    {\n    \tcout \u0026lt;\u0026lt; \u0026quot;sao iguais\\n\u0026quot;;\n    }\n    else\n    {\n    \tv[3] \u003d v[4]; //copia a 4o string para a 3o posição\n    }\n    v.erase(v.begin() + 3); //apaga a 4o string do vector (0 indexado)\n    v.erase(v.begin() + 0); //ou opcionalmente v.erase(v.begin());, apaga a primeira posicao\n\n\n    vector\u0026lt;string\u0026gt; v2;\n    //copia o v pro v2 O(n*m), pois tem n posições e no pior \n    //caso cada uma tera uma string de tamanho m\n    v2 \u003d v;\n    v.clear(); // limpa o vector\n    v.resize(100); //pre-aloca 100 posições\n    v[5] \u003d v2[0].substr(5, 10); //pega 10 caracteres a partir da posiçao 5 da primeira string em v2\n                                //e coloca em v[5]\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003epair/sort/lower_bound/upper_bound\u003c/h3\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint n,x;\nvector\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt; v;\n\nint main()\n{\n    ios :: sync_with_stdio(false); //para deixar o cin e o cout mais rapidos\n    cin \u0026gt;\u0026gt; n;\n    for (int i \u003d 0; i \u0026lt; n; ++i)\n\t{\n    \tcin \u0026gt;\u0026gt; x;\n    \tv.push_back(make_pair(x, i)); //make pair cria um pair\n\t}\n\n\tsort(v.rbegin(), v.rend());//Ordena o vetor de maneira decrescente\n\n\tsort(v.begin(), v.end()); //Ordena o vector de pair de maneira crescente em O(nlog(n))\n\t//quando um pair eh ordenado, primeiro ele compara o primeiro elemento, se forem iguais o\n\t//desempate eh pelo segundo\n\n\tfor (int i \u003d 0; i \u0026lt; v.size(); ++i)\n\t{\n\t\tcout \u0026lt;\u0026lt; v[i].first \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; v[i].second \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; //first eh o primeiro elemento do pair, \n\t\t                                                  //second o segundo\n\t}\n \t\n \t//c++11, to procurando se o par (10, 2) existe dentro de v\n \t//lower_bound retorna o primeiro elemento \u0026gt;\u003d a query, eh uma busca binaria portanto\n \t//complexidade \u003d O(log(n))\n\tauto it \u003d lower_bound(v.begin(), v.end(), make_pair(10, 2));\n\tif ((*it) \u003d\u003d make_pair(10, 2))\n\t{\n\t\tcout \u0026lt;\u0026lt; \u0026quot;achei\\n\u0026quot;;\n\t}\n\n\t//upper_bound retorna o primeiro elemento \u0026gt; que a query, O(log(n))\n\tauto it2 \u003d upper_bound(v.begin(), v.end(), make_pair(10, 2));\n\n\tcout \u0026lt;\u0026lt; it2 - it \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; //quantos elementos tem entre it2 e it\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003equeue/stack/deque\u003c/h3\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint n,x;\nqueue\u0026lt;int\u0026gt; q;\nstack\u0026lt;int\u0026gt; s;\ndeque\u0026lt;int\u0026gt; dq;\n\nint main()\n{\n    ios :: sync_with_stdio(false); //para deixar o cin e o cout mais rapidos\n    cin \u0026gt;\u0026gt; n;\n    for (int i \u003d 0; i \u0026lt; n; ++i)\n\t{\n    \tcin \u0026gt;\u0026gt; x;\n    \tq.push(x); //coloca na fila O(1)\n    \ts.push(x); //coloca na pilha O(1)\n    \tdq.push_back(x); //coloca no fim do deque O(1)\n    \tdq.push_front(x); //coloca no começo do deque O(1)\n\t}\n\n\twhile (!q.empty()) //enquanto a fila não estiver vazia O(1)\n\t{\n\t\tint v \u003d q.front(); //começo da fila O(1)\n\t\tcout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n\t\tq.pop(); //tira do comeco da fila O(1)\n\t}\n\n\twhile (!s.empty()) //enquanto a pilha não estiver vazia O(1)\n\t{\n\t\tint v \u003d q.top(); //fim da pilha O(1)\n\t\tcout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n\t\tq.pop(); //tira do fim da pilha O(1)\n\t}\n\n\tfor (int i \u003d 0; i \u0026lt; dq.size(); ++i)\n\t{\n\t\tcout \u0026lt;\u0026lt; dq[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; //O(1)\n\t}\n\tdq.pop_back(); //tira o ultimo elemento do deque\n\tdq.pop_front(); //tira o primeiro elemento do deque\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003emap/set/piority_queue\u003c/h3\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint n,x;\nset\u0026lt;int\u0026gt; s;\nmap\u0026lt;int, int\u0026gt; m;\npriority_queue\u0026lt;int\u0026gt; pq;\n\nint main()\n{\n    ios :: sync_with_stdio(false); //para deixar o cin e o cout mais rapidos\n    cin \u0026gt;\u0026gt; n;\n    for (int i \u003d 0; i \u0026lt; n; ++i)\n\t{\n    \tcin \u0026gt;\u0026gt; x;\n    \ts.insert(x); //coloca o x no set, lembrando que set n aceita elemento repetido\n    \t\t\t\t//se vc tentar inserir um x que ja existe no set, ele vai soh ignorar\n    \t\t\t\t// O(log(n))\n    \tm[x] \u003d 100; //O(log(n)) pois o acesso ao map atraves do \u0026quot;[]\u0026quot; eh log\n    \tpq.push(10); //O(log(n)), lembrando que a inserção na fila de prioridades\n    \t\t\t\t//eh ordenada\n\t}\n\n\tif (s.count(23) \u003d\u003d 1) //checa se o 23 existe dentro do set s O(log(n))\n\t{\n\t\tcout \u0026lt;\u0026lt; \u0026quot;achei\\n\u0026quot;;\n\t}\n\tif (m[23] \u0026gt; 0) //checa se o 23 existe no map m, lembrando que se ele nao existir\n\t\t           //o map vai adicionar o 23 e colocar 0 como seu valor\n\t{\n\t\tcout \u0026lt;\u0026lt; \u0026quot;achei\\n\u0026quot;;\t\n\t}\n\n\ts.erase(10); //remove o cara de valor 10 do set, lembrando q se ele nao existir voce tomara\n\t             //runtime error! O(logn)\n\tm.erase(50); //remove o cara de valor 50 do map O(logn)\n\t//c++11 only\n\tfor (auto u : s)\n\t{\n\t\tcout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; //imprime todos os elementos dentro de s\n\t}\n\tfor (auto u : m)\n\t{\n\t\tcout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; //imprime todos os elementos dentro de s\n\t}\n\n\twhile (!pq.empty())\n\t{\n\t\tint v \u003d pq.top(); //pega o primeiro elemento O(1)\n\t\tcout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n\t\tpq.pop(); //Remove o primeiro elemento O(log(n))\n\t}\n\n\tcout \u0026lt;\u0026lt; m.size() \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; pq.size() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n\t//pega o numero de elementos em m, s e pq, O(1)\n\t\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCréditos do texto ao ex-coach do GEMA \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/bssanches\" title\u003d\"Candidate Master bssanches\"\u003ebssanches\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}