{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1457006739,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1457006739,"id":43543,"title":"\u003cp\u003eЗадачи с использованием условных операторов и циклов. Часть 2\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eРассмотрим следующую задачу.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача 2\u003c/strong\u003e. Дано \u003cem\u003en\u003c/em\u003e пар целых положительных чисел. Найдите пару, имеющую максимальный наибольший общий делитель. Количество пар не более \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e\u003c/span\u003e, каждое число в паре не превосходит \u003cspan class\u003d\"tex-span\"\u003e2·10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eВыведите этот наибольший общий делитель и пару, которая ему соответствует. Если существует несколько подходящих пар, выведите любую из них. \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eРешение\u003c/strong\u003e. \u003c/p\u003e\u003cp\u003eСначала обсудим, как бы мы действовали, если бы у нас имелась функция, вычисляющая наибольший общий делитель. \u003c/p\u003e\u003cp\u003e\u003cem\u003eВ Java не существует функций, не входящих в состав класса. Поэтому, строго говоря, мы должны были бы говорить о методе, описанном в некотором классе. Но здесь и далее мы будем использовать слово «функция» как синоним слова «метод». Надеемся, что это не приведёт к путанице.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eДля хранения лучшей пары чисел нам потребуется две переменных. Также нам понадобится переменная для хранения максимального на текущий момент значения НОД среди уже просмотренных пар. Псевдокод может выглядеть так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eдля (очередной пары из n пар) {\n\tпервый_элемент_пары \u003d читать_очередное_целое_число()\n\tвторой_элемент_пары \u003d читать_очередное_целое_число()\n\tНОД_пары \u003d НОД(первый_элемент_пары, второй_элемент_пары)\n\tесли (НОД_пары \u0026gt; максимальный_НОД) {\n\t\tмаксимальный_НОД \u003d НОД_пары\n\t\tпервый_элемент_лучшей_пары \u003d первый_элемент_пары\n\t\tвторой_элемент_лучшей_пары \u003d второй_элемент_пары\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбратите внимание, что после чтения очередной пары чисел в цикле на этой же итерации цикла принимается решение — сохраняется ли эта пара в качестве лучшей (в соответствующих переменных) или же отбрасывается. Поэтому на следующей итерации те же переменные могут использоваться для чтения очередной пары. \u003c/p\u003e\u003cp\u003eУтверждение «\u003ccode\u003eмаксимальный_НОД\u003c/code\u003e является максимальным среди всех просмотренных пар» (это утверждение можно дополнить также тем, что в переменных \u003ccode\u003eпервый_элемент_лучшей_пары\u003c/code\u003e и \u003ccode\u003eвторой_элемент_лучшей_пары\u003c/code\u003e хранятся именно первый и второй элементы пары с максимальным НОД) является инвариантом цикла. Чтобы оно выполнялось также и до цикла, необходимо присвоить подходящие начальные значения переменным, входящим в инвариант. \u003c/p\u003e\u003cp\u003eВ действительности вполне достаточно будет задать начальное значение только переменной \u003ccode\u003eмаксимальный_НОД\u003c/code\u003e — но такое, чтобы при первом же входе в цикл это значение было заменено значением НОД первой пары (и, соответственно, первая просмотренная пара чисел стала бы лучшей среди всех просмотренных). \u003c/p\u003e\u003cp\u003eПоскольку наименьший возможный НОД (для двух взаимно простых чисел) равен единице, то выбор в качестве начального значения для переменной \u003ccode\u003eмаксимальный_НОД\u003c/code\u003e нуля гарантирует обновление значения этой переменной при любых возможных значениях первой пары чисел. \u003c/p\u003e\u003cp\u003eТеперь осталось записать функцию НОД. Для вычисления наибольшего общего делителя воспользуемся алгоритмом Евклида. \u003c/p\u003e\u003cp\u003e\u003cem\u003eИсторию построения алгоритма Евклида и доказательство его корректности здесь мы приводить не будем, полагая, что всё это известно из других источников (если это не так, прочтите, например, начало главы 31 книги «Алгоритмы. Построение и анализ»).\u003c/em\u003e\u003c/p\u003e\u003cp\u003eСуть алгоритма Евклида состоит в следующем: на каждом его шаге большее из двух чисел заменяется остатком от деления этого числа на меньшее. \u003c/p\u003e\u003cp\u003e\u003cem\u003eТекст ниже не следует рассматривать как доказательство алгоритма Евклида. Это лишь пояснение к его конкретному виду.\u003c/em\u003e \u003c/p\u003e\u003cp\u003eРассмотрим два целых числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e \u0026gt; \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e, которые имеют наибольший общий делитель \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e. Тогда эти числа можно представить в виде \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d \u003ci\u003ep\u003c/i\u003e·\u003ci\u003ed\u003c/i\u003e,  \u003ci\u003eb\u003c/i\u003e \u003d \u003ci\u003eq\u003c/i\u003e·\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e. С другой стороны, если число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e делится на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e с остатком \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e, то \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e·\u003ci\u003ed\u003c/i\u003e \u003d \u003ci\u003eq\u003c/i\u003e·\u003ci\u003ed\u003c/i\u003e·\u003ci\u003ek\u003c/i\u003e + \u003ci\u003er\u003c/i\u003e\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d ⌊ \u003ci\u003ea\u003c/i\u003e / \u003ci\u003eb\u003c/i\u003e⌋ \u003c/span\u003e, а \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/16/8f/168f25a9c24a330af0ad6b159694adcf9ba2ca54.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003c/p\u003e\u003cp\u003eОтсюда \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e \u003d (\u003ci\u003ep\u003c/i\u003e–\u003ci\u003eq\u003c/i\u003e·\u003ci\u003ek\u003c/i\u003e)·\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e, т. е. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e является делителем числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e. Конечно, можно поставить вопрос — а является ли \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e наибольшим общим делителем чисел \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e? Не существует ли какого-либо другого общего делителя для этих чисел, большего \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e? \u003c/p\u003e\u003cp\u003eПредположим, что такой делитель существует, и это некоторый \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u0026gt; \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e. В этом случае \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e \u003d \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e·\u003ci\u003es\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e \u003d \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e·\u003ci\u003et\u003c/i\u003e\u003c/span\u003e. С другой стороны, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d \u003ci\u003eb\u003c/i\u003e·\u003ci\u003ek\u003c/i\u003e + \u003ci\u003er\u003c/i\u003e \u003d \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e·\u003ci\u003et\u003c/i\u003e·\u003ci\u003ek\u003c/i\u003e + \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e·\u003ci\u003es\u003c/i\u003e \u003d (\u003ci\u003et\u003c/i\u003e·\u003ci\u003ek\u003c/i\u003e + \u003ci\u003es\u003c/i\u003e)·\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, т.е. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e будет делителем и числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, что противоречит нашему первоначальному предположению, что \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e — наибольший общий делитель. Следовательно, замена большего числа остатком от деления сохраняет НОД. \u003c/p\u003e\u003cp\u003e\u003cem\u003eОкончание пояснения.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eТаким образом, взяв два числа, мы будем на каждом шаге алгоритма заменять большее из чисел остатком от деления его на меньшее. Очевидно, что остаток от деления всегда будет меньше делителя, поэтому на следующем шаге алгоритма именно делитель будет становиться большим из двух чисел. \u003c/p\u003e\u003cp\u003eКогда мы должны остановиться? Наибольший общий делитель будет найден, когда на очередном шаге остаток от деления обратится в ноль. Запишем псевдокод функции:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eцелое НОД (целое первое_число, целое второе_число) {\n\tпока (второе_число !\u003d 0) {\n\t\tостаток \u003d первое_число % второе_число\n\t\tпервое_число \u003d второе_число\n\t\tвторое_число \u003d остаток\n\t}\n\tрезультат ← первое_число\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВажно, что функция принимает два целочисленных параметра и возвращает один целочисленный результат. С функциями, принимающими параметры, Вы уже сталкивались в качестве «пользователя» (например, обращаясь к функциям \u003ccode\u003emax()\u003c/code\u003e или \u003ccode\u003emin()\u003c/code\u003e — у них тоже по два параметра, и они так же возвращают число в качестве результата), но в наших проектах такие функции ещё не встречались.\u003c/p\u003e\u003cp\u003eВероятно, тот факт, что результатом выполнения функции внутри функции может быть какая-то переменная, но для «внешнего мира» эта переменная скрыта, и результат получается при обращении к функции, для Вас уже привычен. \u003c/p\u003e\u003cp\u003eТеперь нужно понять следующее: в заголовке функции описываются так называемые формальные параметры — в некотором смысле это «псевдонимы» реальных значений, с которыми будет работать функция. \u003c/p\u003e\u003cp\u003eФормальные параметры служат для описания действий внутри функции, и только внутри неё. Единственное (но важное) отличие формальных параметров от переменных, описанных внутри функции (в нашем случае — \u003ccode\u003eостаток\u003c/code\u003e), состоит в том, что их значения изначально получаются извне. \u003c/p\u003e\u003cp\u003eКогда осуществляется вызов функции, вместо формальных параметров подставляются фактические параметры — те значения, над которыми и нужно выполнить описанные в функции действия. Именно это записано в псевдокоде, приведённом в самом начале решения: функция НОД вызывается с параметрами \u003ccode\u003eпервый_элемент_пары\u003c/code\u003e и \u003ccode\u003eвторой_элемент_пары\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003cem\u003eСуществует два принципиально отличающихся подхода к связи между формальными и фактическими параметрами. В одном случае при передаче фактических параметров создается их копия, а значения фактических параметров не меняются. В другом же — все изменения производятся над самими фактическими параметрами.\u003c/em\u003e \u003c/p\u003e\u003cp\u003e\u003cem\u003eВ Java эти подходы сочетаются. Для значений примитивных типов (\u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003edouble\u003c/code\u003e, \u003ccode\u003echar\u003c/code\u003e, \u003ccode\u003eboolean\u003c/code\u003e) при передаче в функцию создаются копии, значения же объектных типов (классов) передаются в функцию по адресу и все изменения происходят непосредственно с этими значениями.\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eЧтобы понять, почему так происходит, нужно знать следующее. Память для значений примитивных типов выделяется сразу при объявлении этих переменных (как только Вы написали \u003ccode\u003eint a\u003c/code\u003e — Вы дали указание выделить 4 байта под переменную с именем \u003ccode\u003ea\u003c/code\u003e; имя переменной связывается с этой областью памяти).\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eКогда же описывается переменная объектного типа, то для выделения памяти под неё требуется использовать оператор \u003ccode\u003enew\u003c/code\u003e. Имя переменной в этой ситуации будет связано с «хранилищем адреса», по которому память фактически будет выделена. Т.е. обращение к переменной объектного типа выполняется в два этапа: сначала мы узнаём адрес, по которому она расположена в памяти, после чего обращаемся по этому адресу.\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eВозвращаясь к параметрам функции — если передаются значения примитивных типов, создание копии для них означает выделение точно такой же области памяти и копирование туда значения. Далее функция будет работать именно с этой областью памяти, не затрагивая значения в исходной. Если же передаются значения объектных типов, то (даже если их скопировать) функция получает в своё распоряжение адрес, где фактически располагается объект. Таким образом, она будет работать с «исходной» областью памяти.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eЗаметим, что если второе число больше, чем первое, то остаток от деления первого числа на второе будет в точности равен первому числу. В этом случае на первой итерации фактически произойдет обмен значениями между переменными \u003ccode\u003eпервое_число\u003c/code\u003e и \u003ccode\u003eвторое_число\u003c/code\u003e с помощью переменной \u003ccode\u003eостаток\u003c/code\u003e в качестве промежуточной. После этого всё будет происходить именно так, как описывалось выше. \u003c/p\u003e\u003cp\u003eЗапишем решение в виде программы. Создадим (с помощью соответствующего диалогового окна) в проекте \u003ccode\u003epractice01\u003c/code\u003e класс \u003ccode\u003eProblem02\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\npublic class Problem02 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКак и ранее, метод \u003ccode\u003emain()\u003c/code\u003e мы пока оставим пустым. Опишем класс \u003ccode\u003eTheBestGCD\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\npublic class Problem02 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass TheBestGCD {\n\t\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОпишем в этом классе переменные \u003ccode\u003ebestFirst\u003c/code\u003e и \u003ccode\u003ebestSecond\u003c/code\u003e, а также \u003ccode\u003emaxGCD\u003c/code\u003e — соответственно для хранения первого элемента лучшей пары, второго элемента лучшей пары и максимального НОД. Поскольку, как и в предыдущих программах, мы отделим метод, в котором будет описано собственно решение, от метода печати, эти переменные нужно объявить как поля класса, чтобы они были доступны всем методам класса.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass TheBestGCD {\n\t\n\tint bestFirst;\n\tint bestSecond;\n\tint maxGCD;\n\t\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПри чтении входных данных нам нужно будет сначала прочитать количество пар чисел, а затем уже сами эти пары. Количество пар чисел можно прочитать в конструкторе, а вот собственно числа — в методе, непосредственно решающем задачу. \u003cbr /\u003e Это значит, что переменную \u003cem\u003en\u003c/em\u003e, обозначающую количество пар, также следует сделать полем класса — чтобы она была доступна как из конструктора, так и из метода решения. \u003cbr /\u003e Более того, так же следует поступить и с переменной, обеспечивающей чтение данных, — т.е. с объектом класса \u003ccode\u003eScanner\u003c/code\u003e. Как и ранее, когда Вы будете печатать \u003cem\u003eScanner\u003c/em\u003e, IDE предложит дополнить Вашу программу предложением импорта (и отказываться от этого предложения не нужно) (кажется, данная тавтология не должна запутывать). \u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\nimport java.util.Scanner;\n\npublic class Problem02 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass TheBestGCD {\n\t\n\tint bestFirst;\n\tint bestSecond;\n\tint maxGCD;\n\t\n\tint n;\n\tScanner in;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПеременные \u003ccode\u003en\u003c/code\u003e и \u003ccode\u003ein\u003c/code\u003e визуально отделены от предыдущих трёх переменных исключительно с целью лучшего восприятия. \u003c/p\u003e\u003cp\u003eТеперь запишем конструктор класса \u003ccode\u003eTheBestGCD\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass TheBestGCD {\n\t\n\tTheBestGCD() {\n\t\tin \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t}\n\t\n\tint bestFirst;\n\tint bestSecond;\n\tint maxGCD;\n\t\n\tint n;\n\tScanner in;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбратите внимание на следующее. \u003cbr /\u003e Во-первых, переменные \u003ccode\u003ein\u003c/code\u003e и \u003ccode\u003en\u003c/code\u003e не нужно (ни в коем случае!) повторно объявлять в конструкторе. Если Вы это сделаете, то IDE не выдаст Вам сообщений об ошибке. Однако получится, что Вы объявите эти переменные в рамках конструктора, и по завершении его работы они прекратят свое существование. В то же время переменная \u003ccode\u003ein\u003c/code\u003e, объявленная как поле класса, не будет связана со стандартным потоком ввода, а переменная \u003ccode\u003en\u003c/code\u003e будет считаться равной нулю (значения простых типов в Java автоматически инициализируются нулём или его «аналогом») — над ними же никаких действий производиться не будет. \u003cbr /\u003e Во-вторых, над объектом класса \u003ccode\u003eScanner\u003c/code\u003e мы не выполняем операцию закрытия (\u003ccode\u003eclose()\u003c/code\u003e) — поскольку собираемся читать с помощью этого объекта данные в другом методе. \u003c/p\u003e\u003cp\u003eСледующий наш шаг — написание метода \u003ccode\u003egcd\u003c/code\u003e. Принципиальных изменений по сравнению с псевдокодом не будет:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass TheBestGCD {\n\t\n\tTheBestGCD() {\n\t\tin \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t}\n\t\n\tint gcd(int a, int b) {\n\t\tint r;\n\t\twhile (b !\u003d 0){\n\t\t\tr \u003d a % b;\n\t\t\ta \u003d b;\n\t\t\tb \u003d r;\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tint bestFirst;\n\tint bestSecond;\n\tint maxGCD;\n\t\n\tint n;\n\tScanner in;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНа что следует обратить внимание в методе \u003ccode\u003egcd()\u003c/code\u003e? Он имеет тип \u003ccode\u003eint\u003c/code\u003e и обязан возвращать значение этого типа. Возвращаемым значением будет как раз НОД(a, b). \u003cbr /\u003e Переменная \u003ccode\u003er\u003c/code\u003e объявлена до цикла; впрочем, можно было сделать объявление и в цикле — принципиальной разницы нет. \u003c/p\u003e\u003cp\u003eНапишем метод \u003ccode\u003esolve()\u003c/code\u003e, в котором и происходит отыскание наилучшей в смысле задачи пары чисел. В нём также не будет отличий по сравнению с псевдокодом (описания переменных и инициализация одной из них были оговорены в тексте).\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass TheBestGCD {\n\t\n\tTheBestGCD() {\n\t\tin \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t}\n\t\n\tint gcd(int a, int b) {\n\t\tint r;\n\t\twhile (b !\u003d 0){\n\t\t\tr \u003d a % b;\n\t\t\ta \u003d b;\n\t\t\tb \u003d r;\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tvoid solve() {\n\t\tmaxGCD \u003d 0;\n\t\tint first;\n\t\tint second;\n\t\tint curGCD;\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t\tfirst \u003d in.nextInt();\n\t\t\tsecond \u003d in.nextInt();\n\t\t\tcurGCD \u003d gcd(first, second);\n\t\t\tif (curGCD \u0026gt; maxGCD) {\n\t\t\t\tmaxGCD \u003d curGCD;\n\t\t\t\tbestFirst \u003d first;\n\t\t\t\tbestSecond \u003d second;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint bestFirst;\n\tint bestSecond;\n\tint maxGCD;\n\t\n\tint n;\n\tScanner in;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВызов метода \u003ccode\u003egcd()\u003c/code\u003e происходит с фактическими параметрами \u003ccode\u003efirst\u003c/code\u003e и \u003ccode\u003esecond\u003c/code\u003e, которые перед этим прочитываются с клавиатуры. \u003c/p\u003e\u003cp\u003eНаконец, напишем метод \u003ccode\u003eprint()\u003c/code\u003e. В нём будет сформирована строка из трёх величин, которые нам нужно вывести. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass TheBestGCD {\n\t\n\tTheBestGCD() {\n\t\tin \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t}\n\t\n\tint gcd(int a, int b) {\n\t\tint r;\n\t\twhile (b !\u003d 0){\n\t\t\tr \u003d a % b;\n\t\t\ta \u003d b;\n\t\t\tb \u003d r;\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tvoid solve() {\n\t\tmaxGCD \u003d 0;\n\t\tint first;\n\t\tint second;\n\t\tint curGCD;\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t\tfirst \u003d in.nextInt();\n\t\t\tsecond \u003d in.nextInt();\n\t\t\tcurGCD \u003d gcd(first, second);\n\t\t\tif (curGCD \u0026gt; maxGCD) {\n\t\t\t\tmaxGCD \u003d curGCD;\n\t\t\t\tbestFirst \u003d first;\n\t\t\t\tbestSecond \u003d second;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid print() {\n\t\tSystem.out.println(maxGCD + \u0026quot; \u0026quot; + bestFirst + \u0026quot; \u0026quot; + bestSecond);\n\t}\n\t\n\tint bestFirst;\n\tint bestSecond;\n\tint maxGCD;\n\t\n\tint n;\n\tScanner in;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eСобирая всё вместе, допишем тело метода \u003ccode\u003emain()\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\nimport java.util.Scanner;\n\npublic class Problem02 {\n\n\tpublic static void main(String[] args) {\n\t\tTheBestGCD bgcd \u003d new TheBestGCD();\n\t\tbgcd.solve();\n\t\tbgcd.print();\n\t}\n\n}\n\nclass TheBestGCD {\n\t\n\tTheBestGCD() {\n\t\tin \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t}\n\t\n\tint gcd(int a, int b) {\n\t\tint r;\n\t\twhile (b !\u003d 0){\n\t\t\tr \u003d a % b;\n\t\t\ta \u003d b;\n\t\t\tb \u003d r;\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tvoid solve() {\n\t\tmaxGCD \u003d 0;\n\t\tint first;\n\t\tint second;\n\t\tint curGCD;\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t\tfirst \u003d in.nextInt();\n\t\t\tsecond \u003d in.nextInt();\n\t\t\tcurGCD \u003d gcd(first, second);\n\t\t\tif (curGCD \u0026gt; maxGCD) {\n\t\t\t\tmaxGCD \u003d curGCD;\n\t\t\t\tbestFirst \u003d first;\n\t\t\t\tbestSecond \u003d second;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid print() {\n\t\tSystem.out.println(maxGCD + \u0026quot; \u0026quot; + bestFirst + \u0026quot; \u0026quot; + bestSecond);\n\t}\n\t\n\tint bestFirst;\n\tint bestSecond;\n\tint maxGCD;\n\t\n\tint n;\n\tScanner in;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗапустите полученную программу на выполнение на следующих тестах:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eА\u003c/strong\u003e. \u003c/p\u003e\u003cp\u003e5 \u003cbr /\u003e 12 18 \u003cbr /\u003e 15 75 \u003cbr /\u003e 35 24 \u003cbr /\u003e 54 24 \u003cbr /\u003e 7 7 \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eВ\u003c/strong\u003e. \u003c/p\u003e\u003cp\u003e5 \u003cbr /\u003e 12 18 \u003cbr /\u003e 15 9 \u003cbr /\u003e 35 24 \u003cbr /\u003e 54 24 \u003cbr /\u003e 7 7 \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eС\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003e5 \u003cbr /\u003e 12 18 \u003cbr /\u003e 15 9 \u003cbr /\u003e 35 24 \u003cbr /\u003e 54 24 \u003cbr /\u003e 7 3 \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eКак изменится результат при запуске на последнем тесте, если условие \u003ccode\u003e(curGCD \u0026gt; maxGCD)\u003c/code\u003e заменить на \u003ccode\u003e(curGCD \u0026gt;\u003d maxGCD)\u003c/code\u003e ? Почему это происходит?\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадачи на использование циклов и условных операторов\u003c/strong\u003e (для решения в аудитории и дома)\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1787\"\u003eTimus 1787 Поворот на Мегу\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1910\"\u003eTimus 1910 Руины титанов: сокрытый вход\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1925\"\u003eTimus 1925 О заслуге британских учёных\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1581\"\u003eTimus 1581 Работа в команде\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1931\"\u003eTimus 1931 Отличная команда\u003c/a\u003e\u003c/p\u003e\u003cp\u003eПродолжение следует...\u003c/p\u003e\u003c/div\u003e","tags":["java","циклы"]}}