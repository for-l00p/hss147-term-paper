{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1458420272,"rating":66,"authorHandle":"Errichto","modificationTimeSeconds":1458506269,"id":43886,"title":"\u003cp\u003eIndiaHacks Finals 2016 — Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eProblems ABCG will be described better soon.\u003c/p\u003e\u003cp\u003eproblem A — watch out for test like \u0026quot;1 1 1 2 2 2 2 3 3 3\u0026quot;. It shows that it\u0027s not enough to sort number and check three neighbouring elements. You must remove repetitions. The easier solution is to write 3 for-loops, without any sorting. Do you see how?\u003c/p\u003e\u003cp\u003eproblem B — you should generate all \u003cspan class\u003d\"tex-span\"\u003e6\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e possible starting strings and for each of them check whether you will get \u0026quot;a\u0026quot; at the end. Remember that you should check two first letters, not last ones (there were many questions about it).\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/653/problem/C\"\u003e653C - Bear and Up-Down\u003c/a\u003e — Let\u0027s call an index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e bad if the given condition about \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e doesn\u0027t hold true. We are given a sequence that has at least one bad place and we should count ways to swap two elements to fix all bad places (and not create new bad places). The shortest (so, maybe easiest) solution doesn\u0027t use this fact but one can notice that for more than \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e bad places the answer is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e because swapping \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e can affect only indices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - 1, \u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e - 1, \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWith one iteration over the given sequence we can find and count all bad places. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e denote index of the first bad place (or index of some other bad place, it\u0027s not important). We must swap \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e with something because otherwise \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e would still be bad. Thus, it\u0027s enough to consider \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e swaps ~-- for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e iterate over index of the second element to swap (note that \u0026quot;the second element\u0026quot; doesn\u0027t have to be bad and samples show it). For each of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e swaps we can do the following (let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e denote chosen two indices):\u003c/p\u003e \u003col\u003e   \u003cli\u003eCount bad places among four indices: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - 1, \u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e - 1, \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. If it turns out that these all not all initial bad places then we don\u0027t have to consider this swap — because some bad place will still exist anyway.\u003c/li\u003e   \u003cli\u003eSwap \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eCheck if there is some bad place among four indices: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - 1, \u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e - 1, \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. If not then we found a correct way.\u003c/li\u003e   \u003cli\u003eSwap \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e again, to get an initial sequence.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eBe careful not to count the same pair of indices twice. In the solution above it\u0027s possible to count twice a pair of indices \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e - 1, \u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e (where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e was defined in the paragraph above). So, add some \u003ccode\u003eif\u003c/code\u003e or do it more brutally — create a set of pairs and store sorted pairs of indices there.\u003c/p\u003e\u003cp\u003eTODO — add codes.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCHALLENGE\u003c/strong\u003e — can you solve this problem if the initial sequence is already nice (if it doesn\u0027t have bad places)?\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/653/problem/D\"\u003e653D - Delivery Bears\u003c/a\u003e — invented and prepared by \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/lewin\" title\u003d\"International master lewin\"\u003elewin\u003c/a\u003e, also the editorial.\u003c/p\u003e\u003cp\u003eJava code: \u003ca href\u003d\"/contest/653/submission/16825205\" title\u003d\"Submission 16825205 by Errichto\"\u003e16825205\u003c/a\u003e\u003cbr /\u003eC++ code solving also the harder version: \u003ca href\u003d\"/contest/653/submission/16825257\" title\u003d\"Submission 16825257 by Errichto\"\u003e16825257\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s transform this into a flow problem. Here, we transform \u0026quot;weight\u0026quot; into \u0026quot;flow\u0026quot;, and each \u0026quot;bear\u0026quot; becomes a \u0026quot;path\u0026quot;.\u003c/p\u003e\u003cp\u003eSuppose we just want to find the answer for a single \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. We can do this binary search on the flow for each path. To check if a particular flow of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003c/span\u003e is possible, reduce the capacity of each edge from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/15/a2/15a22a99bbd79b4dc378bea11a977cf37b4fa6a3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Then, check if the max flow in this graph is at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. The final answer is then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e multiplied by the flow value that we found.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMUCH HARDER VERSION\u003c/strong\u003e — you are also given an integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ek\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e\u003c/span\u003e) and your task is to find the answer for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e paths, for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + 1\u003c/span\u003e paths, ..., and for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e paths. There should be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e real values on the output.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eThe solution of the harder version.\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eHowever, this is not fast enough when we have up to 10^4 values of x to check.\u003c/p\u003e\u003cp\u003eInstead, we look at a fast way of getting the flow value for x+1 paths given a flow with x paths in only O(m log m) time.\u003c/p\u003e\u003cp\u003eSuppose we\u0027ve found the paths for x bears, and we know that the number of bears who use edge number i is w_i. Also, let f_x be the weight that each bear carries, given that there are x bears.\u003c/p\u003e\u003cp\u003eThen, we can create a residual graph as follows: For each edge (u_i -\u0026gt; v_i) with capacity c_i, create an edge in th residual graph from u_i to v_i with capacity (c_i) / (1 + w_i), and if w_i \u0026gt; 0, a backward edge with capacity f_x.\u003c/p\u003e\u003cp\u003eThen, we can find the fattest path in this graph with a dijsktra\u0027s in O(m log m), giving us f_(x+1). This also allows us to update our paths. In particular, if we use a backwards edge, we subtract the number of times the edge is used by 1, otherwise, we increase it by 1. This allows us to construct a new residual graph. It can be shown that this only results in at most one new path.\u003c/p\u003e\u003cp\u003eWe can prove that this is correct by induction. Suppose the answer is correct for x bears.\u003c/p\u003e\u003cp\u003eNow, one observation is that f_(x+1) must be less than or equal to f_x, as any plan that x+1 bears follow will also be able to be executed with x bears. \u003c/p\u003e\u003cp\u003eSuppose the optimal solution for x+1 bears is actually g_(x+1). We just need to argue that f_(x+1) \u0026gt;\u003d g_(x+1) and we are done. In the optimal solution, consider replacing each edge with capacity c_i to floor(c_i/g_(x+1)). Now, consider the optimal paths for x bears in this reduced capacity graph (which we found through induction). Since there are only x bears, but we know we can support x+1 bears, there exists a path in the residual graph from the source to the sink. Let\u0027s look at the capacity of this path. If we travel along any backward edge, the capacity of that edge is f_x which is at least g_(x+1). If we travel on a forward edge, we have c_i/(1+w_i) \u0026gt;\u003d g_(x+1) \u0026lt;\u003d\u0026gt; c_i \u0026gt;\u003d (1+w_i)*g_(x+1). The second inequality follows from reversing the \u0026quot;divide by g_(x+1)\u0026quot; step. \u003c/p\u003e\u003cp\u003eThus, the overall running time is O(mn^2 * log(m*x) + k*m log m), where the first part comes from the initial binary search, and the second part comes from doing k fattest path computations.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/653/problem/E\"\u003e653E - Bear and Forgotten Tree 2\u003c/a\u003e\u003c/p\u003e\u003cp\u003eC++ code: \u003ca href\u003d\"/contest/653/submission/16826422\" title\u003d\"Submission 16826422 by Errichto\"\u003e16826422\u003c/a\u003e\u003c/p\u003e\u003cp\u003eYou are given a big graph with some edges forbidden, and the required degree of vertex 1. We should check whether there exists a spanning tree. Let\u0027s first forget about the condition about the degree of vertex 1. The known fact: a spanning tree exists if and only if the graph is connected (spend some time on this fact if it\u0027s not obvious for you). So, let\u0027s check if the given graph is connected. We will do it with DFS.\u003c/p\u003e\u003cp\u003eWe can\u0027t run standard DFS because there are maybe \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e edges (note that the input contains forbidden edges, and there may be many more allowed edges then). We should modify it by adding a set or list of unvisited vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e. When we are at vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e we can\u0027t check all edges adjacent to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and instead let\u0027s iterate over possible candidates for adjacent unvisited vertices (iterate over \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e). For each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e we should check whether \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e are connected by a forbidden edge (you can store input edges in a set of pairs or in a similar structure). If they are connected by a forbidden edge then nothing happens (but for each input edge it can happen only twice, for each end of edge, thus \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003em\u003c/i\u003e)\u003c/span\u003e in total), and otherwise we get a new vertex. The complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f6/eb/f6ebd1c3c762e8ba1735c7f9ab270f2ecd7a8841.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e where \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a2/46/a246859516c2d7d237d3c1e375408179183169d7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is from using set of forbidden edges.\u003c/p\u003e\u003cp\u003eNow we will check for what degree of vertex 1 we can build a tree. We again consider a graph with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e vertices and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e forbidden edges. We will first find out what is \u003cstrong\u003ethe minimum\u003c/strong\u003e possible degree of vertex 1 in some spanning tree. After removing vertex 1 we would get some connected components and in the initial graph they could be connected to each other only with edges to vertex 1. With the described DFS we can find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ec\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e) — the number of created connected components. Vertex 1 must be adjacent to at least one vertex in each of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e components. And it would be enough to get some tree because in each component there is some spanning tree — together with edges to vertex 1 they give us one big spanning tree with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e vertices (we assume that the initial graph is connected).\u003c/p\u003e\u003cp\u003eAnd \u003cstrong\u003ethe maximum\u003c/strong\u003e degree of vertex 1 is equal to the number of allowed edges adjacent to this vertex. It\u0027s because more and more edges from vertex 1 can only help us (think why). It will be still possible to add some edges in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e components to get one big spanning tree.\u003c/p\u003e\u003cp\u003eSo, what is the algorithm? Run the described DFS to check if the graph is connected (if not then print \u0026quot;NO\u0026quot;). Remove vertex 1 and count connected components (e.g. starting DFS\u0027s from former neighbours of vertex 1). Also, simply count \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e — the number of allowed edges adjacent to vertex 1. If the required degree \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e inclusive then print \u0026quot;YES\u0026quot;, and otherwise print \u0026quot;NO\u0026quot;.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/653/problem/F\"\u003e653F - Paper task\u003c/a\u003e — invented and prepared by \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/k790alex\" title\u003d\"Specialist k790alex\"\u003ek790alex\u003c/a\u003e, also the editorial.\u003c/p\u003e\u003cp\u003eJava code (modify-SA-solution): \u003ca href\u003d\"/contest/653/submission/16821422\" title\u003d\"Submission 16821422 by k790alex\"\u003e16821422\u003c/a\u003e\u003cbr /\u003eC++ code (compressing-solution): \u003ca href\u003d\"/contest/653/submission/16826803\" title\u003d\"Submission 16826803 by Errichto\"\u003e16826803\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThere are two solutions. The first and more common solution required understanding how do SA (suffix array) and LCP (longest common prefix) work. The second processed the input string first and then run SA+LCP like a blackbox, without modifying or caring about those algorithms.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eModify-SA-solution\u003c/strong\u003e — The main idea is to modify the algorithm for computing the number of distinct substrings using SA + LCP.\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003equery\u003c/i\u003e(\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e)\u003c/span\u003e denote the number of well formed prefixes of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esubstring\u003c/i\u003e(\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e)\u003c/span\u003e. For example, for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esubstring\u003c/i\u003e(\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e) \u003d \u0026quot;(())()(\u0026quot;\u003c/span\u003e we would have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003equery\u003c/i\u003e(\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e) \u003d 2\u003c/span\u003e because we count \u003cspan class\u003d\"tex-span\"\u003e(())\u003c/span\u003e oraz \u003cspan class\u003d\"tex-span\"\u003e(())()\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eHow to be able to get \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003equery\u003c/i\u003e(\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e)\u003c/span\u003e fast? You can treat the opening bracket as \u003cspan class\u003d\"tex-span\"\u003e + 1\u003c/span\u003e and the ending bracket as \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e. Then you are interested in the number of intervals starting in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e, ending not after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e, with sum on the interval equal to zero. Additionally, the sum from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e to any earlier right end can\u0027t be less than zero. Maybe you will need some preprocessing here, maybe binary search, maybe segment trees. It\u0027s an exercise for you.\u003c/p\u003e\u003cp\u003eWe can iterate over suffix array values and for each suffix we add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003equery\u003c/i\u003e(\u003ci\u003esuffix\u003c/i\u003e, \u003ci\u003eN\u003c/i\u003e) - \u003ci\u003equery\u003c/i\u003e(\u003ci\u003esuffix\u003c/i\u003e, \u003ci\u003esuffix\u003c/i\u003e + \u003ci\u003eLCP\u003c/i\u003e[\u003ci\u003esuffix\u003c/i\u003e] - 1)\u003c/span\u003e to the answer. In other words we count the number of well formed substrings in the current suffix and subtract the ones we counted in the previous step.\u003c/p\u003e\u003cp\u003eThe complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e but you could get AC with very fast solution with extra \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a2/46/a246859516c2d7d237d3c1e375408179183169d7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCompressing-solution\u003c/strong\u003e — I will slowly compress the input string, changing small well-formed substrings to some new characters (in my code they are represented by integer numbers, not by letters). Let\u0027s take a look at the example:\u003cbr /\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/43/85/438545595a6db6660f3075183fa221f27fa644d8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003cbr /\u003eor equivalently:\u003cbr /\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/2a/9c/2a9c1562e2658d1b0d3043ac0defa0a2b7191c59.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eWhenever I have a maximum (not possible to expand) substring with single letters only, without any brackets, then I add this substring to some global list of strings. At the end I will count distinct substrings in the found list of strings (using SA+LCP). In the example above I would first add a string \u0026quot;a\u0026quot; and later I would add \u0026quot;baa\u0026quot;. Note that each letter represents some well formed substring, e.g. \u0027b\u0027 represents \u003cspan class\u003d\"tex-span\"\u003e(())\u003c/span\u003e here.\u003c/p\u003e\u003cp\u003eI must make sure that the same substrings will be compressed to the same letters. To do it, I always move from left to right, and I use trie with map (two know what to get from some two letters).\u003c/p\u003e\u003cp\u003eproblem G — you can consider each prime number separately. Can you find the answer if there are only 1\u0027s and 2\u0027s in the input? It may be hard to try to iterate over possible placements of the median. Maybe it\u0027s better to think how many numbers we will change from 2^p to 2^{p+1}.\u003c/p\u003e\u003c/div\u003e","tags":["indiahacks","hackerearth","editorial"]}}