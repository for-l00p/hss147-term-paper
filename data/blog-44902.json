{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1463423625,"rating":110,"authorHandle":"komendart","modificationTimeSeconds":1463490401,"id":44902,"title":"\u003cp\u003eCodeforces Round #353 (Div. 2) Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eSomeday I will arrange C and D correctly :)\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/675/problem/A\" title\u003d\"Codeforces Round 353 (Div. 2)\"\u003e675A - Infinite Sequence\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirstly, in case \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e \u003d 0\u003c/span\u003e we should output YES if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e else answer is NO.\u003c/p\u003e\u003cp\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e belongs to sequence \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e * \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e where k is non-negative integer.\u003c/p\u003e\u003cp\u003eSo answer is YES if \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eb\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e) / \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e is non-negative integer else answer is NO.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n \nusing namespace std;\n \nint main() {\n    int a, b, c;\n    cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c;\n \n    if (c \u003d\u003d 0) {\n        if (a \u003d\u003d b) cout \u0026lt;\u0026lt; \u0026quot;YESn\u0026quot;;\n        else cout \u0026lt;\u0026lt; \u0026quot;NOn\u0026quot;;\n    } else {\n        if ((b - a) % c \u003d\u003d 0 \u0026amp;\u0026amp; (b - a) / c \u0026gt;\u003d 0) cout \u0026lt;\u0026lt; \u0026quot;YESn\u0026quot;;\n        else cout \u0026lt;\u0026lt; \u0026quot;NOn\u0026quot;;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/675/problem/B\" title\u003d\"Codeforces Round 353 (Div. 2)\"\u003e675B - Restoring Painting\u003c/a\u003e\u003c/p\u003e\u003cp\u003ex a y\u003c/p\u003e\u003cp\u003eb m c\u003c/p\u003e\u003cp\u003ez d w\u003c/p\u003e\u003cp\u003eNumber in the center may be any from 1 to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e because number in the center belongs to all subsquares \u003cspan class\u003d\"tex-span\"\u003e2 × 2\u003c/span\u003e. So, let\u0027s find answer with fixed number in the center and then multiply answer by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLet\u0027s iterate over all possible \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Sums of each subsquare \u003cspan class\u003d\"tex-span\"\u003e2 × 2\u003c/span\u003e are the same so \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e + \u003ci\u003ea\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e \u003d \u003ci\u003ey\u003c/i\u003e + \u003ci\u003ec\u003c/i\u003e + \u003ci\u003ea\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e \u003d \u003ci\u003ex\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e - \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSimilarly, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e \u003d \u003ci\u003ex\u003c/i\u003e + \u003ci\u003ea\u003c/i\u003e - \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e - \u003ci\u003ed\u003c/i\u003e \u003d \u003ci\u003ez\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e - \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThis square is legal if \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ey\u003c/i\u003e, \u003ci\u003ez\u003c/i\u003e, \u003ci\u003ew\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. We should just check it.\u003c/p\u003e\u003cp\u003eAlso we can solve this problem in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nint main() {\n    int n, a, b, c, d;\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d;\n\n    long long ans \u003d 0;\n    for (int x \u003d 1; x \u0026lt;\u003d n; x++) {\n        int y \u003d x + b - c;\n        int z \u003d x + a - d;\n        int w \u003d a + y - d;\n        if (1 \u0026lt;\u003d y \u0026amp;\u0026amp; y \u0026lt;\u003d n \u0026amp;\u0026amp; 1 \u0026lt;\u003d z \u0026amp;\u0026amp; z \u0026lt;\u003d n \u0026amp;\u0026amp; 1 \u0026lt;\u003d w \u0026amp;\u0026amp; w \u0026lt;\u003d n) {\n            ans++;\n        }\n    }\n    ans *\u003d n;\n\n    cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/675/problem/C\" title\u003d\"Codeforces Round 353 (Div. 2)\"\u003e675C - Money Transfers\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe have array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and should make all numbers in it be equal to zero with minimal number of operations. Sum of all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e equals to zero.\u003c/p\u003e\u003cp\u003eWe can divide array into parts of consecutive elements with zero sum. If part has length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e we can use all pairs of neighbours in operations and make all numbers be equal to zero with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e - 1\u003c/span\u003e operations.\u003c/p\u003e\u003cp\u003eSo, if we sum number of operations in each part we get \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e \u003d \u003ci\u003en\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is number of parts. We should maximize \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e to get the optimal answer.\u003c/p\u003e\u003cp\u003eOne of the part consists of some prefix and probably some suffix. Each of other parts is subarray of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLet\u0027s calculate prefix sums. Each part has zero sum so prefix sums before each part-subarray are the same.\u003c/p\u003e\u003cp\u003eSo we can calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e — number of occurencies of the most frequent number in prefix sums and answer will be equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ef\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eBonus: how to hack solutions with overflow?\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n\n    int n;\n    cin \u0026gt;\u0026gt; n;\n    map\u0026lt;long long, int\u0026gt; d;\n    long long sum \u003d 0;\n    int ans \u003d n - 1;\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        int t;\n        cin \u0026gt;\u0026gt; t;\n        sum +\u003d t;\n        d[sum]++;\n        ans \u003d min(ans, n - d[sum]);\n    }\n\n    cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/675/problem/D\" title\u003d\"Codeforces Round 353 (Div. 2)\"\u003e675D - Tree Construction\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe have binary search tree (BST) and should insert number in it with good time complexity.\u003c/p\u003e\u003cp\u003eLet we should add number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Find numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u0026lt; \u003ci\u003ex\u003c/i\u003e \u0026lt; \u003ci\u003er\u003c/i\u003e\u003c/span\u003e which were added earlier, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e is maximal possible, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e is minimal possible (all will be similar if only one of this numbers exists). We can find them for example with std::set and upper_bound in C++.\u003c/p\u003e\u003cp\u003eWe should keep sorted tree traversal (it\u0027s property of BST). So \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e must be right child of vertex with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e or left child of vertex with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e hasn\u0027t right child and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e hasn\u0027t left child. Hence lowest common ancestor (lca) of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e doesn\u0027t equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e. So lca is between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e in tree traversal. But it\u0027s impossible because \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e is maximal possible and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e is minimal possible. So \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e has right child or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e has left child and we know exactly which of them will be parent of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThat\u0027s all. Time complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;map\u0026gt;\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n\n    set\u0026lt;int\u0026gt; numbers;\n    map\u0026lt;int, int\u0026gt; left;\n    map\u0026lt;int, int\u0026gt; right;\n\n    int n, v;\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; v;\n    numbers.insert(v);\n    for (int i \u003d 0; i \u0026lt; n - 1; i++) {\n        cin \u0026gt;\u0026gt; v;\n        auto it \u003d numbers.upper_bound(v);\n        int result;\n        if (it !\u003d numbers.end() \u0026amp;\u0026amp; left.count(*it) \u003d\u003d 0) {\n            left[*it] \u003d v;\n            result \u003d *it;\n        } else {\n            it--;\n            right[*it] \u003d v;\n            result \u003d *it;\n        }\n        numbers.insert(v);\n        cout \u0026lt;\u0026lt; result;\n        if (i \u003d\u003d n - 2) cout \u0026lt;\u0026lt; \u0027n\u0027;\n        else cout \u0026lt;\u0026lt; \u0027 \u0027;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/675/problem/E\" title\u003d\"Codeforces Round 353 (Div. 2)\"\u003e675E - Trains and Statistic\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet the indexation will be from zero. So we should subtract one from all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Also let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e \u003d \u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is sum of shortests pathes from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1... \u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e \u003d 0\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e - (\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003em\u003c/i\u003e) + \u003ci\u003en\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e - 1\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e belongs to range from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is maximal. We can find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e with segment tree or binary indexed tree or sparse table.\u003c/p\u003e\u003cp\u003eNow answer equals to sum of all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nconst int maxn \u003d 1 \u0026lt;\u0026lt; 18;\npair\u0026lt;int, int\u0026gt; tree[maxn * 2];\n\nvoid build(const vector\u0026lt;int\u0026gt; \u0026amp;a, int n) {\n    for (int i \u003d 0; i \u0026lt; n; i++) tree[maxn + i] \u003d {a[i], i};\n    for (int i \u003d maxn - 1; i \u0026gt; 0; i--)\n        tree[i] \u003d max(tree[i * 2], tree[i * 2 + 1]);\n}\n\nint get(int l, int r) {\n    pair\u0026lt;int, int\u0026gt; ans{-1, -1};\n    for (l +\u003d maxn, r +\u003d maxn + 1; l \u0026lt; r; l \u0026gt;\u0026gt;\u003d 1, r \u0026gt;\u0026gt;\u003d 1) {\n        if (l \u0026amp; 1) ans \u003d max(ans, tree[l++]);\n        if (r \u0026amp; 1) ans \u003d max(ans, tree[--r]);\n    }\n    return ans.second;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n\n    int n;\n    cin \u0026gt;\u0026gt; n;\n    vector\u0026lt;int\u0026gt; a(n);\n    a[n - 1] \u003d n - 1;\n    for (int i \u003d 0; i \u0026lt; n - 1; i++) {\n        cin \u0026gt;\u0026gt; a[i];\n        a[i]--;\n    }\n\n    build(a, n);\n    vector\u0026lt;long long\u0026gt; dp(n);\n    long long ans \u003d 0;\n    dp[n - 1] \u003d 0;\n    for (int i \u003d n - 2; i \u0026gt;\u003d 0; i--) {\n        int m \u003d get(i + 1, a[i]);\n        dp[i] \u003d dp[m] - (a[i] - m) + n - i - 1;\n        ans +\u003d dp[i];\n    }\n\n    cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0027n\u0027;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}