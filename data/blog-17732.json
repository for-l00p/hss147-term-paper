{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1430843809,"rating":67,"authorHandle":"cgy4ever","modificationTimeSeconds":1430846622,"id":17732,"title":"\u003cp\u003eShort Editorial of SRM 658 Div1\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eShort Editorial of SRM 658 Div1\u003c/p\u003e\u003ch3\u003eReference Code:\u003c/h3\u003e\u003cp\u003eDiv2-Easy: \u003ca href\u003d\"http://ideone.com/O7yBlI\"\u003ehttp://ideone.com/O7yBlI\u003c/a\u003e\u003c/p\u003e\u003cp\u003eDiv2-Medium: \u003ca href\u003d\"http://ideone.com/cazTBB\"\u003ehttp://ideone.com/cazTBB\u003c/a\u003e\u003c/p\u003e\u003cp\u003eDiv2-Hard: \u003ca href\u003d\"http://ideone.com/rxEUcR\"\u003ehttp://ideone.com/rxEUcR\u003c/a\u003e\u003c/p\u003e\u003cp\u003eDiv1-Easy: \u003ca href\u003d\"http://ideone.com/JLuDVM\"\u003ehttp://ideone.com/JLuDVM\u003c/a\u003e\u003c/p\u003e\u003cp\u003eDiv1-Medium: \u003ca href\u003d\"http://ideone.com/7FEz1K\"\u003ehttp://ideone.com/7FEz1K\u003c/a\u003e\u003c/p\u003e\u003cp\u003eDiv1-Hard: \u003ca href\u003d\"http://ideone.com/clL4Rk\"\u003ehttp://ideone.com/clL4Rk\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eEditorial:\u003c/h3\u003e\u003ch4\u003eDiv1-Easy:\u003c/h4\u003e\u003cp\u003eThe key is that: Any tree is a bipartite graph!\u003c/p\u003e\u003cp\u003eThat means, if two nodes are in the same part, then the distance between them is an even number, otherwise it is an odd number.\u003c/p\u003e\u003cp\u003eAssume the 0-th node is in first part, then we can know which part each node belong to by looking at x[0][i] : if x[0][i] is \u0027E\u0027 then i-th node should be in the first part, otherwise it should be in the second part.\u003c/p\u003e\u003cp\u003eThere are few things to check:\u003c/p\u003e \u003col\u003e   \u003cli\u003ex[0][0] should be \u0027E\u0027.\u003c/li\u003e   \u003cli\u003ethere should be at least one node in both part, i.e. there should exist i such that x[0][i] \u003d \u0027O\u0027.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eAnd then we can check if for all i,j: x[i][j] \u003d (i-th node and j-th node in the same part ? \u0027E\u0027 : \u0027O\u0027), if not, there is no solution.\u003c/p\u003e\u003cp\u003eOtherwise we can build any spaning tree of this complete bipartite graph, for example we can use this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e1 - 1\n1 - 2\n1 - .\n1 - m\n2 - 1\n3 - 1\n. - 1\nn - 1\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003eDiv1-Medium:\u003c/h4\u003e\u003cp\u003eSuppose for the i-th SCV: it received x9[i] times attack as the first target (so damage is 9), x3[i] times attack as second target, and x1[i] times attack as third target.\u003c/p\u003e\u003cp\u003eIf we totally attack t times, then these conditions are necessary:\u003c/p\u003e \u003col\u003e   \u003cli\u003eFor each i, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e9[\u003ci\u003ei\u003c/i\u003e] * 9 + \u003ci\u003ex\u003c/i\u003e3[\u003ci\u003ei\u003c/i\u003e] * 3 + \u003ci\u003ex\u003c/i\u003e1[\u003ci\u003ei\u003c/i\u003e] * 1 ≥ \u003ci\u003ex\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e: this means the i-th SCV must received enough damage to be destroyed.\u003c/li\u003e   \u003cli\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/af/fb/affb7e7a21c3540a4a596fa164b4c115244b0119.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9e/f1/9ef1cfbfde1dd4b5caa6ff578aee401177012b14.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b1/02/b1024132b10486c799d32a8d694ccf1d6f99cf58.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e: this means we can\u0027t have more then t \u0027attack as first/second/third target\u0027.\u003c/li\u003e   \u003cli\u003eFor each i, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e9[\u003ci\u003ei\u003c/i\u003e] + \u003ci\u003ex\u003c/i\u003e3[\u003ci\u003ei\u003c/i\u003e] + \u003ci\u003ex\u003c/i\u003e1[\u003ci\u003ei\u003c/i\u003e] ≤ \u003ci\u003et\u003c/i\u003e\u003c/span\u003e: this is because one SCV can not be attacked more than t times totally.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eWhat\u0027s amazing is that these 3 conditions are sufficient. I will skill the proof here (In fact I don\u0027t have a nice one -- it is ordinary case analysis, if you know a better one then please tell us, thanks!)\u003c/p\u003e\u003cp\u003eThen it becomes easy: First we do the binary search for the answer. Then we can do DP. DP[cur][i][j] :\u003d if we use totally i times \u0027attack as first target\u0027 and j times \u0027attack as second target\u0027 to kill all first cur SCV, then what\u0027s the minimal number of \u0027attack as third target\u0027 can be?\u003c/p\u003e\u003ch4\u003eDiv1-Hard:\u003c/h4\u003e\u003cp\u003eThis task ask the following thing: given a bipartite graph with n nodes in both part, find b: a subset of boys such that: 1. the girl they loves, or say, the neighborhoods of b: |neig(b)| \u003d |b|, that means, any of them don\u0027t love girls that is not in this matching. 2. There is a matching of these |b| boys with these |b| girls.\u003c/p\u003e\u003cp\u003eFormula like |neig(b)| \u003d |b| give us a hint for Hall\u0027s marriage theorem: Suppose the maximal matching of this bipartite graph is n — d, then we can find b, a subset of boys, such that |b| — |neig(b)| \u003d d. (We can use maxflow algorithm to find such set, by getting the minimal cut)\u003c/p\u003e\u003cp\u003eAnd then we can do max matching for these |b| boys and |neig(b)| girls, it will give you a valid answer (so we never return {-1}). Why? You can prove the maximal matching of this subgraph is |neig(b)|, once again, by Hall\u0027s marriage theorem.\u003c/p\u003e\u003c/div\u003e","tags":["petr win again"]}}