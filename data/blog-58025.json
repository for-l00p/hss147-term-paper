{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1519551942,"rating":15,"authorHandle":"KokiYmgch","modificationTimeSeconds":1519551942,"id":58025,"title":"\u003cp\u003eImplementation of centroid decomposition on a tree\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI wrote about the easy implementation of centroid decomposition on a tree.\u003c/p\u003e\u003cp\u003eJapanese here: \u003ca href\u003d\"http://www.learning-algorithms.com/entry/2018/01/20/031005\"\u003ehttp://www.learning-algorithms.com/entry/2018/01/20/031005\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst of all, the implementation of centroid decomposition tends to be complicated, and you might have seen someone\u0027s code which has too many functions named \u0027dfs n\u0027 (n \u003d 1, 2, 3, ...). I, for one, don\u0027t want to code something like that!\u003c/p\u003e\u003cp\u003eSo, let me introduce my implementation of centroid decompositon. I hope you get something new from it. \u003c/p\u003e\u003cp\u003eFirstly, we need to know one of the centroids of the tree. Be careful not to forget that some vertices are going to die while repeating the decompositon.\u003c/p\u003e\u003cp\u003eThe function which returns the centroid is easily implemented in the following way:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint OneCentroid(int root, const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;g, const vector\u0026lt;bool\u0026gt; \u0026amp;dead) {\n        static vector\u0026lt;int\u0026gt; sz(g.size());\n        function\u0026lt;void (int, int)\u0026gt; get_sz \u003d [\u0026amp;](int u, int prev) {\n                sz[u] \u003d 1;\n                for (auto v : g[u]) if (v !\u003d prev \u0026amp;\u0026amp; !dead[v]) {\n                        get_sz(v, u);\n                        sz[u] +\u003d sz[v];\n                }\n        };\n        get_sz(root, -1);\n        int n \u003d sz[root];\n        function\u0026lt;int (int, int)\u0026gt; dfs \u003d [\u0026amp;](int u, int prev) {\n                for (auto v : g[u]) if (v !\u003d prev \u0026amp;\u0026amp; !dead[v]) {\n                        if (sz[v] \u0026gt; n / 2) {\n                                return dfs(v, u);\n                        }\n                }\n                return u;\n        };\n        return dfs(root, -1);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen, using this centroid, you can implement centroid decomposition like this.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid CentroidDecomposition(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;g) {\n        int n \u003d (int) g.size();\n        vector\u0026lt;bool\u0026gt; dead(n, false);\n        function\u0026lt;void (int)\u0026gt; rec \u003d [\u0026amp;](int start) {\n                int c \u003d OneCentroid(start, g, dead);           //2\n                dead[c] \u003d true;                                //2\n                for (auto u : g[c]) if (!dead[u]) {\n                        rec(u);                                //3\n                }\n                /*\n                        compute something with the centroid    //4\n                */\n                dead[c] \u003d false;                               //5\n        };\n        rec(0);                                                //1\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis works following way:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eCalculate on the entire tree. All the vertices are alive now.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eFind the centroid of the current tree, and make it die.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eCalculate on the subtree which doesn\u0027t include the centroid. Go to 2 with this subtree.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eCalculate something required which \u003cstrong\u003eincludes the centroid\u003c/strong\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eMake the centroid alive again, because this is DFS.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eSimply enough, when you use this, you just need to change the part 4. All the other parts are the same, which means you can use it generally.\u003c/p\u003e\u003cp\u003eLet me show you an example.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://beta.atcoder.jp/contests/yahoo-procon2018-final-open/tasks/yahoo_procon2018_final_c\"\u003ehttps://beta.atcoder.jp/contests/yahoo-procon2018-final-open/tasks/yahoo_procon2018_final_c\u003c/a\u003e\u003c/p\u003e\u003cp\u003e(I guess this statement is available only in Japanese. Sorry for inconvenience!)\u003c/p\u003e\u003cp\u003eSummary: You are given a tree with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e vertices. Answer the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e queries below.\u003c/p\u003e\u003cp\u003eQuery \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e : Find the number of the vertices, such that the distance from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e, \u003ci\u003eQ\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eThe obvious solution to this problem is, for each query \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, make \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e-rooted tree and count the number of the vertices whose depth is equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. This solution, however, requires time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNQ\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWhen you want to count something on a tree, especially when it\u0027s related to a path, centroid decomposition is one of the good directions you are heading for.\u003c/p\u003e\u003cp\u003eFirst of all, let all the queries on the tree, and deal with them all at once. It\u0027s easy to see that these queries are actually asking the number of the paths whose length is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e and the end point is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIf you decompose the tree, as I mentioned above, \u003cstrong\u003eyou only need to count the paths which include the centroid\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eMore specifically, just calculate the the number of the distances from the centroid, and make the paths whose length is exacly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, and count them. Again, I didn\u0027t change almost anything but the part 4 of the implementation above.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;functional\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;cmath\u0026gt;\nusing namespace std;\n\nint OneCentroid(int root, const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;g, const vector\u0026lt;bool\u0026gt; \u0026amp;dead) {\n        static vector\u0026lt;int\u0026gt; sz(g.size());\n        function\u0026lt;void (int, int)\u0026gt; get_sz \u003d [\u0026amp;](int u, int prev) {\n                sz[u] \u003d 1;\n                for (auto v : g[u]) if (v !\u003d prev \u0026amp;\u0026amp; !dead[v]) {\n                        get_sz(v, u);\n                        sz[u] +\u003d sz[v];\n                }\n        };\n        get_sz(root, -1);\n        int n \u003d sz[root];\n        function\u0026lt;int (int, int)\u0026gt; dfs \u003d [\u0026amp;](int u, int prev) {\n                for (auto v : g[u]) if (v !\u003d prev \u0026amp;\u0026amp; !dead[v]) {\n                        if (sz[v] \u0026gt; n / 2) {\n                                return dfs(v, u);\n                        }\n                }\n                return u;\n        };\n        return dfs(root, -1);\n}\n\nvector\u0026lt;int\u0026gt; CentroidDecomposition(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;g, const vector\u0026lt;vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; \u0026amp;l, int q) {\n        int n \u003d (int) g.size();\n        vector\u0026lt;int\u0026gt; ans(q, 0);\n        vector\u0026lt;bool\u0026gt; dead(n, false);\n        function\u0026lt;void (int)\u0026gt; rec \u003d [\u0026amp;](int start) {\n                int c \u003d OneCentroid(start, g, dead);\n                dead[c] \u003d true;\n                for (auto u : g[c]) if (!dead[u]) {\n                        rec(u);\n                }\n\n                /* \n                        changed from here\n                */\n                map\u0026lt;int, int\u0026gt; cnt;\n                function\u0026lt;void (int, int, int, bool)\u0026gt; add_cnt \u003d [\u0026amp;](int u, int prev, int d, bool add) {\n                        cnt[d] +\u003d (add ? 1 : -1);\n                        for (auto v : g[u]) if (v !\u003d prev \u0026amp;\u0026amp; !dead[v]) {\n                                add_cnt(v, u, d + 1, add);\n                        }\n                };\n                function\u0026lt;void (int, int, int)\u0026gt; calc \u003d [\u0026amp;](int u, int prev, int d) {\n                        for (auto it : l[u]) {\n                                int dd, idx;\n                                tie(dd, idx) \u003d it;\n                                if (dd - d \u0026gt;\u003d 0 \u0026amp;\u0026amp; cnt.count(dd - d)) {\n                                        ans[idx] +\u003d cnt[dd - d];\n                                }\n                        }\n                        for (auto v : g[u]) if (v !\u003d prev \u0026amp;\u0026amp; !dead[v]) {\n                                calc(v, u, d + 1);\n                        }\n                };\n                add_cnt(c, -1, 0, true);\n                for (auto it : l[c]) {\n                        int dd, idx;\n                        tie(dd, idx) \u003d it;\n                        ans[idx] +\u003d cnt[dd];\n                }\n                for (auto u : g[c]) if (!dead[u]) {\n                        add_cnt(u, c, 1, false);\n                        calc(u, c, 1);\n                        add_cnt(u, c, 1, true);\n                }\n                //\n\n                dead[c] \u003d false;\n        };\n        rec(0); \n        return ans;\n}\n\nint main() {\n        int n, q;\n        scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;n, \u0026amp;q);\n        vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n);\n        for (int i \u003d 0; i \u0026lt; n - 1; i ++) {\n                int a, b;\n                scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;a, \u0026amp;b);\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        vector\u0026lt;vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; l(n); //dist, query idx\n        for (int i \u003d 0; i \u0026lt; q; i ++) {\n                int v, k;\n                scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;v, \u0026amp;k);\n                v --;\n                l[v].emplace_back(k, i);\n        }\n        auto ans \u003d CentroidDecomposition(g, l, q);\n        for (int i \u003d 0; i \u0026lt; q; i ++) {\n                printf(\u0026quot;%d\\n\u0026quot;, ans[i]);\n        }\n        return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can practice centroid decomposition on these problems too! Try them if you would like!\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/914/problem/E\"\u003ehttp://codeforces.com/contest/914/problem/E\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://csacademy.com/contest/round-58/task/path-inversions\"\u003ehttps://csacademy.com/contest/round-58/task/path-inversions\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThese problems ask you to count the number of the specific paths too.\u003c/p\u003e\u003cp\u003eThank you for your reading!\u003c/p\u003e\u003c/div\u003e","tags":["centroid","centroid decomposition","#implementation"]}}