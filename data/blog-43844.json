{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1458227003,"rating":0,"authorHandle":"HellKitsune","modificationTimeSeconds":1458227003,"id":43844,"title":"\u003cp\u003eОбходы графа\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eОбход в глубину\u003c/strong\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e/*  цель программы - считать граф, заданный во входных данных \n    сначала количеством вершин n, затем матрицей смежности n x n\n    затем вывести на экран все вершины, достижимые из вершины 0 */\n\n#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint n;\nint edges[100][100]; //матрица смежности графа\n//edges[i][j] равно 1, когда в графе есть ребро из вершины i в вершину j\n//и нулю в противном случае\nbool visited[100] \u003d {}; //visited[i] \u003d true, если мы уже посетили вершину i\n\nvoid dfs(int v) { //dfs принимает на вход один параметр - текущую вершину\n    visited[v] \u003d true; //помечаем вершину как посещенную\n    cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl; //и выводим на экран\n    //теперь обойдем все ещё не посещенные вершины, доступные из данной\n    for (int i \u003d 0; i \u0026lt; n; ++i) {\n        if (edges[v][i] \u003d\u003d 1 \u0026amp;\u0026amp; !visited[i]) { //если есть ребро из v в i и еще не посетили вершину i\n            dfs(i); //рекурсивно запустим обход в глубину из вершины i\n        }\n    }\n}\n\nint main() {\n    cin \u0026gt;\u0026gt; n;\n    for (int i \u003d 0; i \u0026lt; n; ++i) {\n        for (int j \u003d 0; j \u0026lt; n; ++j) {\n            cin \u0026gt;\u0026gt; edges[i][j];\n        }\n    }\n    dfs(0);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eОбход в ширину\u003c/strong\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e/*  цель программы - считать граф, заданный во входных данных\n    сначала количеством вершин n, затем матрицей смежности n x n\n    затем вывести на экран через пробел расстояния\n    от вершины 0 до вершин 0, 1, 2, ..., n - 1\n    если какая-то из вершин не достижима из нулевой,\n    вывести вместо расстояния для этой вершины -1 */\n\n#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint n;\nint edges[100][100];\nint dist[100]; //массив расстояния до вершин\nqueue\u0026lt;int\u0026gt; q;\n\nint main() {\n    cin \u0026gt;\u0026gt; n;\n    for (int i \u003d 0; i \u0026lt; n; ++i) {\n        for (int j \u003d 0; j \u0026lt; n; ++j) {\n            cin \u0026gt;\u0026gt; edges[i][j];\n        }\n    }\n    for (int i \u003d 0; i \u0026lt; n; ++i) {\n        dist[i] \u003d -1; //-1 означает, что мы еще не посетили вершину i\n    }\n    dist[0] \u003d 0; //для вершины 0 мы уже знаем кратчайшее расстояние, оно равно нулю\n    q.push(0); //начинаем обход из вершины 0\n    while (!q.empty()) { //пока очередь не пуста\n        int v \u003d q.front(); //достаем вершину из начала очереди\n        q.pop(); //и удаляем из очереди только что взятый элемент\n        for (int i \u003d 0; i \u0026lt; n; ++i) { //теперь обойдем все вершины, достижимые из данной\n            if (edges[v][i] \u003d\u003d 1 \u0026amp;\u0026amp; dist[i] \u003d\u003d -1) { //если есть ребро из v в i и еще не посетили вершину i\n                dist[i] \u003d dist[v] + 1; //расстояние до i равно расстоянию до v плюс единица за проход по ребру из v в i\n                q.push(i); //добавляем вершину i в очередь, чтобы позже пройти по рёбрам и из неё\n            }\n        }\n    }\n    for (int i \u003d 0; i \u0026lt; n; ++i) {\n        cout \u0026lt;\u0026lt; dist[i] \u0026lt;\u0026lt; \u0027 \u0027; //выводим найденные расстояния через пробел\n    }\n    cout \u0026lt;\u0026lt; endl;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}