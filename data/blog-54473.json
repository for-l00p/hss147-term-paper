{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1505157878,"rating":6,"authorHandle":"1am","modificationTimeSeconds":1505163549,"id":54473,"title":"\u003cp\u003eTutorial : 2013-2014 ACM-ICPC Brazil Subregional Programming Contest\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eC- Boss\u003c/h1\u003e\u003cp\u003eDue to small limits of this problem, for every swap query, we can afford to run a topological sort on the graph again and recalculate all the answers. If I ran a dfs on every node that has an in degree of zero, that would get me TLE because in worst case scenario I would visit the majority of the nodes every run. Using a topological sort guarantees O(n) update. \u003c/p\u003e\u003cp\u003eWhen swapping indices, make sure to keep track of where that person is now standing. So instead of actually rebuilding the graph, just swap the two people and their ages and say that the answer for this person is now gotten from this index instead of its original.\u003c/p\u003e\u003cp\u003eImplementation with topological sort on update queries: \u003ca href\u003d\"https://ideone.com/tE3kJo\"\u003ehttps://ideone.com/tE3kJo\u003c/a\u003e \u003cbr /\u003e \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Vendetta.\" title\u003d\"Candidate Master Vendetta.\"\u003eVendetta.\u003c/a\u003e\u0027s implementation with DFS on get answer query: \u003ca href\u003d\"https://ideone.com/4iMx8y\"\u003ehttps://ideone.com/4iMx8y\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eD- Folding Machine\u003c/h1\u003e\u003cp\u003eThis problem can be solved using careful backtracking. Try to fold at every index. To make the code slightly faster, you can keep a set of vector\u0027s to guarantee that you don\u0027t visit the same state twice.\u003c/p\u003e\u003cp\u003eImplementation with set: \u003ca href\u003d\"https://ideone.com/2ILk62\"\u003ehttps://ideone.com/2ILk62\u003c/a\u003e \u003cbr /\u003e \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Vendetta.\" title\u003d\"Candidate Master Vendetta.\"\u003eVendetta.\u003c/a\u003e\u0027s implementation without: \u003ca href\u003d\"https://ideone.com/tBXJyr\"\u003ehttps://ideone.com/tBXJyr\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eF- Triangles\u003c/h1\u003e\u003cp\u003eThis problem looks difficult, but it isn\u0027t at all. An equilateral triangle will split the circle into 3 equivalent sections. The 3 points will have equal distances between them equal to len \u003d circumference/3. So this problem can be solved using a set. If you use point x, I need to check if I have point (x +len)%circumference and (x +2 *len) %circumference. I will count each triangle in this method 3 times, so divide final answer by 3.\u003c/p\u003e\u003cp\u003eHere is the code: \u003ca href\u003d\"https://ideone.com/Ybryxx\"\u003ehttps://ideone.com/Ybryxx\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eG- Lines of Containers\u003c/h1\u003e\u003cp\u003eTake a look at the first row. If the first row looks like this: 6 9 8 7 10, I know I need to swap column 2 and column 4.\u003c/p\u003e\u003cp\u003eI can get this by storing the column numbers that are not in their proper place. They should be the same columns for all the rows. So firstly find what changes are needed to make to the columns using row 1. Change all the rows with the same changes. \u003c/p\u003e\u003cp\u003eTo get the minimum amount of changes for columns, once again we look just at row 1. If I\u0027m in my proper place, continue. Otherwise find the column position of the number that should be in my place and swap with it. \u003c/p\u003e\u003cp\u003eFor example: 1 5 2 3 4 --\u0026gt; 1 2 5 3 4 --\u0026gt; 1 2 3 5 4 --\u0026gt; 1 2 3 4 5\u003c/p\u003e\u003cp\u003eThe optimal amount of swaps needed for this example is 3. There is nothing better.\u003c/p\u003e\u003cp\u003eEvery row should now have the elements in its row sorted with the proper numbers. \u003c/p\u003e\u003cp\u003eNow using the first column, I can figure out what rows I need to swap. My final answer is the sum of the swaps for the rows and the columns.\u003c/p\u003e\u003cp\u003eHere are two codes:\u003cbr /\u003e \u003ca href\u003d\"https://ideone.com/FYXa9a\"\u003ehttps://ideone.com/FYXa9a\u003c/a\u003e \u003cbr /\u003e team ( educational حل)\u0027s implementation: \u003ca href\u003d\"https://ideone.com/ctezHE\"\u003ehttps://ideone.com/ctezHE\u003c/a\u003e \u003cbr /\u003e\u003c/p\u003e\u003ch1\u003eH- Buses\u003c/h1\u003e\u003cp\u003eIf the limits were small, we can solve this problem using dynamic programming. The state will look like this:\u003c/p\u003e\u003cp\u003edp[n] \u003d K * dp[n-5] + L* dp[ n-10];\u003c/p\u003e\u003cp\u003eLook familiar? Lets divide by 5. \u003cbr /\u003e dp[n/5] \u003d K * dp[n-1] + L * dp[n-2];\u003c/p\u003e\u003cp\u003eIts the Fibonacci sequence with factors :D Using matrix multiplication, instead of the base matrix being \u003c/p\u003e\u003cp\u003e|1 1| \u003cbr /\u003e |1 0|\u003c/p\u003e\u003cp\u003ewe change it to this to deal with the factors:\u003c/p\u003e\u003cp\u003e|K L| \u003cbr /\u003e |1 0|\u003c/p\u003e\u003cp\u003eand take this matrix to the power of n /5.\u003c/p\u003e\u003cp\u003eHere is the code: \u003ca href\u003d\"https://ideone.com/2jn9CI\"\u003ehttps://ideone.com/2jn9CI\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eI — Patches\u003c/h1\u003e\u003cp\u003eWe can solve this problem using dynamic programming starting from every index. Start patching at this index, each time adding either the larger patch or the smaller one. Use upper bound to find the next uncovered index. Using this solution, we deal with the situation of a wheel having holes at index 1 and index n and nowhere else. This way we try to starting patching at n whereas if we started just at 1, we wouldn\u0027t be able to reach n. \u003c/p\u003e\u003cp\u003eHere are two codes: \u003cbr /\u003e \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Vendetta.\" title\u003d\"Candidate Master Vendetta.\"\u003eVendetta.\u003c/a\u003e\u0027s code: \u003ca href\u003d\"https://ideone.com/BSokLq\"\u003ehttps://ideone.com/BSokLq\u003c/a\u003e \u003cbr /\u003e \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Hiasat\" title\u003d\"Candidate Master Hiasat\"\u003eHiasat\u003c/a\u003e\u0027s code: \u003ca href\u003d\"https://ideone.com/wvCTZw\"\u003ehttps://ideone.com/wvCTZw\u003c/a\u003e \u003cbr /\u003e\u003c/p\u003e\u003ch1\u003eJ- Trucks\u003c/h1\u003e\u003cp\u003eThe first step is to get the maximum spanning tree. Sort the edges and keep adding the largest one as long as the edge connects two unconnected components. \u003c/p\u003e\u003cp\u003eThen for each query, get the LCA. In our sparse table, not only store the ancestors, store also the minimum edge between me and my 2 ^k th parent. This can be done in a similar way to how we get the 2^k ancestor:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor(int k\u003d1;(1 \u0026lt;\u0026lt; k) \u0026lt;\u003d n;k++){\n\t\tfor(int i\u003d1;i \u0026lt;\u003d n;i++){\n\t\t\tif(dp[i][k - 1].fi \u003d\u003d -1){\n\t\t\t\tdp[i][k].fi\u003d-1;\n\t\t\t\tdp[i][k].se\u003d1e9;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[i][k].fi\u003ddp[dp[i][k - 1].fi][k - 1].fi;\n\t\t\t\tdp[i][k].se\u003dmin(dp[i][k - 1].se,dp[dp[i][k - 1].fi][k - 1].se);\n\t\t\t}\n\t\t}\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ewhere dp[u][0].fi\u003d my parent node and dp[u][0].se\u003d the edge between me and my direct parent;\u003c/p\u003e\u003cp\u003eNow when using binary lifting to get the LCA, we can get the minimum edge while lifting also. That is our answer; the minimum edge on the simple path of the 2 nodes in the the maximum spanning tree.\u003c/p\u003e\u003cp\u003eHere is the code: \u003ca href\u003d\"https://ideone.com/iDOwYp\"\u003ehttps://ideone.com/iDOwYp\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eOld problems\u003c/h1\u003e\u003cp\u003esolution to galaxy is posted.\u003cbr /\u003esolution for spy should be out in sometime.\u003cbr /\u003eboth in their original blog.\u003c/p\u003e\u003c/div\u003e","tags":[]}}