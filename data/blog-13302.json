{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1407249830,"rating":7,"authorHandle":"ikbal","modificationTimeSeconds":1407249875,"id":13302,"title":"\u003cp\u003eTreap implementation\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;complex\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;list\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;set\u0026gt;\n\n#define all(x) x.begin(), x.end()\n#define type(x) __typeof((x).begin())\n#define foreach(it,x) for(__typeof(x.begin()) it \u003d x.begin() ; it!\u003dx.end() ; it++ )\n\n#ifdef KAZAR\n    #define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#else\n    #define eprintf(...) 0\n#endif\n\nusing namespace std;\n\ntemplate\u0026lt;class T\u0026gt; inline void umax(T \u0026amp;a,T b){if(a\u0026lt;b) a \u003d b ; }\ntemplate\u0026lt;class T\u0026gt; inline void umin(T \u0026amp;a,T b){if(a\u0026gt;b) a \u003d b ; }\ntemplate\u0026lt;class T\u0026gt; inline T abs(T a){return a\u0026gt;0 ? a : -a;}\ntemplate\u0026lt;class T\u0026gt; inline T gcd(T a,T b){return __gcd(a, b);}\ntemplate\u0026lt;class T\u0026gt; inline T lcm(T a,T b){return a/gcd(a,b)*b;}\n\nconst int inf \u003d 1e9 + 143;\nconst long long longinf \u003d 1e18 + 143;\n\ninline int read(){int x;scanf(\u0026quot; %d\u0026quot;,\u0026amp;x);return x;}\n\nstruct treap{\n    treap *l, *r;\n    int size, x, y;\n    treap(int _x \u003d 0);\n};\n\ntreap *null;\n\ntreap::treap(int _x){\n    x \u003d _x;\n    y \u003d rand() \u0026lt;\u0026lt; 16 ^ rand();//!\n    size \u003d 1;\n    l \u003d r \u003d null;\n}\n\nvoid relax(treap *root){\n    root-\u0026gt;size \u003d 1 + root-\u0026gt;l-\u0026gt;size + root-\u0026gt;r-\u0026gt;size;\n}\n\ntreap *merge(treap *l,treap *r){\n    if(l \u003d\u003d null) return r;\n    if(r \u003d\u003d null) return l;\n    if(l-\u0026gt;y \u0026gt; r-\u0026gt;y){\n        l-\u0026gt;r \u003d merge(l-\u0026gt;r, r);\n        relax(l);\n        return l;\n    }else{\n        r-\u0026gt;l \u003d merge(l, r-\u0026gt;l);\n        relax(r);\n        return r;\n    }\n}\n\nvoid split(treap *root,treap *\u0026amp;l,treap *\u0026amp;r,int from){\n    if(root \u003d\u003d null){\n        l \u003d r \u003d null;\n        return;\n    }\n    if(from \u0026lt;\u003d root-\u0026gt;l-\u0026gt;size){\n        split(root-\u0026gt;l, l, r, from);\n        root-\u0026gt;l \u003d r;\n        relax(root);\n        r \u003d root;\n    }else{\n        split(root-\u0026gt;r, l, r, from - root-\u0026gt;l-\u0026gt;size - 1);\n        root-\u0026gt;r \u003d l;\n        relax(root);\n        l \u003d root;\n    }\n}\n\nvoid left(treap *\u0026amp;root,int x1,int x2,int k){\n    treap *l, *m, *r;\n    split(root, l, r, x1 - 1);\n    split(r, m, r, x2 - x1 + 1);\n    {\n        treap *T1, *T2;\n        split(m, T1, T2, k);\n        m \u003d merge(T2, T1);\n    }\n    root \u003d merge(l, merge(m ,r));\n}\n\nvoid right(treap *\u0026amp;root,int x1,int x2,int k){\n    treap *l, *m, *r;\n    split(root, l, r, x1 - 1);\n    split(r, m, r, x2 - x1 + 1);\n    {\n        treap *T1, *T2;\n        split(m, T1, T2, x2 - x1 + 1 - k);\n        m \u003d merge(T2, T1);\n    }\n    root \u003d merge(l, merge(m ,r));\n}\n\nint get(treap *\u0026amp;root,int k){\n    treap *l, *m, *r;\n    split(root, l, r, k - 1);\n    split(r, m, r, 1);\n    int temp \u003d m-\u0026gt;x;\n    root \u003d merge(l, merge(m, r));\n    return temp;\n}\n\nint main(){\n\n#ifdef KAZAR\n    freopen(\u0026quot;f.input\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n    freopen(\u0026quot;f.output\u0026quot;,\u0026quot;w\u0026quot;,stdout);\n    freopen(\u0026quot;error\u0026quot;,\u0026quot;w\u0026quot;,stderr);\n#endif\n\n    null \u003d new treap();\n    null-\u0026gt;x \u003d null-\u0026gt;y \u003d null-\u0026gt;size \u003d 0;\n    null-\u0026gt;l \u003d null-\u0026gt;r \u003d null;\n\n    int n \u003d read();\n    int q \u003d read();\n\n    treap *root \u003d null;\n\n    for(int i \u003d 1; i \u0026lt;\u003d n; i++){\n        int x \u003d read();\n        root \u003d merge(root, new treap(x));\n    }\n\n    while(q--){\n        char foo;\n        scanf(\u0026quot; %c\u0026quot;,\u0026amp;foo);\n        if(foo \u003d\u003d \u0027L\u0027){\n            int x1 \u003d read(), x2 \u003d read(), k \u003d read();\n            left(root, x1, x2, k);\n        }else if(foo \u003d\u003d \u0027R\u0027){\n            int x1 \u003d read(), x2 \u003d read(), k \u003d read();\n            right(root, x1, x2, k);\n        }else{\n            int x \u003d read();\n            printf(\u0026quot;%d\\n\u0026quot;,get(root, x));\n        }\n    }\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}