{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1479213506,"rating":1,"authorHandle":"Slamur","modificationTimeSeconds":1479213506,"id":48390,"title":"\u003cp\u003eЗаметки о типах данных\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eТема этого поста — выбор верного типа данных для корректной работы вашей программы.\u003c/p\u003e\u003cp\u003eДанный пост ориентирован в первую очередь на работу с типизированнными языками C++/C#/Java/Pascal, так как Python использует длинную арифметику для целых чисел. Но про вещественные числа может быть полезно почитать всем.\u003c/p\u003e\u003cp\u003eДля начала, хотелось бы напомнить используемые примитивные типы данных в языках :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eboolean - 8 бит - два возможных значения \u0026quot;true\u0026quot; и \u0026quot;false\u0026quot;;\nbyte - 8 бит - [-128; 127]\nchar - 8 бит для ASCII-кодов и 16 бит для Unicode - [0; 255] и [0; 65535] соответственно\nshort (int в Pascal) - 16 бит - [-32768; 32767]\nint (longint в Pascal) - 32 бита - [-2147483648; 2147483647] - Обратим внимание(!), что стандартный int не вмещает числа чуть более 2*10^9!\nlong(long long в C++, int64 в Pascal) - 64 бита - [-9223372036854775808; 9223372036854775807] - порядка 9 * 10^18. То есть числа размера 10^19 и больше в стандартные числовые типы данных просто так не влезут!\n\nfloat/double - 32/64 бита - [-10^308; 10^308] - вещественные числа. Double имеют мантиссу в 52 бита, 11 бит порядка и бит знака; обеспечивают относительную точность около log10(2^53) \u003d 15-16 десятичных цифр. \u0026lt;br/\u0026gt;   \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТакже стоит отметить, что в c++ и в c# существуют беззнаковые версии типов (unsigned в с++ и префикс u в с# — uint для примера) — они занимают то же количество бит K, но отрезок сдвинут от [-2^(K — 1); 2^(K — 1) — 1] до [0; 2^K — 1].\u003c/p\u003e\u003cp\u003eДля оценки размера в битах значения какой-либо переменной можно воспользоваться простой оценкой — 2^10 \u003d 1024 примерно равно 1000 \u003d 10^3. То есть за каждую 1000 прибавляйте 10 к размеру числа в битах.\u003c/p\u003e\u003cp\u003eСамое важное, что стоит понимать про целочисленные типы данных — это возможность переполнения. Если вы попытаетесь записать в переменную целочисленного типа значение больше, чем его максимальное значение (что означает, что ваше значение имеет больше бит, чем хранит данный тип), то запишутся лишь младшие биты, которые \u0026quot;уместились\u0026quot; в данном типе — старшие биты будут просто утеряны. А потеря информации приведет к неправильной работе или неправильному выводу вашей программы в дальнейшем.\u003c/p\u003e\u003cp\u003eКак же избежать переполнения? Вспомним, что в данных языках числовые типы выстроены в иерархию типов:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ebyte, char -\u0026gt; short -\u0026gt; int -\u0026gt; long -\u0026gt; float -\u0026gt; double.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЕсли в операции участвуют переменные двух различных числовых типов T1 и T2 (допустим, что T1 левее T2 по иерархии), то сначала переменная типа T1 будет приведена к типу T2, а затем уже будет вычислен результат также типа T2. Это называется \u0026quot;неявным преобразованием типов\u0026quot;. Преобразование в обратную сторону называется \u0026quot;явным\u0026quot; и проводится, обычно, с помощью оператора приведения типа (T).\u003c/p\u003e\u003cp\u003eТак как результат операции будет иметь \u0026quot;старший\u0026quot; из типов операндов в иерархии типов то переполнения результата не будет, если хотя бы один из операндов будет иметь тип, вмещающий значение результата.\u003c/p\u003e\u003cp\u003eЗамечание: все типы, стоящие левее int по иерархии, автоматически приводятся к int при выполнении операций.\u003c/p\u003e\u003cp\u003eПример: \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eshort a \u003d 3;\nbyte b \u003d 5;\nshort c \u003d a + b;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЭто не скомпилируется, так как вы попытаетесь в переменную типа short записать результат типа int, который стоит \u0026quot;правее\u0026quot; по иерархии типов. Корректно будет записать \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eshort c \u003d (short) (a + b);  \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДавайте рассмотрим несколько примеров \u0026quot;опасных мест\u0026quot; с возможным переполнением и способы бороться с ними:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e1. Переполнение при суммировании.\n\n    int a \u003d 2 * 1000 * 1000 * 1000; // 2 * 10^9\n    int b \u003d 2 * 1000 * 1000 * 1000; // 2 * 10^9\n    long c \u003d a + b;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗдесь значение суммы a + b заведомо больше, чем максимальное число в int, но меньше максимального числа в long. Хотя кажется, что все ок, но здесь переполнение будет, так как сначала будет вычислен результат (a + b) в типе int, а потом уже произойдет присвоение данного результата переменной c типа long. \u003c/p\u003e\u003cp\u003eВозможные решения:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e- Изменить тип a или b на long.\n- Сделать явное преобразование типов при вычислении c : long c \u003d (long)a + b;\n- Добавить фиктивный операнд типа long: long c \u003d a + 0L + b; // 0 типа long\n\n2. Переполнение при произведении.\n\n    int a \u003d 100 * 1000; // 10^5\n    int b \u003d 100 * 1000; // 10^5\n    long c \u003d a * b;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eСлучай, аналогичный первому. A * B не влазит в int, а в long влазит.\u003c/p\u003e\u003cp\u003eВозможные решения:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e- Изменить тип a или b на long.\n- Сделать явное преобразование типов при вычислении c : long c \u003d (long)a * b;\n- Добавить фиктивный операнд типа long: long c \u003d a * 1L * b; // 1 типа long\n\n3. Целочисленное деление, когда было нужно вещественное.\n\n    int a \u003d 4;\n    int b \u003d 3; \n    double c \u003d a / b; // 1 вместо 1.(3)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТак как произошло деление int на int, то сначала был вычислен результат целочисленного деления 4 / 3 \u003d 1, а уже потом данный результат был преобразован к double и записан в переменную c.\u003c/p\u003e\u003cp\u003eВозможные решения:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e- Изменить тип a или b на double.\n- Сделать явное преобразование типов при вычислении c : double c \u003d (double) a / b;\n- Добавить фиктивный операнд типа double: double c \u003d 1.0 * a / b; // 1 типа double\n\n4. Потеря информации при преобразовании long к double.\n\n    long a \u003d 123456789123456789L;\n    double b \u003d a + 1;\n    long c \u003d (long)b;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ a будет храниться значение 123456789123456789, а в с — 123456789123456784. Почему так? Как было замечено раньше, long вмещает в себя 18 десятичных знаков, а double хранит только 15 старщих значащих цифр, поэтому при преобразовании часть информации может потеряться.\u003c/p\u003e\u003cp\u003eПрямого решения здесь нет, надо просто помнить и стараться избегать таких случаев.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e5. Unsigned int и int (только для языков, имеющих беззнаковые типы).\n\n    unsigned int a \u003d 0;\n    int b \u003d 1;\n    if (a - b \u0026gt; 0) print(\u0026quot;Значение больше 0\u0026quot;);\n    else print(\u0026quot;Значение меньше 0\u0026quot;);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eБудет выведено \u0026quot;Значение больше 0\u0026quot;. Почему? При операциях между unsigned и signed результат будет unsigned. Так как unsigned тип не хранит меньше 0, то 0 — 1 в беззнаковом типе будет равно максимальному числу, \u0026quot;влезающему\u0026quot; в unsigned int — (2^32 — 1).\u003c/p\u003e\u003cp\u003eВозможные решения:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e- Изменить тип a на int.\n- Сделать явное преобразование типов при вычислении: (int)a - b;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОтдельно бы хотелось рассказать про работу с типом char.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e- Если вам нужно из символа цифры получить само значение цифры: \n\n    char digitChar \u003d \u00275\u0027;\n    int digit \u003d digitChar - \u00270\u0027;\n\n- Если по латинской букве нужно узнать ее номер в алфавите:\n\n    char lowerLetter \u003d \u0027r\u0027;\n    int lowerIndex \u003d lowerLetter - \u0027a\u0027;\n    char upperLetter \u003d \u0027R\u0027;\n    int upperIndex \u003d upperLetter - \u0027A\u0027;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ заключение хотелось бы провести небольшую викторину (отписывайте свои ответы в комментариях):\u003c/p\u003e\u003cp\u003eДля каждого случая надо написать, что будет при запуске данного кода, и как бы вы исправили, если код работает неверно.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e1. Итерация по числам вида step, 2 * step, ... до lim.\n\n    long lim \u003d 10L * 1000 * 1000 * 1000; // 10^10\n    int step \u003d 100 * 1000; // 10^5\n    int count \u003d 0;\n    for (int i \u003d 0; i \u0026lt; lim; i +\u003d step) {\n       ++count;\n    }\n    print(count);\n\n2. Итерация по степеням двойки.\n\n    long lim \u003d (1 \u0026lt;\u0026lt; 40); // 2 ^ 40\n    int count \u003d 0;\n    for (int i \u003d 1; i \u0026lt; lim; i \u0026lt;\u0026lt;\u003d 1) { // ( i \u0026lt;\u0026lt;\u003d 1 аналогично i \u003d i * 2)\n       count++;\n    }\n    print(count); // сколько выведется и почему?\n\n3. Вывод значения символа \u00278\u0027.\n\n    char x \u003d \u00270\u0027;\n    String s \u003d \u0026quot;X \u003d \u0026quot; + (x + 8);\n    print(s);\n\n4. Тождественная проверка.\n\n    long a \u003d 123456789L * 123456789;\n    double b \u003d Math.sqrt(a);\n    long c \u003d (long) (b * b);\n    if (a \u003d\u003d c) print(\u0026quot;true\u0026quot;);\n    else print(\u0026quot;false\u0026quot;);\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["самара","примитивные типы","переполнение"]}}