{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1516387530,"rating":191,"authorHandle":"STommydx","modificationTimeSeconds":1516452173,"id":57223,"title":"\u003cp\u003eCodeforces Round #457 (Div. 2) Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI would like to take this opportunity to express my deepest apology to all of you who take your own precious time to participate in this unrated round. Also, apologies to \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/gritukan\" title\u003d\"Международный гроссмейстер gritukan\"\u003egritukan\u003c/a\u003e who really helped a lot in preparing the round and \u003ca class\u003d\"rated-user user-admin\" href\u003d\"/profile/MikeMirzayanov\" title\u003d\"Штаб, MikeMirzayanov\"\u003eMikeMirzayanov\u003c/a\u003e who helped to host the round, I did not do a good job in managing the round. As the main author of this round, I\u0027m undoubtedly responsible for the mistake that not writing a brute force solution to test the correctness of the intended solution. It is my responsibility to make sure everything is right before the round starts. I am really sorry that the round must be unrated to ensure fairness to all contestants.\u003c/p\u003e\u003cp\u003eI hope all of you can learn something from the contest. Do not claim a greedy solution absolutely correct (like me :C) unless you have proved it. On the bright side, I\u0027m really glad that some of you found problem D and E interesting as said in some comments in the announcement blog post. I admit that problem D may seem to be a quite standard data structure problem but we think it would be fun for less experienced contestants to think how to put the concepts learnt together.\u003c/p\u003e\u003cp\u003eJust a little unimportant fact: The original div2B problem was a harder data structure problem which involves a slightly complicate mathematical proof (which the current one doesn\u0027t have :C). We replaced it because it is too difficult for div2B as the coordinator suggested.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/916/problem/A\" title\u003d\"Codeforces Round 457 (Div. 2)\"\u003e916A - Джейми и откладывание будильника\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eidea: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/STommydx\" title\u003d\"Кандидат в мастера STommydx\"\u003eSTommydx\u003c/a\u003e, preparation: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/jamiechoi\" title\u003d\"Эксперт jamiechoi\"\u003ejamiechoi\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s use brute force the find the answer. We first set the alarm time as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehh\u003c/i\u003e: \u003ci\u003emm\u003c/i\u003e\u003c/span\u003e and initialize the answer as 0. While the time is not \u003cem\u003elucky\u003c/em\u003e, set the alarm time to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e minute before and add 1 to the answer.\u003c/p\u003e\u003cp\u003eWhy does this solution run in time? As \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e ≤ 60\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehh\u003c/i\u003e\u003c/span\u003e decrease at most \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e for every iteration. Also, after at most 60 iterations, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehh\u003c/i\u003e\u003c/span\u003e must decrease at least once. All time representation that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehh\u003c/i\u003e \u003d 07\u003c/span\u003e (07:XX) is lucky so at most 24 times decrement of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehh\u003c/i\u003e\u003c/span\u003e will lead to a lucky time. Therefore, the max. number of iteration possible is \u003cspan class\u003d\"tex-span\"\u003e24 * 60 \u003d 1440\u003c/span\u003e which is very small for 1 sec TL.\u003c/p\u003e\u003cp\u003eIn fact, the largest possible answer is \u003cspan class\u003d\"tex-span\"\u003e390\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d 2\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehh\u003c/i\u003e \u003d 06\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emm\u003c/i\u003e \u003d 58\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eMy implementation: \u003ca href\u003d\"/contest/916/submission/34342125\" title\u003d\"Посылка 34342125 от STommydx\"\u003e34342125\u003c/a\u003e\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/916/problem/B\" title\u003d\"Codeforces Round 457 (Div. 2)\"\u003e916B - Джейми и двоичная последовательность (изменена после раунда)\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eidea: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/jamiechoi\" title\u003d\"Эксперт jamiechoi\"\u003ejamiechoi\u003c/a\u003e, preparation: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/STommydx\" title\u003d\"Кандидат в мастера STommydx\"\u003eSTommydx\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe main idea of the solution is \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sup\u003e \u003d 2·2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ex\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e, that means you can replace 1 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e element with 2 \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e - 1)\u003c/span\u003e elements. To start with, express \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e in binary — powers of two. As we can only increase the number of elements, there is no solution if there exists more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e elements. \u003c/p\u003e\u003cp\u003eLet\u0027s fix the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e value first. Observe that we can decrease the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e value only if all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e can be changed to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e - 1\u003c/span\u003e. So we scan from the largest power and try to break it down if doing so does not produce more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e elements. After \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e is fixed, we can greedily decrease the smallest element while the number of elements is less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eMy implementation: \u003ca href\u003d\"/contest/916/submission/34342011\" title\u003d\"Посылка 34342011 от STommydx\"\u003e34342011\u003c/a\u003e\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/916/problem/C\" title\u003d\"Codeforces Round 457 (Div. 2)\"\u003e916C - Джейми и интересный граф\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eidea: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/STommydx\" title\u003d\"Кандидат в мастера STommydx\"\u003eSTommydx\u003c/a\u003e, preparation: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/STommydx\" title\u003d\"Кандидат в мастера STommydx\"\u003eSTommydx\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst, observe that only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e edges are required to fulfil the requirement, so we will make the other \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e - \u003ci\u003en\u003c/i\u003e + 1\u003c/span\u003e edges with a very large number so they would not contribute to the shortest path or the MST. Now, the problem is reduced to building a tree with prime weight sum and two nodes in the tree have prime distance. \u003c/p\u003e\u003cp\u003eRecall that a path graph is also a tree! If we join \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ei\u003c/i\u003e + 1)\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003en\u003c/i\u003e\u003c/span\u003e, the shortest path will lie on the whole tree. We are left with a problem finding \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e numbers that sum to a prime. Let\u0027s make 1 edge with weight \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e - \u003ci\u003en\u003c/i\u003e + 2\u003c/span\u003e and others with weight \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Choosing a prime slightly larger than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e (e.g. \u003cspan class\u003d\"tex-span\"\u003e100003\u003c/span\u003e) will fulfil the requirement for all cases.\u003c/p\u003e\u003cp\u003eMy implementation: \u003ca href\u003d\"/contest/916/submission/34342305\" title\u003d\"Посылка 34342305 от STommydx\"\u003e34342305\u003c/a\u003e\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/916/problem/D\" title\u003d\"Codeforces Round 457 (Div. 2)\"\u003e916D - Джейми и список дел\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eidea: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/STommydx\" title\u003d\"Кандидат в мастера STommydx\"\u003eSTommydx\u003c/a\u003e, preparation: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/STommydx\" title\u003d\"Кандидат в мастера STommydx\"\u003eSTommydx\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s solve a version that does not consist of undo operation first. The task can be divided to two parts: finding the priority of a string and finding the rank of a priority. Both parts can be solved using trie trees. The first part is basic string trie with get and set operation so I will not describe it here in details. The second part is finding a rank of the number which can be supported by a binary trie. \u003c/p\u003e\u003cp\u003eTo support the undo operation, observe that each operation only add at most 31 nodes to the trie trees. Therefore, we can make use the idea of persistent data structure and store all versions by reusing old versions of the data structure with pointers. Remember to flush the output after each query operation.\u003c/p\u003e\u003cp\u003eAs pointed out by some of you, there exists alternative solutions using persistent dynamic segment trees.\u003c/p\u003e\u003cp\u003eMy implementation: \u003ca href\u003d\"/contest/916/submission/34342389\" title\u003d\"Посылка 34342389 от STommydx\"\u003e34342389\u003c/a\u003e (sorry for a bit messy)\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/916/problem/E\" title\u003d\"Codeforces Round 457 (Div. 2)\"\u003e916E - Джейми и дерево\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eidea: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/longhuenchan\" title\u003d\"Кандидат в мастера longhuenchan\"\u003elonghuenchan\u003c/a\u003e, preparation: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/longhuenchan\" title\u003d\"Кандидат в мастера longhuenchan\"\u003elonghuenchan\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s solve the problem without operation 1 first. That means the subtree of a vertex does not change.\u003c/p\u003e\u003cp\u003eFor operation 2, the subtree of smallest size that contains \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e means the lowest common ancestor (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elca\u003c/i\u003e\u003c/span\u003e) of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, and we update the subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elca\u003c/i\u003e\u003c/span\u003e. For operation 3, we query the sum of the subtree rooted at the given vertex. To do this, we can flatten a tree into an one dimensional array by considering the DFS order of the vertices starting from vertex \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. If a vertex has DFS order \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and its subtree has size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, then the update/query range is \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ex\u003c/i\u003e..\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e - 1]\u003c/span\u003e. This can be done by standard data structures, such as binary indexed tree with range update function, or segment tree with lazy propagation.\u003c/p\u003e\u003cp\u003eThings get more complicated when the root of the tree \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e changes. One should notice that in order to reduce time complexity, we should not recalculate everything when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e changes. We just need to keep a variable storing the current root. Now let\u0027s discuss the two main problems we face (In the following context, subtree of a vertex is defined according to vertex \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e unless otherwise stated): \u003c/p\u003e\u003cp\u003eHow to find the LCA of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e using the precomputed LCA table that assumes the root is vertex \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e? Let\u0027s separate the situation into several cases. If both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e are in the subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e, then query the LCA directly is fine. If exactly one of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is in the subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e, the LCA must be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e. If none of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is in the subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e, we can first find the lowest nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is an ancestor of both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e is an ancestor of both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e are different, we choose the deeper one. If they are the same, then we query the LCA directly. Combining the above cases, one may find the LCA is the lowest vertex among \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elca\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e), \u003ci\u003elca\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e), \u003ci\u003elca\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eAfter we have found the origin \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e of update (for query, it is given), how to identify the \u003cstrong\u003esubtree of a vertex\u003c/strong\u003e and carry out updates/queries on it? Again, separate the situation into several cases. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e \u003d \u003ci\u003er\u003c/i\u003e\u003c/span\u003e, update/query the whole tree. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e is in the subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e, or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e isn\u0027t an ancestor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e, update/query the subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e. Otherwise, update/query the whole tree, then undo update/exclude the results of the subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u0027\u003c/span\u003e, such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u0027\u003c/span\u003e is a child of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e and the subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u0027\u003c/span\u003e contains \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe above ideas can be verified by working with small trees on paper.\u003c/p\u003e\u003cp\u003e\u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/longhuenchan\" title\u003d\"Кандидат в мастера longhuenchan\"\u003elonghuenchan\u003c/a\u003e\u0027s implementation: \u003ca href\u003d\"/contest/916/submission/34352491\" title\u003d\"Посылка 34352491 от longhuenchan\"\u003e34352491\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe are glad to see some more elegant implementations by the contestants.\u003c/p\u003e\u003cp\u003eFeel free to discuss the problems below. I am happy to listen to feedback and answer questions from you guys. :)\u003c/p\u003e\u003c/div\u003e","tags":[]}}