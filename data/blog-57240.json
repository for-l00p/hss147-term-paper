{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1516454377,"rating":8,"authorHandle":"Rudy420","modificationTimeSeconds":1516566272,"id":57240,"title":"\u003cp\u003eRound #3 Tutorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003eA. Bear and Friendship Condition\u003c/h4\u003e\u003cp\u003eGraful e bun daca si numai daca fiecare componenta conexa e un subgraf complet (clique). Asta se verifica usor cu DFS.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCod\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define sz size()\n#define pb push_back\n\nint n,m,x,y,v[150005];\n\nvector \u0026lt;int\u0026gt; g[150005],q;\n\nvoid DFS(int nod){\n    if(v[nod]) return;\n    v[nod]\u003d1; q.pb(nod);\n    for(int i : g[nod]){\n        DFS(i);\n    }\n}\n\nint32_t main(){\n    ios_base :: sync_with_stdio(0); cin.tie(); cout.tie();\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n    for(int i\u003d1;i\u0026lt;\u003dm;i++){\n        cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n    for(int i\u003d1;i\u0026lt;\u003dn;i++){\n        if(!v[i]){\n            q.clear();\n            DFS(i);\n            for(int j : q){\n                if(g[j].sz!\u003dq.sz-1){\n                    cout \u0026lt;\u0026lt; \u0026quot;NO\u0026quot;;\n                    return 0;\n                }\n            }\n        }\n    }\n    cout \u0026lt;\u0026lt; \u0026quot;YES\u0026quot;;\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003eB. Hongcow Builds A Nation\u003c/h4\u003e\u003cp\u003eNoi trebuie sa adugam numarul maxim de muchii astfel incit in fiecare componenta conexa sa avem maxim un guvern. Gasim componentele conexe initiale. E usor de aratat ca este optim sa unim componentele ce nu contin nici un guvern, apoi sa le unim cu componenta maxima ce contine un guvern, apoi sa adaugam muchii pina cind fiecare componenta e un graf complet. Raspunsul e numarul de muchii din acest graf minus numarul de muchii din graful initial. Toate acestea se pot face cu DFS. N e destul de mic si trec si solutii in O(N^2+M). Solutia de mai jos e in O(N+M).\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCod\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define sz size()\n#define pb push_back\n\nint n,m,k,c[1005],x,y,v[1005],cnt,ncomp,ans,p;\n\nvector \u0026lt;int\u0026gt; g[1005],comp;\n\nvoid DFS(int nod){\n    if(v[nod]) return;\n    v[nod]\u003d1;\n    if(c[nod]) p\u003d0;\n    cnt++;\n    for(int i : g[nod]){\n        DFS(i);\n    }\n}\n\nint32_t main(){\n    ios_base :: sync_with_stdio(0); cin.tie(); cout.tie();\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k;\n    for(int i\u003d1;i\u0026lt;\u003dk;i++){\n        cin \u0026gt;\u0026gt; x;\n        c[x]\u003d1;\n    }\n    for(int i\u003d1;i\u0026lt;\u003dm;i++){\n        cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n    for(int i\u003d1;i\u0026lt;\u003dn;i++){\n        if(!v[i]){\n            cnt\u003d0; p\u003d1;\n            DFS(i);\n            if(p) ncomp+\u003dcnt;\n            else comp.pb(cnt);\n        }\n    }\n    sort(comp.begin(),comp.end());\n    comp[comp.sz-1]+\u003dncomp;\n    for(int i : comp){\n        ans+\u003di*(i-1)/2;\n    }\n    cout \u0026lt;\u0026lt; ans-m;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003eC. Two Buttons\u003c/h4\u003e\u003cp\u003eFacem un graf orientat, fiecare nod reprezinta un numar natural. Punem muchiile x-\u0026gt;2x si x-\u0026gt;x-1. Raspunsul va fi drumul minim de la n la m. Noi avem un numar infinit de noduri, dar observam ca daca x\u0026gt;2*m atunci nu ne pasa de el, si deci avem maxim 2*m noduri. Drumul minim se gaseste usor cu BFS.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCod\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define sz size()\n#define pb push_back\n\nint n,m,v[20005];\n\nqueue \u0026lt;int\u0026gt; q;\n\nint32_t main(){\n    ios_base :: sync_with_stdio(0); cin.tie(); cout.tie();\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n    q.push(n); v[n]\u003d1;\n    while(!v[m]){\n        int nod\u003dq.front();\n        q.pop();\n        if(nod\u0026lt;\u003dm \u0026amp;\u0026amp; !v[2*nod]){\n            v[2*nod]\u003dv[nod]+1;\n            q.push(2*nod);\n        }\n        if(nod\u0026gt;1 \u0026amp;\u0026amp; !v[nod-1]){\n            v[nod-1]\u003dv[nod]+1;\n            q.push(nod-1);\n        }\n    }\n    cout \u0026lt;\u0026lt; v[m]-1;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003eD. The Two Routes\u003c/h4\u003e\u003cp\u003eUnul din grafuri va contine muchia 1-N, si deci distanta minima pentru graful acela va fi 1. Pentru celalalt graf, raspunsul se gaseste usor cu BFS. N e mic, deci trece si BFS in O(N^2+M).\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCod\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define sz size()\n#define pb push_back\n\nint n,m,x,y,p,a[405][405],b[405][405],v[405];\n\nqueue \u0026lt;int\u0026gt; q;\n\n\nint32_t main(){\n    ios_base :: sync_with_stdio(0); cin.tie(); cout.tie();\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n    for(int i\u003d1;i\u0026lt;\u003dm;i++){\n        cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n        if((x\u003d\u003d1 \u0026amp;\u0026amp; y\u003d\u003dn) || (x\u003d\u003dn \u0026amp;\u0026amp; y\u003d\u003d1)) p\u003d1;\n        a[x][y]\u003d1;\n        a[y][x]\u003d1;\n    }\n    for(int i\u003d1;i\u0026lt;\u003dn;i++){\n        for(int j\u003d1;j\u0026lt;\u003dn;j++){\n            if(i!\u003dj) b[i][j]\u003d!a[i][j];\n        }\n    }\n    if(p){\n        q.push(1);\n        v[1]\u003d1;\n        while(q.sz){\n            int nod\u003dq.front();\n            q.pop();\n            for(int j\u003d1;j\u0026lt;\u003dn;j++){\n                if(b[nod][j] \u0026amp;\u0026amp; !v[j]) v[j]\u003dv[nod]+1,q.push(j);\n            }\n        }\n    }\n    else{\n        q.push(1);\n        v[1]\u003d1;\n        while(q.sz){\n            int nod\u003dq.front();\n            q.pop();\n            for(int j\u003d1;j\u0026lt;\u003dn;j++){\n                if(a[nod][j] \u0026amp;\u0026amp; !v[j]) v[j]\u003dv[nod]+1,q.push(j);\n            }\n        }\n    }\n    cout \u0026lt;\u0026lt; v[n]-1;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003eE. Igor In the Museum\u003c/h4\u003e\u003cp\u003eSolutia in O(n*m*k): pentru fiecare intrebare chemam algoritmul Lee si gasim raspunsul. Pentru a optimiza la O(n*m+k), observam ca toate patratele din aceeasi componenta conexa au acelasi raspuns, si deci noi trebuie sa chemam Lee pentru fiecare componenta conexa doar odata, si cum Lee va evectua O(numarul de patrate din componenta) operatii, in total vom avea O(n*m) operatii. Deci precalculam raspunsul pentru fiecare celula, si raspundem la fiecare intrebare raspundem in O(1)\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCod\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define sz size()\n#define pb push_back\n\nint n,m,t[1005][1005],cnt,v[1005][1005],k,x,y;\n\nchar a[1005][1005];\n\nvoid DFS1(int x, int y){\n    if(v[x][y]) return;\n    v[x][y]\u003d1;\n    if(a[x-1][y]\u003d\u003d\u0027*\u0027) cnt++;\n    else if(x\u0026gt;1) DFS1(x-1,y);\n    if(a[x+1][y]\u003d\u003d\u0027*\u0027) cnt++;\n    else if(x\u0026lt;n) DFS1(x+1,y);\n    if(a[x][y-1]\u003d\u003d\u0027*\u0027) cnt++;\n    else if(y\u0026gt;1) DFS1(x,y-1);\n    if(a[x][y+1]\u003d\u003d\u0027*\u0027) cnt++;\n    else if(y\u0026lt;m) DFS1(x,y+1);\n}\n\nvoid DFS2(int x, int y){\n    if(v[x][y]\u003d\u003d2) return;\n    v[x][y]\u003d2; t[x][y]\u003dcnt;\n    if(x\u0026gt;1 \u0026amp;\u0026amp; a[x-1][y]\u003d\u003d\u0027.\u0027) DFS2(x-1,y);\n    if(x\u0026lt;n \u0026amp;\u0026amp; a[x+1][y]\u003d\u003d\u0027.\u0027) DFS2(x+1,y);\n    if(y\u0026gt;1 \u0026amp;\u0026amp; a[x][y-1]\u003d\u003d\u0027.\u0027) DFS2(x,y-1);\n    if(y\u0026lt;m \u0026amp;\u0026amp; a[x][y+1]\u003d\u003d\u0027.\u0027) DFS2(x,y+1);\n}\n\nint32_t main(){\n    ios_base :: sync_with_stdio(0); cin.tie(); cout.tie();\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k;\n    for(int i\u003d1;i\u0026lt;\u003dn;i++){\n        for(int j\u003d1;j\u0026lt;\u003dm;j++){\n            cin \u0026gt;\u0026gt; a[i][j];\n        }\n    }\n    for(int i\u003d1;i\u0026lt;\u003dn;i++){\n        for(int j\u003d1;j\u0026lt;\u003dm;j++){\n            if(a[i][j]\u003d\u003d\u0027.\u0027 \u0026amp;\u0026amp; !v[i][j]){\n                DFS1(i,j);\n                DFS2(i,j);\n                cnt\u003d0;\n            }\n        }\n    }\n    for(int i\u003d1;i\u0026lt;\u003dk;i++){\n        cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n        cout \u0026lt;\u0026lt; t[x][y] \u0026lt;\u0026lt; \u0027\\n\u0027;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003eF. Journey\u003c/h4\u003e\u003cp\u003eSolutia este dp pe arbori. Fie dp[i] â€” expected length daca incepem in nodul i si mergem in jos. Daca suntem in nodul N, calculam recursiv dp[i] pentru copiii lui, apoi dp[N]\u003dsum(dp[kids])/(numarul de copii)+1.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCod\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define sz size()\n#define pb push_back\n\nint n,x,y;\n\nvector \u0026lt;int\u0026gt; g[100005];\n\ndouble dp[100005];\n\nvoid DFS(int nod, int p){\n    for(int i : g[nod]){\n        if(i!\u003dp) DFS(i,nod),dp[nod]+\u003ddp[i];\n    }\n    if(p\u003d\u003d-1 \u0026amp;\u0026amp; g[nod].sz) dp[nod]/\u003dg[nod].sz;\n    else if(g[nod].sz\u0026gt;1) dp[nod]/\u003dg[nod].sz-1;\n    if(nod!\u003d1) dp[nod]++;\n}\n\nint32_t main(){\n    ios_base :: sync_with_stdio(0); cin.tie(); cout.tie();\n    cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(7);\n    cin \u0026gt;\u0026gt; n;\n    for(int i\u003d1;i\u0026lt;n;i++){\n        cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n    DFS(1,-1);\n    cout \u0026lt;\u0026lt; dp[1];\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003eG. Timofey and a tree\u003c/h4\u003e\u003cp\u003eDaca doua noduri vecine sunt de culori diferite, atunci unul din ele trebuie sa fie raspunsul. Gasim o astfel de pereche, incercam ambele noduri, daca niciunul nu merge raspunsul e \u0026quot;NO\u0026quot;, atfel e \u0026quot;YES\u0026quot;.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCod\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define sz size()\n#define pb push_back\n\nint n,x,y,c[100005],v[100005],b;\n\nvector \u0026lt;int\u0026gt; g[100005];\n\nvoid DFS(int nod, int p){\n    if(v[nod]) return;\n    v[nod]\u003d1;\n    if(c[nod]!\u003dc[p]) b\u003d0;\n    for(int i : g[nod]){\n        DFS(i,p);\n    }\n}\n\nint32_t main(){\n    ios_base :: sync_with_stdio(0); cin.tie(); cout.tie();\n    cin \u0026gt;\u0026gt; n;\n    for(int i\u003d1;i\u0026lt;n;i++){\n        cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n    for(int i\u003d1;i\u0026lt;\u003dn;i++){\n        cin \u0026gt;\u0026gt; c[i];\n    }\n    for(int i\u003d1;i\u0026lt;\u003dn;i++){\n        for(int j : g[i]){\n            if(c[i]!\u003dc[j]){\n\n                v[i]\u003d1; b\u003d1;\n                for(int k : g[i]){\n                    DFS(k,k);\n                }\n                if(b){\n                    cout \u0026lt;\u0026lt; \u0026quot;YES\\n\u0026quot; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027\\n\u0027;\n                    return 0;\n                }\n\n                for(int k\u003d1;k\u0026lt;\u003dn;k++) v[k]\u003d0;\n\n                v[j]\u003d1; b\u003d1;\n                for(int k : g[j]){\n                    DFS(k,k);\n                }\n                if(b){\n                    cout \u0026lt;\u0026lt; \u0026quot;YES\\n\u0026quot; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0027\\n\u0027;\n                    return 0;\n                }\n\n                cout \u0026lt;\u0026lt; \u0026quot;NO\u0026quot;;\n\n                return 0;\n            }\n        }\n    }\n    cout \u0026lt;\u0026lt; \u0026quot;YES\\n\u0026quot; \u0026lt;\u0026lt; 1;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["dfs","bfs","tree"]}}