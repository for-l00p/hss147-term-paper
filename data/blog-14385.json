{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1413992427,"rating":185,"authorHandle":"kien_coi_1997","modificationTimeSeconds":1414750184,"id":14385,"title":"\u003cp\u003eAn efficient way to solve some counting problems without matrix multiplication\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI\u0027m going to talking about an approach which can replace matrix multiplication in some problems. It is not only easier to implement, but also easier to adjust your code.\u003c/p\u003e\u003cp\u003eIt is hard to write both long and detailed blog. Therefore, you can comment anything which you didn\u0027t understand well. I will reply (or update this blog if it is necessary).\u003c/p\u003e\u003ch2\u003eI. Background\u003c/h2\u003e\u003cp\u003eMatrix multiplication is useful. In many counting problems, when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is small, we can use DP to solve. However, when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is large (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≈ 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e), we must use matrix multiplication to increase solution\u0027s speed. In solutions using matrix multiplication, generating base matrix is not easy at all. I found an good approach to solve some of those problems without matrix multiplication.\u003c/p\u003e\u003cp\u003eThere are several advantages of my approach:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eWe don\u0027t need to implement multiply operator between two matrix (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e·\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e) and power operator (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e).\u003c/li\u003e   \u003cli\u003eWe don\u0027t need to spend time to generate base matrix\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eBesides, there are following disadvantages:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eThis approach is only applicable in counting problems, it means this approach can\u0027t replace matrix multiplication in all of problems.\u003c/li\u003e   \u003cli\u003eI\u0027m not sure if this approach are usable in all of counting problems (which can be solved using matrix multiplication)\u003c/li\u003e \u003c/ul\u003e\u003ch2\u003eII. The simplest example\u003c/h2\u003e\u003cp\u003eFor example, I will use this problem: \u003c/p\u003e\u003cp\u003eHow many right bracket sequence which has length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and depth is not larger than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e? (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e, \u003ci\u003eL\u003c/i\u003e ≤ 10\u003c/span\u003e)\u003c/p\u003e\u003cp\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 4\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e \u003d 1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e()()\u003c/span\u003e is only right bracket sequence, but \u003cspan class\u003d\"tex-span\"\u003e(())\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e((()\u003c/span\u003e, and \u003cspan class\u003d\"tex-span\"\u003e))((\u003c/span\u003e is not.\u003c/p\u003e\u003cp\u003eLet\u0027s think about some other common ways before talking about main approach.\u003c/p\u003e\u003cp\u003eFirstly, because of large \u003cem\u003en\u003c/em\u003e, we can use matrix multiplication to use this problem. \u003cem\u003eF[i]\u003c/em\u003e is an array of \u003cem\u003eL\u003c/em\u003e elements, where \u003cem\u003eF[i][k]\u003dx\u003c/em\u003e means there are \u003cem\u003ex\u003c/em\u003e sequence length \u003cem\u003ei\u003c/em\u003e and current height is \u003cem\u003ek\u003c/em\u003e. As I said above, the hardest step is to generating base matrix. Amazingly, my approach can solve this problem, and solution size is less than 30 lines.\u003c/p\u003e\u003cp\u003eLet\u0027s think about DP approach. It is easy to find formula \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003eh\u003c/i\u003e) \u003d \u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e - 1, \u003ci\u003eh\u003c/i\u003e - 1) + \u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e - 1, \u003ci\u003eh\u003c/i\u003e + 1)\u003c/span\u003e that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003eh\u003c/i\u003e)\u003c/span\u003e means number of valid sequences with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is the length of remaining sequence, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e is current height. The goal is calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, 0)\u003c/span\u003e. Of course, time complexity in this case is too large. My approach combine two approaches above.\u003c/p\u003e\u003cp\u003eNow, I will talk about my approach.\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003eh\u003c/i\u003e, \u003ci\u003eh\u003c/i\u003e0)\u003c/span\u003e is number of sequence length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, start at height \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e (current height), and end at height \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e0\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThere are two case: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 2 * \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 2 * \u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 0\u003c/span\u003e then return \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e \u003d \u003ci\u003eh\u003c/i\u003e0\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e otherwise\u003c/li\u003e   \u003cli\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is even, we have: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(2 * \u003ci\u003ek\u003c/i\u003e, \u003ci\u003eh\u003c/i\u003e, \u003ci\u003eh\u003c/i\u003e0)\u003c/span\u003e \u003d sum of all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e, \u003ci\u003eh\u003c/i\u003e, \u003ci\u003ei\u003c/i\u003e) * \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e, \u003ci\u003ei\u003c/i\u003e, \u003ci\u003eh\u003c/i\u003e0)\u003c/span\u003e where i in range \u003cspan class\u003d\"tex-span\"\u003e0..\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e\u003c/li\u003e   \u003cli\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is odd: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(2 * \u003ci\u003ek\u003c/i\u003e + 1, \u003ci\u003eh\u003c/i\u003e, \u003ci\u003eh\u003c/i\u003e0) \u003d \u003ci\u003ef\u003c/i\u003e(2 * \u003ci\u003ek\u003c/i\u003e, \u003ci\u003eh\u003c/i\u003e - 1, \u003ci\u003eh\u003c/i\u003e0) + \u003ci\u003ef\u003c/i\u003e(2 * \u003ci\u003ek\u003c/i\u003e, \u003ci\u003eh\u003c/i\u003e + 1, \u003ci\u003eh\u003c/i\u003e0)\u003c/span\u003e\u003c/li\u003e   \u003cli\u003eAdditionally, we need to pay attention at following case: if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e \u0026lt; 0\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e \u0026gt; \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e \u003d 0\u003c/span\u003e\u003c/li\u003e   \u003cli\u003eThe goal is output \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, 0, 0)\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThe complexity of this approach is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/01/cf/01cfd68b3e6cbe1e2edcb86f4940844eb120a5eb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, equally to solution using matrix multiplication. Note that there are only \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3b/89/3b8980e60a704ef2b80af6de73f91762686fdb97.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e states, not \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eL\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e * \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. For example, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 100\u003c/span\u003e, values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e in all of states will be in the set \u003cspan class\u003d\"tex-span\"\u003e{100, 50, 25, 24, 12, 6, 3, 2, 1, 0}\u003c/span\u003e. Therefore, we can use index of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e in above set, in other words, the depth of current state, to represent \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e in states instead of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003ePseudo-code\u003c/p\u003e \u003cpre\u003e\u003ccode\u003edef f(n, h, h0, Depth):\n\tif h\u0026lt;0 or h\u0026gt;L: return 0\n\tif n\u003d\u003d0: return (h\u003d\u003dh0 ? 1 : 0)\n\tif Saved[h][h0][Depth]\u003d\u003dtrue: return Value[h][h0][Depth]\n\n\tif n is even:\n\t\tResult \u003d0\n\t\tfor i in 0..L: Result +\u003d f(n/2, h, i, Depth+1) * f(n/2, i, h0, Depth+1)\n\telse:\n\t\tResult \u003d f(n-1, h-1, h0, Depth+1) + f(n-1, h+1, h0, Depth+1)\n\t\n\tSaved[h][h0][Depth] \u003d true\n\tValue[h][h0][Depth] \u003d Result\n\nread n, L (from input)\noutput f(n, 0, 0, 0)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTo explain how can Depth represent n, let n\u003d100 for example, for each values of n, we have a value of Depth:\u003c/p\u003e\u003cp\u003en 100 25 24 12 6 3 2 1 0 Depth 0 1 2 3 4 5 6 7 8\u003c/p\u003e\u003ch2\u003eIII. General case: when f(n, [a,b,c,...]) can be calculated from f(n-1, [a\u0027,b\u0027,c\u0027,...])\u003c/h2\u003e\u003cp\u003eIn this case, if you can still use matrix multiplication, you will have a big difficulty in generating base matrix. Consider following problem (I don\u0027t know where it is from):\u003c/p\u003e\u003cp\u003eThere are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e kind of flowers. In these \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e kinds, there are 4 kinds of flowers: \u003cem\u003egerbera\u003c/em\u003e, \u003cem\u003eorchid\u003c/em\u003e, \u003cem\u003eazalea\u003c/em\u003e and \u003cem\u003ehydrangea\u003c/em\u003e. We use them to create a sequence with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e pots of flowers. There are several conditions:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eA \u003cem\u003ehydrangea\u003c/em\u003e must be put between an \u003cem\u003eazalea\u003c/em\u003e and an \u003cem\u003eorchid\u003c/em\u003e \u003cem\u003e(aho\u003c/em\u003e or \u003cem\u003eoha)\u003c/em\u003e\u003c/li\u003e   \u003cli\u003eThere are at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e flower different from \u003cem\u003egerbera\u003c/em\u003e between any pairs of \u003cem\u003egerbera\u003c/em\u003e. Our goal is to find number of valid sequences.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSuppose that there are t\u003d5 kinds of flowers: \u003cem\u003eazaleas\u003c/em\u003e (a), \u003cem\u003ehydrangeas\u003c/em\u003e (h), \u003cem\u003eorchids\u003c/em\u003e (o) \u003cem\u003egerbera\u003c/em\u003e (g) and \u003cem\u003ebegonias\u003c/em\u003e (b) and between two gerbera, there must be at least \u003cem\u003ep\u003d3\u003c/em\u003e flowers different from gerbera. With \u003cem\u003en\u003d6\u003c/em\u003e, there are 2906 valid sequences, 5 of them are: \u003cem\u003eaoaaoo\u003c/em\u003e, \u003cem\u003eahohag\u003c/em\u003e, \u003cem\u003egbbbgo\u003c/em\u003e, \u003cem\u003egbbbog\u003c/em\u003e, \u003cem\u003ebbbbbb\u003c/em\u003e. Following sequences are invalid: \u003cem\u003eohoaha\u003c/em\u003e (substring \u003cem\u003e“aha”\u003c/em\u003e is invalid because it should be \u003cem\u003e“oha”\u003c/em\u003e or \u003cem\u003e“aho”\u003c/em\u003e), \u003cem\u003egogbao\u003c/em\u003e (because there are not 3 flowers between \u003cem\u003eg\u003c/em\u003e and \u003cem\u003eg\u003c/em\u003e ), \u003cem\u003eahohah\u003c/em\u003e (because the last \u003cem\u003eh\u003c/em\u003e is not adjacent with \u003cem\u003ea\u003c/em\u003e and \u003cem\u003eo\u003c/em\u003e ).\u003c/p\u003e\u003cp\u003eConstrains: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e, \u003ci\u003ep\u003c/i\u003e ≤ 20, \u003ci\u003et\u003c/i\u003e ≤ 20\u003c/span\u003e\u003c/p\u003e\u003cp\u003eIt is not to hard to find its DP formula: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e, \u003ci\u003eJust\u003c/i\u003e)\u003c/span\u003e returns number of valid sequence. Its parameters, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eJust\u003c/i\u003e\u003c/span\u003e, are described as follow:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is length of remaining sequence which we need to build.\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is number of pots different from \u003cem\u003egerbera\u003c/em\u003e that I have just put them, in other words, we have just put \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e pots of flowers different from \u003cem\u003egerbera\u003c/em\u003e (you can imagine that all pots in range \u003cem\u003en+1\u003c/em\u003e .. \u003cem\u003en+x\u003c/em\u003e are not gerbera).\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eJust\u003c/i\u003e\u003c/span\u003e represents the last pot of flower (the last pot which we have just put, in other words, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eJust\u003c/i\u003e\u003c/span\u003e represents pot number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + 1\u003c/span\u003e), \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eJust\u003c/i\u003e\u003c/span\u003e can be one of three following values, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eJust\u003c/i\u003e \u003d 1\u003c/span\u003e means \u003cem\u003eazalea\u003c/em\u003e or \u003cem\u003eorchid\u003c/em\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eJust\u003c/i\u003e \u003d 2\u003c/span\u003e means \u003cem\u003ehydrangea\u003c/em\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eJust\u003c/i\u003e \u003d 0\u003c/span\u003e in other cases (included \u003cem\u003egerbera\u003c/em\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e - 4\u003c/span\u003e remaining kind of flowers)\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThe following code is DP function, it will work with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≤ 10000\u003c/span\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003elong f(int n, int x, int Just) {\n\tif (x\u0026gt;\u003dp) x\u003dp;\n\tif (Just\u003d\u003d2) {\n\t\tif (n\u003d\u003d0) return 0;\n\t\treturn f(n-1, x+1, 1);\n\t} else {\n\t\tif (n\u003d\u003d0) return 1;\n\t\tif (F[x][Just].count(n)) return F[x][Just][n];\n\t\tlong Sum \u003d f(n-1, x+1, 1) * 2;\n\t\tif (Just\u003d\u003d1) Sum +\u003d f(n-1, x+1, 2);\n\t\tif (x\u0026gt;\u003dp) Sum +\u003d f(n-1, 0, 0);\n\t\tSum +\u003d f(n-1, x+1, 0) * (t-4);\n\t\treturn F[x][Just][n] \u003d Sum % M;\n\t}\n}\ncout \u0026lt;\u0026lt; f(n, ::p, 0) \u0026lt;\u0026lt; endl;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow, I will talk about correct solution. To be able to solve with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e up to \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e, I use my above approach. Now we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003ep\u003c/i\u003e, \u003ci\u003eJust\u003c/i\u003e, \u003ci\u003ep\u003c/i\u003e0, \u003ci\u003eJust\u003c/i\u003e0)\u003c/span\u003e means we are start from state \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003ep\u003c/i\u003e, \u003ci\u003eJust\u003c/i\u003e)\u003c/span\u003e, how many way to go to state \u003cspan class\u003d\"tex-span\"\u003e(0, \u003ci\u003ep\u003c/i\u003e0, \u003ci\u003eJust\u003c/i\u003e0)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTo prevent misunderstanding, I will explain more about \u003cem\u003eStop\u003c/em\u003e parameter. Whenever \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eStop\u003c/i\u003e \u003d \u003ci\u003etrue\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003ep\u003c/i\u003e, \u003ci\u003eJust\u003c/i\u003e, \u003ci\u003ep\u003c/i\u003e0, \u003ci\u003eJust\u003c/i\u003e, \u003ci\u003eStop\u003c/i\u003e) \u003d \u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003ep\u003c/i\u003e, \u003ci\u003eJust\u003c/i\u003e)\u003c/span\u003e. Whenever \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eStop\u003c/i\u003e \u003d \u003ci\u003efalse\u003c/i\u003e\u003c/span\u003e, f(n, p, Just, p0, Just, Stop) \u003d f(n, p, Just, p0, Just)$\u003c/p\u003e\u003cp\u003eWe have two case: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 2 * \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 2 * \u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 2 * \u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 0\u003c/span\u003e, we implement it as well as old DP-function. Else if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 2 * \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(2 * \u003ci\u003ek\u003c/i\u003e, \u003ci\u003ep\u003c/i\u003e, \u003ci\u003eJust\u003c/i\u003e, \u003ci\u003ep\u003c/i\u003e0, \u003ci\u003eJust\u003c/i\u003e0)\u003c/span\u003e \u003d sum of all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e, \u003ci\u003ep\u003c/i\u003e, \u003ci\u003eJust\u003c/i\u003e, \u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e) * \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e, \u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003ep\u003c/i\u003e0, \u003ci\u003eJust\u003c/i\u003e0)\u003c/span\u003e for all valid pairs of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e in range \u003cspan class\u003d\"tex-span\"\u003e0..: : \u003ci\u003ep\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e in range \u003cspan class\u003d\"tex-span\"\u003e0..2\u003c/span\u003e)\u003c/p\u003e\u003cp\u003ePay attention in case \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 0\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 0\u003c/span\u003e doesn\u0027t represent the end of the sequence. Because our sequence are broke into many segments, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 0\u003c/span\u003e only represents an end of a part. Therefore, I use additional parameter \u003cem\u003eStop\u003c/em\u003e typed \u003cem\u003eboolean\u003c/em\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003emap\u0026lt;int, int\u0026gt; G[21][3][21][3][2];\n#define C p][Just][p0][Just0][Stop\n\nlong g(int n, int p, int Just, int p0, int Just0, bool Stop) {\t\n\tif (p\u0026gt;\u003d::p) p\u003d::p;\n\tif (n%2\u003d\u003d1 || n\u003d\u003d0) {\n\t\tif (Just\u003d\u003d2) {\n\t\t\tif (n\u003d\u003d0) return Stop ? 0 : p\u003d\u003dp0 \u0026amp;\u0026amp; Just\u003d\u003dJust0;\n\t\t\treturn g(n-1, p+1, 1, p0, Just0, Stop);\n\t\t} else {\n\t\t\tif (n\u003d\u003d0) return Stop ? 1 : p\u003d\u003dp0 \u0026amp;\u0026amp; Just\u003d\u003dJust0;\n\t\t\tif (G[C].count(n)) return G[C][n];\n\t\t\tlong Sum \u003d g(n-1, p+1, 1, p0, Just0, Stop) * 2;\n\t\t\tif (Just\u003d\u003d1) Sum +\u003d g(n-1, p+1, 2, p0, Just0, Stop);\n\t\t\tif (p\u0026gt;\u003d::p) Sum +\u003d g(n-1, 0, 0, p0, Just0, Stop);\n\t\t\tSum +\u003d g(n-1, p+1, 0, p0, Just0, Stop) * (t-4);\n\t\t\treturn G[C][n] \u003d Sum % M;\n\t\t}\n\t} else {\t\t\n\t\tif (G[C].count(n)) return G[C][n];\n\t\tlong Sum \u003d 0;\n\t\tfor (int i\u003d0; i\u0026lt;\u003d::p; i++)\n\t\tfor (int k\u003d0; k\u0026lt;\u003d2; k++) {\n\t\t\tlong G1 \u003d g(n/2, p, Just, i, k, false);\n\t\t\tlong G2 \u003d g(n/2, i, k, p0, Just0, Stop);\n\t\t\tSum +\u003d G1*G2;\n\t\t}\n\t\treturn G[C][n] \u003d Sum % M;\n\t}\n}\n\ncout \u0026lt;\u0026lt; g(n, ::p, 0, rand()%21, rand()%3, true) \u0026lt;\u0026lt; endl;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNote that in my above code, \u003ccode\u003e::p\u003c/code\u003e and \u003ccode\u003ep\u003c/code\u003e are different. \u003ccode\u003e::p\u003c/code\u003e is the \u003ccode\u003ep\u003c/code\u003e in the input (how many flowers different from \u003cem\u003egerbera\u003c/em\u003e between any two pairs of \u003cem\u003egerbera\u003c/em\u003e), \u003ccode\u003ep\u003c/code\u003e is parameter of function \u003ccode\u003eg\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003cem\u003erand()%21\u003c/em\u003e, and \u003cem\u003erand%3\u003c/em\u003e mean that those values are not important (whenever \u003cem\u003eStop\u003d\u003dtrue\u003c/em\u003e, \u003cem\u003ep0\u003c/em\u003e and \u003cem\u003eJust0\u003c/em\u003e are not important)\u003c/p\u003e\u003cp\u003eThe complexity of above solution is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e3/4c/e34cf68e624dbed6dae11ab04c5fee6679ea236e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. In fact, we can avoid using map to reduce the complexity. If we do, it becomes \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d1/72/d172f98bde12961fdf0dba3c6e18a50142ca3044.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, equal to the complexity of using matrix multiplication. (I used map for easier readability)\u003c/p\u003e\u003ch2\u003eIV. f(n) \u003d f(n-1) + f(n-2)\u003c/h2\u003e\u003cp\u003eNow, let\u0027s calculate 10^9-th number in fibonacci sequence (in some modulo). Use matrix multiplication in this problem is easy, however, we have another way to solve this problem without using matrix multiplication. Consider following example:\u003c/p\u003e\u003cp\u003eYou are standing at position n in Ox axis. In a step, you can move to the left 1 or 2. How many ways to reach position 0?\u003c/p\u003e\u003cp\u003eIt is not hard to realize \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e) \u003d \u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e - 1) + \u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e - 2)\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(0) \u003d 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(1) \u003d 1\u003c/span\u003e. Therefore \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e is \u003cem\u003e(n+1)-th\u003c/em\u003e element in fibonacci sequence.\u003c/p\u003e\u003cp\u003eThere are two cases:\u003c/p\u003e \u003cul\u003e   \u003cli\u003en\u003d2*k: we have two choices: first choice is to jump from 2*k to k and jump to 0, another choice is to jump from n to k+1, move 2 step left, and jump from k-1 to 0. Therefore, f(2*k) \u003d f(k)*f(k) + f(k-1) * f(k-1)\u003c/li\u003e   \u003cli\u003en\u003d2*k+1: consider two segments \u003ca href\u003d\"distance\u003dk\"\u003e0..k\u003c/a\u003e and \u003ca href\u003d\"distance\u003dk+1\"\u003ek..n\u003c/a\u003e. There are two choices: first choice is to jump from n to k and jump from k to 0, another choice is to jump from n to k+1, move 2 steps to the left, and jump from k-1 to 0. Therefore, f(2*k+1) \u003d f(k)*f(k+1) + f(k-1)*f(k).\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eIf we stop at this point, time complexity is too large, consider case n\u003d100:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eDepth 0: call f(100)\u003c/li\u003e   \u003cli\u003eDepth 1: call f(49), f(50)\u003c/li\u003e   \u003cli\u003eDepth 2: f(23), f(24), f(25)\u003c/li\u003e   \u003cli\u003eDepth 3: 10, 11, 12, 13\u003c/li\u003e   \u003cli\u003e…\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eTime complexity is now still \u003cs\u003eO(n)\u003c/s\u003e \u003ca href\u003d\"//codeforces.com/blog/entry/14516\"\u003eO(log n)\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe will reduce complexity as following. Let MinDepth[i] be the smallest n in Depth i, for example, array MinDepth[] in above example is {100, 49, 23, 10, …}. Now we will calculate f(25) using f(23) and f(24). Because MinDepth[2] is 23, and 25-23\u0026gt;\u003d2, therefore, f(25) \u003d f(23) + f(24).\u003c/p\u003e\u003cp\u003ePseudo-code\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eMinDepth[] \u003d {oo,oo,...}\n\ndef f(n, Depth):\n\tif n\u003d\u003d0 or n\u003d\u003d1: return 1\n\tif n-MinDepth[Depth]\u0026gt;\u003d2: \n\t\treturn f(n-1, Depth) + f(n-2, Depth)\n\n\tif Saved[n]: return Value[n]\n\tMinDepth[Depth] \u003d min(MinDepth[Depth], n)\n\tif n is even:\n\t\tCount1 \u003d f(n/2-1, Depth+1) * f(n/2-1, Depth+1)\n\t\tCount2 \u003d f(n/2, Depth+1) * f(n/2, Depth+1)\n\t\tResult \u003d Count1 + Count2\n\telse:\n\t\tCount1 \u003d f(n/2-1, Depth+1) * f(n/2, Depth+1)\n\t\tCount2 \u003d f(n/2, Depth+1) * f(n/2+1, Depth+1)\n\t\tResult \u003d Count1 + Count2\n\tSaved[n] \u003d true\n\tValue[n] \u003d Result\n\ninput n\noutput f(n,0)\n\u003c/code\u003e\u003c/pre\u003e \u003cul\u003e   \u003cli\u003eDepth 0: call f(100)\u003c/li\u003e   \u003cli\u003eDepth 1: call f(49), f(50)\u003c/li\u003e   \u003cli\u003eDepth 2: f(23), f(24), f(25)\u003df(23)+f(24)\u003c/li\u003e   \u003cli\u003eDepth 3: 10, 11, f(12)\u003df(10)+f(11)\u003c/li\u003e   \u003cli\u003e…\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eTime complexity now is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogn\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003ch2\u003eV. Conclusion\u003c/h2\u003e\u003cp\u003eIt is hard to write both long and detailed blog. Therefore, you can comment anything which you didn\u0027t understand well. I will reply (or update this blog if it is necessary).\u003c/p\u003e\u003c/div\u003e","tags":["matrix","multiplication","dynamic"]}}