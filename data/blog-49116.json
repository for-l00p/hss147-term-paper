{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1481911586,"rating":7,"authorHandle":"tankist.scratch","modificationTimeSeconds":1518457347,"id":49116,"title":"\u003cp\u003eclass graph\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ctable width\u003d\"100%\"\u003e   \u003ctbody\u003e\u003ctr\u003e     \u003cth\u003eФункция\u003c/th\u003e     \u003cth\u003eИспользование\u003c/th\u003e     \u003cth\u003eОписание\u003c/th\u003e   \u003c/tr\u003e   \u003ctr\u003e     \u003cth\u003eaddvector\u003c/th\u003e     \u003ctd\u003e\u003cb style\u003d\"color: rgb(0,0,170);\"\u003eaddvector\u003c/b\u003e(\u003cspan style\u003d\"color: rgb(0,170,170);\"\u003eunsigned int\u003c/span\u003e \u003cb\u003ea\u003c/b\u003e, \u003cspan style\u003d\"color: rgb(0,170,170);\"\u003eunsigned int\u003c/span\u003e \u003cb\u003eb\u003c/b\u003e, \u003cspan style\u003d\"color: rgb(0,170,170);\"\u003eint\u003c/span\u003e \u003cb\u003ew\u003c/b\u003e)\u003c/td\u003e     \u003ctd\u003eДобавляет \u003ca href\u003d\"https://ru.wikipedia.org/wiki/Глоссарий теории графов#дуга\"\u003eдугу\u003c/a\u003e из точки \u003cb\u003ea\u003c/b\u003e в точку \u003cb\u003eb\u003c/b\u003e весом \u003cb\u003ew\u003c/b\u003e.\u003c/td\u003e   \u003c/tr\u003e   \u003ctr\u003e     \u003cth\u003eaddline\u003c/th\u003e     \u003ctd\u003e\u003cb style\u003d\"color: rgb(0,0,170);\"\u003eaddline\u003c/b\u003e(\u003cspan style\u003d\"color: rgb(0,170,170);\"\u003eunsigned int\u003c/span\u003e \u003cb\u003ea\u003c/b\u003e, \u003cspan style\u003d\"color: rgb(0,170,170);\"\u003eunsigned int\u003c/span\u003e \u003cb\u003eb\u003c/b\u003e, \u003cspan style\u003d\"color: rgb(0,170,170);\"\u003eint\u003c/span\u003e \u003cb\u003ew\u003c/b\u003e)\u003c/td\u003e     \u003ctd\u003eДобавляет \u003ca href\u003d\"https://ru.wikipedia.org/wiki/Глоссарий теории графов#ребро\"\u003eребро\u003c/a\u003e (две \u003ca href\u003d\"https://ru.wikipedia.org/wiki/Глоссарий теории графов#дуга\"\u003eдуги\u003c/a\u003e) между точками \u003cb\u003ea\u003c/b\u003e и \u003cb\u003eb\u003c/b\u003e весом \u003cb\u003ew\u003c/b\u003e.\u003c/td\u003e   \u003c/tr\u003e   \u003ctr\u003e     \u003cth\u003eaddvertex\u003c/th\u003e     \u003ctd\u003e\u003cb style\u003d\"color: rgb(0,0,170);\"\u003eaddvertex\u003c/b\u003e()\u003c/td\u003e     \u003ctd\u003eДобавляет \u003ca href\u003d\"https://ru.wikipedia.org/wiki/Глоссарий теории графов#вершина\"\u003eвершину\u003c/a\u003e.\u003c/td\u003e   \u003c/tr\u003e   \u003ctr\u003e     \u003cth\u003echildren\u003c/th\u003e     \u003ctd\u003e\u003cspan style\u003d\"color: rgb(0,170,170);\"\u003elist\u003c/span\u003e\u0026lt;\u003cspan style\u003d\"color: rgb(0,170,170);\"\u003epair\u003c/span\u003e\u0026lt;\u003cspan style\u003d\"color: rgb(0,170,170);\"\u003eunsigned int\u003c/span\u003e, \u003cspan style\u003d\"color: rgb(0,170,170);\"\u003eint\u003c/span\u003e\u0026gt;\u0026gt; \u003cb style\u003d\"color: rgb(0,0,170);\"\u003echildren\u003c/b\u003e(\u003cspan style\u003d\"color: rgb(0,170,170);\"\u003eunsigned int\u003c/span\u003e \u003cb\u003ei\u003c/b\u003e)\u003c/td\u003e     \u003ctd\u003eВозвращает список \u003ca href\u003d\"https://ru.wikipedia.org/wiki/Глоссарий теории графов#дуга\"\u003eдуг\u003c/a\u003e, исходящих из \u003ca href\u003d\"https://ru.wikipedia.org/wiki/Глоссарий теории графов#вершина\"\u003eвершины\u003c/a\u003e \u003cb\u003ei\u003c/b\u003e в виде \u003ci\u003e\u003cb\u003e(\u003c/b\u003eточка, в которую входит дуга\u003cb\u003e;\u003c/b\u003e вес дуги\u003cb\u003e)\u003c/b\u003e\u003c/i\u003e\u003cb\u003e.\u003c/b\u003e\u003c/td\u003e   \u003c/tr\u003e   \u003ctr\u003e     \u003cth\u003eheight\u003c/th\u003e     \u003ctd\u003e\u003cspan style\u003d\"color: rgb(0,170,170);\"\u003eunsigned int\u003c/span\u003e \u003cb style\u003d\"color: rgb(0,0,170);\"\u003eheight\u003c/b\u003e(\u003cspan style\u003d\"color: rgb(0,170,170);\"\u003eunsigned int\u003c/span\u003e \u003cb\u003estart\u003c/b\u003e)\u003c/td\u003e     \u003ctd\u003eВозвращает высоты дерева с корнем в вершине \u003cb\u003estart\u003c/b\u003e\u003c/td\u003e   \u003c/tr\u003e   \u003ctr\u003e     \u003cth\u003edfs\u003c/th\u003e     \u003ctd\u003e\u003cspan style\u003d\"color: rgb(0,170,170);\"\u003epair\u003c/span\u003e\u0026lt;\u003cspan style\u003d\"color: rgb(0,170,170);\"\u003eunsigned int\u003c/span\u003e, \u003cspan style\u003d\"color: rgb(0,170,170);\"\u003elist\u003c/span\u003e\u0026lt;\u003cspan style\u003d\"color: rgb(0,170,170);\"\u003eunsigned int\u003c/span\u003e\u0026gt;\u0026gt; \u003cb style\u003d\"color: rgb(0,0,170);\"\u003edfs\u003c/b\u003e()\u003c/td\u003e     \u003ctd\u003eОбход в глубину. Возвращает количество компонент смежности и принадлежность каждой вершины к компоненте связанности.\u003c/td\u003e   \u003c/tr\u003e   \u003ctr\u003e     \u003cth\u003ebfs\u003c/th\u003e     \u003ctd\u003e\u003cspan style\u003d\"color: rgb(0,170,170);\"\u003elist\u003c/span\u003e\u0026lt;\u003cspan style\u003d\"color: rgb(0,170,170);\"\u003eunsigned int\u003c/span\u003e\u0026gt; \u003cb style\u003d\"color: rgb(0,0,170);\"\u003ebfs\u003c/b\u003e(\u003cspan style\u003d\"color: rgb(0,170,170);\"\u003eunsigned int\u003c/span\u003e \u003cb\u003estart\u003c/b\u003e, \u003cspan style\u003d\"color: rgb(0,170,170);\"\u003eunsigned int\u003c/span\u003e \u003cb\u003eend\u003c/b\u003e)\u003c/td\u003e     \u003ctd\u003eОбход в ширину. Возвращает путь от вершины \u003cb\u003estart\u003c/b\u003e до вершины \u003cb\u003eend\u003c/b\u003e. Если пути нет возвращает пустой \u003cspan style\u003d\"color: rgb(0,170,170);\"\u003elist\u003c/span\u003e.\u003c/td\u003e   \u003c/tr\u003e   \u003ctr\u003e     \u003cth\u003edijkstra\u003c/th\u003e     \u003ctd\u003e\u003cspan style\u003d\"color: rgb(0,170,170);\"\u003elist\u003c/span\u003e\u0026lt;\u003cspan style\u003d\"color: rgb(0,170,170);\"\u003eunsigned int\u003c/span\u003e\u0026gt; \u003cb style\u003d\"color: rgb(0,0,170);\"\u003edijkstra\u003c/b\u003e(\u003cspan style\u003d\"color: rgb(0,170,170);\"\u003eunsigned int\u003c/span\u003e \u003cb\u003estart\u003c/b\u003e, \u003cspan style\u003d\"color: rgb(0,170,170);\"\u003eunsigned int\u003c/span\u003e \u003cb\u003eend\u003c/b\u003e)\u003c/td\u003e     \u003ctd\u003eАлгоритм Дейкстры. Возвращает путь от вершины \u003cb\u003estart\u003c/b\u003e до вершины \u003cb\u003eend\u003c/b\u003e. Если пути нет возвращает пустой \u003cspan style\u003d\"color: rgb(0,170,170);\"\u003elist\u003c/span\u003e.\u003c/td\u003e   \u003c/tr\u003e \u003c/tbody\u003e\u003c/table\u003e  \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ePython 3\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eclass graph:\n    def __init__(self, v\u003d0):\n        self.colors \u003d []\n        self.len \u003d 0\n        self.lines \u003d []\n        for _ in range(v):\n            self.addvertex()\n\n    def addvector(self, a, b, w\u003d1):\n        self.lines[a].add((b, w))\n\n    def addline(self, a, b, w\u003d1):\n        self.addvector(a, b, w)\n        self.addvector(b, a, w)\n\n    def addvertex(self):\n        self.lines.append(set())\n        self.colors.append(\u0026quot;\u0026quot;)\n        self.len +\u003d 1\n\n    def __getitem__(self, item):\n        \u0026quot;\u0026quot;\u0026quot;graph[i]\u0026quot;\u0026quot;\u0026quot;\n        return self.colors[item]\n\n    def __setitem__(self, key, value):\n        \u0026quot;\u0026quot;\u0026quot;graph[i] \u003d \u0027color\u0027\u0026quot;\u0026quot;\u0026quot;\n        self.colors[key] \u003d value\n\n    def children(self, i):\n        return self.lines[i]\n\n    def dfs(self):\n        colors \u003d [0] * self.len\n        current \u003d 0\n        visited \u003d [0] * self.len\n        for i in range(self.len):\n            if not colors[i]:\n                current +\u003d 1\n                self._dfs(i, colors, current, visited)\n        return [current, colors]\n\n    def _dfs(self, i, colors, current, visited):\n        colors[i] \u003d current\n        visited[i] \u003d 1\n        for j, _ in self.children(i):\n            if not visited[j]:\n                self._dfs(j, colors, current, visited)\n        visited[i] \u003d 2\n\n    def height(self, v):\n        from collections import deque\n\n        l \u003d [0] * self.len\n        h \u003d deque([v])\n        while h:\n            c \u003d h.popleft()\n            for j, _ in self.children(c):\n                l[j] \u003d l[c] + 1\n                h.append(j)\n        return max(l)\n\n    def __len__(self):\n        return self.len\n\n    def bfs(self, start, end):\n        from collections import deque\n        pred \u003d [-1] * self.len\n        pred[start] \u003d -2\n        q \u003d deque([start])\n        while q:\n            c \u003d q.popleft()\n            if c \u003d\u003d end:\n                break\n            for v, _ in self.children(c):\n                if pred[v] \u003d\u003d -1:\n                    q.append(v)\n                    pred[v] \u003d c\n        else:\n            return []\n\n        c \u003d end\n        p \u003d [end]\n        while c !\u003d start:\n            c \u003d pred[c]\n            p.append(c)\n        return p\n\n    def dijkstra(self, start, end):\n        import heapq as h\n        nt \u003d [(0, start)]\n        pred \u003d [float(\u0026quot;inf\u0026quot;)] * self.len\n        weights \u003d [float(\u0026quot;inf\u0026quot;)] * self.len\n        weights[start] \u003d 0\n        while nt:\n            c \u003d h.heappop(nt)[1]\n            for v, w in self.children(c):\n                if weights[c] + w \u0026lt; weights[v]:\n                    weights[v] \u003d weights[c] + w\n                    h.heappush(nt, (weights[v], v))\n                    pred[v] \u003d c\n\n        if weights[end] !\u003d float(\u0026quot;inf\u0026quot;):\n            c \u003d end\n            p \u003d [end]\n            while c !\u003d start:\n                c \u003d pred[c]\n                p.append(c)\n            return p\n        else:\n            return []\n\n    def kraskal(self):\n        import heapq as h\n        r \u003d []\n        for i in range(self.len):\n            for v, w in self.lines[i]:\n                h.heappush(r, (w, i, v))\n\n        u \u003d []\n        k \u003d []\n        for i in range(self.len):\n            u.append(i)\n            k.append({i})\n        s \u003d self.len - 1\n        n \u003d graph(self.len)\n        while s:\n            c \u003d h.heappop(r)\n            if k[u[c[1]]] and k[u[c[2]]] and u[c[1]] !\u003d u[c[2]]:\n                i \u003d u[c[2]]\n                for v in k[u[c[2]]]:\n                    k[u[c[1]]].add(v)\n                    u[v] \u003d u[c[1]]\n                k[i] \u003d False\n                n.addline(c[1], c[2], c[0])\n                s -\u003d 1\n\n        return n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}