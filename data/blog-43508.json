{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1456926568,"rating":92,"authorHandle":"dumbass","modificationTimeSeconds":1456927565,"id":43508,"title":"\u003cp\u003eFaster Dijkstra on Special Graphs [Tutorial]\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eYou can read the latex formatted pdf \u003ca href\u003d\"https://www.dropbox.com/s/03wjbvhhvqcsz3c/fast-dijkstra.pdf?dl\u003d0\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003ch3\u003ePre Requisites\u003c/h3\u003e\u003cp\u003eDijkstra\u0027s algorithm\u003c/p\u003e\u003ch3\u003eMotivation Problem\u003c/h3\u003e\u003cp\u003eYou are given a weighted graph \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003c/span\u003e vertices and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eE\u003c/i\u003e\u003c/span\u003e edges. Find the shortest path from a given source \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e to all the vertices, given that all the edges have weight \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003c/span\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6b/ac/6bac178fcf500ac68b51086caba028ee357d9b8c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cspan class\u003d\"tex-span\"\u003e{\u003ci\u003eX\u003c/i\u003e, \u003ci\u003eY\u003c/i\u003e}\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e, \u003ci\u003eY\u003c/i\u003e \u0026gt;  \u003d 0\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/f3/ea/f3ea4e756cd4fbb28f6b52def4a8181d8ee68005.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch3\u003eNaive Solution\u003c/h3\u003e\u003cp\u003eMost people when given this question would solve it using Dijkstra\u0027s algorithm which can solve this efficiently in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eE\u003c/i\u003e * \u003ci\u003elogV\u003c/i\u003e)\u003c/span\u003e (Let\u0027s not take Fibonacci heap implementation into consideration now). It turns out that this solution, though it will work in most cases well under the time, can be improved further to a linear time algorithm.\u003c/p\u003e\u003cp\u003eBefore moving into the next section, try to think about how you could optimise Dijkstra\u0027s algorithm. ( \u003cstrong\u003eHint :\u003c/strong\u003e There are only two possible values of the edge weight.)\u003c/p\u003e\u003ch3\u003eOptimised Solution\u003c/h3\u003e\u003cp\u003eLet us see why we have the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogV\u003c/i\u003e)\u003c/span\u003e factor in the original Dijkstra : \u003cstrong\u003epriority queue\u003c/strong\u003e ! So, if we can just find a way to keep the queue sorted by non-decreasing distance in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e always, then we can replace the priority queue with a normal queue and find the shortest distance from source to all vertices.\u003c/p\u003e\u003cp\u003eLet us keep two different queues \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQX\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQY\u003c/i\u003e\u003c/span\u003e. Suppose we are at an arbitrary node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and we are able to reduce the distance to node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e by travelling over an edge from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e. If this travelled edge from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e has a weight \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e then push \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e to the queue \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQX\u003c/i\u003e\u003c/span\u003e, else push it on the queue \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQY\u003c/i\u003e\u003c/span\u003e. In short, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQX\u003c/i\u003e\u003c/span\u003e stores information of all nodes whose current minimum is achieved by last travelling over an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e weighted edge and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQY\u003c/i\u003e\u003c/span\u003e stores the information of nodes having last weighted edge as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eOur entire algorithm is almost the same as that of Dijkstra. One change is to use two queues as mentioned above instead of the priority queue to try and remove the log factor. Another change is that in case of Dijkstra we always take the top node as the next node, but in this algorithm we take the less distant node of the two queue heads. If we can prove that the queues are sorted, we can prove that the answer produced cannot be different from Dijkstra since we are always taking the minimum distant node for calculations and also keeping the distance queues sorted.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eClaim :\u003c/strong\u003e \u0026quot;The queues \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQX\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQY\u003c/i\u003e\u003c/span\u003e are always sorted.\u0026quot;\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProof :\u003c/strong\u003e Let us assume that the first inversion has just occurred in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQX\u003c/i\u003e\u003c/span\u003e. Let the last element be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003c/span\u003e and the second last element be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eU\u003c/i\u003e\u003c/span\u003e. So, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edist\u003c/i\u003e(\u003ci\u003eU\u003c/i\u003e)\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e \u0026gt; \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edist\u003c/i\u003e(\u003ci\u003eV\u003c/i\u003e)\u003c/span\u003e. Now, since both of them last travelled an edge with weight X, we can subtract this quantity from both the distances. Thus, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edist\u003c/i\u003e(\u003ci\u003eU\u003c/i\u003e) - \u003ci\u003eX\u003c/i\u003e \u0026gt; \u003ci\u003edist\u003c/i\u003e(\u003ci\u003eV\u003c/i\u003e) - \u003ci\u003eX\u003c/i\u003e\u003c/span\u003e. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epre\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e) \u003d \u003ci\u003edist\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e) - \u003ci\u003eX\u003c/i\u003e\u003c/span\u003e. Thus, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epre\u003c/i\u003e(\u003ci\u003eU\u003c/i\u003e) \u0026gt; \u003ci\u003epre\u003c/i\u003e(\u003ci\u003eV\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epre\u003c/i\u003e(\u003ci\u003eU\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epre\u003c/i\u003e(\u003ci\u003eV\u003c/i\u003e)\u003c/span\u003e must have come from one of the two queues. They cannot come from the same queue, since we assumed the two queues were always sorted before this moment of time. So they must be from two different queues. But according to our algorithm, we take the minimum of the head of the two queues and so if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epre\u003c/i\u003e(\u003ci\u003eU\u003c/i\u003e)\u003c/span\u003e was taken before \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epre\u003c/i\u003e(\u003ci\u003eV\u003c/i\u003e)\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epre\u003c/i\u003e(\u003ci\u003eU\u003c/i\u003e) \u0026lt;  \u003d \u003ci\u003epre\u003c/i\u003e(\u003ci\u003eV\u003c/i\u003e)\u003c/span\u003e. This contradiction proves that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQX\u003c/i\u003e\u003c/span\u003e is always sorted. We can use a similar argument for the other queue.\u003c/p\u003e\u003cp\u003eOnce the claim is proved, the whole algorithm should look pretty trivial from implementation point of view. Since we have removed the log factor, this runs in linear time. We can also extend this to a bigger number of distinct edges and use a set for finding minima. You can refer to the pseudocode in the next section in case you have implementation doubts.\u003c/p\u003e\u003ch3\u003ePseudo Code\u003c/h3\u003e \u003cpre\u003e\u003ccode\u003equeue QX , QY\npush source S to QX\nwhile one of the two queues is not empty:\n    u \u003d pop minimal distant node among the two queue heads\n    for all edges e of form (u,v):\n        if dist(v) \u0026gt; dist(u) + cost(e):\n            dist(v) \u003d dist(u) + cost(e);\n            if cost(e) \u003d\u003d X:\n                QX.push(dist(v),v);\n            else:\n                QY.push(dist(v),v);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhile finding the minimal distant node, you need to check if anyone of the queue is empty to avoid null pointer errors. Otherwise, everything else is same as Dijkstra when it comes to implementation.\u003c/p\u003e\u003ch3\u003eProblems to practice\u003c/h3\u003e\u003cp\u003eI don\u0027t have any specific problems for this, but all problems that can be solved by 0-1 BFS can also be solved by this. Refer \u003ca href\u003d\"//codeforces.com/blog/entry/22276\"\u003ehere\u003c/a\u003e for some questions.\u003c/p\u003e\u003ch3\u003eConclusion\u003c/h3\u003e\u003cp\u003eI hope you learnt something new! Feel free to point out mistakes. There is a rare chance that you would need this algorithm anytime, but it might turn out useful in optimisation problems. This post was largely inspired by a \u003ca href\u003d\"//codeforces.com/blog/entry/22276?#comment-268883\"\u003ecomment\u003c/a\u003e on my \u003ca href\u003d\"//codeforces.com/blog/entry/22276\"\u003e0-1 BFS tutorial\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eHappy Coding!\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e","tags":["dijkstra","fast algorithm","tutorial"]}}