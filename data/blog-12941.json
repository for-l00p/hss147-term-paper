{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1404484131,"rating":0,"authorHandle":"adiko2008","modificationTimeSeconds":1478937114,"id":12941,"title":"\u003cp\u003eРазбор финального дня (04.07.2014)\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eРазбор\u003c/h2\u003e\u003cp\u003e\u003ca href\u003d\"https://docs.google.com/document/d/1bTHu5_BDlclCqIM4TzL59MNnVkRssUF_racfU5tVWWU/edit\"\u003eразборчик.\u003c/a\u003e\u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003ch2\u003eКомментарий\u003c/h2\u003e\u003ch3\u003eЗадача G\u003c/h3\u003e\u003cp\u003eСовсем не обязательно вспоминать какие-то обходы. Достаточно написать следующий код.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint ans \u003d 0;\nfor (i \u003d 0; i \u0026lt; n; i++)\n{\n    int count \u003d 1, q \u003d i;\n    while (a[q] !\u003d -1)\n    {\n        q \u003d a[q];\n        count++;\n    }\n    ans \u003d max(ans, count);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eФактически, это обход графа. Но есть существенная разница: при попытке запустить dfs или bfs программа будет перебирать все вершины в поисках начальника работника, в то время как условие гарантирует, что он всего один и при этом мы можем попасть к нему напрямую без всякого перебора, что и сделано в данном коде.\u003cbr /\u003e\u003c/p\u003e\u003ch3\u003eЗадача H\u003c/h3\u003e\u003cp\u003eРешается бинарным поиском. Самое тяжёлое — научиться быстро определять, сколько будет окрашено клеток через k секунд. (Эта функция неубывающая, так что бинарный поиск применить можно.) Подсчитать это можно, например, через формулу включения-исключения за O(1).\u003cbr /\u003e\u003c/p\u003e\u003ch3\u003eЗадача J\u003c/h3\u003e\u003cp\u003eПросто красивая задача на идею. Подробнее \u003ca href\u003d\"http://codeforces.ru/blog/entry/5934\"\u003eздесь\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e","tags":[]}}