{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1490967659,"rating":-2,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1490967659,"id":51345,"title":"\u003cp\u003eSolutions to Codeforces Beta Round #32, A, B, C, D\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA. Reconnaissance\u003c/p\u003e\u003cp\u003eThe solution to this problem is straightforward. As it is stressed that (i,j) and (j,i) are different, we can adopt a nested-2-loop to enumerate all the feasible combination of i and j, and check whether the difference of height satisfy the condition or not. \u003c/p\u003e\u003cp\u003eB. Borze\u003c/p\u003e\u003cp\u003eThe problem is simplified since it is guaranteed that the given sequence is valid Borze code. We can enumerate the letters from the first one, and implement the decoding according to the following rules:\u003c/p\u003e\u003cp\u003eRule 1): whenever we meet a \u0027.\u0027, decode it as \u0026quot;0\u0026quot; and move to the next letter;\u003c/p\u003e\u003cp\u003eRule 2): whenever we meet a \u0027-\u0027 and the next one is \u0027-\u0027 as well, decode it as \u0026quot;2\u0026quot; and skip the next letter and move directly to the one following it;\u003c/p\u003e\u003cp\u003eRule 3): whenever we meet a \u0027-\u0027 and the next one is \u0027.\u0027 as well, decode it as \u0026quot;1\u0026quot; and skip the next letter and move directly to the one following it;\u003c/p\u003e\u003cp\u003eC. Flea\u003c/p\u003e\u003cp\u003eNote that at first the flea is at the center of the cell, and no matter how it jumps later, it should always stay at the center of some cell. Therefore, although there are n*m cells, the board can in fact be viewed as a grid with (n-1)*(m-1) points and the flea can only jump from one single point to the other ones. Suppose that the flea first starts from point (1,1), then it can jump to point ( 1+(m-1)/s*s, 1) along the parallel axis, while jumping to point ( 1, 1+(n-1)/s*s ) along the perpendicular axis (note that only \u0026quot;integer division\u0026quot; is included here, i.e., 5/2\u003d2 but not 2.5). Therefore, we have found out ( (m-1)/s+1 )*( (n-1)/s+1 ) points which are completely equivalent to each other. Note that (m-1)/s*s\u0026lt;(m-1) might hold since we adopt \u0026quot;integer division\u0026quot;, and the different is just (m-1)%s. This implies that if the flea starts from points (2,1), (3,1),...( 1+(m-1)%s, 1 ), it can also cover ( (m-1)/s+1 )*( (n-1)/s+1 ) points. Similarly, it leads to the same result if it starts from points (1,2), (1,3), ... ( 1+(n-1)%s, 1). Therefore, there are totally ( (m-1)/s+1 )*( (n-1)/s+1 ) * ( 1+(n-1)%s )*( 1+(m-1)%s ) points which are equivalent, and this is just the answer.\u003c/p\u003e\u003cp\u003eD. Constellation\u003c/p\u003e\u003cp\u003eAt first sight, it seems that we should find out all the reasonable constellation and then sort them as the problem asks, while taking out the k-th one as the answer. However, we soonly realize that the number might be too large to store. In fact, we can just enumerate the constellation one by one in the order requested by the problem, by adopting a nested-3-loop. At first, we enumerate every feasible x, which will not exceed max(n,m) (in fact it might be half of max(n,m), but later you will find that this constant 1/2 is not important as ususally done in the analysis of computational complexity), then for the second loop, we enumerate indices i from 1 to n (or 0 to n-1), and the third loop deals with j from 1 to m. Whenever we find a reasonable constellation, we increase the \u0026quot;counter\u0026quot; by 1, and when the k-th constellation is reached, we store the positions of the five stars, and give the final answer, while outputing \u0026quot;-1\u0026quot; if the counter is still less than k after the last reasonable constellation is counted.\u003c/p\u003e\u003c/div\u003e","tags":[]}}