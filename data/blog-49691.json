{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1484092118,"rating":243,"authorHandle":"linkret","modificationTimeSeconds":1484104495,"id":49691,"title":"\u003cp\u003eIncredibly beautiful DP optimization from N^3 to N log^2 N\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThe task I want to discuss is \u003ca href\u003d\"/contest/739/problem/E\" title\u003d\"Codeforces Round 381 (Div. 1)\"\u003e739E - Gosha is hunting\u003c/a\u003e. While the official solution is a greedy algorithm sped up enough to pass the time limit, I recently came upon another solution. The main idea is to speed up the obvious dp approach, where we define dp[i][x][y] as the maximum expected number of caught pokemon in the prefix of first i pokemon, if we throw at most x A-pokeballs and at most y B-pokeballs. The computation of each state is O(1), so the complexity of this solution is O(n^3). There is no obvious way to speed up this dp, because the transition of states is already done in O(1), and that\u0027s where dp optimization techniques usually cut the complexity. It\u0027s also useless to use some other definition of dp, since they will all take O(n^3) time to compute. But what we can do is to use the same trick used to solve the task Alien, from IOI 2016, or \u003ca href\u003d\"/contest/674/problem/C\" title\u003d\"Codeforces Round 351 (VK Cup 2016 Round 3, Div. 1 Edition)\"\u003e674C - Levels and Regions\u003c/a\u003e in O(n log k) as \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Radewoosh\" title\u003d\"International Grandmaster Radewoosh\"\u003eRadewoosh\u003c/a\u003e had described on his blog, and completely kick out a dimension from our dp!\u003c/p\u003e\u003ch2\u003eKicking out the 3rd dimension:\u003c/h2\u003e\u003cp\u003eBy kicking out the 3rd dimension, we\u0027re left with dp[i][x]. This is now defined as the highest expected number of caught pokemon in the prefix of i pokemon if we throw at most x A-pokeballs and any number of B-pokeballs. Obviously this will always use the maximum amount of B-pokeballs. But what\u0027s really cool is that we can actually try to simulate this last dimension: we define some C as a \u0026quot;cost\u0026quot; we have to pay every time we want to take a B-pokeball. This is essentially adding the functions f(x) \u003d dp[n][a][x] and g(x) \u003d -Cx. The cool thing is, f(x) is concave, i.e. f(x+1) — f(x) \u0026lt;\u003d f(x) — f(x-1). This is intuitive because whenever we get a new B-pokeball, we will always throw it at the best possible place. So if we get more and more of them, our expected number of caught pokemon will increase more and more slowly. And why is it useful that f(x) is convex? Well, h(x) \u003d f(x) + g(x) has a non-trivial maximum, that we can find. And if h(x) is maximal, it means that for this C, it\u0027s optimal to throw x B-pokeballs. Now it\u0027s pretty obvious that we can do a binary search on this C to find one such that it\u0027s optimal to throw exactly b B-pokeballs, as given in the input. Inside our binary search we just do the O(n^2) algorithm, and when we finish, do a reconstruction of our solution to see how many B-pokeballs we\u0027ve used, and use that information to continue binary searching. This gives us complexity O(n^2 log n), which is good enough to get AC. This trick was shown to us at our winter camp, which ended yesterday.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode:\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nconst int maxn \u003d 2020;\nconst double eps \u003d 1e-8;\nint n, a, b, opt[maxn][maxn];\ndouble dp[maxn][maxn], pa[maxn], pb[maxn], pab[maxn];\n\nint solve(double mid){\n    for(int i \u003d 1; i \u0026lt;\u003d n; i++){\n        for(int j \u003d 0; j \u0026lt;\u003d a; j++){\n            double \u0026amp;d \u003d dp[i][j];\n            int \u0026amp;o \u003d opt[i][j];\n\n            d \u003d dp[i - 1][j];\n            o \u003d 0;\n\n            if(j \u0026amp;\u0026amp; d \u0026lt; dp[i - 1][j - 1] + pa[i]){\n                d \u003d dp[i - 1][j - 1] + pa[i];\n                o \u003d 1;\n            }\n\n            if(d \u0026lt; dp[i - 1][j] + pb[i] - mid){\n                d \u003d dp[i - 1][j] + pb[i] - mid;\n                o \u003d 2;\n            }\n\n            if(j \u0026amp;\u0026amp; d \u0026lt; dp[i - 1][j - 1] + pab[i] - mid){\n                d \u003d dp[i - 1][j - 1] + pab[i] - mid;\n                o \u003d 3;\n            }\n        }\n    }\n\n    int ret \u003d 0, la \u003d a;\n\n    for(int i \u003d n; i \u0026gt;\u003d 1; i--){\n        if(opt[i][la] \u0026gt; 1)\n            ret++;\n\n        if(opt[i][la] \u0026amp; 1)\n            la--;\n    }\n\n    return ret;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\n    for(int i \u003d 1; i \u0026lt;\u003d n; i++)\n        cin \u0026gt;\u0026gt; pa[i];\n\n    for(int i \u003d 1; i \u0026lt;\u003d n; i++)\n        cin \u0026gt;\u0026gt; pb[i];\n\n    for(int i \u003d 1; i \u0026lt;\u003d n; i++)\n        pab[i] \u003d pa[i] + pb[i] - pa[i] * pb[i];\n\n    double lo \u003d 0, hi \u003d 1, mid;\n\n    for(int it \u003d 0; it \u0026lt; 50; it++){\n        mid \u003d (lo + hi) / 2;\n\n        if(solve(mid) \u0026gt; b)\n            lo \u003d mid;\n        else\n            hi \u003d mid;\n    }\n\n    int ans \u003d solve(hi);\n\n    cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(10) \u0026lt;\u0026lt; dp[n][a] + hi * b \u0026lt;\u0026lt; endl;\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003eKicking out another dimension?\u003c/h2\u003e\u003cp\u003eBut is this all? Can we do better? Why can\u0027t we kick out the 2nd dimension in the same way we kicked out the first one? It turns out that in this task, we actually can! We just define D as the cost that we deduct each time we use an A-pokeball, and then using binary search find the C for which we use exactly enough B-pokeballs, and reconstruct the solution to see if we\u0027ve used too many or too little A-pokeballs. The function is again concave, so the same trick works! Using this I was able to get AC in O(n log^2 n), which is pretty amazing for a Div1 E task with N \u0026lt;\u003d 2000. My friends \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/vilim_l\" title\u003d\"Candidate Master vilim_l\"\u003evilim_l\u003c/a\u003e, \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/jklepec\" title\u003d\"Candidate Master jklepec\"\u003ejklepec\u003c/a\u003e, \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/lukatiger\" title\u003d\"Expert lukatiger\"\u003elukatiger\u003c/a\u003e and me are still amazed that this can be done!\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode:\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\ntypedef pair\u0026lt;int, int\u0026gt; pii;\n\nconst int maxn \u003d 2020;\nconst double eps \u003d 1e-8;\nint n, a, b, opt[maxn];\ndouble dp[maxn], pa[maxn], pb[maxn], pab[maxn];\n\npii solve(double \u0026amp;D, double \u0026amp;C){\n    for(int i \u003d 1; i \u0026lt;\u003d n; i++){\n        double \u0026amp;d \u003d dp[i];\n        int \u0026amp;o \u003d opt[i];\n\n        d \u003d dp[i - 1];\n        o \u003d 0;\n\n        if(d \u0026lt; dp[i - 1] + pa[i] - D){\n            d \u003d dp[i - 1] + pa[i] - D;\n            o \u003d 1;\n        }\n\n        if(d \u0026lt; dp[i - 1] + pb[i] - C){\n            d \u003d dp[i - 1] + pb[i] - C;\n            o \u003d 2;\n        }\n\n        if(d \u0026lt; dp[i - 1] + pab[i] - C - D){\n            d \u003d dp[i - 1] + pab[i] - C - D;\n            o \u003d 3;\n        }\n    }\n\n    pii ret \u003d pii(0, 0);\n\n    for(int i \u003d 1; i \u0026lt;\u003d n; i++){\n        if(opt[i] \u0026gt; 1)\n            ret.second++;\n\n        if(opt[i] \u0026amp; 1)\n            ret.first++;\n    }\n\n    return ret;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\n    for(int i \u003d 1; i \u0026lt;\u003d n; i++)\n        cin \u0026gt;\u0026gt; pa[i];\n\n    for(int i \u003d 1; i \u0026lt;\u003d n; i++)\n        cin \u0026gt;\u0026gt; pb[i];\n\n    for(int i \u003d 1; i \u0026lt;\u003d n; i++)\n        pab[i] \u003d pa[i] + pb[i] - pa[i] * pb[i];\n\n    double lo \u003d 0, hi \u003d 1, mid, lo2, hi2, mid2;\n\n    for(int it2 \u003d 0; it2 \u0026lt; 50; it2++){\n        mid \u003d (lo + hi) / 2;\n\n        lo2 \u003d 0, hi2 \u003d 1, mid2;\n\n        for(int it \u003d 0; it \u0026lt; 50; it++){\n            mid2 \u003d (lo2 + hi2) / 2;\n\n            if(solve(mid, mid2).second \u0026gt; b)\n                lo2 \u003d mid2;\n            else\n                hi2 \u003d mid2;\n        }\n\n        if(solve(mid, hi2).first \u0026gt; a)\n            lo \u003d mid;\n        else\n            hi \u003d mid;\n    }\n\n    solve(hi, hi2);\n\n    cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(10) \u0026lt;\u0026lt; dp[n] + hi2 * b + hi * a \u0026lt;\u0026lt; endl;\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["dynamic programming","optimization","analysis of problem","prevara"]}}