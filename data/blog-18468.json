{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1433962714,"rating":7,"authorHandle":"black_bird","modificationTimeSeconds":1433962714,"id":18468,"title":"\u003cp\u003e0-1 Knapsack: return weight and maximum value in C++\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eWe know in 0-1 Knapsack problem we get the maximum benefits from some items with a limited capacity. Example:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e4 10 // 5 items, 10 capacity\n1 120 // weight cost_value\n4 280\n3 150\n4 200\nAns: 600\nTotal Weight: 9\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut my question is, I want the total weight and benefit at a time. How is this possible? And what will be the change of my code? Please suggest me with my own code.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\n#define MAX_N 100\n#define MAX_W 1000\nint n;\nint dp[MAX_N+1][MAX_W+1];\nint weight[MAX_N+1];\nint cost[MAX_N+1];\nint CAP;\nint func(int i,int w)\n{\n    if(i\u003d\u003dn+1) return 0;\n    if(dp[i][w]!\u003d-1) return dp[i][w];\n    int profit1\u003d0,profit2\u003d0;\n    if(w+weight[i]\u0026lt;\u003dCAP)\n        profit1\u003dcost[i]+func(i+1,w+weight[i]);\n\n    profit2\u003dfunc(i+1,w);\n    dp[i][w]\u003dmax(profit1,profit2);\n    return dp[i][w];\n}\nint main()\n{\n\n    //freopen(\u0026quot;in\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n    memset(dp,-1,sizeof(dp));\n    scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;CAP);\n    for(int i\u003d1; i\u0026lt;\u003dn; i++)\n    {\n        scanf(\u0026quot;%d %d\u0026quot;,\u0026amp;weight[i],\u0026amp;cost[i]);\n    }\n    printf(\u0026quot;%d\\n\u0026quot;,func(1,0));\n\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}