{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1433856989,"rating":33,"authorHandle":"Zlobober","modificationTimeSeconds":1433870745,"id":18431,"title":"\u003cp\u003eCheckers with testlib.h\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eIntroduction\u003c/h2\u003e\u003cp\u003eChecker is a program that should be written when task allows more than one correct solution. Although it seems that it is very easy to write checker, there are lots of important technical details that are easy to forget if you don\u0027t use a special library like testlib.h.\u003c/p\u003e\u003cp\u003eA common convention is that a checker should be a program taking three command-line arguments: the testdata filename, the participant output filename and the jury answer filename. Checker should read the contents of the input, output and answer, decide whether participant answer is correct (and optimal being compared to the jury\u0027s answer if there can be unoptimal answer in this task) and return one of several pre-defined verdicts:\u003c/p\u003e \u003ctable\u003e   \u003cthead\u003e     \u003ctr\u003e       \u003cth\u003eVerdict \u003c/th\u003e       \u003cth\u003etestlib macro \u003c/th\u003e       \u003cth\u003emeaning \u003c/th\u003e     \u003c/tr\u003e   \u003c/thead\u003e   \u003ctbody\u003e     \u003ctr\u003e       \u003ctd\u003eOk \u003c/td\u003e       \u003ctd\u003e\u003ccode\u003e_ok\u003c/code\u003e \u003c/td\u003e       \u003ctd\u003eThe output is correct, follows the output format and represents an optimal answer (if applicable in this problem). \u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003eWrong Answer \u003c/td\u003e       \u003ctd\u003e\u003ccode\u003e_wa\u003c/code\u003e \u003c/td\u003e       \u003ctd\u003eThe output is wrong or incorrect. \u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003ePresentation Error \u003c/td\u003e       \u003ctd\u003e\u003ccode\u003e_pe\u003c/code\u003e \u003c/td\u003e       \u003ctd\u003eThe output doesn\u0027t follow output format specification of the task. Although, on Codeforces this verdict is being replaced by Wrong Answer since it\u0027s usually hard to distinguish Presentation Error and Wrong Answer \u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003ePartially Correct \u003c/td\u003e       \u003ctd\u003e\u003ccode\u003e_pc(score)\u003c/code\u003e \u003c/td\u003e       \u003ctd\u003eIf there is a partial scoring in the task, this verdict should be used in situation when solution is partially correct or to give solution some number of points. Here \u003ccode\u003escore\u003c/code\u003e should be an integer between 0 and 200 where 0 represents the lowest mark (no points) and 200 represents the highest mark (maximum possible number of points) \u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003eFail \u003c/td\u003e       \u003ctd\u003e\u003ccode\u003e_fail\u003c/code\u003e \u003c/td\u003e       \u003ctd\u003eThis verdict means that checker has encountered a critical internal error or that the jury\u0027s answer is incorrect or that contestant found the more optimal answer than jury. This verdict means that something wrong has happened and it requires a special investigation from jury. \u003c/td\u003e     \u003c/tr\u003e   \u003c/tbody\u003e \u003c/table\u003e\u003cp\u003eUsually the verdict returned by checker is indicated by the return code of its executable, but it may possibly be transfered to the testing system by many other ways: by creating a special xml-file with checker outcome, by writing to stdout or somehow else. When using testlib.h for writing a checker all those system-dependent ways are combined in a single expression \u003ccode\u003equitf(VERDICT, \u0026quot;comment\u0026quot;, ...)\u003c/code\u003e.\u003c/p\u003e\u003ch2\u003eSimplest checker example\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eProblem statement\u003c/strong\u003e: You are given two integers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e - 1000 ≤ \u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e ≤ 1000\u003c/span\u003e). Find their sum and output it.\u003c/p\u003e\u003cp\u003eLet\u0027s write a checker for this problem. It will be very simple:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026quot;testlib.h\u0026quot;\n\nint main(int argc, char* argv[]) {\n    // This command initializes checker environment.\n    registerTestlibCmd(argc, argv);\n    // Now there are three global variables specifying testlib streams:\n    // inf - stream with the testdata.\n    // ouf - stream with the contestant output.\n    // ans - stream with the jury answer.\n    // All those streams provide the similar interface for reading data.\n\n    // This function reads a single integer from the participant output that \n    // should be between -2000 and 2000. If it doesn\u0027t belong to the specified\n    // range, checker finishes with verdict _pe and comment saying that [sum of numbers]\n    // is outside of the specified range.\n    int pans \u003d ouf.readInt(-2000, 2000, \u0026quot;sum of numbers\u0026quot;);\n    \n    // This function reads a single integer from the jury output. Here we suppose\n    // that jury\u0027s answer is correct and we do not need to additionally verify it.\n    int jans \u003d ans.readInt(); // We suppose that jury\u0027s answer is correct\n    \n    if (pans \u003d\u003d jans)\n        quitf(_ok, \u0026quot;The sum is correct.\u0026quot;); // This finishes checker with verdit OK.\n    else\n        // quitf handles a comment like printf, i. e. you may use specifiers like\n        // %d, %s etc in the comment.\n        quitf(_wa, \u0026quot;The sum is wrong: expected \u003d %d, found \u003d %d\u0026quot;, jans, pans);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eAvailable methods\u003c/h2\u003e\u003cp\u003eThere are lots of methods useful for writing checkers.\u003c/p\u003e \u003ctable\u003e   \u003cthead\u003e     \u003ctr\u003e       \u003cth\u003eMethod \u003c/th\u003e       \u003cth\u003eDescription\u003c/th\u003e     \u003c/tr\u003e   \u003c/thead\u003e   \u003ctbody\u003e     \u003ctr\u003e       \u003ctd\u003e\u003ccode\u003estream.readXXX\u003c/code\u003e \u003c/td\u003e       \u003ctd\u003eAll methods of form readXXX (like readInt, readLong, readDouble, readToken etc) are common for all testlib uses: checkers, validators and interactors. TODO: put all such methods on the separate page. \u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003e\u003ccode\u003evoid quit(TResult verdict, string message);\u003c/code\u003e \u003cbr /\u003e \u003ccode\u003evoid quit(TResult verdict, const char* message);\u003c/code\u003e \u003cbr /\u003e \u003ccode\u003evoid quitf(TResult verdict, const char* message, ...);\u003c/code\u003e \u003c/td\u003e       \u003ctd\u003eFinishes the checker with a given verdict and comment. \u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003e\u003ccode\u003evoid quitif(bool condition, TResult verdict, const char* message, ...);\u003c/code\u003e \u003c/td\u003e       \u003ctd\u003eif condition is true then performs quitf(verdict, message, ...) \u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003e\u003ccode\u003evoid ensuref(bool condition, const char* message, ...);\u003c/code\u003e \u003c/td\u003e       \u003ctd\u003eAn equivalent of assert. Checks that condition is true, otherwise finishes with _fail verdict. Useful for debugging checkers.\u003c/td\u003e     \u003c/tr\u003e   \u003c/tbody\u003e \u003c/table\u003e\u003cp\u003eTODO: finish this list.\u003c/p\u003e\u003ch2\u003ereadAns paradigm\u003c/h2\u003e\u003cp\u003eSuppose you have a task that asks contestant to find a complex composite answer that is not just a single number. Example:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem statement\u003c/strong\u003e You are given a connected undirected weighted graph witn \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e vertices and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e edges. Find a simple path between vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e and vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e ≠ \u003ci\u003et\u003c/i\u003e\u003c/span\u003e) of maximum weight and output it. Samples (input and output format is clarified in square brackets):\u003c/p\u003e \u003ctable\u003e   \u003cthead\u003e     \u003ctr\u003e       \u003cth\u003eSample input \u003c/th\u003e       \u003cth\u003eSample output \u003c/th\u003e     \u003c/tr\u003e   \u003c/thead\u003e   \u003ctbody\u003e     \u003ctr\u003e       \u003ctd\u003e\u003cdiv style\u003d\"font-family: monospace;\"\u003e4 5 [n, m] \u003cbr /\u003e1 2 4 [edges]\u003cbr /\u003e2 4 2\u003cbr /\u003e1 4 4\u003cbr /\u003e1 3 5\u003cbr /\u003e3 4 3\u003cbr /\u003e1 4 [s, t]\u003c/div\u003e \u003c/td\u003e       \u003ctd\u003e\u003cdiv style\u003d\"font-family: monospace;\"\u003e3 [number of vertices in path]\u003cbr /\u003e1 3 4 [path]\u003c/div\u003e \u003c/td\u003e     \u003c/tr\u003e   \u003c/tbody\u003e \u003c/table\u003e\u003cp\u003eHere is an example of \u003cstrong\u003ebad\u003c/strong\u003e checker implementation for this task.\u003c/p\u003e\u003ch3\u003eBad checker implementation\u003c/h3\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026quot;testlib.h\u0026quot;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;vector\u0026gt;\nusing namespace std;\n\nmap\u0026lt;pair\u0026lt;int, int\u0026gt;, int\u0026gt; edges;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int n \u003d inf.readInt(); // no need to additionally call readSpace() or readEoln() since\n    int m \u003d inf.readInt(); // there is no need to validate input file in the checker\n    for (int i \u003d 0; i \u0026lt; m; i++) {\n        int a \u003d inf.readInt();\n        int b \u003d inf.readInt();\n        int w \u003d inf.readInt();\n        edges[make_pair(a, b)] \u003d edges[make_pair(b, a)] \u003d w;\n    }\n    int s \u003d inf.readInt();\n    int t \u003d inf.readInt();\n\n    // reading jury answer\n    int jvalue \u003d 0;\n    vector\u0026lt;int\u0026gt; jpath;\n    int jlen \u003d ans.readInt();\n    for (int i \u003d 0; i \u0026lt; jlen; i++) {\n        jpath.push_back(ans.readInt());\n    }\n    for (int i \u003d 0; i \u0026lt; jlen - 1; i++) {\n        jvalue +\u003d edges[make_pair(jpath[i], jpath[i + 1])];\n    }\n    \n    // reading participant answer\n    int pvalue \u003d 0;\n    vector\u0026lt;int\u0026gt; ppath;\n    vector\u0026lt;bool\u0026gt; used(n, false);\n    int plen \u003d ouf.readInt(2, n, \u0026quot;number of vertices\u0026quot;); // path should at least contain s and t\n    for (int i \u003d 0; i \u0026lt; plen; i++) {\n        int v \u003d ouf.readInt(1, n, format(\u0026quot;path[%d]\u0026quot;, i + 1).c_str());\n        if (used[v - 1]) // checking that no vertex is used twice\n            quitf(_wa, \u0026quot;vertex %d was used twice\u0026quot;, v);\n        used[v - 1] \u003d true;\n        ppath.push_back(v);\n    }\n    // checking that path is actually between s and t\n    if (ppath.front() !\u003d s) \n        quitf(_wa, \u0026quot;path doesn\u0027t start in s: expected s \u003d %d, found %d\u0026quot;, s, ppath.front());\n    if (ppath.back() !\u003d t)\n        quitf(_wa, \u0026quot;path doesn\u0027t finish in t: expected t \u003d %d, found %d\u0026quot;, t, ppath.back());\n    // checking that each pair of adjacent vertices in the path is indeed connected by an edge\n    for (int i \u003d 0; i \u0026lt; plen - 1; i++) {\n        if (edges.find(make_pair(ppath[i], ppath[i + 1])) \u003d\u003d edges.end())\n            quitf(_wa, \u0026quot;there is no edge (%d, %d) in the graph\u0026quot;, ppath[i], ppath[i + 1]);\n        pvalue +\u003d edges[make_pair(ppath[i], ppath[i + 1])];\n    }\n    \n    if (jvalue !\u003d pvalue)\n        quitf(_wa, \u0026quot;jury has answer %d, participant has answer %d\u0026quot;, jvalue, pvalue);\n    else\n        quitf(_ok, \u0026quot;answer \u003d %d\u0026quot;, pvalue);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHere are the main two issues that appear in this checker.\u003c/p\u003e \u003col\u003e   \u003cli\u003eIt believes that the jury\u0027s answer is absolutely correct. In case when jury\u0027s answer is unoptimal and contestant have really found the better answer, he will get the verdict WA that is not fair. There is a special verdict Fail exactly for this situation.\u003c/li\u003e   \u003cli\u003eIt contains the duplicating code for extracting the answer value for jury and contestant. In this case extracting the value is just one \u0026quot;for\u0026quot; cycle but for a harder task it may be a very complicated subroutine, and as usual, using the duplicated code makes twice harder to fix it, rewrite it or change it when output format changes.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eIn fact, reading an answer value is a subroutine that works exactly the same for contestant and jury. That\u0027s why it is usually being put into a separate function receiving the input stream as a parameter.\u003c/p\u003e\u003ch3\u003eGood checker implementation\u003c/h3\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026quot;testlib.h\u0026quot;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;vector\u0026gt;\nusing namespace std;\n\nmap\u0026lt;pair\u0026lt;int, int\u0026gt;, int\u0026gt; edges;\nint n, m, s, t;\n\n// This function receives stream as an argument, reads an answer from it,\n// checks its correctness (i. e. that it is indeed a correct path from s to t in the graph),\n// calculates its value and returns it. If the path is incorrect, it stops the execution\n// with _wa outcome if stream \u003d ouf (contestant) or with _fail outcome if stream \u003d ans (jury).\nint readAns(InStream\u0026amp; stream) {\n// reading participant answer\n    int value \u003d 0;\n    vector\u0026lt;int\u0026gt; path;\n    vector\u0026lt;bool\u0026gt; used(n, false);\n    int len \u003d stream.readInt(2, n, \u0026quot;number of vertices\u0026quot;); // path should at least contain s and t\n    for (int i \u003d 0; i \u0026lt; len; i++) {\n        int v \u003d stream.readInt(1, n, format(\u0026quot;path[%d]\u0026quot;, i + 1).c_str());\n        if (used[v - 1]) { // checking that no vertex is used twice\n            // stream.quitf works as quitf but it modifies the verdict according\n            // to what stream it is being invoked from. If stream \u003d\u003d ouf then\n            // it works exactly like quitf, otherwise if stream \u003d\u003d ans then\n            // any verdict will work like _fail (because it\u0027s bad when jury\u0027s answer is incorrect)\n            stream.quitf(_wa, \u0026quot;vertex %d was used twice\u0026quot;, v);\n        }\n        used[v - 1] \u003d true;\n        path.push_back(v);\n    }\n    // checking that path is actually between s and t\n    if (path.front() !\u003d s) \n        stream.quitf(_wa, \u0026quot;path doesn\u0027t start in s: expected s \u003d %d, found %d\u0026quot;, s, path.front());\n    if (path.back() !\u003d t)\n        stream.quitf(_wa, \u0026quot;path doesn\u0027t finish in t: expected t \u003d %d, found %d\u0026quot;, t, path.back());\n    // checking that each pair of adjacent vertices in the path is indeed connected by an edge\n    for (int i \u003d 0; i \u0026lt; len - 1; i++) {\n        if (edges.find(make_pair(path[i], path[i + 1])) \u003d\u003d edges.end())\n            stream.quitf(_wa, \u0026quot;there is no edge (%d, %d) in the graph\u0026quot;, path[i], path[i + 1]);\n        value +\u003d edges[make_pair(path[i], path[i + 1])];\n    }\n    return value;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    n \u003d inf.readInt(); // no need to additionally call readSpace() or readEoln() since\n    m \u003d inf.readInt(); // there is no need to validate input file in the checker\n    for (int i \u003d 0; i \u0026lt; m; i++) {\n        int a \u003d inf.readInt();\n        int b \u003d inf.readInt();\n        int w \u003d inf.readInt();\n        edges[make_pair(a, b)] \u003d edges[make_pair(b, a)] \u003d w;\n    }\n    int s \u003d inf.readInt();\n    int t \u003d inf.readInt();\n\n    int jans \u003d readAns(ans);\n    int pans \u003d readAns(ouf);\n    if (jans \u0026gt; pans)\n        quitf(_wa, \u0026quot;jury has the better answer: jans \u003d %d, pans \u003d %d\\n\u0026quot;, jans, pans);\n    else if (jans \u003d\u003d pans)\n        quitf(_ok, \u0026quot;answer \u003d %d\\n\u0026quot;, pans);\n    else // (jans \u0026lt; pans)\n        quitf(_fail, \u0026quot;:( participant has the better answer: jans \u003d %d, pans \u003d %d\\n\u0026quot;, jans, pans);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNotice that by using this paradigm we also check the jury answer for being correct. Checkers written in such form are usually shorter and easier to understand and fix. It is also applicable when task output is NO/(YES+certificate).\u003c/p\u003e\u003ch2\u003eNotes, advices and common mistakes\u003c/h2\u003e \u003cul\u003e   \u003cli\u003eUse readAns paradigm. It really makes easier to understand and work with your checker.\u003c/li\u003e   \u003cli\u003eAlways use optional arguments for methods like readInt(), readLong() etc. If you forget to check range for some variable, your checker may work incorrectly or even face runtime-error that will result in Check Failed in testing system.\u003c/li\u003e \u003c/ul\u003e\u003ch3\u003eBad:\u003c/h3\u003e \u003cpre\u003e\u003ccode\u003e// ....\nint k \u003d ouf.readInt();\nvector\u0026lt;int\u0026gt; lst;\nfor (int i \u003d 0; i \u0026lt; k; i++)       // This will behave similarly for k \u003d 0 as well as for k \u003d -5.\n    lst.push_back(ouf.readInt()); // But we don\u0027t want to accept list of length -5, don\u0027t we?\n// ....\nint pos \u003d ouf.readInt();\nint x \u003d A[pos]; // 100% place for runtime-error. There will surely be a contestant who will output\n                // -42, 2147483456 or some other garbage instead of correct value.\n// ....\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eGood:\u003c/h3\u003e \u003cpre\u003e\u003ccode\u003e// ....\nint k \u003d ouf.readInt(0, n); // Now negative values of k will cause PE.\nvector\u0026lt;int\u0026gt; lst;\nfor (int i \u003d 0; i \u0026lt; k; i++)\n    lst.push_back(ouf.readInt());\n// ....\nint pos \u003d ouf.readInt(0, (int)A.size() - 1); // That\u0027s how we prevent index out of range.\nint x \u003d A[pos]; \n// ....\n\u003c/code\u003e\u003c/pre\u003e \u003cul\u003e   \u003cli\u003eUse optional comments in readXXX methods. With them it is much easier to understand where did checker stop its execution (if not you don\u0027t specify it, the comment will be like \u0026quot;integer doesn\u0027t belong to range [23, 45]\u0026quot; and it\u0027s not clear what integer caused such behavior). Also write informative comments in quitf calls; remember that your comments will be probably available to the contestants after the competition (or even during the competition like while hacking on Codeforces).\u003c/li\u003e \u003c/ul\u003e\u003c/div\u003e","tags":[]}}