{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1480162367,"rating":0,"authorHandle":"Slamur","modificationTimeSeconds":1507465666,"id":48637,"title":"\u003cp\u003eБазовые структуры данных. Java. Массив\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eДанная лекция является первой из лекций по базовым структурам данных в языке Java и рассказывает о массиве. \u003cbr /\u003e\u003c/p\u003e\u003ch4\u003e0) Массивы\u003c/h4\u003e\u003cp\u003eВ Java массивы являются статическими объектами — размер у них не меняется.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eСоздание массива.\u003c/strong\u003e\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003e\t// Создание массива с помощью конструктора\n\t// При создании массива конструктором все его значения получают значение по умолчанию\n\t// Для примитивов это 0 (false для boolean), а для ссылочных типов это null.\n\tint n \u003d 10;\n\t\n\tint[] a \u003d new int[n]; // 0, 0, ..., 0\n\tString[] s \u003d new String[n]; // null, null, null, ...\n\tboolean[] b \u003d new boolean[n]; // false, false, ...\n\t\n\t// Массив из явно заданных значений\t\n\tint[] a \u003d new int[] { 1, 2, 3, 4, 5 };\n\tint[] a \u003d { 1, 2, 3, 4, 5 };\n\t\n\t// У строки есть метод toCharArray(), которая возвращает массив из ее символов\n\tchar[] c \u003d \u0026quot;hello\u0026quot;.toCharArray(); // { \u0027h\u0027, \u0027e\u0027, \u0027l\u0027, \u0027l\u0027, \u0027o\u0027 }\n\t\n\t// Чтобы скопировать список, нужно воспользоваться функцией clone (только для примитивных типов - для ссылочных надо каждый элемент еще копировать)\n\t// Простое присваивание \u0027b \u003d a\u0027 копирует ссылку - в итоге вы получите два массива, которые будут меняться одновременно\n\tint[] b \u003d a.clone();\n\t\n\t// Двумерный массив создается абсолютно также. Можно считать, что это массив массивов.\n\t// Так как это массив массивов, то можно создать массивы разной длины\n\t\n\tint[][] a \u003d new int[n][m]; // все массивы одинаковой длины\n\t\n\tint[][] a \u003d {\n\t\t{ 1, 2 },\n\t\t{ 3, 4 },\n\t\t{ 5 }\n\t};\n\t\n\tint[][] a \u003d new int[n][];\n\t// В этот момент массив a состоит из null - так как int[] - ссылочный тип\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) {\n\t\ta[i] \u003d new int[2 * i + 1]; // будут созданы массив размеров 1, 3, 5, ...\n\t}\n\u003c/code\u003e\u003c/pre\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eРабота с массивом.\u003c/strong\u003e\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003e\tint[] a \u003d { 1, 7, 3, 6, 5 };\n\t\n\t// Индексация производится оператором [], индексы начинаются с 0.\n\tint x \u003d a[3] // x \u003d 6\n\ta[1] \u003d 10; // a \u003d { 1, 10, 3, 6, 5 }\n\t\n\t// Для получения длины списка есть функция length.\t\n\tint y \u003d a.length; // y \u003d 5\n\t\n\t// Заполнить массив одним значением\n\tArrays.fill(a, 10); // { 10, 10, 10, 10, 10 }\n\t\n\t// Важно! Передача объекта ссылочного типа приведет к тому, что все элементы будут ссылкой на один объект, а не копиями.\n\tPoint[] p \u003d new Point[3];\n\t\n\t// Не делайте так!\n\t// Arrays.fill(p, new Point(0, 0)); // p \u003d { (0, 0), (0, 0), (0, 0)  }\n\t// p[0].x \u003d 1; // p \u003d { (1, 0), (1, 0), (1, 0) }\n\t\n\t// Вот как правильно\n\tfor (int i \u003d 0; i \u0026lt; p.length; ++i) {\n\t\tp[i] \u003d new Point(0, 0);\n\t}\n\t\n\t// Сортировка массива\n\tArrays.sort(a); // { 1, 3, 5, 6, 7 }\n\t\n\t// Сортировка отрезка - от второго параметра включительно до третьего невключительно\n\tint[] a \u003d { 1, 4, 3, 5, 2 };\n\tArrays.sort(a, 2, 5); // { 1, 4, 2, 3, 5 }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["самара","массив","java"]}}