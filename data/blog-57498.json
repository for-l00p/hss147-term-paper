{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1517569199,"rating":-24,"authorHandle":"hissain.khan","modificationTimeSeconds":1517682972,"id":57498,"title":"\u003cp\u003eQuad tree â€” Implementation\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHere I have implemented Quad tree for ranged sum query. Is it possible to improve update with lazy propegation or something like that.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/7b/ff/7bff9daa7c6aec3f2ff2717b7ee778e9c0ba43f3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;stdio.h\u0026gt;\n#define SZ 10\n\nint TT[4 * SZ * SZ];\n\nint AA[4][4] \u003d {\n\t{ 1, 1, 1, 1 },\n\t{ 1, 1, 1, 1 },\n\t{ 1, 1, 1, 1 },\n\t{ 1, 1, 1, 1 }\n};\n\nint bld(int n, int i1, int j1, int i2, int j2){\n\n\tif (i1 \u0026gt; i2 || j1 \u0026gt; j2)\n\t\treturn 0;\n\n\tif (i1 \u003d\u003d i2 \u0026amp;\u0026amp; j1 \u003d\u003d j2)\n\t\treturn TT[n] \u003d AA[i1][i2];\n\n\tint mi \u003d i1 + (i2 - i1) / 2;\n\tint mj \u003d j1 + (j2 - j1) / 2;\n\n\tTT[n] \u003d 0;\n\n\tTT[n] +\u003d bld(4 * n + 1, i1, j1, mi, mj);\t\t// upper left quad\n\tTT[n] +\u003d bld(4 * n + 2, mi + 1, j1, i2, mj);\t\t// lower left quad\n\tTT[n] +\u003d bld(4 * n + 3, i1, mj + 1, mi, j2);\t\t// upper right quad\n\tTT[n] +\u003d bld(4 * n + 4, mi + 1, mj + 1, i2, j2);\t// lower right quad\n\n\treturn TT[n];\n}\n\nint qry(int n, int i1, int j1, int i2, int j2, int r1, int c1, int r2, int c2){\n\n\tif (i1 \u0026gt; r2 || j1 \u0026gt; c2 || i2 \u0026lt; r1 || j2 \u0026lt; c1 || i1 \u0026gt; i2 || j1 \u0026gt; j2)\n\t\treturn 0;\n\n\tif (i1 \u0026gt;\u003d r1 \u0026amp;\u0026amp; j1 \u0026gt;\u003d c1 \u0026amp;\u0026amp; i2 \u0026lt;\u003d r2 \u0026amp;\u0026amp; j2 \u0026lt;\u003d c2)\n\t\treturn TT[n];\n\n\tint mx \u003d 0;\n\n\tint mi \u003d i1 + (i2 - i1) / 2;\n\tint mj \u003d j1 + (j2 - j1) / 2;\n\n\tmx +\u003d qry(4 * n + 1, i1, j1, mi, mj, r1, c1, r2, c2);\n\tmx +\u003d qry(4 * n + 2, mi + 1, j1, i2, mj, r1, c1, r2, c2);\n\tmx +\u003d qry(4 * n + 3, i1, mj + 1, mi, j2, r1, c1, r2, c2);\n\tmx +\u003d qry(4 * n + 4, mi + 1, mj + 1, i2, j2, r1, c1, r2, c2);\n\n\treturn mx;\n}\n\n\nint upd(int n, int i1, int j1, int i2, int j2, int r1, int c1, int r2, int c2, int v){\n\n\tif (i1 \u0026gt; r2 || j1 \u0026gt; c2 || i2 \u0026lt; r1 || j2 \u0026lt; c1 || i1 \u0026gt; i2 || j1 \u0026gt; j2)\n\t\treturn 0;\n\n\tif (i1 \u003d\u003d i2 \u0026amp;\u0026amp; j1 \u003d\u003d j2)\n\t\treturn TT[n] \u003d v;\n\n\tPoint mx(-1, -1, 0);\n\n\tint mi \u003d i1 + (i2 - i1) / 2;\n\tint mj \u003d j1 + (j2 - j1) / 2;\n\n\tmx +\u003d upd(4 * n + 1, i1, j1, mi, mj, r1, c1, r2, c2, v);\n\tmx +\u003d upd(4 * n + 2, mi + 1, j1, i2, mj, r1, c1, r2, c2, v);\n\tmx +\u003d upd(4 * n + 3, i1, mj + 1, mi, j2, r1, c1, r2, c2, v);\n\tmx +\u003d upd(4 * n + 4, mi + 1, mj + 1, i2, j2, r1, c1, r2, c2, v);\n\n\treturn TT[n] \u003d mx;\n}\n\nint main(){\n\n\tint R, C;\n\n\tint x1, y1, x2, y2;\n\n\t// Data array Row,Col (RxC)\n\n\tR \u003d 4;\n\tC \u003d 4;\n\n\t// Query range (x1, y1) ~ (x2, y2)\n\n\tx1 \u003d 0, y1 \u003d 0;\n\tx2 \u003d 2, y2 \u003d 2;\n\n\tint p;\n\n\tbld(0, 0, 0, R - 1, C - 1);\n\n\tp \u003d qry(0, 0, 0, R - 1, C - 1, x1, y1, x2, y2);\n\n\tp \u003d upd(0, 0, 0, R - 1, C - 1, x1, y1, x2, y2, 2); // value \u003d 2\n\n\tp \u003d qry(0, 0, 0, R - 1, C - 1, x1, y1, x2, y2);\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["2d segment tree","2d","#rmq"]}}