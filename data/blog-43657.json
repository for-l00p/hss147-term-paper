{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1457435035,"rating":-12,"authorHandle":"S.G.G","modificationTimeSeconds":1457437850,"id":43657,"title":"\u003cp\u003eCodeforces Round #345 (Div. 2)-E. Table Compression\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"//www.codeforces.com/contest/651/problem/E\"\u003eProblem Link\u003c/a\u003e\u003c/p\u003e\u003ch1\u003e\u003cstrong\u003eSolution\u003c/strong\u003e\u003c/h1\u003e\u003cp\u003eThere is no harm in assumptioning that all the values in the table \u003c/p\u003e\u003cp\u003eare unique.Then it gets easier to think out the solution of the \u003c/p\u003e\u003cp\u003eproblem.We can sort all the values from small to large and insert \u003c/p\u003e\u003cp\u003ethem into the final matrix one by one and change the value into the \u003c/p\u003e\u003cp\u003emaximum value in the same row or column at present.It will be the \u003c/p\u003e\u003cp\u003efinal value after it added one.Then how to solve this problem when \u003c/p\u003e\u003cp\u003ethe values are not unique?How can we deal with the elements with the \u003c/p\u003e\u003cp\u003esame value?We can use Union-Find Sets to merge the elements that have \u003c/p\u003e\u003cp\u003ethe same value and limit each other.Obviously the elements in the \u003c/p\u003e\u003cp\u003esame union will have same final values and there is no limit from a \u003c/p\u003e\u003cp\u003eunion to another.Then the solution is similar to before.\u003c/p\u003e\u003ch1\u003e\u003cstrong\u003eCode\u003c/strong\u003e\u003c/h1\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;algorithm\u0026gt;\n#include\u0026lt;cstdio\u0026gt;\n#include\u0026lt;cstdlib\u0026gt;\n#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cmath\u0026gt;\nusing namespace std;\nstruct hh\n{\n\tint n;//Serial number\n\tint x;//row\n\tint y;//column\n\tint v;//value\n} a[1000001];\nint n,m,i,j,t,lt,p,fa[1000001],ans[1000001],la[1000001],lb[1000001],fi[1000001],h[1000001],l[1000001];\n//fa[] array used in Union-Find Sets\n//ans[] the final answer\n//la[] The target point (Adjacency list)\n//lb[] Pointer (Adjacency list)\n//fi[] Pointer to the last line (Adjacency list)\n//h[i] the maximum in row i \n//l[i] the maximum in column i\nvoid add(int x,int y)\n{\n\tla[++lt]\u003dy; lb[lt]\u003dfi[x]; fi[x]\u003dlt;\n}\n\nint find(int x)\n{\n\tif (fa[x]\u003d\u003dx) return x;\n\treturn fa[x]\u003dfind(fa[x]);\n}\n\nbool cmp1(hh a,hh b)\n{\n\treturn a.v\u0026lt;b.v || (a.v\u003d\u003db.v \u0026amp;\u0026amp; a.x\u0026lt;b.x);\n}\n\nbool cmp2(hh a,hh b)\n{\n\treturn a.y\u0026lt;b.y;\n}\n\nvoid bfs(int x)\n{\n\tint k,mx\u003dmax(h[(x-1)/m+1],l[(x-1)%m+1]);\n\tfor (k\u003dfi[x];k;k\u003dlb[k])\n\t\tmx\u003dmax(mx,max(h[(la[k]-1)/m+1],l[(la[k]-1)%m+1]));\n\tfor (k\u003dfi[x];k;k\u003dlb[k]) \n\t\tans[la[k]]\u003dh[(la[k]-1)/m+1]\u003dl[(la[k]-1)%m+1]\u003dmx+1;\n\tans[x]\u003dh[(x-1)/m+1]\u003dl[(x-1)%m+1]\u003dmx+1;\n}\n\nint main()\n{\n\t\tscanf(\u0026quot;%d%d\\n\u0026quot;,\u0026amp;n,\u0026amp;m);\n\t\tfor (i\u003d1;i\u0026lt;\u003dn;i++,scanf(\u0026quot;\\n\u0026quot;))\n\t\t\tfor (j\u003d1;j\u0026lt;\u003dm;j++)\n\t\t\t{\n\t\t\t\tt++;\n\t\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;a[t].v);\n\t\t\t\ta[t].n\u003dt;\n\t\t\t\ta[t].x\u003di;\n\t\t\t\ta[t].y\u003dj;\n\t\t\t}\n\t\tsort(a+1,a+t+1,cmp1);\n\t\tfor (i\u003d1;i\u0026lt;\u003dt;i++) fa[i]\u003di;\n\t\tfor (i\u003d1;i\u0026lt;\u003dt;i\u003dp+1)\n\t\t{\n\t\t\tlt\u003d0;\n\t\t\tp\u003di;\n\t\t\twhile (p\u0026lt;t \u0026amp;\u0026amp; a[p+1].v\u003d\u003da[p].v) p++;\n\t\t\tfor (j\u003di+1;j\u0026lt;\u003dp;j++)\n\t\t\t\tif (a[j].x\u003d\u003da[j-1].x) fa[find(a[j].n)]\u003dfind(a[j-1].n);\n\t\t\tsort(a+i,a+p+1,cmp2);\n\t\t\tfor (j\u003di+1;j\u0026lt;\u003dp;j++)\n\t\t\t\tif (a[j].y\u003d\u003da[j-1].y) fa[find(a[j].n)]\u003dfind(a[j-1].n);\n\t\t\tfor (j\u003di;j\u0026lt;\u003dp;j++) find(a[j].n);\n\t\t\tfor (j\u003di;j\u0026lt;\u003dp;j++) add(fa[a[j].n],a[j].n);\n\t\t\tfor (j\u003di;j\u0026lt;\u003dp;j++)\n\t\t\t\tif (fa[a[j].n]\u003d\u003da[j].n) bfs(a[j].n);\n\t\t}\n\t\tfor (i\u003d1;i\u0026lt;\u003dn;i++,printf(\u0026quot;\\n\u0026quot;))\n\t\t\tfor (j\u003d1;j\u0026lt;\u003dm;j++) printf(\u0026quot;%d \u0026quot;,ans[(i-1)*m+j]);\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}