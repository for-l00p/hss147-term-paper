{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1415299752,"rating":116,"authorHandle":"Xellos","modificationTimeSeconds":1416771115,"id":14618,"title":"\u003cp\u003eCodeforces Trainings Season 2 Episode 8: Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"http://www.bapc.eu/problemset.zip\"\u003eComplete problemset + tests + original presentation of solutions.\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://bapc.eu/scoreboards/bapc/\"\u003eOfficial scoreboard\u003c/a\u003e, \u003ca href\u003d\"http://www.bapc.eu/scoreboards/public/\"\u003epublic contest scoreboard\u003c/a\u003e, \u003ca href\u003d\"http://www.cs.ubc.ca/~acm-web/practice/2014-10-25/scores.php\"\u003eused for training elsewhere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eShort hints first, more detailed solutions afterwards.\u003c/p\u003e\u003ch3\u003eA. Avoiding the Apocalypse\u003c/h3\u003e\u003cp\u003e(difficulty: medium-hard, \u003ca href\u003d\"http://ideone.com/JQOMyq\"\u003ecode\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eMaxflow in a suitably selected graph. Ford-Fulkerson is sufficient.\u003c/p\u003e \u003chr /\u003e\u003cp\u003eThe vertices of our graph need to correspond to states that one person can be in when traversing the original road network; the number of people moving in a group is then represented by flow along edges. Therefore, the most natural choice is to use vertices corresponding to states (location, time).\u003c/p\u003e\u003cp\u003eThe rules from the problem statement say that at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e people can move along an edge \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e \u003d (\u003ci\u003eu\u003c/i\u003e -  \u0026gt; \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e in the original at any time. That means if we add an edge from \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e + \u003ci\u003es\u003c/i\u003e)\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e is the time it takes to traverse edge \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e), it needs to have capacity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e; such edges fully describe these rules.\u003c/p\u003e\u003cp\u003eStaying in place is also moving, just into the same vertex; it takes one time unit. That adds some more edges (with infinite capacity, as any number of people can stay in place).\u003c/p\u003e\u003cp\u003eNow, a path of some person is represented by a unit flow in this graph. In order to find the maximum number of people that can get somewhere, we clearly want a maximum flow in this graph.\u003c/p\u003e\u003cp\u003eWait, people can\u0027t wait forever! We still haven\u0027t used the restriction on time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e till zombification, but that\u0027s simple — just don\u0027t use vertices corresponding to time \u003cspan class\u003d\"tex-span\"\u003e \u0026gt; \u003ci\u003eS\u003c/i\u003e\u003c/span\u003e. This also bounds the number of vertices to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNS\u003c/i\u003e)\u003c/span\u003e and edges to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003eN\u003c/i\u003e + \u003ci\u003eM\u003c/i\u003e)\u003ci\u003eS\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFurthermore, we need a source vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, a sink vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and edges from/to them; the answer is the maxflow from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. It\u0027s obvious that we need 1 edge from the source to the starting vertex of our group of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e people (at time \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e), and that edge should have capacity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e. For edges to the sink, we\u0027ll use the last remaining part of the input (finally, the input is spent!): they need to go from the medical facilities, at time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e (there\u0027s no harm in waiting for a film-like cliffhanger), and have infinite capacity.\u003c/p\u003e\u003cp\u003eAll that\u0027s left is applying a standard maxflow algorithm, for example Ford-Fulkerson. That one has complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003eV\u003c/i\u003e + \u003ci\u003eE\u003c/i\u003e)\u003ci\u003eF\u003c/i\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003c/span\u003e is our answer (the maxflow), \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eE\u003c/i\u003e\u003c/span\u003e are vertices and edges of our graph — in this case, it\u0027s \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003eN\u003c/i\u003e + \u003ci\u003eM\u003c/i\u003e)\u003ci\u003eSG\u003c/i\u003e)\u003c/span\u003e. It actually runs in time, because its constant is fairly small and most tests are small or have small answers.\u003c/p\u003e\u003ch3\u003eB. Button Bashing\u003c/h3\u003e\u003cp\u003e(diff: easy-medium, \u003ca href\u003d\"http://ideone.com/h5jIiJ\"\u003ecode\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eBFS in a graph of cooking times.\u003c/p\u003e \u003chr /\u003e\u003cp\u003eAgain, we can construct a directed graph of states. In this case, each state will be a time set on the microwave so far; from it, you have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e edges corresponding to button presses that lead you to a different time as described in the problem statement.\u003c/p\u003e\u003cp\u003eObviously, you want to find the minimum distance from vertex \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003et\u003c/i\u003e \u003d 0)\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003et\u003c/i\u003e \u003d \u003ci\u003eT\u003c/i\u003e)\u003c/span\u003e, or min. distances to vertices \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003et\u003c/i\u003e \u0026gt; \u003ci\u003eT\u003c/i\u003e)\u003c/span\u003e (since you can always keep pressing one positive button, at least vertex \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003et\u003c/i\u003e \u003d 3600)\u003c/span\u003e is guaranteed to be reachable) when necessary. One BFS is enough to find the min. distances of all vertices from \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003et\u003c/i\u003e \u003d 0)\u003c/span\u003e and loop over all vertices \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003et\u003c/i\u003e ≥ \u003ci\u003eT\u003c/i\u003e)\u003c/span\u003e until you find one with non-infinite distance.\u003c/p\u003e\u003cp\u003eThere are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(3600\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e edges in our graph, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e vertices, so our BFS takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(3600\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e time.\u003c/p\u003e\u003ch3\u003eC. Citadel Construction\u003c/h3\u003e\u003cp\u003e(diff: med-hard, \u003ca href\u003d\"http://ideone.com/ZoFQek\"\u003ecode\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eConvex hull; fix 1 vertex (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e) of the quadrilateral, iterate the opposite one (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e) along the convex hull and recalculate the furthest vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e from line \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e - \u003ci\u003ew\u003c/i\u003e\u003c/span\u003e on each of its sides. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e \u003chr /\u003e\u003cp\u003eWe need to pick a quadrilateral (possibly degenerated into a triangle) with maximum area. Obviously, a triangle is better than a concave quadrilateral, so let\u0027s stick to convex ones.\u003c/p\u003e\u003cp\u003eSuppose that we picked one diagonal of our quadrilateral. Its area is the sum of triangles made by this line segment and 2 vertices on opposite sides from it. Using the well-known formula: area (of a triangle) \u003d base * height / 2, we realize that the most distant points from the line give the largest area, because the chosen diagonal is each triangle\u0027s base.\u003c/p\u003e\u003cp\u003eWe can imagine taking a line parallel to our diagonal and moving it perpendicularly to it; the last vertices it crosses (depending on the direction of its movement) are the most distant ones. But this is equivalent to saying that these most distant vertices must lie on the convex hull — if we draw a line through a point that\u0027s not on the convex hull, there will be points (stricty) on both sides from it, the ones belonging to the convex hull. Applied to both diagonals, it means we only need to use points on the convex hull.\u003c/p\u003e\u003cp\u003eLet\u0027s now pick a diagonal between 2 vertices on the convex hull and rotate our coordinate system so this diagonal coincides with the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-axis. We need to find the topmost point (farthest from the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-axis on one side, the other side can be done analogously). By definition of convexity, as we go from left to right on the hull, the angle between the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-axis and the side of the hull we\u0027re currently moving along will be non-increasing, which means the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e-coordinates of points we pass first increase (up to the first segment with negative angle) and then decrease.\u003c/p\u003e\u003cp\u003eIf we rotate this diagonal around one vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e of the hull, starting with position parallel (angle \u003cspan class\u003d\"tex-span\"\u003e0°\u003c/span\u003e) to one side \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e - \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e of the hull in that place, adding vertices to the part \u0026quot;above\u0026quot; the diagonal, the angles of all segments with the diagonal increase equally and the first segment with negative angle moves along the hull in the same direction we\u0027re adding vertices in. Therefore, we can use two pointers to store the other point of the diagonal \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e and the topmost point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSince the \u0026quot;bottommost\u0026quot; point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e can be recomputed using the 2 pointers\u0027 method with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e in parallel to recomputing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and we can calculate the respective area easily using vector cross products, this gives us (together with the convex hull) an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e algorithm.\u003c/p\u003e\u003ch3\u003eD. Dropping Directions\u003c/h3\u003e\u003cp\u003e(diff: med-hard, \u003ca href\u003d\"http://ideone.com/QquiQZ\"\u003ecode\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eBuild a graph with vertices (intersection, direction); it\u0027s a specific union of cycles. Adding a signpost points all locations on 0 or 2 cycles to the goal.\u003c/p\u003e \u003chr /\u003e\u003cp\u003eThe graph we\u0027re given is not very good, since the next intersection depends on the previous one. A much better graph is a directed one with vertices (intersection, direction). In this graph, the next vertex is given uniquely and the vertex from which we had to arrive is also given uniquely, so it must be a union of cycles.\u003c/p\u003e\u003cp\u003eFurthermore, if we had a cycle in it along some intersections, then there must be another cycle in which the order of intersections is opposite — it corresponds to traversing the same path in the original graph, just taking the opposite direction at each intersection.\u003c/p\u003e\u003cp\u003eNow, what would happen if we added some signposts? Each vertex would still have outdegree 1, but some would have indegree 0, so each connected component would be a cycle with some trees (directed to the root) appended to its vertices as roots. The situation we want to obtain is for each component\u0027s cycle to contain one of the goal\u0027s vertices (there are 4 of them, and at most 4 such cycles).\u003c/p\u003e\u003cp\u003eLet\u0027s look at the intersections in the goal\u0027s cycles, and at signposts in them. Such an intersection corresponds to 4 vertices, two of which originally lied in the goal\u0027s cycles already. Adding a signpost would therefore point at most 2 other cycles to the goal. After we added such a signpost, we could look at the graph again, find an intersection that leads tourists to the goal in two directions (either directly along an original goal\u0027s cycle, or by finding the previously added signpost) and add a signpost to it, and repeat until the goal is always reachable.\u003c/p\u003e\u003cp\u003eIn fact, we can always find an intersection such that adding a signpost would point 2 cycles to the goal this way. Thanks to our strategy and the symmetric property of our graph, we know that pointing one cycle to the goal means pointing its opposite direction cycle to the goal as well, so we point 0 or 2 cycles. And if we could only point 0 cycles, that would mean the original graph isn\u0027t connected.\u003c/p\u003e\u003cp\u003eTherefore, we can calculate the answer very easily: it\u0027s the number of components that don\u0027t contain the goal\u0027s intersection / 2. All it takes is one BFS for each component, in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e time total.\u003c/p\u003e\u003ch3\u003eE. Excellent Engineers\u003c/h3\u003e\u003cp\u003e(diff: medium, \u003ca href\u003d\"http://ideone.com/JD7PRb\"\u003ecode\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eA classical problem solvable simply using sorting and minimum-BIT in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/44/4f/444f5650f8f9de80540894d0bf33cb667ec90df3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003chr /\u003e\u003cp\u003eThe order of engineers doesn\u0027t matter, so let\u0027s sort them by their first ranks. Now, the only people who can kick an engineer out of the shortlist now have to be before him in the sorted order, so let\u0027s process them in that order.\u003c/p\u003e\u003cp\u003eFor an engineer \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e)\u003c/span\u003e, we need to find out if, among people processed before him and with smaller \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e, there\u0027s someone also with smaller \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e\u003c/span\u003e. That\u0027s straightforward if we use a minimum-BIT: if we store in the BIT an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[]\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e] \u003d \u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e\u003c/span\u003e for already processed engineers and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e] \u003d ∞\u003c/span\u003e for the rest, then it\u0027s equivalent to asking if \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d8/03/d80322f824ef5fdc0e60dcae17dfa813d5d1b6f2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Based on the answer, we can decide whether to add him to the shortlist. Then, we need to add the currently processed engineer by updating \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e]\u003c/span\u003e to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/45/44/4544a052ed3cc4c45a8bbe10c09c4c8d3b725059.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eSorting can be done in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e, queries and updates on BIT work in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/28/a3/28a3e1ebf443830c2b8d35cc88c49444739ab741.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, so we have an \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/44/4f/444f5650f8f9de80540894d0bf33cb667ec90df3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e algorithm.\u003c/p\u003e\u003ch3\u003eF. Floating Formation\u003c/h3\u003e\u003cp\u003e(diff: hard, \u003ca href\u003d\"http://ideone.com/0FVM0P\"\u003ecode\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eBoats are edges, designs are edges. Compress the graph to a tree with its root marked, then keep marking the vertex that has the most unmarked vertices on the path from it to the root. It can be done with preorder numbering and a segment tree.\u003c/p\u003e \u003chr /\u003e\u003cp\u003eThe input graph has specific form that simplifies stuff a lot — it\u0027s connected and has a part that always stays afloat. We can identify this part and compress it into the root of a tree. How? By identifying the part that doesn\u0027t stay afloat, and that can be done simply by cutting off leaves of the graph (stored in a queue) and adding their neighbours to the queue if they become leaves.\u003c/p\u003e\u003cp\u003eNow, we have a rooted tree, with only its root marked as \u0026quot;stays afloat\u0026quot;. If we connect a boat to its unmarked vertex, that vertex and all on the path from it to the root will also become marked that way. Obviously, we want to connect boats to leaves only; in fact, we want to connect a boat to a deepest vertex (if there are more, any one will do). If we didn\u0027t connect a boat to any of the deepest vertices, we could look at the first vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e on the path from one of them (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e) to the root that becomes marked in the end, take a boat from its subtree (connected to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e) and connect it to that deepest vertex (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e) instead, gaining at least one marked vertex, because we mark all vertices from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, unmark at most all vertices from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e must have been deeper than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe can connect the first boat to this vertex and mark all vertices on the path from it to the root; this can be done by simply moving along the path until we encounter a previously marked vertex. Where to put the next boat? Again, to the vertex with the most unmarked ones on the path from it to the root (let\u0027s call this number \u0026quot;true depth\u0026quot;). The argument is that the cost is the same as if we just took all marked vertices and merged them into the root (we did this at the beginning, remember?), obtaining another tree with all but the root unmarked, which is the same situation as when choosing the vertex for the first boat.\u003c/p\u003e\u003cp\u003eWe now have a clear idea of \u003ci\u003ewhat\u003c/i\u003e to do — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e times \u0026quot;pick the truly deepest vertex and mark all vertices above it (including itself)\u0026quot;. Then, we just need to count unmarked vertices to get the answer. The only question remaining is \u003ci\u003ehow\u003c/i\u003e to do this.\u003c/p\u003e\u003cp\u003eMarking vertices is straightforward, the only problem is updating true depths and finding the truly deepest vertex. What often helps with this type of problems is renumbering vertices so that each subtree would contain vertices from one interval. For example, with preorder numbering, which can be computed with one DFS — the root gets number 0, its first son gets number 1, then the subtree of the first son is numbered recursively, the second son gets the first unused number, then its subtree is numbered recursively, the 3rd son gets the first unused number again etc. This produces the desired numbering, and updating true depths when vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is marked turns into subtracting 1 from all true depths in an interval (corresponding to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e\u0027s subtree).\u003c/p\u003e\u003cp\u003eSo, we need to find the maximum and subtract a constant from an interval. Does that remind you of anything? Yes, maximum interval/segment tree. With lazy updates and able to find the vertex that this maximum belonged to. Lazy propagation is a standard thing, so I won\u0027t describe the tree here, but I\u0027ll mention that in order to get the vertex, you can keep the maximum of pairs (true depth, corresponding vertex). The time complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3b/1d/3b1dbb6b6fdb8b19c473de53edde3326e8cd48bb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, because all but the query answering/updating takes just linear time and a segment tree can be constructed in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003eG. Growling Gears\u003c/h3\u003e\u003cp\u003e(diff: easy, \u003ca href\u003d\"http://ideone.com/kGsk9G\"\u003ecode\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eTake the derivative of function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003eR\u003c/i\u003e)\u003c/span\u003e, find the optimal \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003chr /\u003e\u003cp\u003eThis is one of the most basic problems in calculus. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003eR\u003c/i\u003e)\u003c/span\u003e is a polynomial, which is differentiable in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e0/37/e03753cc7731c1b0a4dae876c60ebc837b4ee0e6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, so its maxima must satisfy \u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/29/18/2918a1daa600242c6112ba421215d07246cf2579.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f8/e5/f8e5c94a42383fd01a358af9ad5c73b00ec0ebe3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eIn this case, it means \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003eaR\u003c/i\u003e \u003d \u003ci\u003eb\u003c/i\u003e, \u003c/span\u003e-2a \u0026lt; 0$. The second rule is always satisfied, the first one has exactly one solution: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/99/61/9961845b3f6de90fa5139e180902b1e289a47aca.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, with the corresponding maximum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003emx\u003c/i\u003e\u003c/sub\u003e) \u003d \u003ci\u003eb\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e / 4\u003ci\u003ea\u003c/i\u003e + \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe want just solutions with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e \u0026gt; 0\u003c/span\u003e, but in this problem, it\u0027s always satisfied.\u003c/p\u003e\u003cp\u003eWe get a straightforward \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e code; doubles are fully sufficient for max. values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003eH. Highway Hassle\u003c/h3\u003e\u003cp\u003e(diff: harder, I\u0027m not sure if \u0026quot;very hard\u0026quot; is accurate)\u003c/p\u003e\u003cp\u003eLol nope. Look for it down in the comments.\u003c/p\u003e\u003ch3\u003eI. Interesting Integers\u003c/h3\u003e\u003cp\u003e(diff: medium, \u003ca href\u003d\"http://ideone.com/kHcrCC\"\u003ecode\u003c/a\u003e)\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e \u003d \u003ci\u003eG\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e\u003ci\u003eb\u003c/i\u003e + \u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 2\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e; try all reasonable \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, solve the equation \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/68/24/68248a29505d9be9ff3116201df03e4070a3d85d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (think why it\u0027s equivalent to N\u003dF_{n-1}b+F_{n-2}a$)\u003c/p\u003e \u003chr /\u003e\u003cp\u003eWe know that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e \u003d \u003ci\u003eG\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e\u003ci\u003eb\u003c/i\u003e + \u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 2\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e - 1\u003c/sub\u003e \u003d 1, \u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e \u003d 0\u003c/span\u003e (it\u0027s not called a linear recurrence without reason); proof by seeing that it satisfies all conditions it needs to satisfy. For \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e \u0026gt; 0\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e ≥ \u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and Fibonacci numbers increase quickly, so we can try all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, for which \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e holds.\u003c/p\u003e\u003cp\u003eLet\u0027s fix \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≥ 3\u003c/span\u003e. Modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e, we know that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e ≡ \u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 2\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e; consecutive Fibonacci numbers are also coprime (easy proof by induction), so \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 2\u003c/sub\u003e\u003c/span\u003e has a modular inverse and \u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d \u003ci\u003ekF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e + \u003ci\u003eNF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 2\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003eφ(\u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e) - 1\u003c/sup\u003e .\u003c/span\u003e\u003c/center\u003e\u003cp\u003eWe can precompute Euler\u0027s \u003cspan class\u003d\"tex-span\"\u003eφ\u003c/span\u003e of all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e ≤ \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e after factorising them. Then, we can compute the smallest positive \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e that can lead to a good pair \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e using fast exponentiation and its respective \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eWe can add any multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e and subtract the same multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 2\u003c/sub\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e to get all the other pairs \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e. The largest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, for which \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e + \u003ci\u003ekF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e ≤ \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e - \u003ci\u003ekF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 2\u003c/sub\u003e\u003c/span\u003e holds, is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/87/3b/873bd5abf895a3a19a672b055c7c8c0f96582862.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (integer division). If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e \u0026lt; \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e, there\u0027s clearly no way to make a good pair \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e with this \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e must be the smallest possible \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e here, but we\u0027d try to subtract something from it). Otherwise, the pair corresponding to this \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e must be good.\u003c/p\u003e\u003cp\u003eWe just need to pick the optimal one of so found good pairs \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e. There are \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/28/a3/28a3e1ebf443830c2b8d35cc88c49444739ab741.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e possible \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e-s, each requires \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/50/f5/50f569c1460b0cfb4ec5311b369b5e122b4a409e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e factorisation for \u003cspan class\u003d\"tex-span\"\u003eφ\u003c/span\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/28/a3/28a3e1ebf443830c2b8d35cc88c49444739ab741.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e exponentiation; all remaining steps are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e, so we get \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b0/cb/b0cbb7d884bde96c5048f5a49dee70c41edde4a6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e complexity per query with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bf/8e/bf8ee04fe65af1a8ae2fb3a0f058d83b9395b7ba.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e precomputation.\u003c/p\u003e\u003ch3\u003eJ. Jury Jeopardy\u003c/h3\u003e\u003cp\u003e(diff: easy, \u003ca href\u003d\"http://ideone.com/2GvJcp\"\u003ecode\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eTrivial simulation of what\u0027s described in the statement (walk around the maze and mark cells as empty), just bug-prone. Nothing else to add, you can read my code to understand better.\u003c/p\u003e\u003ch3\u003eK. Key to Knowledge\u003c/h3\u003e\u003cp\u003e(diff: medium, \u003ca href\u003d\"http://ideone.com/4mJcxj\"\u003ecode\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eMeet in the middle, pick one half of correct answers. \u003cspan class\u003d\"tex-span\"\u003e31\u003csup class\u003d\"upper-index\"\u003e12\u003c/sup\u003e \u0026lt; 10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e\u003c/span\u003e, so a vector can be compressed into a 64-bit integer.\u003c/p\u003e \u003chr /\u003e\u003cp\u003eThe simplest bruteforce would try all possible combinations of correct answers, count the number of correct answers each student got and decide if it\u0027s correct. But that\u0027s too slow.\u003c/p\u003e\u003cp\u003eA better solution uses meet-in-the-middle approach. We can bruteforce all combinations of the first \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f6/ec/f6ece8ade689c3b06ae8a3b6f7b5db67b6fdcd53.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e correct answers and count how many of them each student answered correctly, as a vector \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e. The same can be done for the last \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/2d/c5/2dc5465079a3810cb17ea8e0626f8593e7e5bc18.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e answers, obtaining vectors \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e of how many answers each student needs to answer correctly in the other half. The answer to the problem is the number of pairs \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e, \u003ci\u003ew\u003c/i\u003e)\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e \u003d \u003ci\u003ew\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe could just throw all vectors \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e into a \u003ccode\u003emap\u0026lt;\u0026gt;\u003c/code\u003e and compute the answer directly by looping over all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e. But to make sure it doesn\u0027t TLE, we can convert the vectors into numbers in base \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e + 1\u003c/span\u003e. Since these numbers are at most \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eM\u003c/i\u003e + 1)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sup\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e\u003c/span\u003e here, 64-bit integers are sufficient for this representation. Comparing vectors in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e now turns into comparing integers in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThere are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eM\u003c/i\u003e / 2\u003c/sup\u003e)\u003c/span\u003e halves of correct answers to check (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eMN\u003c/i\u003e)\u003c/span\u003e), compress (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e) and drill into or search in a map (\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c4/3d/c43dab4cf9f192e2bb043f554a28ced54a3721bf.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e), so the time for this is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eM\u003c/i\u003e / 2\u003c/sup\u003e\u003ci\u003eMN\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e","tags":["gym","training","s02e08","editorial"]}}