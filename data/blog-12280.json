{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1399962964,"rating":68,"authorHandle":"adamant","modificationTimeSeconds":1399995052,"id":12280,"title":"\u003cp\u003eObtaining suffix array from suffix automaton\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi everyone! 2 years ago \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Logvinov_Leon\" title\u003d\"Candidate Master Logvinov_Leon\"\u003eLogvinov_Leon\u003c/a\u003e \u003ca href\u003d\"http://codeforces.ru/blog/entry/3581\"\u003easked\u003c/a\u003e about way to get the suffix array from suffix automata. Oddly enough, he had not received answer. However, as you may have noticed, I\u0027m interested in the topic of transformations of some string structures to others, so I decided to shed some light on how this is done. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eSo, you will notice that suffix automaton — essentially a suffix tree with a few other compression principle. While in compressed tree we just squeeze the edges, when we construct the suffix automaton we getting something like two-way trie. We are compressing not only common prefixes, but also common suffixes. From this we can draw the following interesting conclusion: if we will traverse through automaton with dfs, ignoring the used-array, we will get the same thing as when traversing suffix tree. Now remember that the suffix array from suffix tree obtained by the usual DFS — we just write down the suffixes in the order in which we encounter them in the trie. Thus, we already have an algorithm for constructing suffix array from automata for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eBut, of course, it does not suit us and we want to go further. If we want to have linear time, we can\u0027t ignore the used-array. Easy to see that even so, starting in depth tour we will meet a few (at least one) suffixes before the first stop in the visited state. Now our task when we visit the state is to quickly get all the suffixes that are hidden behind it, without traversing all the ways from this state again. I suggest the following solution: let each state in the machine to keep indices of the first and last encountered after it suffixes in suffix array. Then, when we came in the used state, we will add to the array all the suffixes in which we would have got from it, taking into account the already traversed length. Obviously, this solution will work for the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e, since we totally add exactly n suffixes, and all the rest of the time we just dfs through the suffix automaton.\u003c/p\u003e\u003cp\u003eP.S. my \u003ca href\u003d\"http://ideone.com/Rud85z\"\u003eimplementation\u003c/a\u003e of the algorithm. \u003cbr /\u003e P.P.S. I can\u0027t say for sure, but it seems that in practice, this algorithm is not applicable due to the very large constants.\u003c/p\u003e\u003c/div\u003e","tags":["suffix array","suffix automata"]}}