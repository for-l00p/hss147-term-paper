{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1517930617,"rating":-9,"authorHandle":"shash42","modificationTimeSeconds":1517931122,"id":57587,"title":"\u003cp\u003eApproach to 2D Segment Tree with Lazy Propogation (should allow RMQ?)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI was going through many online blogs on 2D Subrectangle Queries and Updates using Lazy Propogation. I was surprised to find that Subtrectangle Minimum and Maximum Queries were not possible in sub-linear time. \u003c/p\u003e\u003cp\u003eThis was probably because most 2D Data Structure approaches were based on Fixing an Origin, and then handling queries as\u003cbr /\u003e\u003cb\u003e Q(x1, y1, x2, y2) {x1\u0026lt;\u003dx2 and y1\u0026lt;\u003dy2} \u003d Q\u0027(x2, y2)-Q\u0027(x1, y2)-Q\u0027(x2, y1)+Q\u0027(x1, y1). \u003c/b\u003e \u003cbr /\u003e [This example shows Range Sum Query]. This is like basic 2D prefix sums but with segment trees/2D BIT to handle updates.\u003c/p\u003e\u003cp\u003eHowever, I came up with a different approach. [Please note that there is some bug in the codes right now which is taking too long to debug, so I thought I\u0027d first ask if I\u0027m on the right track here before I spend more time debugging as I\u0027ve already spent a whole day working on this.] \u003cbr /\u003e Since we are maintaining a Segment Tree of Rows where each Segment Tree holds another Segment Tree for columns, I went with the naive approach. Now, a segment tree node with range (x, x, y, y) holds the value at that point (arr[x][y]), not the sum from origin till there. \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSpoiler\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003evoid buildy(int idx, int lx, int rx, int idy, int ly, int ry)\n{\n\tif(ly\u003d\u003dry)\n\t{\n\t\tif(lx\u003d\u003drx) segt[idx][idy]\u003da[idx][idy];\n\t\telse segt[idx][idy]\u003dmax(segt[idx*2][idy], segt[idx*2+1][idy]);\n\t\tlzy[idx][idy]\u003dlazy[idx][idy]\u003d0;\n\t\treturn;\n\t}\n\tint mid\u003d(ly+ry)/2;\n\tbuildy(idx, lx, rx, idy*2, ly, mid);\n\tbuildy(idx, lx, rx, idy*2+1, mid+1, ry);\n\tsegt[idx][idy]\u003dmax(segt[idx][idy*2], segt[idx][idy*2+1]);\n\tlzy[idx][idy]\u003dlazy[idx][idy]\u003d0;\t\n}\nvoid buildx(int ind, int l, int r)\n{\n\tif(l!\u003dr)\n\t{\n\t\tint mid\u003d(l+r)/2;\n\t\tbuildx(ind*2, l, mid);\n\t\tbuildx(ind*2+1, mid+1, r);\n\t\treturn;\n\t}\n\tbuildy(ind, l, r, 1, 0, m-1);\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eUpdates are basically handled in a normal segment tree fashion. If a node\u0027s range is completely within update\u0027s target range then we make the update and propogate lazy to ranges within the node\u0027s range. To do this we first isolate idx nodes within the update\u0027s target x range and then for these nodes we set the idy nodes within update\u0027s target y range. Since there will be logarithmic of both, the complexity is logNlogM. The 2 lazy arrays are explained after the update codes.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSpoiler\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cbr /\u003evoid updy(int idx, int lx, int rx, int idy, int ly, int ry, int stx, int endx, int sty, int endy, int val)\n{\n\tlazify(idx, idy, lx, rx, ly, ry);\n\tif(ly\u0026gt;\u003dsty \u0026amp;\u0026amp; ry\u0026lt;\u003dendy)\n\t{\n\t\tif(lx\u0026gt;\u003dstx \u0026amp;\u0026amp; rx\u0026lt;\u003dendx)\n\t\t{\n\t\t\tsegt[idx][idy]+\u003dval;\n\t\t\tif(ly!\u003dry)\n\t\t\t{\n\t\t\t\tlzy[idx][idy*2]+\u003dval;\n\t\t\t\tlzy[idx][idy*2+1]+\u003dval;\n\t\t\t}\n\t\t\tif(lx!\u003drx)\n\t\t\t{\n\t\t\t\tlazy[idx*2][idy]+\u003dval;\n\t\t\t\tlazy[idx*2+1][idy]+\u003dval;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsegt[idx][idy]\u003dmax(segt[idx*2][idy], segt[idx*2+1][idy]);\n\t\t}\n\t\treturn;\n\t}\n\tif(ly\u0026gt;endy || ry\u0026lt;sty) return;\n\tint mid\u003d(ly+ry)/2;\n\tupdy(idx, lx, rx, idy*2, ly, mid, stx, endx, sty, endy, val);\n\tupdy(idx, lx, rx, idy*2+1, mid+1, ry, stx, endx, sty, endy, val);\n\tsegt[idx][idy]\u003dmax(segt[idx][idy*2], segt[idx][idy*2+1]);\n}\nvoid updx(int ind, int lx, int rx, int stx, int endx, int sty, int endy, int val)\n{\n\tint lazyupd\u003dqueryy(ind, 1, lx, rx, 0, m-1, sty, endy);\n\tif(lx\u0026gt;endx || rx\u0026lt;stx) return;\n\tif(lx\u0026gt;\u003dstx \u0026amp;\u0026amp; rx\u0026lt;\u003dendx)\n\t{\n\t\tupdy(ind, lx, rx, 1, 0, m-1, stx, endx, sty, endy, val);\n\t\treturn;\n\t}\n\tint mid\u003d(lx+rx)/2;\n\tupdx(ind*2, lx, mid, stx, endx, sty, endy, val);\n\tupdx(ind*2+1, mid+1, rx, stx, endx, sty, endy, val);\n\tupdy(ind, lx, rx, 1, 0, m-1, stx, endx, sty, endy, val);\n\treturn;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eFinally coming to the lazy part. We have 2 lazy arrays, lazy and lzy. Lazy basically propogates over x coordinates whereas lzy propogates over y coordinates. This is important (and can\u0027t be merged into a single 2D array) because of the way I chose to propogate: \u003cbr /\u003e Imagine a 2D space of idx, idy coordinates. Let the children of idx be below the node and children of idy be on the left. So now we need to propogate in a way that we compress a rectangle between (0, 0 \u0026amp; idx, idy) towards the origin. So an update needs to go both down and left. If we do this simultaneously in a single 2D array as:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSpoiler\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003elazy[idx*2][idy]+\u003dlazy[idx][idy];\nlazy[idx*2+1][idy]+\u003dlazy[idx][idy];\nlazy[idx][idy*2]+\u003dlazy[idx][idy];\nlazy[idx][idy*2+1]+\u003dlazy[idx][idy];\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003ethe paths will start crossing creating a mess. For eg, an update could go left then down and down then left and thus double update the same node. To prevent this, we make a rule that an update that has been propogated to the left once cant be propogated down. So updates first go down and then each node they visit propogates them to the left. Thus we need 2 arrays lazy and lzy, values in lzy cant be propogated down where as values in lazy can be propogated leftwards once (then they become part of lzy and thus cant go down) and can be propogated down. Notice how calling querry function in a junk variable lazyupd helps to propogate updates for all nodes we visit (logN for each update on idx).\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSpoiler\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003evoid lazify(int idx, int idy, int lx, int rx, int ly, int ry)\n{\n\tif(lx!\u003drx)\n\t{\n\t\tlazy[idx*2][idy]+\u003dlazy[idx][idy];\n\t\tlazy[idx*2+1][idy]+\u003dlazy[idx][idy];\t\n\t}\n\tif(ly!\u003dry)\n\t{\n\t\tlzy[idx][idy*2]+\u003dlazy[idx][idy];\n\t\tlzy[idx][idy*2]+\u003dlzy[idx][idy];\n\t\tlzy[idx][idy*2+1]+\u003dlazy[idx][idy];\n\t\tlzy[idx][idy*2+1]+\u003dlzy[idx][idy];\n\t}\n\tsegt[idx][idy]+\u003dlazy[idx][idy];\n\tsegt[idx][idy]+\u003dlzy[idx][idy];\n\tlzy[idx][idy]\u003dlazy[idx][idy]\u003d0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eFinally I come to queries. We do the junk variable based lazy propogation here too. The rest is pretty trivial.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSpoiler\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eint queryy(int idx, int idy, int lx, int rx, int ly, int ry, int sty, int endy)\n{\n\tlazify(idx, idy, lx, rx, ly, ry);\n\tif(ly\u0026gt;endy || ry\u0026lt;sty)\treturn 0;\n\tif(ly\u0026gt;\u003dsty \u0026amp;\u0026amp; ry\u0026lt;\u003dendy)\n\t{\n\t\treturn segt[idx][idy];\n\t}\n\tint mid\u003d(ly+ry)/2;\n\treturn max(queryy(idx, idy*2, lx, rx, ly, mid, sty, endy), queryy(idx, idy*2+1, lx, rx, mid+1, ry, sty, endy));\t\n}\nint queryx(int ind, int lx, int rx, int stx, int endx, int sty, int endy)\n{\n\tint lzyupd\u003dqueryy(ind, 1, lx, rx, 0, m-1, sty, endy);\t\n\tif(lx\u0026gt;endx || rx\u0026lt;stx) return 0;\n\tif(lx\u0026gt;\u003dstx \u0026amp;\u0026amp; rx\u0026lt;\u003dendx)\n\t{\n\t\treturn queryy(ind, 1, lx, rx, 0, m-1, sty, endy);\n\t}\n\tint mid\u003d(lx+rx)/2;\n\treturn max(queryx(ind*2, lx, mid, stx, endx, sty, endy), queryx(ind*2+1, mid+1, rx, stx, endx, sty, endy));\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eWhile this code is a little buggy still for some reason (would be great if someone could help me correct it), I want to know if the general idea is correct. This should definitely be better than a quad-tree approach or similar if I am not missing some key point. Please go through the post and let me know of your opinion, if it is correct I will make another blogpost hopefully transforming this post into my first tutorial :D\u003c/p\u003e\u003c/div\u003e","tags":["2d segment tree","lazy propagation","technique","approach"]}}