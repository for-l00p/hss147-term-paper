{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1500120832,"rating":3,"authorHandle":"Lance_HAOH","modificationTimeSeconds":1500128490,"id":53314,"title":"\u003cp\u003eHelp needed to solve JOI 2013/2014 Problem — Historical Research\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi. I am having problem trying to solve JOI 2013/2014 — Historical Research. The english problem statement can be found \u003ca href\u003d\"https://dunjudge.me/analysis/problems/743/\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eFor those who understand Japanese, the editorial can be found \u003ca href\u003d\"https://www.ioi-jp.org/camp/2014/2014-sp-tasks/2014-sp-d1-historical-review.pdf\"\u003ehere\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe input and output data can be found \u003ca href\u003d\"https://www.ioi-jp.org/camp/2014/2014-sp-tasks/2014-sp-d1-data.zip\"\u003ehere\u003c/a\u003e\u003c/p\u003e\u003cp\u003eMy approach is as follows:\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eproduct\u003c/i\u003e \u003d \u003ci\u003eelement\u003c/i\u003e × \u003ci\u003efrequency\u003c/i\u003e\u003c/span\u003e in subarray \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e]\u003c/span\u003e \u003c/p\u003e\u003cp\u003eWe use a BST to answer our max product queries and element updates efficiently, Each element of the BST would be \u003cspan class\u003d\"tex-span\"\u003e \u0026lt; \u003ci\u003eproduct\u003c/i\u003e, \u003ci\u003eelement\u003c/i\u003e, \u003ci\u003efrequency\u003c/i\u003e \u0026gt; \u003c/span\u003e and the elements in the BST are sorted by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eproduct\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e be the number of elements in our array and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e be the number of queries.\u003c/p\u003e\u003cp\u003ePerform square root decomposition on the queries by breaking them into \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/81/f381a867c035d8ab67dd362b509e4d7f78b7a087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e blocks and sorting them in increasing order of left bound followed by increasing order of right bound. Time-complexity of this operation is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eQ\u003c/i\u003e × \u003ci\u003elogQ\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe keep 2 pointers to track the left and right bound of the subarray that we have calculated the element frequency for. Every time we shift the left pointer, we remove the elements from the left side of the subarray from the BST. Every time we shift the right pointer, we add the new elements in the subarray to the BST.\u003c/p\u003e\u003cp\u003eOf course, we have to update the product accordingly. Time-complexity of this operation is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/73/2b/732b15fe297486f588670b40b60692a2546ebafe.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. This is because each query can only be in one block and block size is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/50/f5/50f569c1460b0cfb4ec5311b369b5e122b4a409e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Hence, the left pointer can only move by \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/50/f5/50f569c1460b0cfb4ec5311b369b5e122b4a409e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e on each query (i.e. \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0e/ad/0ead0061628487edc437582f9b5335d1250c1115.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e in total) and the right pointer moves by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e in every block and we have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/50/f5/50f569c1460b0cfb4ec5311b369b5e122b4a409e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e blocks. Hence, right pointer moves by \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c4/c1/c4c1962a861f73dfd2f0c86ee42e9b143e09a42a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e in total. Finally, each movement incurs an update operation in the BST which is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e. That proves the time-complexity for this part.\u003c/p\u003e\u003cp\u003eEvery time we need to query the maximum product, we just query the largest element in the BST, which is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eHence, the total time-complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e9/eb/e9ebb50d8ae7a9645e21a11f1c7cbdfa7c557f0f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. However, \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003eN\u003c/i\u003e, \u003ci\u003eQ\u003c/i\u003e ≤ 100, 000\u003c/span\u003e, which implies that the algorithm will perform \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ae/cf/aecfef3bab9ba5d5d9553f97f6d0498806288786.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e operations in the worst case (do note that the time-limit is only 4s). I tried coding this solution and as expected, it passed all but the last subtask (which uses the largest input).\u003c/p\u003e\u003cp\u003eCould someone please advise me on how I could optimize my solution\u0027s time-complexity?\u003c/p\u003e\u003c/div\u003e","tags":["joi 2014","mos_algorithm","sliding window","two-pointers"]}}