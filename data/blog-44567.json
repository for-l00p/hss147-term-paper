{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1461719563,"rating":0,"authorHandle":"MedoN11","modificationTimeSeconds":1461719563,"id":44567,"title":"\u003cp\u003eHow to solve this gym problem ?\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eLink to problem : \u003ca href\u003d\"//www.codeforces.com/problemset/gymProblem/100499/E\"\u003ehttp://www.codeforces.com/problemset/gymProblem/100499/E\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIdea: To solve this problem using a DFS, and maintaining a treap for each node, where it contains it’s corresponding binary-search tree.\u003c/p\u003e\u003cp\u003eBasically, recursively get the best BST of our right child, and best BST of our left child. ( If they exist ).\u003c/p\u003e\u003cp\u003eEnsure that the values added from each child node would not violate our corresponding binary search tree. If they do erase them, and get the best connected sub-tree you can get.\u003c/p\u003e\u003cp\u003eThis approach gives a Wrong answer. Even though it’s very convincing.\u003c/p\u003e\u003cp\u003eMe and a friend of mine tried coming up with a test case to fail this but couldn’t find any.\u003c/p\u003e\u003cp\u003eThanks !\u003c/p\u003e\u003c/div\u003e","tags":[]}}