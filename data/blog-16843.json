{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1425826583,"rating":8,"authorHandle":"ahmad_mamdouh","modificationTimeSeconds":1427155333,"id":16843,"title":"\u003cp\u003eRound 4 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eDear All,\u003c/p\u003e\u003cp\u003eCongrats to \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/AmrMahmoud\" title\u003d\"Expert AmrMahmoud\"\u003eAmrMahmoud\u003c/a\u003e and \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/RedNextYears\" title\u003d\"Candidate Master RedNextYears\"\u003eRedNextYears\u003c/a\u003e for there amazing performance. \u003c/p\u003e\u003cp\u003eI hope the remaining participants and specially those participating in the next world finals spend more time in practicing. \u003c/p\u003e\u003cp\u003eThe experience in the world finals will be a one of a kind thing and you\u0027ll always look backward at your performance there. You\u0027ll seem much more satisfied if you believe that you spend enough time practicing and preparing for this. \u003c/p\u003e\u003cp\u003eI wish you all best of luck there and solid performance in shaa Allah. Round 4 Link: \u003ca href\u003d\"//codeforces.com/group/91QBrESJ4B/contest/202506\"\u003ehttp://codeforces.com/group/91QBrESJ4B/contest/202506\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eBubble Sort\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSolution by \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/AmrSamir\" title\u003d\"Candidate Master AmrSamir\"\u003eAmrSamir\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAn array that can be sorted with a single bubble pass has the following property:\u003c/p\u003e\u003cp\u003eA value \u003cem\u003ei\u003c/em\u003e can be in any position between 0 and \u003cem\u003ei+1\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eIt can also be thought as a pattern, where a large number \u003cem\u003ej\u003c/em\u003e appears earlier than its position, and all the numbers after it are sorted up to it\u0027s position.\u003c/p\u003e\u003cp\u003eE.g:\u003c/p\u003e\u003cp\u003eposition : ... i i+1 i+2 ... j-1 j ...\u003c/p\u003e\u003cp\u003evalue : ... j i i+1 ... j-2 j-1 ...\u003c/p\u003e\u003cp\u003eIf you try to make a DP to count the number of ways we can make such array, you will find a very easy recurrence:\u003c/p\u003e\u003cp\u003eA position \u003cem\u003ei\u003c/em\u003e can have as value any of the values \u003cem\u003ei\u003c/em\u003e till \u003cem\u003en-1\u003c/em\u003e. If you pick a value \u003cem\u003ej\u003c/em\u003e to be in position \u003cem\u003ei\u003c/em\u003e, you have to keep the array sorted to position of \u003cem\u003ej\u003c/em\u003e, so you can directly skip to position \u003cem\u003ej+1\u003c/em\u003e and continue the recurrence. More formally:\u003c/p\u003e\u003cp\u003eLet DP(i) be the number of ways to have one bubble pass array of length i.\u003c/p\u003e\u003cp\u003eDP(0) \u003d DP(1) \u003d 1\u003c/p\u003e\u003cp\u003eDP(i) \u003d Summation j\u003d0 to j\u003di-1 DP(j)\u003c/p\u003e\u003cp\u003eThis gives you DP(i) \u003d 2^(i-1) (except for i \u003d 0).\u003c/p\u003e\u003cp\u003eNow a simple building path dp cannot work here because of overflow. But we can skip values we are sure to overflow, and only consider shuffling the last 63 values in the array. They are enough even for the largest value of k.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/mpAd94\"\u003ehttp://ideone.com/mpAd94\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eAntipalindromic Numbers\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSolution by \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/mostafa_fahim\" title\u003d\"Expert mostafa_fahim\"\u003emostafa_fahim\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe begin by adding \u00271\u0027 to the number to make sure it is more than the input.\u003c/p\u003e\u003cp\u003eIf the number has odd length then the solution is the minimum number with length (input length +1). Else, the way to go is to try to change the digits at the right side of the number which are equal to their counterpart at the left side. The logical change is to keep incrementing the right hand side digit by \u00271\u0027 (propagating carry in case it is \u00279\u0027) until until it is different from its left hand side counterpart. Due to loose limits, we can try all possibilities starting from the right most digit and returning once a solution is found.\u003c/p\u003e\u003cp\u003eA tricky point is that after incrementing position i for example all positions from i+1 till the end of the numbers can be changed freely (why?) to make the result as small as possible.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/0bV8gj\"\u003ehttp://ideone.com/0bV8gj\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eChipmunks\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSolution by \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/mostafa_fahim\" title\u003d\"Expert mostafa_fahim\"\u003emostafa_fahim\u003c/a\u003e\u003c/p\u003e\u003cp\u003ePretty straight forward pre-computation.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/Xz0BCa\"\u003ehttp://ideone.com/Xz0BCa\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDowry\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSolution by \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/ahmad_mamdouh\" title\u003d\"Expert ahmad_mamdouh\"\u003eahmad_mamdouh\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAs the number of jewels is 32, this is a very good hint to go for meet in the middle. Divide the jewels into two groups each of size 16 (left group and right group), compute all possible subsets weight and value. Now for a given subset in the left group with weight weightLeft and value valueLeft, we want to search in the right group for the maximum value subset with weight between (L-weightLeft, R-weightLeft) as not to violate the problem specifications. This reduces to a range maximum query problem which can be solved using segment trees. The problem is easy but requires constructive thinking for building multiple components and of course careful implementation.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://pastebin.com/hJm4NuMJ\"\u003ehttp://pastebin.com/hJm4NuMJ\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCryptography\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSolution by \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/islam-al-aarag\" title\u003d\"Candidate Master islam-al-aarag\"\u003eislam-al-aarag\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003ePermutation Construction\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe proposed solution here is O(n^3). Suppose that we know the position of number 1 in the permutation, we then let\u0027s try for each one of the given input that this is the correct permutation which we removed 1 from it (we already assume the 1 position), Now we know a candidate solution, let\u0027s check if it\u0027s valid or not. We can do this by doing the procedure explained in the problem statement, remove a number, decrease all numbers greater than this number by 1. If we obtained the whole set of permutations that are present in the input, then this is a valid permutation.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://pastebin.com/Y8HPZqwA\"\u003ehttp://pastebin.com/Y8HPZqwA\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDecoding Prefix Code\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSolution by \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/ahmad_mamdouh\" title\u003d\"Expert ahmad_mamdouh\"\u003eahmad_mamdouh\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAs the number of distinct characters in the input string is limited by 10 and no character code word will be longer than 10, this should hint that the solution is a complete search solution using backtracking with some pruning rules based on the input specifications. Just try each character with a possible word and try to prune dead end solutions as early as possible and once you reach a valid solution, exit.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://pastebin.com/5tyBhn8m\"\u003ehttp://pastebin.com/5tyBhn8m\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eYellow Code\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSolution by \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/m.radwan\" title\u003d\"Master m.radwan\"\u003em.radwan\u003c/a\u003e\u003c/p\u003e\u003cp\u003eCode: \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMatrix Multiplication\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSolution by \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/ahmad_mamdouh\" title\u003d\"Expert ahmad_mamdouh\"\u003eahmad_mamdouh\u003c/a\u003e\u003c/p\u003e\u003cp\u003eSince the problem requires finding the sum of all elements in the resulting matrix, we don\u0027t have to compute each cell\u0027s value (and even we can\u0027t do so because of the problem limits). We can reduce the problem such that for each edge we sum the node degrees for it\u0027s endpoints.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://pastebin.com/QNF6VFG8\"\u003ehttp://pastebin.com/QNF6VFG8\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSaving Princess\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSolution by \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/ahmad_mamdouh\" title\u003d\"Expert ahmad_mamdouh\"\u003eahmad_mamdouh\u003c/a\u003e Typical Dynamic Programming problem, where at each step we can either defeat or enchant the monster. We have 5 parameters here each of limit 50, so we can\u0027t memoize all of them. However, we can observe that using only 4 parameters we can uniquely identify the fifth parameter. We should also keep another array of the path we took to recover the answer.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://pastebin.com/qdrQVDQZ\"\u003ehttp://pastebin.com/qdrQVDQZ\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eTree Analysis\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSolution by \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/islam-al-aarag\" title\u003d\"Candidate Master islam-al-aarag\"\u003eislam-al-aarag\u003c/a\u003e\u003c/p\u003e\u003cp\u003eCode:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCrazy Wall\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSolution by \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/m.radwan\" title\u003d\"Master m.radwan\"\u003em.radwan\u003c/a\u003e\u003c/p\u003e\u003cp\u003eCode:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSubWords\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSolution by \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/AmrSamir\" title\u003d\"Candidate Master AmrSamir\"\u003eAmrSamir\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWhy is there always a solution?\u003c/p\u003e\u003cp\u003eYou can always insert pairs of letters at the ends to generate any string. E.g. one way to generate BabAB (the * surrounds the important letters) *a*A \u003d\u0026gt; *ab*BA \u003d\u0026gt; *abA*aBA \u003d\u0026gt; *abAB*baBA \u003d\u0026gt; b*BabAB*baBA Lets call the letters outside the *\u0027s \u0026quot;side-effects\u0026quot;.\u003c/p\u003e\u003cp\u003eLet\u0027s reduce the string to the lowest form. Why?\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eReducing doesn\u0027t hurt, we can add the removed letters at any time.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIt can be proven that there is a unique reduced form for a string.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eLet\u0027s call the first string W, and the second V. Now we reduced W \u003d\u0026gt; rW, V \u003d\u0026gt; rV. To get the shortest possible string, we need to reuse as many letters of rW to represent rV. Since we can always at letters to start/end of a string to restore missing letters, what we care about matching the middle part.\u003c/p\u003e\u003cp\u003eThis means, we should find the longest common substring of rW and rV, and we can later add any missing letters to this common part. Since the strings are short, any string matching algorithm should work.\u003c/p\u003e\u003cp\u003eGiven that we now know the common part, we need to use this to create the final string. Here is what it will contain:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eRemaining letters in rW that are not in the common part. They cannot be reduced so they survive.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThe full string V.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eSide-effects for the letters in rV that are not in the common part.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/YqHnbZ\"\u003ehttp://ideone.com/YqHnbZ\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}