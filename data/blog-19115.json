{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1436266708,"rating":63,"authorHandle":"Hasan0540","modificationTimeSeconds":1436283843,"id":19115,"title":"\u003cp\u003e2015 ِACM AmmanCPC Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003e\u003cstrong\u003e\u003ca href\u003d\"//codeforces.com/gym/100712/problem/A\"\u003eA. Who Is The Winner\u003c/a\u003e\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eWe can keep the name of the winner team while reading the input, if the current team solved more problems than the current winner, or solved the same number of problems but with less penalty, we set the current team as the winner:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ecin \u0026gt;\u0026gt; curTeam \u0026gt;\u0026gt; curSolved \u0026gt;\u0026gt; curPenalty;\nif (curSolved \u0026gt; winSolved || curSolved \u003d\u003d winSolved \u0026amp;\u0026amp; curPenalty \u0026lt; winPenalty){\n\twinTeam \u003d curTeam;\n\twinSolved \u003d curSolved;\n\twinPenalty \u003d curPenalty;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003e\u003ca href\u003d\"//codeforces.com/gym/100712/problem/B\"\u003eB. Rock-Paper-Scissors\u003c/a\u003e\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eLet\u0027s start with the brute force solution, we can try all possible pairs \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eX\u003c/i\u003e, \u003ci\u003eY\u003c/i\u003e)\u003c/span\u003e, if we know \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eZ\u003c/i\u003e \u003d \u003ci\u003eN\u003c/i\u003e - \u003ci\u003eX\u003c/i\u003e - \u003ci\u003eY\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe number of times Bahosain wins depends on the number of Scissors in the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e rounds, the number of Rocks in the next \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e rounds, and the number of Papers in the last \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eZ\u003c/i\u003e\u003c/span\u003e rounds.\u003c/p\u003e\u003cp\u003eWe can find the number of times he will lose in a similar way.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint res \u003d 0;\nfor (int X \u003d 0; X \u0026lt;\u003d N; ++X)\n\tfor (int Y \u003d 0; Y \u0026lt;\u003d N; ++Y){\n\t\tint winCount \u003d countInRange(0, X - 1, \u0027S\u0027)\t //     Rock \u0026gt; Scissors\n\t\t\t     + countInRange(X, X + Y - 1, \u0027R\u0027)   //    Paper \u0026gt; Rock\n\t\t\t     + countInRange(X + Y, N - 1, \u0027P\u0027);  // Scissors \u0026gt; Paper\n\t\tint loseCount \u003d countInRange(0, X - 1, \u0027P\u0027)      //     Rock \u0026lt; Paper\n\t\t\t      + countInRange(X, X + Y - 1, \u0027S\u0027)  //    Paper \u0026lt; Scissors\n\t\t\t      + countInRange(X + Y, N - 1, \u0027R\u0027); // Scissors \u0026lt; Rock\n\t\tif(winCount \u0026gt; loseCount)\n\t\t\t++res;\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis solution works in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e if the function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecountInRange\u003c/i\u003e\u003c/span\u003e works in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e, we can improve it using prefix sum (cumulative sum).\u003c/p\u003e\u003cp\u003eCreate 3 arrays: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003erockSum\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epaperSum\u003c/i\u003e\u003c/span\u003e, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003escissorsSum\u003c/i\u003e\u003c/span\u003e. We set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003erockSum\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d 1\u003c/span\u003e if there is a rock at index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. We fill the other two arrays in a similar way.\u003c/p\u003e\u003cp\u003eAfter calculating the prefix sums, we can modify \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecountInRange\u003c/i\u003e\u003c/span\u003e to work in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e. For example, to find the number of rocks in a range \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e]\u003c/span\u003e, we can use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003erockSum\u003c/i\u003e[\u003ci\u003eR\u003c/i\u003e] - \u003ci\u003erockSum\u003c/i\u003e[\u003ci\u003eL\u003c/i\u003e - 1]\u003c/span\u003e (watch out when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e \u0026gt; \u003ci\u003eR\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e \u003d 0\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003e\u003ca href\u003d\"//codeforces.com/gym/100712/problem/C\"\u003eC. Street Lamps\u003c/a\u003e\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eIf we don\u0027t have any asterisk \u003ccode\u003e*\u003c/code\u003e, then for each 3 dots we need one lamp, so the answer is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/37/4c/374c3b5ce1867e2027a6327d45d4ebf58562f3f7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e is the number of dots.\u003c/p\u003e\u003cp\u003eWe can solve the problem by creating a copy of the given string, and for each asterisk in the first string we place an asterisk at it\u0027s adjacent indices in the second string. So if the given string is \u003ccode\u003e...**..\u003c/code\u003e, the second one will be \u003ccode\u003e..****.\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eAfter that, we count the number of dots in each block of consecutive dots and find the number of needed lamps for that block.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003e\u003ca href\u003d\"//codeforces.com/gym/100712/problem/D\"\u003eD. Alternating Strings\u003c/a\u003e\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eThis problem can be solved using dynamic programming.\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e be the minimum number of partitions needed for the suffix that starts at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, we try all possible cuts \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ei\u003c/i\u003e...\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e. A cut is possible if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u003d \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, or the substring \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e...\u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e is not alternating and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e + 1 ≤ \u003ci\u003eK\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003edp[s.length()] \u003d 0;\nfor (int i \u003d s.length() - 1; i \u0026gt;\u003d 0; --i){\n\tbool isAlter \u003d true;\n\tdp[i] \u003d 1e9;\n\tfor (int j \u003d i; j - i + 1 \u0026lt;\u003d k \u0026amp;\u0026amp; j\u0026lt;s.size(); ++j){\n\t\tif (j\u0026gt;i \u0026amp;\u0026amp; s[j] \u003d\u003d s[j - 1])\n\t\t\tisAlter \u003d false;\n\t\tif (i \u003d\u003d j || isAlter \u003d\u003d false)\n\t\t\tdp[i] \u003d min(dp[i], 1 + dp[j + 1]);\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFinally, the answer will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[0] - 1\u003c/span\u003e, because \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[0]\u003c/span\u003e represents the number of partitions, not cuts.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNK\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003e\u003ca href\u003d\"//codeforces.com/gym/100712/problem/E\"\u003eE. Epic Professor\u003c/a\u003e\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e be the maximum mark of a student, then the maximum possible bonus marks will be \u003cspan class\u003d\"tex-span\"\u003e100 - \u003ci\u003eM\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe can find the maximum mark in one loop, and then count the number of students such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eMark\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003estudent\u003c/i\u003e\u003c/sub\u003e + 100 - \u003ci\u003eM\u003c/i\u003e ≥ 50\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003e\u003ca href\u003d\"//codeforces.com/gym/100712/problem/F\"\u003eF. Travelling Salesman\u003c/a\u003e\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eWe can greedily keep adding the edges with the minimum length to the graph until we have one component, then the answer is the length of the last added edge.\u003c/p\u003e\u003cp\u003eThis can be done using disjoint-sets data structure. The number of components in the graph will decrease by 1 after merging two components.\u003c/p\u003e\u003cp\u003eNote that the answer is the same as the maximum length of an edge in a minimum spanning tree.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eMlogM\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003e\u003ca href\u003d\"//codeforces.com/gym/100712/problem/G\"\u003eG. Heavy Coins\u003c/a\u003e\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eWe need to find the maximum size of a subset such that the sum of it\u0027s values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e ≥ \u003ci\u003eS\u003c/i\u003e\u003c/span\u003e and the minimum value in the subset is greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e - \u003ci\u003eS\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSince \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e is small, we can try all possible subsets recursively, or iteratively using a bitmask.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint res \u003d 0;\nfor (int mask \u003d 1; mask \u0026lt; (1 \u0026lt;\u0026lt; n); ++mask){\n\tint sum \u003d 0, size \u003d 0, minVal \u003d 1e9;\n\tfor (int i \u003d 0; i\u0026lt;n; ++i)\n\t\tif((mask\u0026gt;\u0026gt;i)\u0026amp;1){\n\t\t\tsum +\u003d val[i];\n\t\t\t++size;\n\t\t\tminVal \u003d min(minVal, val[i]);\n\t\t}\n\tif (sum \u0026gt;\u003d s \u0026amp;\u0026amp; minVal \u0026gt; sum - s)\n\t\tres \u003d max(res, size);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eComplexity: \u003ccode\u003eiterative solution\u003c/code\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sup\u003e\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e, \u003ccode\u003erecursive solution\u003c/code\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003e\u003ca href\u003d\"//codeforces.com/gym/100712/problem/H\"\u003eH. Bridges\u003c/a\u003e\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eAfter removing bridges from the graph, we will have one or more components with no bridges.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/7e/ec/7eec852907a7e648af4d6212874f8bcf19398876.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eImagine each component as one big node, and connect those big nodes using the removed bridges:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/d0/0b/d00b0c17ece5978eefc794eaa1eca15007debee6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThe resulting graph is a tree, each edge in this tree is a bridge in the original graph, we need to remove the maximum possible number of bridges by adding one edge.\u003c/p\u003e\u003cp\u003eAdding an edge between two nodes will remove a number of bridges equal to the number of edges on the unique path between them, so we need to remove the longest path in this tree.\u003c/p\u003e\u003cp\u003eThe final answer is the number of bridges in the graph minus the longest path in the tree.\u003c/p\u003e\u003cp\u003eMapping each component into one node can be done using disjoint-sets. It is possible to solve the problem without actually building the tree, check \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/I_love_Tanya_Romanova\" title\u003d\"Grandmaster I_love_Tanya_Romanova\"\u003eI_love_Tanya_Romanova\u003c/a\u003e\u0027s \u003ca href\u003d\"//codeforces.com/blog/entry/19108?#comment-240096\"\u003ecomment\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e + \u003ci\u003eM\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003e\u003ca href\u003d\"//codeforces.com/gym/100712/problem/I\"\u003eI. Bahosain and Digits\u003c/a\u003e\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eWe can try all possible \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e, we also try all possible digits \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e, that is we want to make all digits in the string equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTo check if that\u0027s possible, we add the needed value to the first digit to make it equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emod\u003c/i\u003e10\u003c/span\u003e), we should add the same value to the next \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e - 1\u003c/span\u003e digits, some contestants did this using segment tree and got TLE.\u003c/p\u003e\u003cp\u003eTo do this efficiently, we can keep a variable \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eadd\u003c/i\u003e\u003c/span\u003e that represents the total added value, and an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eremove\u003c/i\u003e\u003c/span\u003e to mark that when we are at index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, we should subtract \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eremove\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eadd\u003c/i\u003e\u003c/span\u003e, please check the code if that wasn\u0027t clear:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint add \u003d 0, remove[251] \u003d {};\nfor (int i \u003d 0; i + k \u0026lt;\u003d digits.length(); ++i){\n\tadd -\u003d remove[i];\n\tint curDigit \u003d (digits[i] - \u00270\u0027 + add) % 10;\n\tint need \u003d (10 - curDigit + D) % 10;\n\tadd +\u003d need;\n\tremove[i + k] \u003d need;\n}\n// after that we need to check that we won\u0027t need more\n// operations to make the last K digits equal to D.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(10|\u003ci\u003edigits\u003c/i\u003e|\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003e\u003ca href\u003d\"//codeforces.com/gym/100712/problem/J\"\u003eJ. Candy\u003c/a\u003e\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eLet\u0027s create two frequency arrays, one for ages and one for packet sizes, after that we can match ages with packet sizes greedily.\u003c/p\u003e\u003cp\u003eWe keep matching the minimum age \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e with the minimum possible packet size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efreqAge\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] ≤ \u003ci\u003efreqSize\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e. Note that we can\u0027t use sizes less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e after that because the problem says that older students must get more candies.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ebool yes \u003d true;\nfor (int age \u003d 5, size \u003d 1; age \u0026lt;\u003d 15; ++age){\n\tif(freqAge[age] \u003d\u003d 0)\n\t\tcontinue;\n\twhile (size \u0026lt;\u003d 50 \u0026amp;\u0026amp; freqAge[age]\u0026gt;freqSize[size])\n\t\t++size;\n\tif (size \u003d\u003d 51){\n\t\tyes \u003d false;\n\t\tbreak;\n\t}\n\t++size;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(15 + 50)\u003c/span\u003e\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003e\u003ca href\u003d\"//codeforces.com/gym/100712/problem/K\"\u003eK. Runtime Error\u003c/a\u003e\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eMany contestants got runtime error in this problem because of dividing by zero.\u003c/p\u003e\u003cp\u003eWe can solve the problem in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e using an array that tells us if we have some number or not.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ebool have[100001] \u003d {};\nint X \u003d 1e9, Y;\nfor (int val, i \u003d 0; i\u0026lt;n; ++i){\n\tcin \u0026gt;\u0026gt; val;\n\tif (val\u0026gt;0 \u0026amp;\u0026amp; k%val \u003d\u003d 0 \u0026amp;\u0026amp; have[k / val]){\n\t\tint curX \u003d min(val, k / val);\n\t\tint curY \u003d k / curX;\n\t\tif (curX\u0026lt;X){\n\t\t\tX \u003d curX;\n\t\t\tY\u003dcurY;\n\t\t}\n\t}\n\thave[val] \u003d true;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThere are other solutions that use frequency arrays or binary search. Be careful in case \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e is a square number like \u003cspan class\u003d\"tex-span\"\u003e25\u003c/span\u003e and there is one \u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003e\u003ca href\u003d\"//codeforces.com/gym/100712/problem/L\"\u003eL. Alternating Strings II\u003c/a\u003e\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eLet\u0027s go back to the solution of problem \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e, notice that once the substring is not alternating, it won\u0027t be alternating again, so we just choose the minimum value in the range \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ei\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e - 1]\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is the first position after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e...\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e is not alternating. In other words, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e - 1\u003c/sub\u003e \u003d \u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe can use segment tree to get the minimum value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003c/span\u003e in the required range.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e","tags":["gym","acm","amman","editorial"]}}