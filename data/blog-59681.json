{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1527232910,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1528418015,"id":59681,"title":"\u003cp\u003eРазная теория (вся)\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eНе очень структурировано, к сожалению... \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eLambda-выражения\u003c/p\u003e\u003cp\u003eЛямбда-выражения появились в Java 8, причем не в качестве маленького дополнения, а в качестве инструмента, активно используемого в языке (в том числе в JavaFX — фреймворке, пришедшего на смену Swing). Конечно, следует сказать, что лямбда-выражения стоит рассматривать как существенное упрощение синтаксиса, но не как принципиальное новшество. \u003c/p\u003e\u003cp\u003eЧасто говорят, что лямбда-выражения позволяют параметризовать поведение (behavior parametrization). Поясним, что имеется в виду.\u003c/p\u003e\u003cp\u003eВы уже неплохо знакомы со стандартными структурами данных и знаете, что эти струкуры параметризуются типами объектов, которые в них содержатся (\u003ccode\u003eTreeSet\u0026lt;Integer\u0026gt;\u003c/code\u003e или \u003ccode\u003eArrayList\u0026lt;Pair\u0026gt;\u003c/code\u003e, где \u003ccode\u003ePair\u003c/code\u003e — класс, содержащий, например, в качестве полей два целых числа). Также вам знакомо понятие компаратора, который позволяет использовать стандартный метод \u003ccode\u003eCollections.sort()\u003c/code\u003e или же передавать класс в качестве параметра в упорядоченную структуру. Технически компаратор может быть либо реализацией интерфейса \u003ccode\u003eComparable\u003c/code\u003e, либо реализацией интерфейса \u003ccode\u003eComparator\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eИнтерфейс \u003ccode\u003eComparator\u003c/code\u003e содержит метод \u003ccode\u003ecompare(T v1, T v2)\u003c/code\u003e, где \u003ccode\u003eT\u003c/code\u003e — тип (класс), который параметризует компаратор, а \u003ccode\u003ev1\u003c/code\u003e и \u003ccode\u003ev2\u003c/code\u003e — значения этого типа. Класс, реализующий этот интерфейс, может быть отделен от класса \u003ccode\u003eT\u003c/code\u003e, а объект этого класса может передаваться отдельно в метод сортировки или конструктор упорядоченной структуры (например, один из конструкторов класса \u003ccode\u003eTreeSet\u003c/code\u003e описан как \u003ccode\u003eTreeSet(Comparator\u0026lt;? super T\u0026gt; comparator)\u003c/code\u003e). Этот подход обеспечивает гибкость — можно создавать разные структуры данных, параметризованные одним и тем же типом \u003ccode\u003eT\u003c/code\u003e и при этом поддерживающие упорядоченность по разным критериям. \u003c/p\u003e\u003cp\u003eОднако \u0026quot;накладные расходы\u0026quot; при таком подходе будут не такими уж и маленькими. Действительно, нужно описать дополнительный класс, реализующий интерфейс \u003ccode\u003eComparator\u003c/code\u003e, создать объект этого класса, а затем передать этот объект в метод. При этом высока вероятность того, что описанный класс и созданный объект понадобятся единожды именно для передачи в этот метод. \u003c/p\u003e\u003cp\u003eВот как, к примеру, это может выглядеть. Пусть у нас есть некие объекты, характеризуемые тремя целочисленными параметрами (можете представлять себе, что это координаты в трёхмерном пространстве, или же придумать другую интерпретацию; мы назовём соответствующий класс довольно абстрактно — \u003ccode\u003eTriplet\u003c/code\u003e). Пусть у нас есть список \u003ccode\u003elst\u003c/code\u003e (\u003ccode\u003eArrayList\u0026lt;Triplet\u0026gt;\u003c/code\u003e), в котором эти объекты хранятся. И в разные моменты нам нужно по-разному упорядочивать этот список. Например, в некоторый момент нам требуется, чтобы список был упорядочен по убыванию величины первого параметра, а в случае одинаковых значений первого параметра — по возрастанию второго; третий же параметр никакой роли играть не должен. А спустя некоторое время возникает необходимость упорядочить этот список по возрастанию второго параметра, при равенстве вторых параметров — по возрастанию третьего параметра, а при равенстве и третьих параметров — по убыванию первого параметра. \u003c/p\u003e\u003cp\u003e\u0026quot;Классический\u0026quot; подход к решению этой задачи состоял в том, чтобы, во-первых, описать два класса, реализующие интерфейс \u003ccode\u003eComparator\u003c/code\u003e (по одному на каждый способ сортировки), затем создать объекты этих классов и передать их в качестве параметров в соответствующие вызовы метода \u003ccode\u003eCollections.sort()\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eПриведём фрагмент кода (предполагаем, что написать класс, содержащий метод \u003ccode\u003emain()\u003c/code\u003e, в котором создается объект демонстрационного класса и вызывается его метод \u003ccode\u003etest()\u003c/code\u003e, не составит труда для читателей ):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass DemoOldStyle {\n\t\n\tstatic class Triplet {\n\n\t    Triplet(int f, int s, int t) {\n\t        first \u003d f;\n\t        second \u003d s;\n\t        third \u003d t;\n\t    }\n\n\t    public String toString() {\n\t        return \u0026quot;[\u0026quot; + first + \u0026quot;, \u0026quot; + second +  \u0026quot;, \u0026quot; + third + \u0026quot;]\u0026quot;;\n\t    }\n\n\t    int first;\n\t    int second;\n\t    int third;\n\t \n\t}\n\n\tclass CmpX implements Comparator\u0026lt;Triplet\u0026gt; {\n\n\t    public int compare(Triplet t1, Triplet t2) {\n\t        if (t1.first \u0026gt; t2.first) return -1;\n\t        if (t1.first \u0026lt; t2.first) return 1;\n\t        return 0;\n\t    }\n\n\t}\n\n\tclass CmpY implements Comparator\u0026lt;Triplet\u0026gt; {\n\n\t    public int compare(Triplet t1, Triplet t2) {\n\t        if (t1.second \u0026lt; t2.second) return -1;\n\t        if (t1.second \u0026gt; t2.second) return 1;\n\t        if (t1.third \u0026lt; t2.third) return -1;\n\t        if (t1.third \u0026gt; t2.third) return 1;\n\t        if (t1.first \u0026gt; t2.first) return -1;\n\t        if (t1.first \u0026lt; t2.first) return 1;\n\t        return 0;\n\t    }\n\n\t}\n\n\t\n\tDemoOldStyle() {\n\t\tlst \u003d new ArrayList\u0026lt;\u0026gt;();\n\t\tlst.add(new Triplet(1, 2, 3));\n\t\tlst.add(new Triplet(3, 2, 1));\n\t\tlst.add(new Triplet(5, 1, 4));\n\t\tlst.add(new Triplet(4, 3, 2));\n\t\tlst.add(new Triplet(7, 4, 1));\n\t\tlst.add(new Triplet(1, 8, 5));\t\n\t\tlst.add(new Triplet(5, 4, 1));\n\t}\n\t\n\n\tvoid printlst() {\n\t\tfor (Triplet t: lst) {\n\t\t\tSystem.out.println(t);\n\t\t}\n\t}\n\t\n\tvoid test() {\n\t\tCmpX cx \u003d new CmpX();\n\t\tCollections.sort(lst, cx);\n\t\tSystem.out.println(\u0026quot;First comparator\u0026quot;);\n\t\tprintlst();\n\t\tCmpY cy \u003d new CmpY();\n\t\tCollections.sort(lst, cy);\n\t\tSystem.out.println(\u0026quot;Second comparator\u0026quot;);\n\t\tprintlst();\n\t}\n\t\n\t\n\tArrayList\u0026lt;Triplet\u0026gt; lst;\n\t\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДействительно, классы \u003ccode\u003eCmpX\u003c/code\u003e и \u003ccode\u003eCmpY\u003c/code\u003e, равно как и объекты этих классов, создаются для единственного обращения к методу сортировки. Вызов этого метода, конечно, можно переписать как \u003ccode\u003eCollections.sort(lst, new CmpX())\u003c/code\u003e, чтобы не создавать объект \u003ccode\u003ecx\u003c/code\u003e (и, аналогично, объект \u003ccode\u003ecy\u003c/code\u003e), но это не очень сильно уменьшает объём кода (и не избавляет нас от \u0026quot;лишних сущностей\u0026quot;). Чтобы эти \u0026quot;лишние сущности\u0026quot; не плодить, в Java можно использовать так называемые анонимные классы. Запись в этом случае также не слишком укорачивается, но компараторы создаются ровно в том месте, где они необходимы (т.е. соблюдается принцип локальности). Метод \u003ccode\u003etest()\u003c/code\u003e можно дополнить следующими строками:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e                System.out.println(\u0026quot;Yet another first comparator\u0026quot;);\n\t\tCollections.sort(lst, new Comparator\u0026lt;Triplet\u0026gt;() {\n\t\t\tpublic int compare(Triplet t1, Triplet t2) {\n\t\t            if (t1.first \u0026gt; t2.first) return -1;\n \t\t            if (t1.first \u0026lt; t2.first) return 1;\n\t\t            return 0;\n\t\t\t}\n\t\t});\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ этом случае нам не потребуется описывать и класс \u003ccode\u003eCmpX\u003c/code\u003e (аналогично для \u003ccode\u003eCmpY\u003c/code\u003e). Однако это всё равно достаточно объёмный код, многое в котором в принципе \u0026quot;очевидно\u0026quot; для компилятора. Например, поскольку \u003ccode\u003elst\u003c/code\u003e хранит объекты класса \u003ccode\u003eTriplet\u003c/code\u003e, логично предположить, что компаратор будет сравнивать именно эти объекты. Далее, в интерфейсе \u003ccode\u003eComparator\u003c/code\u003e заявлен ровно один метод — \u003ccode\u003ecompare()\u003c/code\u003e, и опять же логично предположить, что нам необходимо реализовать именно этот метод. И разработчики Java (а Java написана на Java) в версии 1.8 дали возможность разработчикам на Java записывать такие конструкции более экономно. Приведём также небольшой фрагмент, которым можно дополнить метод \u003ccode\u003etest()\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\t\tSystem.out.println(\u0026quot;Yet another second comparator\u0026quot;);\n\t\tCollections.sort(lst, (t1, t2) -\u0026gt; {\n\t            if (t1.first \u0026gt; t2.first) return -1;\n \t            if (t1.first \u0026lt; t2.first) return 1;\n\t            return 0;\t\t\t\n\t\t});\n\t\tprintlst();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗаметим, что если бы нам было нужно отсортировать список только по одному значению, то запись была бы еще короче: достаточно было бы воспользоваться соответствующим методом класса Integer. Например, вот так можно было бы отсортировать список по невозрастанию значений поля \u003ccode\u003ethird\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\t\tSystem.out.println(\u0026quot;Sort by third parameter\u0026quot;);\n\t\tCollections.sort(lst, (t1, t2) -\u0026gt; -Integer.compare(t1.third, t2.third);\n\t\tprintlst();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВскоре мы обсудим и другие примеры, и другие способы записи лямбда-выражений. Пока же следует сказать, что мы фактически передаем в метод сортировки функцию, определяющую способ сравнения двух элементов. Именно это и является параметризацией поведения: мы вызываем метод \u003ccode\u003esort()\u003c/code\u003e, чтобы отсортировать список, и именно в вызове метода указываем, как именно его следует отсортировать.\u003c/p\u003e\u003cp\u003eТакже сделаем некоторые (промежуточные) наблюдения.\u003c/p\u003e\u003cp\u003eУпрощённый синтаксис, использованный выше, на самом деле ничего не меняет в смысле \u0026quot;однозначности\u0026quot;. Действительно, мы планируем отсортировать список, который уже параметризован классом \u003ccode\u003eTriplet\u003c/code\u003e, поэтому совершенно логично предположить, что нам нужно описать метод сравнения именно объектов этого класса. Таким образом, информация о типе сравниваемых элементов (которая оставалась ещё в анонимном классе), избыточна. \u003c/p\u003e\u003cp\u003eВторой важный момент заключается в том, что интерфейс \u003ccode\u003eComparator\u003c/code\u003e имеет единственный метод (\u003ccode\u003ecompare\u003c/code\u003e). Поэтому указание, что реализуется именно этот метод, также избыточно. Если бы мы имели дело с интерфейсом, в котором было бы описано несколько методов, то обеспечить однозначность было бы проблематично. А в случае одного метода такой проблемы не возникает. Примерно из подобных соображений (наверное) в Java 8 и появилась концепция \u003cem\u003eфункционального интерфейса\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eТак что запись лямбда-выражения в некотором смысле есть сокращение записи анонимного класса без потери однозначности этой записи. \u003c/p\u003e\u003cp\u003eВ общем виде лямбда-выражение может быть записано так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e(параметры лямбда-выражения) -\u0026gt; {оператор(ы)}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eили\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e(параметры лямбда-выражения) -\u0026gt; выражение;\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбратите внимание, что операторы должны быть обязательно заключены в фигурные скобки. Как раз пример с сортировкой по двум параметрам соответствует первому варианту синтаксиса, а пример с сортировкой по одному параметру — второму варианту.\u003c/p\u003e\u003cp\u003eЧто же касается функциональных интерфейсов — это интерфейсы, имеющие ровно один абстрактный метод. Уточнение про абстрактный метод важно, поскольку интерфейсы могут содержать в себе статические методы, имеющие реализацию (а также статические поля; конечно, это нарушает чистоту концепции интерфейсов, но иногда оказывается весьма полезным).\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Когда вы создавали проекты с графическим интерфейсом, вам неоднократно приходилось иметь дело с событиями и их обработчиками (а также лямбда-выражениями, которые воспринимались на уровне небольшого шаманства). Например, требовалось, чтобы при нажатии на кнопку выполнялось некоторое действие. \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e В Swing (до появления лямбда-выражений) нужно было действовать так. В классе кнопки (более, точно, в наиболее общем \u0026quot;оконном\u0026quot; классе, наследником которого является кнопка) существует метод, позволяющий добавить так называемого слушателя события. Слушатель события — это тоже класс, реализующий некоторый интерфейс слушателя (каждому типу событий соответствовал свой интерфейс слушателя; так, был интерфейс слушателя событий клавиатуры, два интерфейса слушателя событий мыши и т.д.). \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Как вы, наверное, помните, интерфейс — это набор заголовков методов без реализации (да, там могут быть статические методы, константы, но сейчас это несущественные детали). Если некоторый класс заявлен как реализующий некоторый интерфейс, это значит, что класс должен реализовать все объявленные в интерфейсе методы. Однако поскольку в интерфейсах присутствовало по нескольку методов, это создавало программистам ряд неудобств. Например, в одном из интерфейсов слушателя мыши содержатся методы нажатия на клавишу мыши, отпускания клавиши мыши, щелчка по клавише мыши (нажатие + отпускание), а также методы, описывающие реакцию на вход курсора в заданную область и выход курсора из заданной области. Чаще всего программисту нужно было отследить одно-два события из набора, что приводило к формальной реализации не нужных в данный момент методов. Создатели Java, предвидя это, предложили заготовленные абстрактные классы, реализующие интерфейсы слушателей, чтобы программист мог просто унаследовать свой класс от такого абстрактного. \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Получалось, что нужно было определить свой класс (либо самостоятельно реализующий необходимый интерфейс слушателя, либо наследник класса, который реализует этот интерфейс), создать объект этого класса и передать его в качестве параметра методу, добавляющему слушателя к графическому компоненту. Конечно, такой подход обеспечивал большую гибкость: компоненты были слабо связаны с событиями и в любой момент можно было изменить их реакцию на то или иное событие или даже \u0026quot;научить\u0026quot; их реагировать на совершенно другой тип событий. Но ценой этой гибкости было большое количество однотипного кода. \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Если единственное, что вам стало понятно из предыдущих трёх абзацев, это то, что связывание события с компонентом было весьма непростым делом, требующим написания достаточно немаленького объёма кода, вы совершенно правы. Изучать сейчас детально описанный выше процесс в наши планы совершенно не входит, достаточно понимать, что разработчики хотели получить инструмент, который сделал бы этот процесс (и результат в виде кода) более простым. Разумеется, разработка приложений с графическим интерфейсом не единственная область, где лямбда-выражения позволяют существенно упростить код, и они находят свое применение в самых разных ситуациях. \u003c/small\u003e\u003c/p\u003e\u003cp\u003eПотоки Stream\u003c/p\u003e\u003cp\u003eКод и некоторое количество \u0026quot;теории\u0026quot; по лямбда выражениям и потокам данных (stream).\u003c/p\u003e\u003cp\u003eВ следующем примере есть список товарищей (товарищ описывается классом \u003ccode\u003ePerson\u003c/code\u003e), и нам нужно из списка отобрать тех, у кого \u0026quot;подходящий\u0026quot; возраст. Это делается большим количеством спосбов.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\n\npublic class LambdaDemo1 {\n\n    public static void main(String[] args) {\n        PersonListUser plu \u003d new PersonListUser(new PersonList());\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v1 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v1(20);\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v2 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v2(20);\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v3 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v3(20);\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v4 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v4(20);\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v5 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v5(20);\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v6 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v6(20);\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v7 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v7(20);\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v8 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v8(20);\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v9 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v9(20);\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v10 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v10(20);\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v11 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v11(20);\n    }\n\n}\n\nclass PersonList {\n    \n    static class Person {\n        \n        Person(String name, int age, char g){\n            this.name \u003d name;\n            this.age \u003d age;\n            switch (g) {\n            case \u0027m\u0027: case \u0027M\u0027: gender \u003d Gender.MALE; break;\n            case \u0027f\u0027: case \u0027F\u0027: gender \u003d Gender.FEMALE; break;\n            default: gender \u003d Gender.NOTSPECIFIED;\n            }\n            emailAddress \u003d null;\n        }\n\n        Person(String name, int age, char g, String emailAddress){\n            this.name \u003d name;\n            this.age \u003d age;\n            switch (g) {\n            case \u0027m\u0027: case \u0027M\u0027: gender \u003d Gender.MALE; break;\n            case \u0027f\u0027: case \u0027F\u0027: gender \u003d Gender.FEMALE; break;\n            default: gender \u003d Gender.NOTSPECIFIED;\n            }\n            this.emailAddress \u003d emailAddress;\n        }\n\n        public String toString(){\n            return name + \u0026quot;, \u0026quot; + age +  \n                    ((gender !\u003d Gender.NOTSPECIFIED)? ((gender \u003d\u003d Gender.MALE)? \u0026quot;, male\u0026quot;: \u0026quot;, female\u0026quot;): \u0026quot;\u0026quot;) +\n                    ((emailAddress !\u003d null)? \u0026quot;, \u0026quot; +emailAddress: \u0026quot;\u0026quot;);\n        }\n        \n        String shortInfo() {\n            return name + \u0026quot;, \u0026quot; + age;\n        }\n        \n        int getAge(){\n            return age;\n        }\n        \n        String getNameMail(){\n            return name + \u0026quot;: \u0026quot; + emailAddress;\n        }\n        \n        static enum Gender{\n            MALE, FEMALE, NOTSPECIFIED\n        }\n        \n        String name;\n        int age;\n        Gender gender;\n        String emailAddress;\n    }\n    \n    PersonList() {\n        plst \u003d new ArrayList\u0026lt;\u0026gt;();\n        plst.add(new Person(\u0026quot;Alice\u0026quot;, 19, \u0027f\u0027));\n        plst.add(new Person(\u0026quot;Bob\u0026quot;, 20, \u0027m\u0027, \u0026quot;bob123@mail.com\u0026quot;));\n        plst.add(new Person(\u0026quot;Christin\u0026quot;, 21, \u0027f\u0027, \u0026quot;ch15@yz.com\u0026quot;));\n        plst.add(new Person(\u0026quot;Donald\u0026quot;, 18, \u0027z\u0027));\n        plst.add(new Person(\u0026quot;Edvard\u0026quot;, 19, \u0027m\u0027));\n        plst.add(new Person(\u0026quot;Ann\u0026quot;, 20, \u0027z\u0027, \u0026quot;annemail\u0026quot;));\n        plst.add(new Person(\u0026quot;Alan\u0026quot;, 22, \u0027m\u0027, \u0026quot;kh@amazon.com\u0026quot;));\n        plst.add(new Person(\u0026quot;Sarah\u0026quot;, 18, \u0027f\u0027));\n    }\n    \n    void addLast(Person p){\n        plst.add(p);\n    }\n        \n    void printList(PrintStream out) {\n        for (Person p: plst) {\n            out.println(p.toString());\n        }\n    }\n    \n    void printShortList(PrintStream out){\n        for (Person p: plst){\n            out.println(p.shortInfo());\n        }\n    }\n    \n    void printUpToAge(PrintStream out, int age) {\n        for (Person p: plst){\n            if (p.age \u0026lt;\u003d age){\n                out.println(p.name);\n            }\n        }\n    }\n    \n    void printInAgeRange(PrintStream out, int low, int high) {\n        for (Person p: plst){\n            if ((low \u0026lt;\u003d p.age) \u0026amp;\u0026amp; (p.age \u0026lt;\u003d high)){\n                out.println(p.name);\n            }\n        }\n    }\n        \n    void printSelectPerson_v1(PrintStream out, CheckPerson checker){\n        for (Person p: plst) {\n            if (checker.test(p)){\n                out.println(p.name);\n            }\n        }\n    }\n\n    void printSelectPerson_v2(PrintStream out, Predicate\u0026lt;Person\u0026gt; tester){\n        for (Person p: plst){\n            if (tester.test(p)){\n                out.println(p.name);\n            }\n        }\n    }\n    \n    void processSelectPerson_v3(Predicate\u0026lt;Person\u0026gt; tester, Consumer\u0026lt;Person\u0026gt; handler){\n        for (Person p: plst){\n            if (tester.test(p)){\n                handler.accept(p);\n            }\n        }\n    }\n    \n    void processSelectPersonData_v1(Predicate\u0026lt;Person\u0026gt; tester, Function\u0026lt;Person, String\u0026gt; getdata, Consumer\u0026lt;String\u0026gt; handler){\n        for (Person p: plst){\n            if (tester.test(p)){\n                String data \u003d getdata.apply(p);\n                handler.accept(data);\n            }\n        }\n    }\n    \n    void processSelectPersonData_v2(int age){\n        plst.stream()\n            .filter(p -\u0026gt; p.age \u0026lt;\u003d age)\n            .map(Person::getNameMail)\n            .forEach(System.out::println);\n    }\n    \n    List\u0026lt;Person\u0026gt; plst;\n}\n\ninterface CheckPerson {\n    \n    boolean test(PersonList.Person p);\n    \n}\n\n\nclass TestUpToAge implements CheckPerson {\n    \n    TestUpToAge(int uta) {\n        upToAge \u003d uta;\n    }\n    \n    public boolean test(PersonList.Person p){\n        if (p.age \u0026lt;\u003d upToAge) return true;\n        return false;\n    }\n    \n    int upToAge;\n}\n\nclass PersonListUser {\n    \n    PersonListUser(PersonList pl){\n        personList \u003d pl;\n    }\n    \n    void printToAge_v1(int age){\n        personList.printUpToAge(System.out, age);\n    }\n    \n    void printToAge_v2(int age){\n        TestUpToAge tuta \u003d new TestUpToAge(age);\n        personList.printSelectPerson_v1(System.out, tuta);\n    }\n    \n    void printToAge_v3(int age){\n        personList.printSelectPerson_v1(System.out, new TestUpToAge(age));\n    }\n    \n    void printToAge_v4(int age){\n        personList.printSelectPerson_v1(System.out, new CheckPerson() {\n            public boolean test(PersonList.Person p){\n                if(p.age \u0026lt;\u003d age) return true;\n                return false;\n            }\n        });\n    }\n    \n    void printToAge_v5(int age){\n        personList.printSelectPerson_v1(System.out, \n                (PersonList.Person p) -\u0026gt; (p.age \u0026lt;\u003d age));\n    }\n    \n    void printToAge_v6(int age){\n        personList.printSelectPerson_v2(System.out, \n                new Predicate\u0026lt;PersonList.Person\u0026gt;() {\n                    public boolean test(PersonList.Person p){\n                        if (p.age \u0026lt;\u003d age) return true;\n                        return false;\n                    }\n                });\n    }\n    \n    void printToAge_v7(int age){\n        personList.printSelectPerson_v2(System.out, \n                (PersonList.Person p) -\u0026gt; (p.age \u0026lt;\u003d age));\n        \n    }\n    \n    void printToAge_v8(int age){\n        personList.processSelectPerson_v3(\n                (PersonList.Person p) -\u0026gt; (p.age \u0026lt;\u003d age), \n                (PersonList.Person p) -\u0026gt; System.out.println(p.name));\n    }\n    \n    void printToAge_v9(int age){\n        personList.processSelectPersonData_v1(\n                p -\u0026gt; (p.age \u0026lt;\u003d age), \n                p -\u0026gt; p.getNameMail(), \n                email -\u0026gt; System.out.println(email));\n    }\n    \n    void printToAge_v10(int age){\n        personList.processSelectPersonData_v1(\n                p -\u0026gt; (p.age \u0026lt;\u003d age), \n                PersonList.Person::getNameMail, \n                System.out::println);\n    }\n    \n    void printToAge_v11(int age){\n        personList.processSelectPersonData_v2(age);\n    }\n    \n    PersonList personList;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПоследний метод демонстрирует использование потоков (stream). \u003c/p\u003e\u003cp\u003eБолее подробный пример с использованием stream ниже. \u003cbr /\u003e Основной источник материалов (и вдохновения, поскольку некоторые вещи изменены / переделаны) к примеру и небольшому описанию лямбда-выражений, функциональных интерфейсов и потоков данных — лекция из курса по Java на stepik.org (\u0026quot;Java. Базовый курс\u0026quot;, \u003ca href\u003d\"https://stepik.org/course/187/syllabus?module\u003d6\"\u003e6 часть\u003c/a\u003e). \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e\u003cbr /\u003eimport java.math.BigInteger;\nimport java.util.Comparator;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntUnaryOperator;\nimport java.util.stream.IntStream;\n\npublic class TestStream {\n\n    public static void main(String[] args) {\n        ProbeFI pfi \u003d new ProbeFI();\n        pfi.effi();\n        pfi.stfi();\n        pfi.cmpfi();\n        pfi.opttest();\n        \n        ProbeStream ps \u003d new ProbeStream();\n        ps.demo1();\n        ps.demo2();\n        ps.testFP();\n    }\n\n}\n\nclass ProbeFI {\n    \n    void effi() {\n        int added \u003d 10;\n        IntUnaryOperator adder \u003d x -\u0026gt; x + added;\n        \n        System.out.println(adder.applyAsInt(5));\n        \n        //added++;\n        \n        int [] counter \u003d new int[] {0};\n        IntSupplier seq \u003d () -\u0026gt; counter[0]++;\n        seq.getAsInt();\n        System.out.println(counter[0]);\n        \n    }\n    \n    void stfi() {\n        IntPredicate isOdd \u003d x -\u0026gt; x % 2 !\u003d 0;\n        IntPredicate isEven \u003d isOdd.negate();\n        IntPredicate cmb \u003d isOdd.or(isEven);\n        System.out.println(cmb.test(5));\n    }\n    \n    void cmpfi() {\n        Function\u0026lt;Double, Double\u0026gt; sinx \u003d Math::sin;\n        Function\u0026lt;Double, Double\u0026gt; square \u003d x -\u0026gt; x*x;\n        Function\u0026lt;Double, Double\u0026gt; first \u003d sinx.andThen(square);\n        Function\u0026lt;Double, Double\u0026gt; second \u003d sinx.compose(square);\n        \n        Comparator\u0026lt;Double\u0026gt; absValCmp \u003d Comparator.comparing(Math::abs, Double::compare);\n        double f \u003d first.apply(Math.PI/8);\n        double s \u003d second.apply(Math.PI/8);\n        if (absValCmp.compare(f, s) \u0026lt; 0){\n            System.out.println(f + \u0026quot; \u0026quot; + s);\n        }\n        else {\n            System.out.println(\u0026quot;!\u0026quot; + s + \u0026quot; \u0026quot; + f);\n        }\n    }\n    \n    void opttest() {\n        String str \u003d \u0026quot;text\u0026quot;;\n        Optional\u0026lt;String\u0026gt; optstr \u003d Optional.of(\u0026quot;text\u0026quot;);\n        \n        optstr.ifPresent(System.out::println);\n        \n        optstr \u003d Optional.empty();\n        str \u003d optstr.orElse(\u0026quot;test\u0026quot;);\n        System.out.println(str);\n    }\n    \n}\n\nclass ProbeStream {\n    \n    void demo1() {\n        int sum \u003d IntStream.iterate(1, n -\u0026gt; n+1)\n                           .filter(n -\u0026gt; n % 5 \u003d\u003d 0 \u0026amp;\u0026amp; n % 2 !\u003d 0)\n                           .limit(10)\n                           .map(n -\u0026gt; n*n)\n                           .sum();\n        System.out.println(sum);\n    }\n    \n    \n    void demo2() {\n        IntFunction\u0026lt;Character\u0026gt; ci \u003d c -\u0026gt; Character.toChars(c)[0];\n        System.out.println(ci.apply(48));\n        \n        IntStream ist \u003d IntStream.iterate(1, x -\u0026gt; x + 1);\n        ist\n           .map(x -\u0026gt; x*x*x)\n           .filter(n -\u0026gt; n \u0026gt; 500)\n           .mapToObj(Integer::toString)\n           .flatMapToInt(s -\u0026gt; s.chars())           \n           .distinct()           \n           .mapToObj(ci)\n           .skip(3)           \n           .limit(2) \n           .sorted()\n           .forEach(System.out::println);\n           \n    }\n    \n    \n    BigInteger factBI (int n) {\n            return IntStream.rangeClosed(1, n)\n                            .mapToObj(i -\u0026gt; BigInteger.valueOf(i))\n                            .reduce(BigInteger.ONE, BigInteger::multiply);\n    }\n    \n     boolean isPalindrome(String s) {\n             StringBuilder leftToRight \u003d new StringBuilder();\n             \n             s.chars().filter(Character::isLetterOrDigit)\n                      .map(Character::toLowerCase)\n                      .forEach(leftToRight::appendCodePoint);\n            \n             StringBuilder rightToLeft \u003d new StringBuilder(leftToRight).reverse();\n             \n             return leftToRight.toString().equals(rightToLeft.toString());                 \n     }\n    \n     void testFP(){\n         System.out.println(factBI(8));\n         System.out.println(isPalindrome(\u0026quot;A Roza upala na lapu Azora\u0026quot;));\n     }\n    \n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eФункциональные интерфейсы — интерфейсы, которые содержат единственный абстрактный метод. При этом интерфейсы могут содержать статические методы и поля (в любых количествах, это не влияет на их \u0026quot;функциональность\u0026quot;). \u003cbr /\u003e Функциональные интерфейсы помечаются аннотацией \u003ccode\u003e@FunctionalInterface\u003c/code\u003e. Описаны они в пакете java.util.function. Все функциональные интерфейсы могут быть параметризованы любым объектным типом, а для примитивных типов существуют специализированные функциональные интерфейсы (некоторые из них мы будем упоминать далее).\u003c/p\u003e\u003cp\u003eВсего функциональных интерфейсов более четырех десятков, и их можно поделить на пять групп. Коротко о группах:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eConsumer (потребитель); имеет метод, который что-то принимает, но ничего не возвращает (в случае одного параметра — void accept(T t), в случае двух параметров — BiConsumer\u0026lt;T, U\u0026gt;, метод void accept (T t, U u); для примитивных типов — IntConsumer, LongConsumer, DoubleConsumer)\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eSupplier (поставщик); имеет метод, который ничего не принимает, но возвращает некое значение (метод T get()) (для примитивных типов BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier).\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003ePredicate (предикат); имеет метод, который что-то принимает, а возвращает значение булева типа (в случае одного параметра — boolean test(T t), в случае двух параметров — BiPredicate\u0026lt;T, U\u0026gt; и boolean test(T t, U u) соответственно; для примитивных типов — IntPredicate, LongPredicate, DoublePredicate).\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eFunction\u0026lt;T, R\u0026gt; (функция); имеет метод, принимающий аргумент одного типа (T) и возвращающий значение другого типа (R) (в случае одного параметра — R apply(T t), в случае двух параметров BiFunction\u0026lt;T, U, R\u0026gt; и R apply (T t, U u); для примитивных типов есть разные конструкции — в зависимости от того, является ли примитивным типом тип аргумента или / и тип результата: DoubleFunction (T apply(double d)), LongToIntFunction (int apply(long d)), ToIntFunction (int apply(T t)) и т.д.)\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eOperator (оператор); частный случай функции, когда аргумент и результат одного и того же типа (UnaryOperator, BinaryOperator\u0026lt;T, T\u0026gt;, а также интерфейсы для примитивных типов: IntUnaryOperator, IntBinaryOperator, LongUnaryOperator, LongBinaryOperator, DoubleUnaryOperator, DoubleBinaryOperator)\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eКак и \u0026quot;обычные\u0026quot; интерфейсы, функциональные интерфейсы можно реализовывать как в именованных, так и в анонимных классах. Однако то, что по сути необходимо реализовать единственный метод, позволяет отказаться от достаточно объемного кода классов и воспользоваться лямбда-выражениями. Примеры:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e    IntUnaryOperator square \u003d x -\u0026gt; x * x;\n\n    IntUnaryOperator cube \u003d x -\u0026gt; {return x * x * x;}\n\n    IntConsumerPrint print \u003d x -\u0026gt; System.out.print(x);\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ лямбда-выражениях могут использоваться и внешние по отношению к ним переменные, однако при этом переменная должна быть \u0026quot;эффективной константой\u0026quot;. Поясним это на фрагменте кода:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e  int add \u003d 10;\n  IntUnaryOperator adder \u003d x -\u0026gt; x + add;\n  add \u003d add + 1; // не скомпилируется\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЭто требование связано с поддержкой параллелизма — предполагается, что лямбда-выражения могут вычисляться параллельно, поэтому изменение значения переменной, используемой в них, может привести к нежелательным эффектам. Вообще говоря, такую переменную можно было бы сразу объявлять с модификатором final, предполагающим, что она не поменяет своего значения после инициализации. Однако в языке разрешено не указывать такой модификатор, если переменная де-факто не будет изменять своего значения.\u003c/p\u003e\u003cp\u003eОднако это требование может доставить определенные неудобства в тех случаях, когда лямбда-выражения удобно использовать для изменения переменных. Один из возможных \u0026quot;обходных путей\u0026quot; состоит в том, чтобы объявить массив, содержащий один элемент. Собственно переменная-массив будет эффективной константой (точнее, ссылка на массив), а вот содержимое элементов массива может меняться. \u003cbr /\u003e Пример кода:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e  int [] counter \u003d new int[] {0}; \n  IntSupplier seq \u003d () -\u0026gt; counter[0]++;\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ качестве лямбда-выражений могут также использоваться ссылки на методы (method references). Например:\u003c/p\u003e\u003cp\u003e\u003ccode\u003eConsumer\u0026lt;Object\u0026gt; printer \u003d System.out::println\u003c/code\u003e\u003c/p\u003e\u003cp\u003eПри этом, если метод статический, можно ссылаться на него через имя класса, а если нестатический — то через имя объекта (как в примере). Можно даже составить ссылку на конструктор, однако там имеются некоторые тонкости, о которых можно получить представление из документации и иных материалов (в том числе из уже упоминавшейся части 6 курса по Java на stepik.org)\u003c/p\u003e\u003cp\u003eВыше мы уже говорили, что помимо единственного абстрактного (нестатического) метода, функциональные интерфейсы могут иметь еще статические методы. Например, в группе интерфейсов-предикатов есть методы, реализующие привычные логические операции. Например:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e  IntPredicate isOdd \u003d x -\u0026gt; x % 2 !\u003d 0;\n  IntPredicate isEven \u003d isOdd.negate();\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНаряду с методом \u003ccode\u003enegate()\u003c/code\u003e также определены методы \u003ccode\u003eand()\u003c/code\u003e и \u003ccode\u003eor()\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eДля интерфейсов из группы Consumer\u0027ов определен метод \u003ccode\u003eandThen()\u003c/code\u003e, позволяющий выполнить сначала одно, а затем другое действие. Метод \u003ccode\u003eandThen()\u003c/code\u003e определен также и для интерфейсов-функций, но у этих интерфейсов есть еще метод \u003ccode\u003ecompose()\u003c/code\u003e, который сначала выполняет второе действие, а затем уже — первое. Пример применения описан в коде в методе \u003ccode\u003ecmpfi()\u003c/code\u003e (см. выше). Также рекомендуется обратить внимание на то, как в этом методе описан компаратор. Приведем более \u0026quot;привычную\u0026quot; запись этого компаратора:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e  Comparator\u0026lt;Double\u0026gt; absValComp \u003d \n     (a, b) -\u0026gt; Double.compare(Math.abs(a), Math.abs(b));\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТеперь несколько слов о \u0026quot;маленькой, но важной\u0026quot; вещи — типах Optional. Класс Optional — это своего рода \u0026quot;контейнер\u0026quot; для одного объекта типа T (какой положим). Что важно — объект в контейнере может отсутствовать; в Optional описан метод get(), который первым делом проверяет, не будет ли хранимое значение value \u003d\u003d null и, если там все же null, сгенерирует исключение.\u003c/p\u003e\u003cp\u003eПочему возникла потребность в таком типе? Когда есть некий объектный тип (например, тот же String), то бывает неочевидно (особенно в больших проектах), разрешено ли этому значению быть null (т.е. надо ли null как-то обрабатывать). До класса Optional каких-либо стандартных решений не было, в сторонних библиотеках предлагались решения в виде аннотаций @Nullable и @NonNull, но поскольку это именно сторонние библиотеки, компилятор о них не знал и отследить ничего не мог (т.е. не контролировал, скажем, присвоение null переменной, помеченной как @NonNull).\u003c/p\u003e\u003cp\u003eТипичное использование класса Optional продемонстрировано в методе \u003ccode\u003eopttest()\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eНаконец, поговорим о классе Stream (мы будем предпочитать англоязычное название, поскольку название \u0026quot;поток\u0026quot; уже весьма прочно закрепилось за thread). \u003c/p\u003e\u003cp\u003eКлассы Stream содержатся в пакете java.util.stream, все они — параметризуемые. Кроме собственно класса Stream еще есть классы IntStream, LongStream, DoubleStream, поддерживающие работу с соответствующими примитивными типами. \u003c/p\u003e\u003cp\u003eМожно рассматривать Stream как последовательность элементов, к которой можно применять разные преобразования (ко всей последовательности \u0026quot;одновременно\u0026quot;). \u003c/p\u003e\u003cp\u003eStream — не коллекция, где все элементы доступны по отдельности и можно оперировать каждым из них независимо. Stream предлагает рассматривать данные как \u0026quot;единый поток\u0026quot;, в котором ко всем элементам применяется одна и та же операция (есть детали, о них чуть позже). \u003cbr /\u003e В какой-то мере можно было бы сравнить Stream с итератором по коллекции, но итератор мало что умеет — просто ходить по коллекции и выдавать элементы. А у Stream много методов, он умеет с элементами работать, хотя и довольно специфически (с точки зрения человека, привыкшего к императивному программированию).\u003c/p\u003e\u003cp\u003eДалее, коллекция хранит некое конечное количество элементов, а Stream может быть потенциально бесконечным. \u003c/p\u003e\u003cp\u003eКоллекция позволяет изменять элементы и изменять свой собственный состав (удалять / добавлять элементы). А применение операции к Stream никак на него не влияет \u003c/p\u003e\u003cp\u003eПосмотрим на пример работы со stream из метода \u003ccode\u003edemo1()\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e    int sum \u003d IntStream.iterate(1, n -\u0026gt; n + 1)\n                       .filter(n -\u0026gt; n % 5 \u003d\u003d 0 \u0026amp;\u0026amp; n % 2 !\u003d 0)\n                       .limit(10)\n                       .map(n -\u0026gt; n*n) \n                       .sum();\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНазвания здесь \u0026quot;говорящие\u0026quot;. Сначала получаем собственно Stream — бесконечный ряд натуральных чисел (начало с 1, далее задано правило получения следующего элемента из предыдущего). \u003cbr /\u003e Заметим, что операции в stream\u0027ах — \u0026quot;ленивые\u0026quot;, т.е. пока не ясно, зачем что-то считать, ничего вычисляться не будет. Поэтому наш бесконечный ряд натуральных чисел не более, чем соглашение о намерениях. \u003c/p\u003e\u003cp\u003eДалее каждый метод в цепочке описывает какое-то преобразование над stream\u0027ом. Метод \u003ccode\u003efilter()\u003c/code\u003e, принимающий некий предикат, оставляет в stream\u0027е лишь те элементы, которые удовлетворяют условию. Далее метод \u003ccode\u003elimit()\u003c/code\u003e обрезает нашу \u0026quot;условно бесконечную\u0026quot; последовательность данных, оставляя в ней 10 первых элементов. Затем каждый из элементов потока заменяется его квадратом (метод \u003ccode\u003emap\u003c/code\u003e как раз выполняет это отображение).\u003c/p\u003e\u003cp\u003eНаконец, метод \u003ccode\u003esum()\u003c/code\u003e складывает все имеющиеся элементы потока (и формирует результат вычисления). Фактически именно этот метод дает старт вычислениям, до того никаких действий над элементами потока не производится.\u003c/p\u003e\u003cp\u003eОписание этого примера демонстрирует три этапа работы со stream:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eполучение stream\u0027а (т.е. собственно последовательности данных)\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eноль или более промежуточных операций преобразования (они просто запоминаются, но ничего не делается)\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eединственная терминальная операция, которая и запускает процесс вычислений.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eВажно понимать, что использовать терминальную операцию можно только один раз, после ее вызова stream более \u0026quot;непригоден к использованию\u0026quot;; если потребуется выполнить еще какую-либо терминальную операцию, stream понадобится создать заново.\u003c/p\u003e\u003cp\u003eВообще говоря, может понадобиться закрывать stream, вызвав его метод .close(). Однако если никаких системных ресурсов при работе stream\u0027а не выделялось, то вызов .close() не является обязательным (а если бы мы работали, например, с файлами, то это было бы нужно сделать).\u003c/p\u003e\u003cp\u003eНекоторые дополнения по каждому из этапов. \u003c/p\u003e\u003cp\u003eПо первому этапу. \u003c/p\u003e\u003cp\u003eПолучить stream можно из коллекции (или массива) при помощи метода stream(). Кроме него есть и другие методы, которые возвращают stream в качестве результата своей работы. Например, в классе \u003ccode\u003eBufferedReader\u003c/code\u003e есть метод \u003ccode\u003elines()\u003c/code\u003e, который возвращает поток из строк (более того, есть метод, позволяющий получить список директорий в виде потока); в классе \u003ccode\u003eString\u003c/code\u003e есть метод \u003ccode\u003echars()\u003c/code\u003e, который возвращает поток символов, однако в виде \u003ccode\u003eIntStream\u003c/code\u003e (потока CharStream не существует, как можно с этим \u0026quot;бороться\u0026quot; — показано в методе \u003ccode\u003edemo2()\u003c/code\u003e. \u003cbr /\u003e Также stream можно получить, задав правила формирования его элементов с помощью методов \u003ccode\u003egenerate()\u003c/code\u003e, \u003ccode\u003eiterate()\u003c/code\u003e (как в методе \u003ccode\u003edemo1()\u003c/code\u003e), \u003ccode\u003erange()\u003c/code\u003e, \u003ccode\u003erangeClosed()\u003c/code\u003e, определенных в некоторых классах \u0026quot;семейства\u0026quot; Stream, или просто явным образом перечислив его элементы (\u003ccode\u003eIntStream ist \u003d IntStream.of(2, 4, 6, 8);\u003c/code\u003e). \u003cbr /\u003e Это все еще не полный список способов получения stream. Следует добавить, что потоки можно соединять путем конкатенации. \u003c/p\u003e\u003cp\u003eПо второму этапу. \u003c/p\u003e\u003cp\u003eПосмотрим еще раз на метод \u003ccode\u003edemo2()\u003c/code\u003e, в котором использовано достаточно большое количество промежуточных операций (операций преобразования). \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e        ist\n           .map(x -\u0026gt; x*x*x)\n           .filter(n -\u0026gt; n \u0026gt; 500)\n           .mapToObj(Integer::toString)\n           .flatMapToInt(s -\u0026gt; s.chars())           \n           .distinct()           \n           .mapToObj(ci)\n           .skip(3)           \n           .limit(2) \n           .sorted()\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДадим краткие комментарии по поводу использованных методов (подробнее о них можно прочесть в документации / статьях / книгах).\u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003emap()\u003c/code\u003e заменяет каждый элемент потока так, как задано переданной функцией. В нашем случае происходит замена каждого элемента (а элементы — последовательно перечисленные натуральные числа) на его куб (куб числа, как очевидно, тоже число). Кроме того мы можем видеть метод \u003ccode\u003emapToObj()\u003c/code\u003e — он преобразует числа в их строковое представление, именно поэтому нам понадобился именно \u003ccode\u003emapToObj()\u003c/code\u003e, способный сопоставить элементам IntStream элементы другого (объектного) типа. \u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003eflatMapToInt()\u003c/code\u003e делает следующее: каждая строка — элемент stream (после выполнения \u003ccode\u003emapToObj()\u003c/code\u003e мы имеем дело уже со stream, состоящим из элементов типа String) — преобразуется в IntStream, состоящий из кодов символов, составляющих эту строку; после чего все полученные IntStream \u0026quot;склеиваются\u0026quot; в один. Метод \u003ccode\u003eflatMapToInt()\u003c/code\u003e присоединяет очередной полученный IntStream к концу уже имеющегося. \u003c/p\u003e\u003cp\u003eОбсуждая методы, связанные с отображением, мы не упомянули метод \u003ccode\u003efilter\u003c/code\u003e, однако, как представляется, его назначение вполне прояснилось еще из обсуждения метода \u003ccode\u003edemo1()\u003c/code\u003e: он оставляет в потоке лишь те элементы, которые удовлетворяют условию-предикату.\u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003edistinct()\u003c/code\u003e выбрасывает из потока повторяющиеся элементы.\u003c/p\u003e\u003cp\u003eЕще один вызов метода \u003ccode\u003emapToObj()\u003c/code\u003e позволяет нам получить целые числа вместо цифр в символьном представлении.\u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003eskip()\u003c/code\u003e пропускает указанное количество элементов из начала потока.\u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003elimit()\u003c/code\u003e ограничивает наш поток указанным количеством элементов.\u003c/p\u003e\u003cp\u003eНаконец, метод \u003ccode\u003esorted()\u003c/code\u003e упорядочивает содержимое потока \u0026quot;естественным образом\u0026quot; (для чисел \u0026quot;естественным образом\u0026quot; означает по возрастанию). \u003c/p\u003e\u003cp\u003eЗаметим, что есть еще не использованный здесь, но полезный метод \u003ccode\u003epeek()\u003c/code\u003e. Он принимает объект типа Consumer и показывает, что находится у нас в stream. Если передать в качестве такого объекта \u003ccode\u003eSystem.out::println\u003c/code\u003e, то метод будет выводить на экран \u0026quot;промежуточные результаты\u0026quot;. \u003c/p\u003e\u003cp\u003eПо третьему этапу.\u003c/p\u003e\u003cp\u003eМы уже использовали в примерах терминальные операции \u003ccode\u003esum()\u003c/code\u003e и \u003ccode\u003eforEach()\u003c/code\u003e. Их назначение очевидно: \u003ccode\u003esum()\u003c/code\u003e складывает все элементы потока, а \u003ccode\u003eforEach()\u003c/code\u003e выполняет указанную операцию над всеми элементами потока. \u003c/p\u003e\u003cp\u003eИмеется еще ряд терминальных операций, перечислим некоторые из них. \u003cbr /\u003e - Метод \u003ccode\u003efindFirst()\u003c/code\u003e возвращает первый (в порядке следования) элемент из stream (заметим, что возвращается элемент типа Optional, т.к. stream может быть пустой, и никакого элемента в нем нет. \u003cbr /\u003e - Метод \u003ccode\u003efindAny()\u003c/code\u003e возвращает какой-нибудь элемент из stream (не факт, что первый, но не исключено, что первый) \u003cbr /\u003e\u003cbr /\u003e- Метод \u003ccode\u003eallMatch()\u003c/code\u003e проверяет, что все элементы stream удовлетворяют условию, переданному в качестве предиката (т.е. результатом выполнения метода будет некоторое булево значение) \u003cbr /\u003e - Метод \u003ccode\u003eanyMatch()\u003c/code\u003e проверяет, что хотя бы один элемент удовлетворяет условию \u003cbr /\u003e - Метод \u003ccode\u003enoneMatch()\u003c/code\u003e проверяет, что ни один элемент не удовлетворяет условию  \u003cbr /\u003e - Методы \u003ccode\u003emin()\u003c/code\u003e и \u003ccode\u003emax()\u003c/code\u003e принимают в качестве параметра какой-либо компаратор и возвращают результат типа Optional, где T — тип, параметризующий stream \u003cbr /\u003e - Метод \u003ccode\u003ecount()\u003c/code\u003e возвращает количество элементов в stream \u003cbr /\u003e - Метод \u003ccode\u003ecollect()\u003c/code\u003e позволяет собрать элементы, полученные stream, в какую-то коллекцию, причем тип коллекции определяется параметром, передаваемым в \u003ccode\u003ecollect()\u003c/code\u003e. Например, \u003ccode\u003ecollect(Collectors.toList())\u003c/code\u003e позволит получить List. Заметим, что в классе Collectors есть многие \u0026quot;стандартные\u0026quot; коллекторы, а также метод .collector(), который может \u0026quot;собрать\u0026quot; элементы stream так, как потребуется. - Метод \u003ccode\u003ereduce()\u003c/code\u003e позволяет выполнить так называемую свертку, т.е. применить некоторую бинарную операцию к каждой паре элементов из stream. Применяться эта операция будет до тех пор, пока в stream не останется один элемент, и именно он станет результатом работы этого метода. Можно задать значение, которое будет возвращаться, если stream был пуст (некое \u0026quot;нулевое\u0026quot; значение), например:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e   Stream\u0026lt;BigInteger\u0026gt; bigInts \u003d ... // каким-то образом получили такой stream\n   BigInteger sum \u003d bigInts.reduce(BigInteger.ZERO, BigInteger::add);\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТакже в коде приведены два метода — \u003ccode\u003efactBI()\u003c/code\u003e и \u003ccode\u003eisPalindrome()\u003c/code\u003e — показывающие, как с помощью stream посчитать факториал и проверить, не является ли некоторая строка палиндромом. Примеры заимствованы из лекции А.Владыкина, на которую выше уже была ссылка.\u003c/p\u003e\u003cp\u003eКонечно, в данном обзорном материале мы лишь познакомились с лямбда-выражениями и классами Stream. Мы совершенно не затрагивали аспекты параллельного выполнения stream, особенности формирования ссылок на методы и ряд других вещей. Однако представляется, что данное введение в эту тему позволит при необходимости успешно разобраться в более сложных темах. \u003c/p\u003e\u003cp\u003eИсключительные ситуации\u003c/p\u003e\u003cp\u003eС исключительными ситуациями до сих пор мы сталкивались при работе со StreamTokenizer и с файлами. Чаще всего потенциальная исключительная ситуация пропускалась на уровень JVM, никакой иной обработки не предполагалось. Конечно, использование исключительных ситуаций не ограничивается таким подходом, это достаточно мощный и полезный инструмент. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eИсключительные ситуации и их классификация\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЧто такое исключительная ситуация (или, более коротко, исключение)? — Это некоторое событие, происходящее во время выполнения программы и нарушающее \u0026quot;естественный ход\u0026quot; её выполнения. Конечно, если случилось что-то фатальное с точки зрения программы / операционной системы / компьютера — лучшим решением может оказаться прервать выполнение программы. Но, вполне возможно, что получится обойтись и без этого: например, если программа пытается прочитать данные из несуществующего файла, то стоит сообщить об этом пользователю и предложить ему указать другой файл для чтения.\u003c/p\u003e\u003cp\u003eИсключительные ситуации подразделяются на контролируемые (checked) и неконтролируемые (unchecked) (иногда говорят \u0026quot;проверяемые\u0026quot; и \u0026quot;непроверяемые\u0026quot;). Контролируемые исключения — это как раз те, которые можно и нужно обрабатывать в программе. Их можно попытаться \u0026quot;предсказать\u0026quot; на этапе компиляции программы. Действительно, если вы планируете выполнять уже упоминавшееся чтение из файла, это явно написано в программе — вы создаете объект, способный читать данные, принимающий имя файла в качестве параметра.\u003c/p\u003e\u003cp\u003eРазумеется, не все контролируемые исключительные ситуации связаны с работой с файлами, но нужно отметить, что исключительные ситуации, связанные с операциями ввода / вывода, встречаются достаточно часто. Часть исключительных ситуаций связана с работой с потоками (о них — в следующей записи). Поэтому необходимо, чтобы исключительные ситуации были классифицированы — тогда анализ объекта-исключения позволит сформировать адекватную реакцию. \u003c/p\u003e\u003cp\u003eНужно сказать, что Java очень трепетно относится к операциям, являющимся \u0026quot;потенциальными источниками\u0026quot; исключений, и принуждает программиста написать код, обрабатывающий ту или иную исключительную ситуацию. Впрочем, создатели Java предусмотрели возможность передачи обработки исключений из метода, в котором оно возникает, на уровень выше. Напомним, что самым высоким уровнем является JVM (передать обработку исключений на уровень JVM может метод \u003ccode\u003emain()\u003c/code\u003e — и мы этим неоднократно пользовались). В JVM предусмотрена очень примитивная обработка исключений — информирование о них пользователя без ожидания какой-либо его реакции, поэтому отдавать обработку исключений на уровень JVM имеет смысл только в определённых случаях. Это приемлемый подход, к примеру, когда можно считать, что данные, которые подаются на вход программы, всегда корректны (т.е. наверняка проверяются перед тем как будут переданы в программу — это как раз случай хорошо подготовленной задачи с соревнований). Впрочем, хорошим правилом является обработка исключительных ситуаций.\u003c/p\u003e\u003cp\u003eВсе исключительные ситуации наследуют классу \u003ccode\u003eThrowable\u003c/code\u003e. Если совсем точно, у \u003ccode\u003eThrowable\u003c/code\u003e есть два наследника — \u003ccode\u003eError\u003c/code\u003e и \u003ccode\u003eException\u003c/code\u003e, а среди подклассов \u003ccode\u003eException\u003c/code\u003e следует выделить \u003ccode\u003eRuntimeException\u003c/code\u003e, у которого особое назначение (но об этом чуть позже). Разница между \u003ccode\u003eError\u003c/code\u003e и \u003ccode\u003eException\u003c/code\u003e достаточно наглядно описана \u003ca href\u003d\"http://javaconceptoftheday.com/difference-between-error-vs-exception-in-java/\"\u003eздесь\u003c/a\u003e (это не единственный полезный материал на этом сайте).\u003c/p\u003e\u003cp\u003eОшибки (\u003ccode\u003eError\u003c/code\u003e) и исключения времени выполнения (\u003ccode\u003eRuntimeException\u003c/code\u003e) являются неконтролируемыми, остальные исключения относятся к контролируемым.\u003c/p\u003e\u003cp\u003eОшибка (\u003ccode\u003eError\u003c/code\u003e) в большинстве случаев свидетельствует о каких-то серьезных проблемах, возникших в \u0026quot;окружении\u0026quot; программы — например, исчерпана память, которую может выделить приложению JVM. Восстановление после ошибки невозможно. Прогнозирование возникновения ошибки, как понятно, тоже невозможно. Также понятно, что ошибки возникают во время выполнения программы. Однако между ошибками и исключениями времени выполнения существует заметная разница.\u003c/p\u003e\u003cp\u003eИсключения времени выполнения (\u003ccode\u003eRuntimeException\u003c/code\u003e) возникают во время \u0026quot;нормального\u0026quot; выполнения программы. В отличие от ошибок, они являются \u0026quot;внутренним делом\u0026quot; программы, но, как и ошибки, обычно их невозможно (нереально) предвидеть, и восстановить работу программы после того, как они произойдут, нельзя.\u003c/p\u003e\u003cp\u003eНапример, есть класс \u003ccode\u003eInputMismatchException\u003c/code\u003e — такая исключительная ситуация произойдёт, например, когда при вводе вместо числа пользователь напечатает строку. Исключительная ситуация \u003ccode\u003eArithmeticException\u003c/code\u003e может случиться по причине деления на ноль, а при попытке преобразовать строку в число, если эта строка числом не является, вы увидите сообщение о \u003ccode\u003eNumberFormatException\u003c/code\u003e. Вероятно, стоит упомянуть \u003ccode\u003eNullPointerException\u003c/code\u003e — если обратиться к динамической структуре данных, память для которой не выделена, можно увидеть сообщение именно об этой ошибке. Ещё одна (хорошо знакомая вам) исключительная ситуация — \u003ccode\u003eArrayIndexOutOfBoundsException\u003c/code\u003e, возникающая, когда вы пытаетесь обратиться к элементу с индексом, превосходящим размер массива. \u003c/p\u003e\u003cp\u003e\u003cbr /\u003e \u003cstrong\u003eОбработка исключительных ситуаций\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЕсли исключительная ситуация относится к классу контролируемых исключительных ситуаций, то рано или поздно она должна быть обработана (даже если мы пропускаем эту ИС вплоть до виртуальной машины Java, ИС будет обработана именно там). \u003c/p\u003e\u003cp\u003eОбработка выполняется с помощью оператора \u003ccode\u003etry\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etry {\n    \u0026lt;операторы\u0026gt;\n}\n[\u0026lt;блок catch\u0026gt;]\n...\n[\u0026lt;блок catch\u0026gt;]\n[\u0026lt;блок finally\u0026gt;]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНи блоки catch, ни блок finally не являются обязательными (что и отражено заключением их в квадратные скобки). Но хотя бы один блок catch или блок finally в операторе \u003ccode\u003etry\u003c/code\u003e должны присутствовать.\u003c/p\u003e\u003cp\u003eБлок catch, который часто называют обработчиком исключительной ситуации, имеет следующий вид:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ecatch (\u0026lt;тип - подкласс Throwable\u0026gt; \u0026lt;имя переменной\u0026gt;) {\n    \u0026lt;операторы\u0026gt;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКак можно видеть, типом исключения может быть любой наследник класса \u003ccode\u003eThrowable\u003c/code\u003e. Так, можно попробовать \u0026quot;поймать\u0026quot; исключение выхода за границы массива. Хотя оно и относится к неконтролируемым, тем не менее написать что-то вроде\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ecatch (IndexOutOfBoundsException e) {\n    System.err.println(\u0026quot;IndexOutOfBoundsException: \u0026quot; + e.getMessage());\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eвполне можно, и если в блоке try произойдёт выход за границы массива, возникшая исключительная ситуация будет \u0026quot;поймана\u0026quot; (во время выполнения, конечно) этим блоком catch.\u003c/p\u003e\u003cp\u003eГлавное, что следует помнить, — при проходе по блокам catch, когда их несколько, выбирается \u0026quot;первый подходящий\u0026quot;. Т.е. если сначала мы напишем обработку ИС типа \u003ccode\u003eRuntimeException\u003c/code\u003e, а потом, в блоке, расположенном ниже, — обработку ИС типа \u003ccode\u003eIndexOutOfBoundException\u003c/code\u003e, то в блок, расположенный ниже, мы никогда не попадём. Поэтому обработчики ИС располагают по принципу \u0026quot;от частного к общему\u0026quot;.\u003c/p\u003e\u003cp\u003eПример создания собственной исключительной ситуации.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eimport java.util.Scanner;\n\npublic class MyException {\n\n\tpublic static void main(String[] args) {\n\t\tDemoTimeException dte \u003d new DemoTimeException();\n\t\tdte.test();\n\t}\n\n}\n\n\nclass TimeParseException extends Exception {\n\t\n\tprivate static final long serialVersionUID \u003d 1L;\n\n\tpublic TimeParseException(String msg){\n\t\tsuper(msg);\n\t}\n\t\n\tpublic TimeParseException(String msg, int pos){\n\t\tsuper(msg + \u0026quot; at \u0026quot; + pos + \u0026quot; position\u0026quot;);\n\t}\n\t\n\tpublic TimeParseException(String msg, int pos, int val){\n\t\tsuper(msg + \u0026quot; \u0026quot; + val + \u0026quot; started at \u0026quot; + pos + \u0026quot; position\u0026quot;);\n\t}\n\t\n}\n\nclass TimeReader {\n\t\n\tTimeReader(String stime){\n\t\ttimestring \u003d stime;\n\t\thh \u003d mm \u003d ss \u003d -1;\n\t}\n\t\n\tvoid parse() throws TimeParseException {\n\t\tif (timestring.length() \u0026gt; TSIZE) \n\t\t\tthrow new TimeParseException(\u0026quot;time format is: HH:MM:SS, this string is too long\u0026quot;);\n\t\t\n\t\tif (timestring.length() \u0026lt; TSIZE) \n\t\t\tthrow new TimeParseException(\u0026quot;time format is: HH:MM:SS, this string is too short\u0026quot;);\n\t\t\n\t\tint first \u003d (int) timestring.charAt(0) - ZERO;\n\t\tif (!((0 \u0026lt;\u003d first) \u0026amp;\u0026amp; (first \u0026lt;\u003d 2)))\n\t\t\tthrow new TimeParseException(\u0026quot;hour must be in 0..24 interval, but wrong symbol\u0026quot;, 1);\n\t\t\n\t\tint second \u003d (int)timestring.charAt(1) - ZERO;\n\t\tif (!(0 \u0026lt;\u003d second) \u0026amp;\u0026amp; (second \u0026lt;\u003d 9))\n\t\t\tthrow new TimeParseException(\u0026quot;hour must be in 0..24 interval, but wrong symbol\u0026quot;, 2);\n\t\t\n\t\thh \u003d first * 10 + second;\n\t\tif (!((0 \u0026lt;\u003d hh) \u0026amp;\u0026amp; (hh \u0026lt;\u003d 23)))\n\t\t\tthrow new TimeParseException(\u0026quot;hour must be in 0..24 interval, but value wrong: \u0026quot;, 1, hh);\n\t\t\n\t\thm \u003d timestring.charAt(2);\n\t\tif (hm !\u003d COLON)\n\t\t\tthrow new TimeParseException(\u0026quot;hours and minutes must be divided with colon, but wrong symbol \u0026quot;, 3);\n\t\t\n\t\tfirst \u003d (int) timestring.charAt(3) - ZERO;\n\t\tif (!((0 \u0026lt;\u003d first) \u0026amp;\u0026amp; (first \u0026lt;\u003d 5)))\n\t\t\tthrow new TimeParseException(\u0026quot;minutes must be in 0..59 interval, but wrong symbol\u0026quot;, 4);\n\t\t\n\t\tsecond \u003d (int)timestring.charAt(4) - ZERO;\n\t\tif (!((0 \u0026lt;\u003d second) \u0026amp;\u0026amp; (second \u0026lt;\u003d 9)))\n\t\t\tthrow new TimeParseException(\u0026quot;minutes must be in 0..59 interval, but wrong symbol\u0026quot;, 5);\n\t\t\n\t\tmm \u003d first * 10 + second;\n\t\tif (!((0 \u0026lt;\u003d mm) \u0026amp;\u0026amp; (mm \u0026lt;\u003d 59)))\n\t\t\tthrow new TimeParseException(\u0026quot;minutes must be in 0..59 interval, but value wrong: \u0026quot;, 4, mm);\n\t\t\n\t\tms \u003d timestring.charAt(5);\n\t\tif (ms !\u003d COLON)\n\t\t\tthrow new TimeParseException(\u0026quot;colon must be between minutes and seconds, but wrong symbol\u0026quot;, 6);\n\n\t\tfirst \u003d (int) timestring.charAt(6) - ZERO;\n\t\tif (!((0 \u0026lt;\u003d first) \u0026amp;\u0026amp; (first \u0026lt;\u003d 5)))\n\t\t\tthrow new TimeParseException(\u0026quot;seconds must be in 0..59 interval, but wrong symbol\u0026quot;, 7);\n\t\t\n\t\tsecond \u003d (int)timestring.charAt(7) - ZERO;\n\t\tif (!((0 \u0026lt;\u003d second) \u0026amp;\u0026amp; (second \u0026lt;\u003d 9)))\n\t\t\tthrow new TimeParseException(\u0026quot;seconds must be in 0..59 interval, but wrong symbol\u0026quot;, 8);\n\t\t\n\t\tss \u003d first * 10 + second;\n\t\tif (!(0 \u0026lt;\u003d mm) \u0026amp;\u0026amp; (mm \u0026lt;\u003d 59))\n\t\t\tthrow new TimeParseException(\u0026quot;seconds must be in 0..59 interval, but value wrong: \u0026quot;, 7, ss);\n\t\t\n\t}\n\t\n\tpublic String toString(){\n\t\tString res \u003d ((hh \u0026lt; 10)? \u0026quot;0\u0026quot;: \u0026quot;\u0026quot;) + hh  + \u0026quot; hrs \u0026quot; \n\t\t\t\t\t+ ((mm \u0026lt; 10)? \u0026quot;0\u0026quot;: \u0026quot;\u0026quot;) + mm + \u0026quot; min \u0026quot; + ((ss \u0026lt; 10)? \u0026quot;0\u0026quot;: \u0026quot;\u0026quot;) + ss + \u0026quot; sec \u0026quot;;\n\t\tif (ss \u003d\u003d -1){\n\t\t\tres \u003d \u0026quot;Input data \u0026quot; + timestring + \u0026quot; does not parse as correct time\u0026quot;;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tString timestring;\n\tint hh;\n\tint mm;\n\tint ss;\n\tchar hm;\n\tchar ms;\n\t\n\tstatic final int ZERO \u003d (int)\u00270\u0027;\n\tstatic final int TSIZE \u003d 8;\n\tstatic final char COLON \u003d \u0027:\u0027;\n}\n\nclass DemoTimeException {\n\t\n\tvoid test() {\n\t\tTimeReader tr;\n\t\t\n\t\tfor (String s: ts){\n\t\t\ttr \u003d new TimeReader(s);\n\t\t\ttry {\n\t\t\t\ttr.parse();\n\t\t\t}\n\t\t\tcatch (TimeParseException ex){\n\t\t\t\tSystem.out.println(ex.getMessage());\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tSystem.out.println(tr);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tString [] ts \u003d {\u0026quot;23:04:59\u0026quot;, \u0026quot;32:56:21\u0026quot;, \u0026quot;00:00:00\u0026quot;, \u0026quot;01:23:5\u0026quot;, \u0026quot;02 24 56\u0026quot;, \u0026quot;*3:51:22\u0026quot;, \u0026quot;14:5f:dc\u0026quot;, \n\t\t\t\u0026quot;14:65:32\u0026quot;, \u0026quot;14:42:74\u0026quot;};\n\t\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПотоки Threads\u003c/p\u003e\u003cp\u003eКод примеров, которые приводились на лекциях по потокам (threads). \u003c/p\u003e\u003cp\u003eПример первый\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003epublic class PingPongDemo {\n\n\tpublic static void main(String[] args) {\n\t\tThreadTest t1 \u003d new ThreadTest(\u0026quot;ping\u0026quot;, 33);\n\t\tThreadTest t2 \u003d new ThreadTest(\u0026quot;PONG\u0026quot;, 100);\n\t\tt1.start();\n\t\tt2.start();\n\t}\n\n}\n\n\nclass ThreadTest extends Thread {\n\t\n\tThreadTest(String name, int d) {\n\t\tsuper(name);\n\t\tdelay \u003d d;\n\t\trepeat \u003d (int)(Math.random() * 10);\n\t}\n\t\n\t@Override\n\tpublic void run(){\n\t\tfor (int i \u003d 0; i \u0026lt; repeat; i++) {\n\t\t\ttry {\n\t\t\t\tSystem.out.println(getName() + \u0026quot; засыпает\u0026quot;);\n\t\t\t\tThread.sleep(delay);\n\t\t\t}\n\t\t\tcatch (InterruptedException e){\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\n\t\t\tSystem.out.println(getName() + \u0026quot; просыпается\u0026quot;);\n\t\t}\t\n\t}\n\t \n\tprivate int delay;\n\tprivate int repeat;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПример второй:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e\u003cbr /\u003epublic class DeadlockDemo {\n\n\tpublic static void main(String[] args) {\n\t\tfinal Friend alice \u003d new Friend(\u0026quot;Alice\u0026quot;);\n\t\tfinal Friend bob \u003d new Friend(\u0026quot;Bob\u0026quot;);\n\t\t\n\t\tnew Thread(new Runnable(){\n\t\t\tpublic void run(){\n\t\t\t\tbob.sayHello(alice);\n\t\t\t}\n\t\t}).start();;\n\t\t\n//\t\tnew Thread(new Runnable(){\n//\t\t\tpublic void run(){\n//\t\t\t\talice.sayHello(bob);\n//\t\t\t}\n//\t\t}).start(); \n\n\t}\n\n}\n\nclass Friend {\n\t\n\tFriend (String name) {\n\t\tthis.name \u003d name;\n\t}\n\t\n\tpublic synchronized void sayHello(Friend friend) {\n\t\tSystem.out.printf(\u0026quot;Hello, %s%n\u0026quot;, friend.name);\n\t\tfriend.sayAnswer(this);\n\t}\n\t\n\tpublic synchronized void sayAnswer(Friend friend){\n\t\tSystem.out.printf(\u0026quot;Hello, %s. How are yoy?%n\u0026quot;, friend.name);\t\t\n\t}\n\t\n\tString name;\n\t\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПример третий:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eimport java.util.Random;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class SafeLockDemo {\n\n\tpublic static void main(String[] args) {\n\t\tBowerFriend alice \u003d new BowerFriend(\u0026quot;Alice\u0026quot;);\n\t\tBowerFriend bob \u003d new BowerFriend(\u0026quot;Bob\u0026quot;);\n\n\t\tnew Thread(new BowLoop(bob, alice)).start();;\n\t\tnew Thread(new BowLoop(alice, bob)).start();;\n\t}\n\n}\n\nclass BowLoop implements Runnable {\n\t\n\tBowLoop(BowerFriend bf1, BowerFriend bf2){\n\t\tbower1 \u003d bf1;\n\t\tbower2 \u003d bf2;\n\t}\n\t\n\tpublic void run() {\n\t\tRandom rnd \u003d new Random();\n\t\tfor (;;) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(rnd.nextInt(MC));\n\t\t\t}\n\t\t\tcatch (InterruptedException ie){\n\t\t\t\t// nothing \n\t\t\t}\n\t\t\tbower1.bow(bower2);\n\t\t}\n\t}\n\t\n\tBowerFriend bower1;\n\tBowerFriend bower2;\n\tstatic final int MC \u003d 10;\n}\n\nclass BowerFriend {\n\t\n\tBowerFriend (String name) {\n\t\tthis.name \u003d name;\n\t}\n\t\n\tString getName(){\n\t\treturn this.name;\n\t}\n\t\n\tLock getLock(){\n\t\treturn this.lock;\n\t}\n\t\n\tboolean prepareBow(BowerFriend friend){\n\t\tboolean tlock \u003d false;\n\t\tboolean flock \u003d false;\n\t\ttry {\n\t\t\ttlock \u003d lock.tryLock();\n\t\t\tflock \u003d friend.getLock().tryLock();\n\t\t}\n\t\tfinally {\n\t\t\tif (!(tlock \u0026amp;\u0026amp; flock)){\n\t\t\t\tif (tlock){\n\t\t\t\t\tlock.unlock();\n\t\t\t\t}\n\t\t\t\tif (flock){\n\t\t\t\t\tfriend.getLock().unlock();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn (tlock \u0026amp;\u0026amp; flock);\n\t}\n\t\n\tpublic void bow(BowerFriend friend) {\n\t\tif (prepareBow(friend)){\n\t\t\ttry {\n\t\t\t\tSystem.out.printf(\u0026quot;Hello, %s! How are you?%n\u0026quot;, friend.getName());\n\t\t\t\tfriend.backBow(this);\t\t\t\t\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tlock.unlock();\n\t\t\t\tfriend.getLock().unlock();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSystem.out.printf(\u0026quot;%s already says \\\u0026quot;Hello!\\\u0026quot; to %s\u0026quot;, this.getName(), friend.getName());\n\t\t}\n\t\t\n\t}\n\t\n\tpublic void backBow(BowerFriend friend){\n\t\tSystem.out.printf(\u0026quot;Hello, %s! I am just fine! How are yoy?%n\u0026quot;, friend.getName());\t\t\n\t}\n\t\n\tString name;\n\tprivate final Lock lock \u003d new ReentrantLock();\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["разное"]}}