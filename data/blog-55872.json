{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1511076745,"rating":0,"authorHandle":"TripleM5da","modificationTimeSeconds":1511078567,"id":55872,"title":"\u003cp\u003eMentor\u0027s Weekly Contest #5 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eUse this Editorial Wisely.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTest cases\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003ethe Problem Says in a given array we need to count the number of ranges where the numbers that occur odd number of times are equal one, Constructing an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e solution is easy enough we just need an array to count the occurrences of the values and if the number of values with odd occurrence is 1 we add to our answer the problem is that the values are really big \u003cspan class\u003d\"tex-span\"\u003e ≤ \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e so a good idea would be to Compress the array meaning array \u003cspan class\u003d\"tex-span\"\u003e[6, 4, 5]\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e -  \u0026gt; \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e[2, 0, 1]\u003c/span\u003e and that\u0027s it.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eImplementation\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\nusing namespace std;\nvector\u0026lt;int\u0026gt;a;\nvector\u0026lt;int\u0026gt;v;\nint sv[5005];\nint n;\n\nint main(){\n  freopen(\u0026quot;cases.in\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int t;\n  cin \u0026gt;\u0026gt; t;\n  while(t--){\n    cin \u0026gt;\u0026gt; n;\n    v.clear();\n    a.resize(n);\n    // enter the array\n    for(int i \u003d 0; i \u0026lt; n; i++)cin \u0026gt;\u0026gt; a[i], v.push_back(a[i]);\n    // compress it to new values\n    sort(v.begin(), v.end());\n    v.resize(unique(v.begin(), v.end())-v.begin());\n    for(int i \u003d 0; i \u0026lt; n; i++)a[i] \u003d lower_bound(v.begin(), v.end(),a[i]) - v.begin();\n    int ans \u003d 0;\n    for(int i \u003d 0; i \u0026lt; n; i++){\n      int cnt \u003d 0;\n      memset(sv, 0, sizeof sv);\n\n      for(int j \u003d i; j \u0026lt; n; j++){\n        sv[a[j]]++;\n        //updating number of occurrences\n        if(sv[a[j]]\u0026amp;1)cnt++;\n        else cnt--;\n        if(cnt \u003d\u003d 1)\n          ans++;\n      }\n\n    }\n\n    cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0027\\n\u0027;\n\n\n  }\n\n\n  return 0;\n}\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eEfficiency Test\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003e//TODO\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eWinning Cells\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eWe can Simplify the Problem into two separate nim games where at position \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e we play with 2 piles of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e now we need to know the wining nim games the wining nim games are games where ( \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emod\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e + 1)\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exor\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emod\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e + 1)\u003c/span\u003e ) is not equal to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e so a better idea is to find the losing games and subtract them from the total games so a basic idea would be to get the number of pairs \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e where ( \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emod\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e + 1)\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e \u003d \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emod\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e + 1)\u003c/span\u003e ) so that their \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exor\u003c/i\u003e\u003c/span\u003e is equal to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e.\u003c/p\u003e\u003cp\u003enow for some maths using \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e we can make every pile from \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e and if we think about it our answer would be \u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/dc/b5/dcb5d3e9b09b1dc3a15db2f512df77877a916eb5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003ewe need to focus that sum of these numbers occur \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e / (\u003ci\u003ek\u003c/i\u003e + 1)\u003c/span\u003e times and others occur \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e / (\u003ci\u003ek\u003c/i\u003e + 1) + 1\u003c/span\u003e with some thinking you will find that the numbers that occur \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e / (\u003ci\u003ek\u003c/i\u003e + 1) + 1\u003c/span\u003e times are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emod\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e + 1)\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e + \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e now what is left are just basic maths.\u003c/p\u003e\u003cp\u003ereferences: \u003ca href\u003d\"https://math.stackexchange.com/questions/512266/multi-pile-nim-where-you-can-only-take-up-to-n-objects-strategy\"\u003ehttps://math.stackexchange.com/questions/512266/multi-pile-nim-where-you-can-only-take-up-to-n-objects-strategy\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eImplementation\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\nusing namespace std;\nlong long n, k;\nint main(){\n\n    freopen(\u0026quot;chess.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int t;\n    cin \u0026gt;\u0026gt; t;\n\n    while(t--){\n\n      cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k;\n\n      long long ans \u003d n * n;\n      k++;\n      n--;\n      long long cur \u003d n / k;\n      long long lft \u003d n % k;\n      ans -\u003d ((lft+1) * (cur+1) * (cur+1));\n      ans -\u003d ((cur) * (cur) * (k-(lft+1)));\n\n      cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0027\\n\u0027;\n\n    }\n\n\n\n}\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eBacteria Experiment\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003ethe problem in short is we haver a tree graph and every step if there is a two nodes that are not directly connected but the distance between them is 2 then connect them as wee can see the distance between any 2 nodes decreases by half every step so the number of steps would be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8f/61/8f61503bb0a1f84f65a5a74cf9ab8f706ef6940a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eImplementation\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\n\nusing namespace std;\n\nint n;\nvector\u0026lt;int\u0026gt;adj[500005];\nint u, v;\n\npair\u0026lt;int, int\u0026gt; dfs(int u, int p, int lvl){\n\n    auto ans \u003d pair\u0026lt;int, int\u0026gt;(lvl, u);\n\n    for(auto v : adj[u])if(v !\u003d p)\n        ans \u003d max(ans, dfs(v, u, lvl + 1));\n\n    return ans;\n}\n\nint main(){\n\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\n    for(int i \u003d 0; i \u0026lt; n - 1; i++){\n\n        scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;u, \u0026amp;v);\n\n        u--, v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n\n    }\n\n    auto x \u003d dfs(0, 0, 0);\n    auto y \u003d dfs(x.second, x.second, 0);\n\n\n    cout \u0026lt;\u0026lt; ceil(log2(y.first))\u0026lt;\u0026lt; \u0027\\n\u0027;\n\n\n\n    return 0 ;\n}\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eAmbiguous Dates\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eWe need to find the Minimum Number of Dates that can Collide with each other where there are pair \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e and pair \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ey\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e and both are satisfied in this calender now it\u0027s obvious that we should sort the array since it\u0027s optimal to place the smallest for example we know that pair \u003cspan class\u003d\"tex-span\"\u003e(2, 1)\u003c/span\u003e will appear so we should avoid pair \u003cspan class\u003d\"tex-span\"\u003e(1, 2)\u003c/span\u003e now to count the the number of Dates we need to know for every \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e the minimum between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e (the number of days left in the month) and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e (the number of months left).\u003c/p\u003e\u003cp\u003eand add 2 multiply that number to count \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e and (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eImplementation\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N \u003d 1e6 + 5;\n\nint n, a[N];\n\nint main(){\n\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\n    for(int i \u003d 0; i \u0026lt; n; i++)\n        scanf(\u0026quot;%d\u0026quot;, a + i);\n\n    sort(a,a+n);\n    ll ans\u003d0;\n    for(int i\u003d0;i\u0026lt;n;i++){\n        int l\u003dmin(n-i,a[i]-i);\n        if(l\u0026lt;\u003d0)continue;\n        ans+\u003d(2*(l-1));\n    }\n    cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\n}\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}