{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1517801042,"rating":-3,"authorHandle":"arvindr9","modificationTimeSeconds":1517801197,"id":57548,"title":"\u003cp\u003eFinding the two closest elements of the a given letter c in a grid of n cells\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eIn pllk\u0027s Competitive Programmer\u0027s Handbook, there is a section about square root algorithms. The section about combining algorithms to create a better algorithm (27.1) describes a problem to find, given a grid of n cells, two cells of the same character that have the closest taxicab distance to each other (|x_1 — x_2| + |y_1 — y_2|). \u003c/p\u003e\u003cp\u003eThe picture of an example grid can be seen here: \u003ca\u003ehttps://www.dropbox.com/s/fetsm4d06dhvwso/grid.PNG?dl\u003d0](https://www.dropbox.com/s/fetsm4d06dhvwso/grid.PNG?dl\u003d0\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThere is a sub-problem, which is finding the shortest distance between two cells of the same character c (where c is given). The algorithm described in the book is to do a breadth-first search by starting at all characters with value c simultaneously. How exactly would the BFS work? How would you tell the distance between two characters? I feel if you do a standard bfs, you can never reach a cell of the value c from another cell of the value c since the cells surrounding each c will have already been processed in the first step of bfs. Can someone clarify how the bfs will work in this situation?\u003c/p\u003e\u003cp\u003eThe bfs algorithm is mentioned in algorithm 2 of the Case Processing section of section 27.1 in this link: \u003ca href\u003d\"https://cses.fi/book.pdf\"\u003ehttps://cses.fi/book.pdf\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThanks!\u003c/p\u003e\u003c/div\u003e","tags":["bfs","parallel algorithm"]}}