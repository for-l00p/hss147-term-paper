{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1413749801,"rating":52,"authorHandle":"ifsmirnov","modificationTimeSeconds":1413752876,"id":14353,"title":"\u003cp\u003eОпять об оптимизациях, или Сколько будет от нуля до трех\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eДебагая хеш-таблицу, я вчера наткнулся на очередное забавное проявление оптимизатора g++. Вот минимальный код, на котором я смог его воспроизвести.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n\nint main() {\n    for (int i \u003d 0; i \u0026lt; 4; ++i) {\n        std::cout \u0026lt;\u0026lt; i*1000000000 \u0026lt;\u0026lt; std::endl;\n    }   \n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКазалось бы, вывод предсказуем. Более того, без оптимизации это действительно так. Однако...\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eifsmirnov@carbon:./tmp$ g++-4.8 a.cpp -O2 \u0026amp;\u0026amp; ./a.out  | head -n 10\n0\n1000000000\n2000000000\n-1294967296\n-294967296\n705032704\n1705032704\n-1589934592\n-589934592\n410065408\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eИ так бесконечно долго.\u003c/p\u003e\u003cp\u003eЛогическая цепочка оптимизатора понятна: по стандарту переполнение инта при умножении -- это UB, значит, можно делать всё, что угодно. Но во что превратилось условие остановки цикла, я так и не понял.\u003c/p\u003e\u003cp\u003eУ меня это воспроизводится на g++-4.8 c -O2 и выше. На 4.4, 4.6 и 4.7, clang-3.4 выводятся четыре числа даже с любыми уровнями оптимизации.\u003c/p\u003e\u003cp\u003eИнтересно, что по этому поводу думает MinGW, а также почему все-таки происходит этот эффект.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD:\u003c/strong\u003e если заменить cout на printf, «баг» не вылезает.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD2:\u003c/strong\u003e продолжаем развлекаться. Если вместо вывода делать push_back в вектор, баг вылезает. Если же вместо этого написать свой «вектор», то можно поймать нетривиальный warning.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdlib\u0026gt;\n\nstruct MyVector {\n    int *a;\n    int cap;\n    int n;\n    MyVector() {\n        cap \u003d 1;\n        n \u003d 0;\n        a \u003d (int*)malloc(sizeof(int) * cap);\n    }   \n    void push_back(int x) {\n        if (n \u003d\u003d cap) {\n            cap *\u003d 2;\n            a \u003d (int*)realloc((void*)a, sizeof(int) * cap);\n        }   \n        a[n++] \u003d x;\n    }   \n};\n\nint main() {\n    MyVector a;\n    for (int i \u003d 0; i \u0026lt; 4; ++i) {\n        a.push_back(i * 1000000000);\n    }   \n}\n\nb.cpp: In function ‘int main()’:\nb.cpp:24:35: warning: iteration 2u invokes undefined behavior [-Waggressive-loop-optimizations]\n         a.push_back(i * 1000000000);\n                                   ^\nb.cpp:23:5: note: containing loop\n     for (int i \u003d 0; i \u0026lt; 4; ++i) {\n     ^\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["ub","c++"]}}