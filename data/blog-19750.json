{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1439412111,"rating":21,"authorHandle":"Neodym","modificationTimeSeconds":1439477689,"id":19750,"title":"\u003cp\u003eЭффективное вычисление определителя на языке Java\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eДобрый вечер!\u003c/p\u003e\u003cp\u003eНедавно я столкнулся со следующей проблемой: в процессе решения некой задачи мне понадобилось считать определитель достаточно специфичной матрицы:\u003c/p\u003e\u003cp\u003e1) Ее размер может быть до \u003cspan class\u003d\"tex-span\"\u003e600\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e2) Все ее элементы — целые числа из множества \u003cspan class\u003d\"tex-span\"\u003e{ - 1, 0, 1}\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e3) В любой ее строке и столбце не более \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e ненулевых элементов — то есть, она сильно разрежена (вообще говоря, это матрица смежности некого двудольного графа, но некоторые ребра взяты с минусом).\u003c/p\u003e\u003cp\u003eПритом определители надо подсчитать приблизительно у сотни таких матриц.\u003c/p\u003e\u003cp\u003eЯ скопировал код с e-maxx.ru, и переписал все на Java, но сомневаюсь в эффективности полученного кода. Детерминант, очевидно, может быть очень большим, из-за чего приходится пользоваться BigDecimal и BigInteger с округлениями. По всем этим причинам код работает жутко медленно и нуждается в оптимизации.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e public static BigInteger determinant(final int[][] matr) {\n\n        int accuracy \u003d 20;\n\n        BigDecimal EPS \u003d BigDecimal.valueOf(0.00000000001);\n\n        int n \u003d matr.length;\n        BigDecimal[][] a \u003d new BigDecimal[n][n];\n        for (int i \u003d 0; i \u0026lt; n; ++i)\n            for (int j \u003d 0; j \u0026lt; n; ++j) {\n                a[i][j] \u003d new BigDecimal(matr[i][j]);\n                a[i][j].setScale(accuracy, BigDecimal.ROUND_HALF_UP);\n            }\n\n        BigDecimal det \u003d new BigDecimal(1.0);\n        det.setScale(accuracy, BigDecimal.ROUND_HALF_UP);\n\n        for (int i \u003d 0; i \u0026lt; n; ++i) {\n            int k \u003d i;\n            for (int j \u003d i + 1; j \u0026lt; n; ++j)\n                if (a[j][i].abs().compareTo(a[k][i].abs()) \u0026gt; 0)\n                    k \u003d j;\n            if (a[k][i].abs().compareTo(EPS) \u0026lt; 0) {\n                det \u003d new BigDecimal(0.0);\n                det.setScale(accuracy, BigDecimal.ROUND_HALF_UP);\n                break;\n            }\n            BigDecimal[] tmp \u003d a[i];\n            a[i] \u003d a[k];\n            a[k] \u003d tmp;\n\n            if (i !\u003d k)\n                det \u003d det.divide(new BigDecimal(-1), accuracy, BigDecimal.ROUND_HALF_UP);\n            det \u003d det.multiply(a[i][i]);\n            for (int j \u003d i + 1; j \u0026lt; n; ++j)\n                a[i][j] \u003d a[i][j].divide(a[i][i], accuracy, BigDecimal.ROUND_HALF_UP);\n            for (int j \u003d 0; j \u0026lt; n; ++j)\n                if (j !\u003d i \u0026amp;\u0026amp; a[j][i].abs().compareTo(EPS) \u0026gt; 0)\n                    for (int kk \u003d i + 1; kk \u0026lt; n; ++kk) {\n                        BigDecimal aikji \u003d new BigDecimal(1.0);\n                        aikji.setScale(accuracy, BigDecimal.ROUND_HALF_UP);\n                        aikji \u003d aikji.multiply(a[i][kk]);\n                        aikji \u003d aikji.multiply(a[j][i]);\n                        aikji \u003d aikji.multiply(new BigDecimal(-1));\n                        a[j][kk] \u003d a[j][kk].add(aikji);\n                    }\n        }\n\n        det \u003d det.abs();\n        det \u003d det.add(new BigDecimal(0.00001));\n        return det.abs().toBigInteger();\n\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНа Java я начал писать сравнительно недавно, и, возможно, упускаю какие-то моменты для оптимизации. Может ли кто-нибудь дать совет по коду, или привести ссылку на уже реализованный оптимизированный алгоритм? \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD\u003c/strong\u003e. Из всех предложенных вариантов подошел следующий: так как для матрицы размера \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e × \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e ответ не превосходит \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e, то можно привести матрицу к верхнетреугольному виду, выполняя все вычисления по модулю \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eprime\u003c/i\u003e\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eprime\u003c/i\u003e\u003c/span\u003e — простое число битовой длины не менее \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e — найти его помогут встроенные функции \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eBigInteger\u003c/i\u003e\u003c/span\u003e. Скорость по сравнению с реализацией на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eBigDecimal\u003c/i\u003e\u003c/span\u003e возросла чуть ли не в десяток раз. \u003c/p\u003e\u003cp\u003eВот такие картинки получились благодаря алгоритму (увы, смазанные на этом сайте) :)\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/65/5b/655bd0c22ce0b56f84a146557dc72afc084f3771.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eКод, если кому-то будет интересен:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e   public static BigInteger determinant(final int[][] matr) {\n\n        int n \u003d matr.length;\n        BigInteger[][] a \u003d new BigInteger[n][n];\n        for (int i \u003d 0; i \u0026lt; n; ++i) {\n            for (int j \u003d 0;j  \u0026lt; n; ++j) {\n                a[i][j] \u003d BigInteger.valueOf(matr[i][j]);\n            }\n        }\n\n        BigInteger prime \u003d BigInteger.probablePrime(n + 4, new Random());\n\n        BigInteger det \u003d BigInteger.ONE;\n\n        for (int row \u003d 0; row \u0026lt; n; ++row) {\n            int currentRow \u003d row;\n            while (currentRow \u0026lt; n \u0026amp;\u0026amp; a[currentRow][row].equals(BigInteger.ZERO)) {\n                ++currentRow;\n            }\n            if (currentRow \u003d\u003d n) {\n                return BigInteger.ZERO;\n            }\n\n            if (currentRow !\u003d row) {\n                det \u003d det.negate();\n                BigInteger[] tmp \u003d a[currentRow];\n                a[currentRow] \u003d a[row];\n                a[row] \u003d tmp;\n            }\n\n            BigInteger inverse \u003d a[row][row].modInverse(prime);\n\n            for (currentRow \u003d row + 1; currentRow \u0026lt; n; ++currentRow) {\n                if (a[currentRow][row].equals(BigInteger.ZERO)) {\n                    continue;\n                }\n                BigInteger coefficient \u003d a[currentRow][row].multiply(inverse).remainder(prime);\n                for (int column \u003d row; column \u0026lt; n; ++column) {\n                    a[currentRow][column] \u003d a[currentRow][column].subtract(a[row][column].multiply(coefficient).remainder(prime)).remainder(prime);\n                }\n            }\n\n        }\n\n        for (int i \u003d 0; i \u0026lt; n; ++i) {\n            det \u003d det.multiply(a[i][i]).remainder(prime);\n        }\n        det \u003d det.add(prime);\n        det \u003d det.remainder(prime);\n        if (det.multiply(BigInteger.valueOf(2)).compareTo(prime) \u0026gt; 0) {\n            det \u003d prime.subtract(det).remainder(prime);\n        }\n        return det;\n    }\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["java","детерминант","оптимизация"]}}