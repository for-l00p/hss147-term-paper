{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1521197443,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1521203698,"id":58390,"title":"\u003cp\u003eВвод и вывод большого количества данных\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eНе исключено, что ваши решения некоторых задач на использование коллекций могут работать медленно, и это может быть связано не с неудачно выбранным алгоритмом, но и с необходимостью вводить или выводить большой объем данных (примерно — свыше \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e элементов). \u003ca href\u003d\"https://docs.oracle.com/javase/8/docs/api/index.html?java/util/Scanner.html\"\u003e\u003ccode\u003eScanner\u003c/code\u003e\u003c/a\u003e использует регулярные выражения и фактически выполняет каждый раз работу по распознаванию очередного элемента (методы \u003ccode\u003ehasNext...()\u003c/code\u003e), вывод (\u003ccode\u003eSystem.out\u003c/code\u003e) также идет поэлементно... \u003cbr /\u003e\u003c/p\u003e\u003ch4\u003eЧтение данных\u003c/h4\u003e\u003cp\u003eСначала обсудим, как прочитать данные. Один из наиболее общих инструментов — класс \u003ca href\u003d\"https://docs.oracle.com/javase/8/docs/api/java/io/StreamTokenizer.html\"\u003e\u003ccode\u003eStreamTokenizer\u003c/code\u003e\u003c/a\u003e (также Вы можете встретить комбинацию \u003ca href\u003d\"https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html\"\u003e\u003ccode\u003eBufferedReader\u003c/code\u003e\u003c/a\u003e и \u003ca href\u003d\"https://docs.oracle.com/javase/8/docs/api/java/util/StringTokenizer.html\"\u003e\u003ccode\u003eStringTokenizer\u003c/code\u003e\u003c/a\u003e; есть и другие решения, но они менее популярны).\u003c/p\u003e\u003cp\u003eМы напишем на основе \u003ccode\u003eStreamTokenizer\u003c/code\u003e небольшой класс, в котором будут реализованы методы чтения некоторых типов данных. Этот класс Вы можете включать в свои проекты (дописывать в конец файла с Вашим решением, например) и при необходимости дополнять.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass QuickInput {\n\n    QuickInput() throws IOException {\n        stk \u003d new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    }\n    \n    int nextInt() throws IOException {\n        stk.nextToken();\n        return (int)stk.nval;\n    }\n\n    double nextDouble() throws IOException {\n        stk.nextToken();\n        return stk.nval;\n    }\n\n    String next() throws IOException {\n        stk.nextToken();\n        return stk.sval;\n    }\n\n    StreamTokenizer stk;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПоясним приведенный выше код. Объект класса \u003ccode\u003eStreamTokenizer\u003c/code\u003e создается достаточно \u0026quot;хитрым\u0026quot; образом. Стандартный входной поток \u003ccode\u003eSystem.in\u003c/code\u003e сначала \u0026quot;заворачивается\u0026quot; в \u0026quot;конвертер\u0026quot; \u003ccode\u003eInputStreamReader\u003c/code\u003e, который служит \u0026quot;мостом\u0026quot; между байтовыми и символьными потоками (читает байты, преобразует их в символы). А затем эта конструкция \u0026quot;заворачивается\u0026quot; еще и в \u003ccode\u003eBufferedReader\u003c/code\u003e, который читает символьные потоки, оптимизируя чтение за счет использования буфера. Полученный результат передается уже в конструктор \u003ccode\u003eStreamTokenizer\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003ccode\u003eStreamTokenizer\u003c/code\u003e (с помощью метода \u003ccode\u003enextToken()\u003c/code\u003e) умеет вычитывать \u0026quot;токены\u0026quot; (лексически значимые единицы потока), среди которых он выделяет (вещественные) числа и слова. При этом его поле \u003ccode\u003ettype\u003c/code\u003e получает значение либо значение \u003ccode\u003eTT_NUMBER\u003c/code\u003e, либо значение \u003ccode\u003eTT_WORD\u003c/code\u003e. Соответственно заполняется либо поле \u003ccode\u003enval\u003c/code\u003e, либо поле \u003ccode\u003esval\u003c/code\u003e, откуда уже и забираются прочитанные значения.\u003c/p\u003e\u003cp\u003eВажно, что после создания объекта \u003ccode\u003eStreamTokenizer\u003c/code\u003e его можно перенастраивать удобным образом. Например, с точки зрения StreamTokenizer\u0027а, все цифры и дефис относятся к \u0026quot;числовым символам\u0026quot; и будут распознаваться именно так. Иногда это бывает неудобно, и нужно сделать так, чтобы эти символы включались в состав слова. Сделать это можно следующим образом: сначала объявить эти символы \u0026quot;обычными\u0026quot; (распознаваемыми как отдельные символы):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estk.ordinaryChars(\u00270\u0027,\u00279\u0027);\nstr.ordinaryChar(\u0027-\u0027);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПервый метод объявляет распознаваемыми как отдельные символы диапазон символов, второй — конкретный символ. После этого символы следует включить в список символов, распознаваемых как относящиеся к словам:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estk.wordChars(\u00270\u0027,\u00279\u0027);\nstk.wordChars(\u0027-\u0027,\u0027-\u0027);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eМетод \u003ccode\u003ewordChars()\u003c/code\u003e существует только в \u0026quot;редакции\u0026quot;, работающей с диапазоном, поэтому во втором вызове мы передаем этому методу диапазон из одного символа. После этого цифры с точки зрения \u003ccode\u003eStreamTokenizer\u003c/code\u003e перестанут образовывать числа и будут всегда включаться в состав слов или же считаться словами (т.е. помещаться в \u003ccode\u003esval\u003c/code\u003e после прочтения). \u003c/p\u003e\u003cp\u003eАналогичным образом можно поступать и с пробельными символами. Например, Вам известно, что в тексте есть какие-то символы, которым можно и нужно пропустить. Например, дана последовательность слов через запятую. Поскольку запятая пишется сразу же после букв, без пробела, она может быть включена в состав слова. Если же объявить ее пробельным символом с помощью метода \u003ccode\u003ewhitespaceChars()\u003c/code\u003e, запятые будут просто исключаться из рассмотрения.\u003c/p\u003e\u003cp\u003eЕсли какие-либо символы сделать с помощью метода \u003ccode\u003eordinaryChars()\u003c/code\u003e отдельно распознаваемыми, в поле \u003ccode\u003ettype\u003c/code\u003e будет просто помещаться их числовой код. Заметим, что если нужно сбросить значения всех символов, следует воспользоваться методом \u003ccode\u003eresetSyntax()\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eКроме чисел и слов \u003ccode\u003eStreamTokenizer\u003c/code\u003e умеет распознавать конец файла (когда метод \u003ccode\u003enextToken()\u003c/code\u003e возвращает значение \u003ccode\u003eTT_EOF\u003c/code\u003e, а также конец строки \u003ccode\u003eTT_EOLN\u003c/code\u003e. По умолчанию распознавание конца строки отключено — он воспринимается как один из видов пробельных символов. В случаях, когда нужно анализировать данные именно построчно, следует передать \u003ccode\u003etrue\u003c/code\u003e в метод \u003ccode\u003eeolIsSignificant()\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eОбратите внимание, что метод \u003ccode\u003enextToken()\u003c/code\u003e способен возбуждать исключение \u003ccode\u003eIOException\u003c/code\u003e. Пока мы не обсуждали, как обрабатываются исключительные ситуации; будем предполагать, что данные заведомо корректны и соответствуют описанию в условии задачи (для алгоритмических, \u0026quot;олимпиадных\u0026quot; задач это именно так; в реальных задачах с пользовательским вводом, конечно же, необходимо обеспечивать обработку разнообразных ошибок). В силу такого предположения будем пропускать (\u003ccode\u003ethrows\u003c/code\u003e) обработку исключений на уровень вызывающего метода (и, в конечном счете, на уровень JVM).\u003c/p\u003e\u003cp\u003eПри необходимости прочитанный символ можно \u0026quot;возвратить назад\u0026quot; с помощью метода \u003ccode\u003epushBack()\u003c/code\u003e (чтобы потом прочитать его еще раз). За остальными подробностями отсылаем к документации. \u003c/p\u003e\u003cp\u003eПриведем также краткое описание некоторых полезных технических приемов. \u003c/p\u003e\u003cp\u003e\u003ccode\u003eStreamTokenizer\u003c/code\u003e не \u0026quot;умеет\u0026quot; читать длинные целые числа: точность представления вещественных (\u003ccode\u003edouble\u003c/code\u003e) чисел не превосходит 16 знаков после запятой, а \u003ccode\u003elong\u003c/code\u003e может содержать до 18. Если нужно прочитать целые числа, выходящие за рамки типа \u003ccode\u003eint\u003c/code\u003e, с помощью \u003ccode\u003eStreamTokenizer\u003c/code\u003e, придется сначала прочитать их как строки, а затем уже вызвать метод класса \u003ccode\u003eLong\u003c/code\u003e для преобразования строки в длинное целое (\u003ccode\u003eLong.parseLong()\u003c/code\u003e, принимающий в качестве входного параметра строку). \u003c/p\u003e\u003cp\u003eАналогичным образом можно поступать, когда Вам требуется считать текст, содержащий различные буквенно-цифровые обозначения, в котором имеются и \u0026quot;отдельные числа\u0026quot;. Нет необходимости \u0026quot;переключать синтаксис\u0026quot;, можно прочитать число как строку и воспользоваться методом \u003ccode\u003eInteger.parseInt()\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eВ некоторых ситуациях наиболее разумный подход к считыванию состоит в считывании входных данных построчно. В этом случае возможности \u003ccode\u003eStreamTokenizer\u003c/code\u003e не нужны, достаточно создать экземпляр класса \u003ccode\u003eBufferedReader\u003c/code\u003e и использовать его метод \u003ccode\u003ereadLine()\u003c/code\u003e (также есть \u003ccode\u003elines()\u003c/code\u003e, Вы можете прочесть о нем в документации). \u003c/p\u003e\u003ch4\u003eВывод данных\u003c/h4\u003e\u003cp\u003eВывод данных тоже стоит выполнять \u0026quot;буферизованно\u0026quot;. Это позволяет делать, например, класс \u003ccode\u003ePrintWriter\u003c/code\u003e, который может послужить оберткой для \u003ccode\u003eSystem.out\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ePrintWriter out \u003d new PrintWriter(System.out);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ этом классе поддерживаются методы \u003ccode\u003eprint()\u003c/code\u003e, \u003ccode\u003eprintln()\u003c/code\u003e и \u003ccode\u003eprintf()\u003c/code\u003e; последний позволяет осуществлять форматированный вывод (достаточно подробно рассматривался во второй главе задачника; подробное описание разных строк форматирования можно найти в документации класса \u003ca href\u003d\"https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html\"\u003e\u003ccode\u003eFormatter\u003c/code\u003e\u003c/a\u003e). \u003c/p\u003e\u003cp\u003eПо завершении операций вывода следует выполнить очистку буфера и закрытие потока:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eout.flush();\nout.close();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОчистка буфера необходима, поскольку в нем может оставаться еще невыведенная информация; закрытие потока освобождает системные ресурсы (и фактически завершает операцию вывода). \u003c/p\u003e\u003cp\u003eПри выводе большого количества информации следует избегать формирования строк (это занимает и память, и время). Например, если Вам нужно вывести через пробел числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (предполагаем, что делать это нужно в цикле), то вместо \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eout.println(a[j] + \u0026quot; \u0026quot; + b[j]);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eстоит написать\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eout.print(a[j]);\nout.print(\u0026quot; \u0026quot;);\nout.println(b[j]);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ первом случае сначала будет сформирована сначала строка \u003ccode\u003ea[j] + \u0026quot; \u0026quot;\u003c/code\u003e, а затем строка \u003ccode\u003e(a[j] + \u0026quot; \u0026quot;) + b[j]\u003c/code\u003e; во втором же случае вывод будет выполняться по отдельности для каждого элемента без дополнительных преобразований и выделения памяти.\u003c/p\u003e\u003c/div\u003e","tags":["java","fast scanner"]}}