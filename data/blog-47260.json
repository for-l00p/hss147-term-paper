{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1474490410,"rating":21,"authorHandle":"codeonwort","modificationTimeSeconds":1474490410,"id":47260,"title":"\u003cp\u003eHaskell solution to 702E\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eEducational Round 15 — Problem 702E (Analysis of Pathes on Functional Graph): \u003ca href\u003d\"//codeforces.com/problemset/problem/702/E\"\u003ehttp://codeforces.com/problemset/problem/702/E\u003c/a\u003e \u003cbr /\u003eThe official editorial: \u003ca href\u003d\"//codeforces.com/blog/entry/46324?locale\u003den\"\u003ehttp://codeforces.com/blog/entry/46324?locale\u003den\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis article is not about another solution, but how to implement the solution that editorial provides with Haskell, \u003cem\u003eefficiently\u003c/em\u003e. After reading the editorial I tried to solve it with Haskell, but I got memory limit exceed on test 28: \u003ca href\u003d\"//codeforces.com/contest/702/submission/19550505\"\u003ehttp://codeforces.com/contest/702/submission/19550505\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst I wondered if my code is wrong, so I ported my Haskell code to C++ and it was accepted (0.7ms, 138MB): \u003ca href\u003d\"//codeforces.com/contest/702/submission/20682955\"\u003ehttp://codeforces.com/contest/702/submission/20682955\u003c/a\u003e\u003c/p\u003e\u003cp\u003eSo problem is the nature of Haskell — strong type system and rich expressivity at the cost of excessive memory usage and low performance. Clearly heavy memory usage came from all that state nodes. each state is an array of nodes. There can be at most 10^5 nodes and 34 states (k \u0026lt;\u003d 10^10 and 10^10 is 34 characters in binary representation).\u003c/p\u003e\u003cp\u003eEach node consists of \u003ccode\u003e(next node, total weight, minimum weight)\u003c/code\u003e — whose type is \u003ccode\u003eInt\u003c/code\u003e, \u003ccode\u003eInt64\u003c/code\u003e, and \u003ccode\u003eInt64\u003c/code\u003e respectively. In C++, this is (4+8+8 bytes) * 10^5 * 34 \u003d 64.85MB. How many memory is needed for a node in Haskell?\u003c/p\u003e\u003cp\u003e\u003ccode\u003etype Node \u003d (Int, Int64, Int64)\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003eNode\u003c/code\u003e has a bunch of pointers and wrappers so one \u003ccode\u003eNode\u003c/code\u003e consumes 10 words. (You can see Haskell types\u0027 memory footprints here: \u003ca href\u003d\"https://www.youtube.com/watch?v\u003d_pDUq0nNjhI\"\u003ehttps://www.youtube.com/watch?v\u003d_pDUq0nNjhI\u003c/a\u003e) A word is 8 bytes on a 64-bit machine, so one \u003ccode\u003eNode\u003c/code\u003e takes 80 bytes. To hold all states, we need 259MB. This is only for holding states. Other operations need their memory therefore memory limit (512MB) is exceeded. \u003c/p\u003e\u003cp\u003eTo save memory I unpacked all fields of \u003ccode\u003eNode\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e{-# LANGUAGE BangPatterns #-}\ndata Node \u003d Node {-# UNPACK #-} !Int {-# UNPACK #-} !Int64 {-# UNPACK #-} !Int64\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt removes all pointers and wrappers inside a \u003ccode\u003eNode\u003c/code\u003e. Regarding constructor overhead, now a \u003ccode\u003eNode\u003c/code\u003e takes 4 words \u003d 32 bytes. Now total states consume 103MB and total memory usage of the program is about 210MB. But it\u0027s not over. TLE on test 35 (n \u003d 10^5, k \u003d 10^10) :(\u003c/p\u003e\u003cp\u003eAgain what matters is Haskell\u0027s powerful feature; lazy evaluation. Our states are memory-heavy and they need a lot of numeric calculations. There is no unnecessary work and we have to utilize all of the evaluated results. This is not a place for lazy evaluation, but for strict evaluation.\u003c/p\u003e\u003cp\u003eTo force evaluation of states, I tried \u003ccode\u003eevaluate\u003c/code\u003e in the \u003ccode\u003eControl.Exception\u003c/code\u003e module: \u003ca href\u003d\"//codeforces.com/contest/702/submission/20793048\"\u003ehttp://codeforces.com/contest/702/submission/20793048\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003eevaluate :: a -\u0026gt; IO a\u003c/code\u003e\u003c/p\u003e\u003cp\u003eBut there was no improvement. Stucked here, I was going mad but realized that \u003ccode\u003eevaluate\u003c/code\u003e only evaluates to weak head normal form. To fully evaluate something we need \u003ccode\u003eforce\u003c/code\u003e in \u003ccode\u003eControl.DeepSeq\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eTo \u003ccode\u003eforce\u003c/code\u003e a \u003ccode\u003eNode\u003c/code\u003e, \u003ccode\u003eNode\u003c/code\u003e should be an instance of \u003ccode\u003eNFData\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport Control.DeepSeq\ninstance NFData Node where\n    rnf (Node a b c) \u003d rnf a `seq` rnf b `seq` rnf c\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFinally it was accepted (1.84s, 242MB): \u003ca href\u003d\"//codeforces.com/contest/702/submission/20805671\"\u003ehttp://codeforces.com/contest/702/submission/20805671\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWith all my efforts, My Haskell solution is 2.6 times slower than C++ one which I wrote quite easy. The problem\u0027s time constraint is 2 seconds and Haskell version took 1.84s. So tough!\u003c/p\u003e\u003cp\u003eThis problem made me give up to use Haskell on contests. Maybe I have to use Haskell only for practice :(\u003c/p\u003e\u003c/div\u003e","tags":[]}}