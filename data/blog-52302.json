{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1496264009,"rating":0,"authorHandle":"bssanches","modificationTimeSeconds":1496264009,"id":52302,"title":"\u003cp\u003eBFS\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eBfs resolve problemas do tipo: Qual o caminho mínimo entre A e B? Além disso BFS também tem varios outros usos (Assim como a DFS, você pode responder se existe um caminho de A até B)\u003c/p\u003e\u003cp\u003eLembrem-se que a BFS só serve pra achar caminho mínimo se os pesos da aresta forem 1! (Ou se todas tiverem o mesmo peso X)\u003c/p\u003e\u003cp\u003eArestas com pesos diferentes tem que usar um outro algoritmo que sera explicado na próxima semana :D \u003c/p\u003e\u003cp\u003eAbraços!\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e#define MAX 10000\nint dis[MAX];\nvector\u0026lt;int\u0026gt; adj[MAX];\n\nvoid bfs(int curr)\n{\n\tmemset(dis, -1, sizeof dis);\n\tqueue\u0026lt;int\u0026gt; q;\n\tq.push(curr);\n\tdis[curr] \u003d 0;\n\twhile (!q.empty())\n\t{\n\t\tint v \u003d q.front(); q.pop();\n\t\tfor (int i \u003d 0; i \u0026lt; adj[v].size(); ++i)\n\t\t{\n\t\t\tint u \u003d adj[v][i];\n\t\t\tif (dis[u] \u003d\u003d -1)\n\t\t\t{\n\t\t\t\tdis[u] \u003d dis[v] + 1;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}