{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1401782377,"rating":1,"authorHandle":"Fcdkbear","modificationTimeSeconds":1401782377,"id":12525,"title":"\u003cp\u003eРазбор Тренировки 2.06.2014\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eРазбирать задачи будем в порядке увеличения сложности\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача А\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВ задаче необходимо реализовать дерево отрезков, которое умеет менять элемент и находить сумму на отрезке.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/9cvvE5md\"\u003eКод\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача B\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВ задаче необходимо реализовать два дерева отрезков, которые умеет менять элемент и находить максимум/минимум на отрезке соответственно.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/XJhaaZkw\"\u003eКод\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача D\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eДавайте попробуем реализовать дерево отрезков, которое прямо отвечает на запросы, необходимые в задаче. В каждой вершине дерева будем держать индекс самой левой пустой клеточки этого отрезка или -1 если весь отрезок занят. Тогда как пересчитать ответ для вершины зная ответ для ее детей? Если ответ для левого сына не равен -1, то, очевидно, это и будет наш ответ. Если же ответ равен -1, то наш ответ равен ответу для правого сына. Это позволяет нам отвечать на запросы так как всегда. Просто вместо плюса или минимума будем использовать описанную выше процедуру восстановления ответа (обязательно гляньте код).\u003c/p\u003e\u003cp\u003eТеперь о том, как менять элемент. В случае если мы занимаем ячейку, ответ для нее становится -1, иначе ответ для нее становится ее же номером. Далее необходимо обновить ответы для всех моих родителей.\u003c/p\u003e\u003cp\u003eТаким образом, мы построили структуру, которая за логарифмичекую сложность реализовывает в точности то, что нас просят сделать в условии.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/d1dAFf8j\"\u003eКод\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача С\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eДавайте сделаем несколько предварительных шагов перед тем как работать со структурами.\u003c/p\u003e\u003cp\u003e1) Обьеденим все запросы с одинаковым ответом таким образом, чтобы они не пересекались. Таким образом, например, три запроса\u003c/p\u003e\u003cp\u003e1 3 5\u003c/p\u003e\u003cp\u003e2 4 5\u003c/p\u003e\u003cp\u003e6 8 5\u003c/p\u003e\u003cp\u003eпревратятся в два запроса:\u003c/p\u003e\u003cp\u003e1 4 5\u003c/p\u003e\u003cp\u003e6 8 5\u003c/p\u003e\u003cp\u003e2) Отсортируем запросы в порядке убывания ответа на них.\u003c/p\u003e\u003cp\u003eТеперь утверждается, что решение такое. Будем обрабатывать запросы в осортированном порядке. Все еще пустые клеточки, которые входят в текущий запрос, заполним текущим ответом на запрос. Если таких клеточек нет — ответа не существует. Клеточки, которые не вошли ни в один запрос, можна оставить нетронутыми.\u003c/p\u003e\u003cp\u003eПопробуем както доказать это решение.\u003c/p\u003e\u003cp\u003eЕсли клеточка пустая — значит ни один запрос с большим ответом его не трогал. Более того, если его затронет запрос с меньшим ответом — этот ответ точно будет находится не в нашей ячейке, так как иначе ответ на текущий запрос был бы не правильным. Пример, два запроса:\u003c/p\u003e\u003cp\u003e1 2 2\u003c/p\u003e\u003cp\u003e2 3 1\u003c/p\u003e\u003cp\u003eОчевидно, что в клеточке 2 должно быть значение 2 (или большее значение), а не 1, иначе ответ на первый запрос был бы не 2. \u003c/p\u003e\u003cp\u003eПочему если какой-то запрос не затронул ни одну пустую клеточку, массива, который нас интересует не существует? Потому что все клеточки, которые затронул данный запрос, уже вынуждено заняты бОльшими значениями.\u003c/p\u003e\u003cp\u003eИ так, детально, наше решение\u003c/p\u003e\u003cp\u003e1) Обьединяем запросы с одинаковым ответом\u003c/p\u003e\u003cp\u003e2) Сортируем их в убывающем порядке\u003c/p\u003e\u003cp\u003e3) Обрабатываем их в этом порядке. тобы узнавать следующую пустую клеточку — используем такое же дерево отрезков как в задаче D. Если ни одна клеточка в отрезке не является пустой — массива не существует. Иначе все пустые клетоки на отрезке заполняем текущим ответом на запрос\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/NeRnquDf\"\u003eКод\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["разбор","тренировка"]}}