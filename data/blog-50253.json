{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1486243186,"rating":0,"authorHandle":"mutreta","modificationTimeSeconds":1487709229,"id":50253,"title":"\u003cp\u003eStrings: Multiple Matching\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eMultiple Matching\u003c/h1\u003e\u003cp\u003eGiven a text \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e patterns \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, ..., \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e find how many times each of the patterns appear in the text.\u003c/p\u003e\u003cp\u003eTo solve this problem for a single pattern with KMP algorithm, we walked through the indexes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e of the text storing the length of the biggest occurence of a prefix of the pattern ending the the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th character of the text.\u003c/p\u003e\u003cp\u003eWhen dealing with multiple patterns, the length of the largest match is not enough. To deal with this generalized problem we forget about keeping an integer and start using a string as our state.\u003c/p\u003e\u003cp\u003eAt the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th position of the text the state will be the longest prefix of any pattern that occurs in text, ending at position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eExample:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ePatterns:\np[0] \u003d abac\np[1] \u003d aa\np[2] \u003d aca\n\n\nt \u003d ababacabaa\n\n         +-+-+-+-+-+-+-+-+-+-+\n string  |a|b|a|b|a|c|a|b|a|a|\n         +-+-+-+-+-+-+-+-+-+-+\n   p     |a|a|a|a|a|a|a|b|a|a|\n   a     | |b|b|b|b|b|c|b|b|a|\n   t     | | |a| |a|a|a| |a| |\n   t     | | | | | |c| | | | |\n   e     | | | | | | | | | | |\n   r     | | | | | | | | | | |\n   n     | | | | | | | | | | |\n         +-+-+-+-+-+-+-+-+-+-+\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTo store this prefixes efficiently we use a \u003cstrong\u003etrie\u003c/strong\u003e. A trie is a rooted where all edges are characters in a way that every path from the root to any vertex corresponds to a prefix. We can represent the trie of the patterns of the last example as:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e        * (root)\n      a/\n      *\n     /|\\\n   a/ | \\c\n   * b|  *\n      *   \\a\n    a/     *\n    *\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIs easy to see that each vertex corresponds to a prefix, so from now on we will use the nodes of the trie and prefixes interchangeably. Also, each leaf represents a pattern, but some internal vertex can also be patterns when they are prefix of another patterns.\u003c/p\u003e\u003cp\u003eTo solve the multiple matching problem we once again iterate on the text, maintaining the state. Initially, the state is the empty string, that is represented by the root of our trie. Here is how to build a trie:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estruct node {\n  node *p; // parent\n  node *nxt[26]; // could be map, hash_map\n  node *sl; // suffix link\n  char c; // edge from parent to this node\n  int k; // how many patterns end at this node\n}\n\n\nnode* root \u003d new node();\n\nvoid add(const string s) {\n  node *cur \u003d root;\n  for (int i\u003d0; s[i]; ++i) {\n    int j \u003d s[i] - \u0027a\u0027;\n    if (!cur-\u0026gt;nxt[j]) {\n      node* son \u003d new node();\n      son-\u0026gt;p \u003d cur;\n      son-\u0026gt;c \u003d s[i];\n\n      cur-\u0026gt;nxt[j] \u003d son;\n    }\n    cur \u003d cur-\u0026gt;nxt[j];\n  }\n  cur-\u0026gt;k++;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf you prefer to go without structs:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint p[N], sl[N], nxt[N][26], k[N]\nint n\u003d1; // size of the trie\n\nvoid add(const string s) {\n  int cur \u003d 0; // the first element of the trie is the root\n\n  for (int i\u003d0; s[i]; ++i) {\n    int j \u003d s[i] - \u0027a\u0027;\n    if (!nxt[cur][j]) {\n      p[n] \u003d cur;\n      nxt[cur][j] \u003d n;\n      n++;\n    }\n    cur \u003d nxt[cur][j];\n  }\n\n  k[cur]++;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is the state of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th text position.\u003c/p\u003e\u003cp\u003eTo compute the state for the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th position of the text, we try to make the state as big as possible. If we can create a prefix of a pattern concatenating \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e, we guarantee that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is optimal. If that\u0027s not possible we have to find the biggest prefix of a pattern that is also a suffix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e and that we can append \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to it and still have a valid state. If it\u0027s not possile our state will be the empty string — or the root of the trie.\u003c/p\u003e\u003cp\u003eTo find the biggest prefix of a pattern that is also a suffix of the previous states, we use \u003cstrong\u003esuffix links\u003c/strong\u003e. The suffix link of a node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e is the deepest node of the trie that is a proper suffix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e. Note that, by that definition, the suffix link of the state \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e is smaller than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e (and thus closer to the root of the trie). We\u0027ll denote the suffix link of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esl\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cem\u003eOBS: Suffix links are a generalization of prefix function. Prefix functions work on lists, while suffix links work on tries.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s represent the transition of a parent node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e to a node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e with the character \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ec\u003c/i\u003e] \u003d \u003ci\u003es\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLet\u0027s find the suffix link of the the node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e that has parent \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e, such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e \u003d \u003ci\u003ep\u003c/i\u003e[\u003ci\u003ec\u003c/i\u003e]\u003c/span\u003e, assuming that we\u0027ve already calculated the suffix link for all nodes with depth less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e. If there exists a state \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e \u003d \u003ci\u003esl\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ec\u003c/i\u003e]\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esl\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003et\u003c/i\u003e\u003c/span\u003e. If there\u0027s no state that satisfies this conditions, then we look for the biggest suffix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e that is smaller than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esl\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e that has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e as an edge. By the suffix link definition, the next vertex we should try is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esl\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003esl\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e}\u003c/span\u003e, and so on. If there is no string that satisfies this condition, then we have the empty string as the suffix link.\u003c/p\u003e\u003cp\u003eThe reasoning here is the same as the one used to derive the prefix function.\u003c/p\u003e\u003cp\u003eWe assumed that to calculate the suffix link for string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e we needed to have the suffix link calculated for all nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e that have size smaller than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e. So, to calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esl\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, we need to do it in the proper order. Doing a BFS in the trie gives us that order.\u003c/p\u003e\u003cp\u003eHere\u0027s the code:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003equeue\u0026lt;int\u0026gt; q;\nq.push(0);\n\nwhile (!q.empty()) {\n  int v \u003d q.front(); q.pop();\n  int u \u003d p[v];\n\n  while (u and !nxt[u][c[v]]) u \u003d sl[u];\n\n  sl[v] \u003d nxt[u][c[v]];\n  k[v] +\u003d k[sl[v]];\n\n  for(int i\u003d0; i\u0026lt;26; ++i)\n    if (nxt[v][i])\n      q.push(nxt[v][i]);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf you prefer to use structs:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003equeue\u0026lt;trie\u0026gt; q;\nq.push(root);\n\nwhile (!q.empty()) {\n  trie v \u003d q.front(); q.pop();\n  trie u \u003d t-\u0026gt;p;\n\n  if (u) {\n    u \u003d u-\u0026gt;sl;\n    while (u and !u-\u0026gt;nxt[v-\u0026gt;c]) u \u003d u-\u0026gt;sl;\n    v-\u0026gt;sl \u003d w ? w-\u0026gt;nxt[v-\u0026gt;c] : root;\n    v-\u0026gt;k +\u003d v-\u0026gt;sl-\u0026gt;k;\n  }\n\n  for(int i\u003d0; i\u0026lt;26; ++i)\n    if (v-\u0026gt;nxt[i])\n      q.push(v-\u0026gt;nxt[i]);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}