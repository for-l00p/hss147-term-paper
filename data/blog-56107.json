{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1512146541,"rating":0,"authorHandle":"Mohammad_kilani","modificationTimeSeconds":1512153704,"id":56107,"title":"\u003cp\u003eWeek 3 contest tutorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eProblem A:\u003c/h1\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTags\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eMath, Fast powers.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThere are three cases :\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d 0\u003c/span\u003e in this case the answer is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d 1\u003c/span\u003e in this case the answer is \u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026gt; 1\u003c/span\u003e in this case the answer is \u003cspan class\u003d\"tex-span\"\u003e25\u003c/span\u003e\u003c/p\u003e\u003cp\u003eThe answer is always 25 because we need to print the answer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emod\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e100\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e25\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e × \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emod\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e100\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e \u003d \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e25\u003c/span\u003e, so whatever was the number of times we multiply 5 with 25 the answer will remain the same. \u003c/p\u003e\u003cp\u003ecomplexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e(1)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eUse fast power to find the needed number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emod\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e100\u003c/span\u003e.\u003c/p\u003e\u003cp\u003ecomplexity : \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/df/3c/df3c0d10456d592f7f1a0df0793b9170b3022745.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint main(){\n\tlong long x;\n\tcin \u0026gt;\u0026gt; x;\n\tif(x \u003d\u003d 0) \n\t\tcout \u0026lt;\u0026lt; \u0026quot;01\u0026quot; \u0026lt;\u0026lt; endl;\n\telse if(x \u003d\u003d 1) \n\t\tcout \u0026lt;\u0026lt; \u0026quot;05\u0026quot; \u0026lt;\u0026lt; endl;\n\telse\n\t\tcout \u0026lt;\u0026lt; \u0026quot;25\u0026quot; \u0026lt;\u0026lt; endl;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint fastpower(int num,long long po){\n\tif(po \u003d\u003d 0) return 1;\n\tint cur \u003d fastpower(num,po/2);\n\tint res \u003d cur * cur % 100;\n\tif(po % 2 !\u003d 0) res \u003d res * num % 100;\n\treturn res;\n}\n\nint main(){\n\tlong long x;\n\tcin \u0026gt;\u0026gt; x;\n\tint ans \u003d fastpower(5,x);\n        cout \u0026lt;\u0026lt; (ans / 10) % 10 \u0026lt;\u0026lt; ans % 10 \u0026lt;\u0026lt; endl;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch1\u003eProblem B:\u003c/h1\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTags\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTrees.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThe easiest way to generate the answer is to generate one path starting from node \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and ending at node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e where every node is connected to the next node except node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e, now you have used \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e nodes and you should add more \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - (\u003ci\u003ek\u003c/i\u003e + 1)\u003c/span\u003e nodes, you can add the remaining nodes on any node except node \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e because the longest path will be increased, if there were no nodes between node \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e and there are some remaining nodes it impossible to generate such a tree and you should print -1, otherwise you can connect them with any node between node \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e and node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe case where there is no answer will only happen if \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e \u0026gt; 2)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e \u003d 1)\u003c/span\u003e\u003c/p\u003e\u003cp\u003ecomplexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint main(){\n\tint n , k;\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k;\n\tif(n \u0026gt; 2 \u0026amp;\u0026amp; k \u003d\u003d 1){\n\t\tcout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl;\n\t\treturn 0;\n\t}\n\tfor(int i\u003d1;i\u0026lt;\u003dk;i++) \n\t\tcout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; endl;\n\tfor(int i\u003dk+2;i\u0026lt;\u003dn;i++) \n\t\tcout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch1\u003eProblem C:\u003c/h1\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTags\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eMath, Implementation.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eBecause they are walking with the same speed the distance between the point they should meet at and the point they started at should be equal.\u003c/p\u003e\u003cp\u003eLet\u0027s define the meeting point as \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e. distance between points \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e1, \u003ci\u003ey\u003c/i\u003e1)\u003c/span\u003e should be equal to distance between points \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e2, \u003ci\u003ey\u003c/i\u003e2)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThere are 12 different ways they can walk the same distance and finish at point \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e, all these ways the distance will be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f9/31/f931940466186f90d7896bd9cf905130aa1fef5f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e\u003c/span\u003e is the Manhattan distance.\u003c/p\u003e\u003cp\u003eNow you know the distance they should travel so you can calculate the point that they will finish at, and you have only to check if they will finish at the same point or not.\u003c/p\u003e\u003cp\u003ecomplexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e(1)\u003c/span\u003e \u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint dy[4] \u003d {1,0,-1,0};\nint dx[4] \u003d {0,1,0,-1};\n\nint getidx(char x){\n\tif(x \u003d\u003d \u0027U\u0027) return 0; else if(x \u003d\u003d \u0027D\u0027) return 2; else if(x \u003d\u003d \u0027L\u0027) return 3; else return 1;\n}\n\nint main() {\n\tdouble x, y  , x2 , y2;\n\tchar a1 , a2;\n\tcin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; a1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2 \u0026gt;\u0026gt; a2;\n\tint idx1 \u003d getidx(a1);\n\tint idx2 \u003d getidx(a2);\n\tdouble dist \u003d (abs(x - x2) + abs(y - y2) + 0.0) / 2.0;\n\tdouble nx1 \u003d x + dist * dx[idx1];\n\tdouble nx2 \u003d x2 + dist * dx[idx2];\n\tdouble ny1 \u003d y + dist * dy[idx1];\n\tdouble ny2 \u003d y2 + dist * dy[idx2];\n\tif(abs(nx1 - nx2) \u0026lt; 0.000000001 \u0026amp;\u0026amp; abs(ny1 - ny2) \u0026lt; 0.000000001)\n\t\tputs(\u0026quot;YES\u0026quot;);\n\telse\n\t\tputs(\u0026quot;NO\u0026quot;);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch1\u003eProblem D:\u003c/h1\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTags\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eBinary search, Two pointers.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eBinary search solution.\u003c/p\u003e\u003cp\u003eIt is obvious that if we can get a lucky sub-array of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e then we can get also a sub-array of length less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e, so binary search works here.\u003c/p\u003e\u003cp\u003eNow we want to check if we can get a lucky sub-array of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e\u003c/span\u003e, we will iterate on all sub-arrays, then count the number of lucky numbers in this sub-array (we can do it using prefix sum in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e(1)\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eLets define \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e as the number of lucky numbers in the current sub-array and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e as the number of lucky numbers in the whole array, we need to make \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e swaps and we can do \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003em\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e swaps, if the number of available swaps is larger than the number of needed swaps then we can return true.\u003c/p\u003e\u003cp\u003eIf we iterated on all the sub-arrays and non of them worked we should return false.\u003c/p\u003e\u003cp\u003ecomplexity : \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3c/c1/3cc1f7ea4e5f55e9bdf4a7deb6d7e945e31deeda.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTwo pointers solution.\u003c/p\u003e\u003cp\u003eWe just keep moving the first pointer until it is possible to make all the elements in the current sub-array lucky, to check that we can do this we have to calculate the number of needed elements and the number available elements (exactly like Solution 1) and decide if it is possible or not.\u003c/p\u003e\u003cp\u003ecomplexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int N \u003d 200010;\nint arr[N] , sum[N] , n , m;\n\nbool lucky(int num){\n\twhile(num \u0026gt; 0){\n\t\tif(num % 10 !\u003d 4 \u0026amp;\u0026amp; num % 10 !\u003d 7) return false;\n\t\tnum /\u003d 10;\n\t}\n\treturn true;\n}\n\nbool check(int mid){\n\tfor(int i\u003d1;i\u0026lt;\u003dn-mid+1;i++){\n\t\tint x \u003d sum[i + mid - 1] - sum[i - 1] ; \n\t\tint available \u003d min(sum[n] - x,m);\n\t\tif(mid - x \u0026lt;\u003d available) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\n\tfor(int i\u003d1;i\u0026lt;\u003dn;i++) \n                scanf(\u0026quot;%d\u0026quot;,\u0026amp;arr[i]);\n\tfor(int i\u003d1;i\u0026lt;\u003dn;i++){\n\t\tsum[i] \u003d sum[i-1] + lucky(arr[i]);\n\t}\n\t int low \u003d 1 , high \u003d n , res \u003d 0 ;\n\twhile(high \u0026gt;\u003d low){\n\t\tint mid \u003d (low + high) / 2;\n\t\tif(check(mid)){\n\t\t\tres\u003d  mid;\n\t\t\tlow \u003d mid + 1;\n\t\t}\n\t\telse \n\t\t\thigh \u003d mid - 1;\n\t}\n\tcout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int N \u003d 200010;\nint arr[N] , sum[N] , n , m;\n\nbool lucky(int num){\n\twhile(num \u0026gt; 0){\n\t\tif(num % 10 !\u003d 4 \u0026amp;\u0026amp; num % 10 !\u003d 7) return false;\n\t\tnum /\u003d 10;\n\t}\n\treturn true;\n}\n\nint main() {\n\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\n\tfor(int i\u003d1;i\u0026lt;\u003dn;i++) \n                scanf(\u0026quot;%d\u0026quot;,\u0026amp;arr[i]);\n\tfor(int i\u003d1;i\u0026lt;\u003dn;i++){\n\t\tsum[i] \u003d sum[i-1] + lucky(arr[i]);\n\t}\n\tint j \u003d 1;\n\tint cur \u003d 0 , ans \u003d 0;\n\tfor(int i\u003d1;i\u0026lt;\u003dn;i++){\n\t\tif(lucky(arr[i])) cur++;\n\t\twhile(i - j + 1 - cur \u0026gt; min(sum[n] - cur,m)){\n\t\t\tif(lucky(arr[j])) cur--;\n\t\t\tj++;\n\t\t}\n\t\tans \u003d max(ans,i-j+1);\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}