{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1507127594,"rating":9,"authorHandle":"Mohammad_Karttomeh","modificationTimeSeconds":1507127769,"id":54957,"title":"\u003cp\u003eTraining Contest\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eproblem A :\u003c/h1\u003e\u003cp\u003ethe brute force solution Be appropriate three loops and we have three points A,B,C first, Check that the points do not fall on a straight one and they form a triangle , the sum of length of any two sides is strictly greater than the third side then we keep the result with side1 + side2 + side3 is maximum\u003c/p\u003e\u003cp\u003eside1 \u003d distance between points A,B side2 \u003d distance between points A,C side3 \u003d distance between points B,C\u003c/p\u003e\u003ch1\u003eproblem B :\u003c/h1\u003e\u003cp\u003ewe use bitmask soultion for this problem . make loop from 1 to (2^n-1) and count the number of one in the mask if it equals 10 then maximize the lcm of the number which his indexs in the mask equals 1 in all masks . complexity for this problem equals (2^n) * log(max vale)\u003c/p\u003e\u003ch1\u003eproblem C :\u003c/h1\u003e\u003cp\u003ewe can solve this problem with BFS algortihms first : we use seive algorithms for find all prime number on range (1 , 1e6) and save the minimum divisor large of 1 for all number that not prime second : we use data structure like set and save all value of array and its position third : We use binary Search to get acceptable passing values according to the cases\u003c/p\u003e\u003cp\u003en * m * log(n*m)\u003c/p\u003e\u003ch1\u003eproblem D :\u003c/h1\u003e\u003cp\u003enote that for every 3 range we should find 2 point only .\u003c/p\u003e\u003cp\u003eFirst we should find the last place where the lcm for elements form it to the n equal or more than k we call it by En.\u003c/p\u003e\u003cp\u003eAfter that let\u0027s find all place where the lcm from 1 to them equal or more than k , from each one of them we know that the second range start after it and should end in index less than En we should find the first place were the lcm for elements from i+1 to it equal or more than k then every index from it to (En-1) is acceptable for the second range end .\u003c/p\u003e\u003cp\u003ewe can find it using binary search for solution this will take n log (n) * log(max vale) for every element so we should use data structure such like segment so we find it in log(n) * log(n) * log(max vale) so the total complexity is n * log(n)* log(n) * log(max vale).\u003c/p\u003e\u003cp\u003esince the k is less than or equals 10^5 we should make change on the data structure and on our solution to make the complexity small as possible so if the lcm for range equal or more than k we should stop use lcm because we already have acceptable number and do that in data structure .\u003c/p\u003e\u003cp\u003eso the max vale will be k and the total complexity n * log(n) * log(n) * log(k) .\u003c/p\u003e\u003ch1\u003eproblem E :\u003c/h1\u003e\u003cp\u003eThe brute force Solution have n * n * log complexity it will not work The main idea in this problem is to divide the node to set depend on high so we know that every set of them can be solve separately because they should have the same high This is still a bad solution . Let\u0027s use this idea , divide the Solution for two part the first part is brute force and good for set less than sqrt(n)and the other dfs Solution and good for set more than sqrt(n).\u003c/p\u003e\u003cp\u003ethe brute force Solution for every node see the other node in the same set and add 1 to the lca ( ai , aj )\u003c/p\u003e\u003cp\u003eThe dfs Solution for node 1 run dfs Solution and for every son count the number of node that Belong to this set so this nodes will have lca 1 with other node from the other son so just multiple them and add the result to node 1 and do that for all his son and soo on .\u003c/p\u003e\u003cp\u003eThe total complexity in worst case for first solve is (n/sqrt(n)) * n * log n \u003d n sqrt(n) log(n) For the second n * sqrt(n) .\u003c/p\u003e\u003cp\u003ethe total complexity for this Solution is n * sqrt(n) * log(n) .\u003c/p\u003e\u003c/div\u003e","tags":[]}}