{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1498057947,"rating":-3,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1498057947,"id":52800,"title":"\u003cp\u003eNotes on Codeforces Beta Round #54, A, B, C, D(Bucket Sort)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA. Chat room\u003c/p\u003e\u003cp\u003eSuppose that the given string is denoted as S while \u0026quot;hello\u0026quot; is denoted as T. We can solve the problem by adopting two pointers pS and pT, which point to string S and T, respectively. At first, both pS and pT are set to 0. Then, we increase pS by 1 until it reaches the end of string S. During this process, once it occurs that S[pS]\u003dT[pT], we immediately increase pT by 1 as well. Note that when pT reaches the end of string T, we can break the loop. After all the characters in string S have been visited, and the loop is over (or we break the loop), we can check whether pT has arrived at the end of string T or not. If the answer is YES, it means that we can obtain \u0026quot;hello\u0026quot; from the original given string; otherwise we should output NO.\u003c/p\u003e\u003cp\u003eB. Coins\u003c/p\u003e\u003cp\u003eFor any integer N, we can find all its prime divisors and write it in the form of N\u003dp1^a1*p2^a2*...pn^an, where pi is a prime divisor while ai denotes the number of pi that N has. Intuitively, we may come up with such a sequence which is depicted as follows:\u003c/p\u003e\u003cp\u003e1\u003c/p\u003e\u003cp\u003e1*p1\u003c/p\u003e\u003cp\u003e1*p1*p1\u003c/p\u003e\u003cp\u003e1*p1*...*p1\u003c/p\u003e\u003cp\u003e1*p1*...*p1*p2\u003c/p\u003e\u003cp\u003e1*p1*...*p1*p2*p2\u003c/p\u003e\u003cp\u003e1*p1*...*p1*p2*p2*...*p2\u003c/p\u003e\u003cp\u003e...\u003c/p\u003e\u003cp\u003e1*p1*...*p1*p2*p2*...*p2*pn*...*pn\u003c/p\u003e\u003cp\u003eIt can be seen that such a sequence have (a1+a2+...an+1) integers, and this is just the maximum number of coins that we can obtain. For instance, if N\u003d36, we have 1, 1*2, 1*2*2, 1*2*2*3, 1*2*2*3*3. We can use \u0026quot;proof by contradiction\u0026quot; to prove this claim. Assume that the optimal sequence has M\u0026gt;(a1+a2+...an+1) coins and we denote this sequence as S. Then, let us try to implement some subtle modification to the current sequence to obtain a better one. We first sort S in an increasing order, and use S[i] to denote the i-th integer after sorting. If S[1] is not \u0026quot;1\u0026quot;, we can immediately add \u0026quot;1\u0026quot; to S since any integer is divisible by 1, and thus we have obtained a better sequence S\u0027, which is contradictory to our assumption. Then, S[2] must be equal to some prime divisor, since otherwise we can decompose S[2] and obtain a better sequence again. Next, S[3]/S[2] must be some prime divisor as well, since otherwise we can decompose S[3]/S[2]\u003dP*Q, and add S[2]*P to obtain a better sequence. Based on similar arguments, we can find that there are exactly (a1+a2+...an+1) integers in S, which is contradictory to our assumption, and thus proof is completed.\u003c/p\u003e\u003cp\u003eC. Trees\u003c/p\u003e\u003cp\u003eNote that S\u003d(1,2,3....,3,2,1) is always a reasonable sequence. For the given sequence A\u003d(a[1],a[2],...,a[N]), we can calculate the difference between A and S to obtain the following sequence T\u003dA-S\u003d(a[1]-1,a[2]-2,...,a[N-1]-2,a[N]-1). At first, one should note that if T[i]\u0026lt;0, then a[i] must be changed since the problem requires that a[1]\u0026gt;\u003d1. Next, suppose that the optimal sequence is S\u0027\u003d(x+1,x+2,...,x+2,x+1), where x is some non-negative integer. Here \u0026quot;optimal\u0026quot; means that if we change A into S\u0027, we can achieve the minimum number of changes. Then, we compute T\u0027\u003dA-S\u0027, and count the number of \u0026quot;0\u0026quot; in T\u0027. It can be seen that the number of \u0026quot;0\u0026quot; must be no less than that of any other sequence S\u0027\u0027. Furthermore, if we add all the integers in T\u0027 by x, it is just the same as T, i.e., A-S\u0027+x\u003dT\u0027+x\u003dA-S\u003dT. Therefore, if we count the number of \u0026quot;x\u0026quot; in T, it will be exactly the same as the number of \u0026quot;0\u0026quot; in T\u0027. Based on these arguments, we can just count the number of different non-negative integers in T, and denote the maximum number of some integer as M. Then, the answer is N-M.\u003c/p\u003e\u003cp\u003eD. Calendar\u003c/p\u003e\u003cp\u003eAt first, we store all the strings according to their length, i.e., they are divided into different groups based on their length. Then, all the strings belonging to the same group are sorted in an increasing order. As the problem requires that the final output lines should have the same length, one can calculate that the length should be L\u003d(l1+l2+...+ln)/(n/2)+1, where li denotes the length of the i-th string.\u003c/p\u003e\u003cp\u003eNext, we need implement a loop pf length (n/2) to obtain the answer. During each loop, we will find the first and second string in turn. To find the first string, we can take out the first string of each group and append the special symbol, and find out the smallest one, which is just the target string. Then, we denote the length of the first string as L\u0027, and it is sufficient to take out the first string in the group whose strings all have length L-L\u0027-1. The total complexity is O(N). The above operations in fact look like Bucket Sort...\u003c/p\u003e\u003c/div\u003e","tags":[]}}