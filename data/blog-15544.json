{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1420191001,"rating":0,"authorHandle":"NeverSayNever","modificationTimeSeconds":1420191001,"id":15544,"title":"\u003cp\u003eDP Problem \u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI was solving a simple DP problem .. \u003c/p\u003e\u003cp\u003eGiven a string S and a string T, count the number of distinct subsequences of T in S.\u003c/p\u003e\u003cp\u003eA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \u0026quot;ACE\u0026quot; is a subsequence of \u0026quot;ABCDE\u0026quot; while \u0026quot;AEC\u0026quot; is not).\u003c/p\u003e\u003cp\u003eHere is an example: S \u003d \u0026quot;rabbbit\u0026quot;, T \u003d \u0026quot;rabbit\u0026quot;\u003c/p\u003e\u003cp\u003eReturn 3.\u003c/p\u003e\u003cp\u003eI made a recursive code which is like this ..\u003c/p\u003e\u003cp\u003eI initialise the DP array with -1 and used one based indexing in DP matrix .. \u003c/p\u003e\u003cpre\u003e int solve(string S,string T,int N,int M){\n\u003cpre\u003eif( M \u0026lt;\u003d 0)\n        return 1 ;\n\n    if( N \u0026lt;\u003d 0 )\n        return 0 ;\n\n    int \u0026amp;ret \u003d DP[N][M];\nif(ret !\u003d -1)\n    return ret ;\nret \u003d 0 ;   \n    if(S[N-1] \u003d\u003d T[M-1]){\n        ret +\u003d (solve(S,T,N-1,M-1)+solve(S,T,N-1,M)) ;\n    }else{\n        ret +\u003d (solve(S,T,N-1,M)) ;\n    }\n\n    ret ;\u003c/pre\u003e\u003cp\u003e} \u003c/p\u003e\u003c/pre\u003e\u003cp\u003eI was not getting correct answer then i changed my code and prepared a bottom up code which is this ..\u003c/p\u003e \u003cpre\u003e\nint solve(string \u0026amp;S,string \u0026amp;T,int N,int M){\n\n\t\n\tfor(int i\u003d0;i\u0026lt;\u003dN;i++)\n\t\tfor(int j\u003d0;j\u0026lt;\u003dM;j++)\n\t\t\tDP[i][j] \u003d 0;\n\n\tfor(int i\u003d0;i\u0026lt;\u003dN;i++)\n\t\tDP[i][0] \u003d 1;\n\n\tfor(int i\u003d1;i\u0026lt;\u003dN;i++){\n\t\tfor(int j\u003d1;j\u0026lt;\u003dM;j++){\n\t\t\tif(S[i-1] \u003d\u003d T[j-1])\n\t\t\t\tDP[i][j] +\u003d DP[i-1][j-1] ;\n\t\t\tDP[i][j] +\u003d DP[i-1][j] ;\n\t\t}\n\t}\n\treturn DP[N][M] ;\n}\n\u003c/pre\u003e\u003cp\u003eI got AC with this solution ..Essentially the same as previous one ..\u003c/p\u003e\u003cp\u003eI am still unable to find a bug in my previous code so can anyone help me please .. \u003c/p\u003e\u003cp\u003eThanx in advance \u003c/p\u003e\u003c/div\u003e","tags":[]}}