{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1517153223,"rating":9,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1517153223,"id":57392,"title":"\u003cp\u003eNotes on Codeforces Beta Round #112, Div2- A, B, C, D, E\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/165/problem/A\" title\u003d\"Codeforces Round 112 (Div. 2)\"\u003e165A - Supercentral Point\u003c/a\u003e\u003c/p\u003e\u003cp\u003eStraightforward implementation with exhaustive enumeration.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/165/problem/B\" title\u003d\"Codeforces Round 112 (Div. 2)\"\u003e165B - Burning Midnight Oil\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe main idea is binary search, since if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is a reasonable result, then any \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u0027 \u0026gt; \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e also serves as a reasonable answer. Moreover, we can calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e in previous, and it is sufficient to consider \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e up to \u003cspan class\u003d\"tex-span\"\u003e40\u003c/span\u003e, since the problem guarantees that the maximum value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e. Do not worry that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e will lead to overflow, as we will never use the value which exceeds \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. The left work is to adopt binary search to find the minimum value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/165/problem/C\" title\u003d\"Codeforces Round 112 (Div. 2)\"\u003e165C - Another Problem on Strings\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe can solve this problem based on two cases.\u003c/p\u003e\u003cp\u003e1) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d 0\u003c/span\u003e: we find out all the consecutive intervals \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e that only 0s are included. This interval contributes \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5e/b4/5eb4bf41da19d52a30c5842ca91c98bf04432a90.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e to the final answer, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e \u003d \u003ci\u003er\u003c/i\u003e - \u003ci\u003el\u003c/i\u003e + 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e2) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u0026gt; 0\u003c/span\u003e: we find out each interval \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e that exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e 1s are included and integers with indices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e are also 1s. Then, we move from position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e to the left and find out the first index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u0027\u003c/span\u003e that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e\u0027] \u003d 0\u003c/span\u003e while \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e\u0027 - 1] \u003d 1\u003c/span\u003e. Similarly, we find the index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u0027\u003c/span\u003e so that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003er\u003c/i\u003e\u0027] \u003d 0\u003c/span\u003e while \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003er\u003c/i\u003e\u0027 + 1] \u003d 1\u003c/span\u003e. Then, this interval contributes \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003er\u003c/i\u003e\u0027 - \u003ci\u003er\u003c/i\u003e) × (\u003ci\u003el\u003c/i\u003e - \u003ci\u003el\u003c/i\u003e\u0027)\u003c/span\u003e to the final answer.\u003c/p\u003e\u003cp\u003eThe total complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e according to amortized analysis.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/165/problem/D\" title\u003d\"Codeforces Round 112 (Div. 2)\"\u003e165D - Beard Graph\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAt first, we should realize that the whole graph is either a single link, or a tree that there exists a unique root node so that after deleting this node, the tree is decomposed into several independent single links.\u003c/p\u003e\u003cp\u003eWe can build a segment tree to deal with the modification of the color of some edge, and the query of the distance between two nodes. In order to do this, we have to assign new indices to each edge. Without loss of generality, we start from the root and adopt dfs for each of the “single link”. For each link, we assign both the edges and nodes with indices 1,2,3,... until all the nodes have been visited. After these operations, we can find that for each single link, the indices of edges and nodes belonging to it have consecutive numbers. As for the segment tree, each node contains its managing range, i.e., the edges that it covers, and the number of white edges belonging to this range.\u003c/p\u003e\u003cp\u003eWhen the color of some edge is changed, it is equivalent to modifying a single element in the segment tree. For instance, when an edge becomes white, we increase one for each node that covers this edge in the segment tree. When we are asked to output the distance between two nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, we should consider two cases based on whether they belong to the same single link or not, which can be conveniently obtained by using disjoint set union. Besides, for each node, we should also compute the distance to the root node, as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003ea\u003c/i\u003e]\u003c/span\u003e, in previous. If they belong to the same single link, we can directly query the segment tree to check whether there exists at least one white edge between them, since they have consecutive indices in the segment tree, and the answer is \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003edis\u003c/i\u003e[\u003ci\u003ea\u003c/i\u003e] - \u003ci\u003edis\u003c/i\u003e[\u003ci\u003eb\u003c/i\u003e]|\u003c/span\u003e. If they belong to different single links, we should check whether there is at least one white edge from node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e the root node, and from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e to the root node, independently. To achieve this, we should find the index of the child node that belongs to the same single link as node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e (or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e), and query this range in the segment tree. The answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003ea\u003c/i\u003e] + \u003ci\u003edis\u003c/i\u003e[\u003ci\u003eb\u003c/i\u003e]\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/165/problem/E\" title\u003d\"Codeforces Round 112 (Div. 2)\"\u003e165E - Compatible Numbers\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI read tutorials and found that the solution is based on dp.\u003c/p\u003e\u003cp\u003eWe start with a simple example. Suppose that we are asked to find an integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e that reaults in zero after XOR with 6. We write 6 in binary form as (00...0110), where the total number of digits is 22 (note that \u003cspan class\u003d\"tex-span\"\u003e4 * 10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e \u003d 4 * (10\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e \u0026lt; 4 * 1024\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e \u003d 2\u003csup class\u003d\"upper-index\"\u003e22\u003c/sup\u003e\u003c/span\u003e, and thus 22 digits are enough to represent all the integers required by this problem). We can see that (11...111001) can serve as a potential answer. However, we can find many more reasonable sequences, such as (11....110001), (11...110000) and so on. One can check that the correct sequences must have zeros at the second and third positions, counted from right to left, while the values at the other positions never matter.\u003c/p\u003e\u003cp\u003eWe define that a sequence can be reduced to another sequence, by converting some single 1 to 0. For instance, for (01110), it can be reduced to (01100), (01010), (00110). Thus, given an integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, we represent it in a binary form and inverse every binary digit (0 to 1 and 1 to 0), obtaining a new integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u0027\u003c/span\u003e. Then, it is sufficient to check whether \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u0027\u003c/span\u003e can be reduced to some integer that can be found in the given array.\u003c/p\u003e\u003cp\u003eWe can use bit-mask based dp algorithm to calculate for each integer that, whether it can be reduced to some other one that has appeared in the given sequence. \u003c/p\u003e\u003c/div\u003e","tags":[]}}