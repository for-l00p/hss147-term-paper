{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1493804552,"rating":0,"authorHandle":"krauch","modificationTimeSeconds":1493807111,"id":51817,"title":"\u003cp\u003eEditorial of the Pre-KBO Contest #1 (8th grades)\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eЗадача А\u003c/h2\u003e\u003cp\u003eЗаметим, что если существует к-хороший отрезок длины x, тогда хороший отрезок длины x-1 тоже существует. Значит мы можем перебирать ответ бинпоиском, и каждый раз пытаться искать к-хороший отрезок фиксированный длины x за O(N). Итого O(N * log(N)).\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nconst int N \u003d 5e5 + 5;\n\nint n, k, a[N], ansl \u003d 1, ansr \u003d 1, cnt[(int)1e6 + 6];\n\nint main () {\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k;\n\tfor (int i \u003d 1; i \u0026lt;\u003d n; ++i) {\n\t\tcin \u0026gt;\u0026gt; a[i];\n\t}\n\n\tint l \u003d 1, r \u003d n;\n\twhile (l \u0026lt; r) {\n\t\tint mid \u003d (l + r + 1) / 2;\n\t\t\n\t\t/// Ищем k-хороший отрезок длины mid\n\t\tint res \u003d 0;\n\t\tfor (int i \u003d 0; i \u0026lt;\u003d (int)1e6; ++i) cnt[i] \u003d 0;\n\t\tfor (int i \u003d 1; i \u0026lt;\u003d mid; ++i) {\n\t\t\tcnt[a[i]]++;\n\t\t\tif (cnt[a[i]] \u003d\u003d 1) ++res; // Если количество вхождений этого элемента равно 1, то надо увеличить количество различных элементов\n\t\t}\n\t\tbool found \u003d 0;\n\t\tif (res \u0026lt;\u003d k) {\n\t\t\tfound \u003d 1;\n\t\t\tansl \u003d 1;\n\t\t\tansr \u003d mid;\n\t\t}\n\t\tfor (int i \u003d 1; i \u0026lt;\u003d n - mid; ++i) {\n\t\t\tcnt[a[i]]--;\n\t\t\tif (cnt[a[i]] \u003d\u003d 0) --res; // Если количество вхождений этого элемента равно 0, то надо уменьшить количество различных элементов\n\t\t\tcnt[a[i + mid]]++;\n\t\t\tif (cnt[a[i + mid]] \u003d\u003d 1) ++res;\n\t\t\tif (res \u0026lt;\u003d k) {\n\t\t\t\tfound \u003d 1;\n\t\t\t\tansl \u003d i + 1;\n\t\t\t\tansr \u003d i + mid;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t/// Обновляем границы бинпоиска\n\t\tif (found) l \u003d mid; // Если нашли то пытаемся найти подлинее\n\t\telse r \u003d mid - 1; // А если нет, то и отрезок длинее мы уже не найдем\t\t\n\t}\n\n\tcout \u0026lt;\u0026lt; ansl \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ansr \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003eЗадача Б\u003c/h2\u003e\u003cp\u003eОпределим dp[i] — количество способов схавать i цветков. Понятно, что базой будет dp[0] \u003d 1 (ничего не хавать есть только один способ). Тогда для i \u0026gt; 0 переходы будут такими: \u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eМы либо захаваем один красный цветок:\u003c/p\u003e\u003cp\u003edp[i] +\u003d dp[i-1];\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eЛибо захаваем блок размера k из белых цветов: \u003c/p\u003e\u003cp\u003edp[i] +\u003d dp[i-k];\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eКонечно же не забываем брать по модулю:\u003c/p\u003e\u003cp\u003edp[i] %\u003d MOD (в этой задаче MOD \u003d 1e9+7);\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eИтоговый переход:\u003c/p\u003e\u003cp\u003edp[i] \u003d (dp[i-1] + dp[i-k]) % MOD; \u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eТеперь чтобы быстро отвечать на запросы типа \u0026quot;сумма ДПшок от a до b\u0026quot;, будем хранить сумму на префиксе \u003c/p\u003e \u003cpre\u003epref[i] \u003d (dp[1] + dp[2] + ... + dp[i-1] + dp[i]) % MOD.\u003c/pre\u003e\u003cp\u003eТогда ответом будет ans \u003d pref[b] — pref[a — 1]. Также pref[b] может быть меньше чем pref[a], так как мы берем ответ по модулю (подумайте почему). Значит ans может быть отрицательным. Главное не паниковать и плюсануть MOD (if (ans \u0026lt; 0) ans +\u003d MOD), и все будет ОК (опять же подумайте почему).\u003c/p\u003e\u003c/div\u003e","tags":["чалышмааааааа"]}}