{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1518718623,"rating":102,"authorHandle":"praran26","modificationTimeSeconds":1518719826,"id":57796,"title":"\u003cp\u003eICM Technex 2018 and Codeforces Round #463 (Div. 1 + Div. 2, combined) Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"932A\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint main()\n{\n    string s;\n    cin\u0026gt;\u0026gt;s;\n    cout\u0026lt;\u0026lt;s;\n    reverse(s.begin(),s.end());\n    cout\u0026lt;\u0026lt;s;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"932B\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\n\n#ifdef PRINTERS\n#include \u0026quot;printers.hpp\u0026quot;\nusing namespace printers;\n#define tr(a)\t\tcerr\u0026lt;\u0026lt;#a\u0026lt;\u0026lt;\u0026quot; : \u0026quot;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl\n#else\n#define tr(a)    \n#endif\n\n#define ll          long long\n#define pb          push_back\n#define mp          make_pair\n#define pii         pair\u0026lt;int,int\u0026gt;\n#define vi          vector\u0026lt;int\u0026gt;\n#define all(a)      (a).begin(),(a).end()\n#define F           first\n#define S           second\n#define sz(x)       (int)x.size()\n#define hell        1000000007\n#define endl        \u0027\\n\u0027\n#define rep(i,a,b)\tfor(int i\u003da;i\u0026lt;b;i++)\nusing namespace std;\n\nint x[10][1000005];\n\nint f(int x){\n\tif(x\u0026lt;10)return x;\n\tint prod\u003d1;\n\twhile(x){\n\t\tif(x%10)prod*\u003d(x%10);\n\t\tx/\u003d10;\n\t}\n\treturn f(prod);\n}\n\nvoid solve(){\n\tfor(int i\u003d1;i\u0026lt;\u003d1000000;i++){\n\t\tx[f(i)][i]++;\n\t}\n\tfor(int i\u003d1;i\u0026lt;10;i++){\n\t\tfor(int j\u003d1;j\u0026lt;\u003d1000000;j++){\n\t\t\tx[i][j]+\u003dx[i][j-1];\n\t\t}\n\t}\n\tint Q;\n\tcin\u0026gt;\u0026gt;Q;\n\twhile(Q--){\n\t\tint l,r,k;\n\t\tcin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r\u0026gt;\u0026gt;k;\n\t\tcout\u0026lt;\u0026lt;x[k][r]-x[k][l-1]\u0026lt;\u0026lt;endl;\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t\u003d1;\n//\tcin\u0026gt;\u0026gt;t;\n\twhile(t--){\n\t\tsolve();\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"932C\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\n\n#define ll          long long\n#define pb          push_back\n#define mp          make_pair\n#define pii         pair\u0026lt;int,int\u0026gt;\n#define vi          vector\u0026lt;int\u0026gt;\n#define all(a)      (a).begin(),(a).end()\n#define F           first\n#define S           second\n#define sz(x)       (int)x.size()\n#define hell        1000000007\n#define endl        \u0027\\n\u0027\n#define rep(i,a,b)\tfor(int i\u003da;i\u0026lt;b;i++)\nusing namespace std;\n\nvoid solve(){\n\tint n,a,b;\n\tcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\n\tvector\u0026lt;int\u0026gt;v(n);\n\tiota(all(v),1);\n\tint i\u003d0;\n\twhile(i\u0026lt;n){\n\t\tif((n-i)%b\u003d\u003d0){\n\t\t\tif(b\u0026gt;1)rotate(v.begin()+i,v.begin()+i+1,v.begin()+i+b);\n\t\t\ti+\u003db;\n\t\t}\n\t\telse{\n\t\t\tif(i+a\u0026gt;n){\n\t\t\t\tcout\u0026lt;\u0026lt;-1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(a\u0026gt;1)rotate(v.begin()+i,v.begin()+i+1,v.begin()+i+a);\n\t\t\ti+\u003da;\n\t\t}\n\t}\n\tfor(auto j:v)cout\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t\u003d1;\n//\tcin\u0026gt;\u0026gt;t;\n\twhile(t--){\n\t\tsolve();\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"932D\"\u003eTutorial is loading...\u003c/div\u003e\u003cp\u003eThanks to \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/radoslav11\" title\u003d\"Master radoslav11\"\u003eradoslav11\u003c/a\u003e for nice and short editorial in comments.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\n\n#ifdef PRINTERS\n#include \u0026quot;printers.hpp\u0026quot;\nusing namespace printers;\n#define tr(a)\t\tcerr\u0026lt;\u0026lt;#a\u0026lt;\u0026lt;\u0026quot; : \u0026quot;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl\n#else\n#define tr(a)    \n#endif\n#define ll          long long\n#define pb          push_back\n#define mp          make_pair\n#define pii         pair\u0026lt;int,int\u0026gt;\n#define vi          vector\u0026lt;int\u0026gt;\n#define all(a)      (a).begin(),(a).end()\n#define F           first\n#define S           second\n#define sz(x)       (int)x.size()\n#define hell        1000000007\n#define endl        \u0027\\n\u0027\n#define rep(i,a,b)\tfor(int i\u003da;i\u0026lt;b;i++)\nusing namespace std;\n\nint par[20][400000];\nll par_sum[20][400000];\nint w[400000];\n\nvoid solve(){\n\tint Q;\n\tcin\u0026gt;\u0026gt;Q;\n\tw[0]\u003dINT_MAX;\n\tint last\u003d0;\n\tint cur\u003d1;\n\tfor(int i\u003d0;i\u0026lt;20;i++)par_sum[i][1]\u003d1e16;\n\twhile(Q--){\n\t\tint ch;\n\t\tcin\u0026gt;\u0026gt;ch;\n\t\tif(ch\u003d\u003d1){\n\t\t\tll p,q;\n\t\t\tcin\u0026gt;\u0026gt;p\u0026gt;\u0026gt;q;\n\t\t\tp^\u003dlast;\n\t\t\tq^\u003dlast;\n\t\t\tcur++;\n\t\t\tw[cur]\u003dq;\n\t\t\tif(w[p]\u0026gt;\u003dw[cur]){\n\t\t\t\tpar[0][cur]\u003dp;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint from\u003dp;\n\t\t\t\tfor(int i\u003d19;i\u0026gt;\u003d0;i--){\n\t\t\t\t\tif(w[par[i][from]]\u0026lt;w[cur])\n\t\t\t\t\t\tfrom\u003dpar[i][from];\n\t\t\t\t}\n\t\t\t\tpar[0][cur]\u003dpar[0][from];\n\t\t\t}\n\t\t\tpar_sum[0][cur]\u003d(par[0][cur]\u003d\u003d0?1e16:w[par[0][cur]]);\n\t\t\tfor(int i\u003d1;i\u0026lt;20;i++){\n\t\t\t\tpar[i][cur]\u003dpar[i-1][par[i-1][cur]];\n\t\t\t\tpar_sum[i][cur]\u003d(par[i][cur]\u003d\u003d0?1e16:par_sum[i-1][cur]+par_sum[i-1][par[i-1][cur]]);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tll p,q;\n\t\t\tcin\u0026gt;\u0026gt;p\u0026gt;\u0026gt;q;\n\t\t\tp^\u003dlast;\n\t\t\tq^\u003dlast;\n\t\t\tif(w[p]\u0026gt;q){\n\t\t\t\tcout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl;\n\t\t\t\tlast\u003d0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tq-\u003dw[p];\n\t\t\t\tint ans\u003d1;\n\t\t\t\tfor(int i\u003d19;i\u0026gt;\u003d0;i--){\n\t\t\t\t\tif(par_sum[i][p]\u0026lt;\u003dq){\n\t\t\t\t\t\tans+\u003d(1\u0026lt;\u0026lt;i);\n\t\t\t\t\t\tq-\u003dpar_sum[i][p];\n\t\t\t\t\t\tp\u003dpar[i][p];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\n\t\t\t\tlast\u003dans;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t\u003d1;\n//\tcin\u0026gt;\u0026gt;t;\n\twhile(t--){\n\t\tsolve();\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"932E\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\n\n#define ll          long long\n#define pb          push_back\n#define mp          make_pair\n#define pii         pair\u0026lt;int,int\u0026gt;\n#define vi          vector\u0026lt;int\u0026gt;\n#define all(a)      (a).begin(),(a).end()\n#define F           first\n#define S           second\n#define sz(x)       (int)x.size()\n#define hell        1000000007\n#define endl        \u0027\\n\u0027\n#define rep(i,a,b)\tfor(int i\u003da;i\u0026lt;b;i++)\nusing namespace std;\n\nint dp[5001][5001];\nll expo(ll base, ll exponent, ll mod) {\n    ll ans \u003d 1;\n    while(exponent !\u003d0 ) {\n        if((exponent\u0026amp;1) \u003d\u003d 1) {\n            ans \u003d ans*base ;\n            ans \u003d ans%mod;\n        }\n        base \u003d base*base;\n        base %\u003d mod;\n        exponent\u0026gt;\u0026gt;\u003d 1;\n    }\n    return ans%mod;\n}\nint fill(int diffs,int a,int tot){\n\tif(dp[diffs][a]\u0026gt;\u003d0)return dp[diffs][a];\n\tint b\u003dtot-a;\n\tif(diffs\u003d\u003d0){\n\t\treturn dp[diffs][a]\u003dexpo(2,b,hell);\n\t}\n\treturn dp[diffs][a]\u003d((b?1LL*b*fill(diffs-1,a+1,tot):0LL)+(a?1LL*a*fill(diffs-1,a,tot):0LL))%hell;\n}\n\nvoid solve(){\n\tint N,k;\n\tcin\u0026gt;\u0026gt;N\u0026gt;\u0026gt;k;\n\tmemset(dp,-1,sizeof dp);\n\tcout\u0026lt;\u0026lt;fill(k,0,N)\u0026lt;\u0026lt;endl;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t\u003d1;\n//\tcin\u0026gt;\u0026gt;t;\n\twhile(t--){\n\t\tsolve();\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"932F\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\n\n\n#define ll          long long\n#define pb          push_back\n#define mp          make_pair\n#define pii         pair\u0026lt;int,int\u0026gt;\n#define vi          vector\u0026lt;int\u0026gt;\n#define all(a)      (a).begin(),(a).end()\n#define F           first\n#define S           second\n#define sz(x)       (int)x.size()\n#define hell        1000000007\n#define endl        \u0027\\n\u0027\n#define rep(i,a,b)    for(int i\u003da;i\u0026lt;b;i++)\nusing namespace std;\n\nbool Q;\nstruct Line {\n    mutable ll k, m, p;\n    bool operator\u0026lt;(const Line\u0026amp; o) const {\n        return Q ? p \u0026lt; o.p : k \u0026lt; o.k;\n    }\n};\nstruct LineContainer : multiset\u0026lt;Line\u0026gt; {\n    const ll inf \u003d LLONG_MAX;\n    ll div(ll a, ll b){\n        return a / b - ((a ^ b) \u0026lt; 0 \u0026amp;\u0026amp; a % b);\n    }\n    bool isect(iterator x, iterator y) {\n        if (y \u003d\u003d end()) { x-\u0026gt;p \u003d inf; return false; }\n        if (x-\u0026gt;k \u003d\u003d y-\u0026gt;k) x-\u0026gt;p \u003d x-\u0026gt;m \u0026gt; y-\u0026gt;m ? inf : -inf;\n        else x-\u0026gt;p \u003d div(y-\u0026gt;m - x-\u0026gt;m, x-\u0026gt;k - y-\u0026gt;k);\n        return x-\u0026gt;p \u0026gt;\u003d y-\u0026gt;p;\n    }\n    void add(ll k, ll m) {\n        auto z \u003d insert({k, m, 0}), y \u003d z++, x \u003d y;\n        while (isect(y, z)) z \u003d erase(z);\n        if (x !\u003d begin() \u0026amp;\u0026amp; isect(--x, y)) isect(x, y \u003d erase(y));\n        while ((y \u003d x) !\u003d begin() \u0026amp;\u0026amp; (--x)-\u0026gt;p \u0026gt;\u003d y-\u0026gt;p)\n            isect(x, erase(y));\n    }\n    ll query(ll x) {\n        assert(!empty());\n        Q \u003d 1; auto l \u003d *lower_bound({0,0,x}); Q \u003d 0;\n        return l.k * x + l.m;\n    }\n};\n\nvector\u0026lt;int\u0026gt; x,y;\nvector\u0026lt;vi\u0026gt; adj;\nvector\u0026lt;ll\u0026gt; ans;\nvector\u0026lt;int\u0026gt; subsize;\nvoid dfs1(int u,int v){\n    subsize[u]\u003d1;\n    for(auto i:adj[u]){\n        if(i\u003d\u003dv)continue;\n        dfs1(i,u);\n        subsize[u]+\u003dsubsize[i];\n    }\n}\n\nvoid dfs2(int v, int p,LineContainer\u0026amp; cur){\n    int mx\u003d-1,bigChild\u003d-1;\n    bool leaf\u003d1;\n    for(auto u:adj[v]){\n        if(u!\u003dp and subsize[u]\u0026gt;mx){\n            mx\u003dsubsize[u];\n            bigChild\u003du;\n            leaf\u003d0;\n        }\n    }\n    if(bigChild!\u003d-1){\n        dfs2(bigChild,v,cur);\n    }\n    for(auto u:adj[v]){\n        if(u!\u003dp and u!\u003dbigChild){\n            LineContainer temp;\n            dfs2(u,v,temp);\n            for(auto i:temp){\n                cur.add(i.k,i.m);\n            }\n        }\n    }\n    if(!leaf)ans[v]\u003d-cur.query(x[v]);\n    else ans[v]\u003d0;\n    cur.add(-y[v],-ans[v]);\n}\nvoid solve(){\n    int n;\n    cin\u0026gt;\u0026gt;n;\n    x.resize(n+1);\n    y.resize(n+1);\n    ans.resize(n+1);\n    subsize.resize(n+1);\n    adj.resize(n+1);\n    rep(i,1,n+1)cin\u0026gt;\u0026gt;x[i];\n    rep(i,1,n+1)cin\u0026gt;\u0026gt;y[i];\n    rep(i,1,n){\n        int u,v;\n        cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v;\n        adj[u].pb(v);\n        adj[v].pb(u);\n    }\n    dfs1(1,0);\n    LineContainer lc;\n    dfs2(1,0,lc);\n    rep(i,1,n+1)cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t\u003d1;\n//    cin\u0026gt;\u0026gt;t;\n    while(t--){\n        solve();\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"932G\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#define ll          long long\n#define pb          push_back\n#define mp          make_pair\n#define pii         pair\u0026lt;int,int\u0026gt;\n#define vi          vector\u0026lt;int\u0026gt;\n#define all(a)      (a).begin(),(a).end()\n#define F           first\n#define S           second\n#define sz(x)       (int)x.size()\n#define hell        1000000007\n#define endl        \u0027\\n\u0027\nusing namespace std;\nconst int MAXN\u003d1000005;\nstring s;\nstruct PalindromicTree{\n    int N,cur;\n    vector\u0026lt;map\u0026lt;int,int\u0026gt;\u0026gt; next;\n    vector\u0026lt;int\u0026gt; link,start,len,diff,slink;\n    PalindromicTree(): N(0),cur(0){\n        node();\n        len[0]\u003d-1;\n        node();\n    }\n    int node(){\n        next.emplace_back();\n        link.emplace_back(0);\n        start.emplace_back(0);\n        len.emplace_back(0);\n        diff.emplace_back(0);\n        slink.emplace_back(0);\n        return N++;\n    }\n    void add_letter(int idx){\n        while(true){\n            if(idx-len[cur]-1\u0026gt;\u003d0 \u0026amp;\u0026amp; s[idx-len[cur]-1]\u003d\u003ds[idx])\n                break;\n            cur\u003dlink[cur];\n        }\n        if(next[cur].find(s[idx])!\u003dnext[cur].end()){\n            cur\u003dnext[cur][s[idx]];\n            return;\n        }\n        node();\n        next[cur][s[idx]]\u003dN-1;\n        len[N-1]\u003dlen[cur]+2;\n        start[N-1]\u003didx-len[N-1]+1;\n        if(len[N-1]\u003d\u003d1){\n            link[N-1]\u003ddiff[N-1]\u003dslink[N-1]\u003d1;\n            cur\u003dN-1;\n            return;\n        }\n        while(true){\n            cur\u003dlink[cur];\n            if(idx-len[cur]-1\u0026gt;\u003d0 \u0026amp;\u0026amp; s[idx-len[cur]-1]\u003d\u003ds[idx])\n                break;\n        }\n        link[N-1]\u003dnext[cur][s[idx]];\n        diff[N-1]\u003dlen[N-1]-len[link[N-1]];\n        if(diff[N-1]\u003d\u003ddiff[link[N-1]])\n        \tslink[N-1]\u003dslink[link[N-1]];\n        else\n        \tslink[N-1]\u003dlink[N-1];\n        cur\u003dN-1;\n    }\n};\nll dp[MAXN],sans[MAXN];\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tPalindromicTree pt;\n\tint i,cur;\n\tstring str;\n\tcin\u0026gt;\u0026gt;str;\n\tfor(i\u003d0;i\u0026lt;sz(str)/2;i++){\n\t\ts.pb(str[i]);\n\t\ts.pb(str[sz(str)-i-1]);\n\t}\n\tdp[0]\u003d1;\n\tfor(i\u003d1;i\u0026lt;\u003dsz(s);i++){\n\t\tpt.add_letter(i-1);\n\t\tfor(cur\u003dpt.cur;cur\u0026gt;1;cur\u003dpt.slink[cur]){\n\t\t\tsans[cur]\u003ddp[i-pt.len[pt.slink[cur]]-pt.diff[cur]];\n\t\t\tif(pt.diff[cur]\u003d\u003dpt.diff[pt.link[cur]])\n\t\t\t\tsans[cur]\u003d(sans[cur]+sans[pt.link[cur]])%hell;\n\t\t\tdp[i]\u003d(dp[i]+sans[cur])%hell;\n\t\t}\n\t\tif(i\u0026amp;1)\n\t\t\tdp[i]\u003d0;\n\t}\n\tcout\u0026lt;\u0026lt;dp[sz(s)];\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#define NDEBUG\nNDEBUG\n\n\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;array\u0026gt;\n#include \u0026lt;bitset\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;functional\u0026gt;\n#include \u0026lt;iomanip\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;sstream\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;tuple\u0026gt;\n#include \u0026lt;unordered_map\u0026gt;\n#include \u0026lt;unordered_set\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;memory\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;random\u0026gt;\n\n\n#define forn(t, i, n) for (t i \u003d 0; i \u0026lt; (n); ++i)\n\n\nusing namespace std;\n\n// TC_REMOVE_BEGIN\n/// caide keep\nbool __hack \u003d std::ios::sync_with_stdio(false);\n/// caide keep\nauto __hack1 \u003d cin.tie(nullptr);\n// TC_REMOVE_END\n\n\n// Section with adoption of array and vector algorithms.\n\n\n#define ENABLE_IF(e) typename enable_if\u0026lt;e\u0026gt;::type* \u003d nullptr\n\nnamespace template_util {\n    \n\n    constexpr int bytecount(uint64_t x) {\n        return x ? 1 + bytecount(x \u0026gt;\u0026gt; 8) : 0;\n    }\n\n    template\u0026lt;int N\u0026gt;\n    struct bytetype {\n        \n    };\n\n    template\u0026lt;\u0026gt;\n    struct bytetype\u0026lt;4\u0026gt; {\n        typedef uint32_t type;\n    };\n\n    \n    template\u0026lt;\u0026gt;\n    struct bytetype\u0026lt;1\u0026gt; {\n        typedef uint8_t type;\n    };\n\n    \n    /// caide keep\n    template\u0026lt;uint64_t N\u0026gt;\n    struct minimal_uint : bytetype\u0026lt;bytecount(N)\u0026gt; {\n    };\n}\n\n\ntemplate\u0026lt;class T\u0026gt;\nT next(istream\u0026amp; in) {\n    T ret;\n    in \u0026gt;\u0026gt; ret;\n    return ret;\n}\n\n\n/*\nTODOs:\n primitive root\n discrete log\n\n tests!!!\n*/\n\nnamespace mod_impl {\n    /// caide keep\n    template \u0026lt;class T\u0026gt;\n    constexpr inline T mod(T MOD) {\n        return MOD;\n    }\n\n    /// caide keep\n    template \u0026lt;class T\u0026gt;\n    constexpr inline T mod(T* MOD) {\n        return *MOD;\n    }\n\n    /// caide keep\n    template \u0026lt;class T\u0026gt;\n    constexpr inline T max_mod(T MOD) {\n        return MOD - 1;\n    }\n\n    /// caide keep\n    template \u0026lt;class T\u0026gt;\n    constexpr inline T max_mod(T*) {\n        return numeric_limits\u0026lt;T\u0026gt;::max() - 1;\n    }\n\n    \n    constexpr inline uint64_t combine_max_sum(uint64_t a, uint64_t b) {\n        return a \u0026gt; ~b ? 0 : a + b;\n    }\n\n    \n    /// caide keep\n    template \u0026lt;class T\u0026gt;\n    constexpr inline uint64_t next_divisible(T mod, uint64_t max) {\n        return max % mod \u003d\u003d 0 ? max : combine_max_sum(max, mod - max % mod);\n    }\n\n    /// caide keep\n    template \u0026lt;class T\u0026gt;\n    constexpr inline uint64_t next_divisible(T*, uint64_t) {\n        return 0;\n    }\n\n    //caide keep\n    constexpr int IF_THRESHOLD \u003d 2;\n\n    template \u0026lt;class T, T MOD_VALUE, uint64_t MAX,\n            class RET \u003d typename template_util::minimal_uint\u0026lt;max_mod(MOD_VALUE)\u0026gt;::type,\n            ENABLE_IF(MAX \u0026lt;\u003d max_mod(MOD_VALUE) \u0026amp;\u0026amp; !is_pointer\u0026lt;T\u0026gt;::value)\u0026gt;\n    inline RET smart_mod(typename template_util::minimal_uint\u0026lt;MAX\u0026gt;::type value) {\n        return value;\n    }\n\n    template \u0026lt;class T, T MOD_VALUE, uint64_t MAX,\n            class RET \u003d typename template_util::minimal_uint\u0026lt;max_mod(MOD_VALUE)\u0026gt;::type,\n            ENABLE_IF(max_mod(MOD_VALUE) \u0026lt; MAX \u0026amp;\u0026amp; MAX \u0026lt;\u003d IF_THRESHOLD * max_mod(MOD_VALUE) \u0026amp;\u0026amp; !is_pointer\u0026lt;T\u0026gt;::value)\u0026gt;\n    inline RET smart_mod(typename template_util::minimal_uint\u0026lt;MAX\u0026gt;::type value) {\n        while (value \u0026gt;\u003d mod(MOD_VALUE)) {\n            value -\u003d mod(MOD_VALUE);\n        }\n        return (RET)value;\n    }\n\n    \n}\n\n\n#define MAX_MOD mod_impl::max_mod(MOD_VALUE)\n\nstruct DenormTag {};\n\ntemplate \u0026lt;class T, T MOD_VALUE, uint64_t MAX \u003d MAX_MOD, ENABLE_IF(MAX_MOD \u0026gt;\u003d 2)\u0026gt;\nstruct ModVal {\n    typedef typename template_util::minimal_uint\u0026lt;MAX\u0026gt;::type storage;\n    storage value;\n\n    /// caide keep\n    inline ModVal(): value(0) {\n        assert(MOD \u0026gt;\u003d 2);\n    }\n\n    \n    inline ModVal(storage v, DenormTag): value(v) {\n        assert(MOD \u0026gt;\u003d 2);\n        assert(v \u0026lt;\u003d MAX);\n    };\n\n    inline operator ModVal\u0026lt;T, MOD_VALUE\u0026gt;() {\n        return {v(), DenormTag()};\n    };\n\n    \n    typename template_util::minimal_uint\u0026lt;mod_impl::max_mod(MOD_VALUE)\u0026gt;::type v() const {\n        return mod_impl::smart_mod\u0026lt;T, MOD_VALUE, MAX\u0026gt;(value);\n    }\n};\n\n\ntemplate \u0026lt;class T, T MOD_VALUE, uint64_t MAX1, uint64_t MAX2,\n        uint64_t NEW_MAX \u003d mod_impl::combine_max_sum(MAX1, MAX2),\n        ENABLE_IF(NEW_MAX !\u003d 0), class Ret \u003d ModVal\u0026lt;T, MOD_VALUE, NEW_MAX\u0026gt;\u0026gt;\ninline Ret operator+(ModVal\u0026lt;T, MOD_VALUE, MAX1\u0026gt; o1, ModVal\u0026lt;T, MOD_VALUE, MAX2\u0026gt; o2) {\n    return {typename Ret::storage(typename Ret::storage() + o1.value + o2.value), DenormTag()};\n}\n\n\ntemplate \u0026lt;class T, T MOD_VALUE, uint64_t MAX\u0026gt;\ninline ModVal\u0026lt;T, MOD_VALUE\u0026gt;\u0026amp; operator+\u003d(ModVal\u0026lt;T, MOD_VALUE\u0026gt;\u0026amp; lhs, const ModVal\u0026lt;T, MOD_VALUE, MAX\u0026gt;\u0026amp; rhs) {\n    lhs \u003d lhs + rhs;\n    return lhs;\n}\n\n\ntemplate \u0026lt;class T, T MOD_VALUE, class MOD_TYPE\u0026gt;\nstruct ModCompanion {\n    typedef MOD_TYPE mod_type;\n    typedef ModVal\u0026lt;mod_type, MOD_VALUE\u0026gt; type;\n    \n\n    template \u0026lt;uint64_t C\u0026gt;\n    inline static constexpr ModVal\u0026lt;mod_type, MOD_VALUE, C\u0026gt; c() {\n        return {C, DenormTag()};\n    };\n\n    \n};\n\n\n#undef MAX_MOD\n\ntemplate \u0026lt;uint64_t MOD_VALUE\u0026gt;\nstruct Mod : ModCompanion\u0026lt;uint64_t, MOD_VALUE, typename template_util::minimal_uint\u0026lt;MOD_VALUE\u0026gt;::type\u0026gt; {\n    template\u0026lt;uint64_t VAL\u0026gt;\n    static constexpr uint64_t literal_builder() {\n        return VAL;\n    }\n\n    template\u0026lt;uint64_t VAL, char DIGIT, char... REST\u0026gt;\n    static constexpr uint64_t literal_builder() {\n        return literal_builder\u0026lt;(10 * VAL + DIGIT - \u00270\u0027) % MOD_VALUE, REST...\u0026gt;();\n    }\n};\n\n\n#define REGISTER_MOD_LITERAL(mod, suffix) \\\ntemplate \u0026lt;char... DIGITS\u0026gt; mod::type operator \u0026quot;\u0026quot; _##suffix() { \\\n    return mod::c\u0026lt;mod::literal_builder\u0026lt;0, DIGITS...\u0026gt;()\u0026gt;(); \\\n}\n\n\ntemplate \u0026lt;class T, T MOD_VALUE, uint64_t MAX\u0026gt;\ninline ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; s, ModVal\u0026lt;T, MOD_VALUE, MAX\u0026gt; val) {\n    s \u0026lt;\u0026lt; val.v();\n    return s;\n}\n\nusing md \u003d Mod\u0026lt;1000000007\u0026gt;;\nusing mt \u003d md::type;\nREGISTER_MOD_LITERAL(md, mod)\n\nstruct Triple {\n    int start, delta, count;\n\n    int end() {\n        return start + delta * (count - 1);\n    }\n};\n\n// ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, const Triple\u0026amp; t) {\n//     out \u0026lt;\u0026lt; \u0026quot;(\u0026quot; \u0026lt;\u0026lt; t.start \u0026lt;\u0026lt; \u0026quot;, \u0026quot; \u0026lt;\u0026lt; t.delta \u0026lt;\u0026lt; \u0026quot;, \u0026quot; \u0026lt;\u0026lt; t.count \u0026lt;\u0026lt; \u0026quot;)\u0026quot;;\n//     return out;\n// }\n\nvoid solve(istream\u0026amp; in, ostream\u0026amp; out) {\n    auto s \u003d next\u0026lt;string\u0026gt;(in);\n    string s1;\n    s1.reserve(2 * s.length());\n    forn (int, i, s.length() / 2) {\n        s1.push_back(s[i]);\n        s1.push_back(s[s.length() - i - 1]);\n    }\n    int n \u003d s1.length();\n    vector\u0026lt;Triple\u0026gt; g;\n    vector\u0026lt;mt\u0026gt; d(n + 1), cache(n + 1);\n    d[0] \u003d 1_mod;\n    forn (int, i, n) {\n        vector\u0026lt;Triple\u0026gt; g1;\n        int prev \u003d -i - 1;\n        auto push \u003d [\u0026amp;](Triple t) {\n            if (g1.empty() || t.delta !\u003d g1.back().delta) {\n                g1.push_back(t);\n            } else {\n                g1.back().count +\u003d t.count;\n            }\n        };\n        for (auto t : g) {\n            if (t.start \u0026gt; 0 \u0026amp;\u0026amp; s1[t.start - 1] \u003d\u003d s1[i]) {\n                t.start--;\n                if (prev !\u003d t.start - t.delta) {\n                    push(Triple{t.start, t.start - prev, 1});\n                    t.start +\u003d t.delta;\n                    t.count--;\n                }\n                if (t.count \u0026gt; 0) {\n                    push(t);\n                }\n                prev \u003d t.end();\n            }\n        }\n        if (i \u0026gt;\u003d 1 \u0026amp;\u0026amp; s1[i - 1] \u003d\u003d s1[i]) {\n            push(Triple{i - 1, i - 1 - prev, 1});\n        }\n        g \u003d move(g1);\n        for (auto\u0026amp; t : g) {\n            mt add \u003d d[t.end()];\n            if (t.count \u0026gt; 1) {\n                add +\u003d cache[t.start - t.delta];\n            }\n            if (t.start - t.delta \u0026gt;\u003d 0) {\n                cache[t.start - t.delta] \u003d add;\n            }\n            d[i + 1] +\u003d add;\n        }\n    }\n    out \u0026lt;\u0026lt; d[n] \u0026lt;\u0026lt; endl;\n}\n\n\nint main() {\n    solve(cin, cout);\n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["editorial","icm","technex","932"]}}