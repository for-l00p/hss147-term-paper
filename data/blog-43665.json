{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1457461972,"rating":1,"authorHandle":"dorellin","modificationTimeSeconds":1457465130,"id":43665,"title":"\u003cp\u003eGema Aula 2 2016 — Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eMais uma vez, parábens a todos que tentaram resolver os exercícios :)\u003c/p\u003e\u003cp\u003eVamos às soluções dos problemas da Aula 2!\u003c/p\u003e\u003ch2\u003eProblema A — Such Math (by \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/danft\" title\u003d\"Candidate Master danft\"\u003edanft\u003c/a\u003e)\u003c/h2\u003e\u003cp\u003eNesse problema, você deveria utilizar a propriedade de que \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e - \u003ci\u003ey\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e \u003d (\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e)(\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e. Com essa expressão, era possível descobrir que \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e \u003d \u003ci\u003ep\u003c/i\u003e\u003c/span\u003e e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e \u003d 1\u003c/span\u003e, pois um número primo só pode ser produto de 1 com ele mesmo. Resolvendo a equação, chegamos em \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003ey\u003c/i\u003e \u003d \u003ci\u003ep\u003c/i\u003e - 1\u003c/span\u003e , \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e \u003d (\u003ci\u003ep\u003c/i\u003e - 1) / 2\u003c/span\u003e e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d 1 + (\u003ci\u003ep\u003c/i\u003e - 1) / 2\u003c/span\u003e. O único caso especial a ser tratado é quando \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e \u003d 2\u003c/span\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint main(void) {\n\tint p;\n\t\n\tcin\u0026gt;\u0026gt;p;\n\t\n\tif(p\u003d\u003d2) {\n\t    cout\u0026lt;\u0026lt;\u0026quot;0\\n\u0026quot;;\n\t} else {\n\t    cout \u0026lt;\u0026lt; \u0026quot;1\\n\u0026quot;;\n        int a \u003d 1 + (p-1)/2;\n        int b \u003d (p-1)/2;\n        cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n\t}\n\t\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eProblema B — Cavernoso (by \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/lfdorelli\" title\u003d\"Expert lfdorelli\"\u003elfdorelli\u003c/a\u003e)\u003c/h2\u003e\u003cp\u003eNesse problema, você deveria ler diversas strings que representavam números — e calcular o tamanho delas. A saída deve ser o tamanho mais frequente de string. \u003c/p\u003e\u003cp\u003ePara calcular o tamanho mais frequente, vamos utilizar um vetor \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003eN\u003c/i\u003e]\u003c/span\u003e, onde \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e \u003d 1001\u003c/span\u003e. Esse vetor, na i-ésima posição, irá representar quantas vezes já apareceu uma string de tamanho \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Com isso, no final basta olhar o tamanho que tem maior valor nesse vetor (lembre-se que os tamanhos de string vão até 1000 — está escrito na entrada).\u003c/p\u003e\u003cp\u003ePara ler as strings você poderia utilizar \u003ccode\u003escanf(\u0026quot;%s\u0026quot;, s)\u003c/code\u003e, ou utilizar a \u003ccode\u003estring\u003c/code\u003e do C++ (veja como funciona na solução exemplo abaixo). \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nconst int N \u003d 1001;\nint cnt[N];\n\nint main (void) {\n    int n;\n    int best \u003d 1;\n    cin \u0026gt;\u0026gt; n;\n\n    string s;\n    for (int i \u003d 0; i \u0026lt; n; ++i) {\n        cin \u0026gt;\u0026gt; s;\n        cnt[s.size()]++;\n        if (cnt[s.size()] \u0026gt; cnt[best]) {\n            best \u003d s.size();\n        }\n    }\n    cout \u0026lt;\u0026lt; best \u0026lt;\u0026lt; endl;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSe quiser ver uma solução com \u003ccode\u003escanf\u003c/code\u003e bastante legível, veja a solução da \u003ca class\u003d\"rated-user user-black\" href\u003d\"/profile/BarbaraCortes\" title\u003d\"Unrated, BarbaraCortes\"\u003eBarbaraCortes\u003c/a\u003e: \u003ca href\u003d\"/group/gy03x0glsj/contest/206347/submission/16471357\" title\u003d\"Submission 16471357 by BarbaraCortes\"\u003e16471357\u003c/a\u003e.\u003c/p\u003e\u003ch2\u003eProblema C — Como está sua lógica? (by \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/rodz\" title\u003d\"Specialist rodz\"\u003erodz\u003c/a\u003e)\u003c/h2\u003e\u003cp\u003eNesse problema, você deveria checar se a afirmação: ** \u0026quot;Toda carta que tem em um dos lados um número positivo par tem também, no seu verso, um número negativo ímpar\u0026quot;**. Para checar isso, você deve checar toda carta voltada para cima que tem um número inteiro positivo par (pois a afirmação diz que se isso ocorrer, ela tem que ter um negativo ímpar nas costas) e toda carta negativa par (pois se ela tiver um número positivo par nas costas, você pode concluir que a afirmação é falsa). Juntando as duas coisas, você percebe que basta contar o número de entradas pares!\u003c/p\u003e\u003cp\u003eCom isso, a solução fica simples. O código abaixo testa explicitamente as condições descritas no enunciado, mas basta testar se \u003c/p\u003e\u003cp\u003eUnable to parse markup [type\u003dCF_TEX]\u003c/p\u003e. \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint main()\n{\n\tint n, ans \u003d 0;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\tfor (int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tint x;\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;x);\n\t\tif ((x \u0026gt; 0 and x%2 \u003d\u003d 0) or (x \u0026lt; 0 and x%2 \u003d\u003d 0)) {\n\t\t\tans++;\n                }\n\t}\n\tprintf(\u0026quot;%d\\n\u0026quot;, ans);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eProblema D — Palíndromos (by \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/tomasf\" title\u003d\"Candidate Master tomasf\"\u003etomasf\u003c/a\u003e)\u003c/h2\u003e\u003cp\u003ePara transformar uma string em palíndromo com o menor número de operações, você deve apenas olhar se o caractere correspondente de cada posição na primeira metade é igual ou diferente. Se for diferente, é uma mudança a mais que terá de ser feita. \u003c/p\u003e\u003cp\u003eAlgumas pessoas montaram uma string auxiliar invertida para resolver esse problema. Veja que isso não é necessário. Basta ver, para as primeiras \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e / 2\u003c/span\u003e posições, se a posição \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1 - \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e é igual. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint main(){\n\tint n;\n\tstring s;\n\tcin \u0026gt;\u0026gt; n;\n\tcin \u0026gt;\u0026gt; s;\n\tint ans \u003d 0;\n\tfor(int i \u003d 0; i \u0026lt; n/2; i++){\n\t\tans +\u003d s[i] !\u003d s[s.size() - 1 - i];\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eProblema E — Como proceder? (by \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/samuelfgs96\" title\u003d\"Expert samuelfgs96\"\u003esamuelfgs96\u003c/a\u003e)\u003c/h2\u003e\u003cp\u003eNesse problema você recebia várias consultas em um vetor. Cada consulta pediu a soma dos elementos do vetor em um intervalo [L, R]. No total, tínhamos \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e\u003c/span\u003e consultas e \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e elementos no vetor. Uma solução direta para esse problema que excede o tempo limite é passar, para cada consulta, por todos os intervalos somando os valores. \u003c/p\u003e\u003cp\u003ePara se convencer de que isso é lento, vamos estimar a quantidade de operações realizadas. Vamos supor que cada consulta tenha tamanho \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e (a consulta vai da primeira até a última posição). Faremos então \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e * 10\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e10\u003c/sup\u003e\u003c/span\u003e operações. Em um tempo de 2s, é possível realizar até mais ou menos \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e8\u003c/sup\u003e\u003c/span\u003e operações. Essa análise é uma simplificação, é claro, e mais adiante teremos uma aula de análise de complexidade de algoritmos. Por ora, basta entender que essa solução não é rápida suficiente para passar no tempo.\u003c/p\u003e\u003cp\u003eComo proceder então?\u003c/p\u003e\u003cp\u003eSuponha que o vetor com os números originais seja \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e. Guardaremos um vetor adicional, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e, onde \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ea/58/ea58b707da7cbca38bf597c3f90c43e588c2ed52.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Ou seja, esse vetor guarda a soma acumulada dos elementos da posição 1 até a posição K. Sabemos então que, se quisermos calcular a soma de L a R (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e ≤ \u003ci\u003eR\u003c/i\u003e\u003c/span\u003e) basta fazer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003eB\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e (assuma que \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e \u003d 0\u003c/span\u003e ou trate separado). Por quê isso funciona? Temos: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0a/e8/0ae8b4821c98f7393de4a64a4752b92201c6d744.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e , pois a soma de 1 a R contém a soma de 1 a L-1. Em outras palavras, trocamos um loop por uma subtração. Ou seja, diminuímos em até \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e operações necessárias para responder cada consulta, e temos \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e\u003c/span\u003e consultas no total. Com essa abordagem, é possível resolver o problema :)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eEXTRA\u003c/strong\u003e : Quem tiver interessado em aprender já, aqui vai um link sobre complexidade computacional e análise de algoritmos na prática: \u003ca href\u003d\"https://www.topcoder.com/community/data-science/data-science-tutorials/computational-complexity-section-1/\"\u003ehttps://www.topcoder.com/community/data-science/data-science-tutorials/computational-complexity-section-1/\u003c/a\u003e\u003c/p\u003e\u003cp\u003eUm erro comum nesse problema foi tentar resolvê-lo utilizando o tipo \u003ccode\u003eint\u003c/code\u003e. Esse tipo não era capaz de armazenar a resposta (que era da ordem de \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e12\u003c/sup\u003e\u003c/span\u003e no pior caso), portanto, utilizamos \u003ccode\u003elong long int\u003c/code\u003e. Veja o FAQ no post da aula 2 nesse blog para mais detalhes.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nconst int N \u003d 1001000;\ntypedef long long ll;\n\nll values[N];\n\nint main (void) {\n\tint n, m, temp;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\tfor (int i \u003d 1; i \u0026lt;\u003d n; i++) {\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;temp);\n\t\tvalues[i] \u003d values[i-1] + temp;\n\t}\n\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;m);\n\tfor (int i \u003d 0; i \u0026lt; m; i++) {\n\t\tint l, r;\n\t\tscanf(\u0026quot;%d %d\u0026quot;, \u0026amp;l, \u0026amp;r);\n\t\tcout \u0026lt;\u0026lt; values[r] - values[l-1] \u0026lt;\u0026lt; endl;\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRepare no \u003ccode\u003etypedef long long int ll\u003c/code\u003e. Isso apenas faz com que sempre que digitamos \u003ccode\u003ell\u003c/code\u003e estejamos nos referindo ao tipo \u003ccode\u003elong long int\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eÉ isso aí! :D Espero que tenham gostado. \u003c/p\u003e\u003c/div\u003e","tags":[]}}