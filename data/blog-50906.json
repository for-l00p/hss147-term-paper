{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1489176717,"rating":3,"authorHandle":"BitHashTech","modificationTimeSeconds":1489178872,"id":50906,"title":"\u003cp\u003eTrie â€” data structure \u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThe base idea that we need to store some strings, search for something in them, delete them. Can we do this fast?\u003c/p\u003e\u003cp\u003eIf we used a set what will be the complexity?\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eComplexity\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eInsertion and finding are O(log N) where N is the number of elements in the set but we are searching strings so O((log N) * L)where L is the max length of a string. But we are inserting N elements right? so the building itself takes O(N * log(N) * L).\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eCan we do better? We need to insert a string and search for a string in linear time. \u003c/p\u003e\u003cp\u003eLet\u0027s introduce \u0026quot; \u003cstrong\u003eTrie\u003c/strong\u003e \u0026quot;:\u003c/p\u003e\u003cp\u003eTrie is a data structure that supports inserting, searching, deleting in linear time relatively O(L) where L is length of string.\u003c/p\u003e\u003cp\u003eLets define the language to be English letters, {a,b,c ... z}. \u003c/p\u003e\u003cp\u003eTrie is a tree that consists of nodes that represent a state and edges that represent transitions. Each node has a flag to mark if it is an end of a word or not and has 26 child representing 26 different states that can be reached from our state using the alphabetic (26 letters) initialized by NULL.\u003c/p\u003e\u003cp\u003eLets have an example: We want to add word \u0026quot;hello\u0026quot; to our trie :- \u003c/p\u003e\u003cp\u003eInitially our trie looks like this.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/4d/e8/4de8be46d1d26be11294d60f508bcab8cd9543d5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eEvery node is pointing to NULL.\u003c/p\u003e\u003cp\u003eNow we want to add each letter one by one. \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/ca/42/ca42aee1d7a74adee09a549aba04761078759f39.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003ethe \u0027h\u0027 edge only pointed to new node which pointed to new 26 NULL. We continue adding .. \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/5d/0b/5d0bd8a3daf3c57e563fbf69d705981bdf679755.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cimg alt\u003d\" \" src\u003d\"/predownloaded/b5/19/b519dafe2b42fdc302fdd2bce03a9d5ac1218ce1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cimg alt\u003d\" \" src\u003d\"/predownloaded/82/4a/824a43c8692b0bc2d997765dbf40e5ea160b5034.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eNow we have reached the last character, So we mark it.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/af/bc/afbc90d6a621b5d43931721f901bd0e94bc0bc90.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eSo lets add the word \u0026quot;him\u0026quot; \u003c/p\u003e\u003cp\u003e\u0027h\u0027 is already created, so we go to it.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/b7/ac/b7acfd7dfd292b1cccf14259135893a72a372fd5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eand proceed as normal .. \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/e2/52/e252b128a32b71f3818a779850e9b48fe07cc76a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cimg alt\u003d\" \" src\u003d\"/predownloaded/bf/06/bf06c34e1061545aefa079b28ecc5f1165dff46d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThat\u0027s it. \u003c/p\u003e\u003cp\u003eWhat if we want to search? we just traverse the nodes if they are not NULL or report that the word doesn\u0027t exist.\u003c/p\u003e\u003cp\u003eSo lets go deeper into code :- \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eNode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003estruct Node {\n    Node* arr[26];\n    bool isWord;\n\n    Node() {\n        isWord \u003d false;\n        for ( int i \u003d 0 ; i \u0026lt; 26 ; i++ )\n            arr[i] \u003d NULL ;\n    }\n};\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003einsert\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003evoid insert(node* trieRoot, string \u0026amp;s) {\n    Node *tmp \u003d trieRoot;\n    for (int i \u003d 0; i \u0026lt; s.size(); i++) {\n        if (tmp-\u0026gt;arr[s[i]-\u0027a\u0027] \u003d\u003d NULL)\n            tmp-\u0026gt;arr[s[i]-\u0027a\u0027] \u003d new Node();\n        tmp \u003d tmp-\u0026gt;arr[s[i]-\u0027a\u0027];\n    }\n    tmp-\u0026gt;isWord \u003d true;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003esearch\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003ebool search(Node *trieRoot, string \u0026amp;S)\n{\n    for ( int i \u003d 0 ; i \u0026lt; S.size() ; i++ ) \n        if ( trieRoot-\u0026gt;arr[S[i]-\u0027a\u0027] \u003d\u003d NULL ) return false ; \n        else trieRoot \u003d trieRoot-\u0026gt;arr[S[i]-\u0027a\u0027] ;\n    \n    return trieRoot-\u0026gt;isWord; \n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003edelete\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eDo it yourself. :) \u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eResources :\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://www.geeksforgeeks.org/trie-insert-and-search/\"\u003eGeeksforGeeks\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://www.topcoder.com/community/data-science/data-science-tutorials/using-tries/\"\u003eTopCoder\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://www.youtube.com/watch?v\u003dIGaJWl0jPY4\"\u003eVideo : Mostafa Saad\u003c/a\u003e \u003c/p\u003e\u003cp\u003eProblems :\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/514/c\"\u003eWatto and Mechanism\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/706/problem/D\"\u003eVasiliy\u0027s Multiset\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/456/problem/D\"\u003eA Lot of Games\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["trie","data structure","strings"]}}