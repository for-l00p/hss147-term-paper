{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1413913087,"rating":27,"authorHandle":"Corei13","modificationTimeSeconds":1413913087,"id":14378,"title":"\u003cp\u003eAn O(|V|^2 |E|^{1/2}) Implementation of Push-Relabel Maximum Flow Algorithm\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eFor those who are interested, a C++11 implementation of highest-label push relabel maximum flow algorithm. Style and format is taken from \u003ca href\u003d\"http://web.stanford.edu/~liszt90/acm/notebook.html#file3\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eUses just gap relabeling heuristic. Global relabeling heuristic was implemented but removed because of poor performance.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e/*\n    Implementation of highest-label push-relabel maximum flow\n    with gap relabeling heuristic.\n\n    Running time:\n        O(|V|^2|E|^{1/2})\n\n    Usage:\n        - add edges by AddEdge()\n        - GetMaxFlow(s, t) returns the maximum flow from s to t\n    \n    Input:\n        - graph, constructed using AddEdge()\n        - (s, t), (source, sink)\n\n    Output:\n        - maximum flow value\n\n    Todo:\n        - implement Phase II (flow network from preflow network)\n        - implement GetMinCut()\n*/\n\ntemplate \u0026lt;class T\u0026gt; struct Edge {\n    int from, to, index;\n    T cap, flow;\n\n    Edge(int from, int to, T cap, T flow, int index): from(from), to(to), cap(cap), flow(flow), index(index) {}\n};\n\ntemplate \u0026lt;class T\u0026gt; struct PushRelabel {\n    int n;\n    vector \u0026lt;vector \u0026lt;Edge \u0026lt;T\u0026gt;\u0026gt;\u0026gt; adj;\n    vector \u0026lt;T\u0026gt; excess;\n    vector \u0026lt;int\u0026gt; dist, count;\n    vector \u0026lt;bool\u0026gt; active;\n    vector \u0026lt;vector \u0026lt;int\u0026gt;\u0026gt; B;\n    int b;\n    queue \u0026lt;int\u0026gt; Q;\n\n    PushRelabel (int n): n(n), adj(n) {}\n\n    void AddEdge (int from, int to, int cap) {\n        adj[from].push_back(Edge \u0026lt;T\u0026gt;(from, to, cap, 0, adj[to].size()));\n        if (from \u003d\u003d to) {\n            adj[from].back().index++;\n        }\n        adj[to].push_back(Edge \u0026lt;T\u0026gt;(to, from, 0, 0, adj[from].size() - 1));\n\n    }\n\n    void Enqueue (int v) {\n        if (!active[v] \u0026amp;\u0026amp; excess[v] \u0026gt; 0 \u0026amp;\u0026amp; dist[v] \u0026lt; n) {\n            active[v] \u003d true;\n            B[dist[v]].push_back(v);\n            b \u003d max(b, dist[v]);\n        }\n    }\n\n    void Push (Edge \u0026lt;T\u0026gt; \u0026amp;e) {\n        T amt \u003d min(excess[e.from], e.cap - e.flow);\n        if (dist[e.from] \u003d\u003d dist[e.to] + 1 \u0026amp;\u0026amp; amt \u0026gt; T(0)) {\n            e.flow +\u003d amt;\n            adj[e.to][e.index].flow -\u003d amt;\n            excess[e.to] +\u003d amt;    \n            excess[e.from] -\u003d amt;\n            Enqueue(e.to);\n        }\n    }\n\n    void Gap (int k) {\n        for (int v \u003d 0; v \u0026lt; n; v++) if (dist[v] \u0026gt;\u003d k) {\n            count[dist[v]]--;\n            dist[v] \u003d max(dist[v], n);\n            count[dist[v]]++;\n            Enqueue(v);\n        }\n    }\n\n    void Relabel (int v) {\n        count[dist[v]]--;\n        dist[v] \u003d n;\n        for (auto e: adj[v]) if (e.cap - e.flow \u0026gt; 0) {\n            dist[v] \u003d min(dist[v], dist[e.to] + 1);\n        }\n        count[dist[v]]++;\n        Enqueue(v);\n    }\n\n    void Discharge(int v) {\n        for (auto \u0026amp;e: adj[v]) {\n            if (excess[v] \u0026gt; 0) {\n                Push(e);\n            } else {\n                break;\n            }\n        }\n\n        if (excess[v] \u0026gt; 0) {\n            if (count[dist[v]] \u003d\u003d 1) {\n                Gap(dist[v]); \n            } else {\n                Relabel(v);\n            }\n        }\n    }\n\n    T GetMaxFlow (int s, int t) {\n        dist \u003d vector \u0026lt;int\u0026gt;(n, 0), excess \u003d vector\u0026lt;T\u0026gt;(n, 0), count \u003d vector \u0026lt;int\u0026gt;(n + 1, 0), active \u003d vector \u0026lt;bool\u0026gt;(n, false), B \u003d vector \u0026lt;vector \u0026lt;int\u0026gt;\u0026gt;(n), b \u003d 0;\n        \n        for (auto \u0026amp;e: adj[s]) {\n            excess[s] +\u003d e.cap;\n        }\n\n        count[0] \u003d n;\n        Enqueue(s);\n        active[t] \u003d true;\n        \n        while (b \u0026gt;\u003d 0) {\n            if (!B[b].empty()) {\n                int v \u003d B[b].back();\n                B[b].pop_back();\n                active[v] \u003d false;\n                Discharge(v);\n            } else {\n                b--;\n            }\n        }\n        return excess[t];\n    }\n\n    T GetMinCut (int s, int t, vector \u0026lt;int\u0026gt; \u0026amp;cut);\n};\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["max flow","push-relabel"]}}