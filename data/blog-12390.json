{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1400843928,"rating":1,"authorHandle":"fire_bot","modificationTimeSeconds":1400845499,"id":12390,"title":"\u003cp\u003eJava TLE but C++ AC.. Why?\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eGood day,\u003c/p\u003e\u003cp\u003eYesterday I was solving a simple UVA problem \u003ca href\u003d\"http://uva.onlinejudge.org/index.php?option\u003dcom_onlinejudge\u0026amp;Itemid\u003d8\u0026amp;category\u003d24\u0026amp;page\u003dshow_problem\u0026amp;problem\u003d3057\"\u003e11906 — Knight in a War Grid\u003c/a\u003e and got TLE \u0026gt; 1.000s using DFS. I removed recursion, reduced code to primitives and arrays. Even changed BufferedReader + split to Scanner but it didn\u0027t help to pass the limit. Reworked it in С++ and got AC for 0.038 ms.. Can anyone tell me where is the problem?\u003c/p\u003e\u003cp\u003e---------- Java ----------\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n\tprivate static int[][] grid \u003d new int[101][101];\n\tprivate static boolean[][] visited \u003d new boolean [101][101];\t\n\tprivate static int[] xStack \u003d new int[1000000];\n\tprivate static int[] yStack \u003d new int[1000000];\n\t\n\tprivate static int i, j;\n\t\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tBufferedReader reader \u003d new BufferedReader(new InputStreamReader(System.in));\n\t\tint T, W, R, C, M, N, caseNr \u003d 1, even, odd, newX, newY, gridVal, stackPointer, tx, ty, isize;\n\t\tT \u003d Integer.valueOf(reader.readLine());\n\t\tString[] line \u003d null;\t\t\n\t\tint[][] inc \u003d null;\n\t\t\n\t\twhile(T-- !\u003d 0)\n\t\t{\n\t\t\t\n\t\t\tline \u003d reader.readLine().split(\u0026quot;\\\\s+\u0026quot;);\n\t\t\tR \u003d Integer.valueOf(line[0]);\n\t\t\tC \u003d Integer.valueOf(line[1]);\n\t\t\tM \u003d Integer.valueOf(line[2]);\n\t\t\tN \u003d Integer.valueOf(line[3]);\n\t\t\t\n\t\t\tW \u003d Integer.valueOf(reader.readLine());\n\t\t\t\n\t\t\tif (N \u003d\u003d M)\n\t\t\t{\n\t\t\t\tinc \u003d new int[][] { { N, M }, { N, -M}, {-N, M}, {-N, -M} };\n\t\t\t}\n\t\t\telse if (N \u003d\u003d 0 || M \u003d\u003d 0)\n\t\t\t{\n\t\t\t\tinc \u003d new int[][] { { N, M }, { N, -M}, {M, N}, {-M, N} };\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tinc \u003d new int[][] { { N, M }, { N, -M}, {-N, M}, {-N, -M}, {M, N}, {M, -N}, {-M, N} , {-M, -N} };\n\t\t\t}\n\t\t\t\n\t\t\twhile(W-- !\u003d 0)\n\t\t\t{\n\t\t\t\tline \u003d reader.readLine().split(\u0026quot;\\\\s+\u0026quot;);\n\t\t\t\tgrid[Integer.valueOf(line[0])][Integer.valueOf(line[1])] \u003d -1;\n\t\t\t}\n\t\t\t\n\t\t\teven \u003d odd \u003d stackPointer \u003d 0;\n\n\t\t\txStack[stackPointer] \u003d 0;\n\t\t\tyStack[stackPointer] \u003d 0;\n\t\t\t\n\t\t\tisize \u003d inc.length;\n\t\t\t\n\t\t\twhile(stackPointer !\u003d -1)\n\t\t\t{\n\t\t\t\ttx \u003d xStack[stackPointer];\n\t\t\t\tty \u003d yStack[stackPointer];\n\t\t\t\tstackPointer--;\n\t\t\t\t\n\t\t\t\tif (!visited[tx][ty])\n\t\t\t\t{\n\t\t\t\t\tvisited[tx][ty] \u003d true;\n\t\t\t\t\t\n\t\t\t\t\tfor(i \u003d 0; i \u0026lt; isize; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewX \u003d tx + inc[i][0]; \n\t\t\t\t\t\tnewY \u003d ty + inc[i][1];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (newX \u0026gt;\u003d 0 \u0026amp;\u0026amp; newX \u0026lt; R \u0026amp;\u0026amp; newY \u0026gt;\u003d 0 \u0026amp;\u0026amp; newY \u0026lt; C \u0026amp;\u0026amp; grid[newX][newY] !\u003d -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgrid[newX][newY]++;\n\t\t\t\t\t\t\tstackPointer++;\n\t\t\t\t\t\t\txStack[stackPointer] \u003d newX;\n\t\t\t\t\t\t\tyStack[stackPointer] \u003d newY;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(i \u003d 0; i \u0026lt; R; i++)\n\t\t\t{\n\t\t\t\tfor(j \u003d 0; j \u0026lt; C; j++)\n\t\t\t\t{\n\t\t\t\t\tgridVal \u003d grid[i][j];\n\n\t\t\t\t\tif (gridVal \u0026gt; 0 || (i \u003d\u003d 0 \u0026amp;\u0026amp; j \u003d\u003d 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (gridVal % 2 \u003d\u003d 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\teven++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\todd++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tgrid[i][j] \u003d 0;\n\t\t\t\t\tvisited[i][j] \u003d false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.printf(\u0026quot;Case %d: %d %d%n\u0026quot;, caseNr++, even, odd);\n\t\t}\n\t\t\n\t}\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e---------- C++ ----------\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;map\u0026gt;\n\nusing namespace std;\n\n\nint grid[101][101];\nbool visited[101][101];    \nint xStack[1000000];\nint yStack[1000000];\n\nint i, j;\n    \nint main()\n{\n\t\n\tint T, W, R, C, M, N, caseNr \u003d 1, even, odd, newX, newY, gridVal, stackPointer, tx, ty;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;T);\n\tset\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; inc;\n\twhile(T-- !\u003d 0)\n\t{\n\t\tscanf(\u0026quot;%d %d %d %d %d\u0026quot;, \u0026amp;R, \u0026amp;C, \u0026amp;M, \u0026amp;N, \u0026amp;W);\n\t\tinc.clear();\n                inc.insert(make_pair(N, M));\n                inc.insert(make_pair(N, -M));\n                inc.insert(make_pair(-N, M));\n                inc.insert(make_pair(-N, -M));\n                inc.insert(make_pair(M, N));\n                inc.insert(make_pair(M, -N));\n                inc.insert(make_pair(-M, N));\n                inc.insert(make_pair(-M, -N));\n\t\t\n\t\twhile(W-- !\u003d 0)\n\t\t{\n\t\t\tscanf(\u0026quot;%d %d\u0026quot;, \u0026amp;i, \u0026amp;j);\n\t\t\tgrid[i][j] \u003d -1;\n\t\t}\n\t\t\n\t\teven \u003d odd \u003d stackPointer \u003d 0;\n\n\t\txStack[stackPointer] \u003d 0;\n\t\tyStack[stackPointer] \u003d 0;\n\t\t\n\t\t//printf(\u0026quot;%d\\n\u0026quot;, inc.size());\n\t\t\n\t\tset\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt;::iterator it;\n\t\twhile(stackPointer !\u003d -1)\n\t\t{\n\t\t\ttx \u003d xStack[stackPointer];\n\t\t\tty \u003d yStack[stackPointer];\n\t\t\tstackPointer--;\n\t\t\t\n\t\t\tif (!visited[tx][ty])\n\t\t\t{\n\t\t\t\tvisited[tx][ty] \u003d true;\n\t\t\t\t\n\t\t\t\tfor (it \u003d inc.begin(); it !\u003d inc.end(); ++it)\n                {\n\t\t\t\t\tnewX \u003d tx + (*it).first; \n\t\t\t\t\tnewY \u003d ty + (*it).second;\n\t\t\t\t\t\n\t\t\t\t\tif (newX \u0026gt;\u003d 0 \u0026amp;\u0026amp; newX \u0026lt; R \u0026amp;\u0026amp; newY \u0026gt;\u003d 0 \u0026amp;\u0026amp; newY \u0026lt; C \u0026amp;\u0026amp; grid[newX][newY] !\u003d -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tgrid[newX][newY]++;\n\t\t\t\t\t\tstackPointer++;\n\t\t\t\t\t\txStack[stackPointer] \u003d newX;\n\t\t\t\t\t\tyStack[stackPointer] \u003d newY;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(i \u003d 0; i \u0026lt; R; i++)\n\t\t{\n\t\t\tfor(j \u003d 0; j \u0026lt; C; j++)\n\t\t\t{\n\t\t\t\tgridVal \u003d grid[i][j];\n\n\t\t\t\tif (gridVal \u0026gt; 0 || (i \u003d\u003d 0 \u0026amp;\u0026amp; j \u003d\u003d 0))\n\t\t\t\t{\n\t\t\t\t\tif (gridVal % 2 \u003d\u003d 0)\n\t\t\t\t\t{\n\t\t\t\t\t\teven++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\todd++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tgrid[i][j] \u003d 0;\n\t\t\t\tvisited[i][j] \u003d false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\u0026quot;Case %d: %d %d\\n\u0026quot;, caseNr++, even, odd);\n\t}\n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["c++","java","uva contest"]}}