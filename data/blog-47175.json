{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1474145503,"rating":0,"authorHandle":"1am","modificationTimeSeconds":1474145503,"id":47175,"title":"\u003cp\u003eDay 8 (9/17)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eMulti-source BFS\u003c/h1\u003e\u003cp\u003eFirst we discussed Multi-source BFS, and that if we have more than one source that we want to run a bfs from, we can push them all into the bfs queue if they all have equal priority.\u003c/p\u003e\u003cp\u003eWe solved this problem using that concept: \u003ca href\u003d\"http://www.spoj.com/problems/ABCPATH/\"\u003ehttp://www.spoj.com/problems/ABCPATH/\u003c/a\u003e You find all the possible starting positions (anywhere where there is letter A), push then into vector to later be pushed into queue (or you can push them in queue right away if your queue is global.)\u003c/p\u003e\u003cp\u003eHere is the code for it: \u003ca href\u003d\"http://ideone.com/bKvhfg\"\u003ehttp://ideone.com/bKvhfg\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eDFS / Recursion\u003c/h1\u003e\u003cp\u003eWe then talked about how dfs runs like recursion, and discussed its similarities with the stack data type, while the bfs search takes use of the queue data type. Bfs travels level to level, not going to the next one until the whole level is visited. On the other hand, a dfs search travels depth -first ( hence the name), and then starts backtracking back to its parent that made the function call.\u003c/p\u003e\u003cp\u003eWe discussed that this concept can help us for questions where the depth matters, for example, calculating the size of each subtree in a graph. Here is its code: \u003ca href\u003d\"http://ideone.com/bd8ppg\"\u003ehttp://ideone.com/bd8ppg\u003c/a\u003e\u003c/p\u003e\u003cp\u003eOr for cycle detection in graph like question C from day 8. Here is its code: \u003ca href\u003d\"http://ideone.com/wZ59rw\"\u003ehttp://ideone.com/wZ59rw\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe also solved this question : \u003ca href\u003d\"//codeforces.com/gym/100989/problem/L\"\u003ehttp://codeforces.com/gym/100989/problem/L\u003c/a\u003e using recursion \u003c/p\u003e\u003cp\u003eWe briefly talk about simple task ahah, once again all you have to do is run a bfs from point (0, 0), that will mark everything but the soccer balls as visited. Then you will have the only things not visited is the soccer balls. So you go through and count the number of components that are not visited yet and run a bfs through them.\u003c/p\u003e\u003cp\u003eHere is my old code for it, i definitely wouldnt do the same thing now, in here I change the outside white area to another character, then count the number of components that are not visited. But it is better to do it with one bfs and maybe an extra parameter in the function call to know what colour to watch out for. But here it is for useless reference: \u003ca href\u003d\"http://ideone.com/rPKB86\"\u003ehttp://ideone.com/rPKB86\u003c/a\u003e\u003c/p\u003e\u003cp\u003eGood luck! If I\u0027m missing something, please let me know in a comment below.\u003c/p\u003e\u003cp\u003eThere is a possibility that next week is the last day. Also i am a little uncertain about what to teach, there are the following options:\u003c/p\u003e\u003cp\u003e1 — We solve a mix of random questions, maybe previous ones from unsolved contests, and i will also add new ones with interesting ideas, just to improve problem solving.\u003c/p\u003e\u003cp\u003e2 — We talk more about graph theory like Dijkstra and disjoint sets, and solve some nice graph problems.\u003c/p\u003e\u003cp\u003e3 — Or we focus entirely on dynamic programming\u003c/p\u003e\u003cp\u003eLet me know in a comment or email what you think.\u003c/p\u003e\u003c/div\u003e","tags":[]}}