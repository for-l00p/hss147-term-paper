{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1525078647,"rating":32,"authorHandle":"I_love_myself","modificationTimeSeconds":1526307088,"id":59181,"title":"\u003cp\u003eЗадачка о сумме различных элементов на отрезке с изменениями\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eВсем привет, хочу с вами поделиться интересной задачей и классной идеей.\u003c/p\u003e\u003cp\u003eНеобходимо реализовать структуру данных, выполняющих 2 типа запросов: \u003cbr /\u003e - Изменить элемент в массиве\u003cbr /\u003e - Найти сумму различных элементов с L по R. \u003cbr /\u003e Например массив выглядит так: { 1, 2, 1 }, тогда сумма различных от 1 до 3 равна 3\u003c/p\u003e\u003cp\u003eДля начала \u003cstrong\u003eразберем \u0026quot;лобовое\u0026quot; решение\u003c/strong\u003e задачи за \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/05/27/0527f23dd3261c38f32182dfdab63ba7126872b7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e с помощью корневой оптимизации. Спасибо \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Holidin\" title\u003d\"Candidate Master Holidin\"\u003eHolidin\u003c/a\u003e, который объяснил мне это решение.\u003c/p\u003e\u003cp\u003eПостроим персистентное ДО для суммы различных элементов на отрезке. Заведем еще одно ДО с unordered_map\u0026lt;int, int\u0026gt; в вершине, которое хранит количество элементов, равных X на отрезке. \u003cbr /\u003e Ещё будем накапливать до \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/90/d5/90d5a6cd550a25d4a1e92f4f6e6a222c64aa7a2e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e изменений, если из стало \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/90/d5/90d5a6cd550a25d4a1e92f4f6e6a222c64aa7a2e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, то перестроим наше персистентное ДО заново за \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4c/3c/4c3c85cf6e5c0b720e46ad7622f65d11d323b009.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Чтобы ответить на запрос суммы на отрезке, посчитаем ее с помощью первого ДО, затем пройдемся по всем накопленным изменениям и проверим, входят ли они в наш отрезок и как они меняют сумму с помощью второго ДО с map\u0027ами. Ответ на запрос будет за \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/93/41/9341227bf053e2ee452092ca4e82bd223d9165a3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eТеперь решим задачу нормально\u003c/strong\u003e за \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/94/91/9491cefe4ab27086a5b3d57cb4c1278b7576195c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e в онлайн.\u003c/p\u003e\u003cp\u003eДля начала пусть нам надо просто считать количество различных элементов на отрезке с изменениями.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eКлючевая идея:\u003c/strong\u003e пусть для каждого элемента мы знаем next[i] — индекс следующей позиции j, такой, что a[i] \u003d a[j], i \u0026lt; j. Тогда количество различных элементов на отрезке [L; R] равно \u003cem\u003eколичеству элементов на том же отрезке, у которых next[i] больше R\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eТогда решение очень простое: построим ДО, в котором можно будет считать количество элементов на отрезке [L; R], больших R, для этого в вершине будем хранить ДД по ключу(next[i]). Чтобы обновлять next[i], я лично поддерживал map\u0026lt;int, set\u0026gt;, элемент которого m[x] означает множество позиций, на которых стоят x.\u003c/p\u003e\u003cp\u003eТеперь вернемся к нашей задаче. Чтобы добить её, нужно в декартаче по ключу(next[i]) хранить сумму a[i] в поддереве.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD:\u003c/strong\u003e \u003ca href\u003d\"http://www.spoj.com/problems/XXXXXXXX/\"\u003eСсылка на задачу\u003c/a\u003e Спасибо \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/kefaa\" title\u003d\"Candidate Master kefaa\"\u003ekefaa\u003c/a\u003e и \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/khadaev\" title\u003d\"Grandmaster khadaev\"\u003ekhadaev\u003c/a\u003e \u003cbr /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eРешение в онлайн\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;set\u0026gt;\n\nusing namespace std;\n\n#define int long long\n\n//x - next[]\n//el - value in a\n\nstruct Node {\n\tNode *l, *r;\n\tint x, y;\n\tint el;\n\tint s;\n\n\tNode(int x, int el) : x(x), y(rand()), l(0), r(0), s(el), el(el) {}\n};\n\nint get_s(Node *v)\n{\n\treturn v \u003d\u003d 0 ? 0 : v-\u0026gt;s;\n}\n\nvoid upd(Node *v)\n{\n\tif (v \u003d\u003d 0)\n\t\treturn;\n\tv-\u0026gt;s \u003d get_s(v-\u0026gt;l) + v-\u0026gt;el + get_s(v-\u0026gt;r);\n}\n\nNode *merge(Node *a, Node *b)\n{\n\tif (a \u003d\u003d 0)\n\t\treturn b;\n\tif (b \u003d\u003d 0)\n\t\treturn a;\n\n\tif (a-\u0026gt;y \u0026lt; b-\u0026gt;y) {\n\t\ta-\u0026gt;r \u003d merge(a-\u0026gt;r, b);\n\t\tupd(a);\n\t\treturn a;\n\t}\n\telse {\n\t\tb-\u0026gt;l \u003d merge(a, b-\u0026gt;l);\n\t\tupd(b);\n\t\treturn b;\n\t}\n}\n\npair\u0026lt;Node *, Node *\u0026gt; split(Node *v, int x)\n{\n\tif (v \u003d\u003d 0)\n\t\treturn { 0, 0 };\n\n\tif (v-\u0026gt;x \u0026lt; x) {\n\t\tauto t \u003d split(v-\u0026gt;r, x);\n\t\tv-\u0026gt;r \u003d t.first;\n\t\tupd(v);\n\t\treturn { v, t.second };\n\t}\n\telse {\n\t\tauto t \u003d split(v-\u0026gt;l, x);\n\t\tv-\u0026gt;l \u003d t.second;\n\t\tupd(v);\n\t\treturn { t.first, v };\n\t}\n}\n\nNode *insert(Node *v, int x, int el)\n{\n\tauto a \u003d split(v, x);\n\tauto b \u003d split(a.second, x + 1);\n\n\tif (b.first \u003d\u003d 0)\n\t\treturn merge(merge(a.first, new Node(x, el)), b.second);\n\telse {\n\t\tb.first-\u0026gt;el +\u003d el;\n\t\tb.first-\u0026gt;s +\u003d el;\n\t\treturn merge(a.first, merge(b.first, b.second));\n\t}\n}\n\nNode *erase(Node *v, int x, int el)\n{\n\tauto a \u003d split(v, x);\n\tauto b \u003d split(a.second, x + 1);\n\n\tif (b.first-\u0026gt;el \u003d\u003d el)\n\t\treturn merge(a.first, b.second);\n\telse {\n\t\tb.first-\u0026gt;el -\u003d el;\n\t\tb.first-\u0026gt;s -\u003d el;\n\t\treturn merge(a.first, merge(b.first, b.second));\n\t}\n}\n\nint cnt_lager_k(Node *\u0026amp;v, int k)\n{\n\tauto t \u003d split(v, k);\n\n\tint ans;\n\tans \u003d get_s(t.second);\n\n\tv \u003d merge(t.first, t.second);\n\treturn ans;\n}\n\nvector\u0026lt;int\u0026gt; nextv, a;\nvector\u0026lt;Node *\u0026gt; t;\n\nvoid build(int v, int l, int r)\n{\n\tt[v] \u003d 0;\n\tfor (int i \u003d l; i \u0026lt; r; i++)\n\t\tt[v] \u003d insert(t[v], nextv[i], a[i]);\n\n\tif (r - l \u0026gt; 1) {\n\t\tint m \u003d (l + r) \u0026gt;\u0026gt; 1;\n\t\tbuild(2 * v + 1, l, m);\n\t\tbuild(2 * v + 2, m, r);\n\t}\n}\n\nvoid update(int v, int l, int r, int pos, int lastx, int lastel) //v - l - r - pos - last_nextv[pos] - last_a[pos]\n{\n\tt[v] \u003d erase(t[v], lastx, lastel);\n\tt[v] \u003d insert(t[v], nextv[pos], a[pos]);\n\n\tif (r - l \u0026gt; 1) {\n\t\tint m \u003d (l + r) \u0026gt;\u0026gt; 1;\n\t\tif (pos \u0026lt; m)\n\t\t\tupdate(2 * v + 1, l, m, pos, lastx, lastel);\n\t\telse\n\t\t\tupdate(2 * v + 2, m, r, pos, lastx, lastel);\n\t}\n}\n\nint get_sum(int v, int l, int r, int ql, int qr)\n{\n\tif (qr \u0026lt;\u003d l || r \u0026lt;\u003d ql)\n\t\treturn 0;\n\telse if (ql \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026lt;\u003d qr)\n\t\treturn cnt_lager_k(t[v], qr);\n\telse {\n\t\tint m \u003d (l + r) \u0026gt;\u0026gt; 1;\n\t\treturn get_sum(2 * v + 1, l, m, ql, qr) + get_sum(2 * v + 2, m, r, ql, qr);\n\t}\n}\n\n\nconst int INF \u003d 1e+6;\nint n;\n\nvoid querry(map\u0026lt;int, set\u0026lt;int\u0026gt;\u0026gt; \u0026amp;next)\n{\n\tchar type;\n\tcin \u0026gt;\u0026gt; type;\n\tif (type \u003d\u003d \u0027U\u0027) {\n\t\tint pos, x;\n\t\tcin \u0026gt;\u0026gt; pos \u0026gt;\u0026gt; x;\n\t\tpos--;\n\t\tint last \u003d a[pos];\n\n\t\t//del pointer into pos\n\t\tnext[last].erase(pos);\n\t\tauto it \u003d next[last].lower_bound(pos);\n\t\tif (it !\u003d next[last].begin()) {\n\t\t\t--it;\n\t\t\tint posbef \u003d *it;\n\t\t\tint lastel \u003d a[posbef];\n\t\t\tint lastx \u003d nextv[posbef];\n\t\t\tnextv[posbef] \u003d nextv[pos];\n\t\t\tupdate(0, 0, n, posbef, lastx, lastel);\n\t\t}\n\n\t\ta[pos] \u003d x;\n\n\t\t//add pointer to pos\n\t\tit \u003d next[x].lower_bound(pos);\n\t\tif (it !\u003d next[x].begin()) {\n\t\t\tint posbef \u003d *--it;\n\t\t\tint lastel \u003d a[posbef];\n\t\t\tint lastx \u003d nextv[posbef];\n\t\t\tnextv[posbef] \u003d pos;\n\t\t\tupdate(0, 0, n, posbef, lastx, lastel);\n\t\t}\n\n\t\t//add pointer from pos\n\t\tit \u003d next[x].lower_bound(pos);\n\t\tint lastx \u003d nextv[pos];\n\t\tif (it \u003d\u003d next[x].end())\n\t\t\tnextv[pos] \u003d INF;\n\t\telse\n\t\t\tnextv[pos] \u003d *it;\n\t\tupdate(0, 0, n, pos, lastx, last);\n\n\t\tnext[x].insert(pos);\n\t}\n\telse {\n\t\tint l, r;\n\t\tcin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r;\n\t\tl--;\n\t\tcout \u0026lt;\u0026lt; get_sum(0, 0, n, l, r) \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t}\n}\n\nvoid init(map\u0026lt;int, set\u0026lt;int\u0026gt;\u0026gt; \u0026amp;next)\n{\n\tsrand(time(0));\n\tnextv.resize(n);\n\ta.resize(n);\n\tt.resize(4 * n);\n\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\tcin \u0026gt;\u0026gt; a[i];\n\t\tnext[a[i]].insert(i);\n\t}\n\n\tfor (auto x : next) {\n\t\tnextv[*x.second.rbegin()] \u003d INF;\n\t\tint last \u003d *x.second.rbegin();\n\n\t\tfor (auto it \u003d ++x.second.rbegin(); it !\u003d x.second.rend(); it++) {\n\t\t\tnextv[*it] \u003d last;\n\t\t\tlast \u003d *it;\n\t\t}\n\t}\n\n\tbuild(0, 0, n);\n}\n\nsigned main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\n\tmap\u0026lt;int, set\u0026lt;int\u0026gt;\u0026gt; next; //next[v] - vector\u0026lt;posisions of v\u0026gt;\n\tcin \u0026gt;\u0026gt; n;\n\n\tinit(next);\n\tint q;\n\tcin \u0026gt;\u0026gt; q;\n\n\tfor (int i \u003d 0; i \u0026lt; q; i++)\n\t\tquerry(next);\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["структура данных","декартово дерево","дерево отрезков"]}}