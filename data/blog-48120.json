{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1477948353,"rating":0,"authorHandle":"Fcdkbear","modificationTimeSeconds":1477948353,"id":48120,"title":"\u003cp\u003eРазбор VNTU 2016 Beginners Training #3 \u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eЗадача А\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eДавайте рассмотрим все подстроки входной строки длины 7 (для этого используем фуникцю substr). Если хоть одна подстрока равна \u0026quot;1111111\u0026quot; или \u0026quot;0000000\u0026quot; — то ответ YES. Если ни разу такая ситуация не случилась — ответ NO.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача B\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eДля начала, сведем обе строки к нижнему регистру (сделаем все буквы маленькими). Я писал как это сделать в прошлом разборе. После этого сравнивать строки на лексикографичность можна та же, как и сравнивать числа арифметически. Пример кода сравнения:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e if (s1 \u0026lt; s2) {\n        \tcout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl;\n} else if (s1 \u003d\u003d s2) {\n        \tcout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl;\n} else {\n        \tcout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eЗадача C\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eДавайте выпишем все цифры, которые нам дали в начальной строке, в какую-то отдельную строку. Для этого нужно заметить, что все цифры находятся на четных позициях, поэтому нам интересны только четные позиции (в 0-индексации). Отсортируем получившуюся строку из цифр. Дальше выведем все эти цифры в отсортированном порядке, выводя между ними знак +.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача D\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eДавайте посчитаем, сколько людей будет в трамвае на каждой остановке. Найдем среди этих чисел максимум. Понятное дело, что вместимость трамвая должна быть не меньше, чем этот максимум. Но и делать больше ее незачем — иначе наша вместимость будет не минимальна. А значит, это число и есть ответом на задачу.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача E\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eДавайте сначала узнаем, или слово набрано с ошибочно нажатой клавишей Caps Lock. Для этого проверим, или все символы, начиная с 1-го (в 0-индексации) — большие буквы. Если мы узнаем, что это так — поменяем регистр всех букв в этом слове. В конце нашего алгоритма выведем слово на экран\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача F\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВсегда можно оставить на столе как минимум 1 камень. Кроме этого одного камня можно оставить все такие камни, у которых цвет отличается от цвета предыдущего камня. Давайте посчитаем, сколько же камней мы оставим на столе. Тогда ответ на задачу равен n — (количество камней, которые мы оставляем)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача G\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗаметим, что что-то на экран выводят только символы \u0027H\u0027, \u0027Q\u0027, \u00279\u0027. Тогда просто проверим, есть ли в той строке, которую нам дали в качестве входящих данных, один из этих символов. Если да — ответ YES, иначе NO\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача H\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗаметим, что если мы хотим набрать максимальную сумму минимальным количеством монет — выгодно использовать монеты бОльшего номинала. Из этого следует такое решение. Отсортируем монеты по их номиналу. Будем набирать монеты в порядке уменьшения их номиналов. Как только собранная сумма больше суммы оставшихся монет — количество собранных монет и есть ответом на задачу\u003c/p\u003e\u003c/div\u003e","tags":["разбор","никто не читает тэги","все читают разборы"]}}