{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1431031653,"rating":0,"authorHandle":"KrK","modificationTimeSeconds":1493151214,"id":17774,"title":"\u003cp\u003eKTU CodeJam 2015: Sprendimai\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eSveiki,\u003c/p\u003e\u003cp\u003eČia pateiksiu savo rašytus Codejamo sprendimus ir trumpai pakomentuosiu idėjas. Jeigu kils kokių nors klausimų, arba norėsis platesnio paaiškinimo, galima rašyti komentarą apačioje arba kreiptis į mane asmeniškai.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eA. Holes (expected level — medium)\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eKodas\u003c/em\u003e: \u003ca href\u003d\"http://pastebin.com/tGqubG08\"\u003ehttp://pastebin.com/tGqubG08\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eKomentaras\u003c/em\u003e: Šitame uždavinyje reikia išnaudoti grafo struktūrą (kad tik viena grafo viršūnė gali turėti daugiau nei dvi kaimynines viršūnes). Sugrupuojame viršūnes taip: centrinė (išskirtinė viršūnė), tada į ją remiasi atsišakojimai: vienas tipas — lankas, kuris atgal grįžta į centrinę viršūnę, kitas — atkarpa, kuri baigiasi viršūne, turinčia tik vieną kaimyninę viršūnę. Kiekvienam atsišakojimui saugome viršūnių skaičių. Tada užfiksavus trušiams reikiamą laiką pasislėpti, galime patikrinti, ar jis pakankamas, ar ne. Laikas perrenkamas naudojant dvejetainę paiešką.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eB. Chocolate triangles (expected level — impossible)\u003c/strong\u003e \u003c/p\u003e\u003cp\u003e\u003cem\u003eKodas\u003c/em\u003e: \u003ca href\u003d\"http://pastebin.com/DrLAKwru\"\u003ehttp://pastebin.com/DrLAKwru\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eKomentaras\u003c/em\u003e: Mano manymu, tai pats sunkiausias konkurso uždavinys. Galima buvo taikyti dinaminį programavimą su būsena (a, b, nd). a — kiek pradžios viršūnių liko daugiakampyje (t. y. 1, 2, ..., a dar nepašalintos), b — kiek pabaigos viršūnių liko daugiakampyje (t. y. n — b + 1, n — b + 2, ... n dar nepašalintos), nd — kiek trikampių reikia išpjauti. Kai darome naują dešiniausią pjūvį, galime imti vieną a tipo viršūnę ir vieną b tipo, arba 2 b tipo viršūnes. (2 a tipo viršūnių imti negalime, nes jos turėjo būti paimtos anksčiau ir būsena išeitų kitokia). Perrenkant visus pjūvius galima gauti O(n^5) teisingą algoritmą. Jį galima optimizuoti naudojant kaupiamąsias sumas. (Taip pat reikia optimizuoti algoritmo veikimą pagal atmintį).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eC. Electrician (expected level — easy)\u003c/strong\u003e \u003c/p\u003e\u003cp\u003e\u003cem\u003eKodas\u003c/em\u003e: \u003ca href\u003d\"http://pastebin.com/4QgdBSc8\"\u003ehttp://pastebin.com/4QgdBSc8\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eKomentaras\u003c/em\u003e: Šis uždavinys sprendžiamas su minimalaus jungiamojo medžio algoritmu. Kadangi sudega mažesnio patikimumo laidai, pradėkime nuo didžiausio patikimumo laidų ir junkime į medį. Šiuo atveju gausime maksimalų patikimumą. Jei norime jungimo tvarkos — galime jungti nuo mažiausio patikimumo laidų (jie liks arba sudegs).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eD. The Street Escalator (expected level — easy)\u003c/strong\u003e \u003c/p\u003e\u003cp\u003e\u003cem\u003eKodas\u003c/em\u003e: \u003ca href\u003d\"http://pastebin.com/X3GiF7NH\"\u003ehttp://pastebin.com/X3GiF7NH\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eKomentaras\u003c/em\u003e: Šis uždavinys gali būti sprendžiamas su dinaminio programavimo sprendimu. Būsena (i, j). i — mažiausias keleivio indeksas, j — kurioje pusėje stovi kliūtis, reiškmė — kiek vidutiniškai kartų reikės pakeisti pusę. Fiksuojame i ir j, tada i keleviui yra du variantai: atsidurti pusėje j arba 1 — j. Suskaičiuojamos abiejų būdų tikimybės. Žinant kurią pusę pasirinko keleivis, pereinama į dp[i + 1][0] arba dp[i + 1][1].\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eE. Mr. Buridan and coffee shops (expected level — hard)\u003c/strong\u003e \u003c/p\u003e\u003cp\u003e\u003cem\u003eKodas\u003c/em\u003e: \u003ca href\u003d\"http://pastebin.com/0pJKWgFp\"\u003ehttp://pastebin.com/0pJKWgFp\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eKomentaras\u003c/em\u003e: Esminė įžvalga, kad kai kavinių skaičius \u0026gt; 2 * n, galime spausdinti vien \u0027N\u0027. Taip yra dėl to, kad užrašius bet kuriam taškui lentelėje visus galimus atstumus, jų yra mažiau nei 2 * n, tai reiškia, kad bent dvi kavinės turės tą patį atstumą. Kai kavinių skaičius toks mažas, galime pereiti jų poras. Tada yra 8 variantai, kuriais pora gali nustatyti keletą matricos langelių į \u0027N\u0027. Šie plotai yra stačiakampiai, stulpelių, eilučių atkarpos arba įstrižainių intervalai. Naudodami kaupiamąsias sumas galime kiekvieną variantą apdoroti per O(1).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eF. Bring Your Own Bombs (expected level — medium)\u003c/strong\u003e \u003c/p\u003e\u003cp\u003e\u003cem\u003eKodas\u003c/em\u003e: \u003ca href\u003d\"http://pastebin.com/Unq2m3qb\"\u003ehttp://pastebin.com/Unq2m3qb\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eKomentaras\u003c/em\u003e: Visas bombas sudedame į intervalų medžius: vienas skirtas x intervalams, kitas — y intervalams. Medžio viršūnėje saugomas vidutinis sprogusių bombų skaičius tame intervale. Tada pereinam priešų stačiakampius ir pagal intervaluose saugomas matematines viltis suskaičiuojame, kiek vidutiniškai priešų susprogs. Atsakymus sudedame.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eG. A+-B (expected level — trivial)\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eKodas\u003c/em\u003e: \u003ca href\u003d\"http://pastebin.com/SAGfJqui\"\u003ehttp://pastebin.com/SAGfJqui\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eKomentaras\u003c/em\u003e: Lengviausias konkurso uždavinys, skirtas patikrinti, ar žinote, kur daugmaž persipildo long long skaičiai, ir kaip to išvengti.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eH. Born for the Battle (expected level — easy)\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eKodas\u003c/em\u003e: \u003ca href\u003d\"http://pastebin.com/6QM6T0a0\"\u003ehttp://pastebin.com/6QM6T0a0\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eKomentaras\u003c/em\u003e: Paprastas uždavinys pastebėjus dvejetainę paiešką. Užfiksavus x, susidarome grafą su svoriais 1/0 (pagal loginę sąlygą briaunos_svoris \u0026gt; x). Jei pasiekiame savo tikslą su svoriu \u0026lt;\u003d 1, tada x tinka ir galime išmėginti dar mažesnius x.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eI. Genealogy (expected level — easy)\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eKodas\u003c/em\u003e: \u003ca href\u003d\"http://pastebin.com/3xMiuBC8\"\u003ehttp://pastebin.com/3xMiuBC8\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eKomentaras\u003c/em\u003e: Šis uždavinys turi iš pažiūros keistą sąlygą. Tačiau ją supratus, užtenka ieškoti ilgiausio kryptinio kelio grafe, kol tas kelias neatsiremia į jau aplankytą viršūnę. Sprendimą galima realizuoti rekursiškai. Grafe gali būti ciklų, kas padidina klaidos tikimybę. Pateiktas sprendimas naudoja tris DFS spalvas (balta, pilka ir juoda). Taip pat saugomas laikas, kada duota viršūnė aplankyta.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eJ. Dividing an orange (expected level — medium)\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eKodas\u003c/em\u003e: \u003ca href\u003d\"http://pastebin.com/g4qgM6Yv\"\u003ehttp://pastebin.com/g4qgM6Yv\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eKomentaras\u003c/em\u003e: Tai turbūt lengviausias dalyvių visiškai ignoruotas uždavinys. Jis reikalauja tik matematinių atvejų nagrinėjimo. Tai darant nuo paskutinio žmogaus gauname:\u003c/p\u003e\u003cp\u003ex\u003c/p\u003e\u003cp\u003ex 0\u003c/p\u003e\u003cp\u003ex-1 0 1\u003c/p\u003e\u003cp\u003ex-1 0 1 0\u003c/p\u003e\u003cp\u003eir t. t.\u003c/p\u003e\u003cp\u003eIšeina trys atvejai: 1) pirmajam žmogui lieka teigiamas skaičius apelsinų (pagal aprašytą dėsnį); 2) pirmajam žmogui lieka 0 apelsinų (pagal aprašytą dėsnį); 3) pirmasis žmogus arba gauna -1 -1, arba suranda būdą, kaip papirkti už jo esančius -1 -1, kad gautų 0 0. Šiuo atveju dėsningumas susijęs su dvejeto laipsniais.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eK. Atlantis (expected level — hard)\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eKodas\u003c/em\u003e: \u003ca href\u003d\"http://pastebin.com/ze21Z1PZ\"\u003ehttp://pastebin.com/ze21Z1PZ\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eKomentaras\u003c/em\u003e: Uždavinys susideda iš dviejų dalių. 1) Reikia susidaryti cilindrų hierarchiją (kas į ką įeina). 2) Reikia pereiti per gautus medžius ir pridėti vandenį iš kiekvieno cilindro. Pirmoji dalis yra kur kas sudėtingesnė. Ją galima spręsti naudojant pagal x išrikiuotus įvykius. Kiekvienas cilindras turi įvykį (xi — ri), kuriuo jis pridedamas, ir (xi + ri), kuriuo jis išimamas. Cilindrą galima pridėti/išimti išskaidant jį į viršutinį ir apatinį lankus. Tada pridedant mažesnį cilindrą su dvejetaine paieška aibėje galėsime susirasti tėvinį cilindrą. Ir apdorojus visus įvykius bus gauta hierarchinė struktūra.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eL. Equalize (expected level — medium)\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eKodas\u003c/em\u003e: \u003ca href\u003d\"http://pastebin.com/EB5Zrdm8\"\u003ehttp://pastebin.com/EB5Zrdm8\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eKomentaras\u003c/em\u003e: Šis uždavinys remiasi godaus sprendimo idėja. Einame nuo pirmų krūvų ir rastų perteklių perstumiame į po jų esančias krūvas, kuriose jų trūksta (ir atvirkščiai su deficitu). Kadangi krūvų skaičius gali būti itin didelis, naudojame daugybos ir modulio operacijas, aprašytas pateiktame sprendime.\u003c/p\u003e\u003c/div\u003e","tags":["sprendimai"]}}