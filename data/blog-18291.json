{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1433286983,"rating":79,"authorHandle":"MikeMirzayanov","modificationTimeSeconds":1433894888,"id":18291,"title":"\u003cp\u003eГенераторы на testlib.h\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eГенераторы — это такие вспомогательные программы в задаче по программированию, которые выводят тесты. Далеко не всегда ручные тесты в задаче достаточно маленькие, чтобы обойтись только ими. В этом случае на помощь и приходят генераторы. Если вы пишете генератор на С++, то использование \u003ca href\u003d\"https://github.com/MikeMirzayanov/testlib\"\u003etestlib.h\u003c/a\u003e — хороший выбор.\u003c/p\u003e\u003ch3\u003eВиды генераторов\u003c/h3\u003e\u003cp\u003eЕсть два вида генераторов: обычные и мультигенераторы.\u003c/p\u003e \u003col\u003e   \u003cli\u003eПервые за один свой запуск выводят ровно один тест. Обычно, чтобы сгенерировать несколько тестов, такой генератор надо запустить несколько раз с разными параметрами командной строки. Такие генераторы выводят тест в стандартный поток вывода (на экран).\u003c/li\u003e   \u003cli\u003eМультигенераторы за один запуск выводят сразу много тестов. Такие генераторы выводят тесты в файлы (один файл — один тест).\u003c/li\u003e \u003c/ol\u003e\u003ch3\u003eПример простого обычного генератора на testlib.h\u003c/h3\u003e\u003cp\u003eВыводит пару чисел от 1 до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e — переданный параметр запуска генератора.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026quot;testlib.h\u0026quot;\n#include \u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    int n \u003d atoi(argv[1]);\n    cout \u0026lt;\u0026lt; rnd.next(1, n) \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n    cout \u0026lt;\u0026lt; rnd.next(1, n) \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eЗачем testlib.h?\u003c/h3\u003e\u003cp\u003eПри невнимательном взгляде кажется, что testlib.h почти не нужен для написания генератора. На самом деле это неправда. Почти в каждом генераторе нужна возможность получать случайные значения, и есть большое искушение использовать \u003ccode\u003erand()\u003c/code\u003e. Не делайте этого. Основной принцип написания генератора: \u003cem\u003eгенератор должен выводить один и тот же тест при компиляции любым компилятором на любой платформе, если он запущен одинаковым способом\u003c/em\u003e. При использовании \u003ccode\u003erand()\u003c/code\u003e или классов C++11 вроде \u003ccode\u003emt19937/uniform_int_distribution\u003c/code\u003e ваша программа будет выводить разные тесты после компиляции разными компиляторами.\u003c/p\u003e\u003cp\u003eГенератор случайных значений в testlib.h гарантирует, что будет сгенерировано одно и то же, независимо от генератора и платформы. Кроме того, в testlib.h есть разные удобности для генерации тестов, например, \u003ccode\u003ernd.next(\u0026quot;[a-z]{1,10}\u0026quot;)\u003c/code\u003e вернет случайное слово длины от 1 до 10 из букв от \u003ccode\u003ea\u003c/code\u003e до \u003ccode\u003ez\u003c/code\u003e.\u003c/p\u003e\u003ch3\u003eЧто есть у testlib.h?\u003c/h3\u003e\u003cp\u003eЧтобы инициализировать testlib-генератор, первая строка вашего генератора должна иметь вид \u003ccode\u003eregisterGen(argc, argv, 1);\u003c/code\u003e (где 1 — это версия используемого генератора случайных чисел). После этого можно будет пользоваться объектом \u003ccode\u003ernd\u003c/code\u003e, который будет проинициализирован хешем от всех аргументов командной строки. Таким образом, результат вывода \u003ccode\u003eg 100\u003c/code\u003e и \u003ccode\u003eg.exe   \u0026quot;100\u0026quot;\u003c/code\u003e будет одинаков, а у \u003ccode\u003eg 100 0\u003c/code\u003e будет отличаться.\u003c/p\u003e\u003cp\u003eОбъект \u003ccode\u003ernd\u003c/code\u003e имеет тип \u003ccode\u003erandom_t\u003c/code\u003e, то есть вы можете создать и свой генератор, но обычно это не нужно.\u003c/p\u003e\u003cp\u003eУ объекта \u003ccode\u003ernd\u003c/code\u003e есть много полезных членов-функций. Вот примеры:\u003c/p\u003e \u003ctable\u003e   \u003cthead\u003e     \u003ctr\u003e       \u003cth\u003eВызов\u003c/th\u003e       \u003cth\u003eЧто делает\u003c/th\u003e     \u003c/tr\u003e   \u003c/thead\u003e   \u003ctbody\u003e     \u003ctr\u003e       \u003ctd\u003ernd.next(4)\u003c/td\u003e       \u003ctd\u003eравновероятное целое случайное число от 0 до 3 включительно\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003ernd.next(4, 100)\u003c/td\u003e       \u003ctd\u003eравновероятное целое случайное число от 4 до 100 включительно\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003ernd.next(10.0)\u003c/td\u003e       \u003ctd\u003eравновероятное вещественное случайное число в полуинтервале [0,10)\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003ernd.next(\u0026quot;one|two|three\u0026quot;)\u003c/td\u003e       \u003ctd\u003eравновероятное случайное одно слово из трех one, two и three\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003ernd.next(\u0026quot;[1-9][0-9]{99}\u0026quot;)\u003c/td\u003e       \u003ctd\u003eравновероятное случайное 100-значное число в виде строки \u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003ernd.wnext(4,t)\u003c/td\u003e       \u003ctd\u003ewnext — это способ получения неравновероятного распределения (со смещенным матожиданием), параметр \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e обозначает количество вызовов операции \u0026quot;максимум\u0026quot; для аналогичных вызовов next, например rnd.wnext(3, 1) эквивалентен max(rnd.next(3), rnd.next(3)), а rnd.wnext(4, 2) эквивалентен max(rnd.next(4), max(rnd.next(4), rnd.next(4))). Если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e \u0026lt; 0\u003c/span\u003e, то \u003cspan class\u003d\"tex-span\"\u003e - \u003ci\u003et\u003c/i\u003e\u003c/span\u003e будет найден минимум. Если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e \u003d 0\u003c/span\u003e, то wnext эквивалентен next.\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003ernd.any(container)\u003c/td\u003e       \u003ctd\u003eвернет случайный элемент контейнера container (с произвольным доступом по итератору), например, работает для std::vector и std::string\u003c/td\u003e     \u003c/tr\u003e   \u003c/tbody\u003e \u003c/table\u003e\u003cp\u003eКроме того, не надо использовать \u003ccode\u003estd::random_shuffle\u003c/code\u003e, используйте \u003ccode\u003eshuffle\u003c/code\u003e из testlib. Он так же принимает два итератора, но работает, используя \u003ccode\u003ernd\u003c/code\u003e.\u003c/p\u003e\u003ch4\u003eПример: генерация неориентированного дерева\u003c/h4\u003e\u003cp\u003eНиже основной код генератора неориентированного дерева, который принимает два параметра — количество вершин и степень его \u003cem\u003eвытянутости\u003c/em\u003e. Например, при \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 10, \u003ci\u003et\u003c/i\u003e \u003d 1000\u003c/span\u003e наверняка будет сгенерирована цепь, а при \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 10, \u003ci\u003et\u003c/i\u003e \u003d  - 1000\u003c/span\u003e наверняка будет сгенерирована ромашка (звездочка).\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eregisterGen(argc, argv, 1);\n\nint n \u003d atoi(argv[1]);\nint t \u003d atoi(argv[2]);\n\nvector\u0026lt;int\u0026gt; p(n);\n\n/* setup parents for vertices 1..n-1 */\nforn(i, n)\n    if (i \u0026gt; 0)\n        p[i] \u003d rnd.wnext(i, t);\n\nprintf(\u0026quot;%d\\n\u0026quot;, n);\n\n/* shuffle vertices 1..n-1 */\nvector\u0026lt;int\u0026gt; perm(n);\nforn(i, n)\n    perm[i] \u003d i;\nshuffle(perm.begin() + 1, perm.end());\n\n/* put edges considering shuffled vertices */\nvector\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt; edges;\nfor (int i \u003d 1; i \u0026lt; n; i++)\n    if (rnd.next(2))\n        edges.push_back(make_pair(perm[i], perm[p[i]]));\n    else\n        edges.push_back(make_pair(perm[p[i]], perm[i]));\n\n/* shuffle edges */\nshuffle(edges.begin(), edges.end());\n\nfor (int i \u003d 0; i + 1 \u0026lt; n; i++)\n    printf(\u0026quot;%d %d\\n\u0026quot;, edges[i].first + 1, edges[i].second + 1);\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003eКак написать мультигенератор?\u003c/h4\u003e\u003cp\u003eМультигенератор за одно исполнение может вывести более одного теста. Тесты таким генератором выводятся в файлы. В генераторе на testlib.h достаточно перед выводом теста написать \u003ccode\u003estartTest(test_index)\u003c/code\u003e. Это приведет к переоткрытию (freopen) потока стандартного вывода на файл с именем \u003ccode\u003etest_index\u003c/code\u003e. Обратите внимание, что в системе Polygon в таком случае в скрипте надо писать что-то вроде \u003ccode\u003emultigen a b c \u0026gt; {4-10}\u003c/code\u003e (если предполагается, что запуск мультигенератора вернет тесты 4, 5, 6, 7, 8, 9 и 10).\u003c/p\u003e\u003ch4\u003eНа что еще обратить внимание?\u003c/h4\u003e \u003cul\u003e   \u003cli\u003eСтрого следуйте формату теста — пробелы, переводы строк должны быть идеально соблюдены. Тест должен заканчиваться переводом строки. Например, если в тест состоит из единственного числа, то выводите его как \u003ccode\u003ecout \u0026lt;\u0026lt; rnd.next(1, n) \u0026lt;\u0026lt; endl;\u003c/code\u003e — с переводом строки в конце.\u003c/li\u003e   \u003cli\u003eЕсли выводимый тест может быть довольно большим, то предпочитайте \u003ccode\u003eprintf\u003c/code\u003e (а не \u003ccode\u003ecout\u003c/code\u003e) — это улучшит производительность.\u003c/li\u003e   \u003cli\u003eЛучше выводите \u003ccode\u003elong long\u003c/code\u003e через \u003ccode\u003ecout\u003c/code\u003e, но если хотите \u003ccode\u003eprintf\u003c/code\u003e, то используйте константу I64 (например, \u003ccode\u003eprintf(I64, x);\u003c/code\u003e).\u003c/li\u003e   \u003cli\u003eНеобходимо не забывать о различных случаях неопределенного поведения языка C++. Например, в приведенном выше примере генератора нельзя объединять две команды \u003ccode\u003ecout\u003c/code\u003e в одну, т.к. тогда порядок вызовов функций \u003ccode\u003ernd.next\u003c/code\u003e не определен.\u003c/li\u003e \u003c/ul\u003e\u003ch4\u003eЕще примеры\u003c/h4\u003e\u003cp\u003eПримеры генераторов можно найти в \u003ca href\u003d\"https://github.com/MikeMirzayanov/testlib/releases\"\u003eдистрибутиве\u003c/a\u003e или непосредственно в \u003ca href\u003d\"https://github.com/MikeMirzayanov/testlib/tree/master/generators\"\u003eрепозитории\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e","tags":["testlib","polygon","generator","generators"]}}