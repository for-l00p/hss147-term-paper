{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1433626401,"rating":97,"authorHandle":"ifsmirnov","modificationTimeSeconds":1433632330,"id":18369,"title":"\u003cp\u003eOn Euler tour trees\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eTL;DR\u003c/strong\u003e: is it possible to construct an Euler tour tree which supports LCA, subtree sum and rerooting?\u003c/p\u003e\u003cp\u003eEuler tour tree (ETT) is a method for representing a rooted undirected tree as a number sequence. There are several common ways to build this representation. Usually only the first is called the Euler tour; however, I don\u0027t know any specific names for others and will call them Euler tours too. All of them have some pros and cons. I want to discuss if we can build an algorithm which contains benefits from each one. Maybe this post also could be a tutorial for beginners. The first way is to write down all edges of the tree, directed, in order of DFS. This is how ETT is defined on, for example, \u003ca href\u003d\"http://en.wikipedia.org/wiki/Euler_tour_technique\"\u003eWikipedia\u003c/a\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e     1\n    / \\\n   2   5\n  / \\\n 3   4\n\n[1-2] [2-3] [3-2] [2-4] [4-2] [2-1] [1-5] [5-1]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe second way is to store vertices. Each vertex is added to the array twice: when we descend into it and when we leave it. Each leaf (except maybe root) has two consecutive entries.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e     1\n    / \\\n   2   5\n  / \\\n 3   4\n\n1 2 3 3 4 4 2 5 5 1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe third way implies storing vertices too, but now each vertex is added every time when we visit it (when descending from parent and when returning from child).\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e     1\n    / \\\n   2   5\n  / \\\n 3   4\n\n1 2 3 2 4 2 1 5 1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFurther all ETT\u0027s are stored in a Cartesian tree (treap) unless other explicitly stated. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efirst\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elast\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e are positions of first and last occurrence of vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in the array (in 2nd and 3rd cases).\u003c/p\u003e\u003cp\u003eSo, how these representation can be used?\u003c/p\u003e\u003cp\u003eFirst, you should notice that a subtree is always mapped to a segment. Thus you can solve subtree queries via segment queries. E.g. if you want to add values to nodes and find subtree sum, you just make a BIT on a 2nd type tour. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eadd\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e becomes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eadd\u003c/i\u003e(\u003ci\u003efirst\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e), \u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e in BIT, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eget\u003c/i\u003e_\u003ci\u003esum\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e becomes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eget\u003c/i\u003e_\u003ci\u003esum\u003c/i\u003e(\u003ci\u003efirst\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e), \u003ci\u003elast\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e))\u003c/span\u003e in BIT. There is also a trick to compute sum on path: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eadd\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e becomes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eadd\u003c/i\u003e(\u003ci\u003efirst\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e), \u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eadd\u003c/i\u003e(\u003ci\u003elast\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e),  - \u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e in BIT, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eget\u003c/i\u003e_\u003ci\u003esum\u003c/i\u003e_\u003ci\u003eon\u003c/i\u003e_\u003ci\u003epath\u003c/i\u003e_\u003ci\u003efrom\u003c/i\u003e_\u003ci\u003eroot\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eget\u003c/i\u003e_\u003ci\u003esum\u003c/i\u003e(0, \u003ci\u003efirst\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e))\u003c/span\u003e (you can check that it works using pencil and paper).\u003c/p\u003e\u003cp\u003eYou can also use ETT for finding LCA. Use the 3rd type. Make an additional array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d \u003ci\u003eheight\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e])\u003c/span\u003e. Then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elca\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e \u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e[\u003ci\u003eargmin\u003c/i\u003e(\u003ci\u003efirst\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e), \u003ci\u003efirst\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e)) \u003ci\u003ein\u003c/i\u003e \u003ci\u003eh\u003c/i\u003e]\u003c/span\u003e. Why? Because \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLCA\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e is a highest vertex which is between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in DFS traverse order. Sometimes I prefer this method to binary accent (not sure if translated correctly) because it proved to be faster and consumes linear memory.\u003c/p\u003e\u003cp\u003eThe fact that a subtree is maps to a segment gives us some more benefits. With the first and third approach you can reroot the tree simply rotating the array. You may avoid some pain in the neck with the third approach if you do not store last number for the root (thus vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e will have exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edeg\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e occurrences). You also can perform link-cut operations simply cutting the segment from the array. It is done quite straightforward when you store edges, and with vertices you should carefully deal with duplicating of the subtree\u0027s former ancestor.\u003c/p\u003e\u003cp\u003eHowever, although these simple structures proved to be powerful enough, I have some open questions. Can you simultaneously reroot a tree and query LCA? Can you query both LCA and subtree sum? and so on. Of course, I don\u0027t want to lose the possibility to make link-cut operations (maybe without rerooting).\u003c/p\u003e\u003cp\u003eSumming up, I made a table with pros and cons of every approach. \u003c/p\u003e \u003ctable\u003e   \u003cthead\u003e     \u003ctr\u003e       \u003cth\u003e \u003c/th\u003e       \u003cth\u003eStores \u003c/th\u003e       \u003cth align\u003d\"center\"\u003eLCA \u003c/th\u003e       \u003cth align\u003d\"center\"\u003eSubtree sum \u003c/th\u003e       \u003cth align\u003d\"center\"\u003ePath sum\u003c/th\u003e       \u003cth align\u003d\"center\"\u003eRerooting \u003c/th\u003e     \u003c/tr\u003e   \u003c/thead\u003e   \u003ctbody\u003e     \u003ctr\u003e       \u003ctd\u003e1\u003c/td\u003e       \u003ctd\u003eedges \u003c/td\u003e       \u003ctd align\u003d\"center\"\u003e— \u003c/td\u003e       \u003ctd align\u003d\"center\"\u003e+ (values on edges) \u003c/td\u003e       \u003ctd align\u003d\"center\"\u003e+ \u003c/td\u003e       \u003ctd align\u003d\"center\"\u003e+ (not sure if works with sum)\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003e2\u003c/td\u003e       \u003ctd\u003evertices\u003c/td\u003e       \u003ctd align\u003d\"center\"\u003e— \u003c/td\u003e       \u003ctd align\u003d\"center\"\u003e+ (values on vertices)\u003c/td\u003e       \u003ctd align\u003d\"center\"\u003e+ \u003c/td\u003e       \u003ctd align\u003d\"center\"\u003e— \u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003e3\u003c/td\u003e       \u003ctd\u003evertices\u003c/td\u003e       \u003ctd align\u003d\"center\"\u003e+ (no rerooting)\u003c/td\u003e       \u003ctd align\u003d\"center\"\u003e— \u003c/td\u003e       \u003ctd align\u003d\"center\"\u003e— \u003c/td\u003e       \u003ctd align\u003d\"center\"\u003e+ (no LCA)\u003c/td\u003e     \u003c/tr\u003e   \u003c/tbody\u003e \u003c/table\u003e\u003cp\u003eSo, the final question (and the main purpose of this post) is: \u003cstrong\u003ecan you add some \u003cspan class\u003d\"tex-span\"\u003e + \u003c/span\u003e\u0027s to this table and/or tell about some other related methods?\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eP.S. This topic is by no means related to heavy-light decomposition and link-cut trees. I know that they may solve some proposed problems, but the idea is to squeeze as much as possible from Euler tours.\u003c/p\u003e\u003c/div\u003e","tags":[]}}