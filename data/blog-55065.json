{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1507465790,"rating":0,"authorHandle":"Slamur","modificationTimeSeconds":1507465790,"id":55065,"title":"\u003cp\u003eБазовые структуры данных. Java. Generic-классы\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eВсе базовые структуры данных в Java, кроме массивов, являются параметризованными [generic] классами. \u003c/p\u003e\u003cp\u003eПоэтому перед обзором структур я опишу основы использования Generic-классов и их взаимодействия с примитивными типами данных. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eВ типизированных языках часто может возникнуть проблема одинакового кода по списку действий, но отличающегося только \u0026quot;целевым\u0026quot; типом данных. К примеру, алгоритм поиска элемента в сортированном массиве не зависит от того, какой тип данных хранит массив — главное, чтобы мы могли сравнвать элементы массива между собой.\u003c/p\u003e\u003cp\u003eДля того, чтобы в таких ситуациях не приходилось много раз писать практически одинаковый код, применяется типизация классов и отдельных методов.\u003c/p\u003e\u003cp\u003eНапример, вот так \u003cstrong\u003eмогут выглядеть\u003c/strong\u003e общие описания функций класса [interface], реализующего список или словарь в Java:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\t// T - это псевдоним типа хранимых элементов\n\tinterface List\u0026lt;T\u0026gt; {\n\t\n\t\tvoid set(int index, T value); // установить значение по индексу\n\t\tT get(int index); // выдать значение по индексу\n\t\t\n\t\tvoid add(T value); \n\t\tvoid remove(T value); // удалить по значению\n\t}\n\t\n\t/*\n\t\tТут целых два типа-параметра\n\t\tK - тип ключа\n\t\tV - тип значения\n\t*/\n\tinterface Map\u0026lt;K, V\u0026gt; {\n\t\n\t\tvoid put(K key, V value); // положить значение по ключу\n\t\tV get(K key); // выдать значение по ключу\n\t}\n\t\n\t// Заметим, что надо указывать тип параметров как в объявлении типа переменной, так и в описании типа при создании объекта.\n\tList\u0026lt;Integer\u0026gt; list; // список, хранящий int/Integer\n\tlist \u003d new ArrayList\u0026lt;Integer\u0026gt;(); \n\t\n\t// Можно сразу писать объявление и создание\n\tMap\u0026lt;String, Long\u0026gt; map \u003d new HashMap\u0026lt;String, Long\u0026gt;(); // словарь, хранящий для строки-ключа значение типа long/Long.\n\t\n\t// С созданием массива Generic-типа возникнут некоторые сложности\n\t// List\u0026lt;Integer\u0026gt;[] lists \u003d new ArrayList\u0026lt;Integer\u0026gt;[5]; // ошибка компиляции\n\t\n\t// Необходимо писать так\n\tList\u0026lt;Integer\u0026gt;[] lists \u003d new List[5]; // вы объявили массив ссылок на объекты Generic-типов\n\tfor (int i \u003d 0; i \u0026lt; lists.length; ++i) {\n\t\tlists[i] \u003d new ArrayList\u0026lt;Integer\u0026gt;(); // вы инициализировали каждую ссылку\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ примере выше вы могли заметить, что вместо типа int я указал тип Integer как тип хранимых данных в списке. Это важный момент, связанный с тем, что в Java все типы-параметры должны быть объектными типами, а примитивные типы данных ими не являются. Для этого в Java были введены типы-обертки для каждого примитивного языка — они являются объектами, но внутри себя хранят только значение соответствующего типа:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\t// типы-обертки свободно конвертируются из примитивного и в примитивный\n\tint a \u003d 5;\n\tInteger b \u003d 6;\n\t\n\tb \u003d a;\n\ta \u003d b;\n\t\n\t// а вот массив оберток не является массивом примитивов\n\tint[] c \u003d new int[5];\n\tInteger[] d \u003d new Integer[6];\n\t\n\t// Некорректные присваивания (различные типы)\n\t// c \u003d d\n\t// d \u003d c \n\t\n\t// Важно! Так как типы-обертки - ссылочные типы, то на \u003d\u003d / !\u003d их сравнивать некорректно.\n\t// Используйте метод equals\n\tInteger p \u003d 100500;\n\tInteger q \u003d 100500;\n\t\n\tboolean x \u003d (p \u003d\u003d q); // x \u003d false\n\tboolean y \u003d (p.equals(q)); // y \u003d true\n\t\n\t// Вы можете заметить, что обычно достаточно привести Integer -\u0026gt; int и спокойно выполнять такие проверки\n\t// Но не всегда можно заметить, что у вас выполняется такая проверка именно с Integer:\n\t\n\tList\u0026lt;Integer\u0026gt; list \u003d new ArrayList\u0026lt;Integer\u0026gt;();\n\t\n\tint z \u003d 100500;\n\tlist.add(z);\n\tlist.add(z);\n\t\n\tx \u003d (list.get(0) \u003d\u003d z); // true\n\tx \u003d (list.get(1) \u003d\u003d z); // true\n\tx \u003d (list.get(0) \u003d\u003d list.get(1)); // false\n\t\n\t// Также типы-обертки могут принимать значение null (они же ссылочные)\n\tInteger f \u003d null;\n\t\n\t// Примитиные типы так не могут\n\t// Следующая строка упадет с NullPointerException - null не приводится к 0!\n\t// int h \u003d f;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПолный список типов-оберток:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eboolean — Boolean\u003c/li\u003e   \u003cli\u003ebyte — Byte\u003c/li\u003e   \u003cli\u003echar — Character\u003c/li\u003e   \u003cli\u003eshort — Short\u003c/li\u003e   \u003cli\u003eint — Integer\u003c/li\u003e   \u003cli\u003elong — Long\u003c/li\u003e \u003c/ul\u003e\u003c/div\u003e","tags":["самара","generic","java"]}}