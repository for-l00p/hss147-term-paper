{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1498180373,"rating":0,"authorHandle":"SAeed","modificationTimeSeconds":1498180373,"id":52837,"title":"\u003cp\u003eSPU Contest #13\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e \u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214260/problem/Blue\"\u003eBlue — Domino piling\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAdHoc\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eOur board has exactly \u003ccode\u003en x m\u003c/code\u003e cells. With a little observation we can see that at most one cell will remain empty, so the answer is just: \u003ccode\u003e(n x m) / 2\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(1)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\t\n\tint n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tcout \u0026lt;\u0026lt; n * m / 2 \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214260/problem/Green\"\u003eGreen — Mysterious Present\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eDP\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s sort the envelopes since only envelopes can get larger.\u003c/p\u003e\u003cp\u003eNow, bviously this problem can be solved with 2D array like LIS. However, this solution appears to be giving MLE, so we will try coding it with a bottom up approach, where or DP becomes only with 1D representing:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eDP[i] \u003d The longest chain ending with the ith envelope.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eFor each envelope try placing it after each one of the previous envelopes (don\u0027t forget to store the envelope that you used to create the current chain, to print to envelopes later).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n^2)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint dp[5010];\nint from[5010];\npair\u0026lt;int, pair\u0026lt;int, int\u0026gt; \u0026gt; a[5010];\nvector\u0026lt;int\u0026gt; best;\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\t\n\tint n, w, h; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; w \u0026gt;\u0026gt; h;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i].first \u0026gt;\u0026gt; a[i].second.first, a[i].second.second \u003d i + 1;\n\tsort(a, a + n);\n\tint ans \u003d 0, who \u003d -1;\n\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\tint maxi \u003d 0, fromWho \u003d -1;\n\t\tfor (int j \u003d 0; j \u0026lt; i; j++){\n\t\t\tif (a[j].first \u0026gt;\u003d a[i].first || a[j].second.first \u0026gt;\u003d a[i].second.first) continue;\n\t\t\tif (dp[j] \u0026gt; maxi) maxi \u003d dp[j], fromWho \u003d j;\n\t\t}\n\t\tif (maxi \u003d\u003d 0 \u0026amp;\u0026amp; (a[i].first \u0026lt;\u003d w || a[i].second.first \u0026lt;\u003d h)) continue;\n\t\tdp[i] \u003d maxi + 1, from[i] \u003d fromWho;\n\t\tif (dp[i] \u0026gt; ans) ans \u003d dp[i], who \u003d i;\n\t}\n\twhile (who !\u003d -1){\n\t\tbest.push_back(a[who].second.second);\n\t\twho \u003d from[who];\n\t}\n\treverse(best.begin(), best.end());\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\tfor (int i \u003d 0; i \u0026lt; ans; i++) cout \u0026lt;\u0026lt; best[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n\tcout \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214260/problem/Purple\"\u003ePurple — Translation\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eImplementation\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eReverse the second string and check.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\t\n\tstring s, t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t;\n\treverse(s.begin(), s.end());\n\tif (s \u003d\u003d t) cout \u0026lt;\u0026lt; \u0026quot;YES\u0026quot; \u0026lt;\u0026lt; endl;\n\telse cout \u0026lt;\u0026lt; \u0026quot;NO\u0026quot; \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214260/problem/Red\"\u003eRed — Compote\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAdHoc\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe amount of compotes we can make is the minimum between: \u003ccode\u003ea, b / 2, c / 4\u003c/code\u003e, and each compote uses 7 fruits.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(1)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\t\n\tint a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c;\n\tcout \u0026lt;\u0026lt; min(a, min(b / 2, c / 4)) * 7 \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214260/problem/Yellow\"\u003eYellow — Two Paths\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eDFS\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eWe can use a brute force to choose the first two nodes which form the first path (two for loops). How can we mark the path from the first node to the second as visited so we won\u0027t pass through it while finding the second path?\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eFirst, calculate the depth and parent for each node, using a single DFS.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eChoose the node with the biggest depth and keep moving to it\u0027s parents till you reach the same level as the second node.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eKeep moving both nodes up through parent till you reach the same common parent.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eMark all the nodes you passed through as visited.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eHow about the second path? We can see that since we will multiply the length of the first path with the second path, we need the second path to be as long as possible. How can we find the longest path in a tree?\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eFor each node store two things: the length of the longest path among its children, and the length of the second longest path among it\u0027s children.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eDiffidently, the path will have a node which he uses two of its children. keep maximizing the length while you are passing through the tree with a DFS. each node\u0027s longest path is the length of the longest path among its children + 1.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nvector\u0026lt;int\u0026gt; G[222];\nint vis[222];\nint parent[222];\nint depth[222];\nint maxHeight[222];\nint secondPath;\n\nvoid dfsParent(int node, int par, int dep){\n\tparent[node] \u003d par;\n\tdepth[node] \u003d dep;\n\tfor (int i \u003d 0; i \u0026lt; G[node].size(); i++){\n\t\tint nxt \u003d G[node][i];\n\t\tif (nxt \u003d\u003d par) continue;\n\t\tdfsParent(nxt, node, dep + 1);\n\t}\n}\n\nint markPathVisited(int from, int to){\n\tint ret \u003d 0;\n\tif (depth[from] \u0026lt; depth[to]) swap(from, to); // now from has more depth\n\twhile (depth[from] \u0026gt; depth[to]) vis[from] \u003d 1, from \u003d parent[from], ret++;\n\twhile (from !\u003d to){\n\t\tvis[from] \u003d vis[to] \u003d 1;\n\t\tfrom \u003d parent[from], to \u003d parent[to];\n\t\tret +\u003d 2;\n\t}\n\tvis[from] \u003d 1;\n\tret++;\n\treturn ret;\n}\n\nvoid dfs(int node){\n\tvis[node] \u003d 1;\n\tint mx \u003d 0, secondMx \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; G[node].size(); i++){\n\t\tint nxt \u003d G[node][i];\n\t\tif (vis[nxt]) continue;\n\t\tdfs(nxt);\n\t\tif (maxHeight[nxt] \u0026gt; mx) secondMx \u003d mx, mx \u003d maxHeight[nxt];\n\t\telse if (maxHeight[nxt] \u0026gt; secondMx) secondMx \u003d maxHeight[nxt];\n\t}\n\tsecondPath \u003d max(secondPath, mx + secondMx + 1);\n\tmaxHeight[node] \u003d mx + 1;\n}\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\t\n\tint n; cin \u0026gt;\u0026gt; n;\n\tfor (int i \u003d 0; i \u0026lt; n - 1; i++){\n\t\tint a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tint ans \u003d 0;\n\tdfsParent(1, -1, 1);\n\tfor (int from \u003d 1; from \u0026lt;\u003d n; from++){\n\t\tfor (int to \u003d from + 1; to \u0026lt;\u003d n; to++){\n\t\t\tmemset(vis, 0, sizeof vis);\n\t\t\tint firstPath \u003d markPathVisited(from, to);\n\t\t\tsecondPath \u003d 0;\n\t\t\tfor (int i \u003d 1; i \u0026lt;\u003d n; i++){\n\t\t\t\tif (vis[i]) continue;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t\tans \u003d max(ans, (firstPath - 1) * (secondPath - 1));\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}