{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1497742981,"rating":0,"authorHandle":"SAeed","modificationTimeSeconds":1497742981,"id":52705,"title":"\u003cp\u003eSPU Contest #9\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e \u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214145/problem/Blue\"\u003eBlue — Playing with Dice\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eBrute Force\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eA dice can have any number between 1 and 6. Since there is only 6 number, we can check each of them to see which player is going to win if this number appear, or indicate that it would cause a draw.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(6)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tint a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\tint fir \u003d 0, draw \u003d 0, sec \u003d 0;\n\tfor (int i \u003d 1; i \u0026lt;\u003d 6; i++){\n\t\tif (abs(i - a) \u0026lt; abs(i - b)) fir++;\n\t\telse if (abs(i - b) \u0026lt; abs(i - a)) sec++;\n\t\telse draw++;\n\t}\n\tcout \u0026lt;\u0026lt; fir \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; draw \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; sec \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214145/problem/Green\"\u003eGreen — Flowers\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eDP\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s first think about the simple solution. Obviously our DP array will have only one dimension which represents the number of the flower we are going to add now. After that for each test case we will have to iterate through all the numbers from \u003ccode\u003ea\u003c/code\u003e to \u003ccode\u003eb\u003c/code\u003e and calculate the answer. The complexity so far is \u003ccode\u003en^2 x t\u003c/code\u003e which is simply too much. How can we speed up this solution?\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eIf we manipulated our DP state a little, so instead of it representing the number of the flower we are going to add (and we keep increasing this number), we can make it to represent the number of flowers we have left to add (and we keep decreasing this number). What would that do? in this case we won\u0027t need to \u003ccode\u003ememset(memo, -1, sizeof memo)\u003c/code\u003e our array for each dp call. Instead we can just clear our memo array once at the start of our code, and then call our dp function as many times as we want without adding any additional complexity.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eSo far we made our complexity \u003ccode\u003en x t\u003c/code\u003e. Obviously we can\u0027t make our dp function any faster (it already has only one dimension), so let\u0027s think about making our calculation for each test case faster. Each test case asks us about the answer of a range \u003ccode\u003e[a, b]\u003c/code\u003e. What is the best way to answer range questions efficiently? Yes it\u0027s \u003cstrong\u003eAccumulative Sum\u003c/strong\u003e. create an array which has the answer for each number alone. Now create another array which represents the accumulative sum for the previous array. Vuala now you can answer each query with a complexity of O(1).\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n + t)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint n, k;\nll MOD \u003d 1e9 + 7;\nll memo[100100];\nll acc[100100];\nll dp(int c){\n\tif (c \u003d\u003d 0) return 1;\n\n\tll \u0026amp;ret \u003d memo[c];\n\tif (ret !\u003d -1) return ret;\n\n\tret \u003d dp(c - 1);\n\tif (c \u0026gt;\u003d k) ret +\u003d dp(c - k);\n\treturn ret %\u003d MOD;\n}\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tint t; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; k;\n\tmemset(memo, -1, sizeof memo);\n\tacc[0] \u003d 0;\n\tfor (int i \u003d 1; i \u0026lt; 100100; i++) acc[i] \u003d (acc[i - 1] + dp(i)) % MOD;\n\t\n\twhile (t--){\n\t\tint a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\t\tll ans \u003d acc[b] - acc[a] + dp(a);\n\t\tans \u003d ((ans % MOD) + MOD) % MOD;\n\t\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\t}\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214145/problem/Purple\"\u003ePurple — Ebony and Ivory\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eMath\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eIf we have an answer, what is the equation representing it?\u003c/p\u003e\u003cp\u003e\u003ccode\u003ea.x + b.y \u003d c\u003c/code\u003e where \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e are some \u003cstrong\u003eintegers\u003c/strong\u003e which are greater than or equal to zero.\u003c/p\u003e\u003cp\u003eFrom the above equation we can calculate \u003ccode\u003ey \u003d (c - a.x) / b\u003c/code\u003e. Remember we agreed that \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e must be integers? well, that means that for \u003ccode\u003ey\u003c/code\u003e to be an integer, \u003ccode\u003ec - a.x\u003c/code\u003e must be divisible by \u003ccode\u003eb\u003c/code\u003e. In other words \u003ccode\u003e(c - a.x) % b \u003d\u003d 0\u003c/code\u003e. Also we said that both \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e must be \u0026gt;\u003d 0. In order for \u003ccode\u003ey\u003c/code\u003e to be \u0026gt;\u003d 0 the following condition must hold \u003ccode\u003ec \u0026gt;\u003d a.x\u003c/code\u003e. Now how can we calculate the answer? we can notice that if you had \u003ccode\u003ex\u003c/code\u003e, we could calculate \u003ccode\u003ey\u003c/code\u003e from the above equation, but \u003ccode\u003ex\u003c/code\u003e\u0027s range is only 10000. So, brute force through every possible value for \u003ccode\u003ex\u003c/code\u003e and calculate the corresponding \u003ccode\u003ey\u003c/code\u003e, if this is possible then the answer is YES, otherwise it\u0027s NO.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(a)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tll a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c;\n\tfor (int x \u003d 0; x \u0026lt; 10001; x++){\n\t\tif (c \u0026gt;\u003d a * x \u0026amp;\u0026amp; (c - a * x) % b \u003d\u003d 0){\n\t\t\tcout \u0026lt;\u0026lt; \u0026quot;YES\u0026quot; \u0026lt;\u0026lt; endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; \u0026quot;NO\u0026quot; \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214145/problem/Red\"\u003eRed — System of Equations\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eBrute Force\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThis problem is really easy, since \u003ccode\u003en\u003c/code\u003e and \u003ccode\u003em\u003c/code\u003e are at most 1000, this means that \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e are also at most 1000. What else do you need? just iterate over all the possible pairs for \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e and check if this pair gives you a valid answer.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(a x b)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tll n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tint ans \u003d 0;\n\tfor (int a \u003d 0; a \u0026lt; 1010; a++){\n\t\tfor (int b \u003d 0; b \u0026lt; 1010; b++){\n\t\t\tif (a * a + b \u003d\u003d m \u0026amp;\u0026amp; a + b * b \u003d\u003d n) ans++;\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214145/problem/Yellow\"\u003eYellow — LCM Challenge\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eBrute Force\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eTo solve this problem you just to think reasonably a little. Obviously the three integers you are going to pick are going to be close to \u003ccode\u003en\u003c/code\u003e, because in general big number give big LCM (with some exceptions). How can we choose three numbers that are (close) to \u003ccode\u003en\u003c/code\u003e and give the best LCM? Obviously these number are going to be in the range \u003ccode\u003e[n-100, n]\u003c/code\u003e. There is no use of choosing an integer which is far from \u003ccode\u003en\u003c/code\u003e by more than 100.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(10^6)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nll gcd(ll a, ll b) { return (b \u003d\u003d 0 ? a : gcd(b, a % b)); }\nll lcm(ll a, ll b) { return (a * (b / gcd(a, b))); }\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tll n; cin \u0026gt;\u0026gt; n;\n\tll maxLCM \u003d 0;\n\tfor (ll a \u003d max(1LL, n - 100); a \u0026lt;\u003d n; a++){\n\t\tfor (ll b \u003d max(1LL, n - 100); b \u0026lt;\u003d n; b++){\n\t\t\tfor (ll c \u003d max(1LL, n - 100); c \u0026lt;\u003d n; c++){\n\t\t\t\tmaxLCM \u003d max(maxLCM, lcm(a, lcm(b, c)));\n\t\t\t}\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; maxLCM \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}