{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1456927930,"rating":-2,"authorHandle":"Duarte","modificationTimeSeconds":1456927930,"id":43510,"title":"\u003cp\u003eHelp problem SegmentTree with lazy\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello everyone, I\u0027m trying to solve the problem \u003ca href\u003d\"http://www.spoj.com/problems/HORRIBLE/\"\u003ehttp://www.spoj.com/problems/HORRIBLE/\u003c/a\u003e, I solved using BIT, but I\u0027m learning about Lazy Propagation and I want to solve using this. I did a code but it is getting WA, and I don\u0027t know why. Anyone can help me ?\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\ntypedef long long int lli;\ntypedef vector\u0026lt;lli\u0026gt; vl;\n\nclass SegmentTree\n{\nprivate:\n\tvl st, lazy, A;\n\tint n;\n\tint left(int p) { return p \u0026lt;\u0026lt; 1; }\n\tint right(int p) { return (p \u0026lt;\u0026lt; 1) + 1; }\t\n\n\tlli rsq(int p, int L, int R, int i, int j)\n\t{\n\t\t\n\t\tif(lazy[p] !\u003d 0)\n\t\t{\n\t\t\tst[p] +\u003d (R - L + 1) * lazy[p];  //RMQ \u003d st[p] +\u003d lazy[\n\t\t\tif(L !\u003d R)\n\t\t\t{\n\t\t\t\tlazy[left(p)] +\u003d lazy[p];\n\t\t\t\tlazy[right(p)] +\u003d lazy[p];\n\t\t\t}\n\t\t\tlazy[p] \u003d 0;\n\t\t}\n\n\t\tif(i \u0026gt; R || j \u0026lt; L || R \u0026lt; L) return 0LL;\n\t\tif(L \u0026gt;\u003d i \u0026amp;\u0026amp; R \u0026lt;\u003d j) return st[p];\n\n\t\treturn rsq(left(p), L, (L + R) / 2, i, j) + rsq(right(p), (L + R) / 2 + 1, R, i, j);\n\t}\n\n\tvoid updateRange(int p, int L, int R, int i, int j, int newValue)\n\t{\n\t\tif(lazy[p] !\u003d 0)\n\t\t{\n\t\t\tst[p] +\u003d (R - L + 1) * lazy[p];  //RMQ \u003d st[p] +\u003d lazy[p];\n\n\t\t\tif(L !\u003d R)\n\t\t\t{\n\t\t\t\tlazy[left(p)] +\u003d lazy[p];\n\t\t\t\tlazy[right(p)] +\u003d lazy[p];\n\t\t\t}\n\t\t\tlazy[p] \u003d 0;\n\t\t}\n\n\t\tif(L \u0026gt; R || L \u0026gt; j || R \u0026lt; i)\n\t\t\treturn;\n\t\tif(L \u0026gt;\u003d i \u0026amp;\u0026amp; R \u0026lt;\u003d j)\n\t\t{\n\t\t\tst[p] +\u003d (R - L + 1) * newValue; //RMQ \u003d st[p] +\u003d value;\n\t\t\tif(L !\u003d R)\n\t\t\t{\n\t\t\t\tlazy[left(p)] +\u003d newValue;\n\t\t\t\tlazy[right(p)] +\u003d newValue;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tupdateRange(left(p), L, (L + R) / 2, i, j, newValue);\n\t\tupdateRange(right(p), (L + R) / 2 + 1, R, i, j, newValue);\n\n\t\tst[p] \u003d st[left(p)] + st[right(p)];\n\n\t}\n\n\n\npublic:\n\tSegmentTree(int _n)\n\t{\n\t\tn \u003d _n;\n\t\tst.assign(4 * n, 0);\n\t\tlazy.assign(4 * n, 0);\n\t}\n\n\tlli rsq(int i, int j)\n\t{\n\t\treturn rsq(1, 0, n - 1, i, j);\n\t}\n\tvoid updateRange(int i, int j, int newValue)\n\t{\n\t\tupdateRange(1, 0, n - 1, i, j, newValue);\n\t}\n};\n\nint main()\n{\n\tint T;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;T);\n\twhile(T--)\n\t{\n\t\tint n, c;\n\t\tscanf(\u0026quot;%d %d\u0026quot;, \u0026amp;n, \u0026amp;c);\n\t\tSegmentTree st(n);\n\n\t\tint x, p, q, v;\n\t\twhile(c--)\n\t\t{\n\t\t\tscanf(\u0026quot;%d %d %d\u0026quot;, \u0026amp;x, \u0026amp;p, \u0026amp;q);\n\t\t\tif(x \u003d\u003d 1)\n\t\t\t\tprintf(\u0026quot;%lld\\n\u0026quot;, st.rsq(p - 1, q - 1));\n\t\t\telse\n\t\t\t{\n\t\t\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;v);\n\t\t\t\tst.updateRange(p - 1, q - 1, v);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["segment tree","lazy propagation"]}}