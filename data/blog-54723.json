{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1506208347,"rating":0,"authorHandle":"Light","modificationTimeSeconds":1506208347,"id":54723,"title":"\u003cp\u003eWeek 8 Discussion\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eToday we talked about Dynamic Programming.\u003c/p\u003e\u003cp\u003eDynamic Programming\u0027s main idea is to save the answers of the \u0026quot;states\u0026quot; we already calculated to save the time needed in calculating of each them multiple times. And that could save us HUGE complexity.\u003c/p\u003e\u003ch3\u003eFibonacci\u003c/h3\u003e\u003cp\u003eFirst we tried applying this idea on finding the K\u0027th Fibonacci number, first our code had an O(2^n) complexity and it looked like this:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint fib(int k){\n\tif(k\u0026lt;\u003d1)\n\t\treturn 1;\n\treturn fib(k-1)+fib(k-2);\n}\n\nint main(){\n\tint k;\n\tcin\u0026gt;\u0026gt;k;\n\tcout\u0026lt;\u0026lt;fib(k)\u0026lt;\u0026lt;endl;\t\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eBut this, we noticed that we calculate some Fibonacci numbers too many times, so the idea we did was to calculate each Fibonacci number once, and store its value so next time we want it we won\u0027t have to calculate it all over again. So we made an array called \u0026quot;dp\u0026quot; which will first have -1 values (meaning we didn\u0027t calculate anything yet), and whenever we calculate a value we will store it in the array, and if we find a state that has it\u0027s number already calculated we will return that value without calculating it again. And by this we will have reduced the complexity from O(2^n) to O(n) since we will visit each number at most once.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint dp[100001];\n\nint fib(int k){\n\tif(dp[k]!\u003d-1)\n\t\treturn dp[k];\n\tif(k\u0026lt;\u003d1)\n\t\treturn dp[k]\u003d1;\n\treturn dp[k]\u003dfib(k-1)+fib(k-2);\n}\n\nint main(){\n\tmemset(dp,-1,sizeof(dp));\n\tint k;\n\tcin\u0026gt;\u0026gt;k;\n\tcout\u0026lt;\u0026lt;fib(k)\u0026lt;\u0026lt;endl;\t\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003chr /\u003e\u003ch3\u003eHammouri and Paint\u003c/h3\u003e\u003cp\u003eThis problem has given us a fence consisting of N wood boards, and told us the cost of painting each board in either White or Black. And wanted us to find the minimum total cost of painting all the boards such that no two adjacent boards are Black. We will brute force to try all possibilities, so we will need to know the index of the board I\u0027m painting, and if I painted the last board black or not. The complexity at the beginning is O(2^n), but since we can only calculate the different states, we can see that they\u0027re only O(n*2) which is great. (which index, and the bool)\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\nint n, B[100001], W[100001];\nlong long dp[100001][2];\n\nlong long calc(int u, bool f){\n\tif(dp[u][f]!\u003d-1)\n\t\treturn dp[u][f];\n\tif(u\u003d\u003dn)\n\t\treturn dp[u][f]\u003d0;\n\tlong long ans\u003dW[u]+calc(u+1,false);\n\tif(f\u003d\u003d0)\n\t\tans\u003dmin(ans, B[u]+calc(u+1,true));\n\treturn dp[u][f]\u003dans;\n}\t\n\nint main(){\n\tcin\u0026gt;\u0026gt;n;\n\tfor(int i\u003d0; i\u0026lt;n; ++i)\n\t\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;B[i],\u0026amp;W[i]);\n\tmemset(dp,-1,sizeof(dp));\n\tcout\u0026lt;\u0026lt;calc(0,0)\u0026lt;\u0026lt;endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eYou can try solving the following problem: (Same idea)\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://www.spoj.com/problems/FARIDA/\"\u003ehttp://www.spoj.com/problems/FARIDA/\u003c/a\u003e\u003c/p\u003e \u003chr /\u003e\u003ch3\u003eHammouri and Coins\u003c/h3\u003e\u003cp\u003eThis problem has given us a 1xN grid which a player will move on, in each second he can either go left, right, or stay at the same place. And there are C coins appearing on the grid for one second each at a specific time in a specific place, so starting from position 1, the problem asks what\u0027s the maximum number of coins we can collect. We got to the solution that we need to know in our state, the index we\u0027re standing in, and the time that has passed so far, so we can know if there\u0027s a coin appearing in this position at this time (we will have saved that earlier), and we would try all possibilities (either go right, left, or stay as is). And so, we will have tried every possible outcome and taken the best. Since our state is position and time, the number of different states will be: number_of_different_positions * number_of_different_times, which is equal to 1000*2000 \u003d 1e6 which is fast enough. So the complexity is O(N*T). \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint n,c,dp[1001][2001];\nbool have[1001][2001];\n\nint calc(int pos, int tm){\n\tif(tm\u0026gt;2000)\n\t\treturn 0;\n\tif(dp[pos][tm]!\u003d-1)\n\t\treturn dp[pos][tm];\n\tint res\u003dcalc(pos, tm+1); //try staying same place\n\tif(pos+1\u0026lt;\u003dn)             //try going right only if I\u0027m not at the end of the grid\n\t\tres\u003dmax(res, calc(pos+1, tm+1));\n\tif(pos-1\u0026gt;\u003d1)             //try going left only if I\u0027m not at the beginning of the grid\n\t\tres\u003dmax(res, calc(pos-1, tm+1));\n\tif(have[pos][tm])        //add current coin\n\t\t++res;\n\treturn dp[pos][tm]\u003dres;\n}\nint main(){\n\tcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;c;\n\tfor(int t,p,i\u003d0; i\u0026lt;c; ++i){\n\t\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;t,\u0026amp;p);\n\t\thave[p][t]\u003dtrue;\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tcout\u0026lt;\u0026lt;calc(1,0)\u0026lt;\u0026lt;endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003chr /\u003e\u003ch3\u003eTwo Ends\u003c/h3\u003e\u003cp\u003e\u003ca href\u003d\"http://www.spoj.com/problems/TWENDS/\"\u003ehttp://www.spoj.com/problems/TWENDS/\u003c/a\u003e (You can read it here)\u003c/p\u003e\u003cp\u003eWe found that our state need 3 things: - The left border of the cards left. - The right border of the cards left. - Who\u0027s turn it is now.\u003c/p\u003e\u003cp\u003eIf we count the different states it would be (1000*1000*2) which is O(1e6) which is fast enough.\u003c/p\u003e\u003cp\u003eNow our dp will run according to who\u0027s turn it is, since we want the difference between Optimal and Greedy strategies, we can add the points of the Optimal strategy and subtract the points of the Greedy strategy, so we will have in total the summation of Optimal cards â€” the summation of Greedy cards.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint n, v[1001], dp[1001][1001][2];\n\nint calc(int i, int j, bool f){\n\tif(i\u0026gt;j)  \t\t\t\t//base case\n\t\treturn 0;\n\tif(dp[i][j][f]!\u003d-1)     //this state is visited\n\t\treturn dp[i][j][f];\n\tint res\u003d0;\n\tif(!f){\t\t\t\t\t\t//First player turn\n\t\tres\u003dv[i]+calc(i+1, j, 1);\n\t\tres\u003dmax(res, v[j]+calc(i, j-1, 1));\n\n\t}else{\t\t\t\t\t\t//Second player turn\n\t\tif(v[i]\u0026gt;\u003dv[j])\n\t\t\tres\u003d -v[i]+calc(i+1, j, 0);\n\t\telse\n\t\t\tres\u003d -v[j]+calc(i, j-1, 0);\n\t}\n\treturn dp[i][j][f]\u003dres;\n}\nint main(){\n\tcin\u0026gt;\u0026gt;n;\n\tint ct\u003d1;\n\twhile(n\u0026gt;0){\n\t\tfor(int i\u003d0; i\u0026lt;n; ++i)\n\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;v[i]);\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tint ans\u003dcalc(0,n-1,0);\n\t\tprintf(\u0026quot;In game %d, the greedy strategy might lose by as many as %d points.\\n\u0026quot;, ct, ans);\n\t\tcin\u0026gt;\u0026gt;n;\n\t\t++ct;\n\t}\n\t\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eAnd that\u0027s all for this week! I\u0027ll try to add these problems and others into a contest as soon as possible, try writing all the codes yourselves and remember that Google is your friend, whatever you want to learn about there\u0027s info about it on Google!\u003c/p\u003e\u003cp\u003eGood luck and work hard!\u003c/p\u003e\u003c/div\u003e","tags":[]}}