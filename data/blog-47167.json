{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1474118651,"rating":5,"authorHandle":"PrashantM","modificationTimeSeconds":1474178108,"id":47167,"title":"\u003cp\u003eSSN CPC Contest — 4 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eA. Puzzles\u003c/h2\u003e\u003cp\u003eWe need to select \u0027n\u0027 elements from an array of size \u0027m\u0027(n \u0026lt;\u003d m) such that the difference between the max-element and min-element in the chosen set is minimised. Notice that once we sort the array, we now need to choose the best sub-array of size n. The max-element and min-element will be the last element and the first element of the subarray respectively. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(mlogm)\u003c/strong\u003e\u003c/p\u003e\u003ch2\u003eB. Boredom\u003c/h2\u003e\u003cp\u003eNotice that the constraints for each element ai is: 1 \u0026lt;\u003d ai \u0026lt;\u003d 10^5. The problem states that by removing a[i], we must remove a[i — 1] and a[i + 1]. To make it simpler, let us store the count of each value from 1 — 10^5 in the array. Let us call this array \u0027c\u0027. c[i] stores the count of value \u0027i\u0027 in the array.\u003c/p\u003e\u003cp\u003eDynamic Programming can be used to solve the question. Let us define dp[i] to be the optimal selection of first i values that will maximize the total points. This is the first step, defining a function.\u003c/p\u003e\u003cp\u003eThe second step, is to find a recurrence. Always, try to shrink the problem from an \u0027end point\u0027. In this case, we either select the value i or we don\u0027t. If we select i, it makes sense to select all elements with value i. This will add c[i] * i to the score. But we cannot use i — 1 now. If we don\u0027t select i, we leave it to dp[i — 1] to select the optimal answer. So, the following recurrence is obtained:\u003c/p\u003e\u003cp\u003edp[i] \u003d max(dp[i — 1],c[i] * i + dp[i — 2]);\u003c/p\u003e\u003cp\u003eNote that this is almost exactly same as the weighted independent set problem.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(M) where M \u003d max value of array (10^5).\u003c/strong\u003e \u003c/p\u003e\u003ch2\u003eC. Cut Ribbon\u003c/h2\u003e\u003cp\u003eLet us use Dynamic Programming to solve this question.\u003c/p\u003e\u003cp\u003eFunction: dp[i] stores the maximum pieces that can be obtained from a ribbon of length i. \u003c/p\u003e\u003cp\u003eRecurrence: dp[i] \u003d max(dp[i — a],dp[i — b],dp[i — c]) + 1 because we either cut the first piece with length a,b or c, after which we are left with ribbon of length i — a,i — b or i — c. \u003c/p\u003e\u003cp\u003eImplementation details are left as an exercise.\u003c/p\u003e\u003ch2\u003eD. Ilya and Queries\u003c/h2\u003e\u003cp\u003eThis problem does not need Dynamic Programming specifically. \u003c/p\u003e\u003cp\u003eLet us create an array \u0027a\u0027 of size \u0027n — 1\u0027. Let a[i] store 1 if s[i] \u003d\u003d s[i + 1], 0 otherwise. Now each query (l,r) is the sum of elements from l to r — 1. This can be calculated in O(1) by storing prefix sums. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(N + M)\u003c/strong\u003e\u003c/p\u003e\u003ch2\u003eE. Flowers\u003c/h2\u003e\u003cp\u003eLet dp[i] denote the number of ways of assigning white and red flowers getting a total of \u0027i\u0027 flowers. The last flower can either be red or white. If it is red, then we can safely consider dp[i — 1] since there is no restriction on the previous flowers. If it is white however, we must make sure the last k flowers are white. So we now fix that and consider dp[i — k].\u003c/p\u003e\u003cp\u003edp[i] \u003d dp[i — 1] + dp[i — k];\u003c/p\u003e\u003cp\u003eTo answer queries again, prefix sums are used. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(M + t) where M is the max value of total number of flowers.\u003c/strong\u003e\u003c/p\u003e\u003ch2\u003eF. Long Path\u003c/h2\u003e\u003cp\u003eThere are different ways to do this problem, I will explain my approach. \u003c/p\u003e\u003cp\u003eAfter drawing a cross on the ceiling of room \u0027i\u0027, if there are odd number of crosses you move to room p[i] using portal 2. Otherwise, you will use portal 1 and move to (i + 1). \u003c/p\u003e\u003cp\u003eFirst notice that each time you enter a room, you will be alternating between using portal 1 and portal 2 (because the parity of crosses — odd/even — changes with each entrance). \u003c/p\u003e\u003cp\u003eThe first question that should be asked is, in this setting, how are we guaranteed that the person will reach (n + 1) from 1? At first glance it seems like we may randomly go back sometimes (using second portal) and forward sometimes (using first portal). What if we are always stuck in some kind of loop where we can\u0027t get beyond a room?\u003c/p\u003e\u003cp\u003eIt can be proved that, this will never happen! We will always end at room (n + 1) eventually. Let us think of a rough proof:\u003c/p\u003e\u003cp\u003eWe will be using induction to prove. Let us assume we can reach room i. Note that, this means we would have gone through every room \u0026lt; i to reach i. Because, the only way you can move forward is using portal 1: which takes you forward by 1 room. You cannot skip rooms forward. We need to prove that if we reach room i, we will always be able to reach room (i + 1). Suppose after painting the cross, there are even number of crosses. Now, trivially you will reach room (i + 1). Suppose there are odd number of crosses, we will go to room p[i] using second portal. p[i] will have odd number of crosses when we enter the room and paint the cross (This is important, try to think why). Now, we must reach room i again because we assumed that we can reach room i, there will not be a loop before i that prevents reaching i. This time, room i will have even number of crosses, so we will go to room (i + 1). Room 1 can be reached always trivially. Hence by induction we will be able to reach room (n + 1) from 1.\u003c/p\u003e\u003cp\u003eNow, this should give us some intuition to build the solution using DP. \u003c/p\u003e\u003cp\u003eLet us assume we are currently at room \u0027i\u0027 where after painting, we have odd number of crosses(this could also mean we just entered the room, because there will be 1 cross). How many portals do you need to pass through, to get back to i ? Because once we get back to i, we will have even number of crosses and we can move forward. \u003c/p\u003e\u003cp\u003eLet us define dp[i] to be the above. \u003c/p\u003e\u003cp\u003edp[i] \u003d number of portals to reach i, starting from i assuming you initially have odd number of crosses on the ceiling. \u003c/p\u003e\u003cp\u003eThe following recurrence is obtained. \u003c/p\u003e\u003cp\u003edp[i] \u003d 1; // This one portal is to reach p[i], since there are odd number of crosses. dp[i] +\u003d dp[p[i]] + 1; // After entering and painting, p[i] will have odd number of crosses. Once we get back to p[i], we go to the next room hence that is 1 portal. dp[i] +\u003d dp[p[i] + 1] + 1; // Similar to above. dp[i] +\u003d dp[p[i] + 2] + 1; ... dp[i] +\u003d dp[i — 1] + 1; // Finally we reach i again. \u003c/p\u003e\u003cp\u003eFinal answer would be: (dp[1] + 1) + (dp[2] + 1) + (dp[3] + 1) ..... (dp[n] + 1)\u003c/p\u003e\u003cp\u003eEach \u0027+ 1\u0027 is for moving to the next room using first portal. \u003c/p\u003e\u003cp\u003eThis solution is probably overkill ( :P ) and there are simpler solutions. But it mentions different intuitions and thoughts that might need to occur to you while thinking of a DP solution. This is not meant to scare the reader away because of it\u0027s length, the point is with time you will never consciously think of all these steps. Somehow, you will get the last recurrence and function pretty quickly. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eBottom Line:\u003c/strong\u003e Improving in Dynamic Programming, basically means improving intuition. And this will come only with practice and seeing different functions to get better ideas. As always, practice is the key. \u003c/p\u003e\u003c/div\u003e","tags":[]}}