{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1485386067,"rating":33,"authorHandle":"xsc","modificationTimeSeconds":1485512150,"id":50013,"title":"\u003cp\u003eAgain, low-level i/o C++.\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI decided to rewrite this post, previously has been deleted.\u003c/p\u003e\u003cp\u003eI know there a many of posts low-level i/o. \u003c/p\u003e\u003cp\u003escanf/printf solves slowly i/o, partially, but not always. \u003c/p\u003e\u003cp\u003eMost generic usage i/o — is read and write integers, so I\u0027ll write about it without a hundred lines of source code.\u003c/p\u003e\u003ch1\u003e1. Read integers.\u003c/h1\u003e\u003cp\u003eFor simplicity, all input file content loaded to a big buffer, and it will be parsed.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003echar in[1\u0026lt;\u0026lt;23] ; // a big buffer\nchar const* o ; // pointer to buffer.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd for detecting end of buffer, put \u0027\\0\u0027 — terminating symbol to end of buffer ( as plain c-string).\u003c/p\u003e\u003ch4\u003eNow loading the file:\u003c/h4\u003e \u003cpre\u003e\u003ccode\u003evoid load(){  o \u003d in;   in [   fread(in,  1,  sizeof(in ) - 4 ,  stdin ) ] \u003d 0; }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003efread - returns number of reading symbols, we just use this for put \u0027\\0\u0027 terminating symbol to end of buffer.\u003c/code\u003e\u003c/p\u003e\u003ch4\u003eReading a unsigned integer:\u003c/h4\u003e \u003cpre\u003e\u003ccode\u003eunsigned readUInt(){\n      unsigned u \u003d 0;\n      \n      while( *o \u0026amp;\u0026amp; *o \u0026lt;\u003d 32) ++o ; //  skip spaces\n    \n      while ( *o \u0026gt;\u003d\u00270\u0027 \u0026amp;\u0026amp; *o \u0026lt;\u003d\u00279\u0027) u \u003d (u \u0026lt;\u0026lt; 3) + (u \u0026lt;\u0026lt; 1) + (*o++ -\u00270\u0027);\n      return u;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBy default most implementations used \u003ccode\u003eu \u003d u * 10 + (*o++ - \u00270\u0027)\u003c/code\u003e,\u003cbr /\u003ebut \u003ccode\u003eu * 10 \u003d u * 8 + u * 2 \u003d (u \u0026lt;\u0026lt; 3) + (u \u0026lt;\u0026lt;1)\u003c/code\u003e I don\u0027t know it gives speed, but with shifting the code become happy :) \u003c/p\u003e\u003ch4\u003eReading signed integer.\u003c/h4\u003e\u003cp\u003eSome theory of signed integer representation, in most situation \u003ca href\u003d\"https://en.wikipedia.org/wiki/Signed_number_representations\"\u003esee here\u003c/a\u003e \u003c/p\u003e\u003cp\u003e\u003ccode\u003e-u \u003d\u003d ~u  + 1\u003c/code\u003e\u003c/p\u003e\u003cp\u003eThere \u003cstrong\u003e~\u003c/strong\u003e — bitwise inverting.\u003c/p\u003e\u003cp\u003eAnd  \u003ccode\u003e~u \u003d\u003d u ^ 0xFFFFFFFF\u003c/code\u003e or \u003ccode\u003e~u \u003d\u003d u ^ ~0\u003c/code\u003e\u003c/p\u003e\u003cp\u003eLet start writing method\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    int readInt()\n    {\n         unsigned u \u003d 0, s \u003d 0; // s \u003d 0, if integer positive, s \u003d ~0 - if integer negative\n         while(*o \u0026amp;\u0026amp; *o \u0026lt;\u003d 32)++o; // skip spaces\n         \n         if (*o \u003d\u003d \u0027-\u0027)s \u003d ~0, ++o; else if (*o \u003d\u003d \u0027+\u0027) ++o; // determine sign\n         while( *o \u0026gt;\u003d\u00270\u0027 \u0026amp;\u0026amp; *o \u0026lt;\u003d \u00279\u0027) u \u003d (u \u0026lt;\u0026lt; 3) + (u \u0026lt;\u0026lt; 1) + (*o ++ - \u00270\u0027);\n\n         return (u^s) + !!s; // ??????? : s \u003d 0 :  (u^s) + !!s \u003d (u^0) + !!0 \u003d u + 0 \u003d u, and\n                             //           s \u003d ~0:  (u^s) + !!s \u003d (u ^ ~0) + !! ~0 \u003d (u^0xFFFFFFFF) + 1 \u003d ~u + 1 \u003d -u\n         \n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHow to use this complete?\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n\nchar const * o;\nchar in[1\u0026lt;\u0026lt;23];\n\nvoid load(){ o \u003d in ;  in [ fread(in,1,sizeof(in)-4,stdin)] \u003d 0; }\nunsigned readUInt(){\n     unsigned u \u003d 0;\n     while(*o \u0026amp;\u0026amp; *o \u0026lt;\u003d 32)++o;\n     while(*o \u0026gt;\u003d\u00270\u0027 \u0026amp;\u0026amp; *o \u0026lt;\u003d\u00279\u0027) u \u003d (u \u0026lt;\u0026lt; 3) + (u \u0026lt;\u0026lt; 1) + (*o++ -\u00270\u0027);\n     return u;\n}\nint readInt(){\n    unsigned u \u003d 0, s \u003d 0;\n    while(*o \u0026amp;\u0026amp; *o \u0026lt;\u003d 32)++o;\n    if (*o \u003d\u003d \u0027-\u0027) s \u003d ~0, ++o; else if(*o \u003d\u003d \u0027+\u0027) ++o;\n    while(*o \u0026gt;\u003d\u00270\u0027 \u0026amp;\u0026amp; *o \u0026lt;\u003d\u00279\u0027) u \u003d (u \u0026lt;\u0026lt; 3) + (u \u0026lt;\u0026lt; 1) + (*o++ - \u00270\u0027);\n\n    return (u ^ s) + !!s;\n}\n\nint main()\n{\n     load();\n     int n \u003d readInt();\n     int s \u003d 0;\n     for(int i\u003d 0; i \u0026lt; n; ++i)s +\u003d readInt();\n\n     printf(\u0026quot;summa \u003d %d\\n\u0026quot;, s);\n     \n     return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCompare low-level i/o: \u003ca href\u003d\"/contest/762/submission/24139587\" title\u003d\"Submission 24139587 by xsc\"\u003e24139587\u003c/a\u003e with std::cin , std::cout \u003ca href\u003d\"/contest/762/submission/24133798\" title\u003d\"Submission 24133798 by xsc\"\u003e24133798\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eBenchmark: read and write 10^6 numbers took \u003ca href\u003d\"https://github.com/raidenluikang/algorithms/tree/master/fastio\"\u003e120~150 milliseconds\u003c/a\u003e where scanf/printf ~650 milliseconds.\u003c/h3\u003e\u003ch2\u003efor competetive programming this single method is enough for reading integers:\u003c/h2\u003e \u003cpre\u003e\u003ccode\u003e   typedef long long ll;\n   typedef unsigned long long ull;\n\n    ll  readInt(){\n          ull u \u003d 0 , s \u003d 0;\n          while(*o \u0026amp;\u0026amp; *o \u0026lt;\u003d 32)++o;\n          if (*o \u003d\u003d \u0027-\u0027) s \u003d ~s, ++o; else if (*o \u003d\u003d \u0027+\u0027) ++o;\n          while(*o \u0026gt;\u003d\u00270\u0027 \u0026amp;\u0026amp; *o\u0026lt;\u003d\u00279\u0027) u \u003d (u \u0026lt;\u0026lt; 3) + (u \u0026lt;\u0026lt; 1) + (*o++ -\u00270\u0027);\n\n          return (u ^ s) +!!s; \n    }\n\u003c/code\u003e\u003c/pre\u003e \u003chr /\u003e\u003ch1\u003e 2. Writing integers.\u003c/h1\u003e\u003cp\u003eThere are need a big buffer and pointer, again.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etypedef long long ll;\nchar out[1\u0026lt;\u0026lt;23];\nchar * w \u003d out; // initialize with \u0026amp;out[0] - beginning of the buffer.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThere a single \u003cstrong\u003ewriteInt\u003c/strong\u003e method, arguments: integer \u003ccode\u003eu\u003c/code\u003e and serarator \u003ccode\u003ec\u003c/code\u003e . \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// need to implement this method.\nvoid writeInt( ll u, char separator); // u - integer, separator - will printed after the integer, most situations is space, or \u0027\\n\u0027.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eAND flush method, which we must call at the end of all operations.\u003c/strong\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// flush - must be called before end of program.\nvoid flush(){  fwrite(out, 1, w - out, stdout); }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFor implementing \u003cstrong\u003ewriteInt\u003c/strong\u003e need temporary buffer :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid writeInt(ll u, char separator)\n{\n     char tmpbuf[20]; int i;\n     if ( u \u0026lt; 0 ){ *w ++ \u003d \u0027-\u0027; u \u003d - u ; }\n     i \u003d 20;\n     do tmpbuf[--i] \u003d u % 10 + \u00270\u0027; while(u/\u003d10); // write last digits of u to tmpbuf from end to begin.\n     \n     // now write tmpbuf to out[] buffer from w pointer.\n     do *w++ \u003d tmpbuf[i++]; while(i \u0026lt; 20);\n\n    // and separator\n     *w++ \u003d separator;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt\u0027s all.\u003c/p\u003e\u003cp\u003e------------------------------------------------------------------------------------------------------\u003c/p\u003e\u003ch1\u003eUPD: Wrapper classes.\u003c/h1\u003e\u003cp\u003eLet simplify all above codes.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etypedef long long ll;\ntypedef unsigned long long ull;\n\nchar in[1\u0026lt;\u0026lt;23];\nchar out[1\u0026lt;\u0026lt;23];\n\n//wrapper to reader\nstruct scanner\n{\n    char const* o;\n    scanner(): o(in){ load(); }\n    void load(){ in[ fread(in , 1, sizeof(in)- 4, stdin)] \u003d 0; }\n    ll readInt(){\n        ull u \u003d 0, s \u003d 0;\n        while(*o \u0026amp;\u0026amp; *o \u0026lt;\u003d 32)++o;\n        if (*o \u003d\u003d \u0027-\u0027)s \u003d ~s, ++o; else if (*o \u003d\u003d \u0027+\u0027)++o;\n        while(*o \u0026gt;\u003d\u00270\u0027 \u0026amp;\u0026amp; *o \u0026lt;\u003d\u00279\u0027) u \u003d (u \u0026lt;\u0026lt; 3) + (u \u0026lt;\u0026lt; 1) + (*o++ - \u00270\u0027);\n        return (u^s) + !!s;\n    }\n};\n\n//wrapper to writer\nstruct writer\n{\n    char * w;\n    writer(): w(out){}\n   ~writer(){ flush();}\n   void flush(){ if (w!\u003dout){ fwrite(out,1,w-out,stdout); w \u003d out; } } \n   void writeInt(ll u, char c){\n        char t[20]; int i \u003d 20; \n         if (u \u0026lt; 0){ *w++ \u003d \u0027-\u0027; u \u003d -u;}\n        do t[--i] \u003d u % 10 + \u00270\u0027; while(u/\u003d10);\n        do *w++ \u003d t[i++]; while(i \u0026lt; 20);\n        *w++ \u003d c;\n   }\n};\n\n\n//A+B\nint main()\n{\n    scanner sc;\n    writer pw;\n    pw.writeInt(sc.readInt() + sc.readInt(), \u0027\\n\u0027);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch1\u003eUPD-2 Reverse-Writer\u003c/h1\u003e\u003cp\u003eSometimes, needed restore answer from end to begin, for example shortest path in graph from source to target. Most solution is save answer to array, vector, and reverse it and print. But there exists another solution with \u003cstrong\u003ereverse-writer\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eReverse-writer -is simple writes numbers to array from end to begin in reverse order. \u003c/p\u003e\u003cp\u003eLet code it\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etypedef long long ll;\ntypedef unsigned long long ull;\n\nchar out[1\u0026lt;\u0026lt;23];\n\nstruct reverse_writer\n{\n   char * w;\n   reverse_writer(): w( out + sizeof(out) ){} // w - indicated end of  out[] array\n   ~reverse_writer(){ flush(); }\n   void flush(){  \n      if (w !\u003d out + sizeof(out) ) \n          fwrite(w, 1, out + sizeof(out) - w, stdout), w \u003d out + sizeof(out);\n    }\n   \n   void writeInt(ll u, char c){\n       *--w \u003d c; // print separator at first\n       (u \u0026lt; 0) ? (u \u003d -u, c \u003d\u0027-\u0027) : c \u003d \u0027\\0\u0027 ; // determine sign\n       do *--w \u003d u%10 + \u00270\u0027; while(u/\u003d10); // put digits \n       if(c)   *--w\u003d c ;// write sign \n   }\n};\n\n\n// USAGE:\n\nvi g[maxn];\nint parent[maxn];\nint n,m,source, target;\nint main()\n{\n     scanner sc; \n     reverse_writer pw;\n     \n     n \u003d sc.readInt(), m \u003d sc.readInt(), source \u003d sc.readInt(), target \u003d sc.readInt();\n\n      for(int i\u003d 0; i\u0026lt;m;++i){ \n          int a \u003d sc.readInt(), b \u003d sc.readInt(); \n         g[a].push_back(b); g[b].push_back(a);\n      }\n\n      memset(parent, -1, sizeof(parent)); \n     dejkstra(source, target);\n\n     int total \u003d 0;  char c \u003d \u0027\\n\u0027;\n     for(int i \u003d target ; i !\u003d -1; i \u003d parent[i], ++total) \n               pw.writeInt( i , c), c \u003d \u0027 \u0027;\n     pw.writeInt(total, \u0027\\n\u0027);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eGOoD lUck!\u003c/p\u003e\u003c/div\u003e","tags":["c++","fast i/o"]}}