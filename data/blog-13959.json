{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1411649731,"rating":160,"authorHandle":"adamant","modificationTimeSeconds":1412017360,"id":13959,"title":"\u003cp\u003ePalindromic tree: behind the scenes\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi everyone!\u003c/p\u003e\u003cp\u003eAs some of you may know, on this summer camp in Petrozavodsk \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/MikhailRubinchik\" title\u003d\"Master MikhailRubinchik\"\u003eMikhailRubinchik\u003c/a\u003e presented a new data structure, palindromic tree. I had the honor to participate in the study of the structure for the six months before that, and I want to tell about it now :) \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eBut firstly a brief explanation. If you alredy know basic ideas of the structure, you may go to the \u003ca href\u003d\"#inter\"\u003einterest part\u003c/a\u003e. Let\u0027s to each palindrome assign corresponding string equal to its right half, i.e., its radius and the boolean variable indicating its parity. Now let\u0027s merge all our radii of subpalindromes of string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e in two prefix trees for even and odd lengths separately. Claim: such trie will be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/72/58/72586b0a63e260f84ef51e7564e30c32ed111e49.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e in memory. Indeed, there can be no more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e distinct subpalindromes in the string, and each node in trie corresponds with only one unique palindrome. Therefore, we have no more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + 2\u003c/span\u003e nodes. \u003c/p\u003e\u003cp\u003eLet\u0027s show that such structure can be constructed in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/98/ee/98ee68ac6cc5a7a1c0a11c7bc4e54303208fb337.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Let each vertex in the tree store \u003cem\u003esuffix link\u003c/em\u003e that leads to the node that corresponds to the radius of maximum suffix palindrome \u003cem\u003eof the whole palindrome\u003c/em\u003e of current node. For example, there is a vertex corresponding to the radius \u003cspan class\u003d\"tex-span\"\u003e\u0026quot;\u003ci\u003ebacaba\u003c/i\u003e\u0026quot;\u003c/span\u003e with odd length, i.e., to the palindrome \u003cspan class\u003d\"tex-span\"\u003e\u0026quot;\u003ci\u003eabacabacaba\u003c/i\u003e\u0026quot;\u003c/span\u003e. Suffix link will lead in the node corresponding to the radius of maximum suffix palindrome \u003cspan class\u003d\"tex-span\"\u003e\u0026quot;\u003ci\u003eabacaba\u003c/i\u003e\u0026quot;\u003c/span\u003e, i.e., \u003cspan class\u003d\"tex-span\"\u003e\u0026quot;\u003ci\u003ecaba\u003c/i\u003e\u0026quot;\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow let us assume that we have a palindromic tree for a string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e and we want to add to the end of the string some character. We will maintain a pointer to the node corresponding to the maximum suffix-palindrome of string on every step. Further actions are similar to those in the construction of suffix automaton. We are look at the new character in the string and at the one that stands in a string before palindrome, which corresponds to the current state. If they do not match, then let\u0027s go by the suffix link and repeat the check. When they match, we look at whether there is an edge to the new character in the node. If yes, then move along the edge and enjoy, if not palindrome that we should add was not in a string before. So, let\u0027s create for it a new node. Now we need to find for it suffix link. Well, let\u0027s go by the suffix links again until you find the correct position in a second time for the same symbol. When we found it — this is the suffix link to a new node. That\u0027s all. Now we have an algorithm that works amortized in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/98/ee/98ee68ac6cc5a7a1c0a11c7bc4e54303208fb337.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, since at each stage we firstly several times reducing our current string, and then increase it by only one character. And obviously there will be no more erases than inserts (which are no more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eAnd yes, a few words about the implementation. You may have noticed that I do not consider the case when occurs the loss outside of the tree. This is due to the fact that such a loss never occurs :). How to achieve this \u0026amp; mdash; since we have two tries, we have two roots. For one of them let\u0027s make an initial length 0 (for even palindromes), and for the second — -1 (respectively for odd). And by default let\u0027s do a suffix link from the first one to the second. Thus, every time we are at the root with the length of -1, we always find that the extension is possible, as the new symbol and the symbol before the suffix-palindrome are the same in this case.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/SdsoPV\"\u003elink\u003c/a\u003e \u003cbr /\u003e Written by me as the most similar to the suffix automaton for the purpose of easier memorization :). There is also great implementation from \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Merkurev\" title\u003d\"Grandmaster Merkurev\"\u003eMerkurev\u003c/a\u003e \u003ca href\u003d\"http://pastebin.com/WyUwbhaM\"\u003elink\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003ca name\u003d\"inter\"\u003e \u003c/a\u003e Now I will talk about how it happened that I was involved in the preparation of the problem for Petrozavodsk camp. In the comments to my \u003ca href\u003d\"/blog/entry/12143\"\u003earticle\u003c/a\u003e about the Manacher\u0027s algorithm \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/MikhailRubinchik\" title\u003d\"Master MikhailRubinchik\"\u003eMikhailRubinchik\u003c/a\u003e wrote about the online version of the algorithm and asked to add it to the article, which I did, after some discussion. Just then Michael told me about the problem from the APIO, which, in an amazing coincidence, was held at the same time. Brief statement: find refrain-palindrome in the given string.\u003c/p\u003e\u003cp\u003eThen Mikhail hinted that they have a cool structure that quickly and easily solves that problem. Since I was young and inexperienced and still wasn\u0027t familiar with the hard suffix structures, I decided to think about that kind of constructive alternative solution. So I\u0027m somewhat reinvented palindromic tree :) In fact, I was very far from the solution, because I did not use the suffix links, and wanted to build it with hashes, but nevertheless I came up with the general structure. And when I told about my tree Mikhail it turned out that it is exactly the structure he told about earlier :)\u003c/p\u003e\u003cp\u003eFurthermore, it was a lot of productive discussion, the results of which I would like to share. For example, I figured out a way to build a tree in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/04/2c/042cb9cecdd34a553c4cb81fe9014bedbb999c5c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, which, however, in practice is faster than many algorithms with other structures that work in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/72/58/72586b0a63e260f84ef51e7564e30c32ed111e49.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. The idea was similar to an online Manacher\u0027s algorithm \u0026amp; mdash; let\u0027s store in each item of the array the pointer to the vertex, which corresponds to the maximum palindrome centered at this item. Further, when calculated palindrome in the new cell, we take either vertex from symmetric to the center of maximum suffix-palindrome cell or some of its ancestor with less length, if it \u0026quot;climbs\u0026quot; over the current end of the string. Initially, it seemed to me that the solution will be linear even if you just go up to the correct level every time, but it turned out that it is not :(\u003c/p\u003e\u003cp\u003eUsing the technique of binary expansion, I was able to reduce time to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bb/25/bb25084d08f4b4b34aa9ae68446613adf360cd79.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Also there are algorithms for finding LA (Level Ancestor) in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8f/c4/8fc4a0f28124b1da0ee2708f303ea3424b95a0e8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, which would solve this problem in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c4/1f/c41f0d8621cab121ad73b55e540e53c2a1294117.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, but, obviously, it would be unreasonable because of the complexity of algorithm. So...\u003c/p\u003e\u003cp\u003e\u003cstrong\u003echallenge 1:\u003c/strong\u003e Can you improve the idea of this algorithm to the \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/72/58/72586b0a63e260f84ef51e7564e30c32ed111e49.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, without using common methods of solving LA problem?\u003c/p\u003e\u003cp\u003eCode:\u003cbr /\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5d/1f/5d1f29f648247e77966a5b1703590aea2a6a75b6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e: \u003ca href\u003d\"http://ideone.com/j8NP5f\"\u003elink\u003c/a\u003e\u003cbr /\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/04/2c/042cb9cecdd34a553c4cb81fe9014bedbb999c5c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e: \u003ca href\u003d\"http://ideone.com/FybSWl\"\u003elink\u003c/a\u003e\u003c/p\u003e\u003cp\u003eOddly enough, it\u0027s not all what I wanted to tell about. In the original version of the problem, which was planned to be at Petrozavodsk one had to not only add character to the end of string and count the number of new palindromes, but also to delete the character from the end of the string. Later, this part has been removed since problem was already complicated enough. Now I would like to describe the possible algorithms for the solution of the task, which was to be originally.\u003c/p\u003e\u003cp\u003eFirstly let\u0027s understand \u0026amp; mdash; what is a problem for us? It seems that we have everything to solve the problem, why wouldn\u0027t we just do a rollback to the previous state? However, this conclusion is false, because the evaluation of adding a new symbol \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/de/14/de14a2d31304107b7af4cc1c3a1099b876dc0c21.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is amortized. And if we for example take a string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eaaaaaaa\u003c/i\u003e...\u003ci\u003eaab\u003c/i\u003e\u003c/span\u003e, and then start each time to remove and return \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. It is easy to see that at each step we will make \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/72/58/72586b0a63e260f84ef51e7564e30c32ed111e49.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e iterations that is of course, unacceptable. Both methods, which will be described have the goal to make an appending of character with strict but not amortized complexity. So:\u003c/p\u003e\u003cp\u003e1) \u0026quot;Smart\u0026quot; suffix links. Let\u0027s at each vertex store additional suffix link that leads to the vertex, which have different preceding character in string as in the usual suffix link. Now we can use ordinary and \u0026quot;smart\u0026quot; suffix links in order to find the next state faster. According to Lemma 11 of \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/MikhailRubinchik\" title\u003d\"Master MikhailRubinchik\"\u003eMikhailRubinchik\u003c/a\u003e\u0027s \u003ca href\u003d\"http://arxiv.org/abs/1404.5244\"\u003eArticle\u003c/a\u003e (article not yet available, however, it has already been accepted for publication. Since it will soon be performing at \u003ca href\u003d\"http://www.sofsem.cz/sofsem15/\"\u003ethis\u003c/a\u003e conference), the path to the root with \u0026quot;smart\u0026quot; links will pass through \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bd/54/bd54c1d599b8a21e51cf2a6e39d309b8fbed6402.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e vertices. Thus, every time we will do no more than \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bd/54/bd54c1d599b8a21e51cf2a6e39d309b8fbed6402.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e operations.\u003c/p\u003e\u003cp\u003e2) \u003ca name\u003d\"ref20\"\u003e \u003c/a\u003e full automaton. Nor, for that matter, why do we bathe with complex theorems, and \u003cem\u003eone\u003c/em\u003e link that takes you to a different character? Let\u0027s keep at each vertex array on \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/49/3d/493d70cfcabb819c54c71de718409d556227a5d8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e elements \u0026amp; mdash; one such link for each letter in the alphabet. It is easy to show that we can now answer the query in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/49/3d/493d70cfcabb819c54c71de718409d556227a5d8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Let us add to the string symbol \u003cspan class\u003d\"tex-span\"\u003e\u0027\u003ci\u003et\u003c/i\u003e\u0027\u003c/span\u003e. It will be \u003cem\u003eapproximately\u003c/em\u003e like this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ev \u003d last\nv \u003d smartlink[v][t]\nnew \u003d to[v][t]\nv \u003d smartlink[v][t]\nsuflink[new] \u003d to[v][t]\nsmartlink[new] \u003d smartlink[ suflink[new] ]\nsmartlink[new][p] \u003d suflink[new]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow we can solve the problem in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/42/62/42620ef6ade4e4693ed3ee6f89228e8b22139218.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time and memory. Let\u0027s improve the result to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ae/bd/aebd797c93b476cfb342b1b4cea39f2c560e081c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. For this we need \u003cem\u003epersistent array\u003c/em\u003e. It can be constructed on the segment tree. So, we create a persistent segment tree with \u003cspan class\u003d\"tex-span\"\u003eΣ\u003c/span\u003e elements. Next, let\u0027s create a new vertex. We can fork in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9c/b2/9cb246fcbc5e8b946b223cca254b609b03643bd6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e desired root of the tree, and in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8a/2a/8a2a400811f57a22345346c3d5f547728fe3c737.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e make a corresponding change. Here our quick structure is ready.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eChallenge 2:\u003c/strong\u003e Do you see other ways to solve this problem? For example, saving amortized evaluation with removal or other ways to solve the problem in less than \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d4/fe/d4fe006d0692f7bd635e9d95227ef345133bf758.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e?\u003c/p\u003e\u003cp\u003eFor dessert, I want to offer you a work-out in the use of this structure and try to solve two problems. The first of them \u0026amp; mdash; is the same problem that was offered this summer at Petrozavodsk training camp, but with more serious constraints. By the way, only one team solved it. IMCS of Siberian FU Bizons with some terrible bitmask magic compressed in memory suffix automaton and passed it on the first try for three minutes before the end of the contest. Kudos to them and respect :). The second task is already quite old. It was presented for the first time at the winter training camp 2006, where the author\u0027s solution reduced the problem to LCA on prefix-function automaton. However...\u003c/p\u003e\u003cp\u003eWe offer you to solve it in a slightly different interpretation, in which the author\u0027s solution, apparently, is not going to work. Imagine that you are given the first line is the line that should go to the second, and the second given is generator. You need to calculate the answer to each of its prefix. Dare :)\u003c/p\u003e\u003cp\u003eSo, the problems:\u003cbr /\u003e \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1960\"\u003etimus. Palindromes and Super Abilities\u003c/a\u003e\u003cbr /\u003e \u003ca href\u003d\"http://www.e-olimp.com/problems/2468\"\u003ee-olimp. Palindromic factory\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["palindromes","palindromic tree","suffix structures","automatons","subpalindromes"]}}