{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1477759562,"rating":-14,"authorHandle":"ebanner","modificationTimeSeconds":1477765779,"id":48079,"title":"\u003cp\u003eProblem 466C\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eAn explanation for my solution to \u003ca href\u003d\"/contest/466/problem/C\" title\u003d\"Codeforces Round 266 (Div. 2)\"\u003e466C - Количество способов\u003c/a\u003e. Credit goes to \u003ca href\u003d\"https://codinghangover.wordpress.com/2015/03/08/codeforces-266-div-2-number-of-ways/\"\u003eCoding Hangover\u003c/a\u003e for the algorithm. This post will detail the approach outlined there, explained with an example.\u003c/p\u003e\u003ch4\u003eProblem Statement\u003c/h4\u003e\u003cp\u003eGiven an array \u003ccode\u003earr\u003c/code\u003e, compute the number of ways we can partition \u003ccode\u003earr\u003c/code\u003e into three chunks such that the elements in each chunk sum to the same number. For example, the answer for \u003ccode\u003earr \u003d [1 2 3 0 3]\u003c/code\u003e is \u003ccode\u003e2\u003c/code\u003e because we can have the following splits:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ccode\u003e[1 2]\u003c/code\u003e \u003ccode\u003e[3]\u003c/code\u003e \u003ccode\u003e[0 3]\u003c/code\u003e\u003c/li\u003e   \u003cli\u003e\u003ccode\u003e[1 2]\u003c/code\u003e \u003ccode\u003e[3 0]\u003c/code\u003e \u003ccode\u003e[3]\u003c/code\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eWe will use \u003ccode\u003earr\u003c/code\u003e as our running example throughout.\u003c/p\u003e\u003ch4\u003eNaive Approach\u003c/h4\u003e\u003cp\u003eFirst, define \u003ccode\u003eS \u003d sum(arr)\u003c/code\u003e. Verify \u003ccode\u003eS % 3 \u003d\u003d 0\u003c/code\u003e. If this is false, then it is impossible to partition \u003ccode\u003earr\u003c/code\u003e into three equally sized chunks and the answer is \u003ccode\u003e0\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eElse, we continue. Pre-compute array \u003ccode\u003eA\u003c/code\u003e which is a running sum of \u003ccode\u003earr\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eA \u003d [1 3 6 6 9]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIterate \u003ccode\u003ei \u003d 0...n-2\u003c/code\u003e through \u003ccode\u003eA\u003c/code\u003e until we hit \u003ccode\u003eA[i] \u003d\u003d S/3\u003c/code\u003e. At this point, we have a potential first chunk. We then iterate \u003ccode\u003ej \u003d i+1...n-1\u003c/code\u003e through \u003ccode\u003eA[i+1:]\u003c/code\u003e until we hit \u003ccode\u003eA[j] \u003d\u003d (2/3)S\u003c/code\u003e. This corresponds to a potential middle chunk whose sum is \u003ccode\u003eS/3\u003c/code\u003e. Note that as long as \u003ccode\u003ej \u0026lt; n-1\u003c/code\u003e, it is guaranteed that \u003ccode\u003esum(arr[j+1:]) \u003d S/3\u003c/code\u003e because we verified that \u003ccode\u003esum(arr) % 3 \u003d\u003d 0\u003c/code\u003e up front. Hence this is a valid partitioning of \u003ccode\u003earr\u003c/code\u003e. Repeat this process for each potential first and second chunks.\u003c/p\u003e\u003cp\u003eUnfortunately the runtime for this approach is \u003ccode\u003eO(n^2)\u003c/code\u003e given the doubly-nested for-loop. Given that \u003ccode\u003en \u003d 5*10^5\u003c/code\u003e in the worst case, in the worst case we will perform \u003ccode\u003e(5*10^5)^2 \u003d 25*10^10\u003c/code\u003e operations, which will take approximately 250 seconds. Clearly this is too long. Given the maximum value of \u003ccode\u003en\u003c/code\u003e, we need to cut down the runtime to \u003ccode\u003eO(n*logn)\u003c/code\u003e at worst.\u003c/p\u003e\u003ch4\u003eA Better Algorithm\u003c/h4\u003e\u003cp\u003eIt may be surprising that there is actually a \u003ccode\u003eO(n)\u003c/code\u003e solution. The intuition is that we will still iterate \u003ccode\u003ei \u003d 0...n-2\u003c/code\u003e through \u003ccode\u003eA\u003c/code\u003e identifying potential first chunks. But instead of having to iterate linearly through \u003ccode\u003eA[i+1:]\u003c/code\u003e to compute the number of ways \u003ccode\u003eA[i+1:]\u003c/code\u003e can be split up into \u003ccode\u003e2\u003c/code\u003e chunks each having \u003ccode\u003eS/3\u003c/code\u003e elements, we will pre-compute another array which will allow us to compute this value in constant time.\u003c/p\u003e\u003cp\u003eTo this end, we pre-compute an array \u003ccode\u003eis_suffix\u003c/code\u003e where \u003ccode\u003eis_suffix[i] \u003d 1\u003c/code\u003e if \u003ccode\u003esum([i:]) \u003d\u003d S/3\u003c/code\u003e and \u003ccode\u003e0\u003c/code\u003e otherwise:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eis_suffix \u003d [0 0 0 1 1]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen we compute another array \u003ccode\u003enb_suffix\u003c/code\u003e where \u003ccode\u003enb_suffix[i] \u003d sum(is_suffix[i:])\u003c/code\u003e. In words, \u003ccode\u003enb_suffix[i]\u003c/code\u003e is the number of suffixes contained in \u003ccode\u003earr[i:]\u003c/code\u003e that sum to \u003ccode\u003eS/3\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003enb_suffix \u003d [2 2 2 2 1]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow we have everything we need. We iterate \u003ccode\u003ei \u003d 0...n-2\u003c/code\u003e through \u003ccode\u003eA\u003c/code\u003e until we hit a potential first chunk. Then the number of ways to split up \u003ccode\u003earr[i+1:]\u003c/code\u003e into \u003ccode\u003e2\u003c/code\u003e chunks whose elements each sum to \u003ccode\u003eS/3\u003c/code\u003e is simply \u003ccode\u003enb_suffix[i+2]\u003c/code\u003e. Why \u003ccode\u003ei+2\u003c/code\u003e? Because we need a first, second, and third chunk. \u003ccode\u003enb_suffix[i+2]\u003c/code\u003e gives us the number of valid last chunks. For each of these last chunks (say it starts at index \u003ccode\u003ek\u003c/code\u003e), the corresponding middle chunk (which starts at \u003ccode\u003ej \u003d i+1\u003c/code\u003e and ends at \u003ccode\u003ej \u003d k-1\u003c/code\u003e) is guaranteed to sum to \u003ccode\u003eS/3\u003c/code\u003e because the first and last chunks sum to \u003ccode\u003e(2/3)*S\u003c/code\u003e and we verified up front that \u003ccode\u003eS % 3 \u003d\u003d 0\u003c/code\u003e.\u003c/p\u003e\u003c/div\u003e","tags":[]}}