{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1502674636,"rating":21,"authorHandle":"ivan100sic","modificationTimeSeconds":1502681542,"id":53837,"title":"\u003cp\u003eInteresting implementation of Persistent Sets\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cem\u003eDo you really hate tree rotations? This blog post is for you!\u003c/em\u003e\u003c/p\u003e\u003cp\u003eRecently, I\u0027ve been solving \u003ca href\u003d\"/contest/768/problem/G\"\u003e768G - The Winds of Winter\u003c/a\u003e and I came up with a solution which is so ridiculously overengineered that I think it deserves its own blog post!\u003c/p\u003e\u003cp\u003eI don\u0027t want to go over all the details of the solution. Instead, I want to demonstrate a nice way to implement and apply Persistent Set and Persistent Array data structures and share a few ideas some may find interesting.\u003c/p\u003e\u003cp\u003eBasically, what I wanted to do is compute for each node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e of the rooted tree a set, which would contain the sizes of all subtrees of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. In other words, if we denote \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esz\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e — the size of the subtree rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, I want to compute the set \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c4/ec/c4ecdc0279bd58449517aa1ab21878dbc96073ef.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. We also want this set to have some \u003ccode\u003elower_bound\u003c/code\u003e and \u003ccode\u003eupper_bound\u003c/code\u003e functionality.\u003c/p\u003e\u003cp\u003eObviously, just storing these sets in a normal way would require \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e memory, so we need another approach. Let\u0027s use the same idea that we use when building persistent arrays. A persistent array of size \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e, \u003ci\u003ek\u003c/i\u003e \u0026gt; 0\u003c/span\u003e will just have two pointers to persistent arrays of size \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e. A persistent array of size \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e will only store data. Our persistent set will be implemented as a persistent array of size at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e whose only elements are \u003cspan class\u003d\"tex-span\"\u003e0, 1\u003c/span\u003e. Positions at which there is an element shall have value \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, others shall have \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. In addition to the two pointers, each array node will also store the sum of all values. Basically our structure looks a lot like a persistent segment tree. This will allow us to implement \u003ccode\u003elower_bound\u003c/code\u003e and \u003ccode\u003eupper_bound\u003c/code\u003e in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. I used class templates to save some memory — this is another interesting idea and a topic on its own.\u003c/p\u003e\u003cp\u003eWhen you want to insert a number into the set, you don\u0027t actually insert it \u003cem\u003einto\u003c/em\u003e the set, instead, you create a copy of the set and insert it there. The copying will create \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e additional nodes and will take \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time. Here\u0027s the code:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ethis_t* insert(int x) {\n  this_t* tmp \u003d new this_t(*this);\n\n  if (x \u0026lt; H)\n    tmp-\u0026gt;left \u003d tmp-\u0026gt;left-\u0026gt;insert(x);\n  else\n    tmp-\u0026gt;right \u003d tmp-\u0026gt;right-\u0026gt;insert(x - H);\n\n  tmp-\u0026gt;total \u003d tmp-\u0026gt;left-\u0026gt;total + tmp-\u0026gt;right-\u0026gt;total;\n  return tmp;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003ethis_t\u003c/code\u003e is the alias for \u003ccode\u003epa\u0026lt;T, order\u0026gt;\u003c/code\u003e, the data type of the class for persistent sets. This is basically a persistent array of length \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eorder\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. The first line just creates a shallow copy of the set the we are in. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eH\u003c/i\u003e\u003c/span\u003e is equal to half of the size of the current set. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is less than this number, it means that this new value should be inserted into the left half. Otherwise, insert it into the right half. Again, insertion does not change the original but returns a copy, so we store that copy into \u003ccode\u003etmp-\u0026gt;left\u003c/code\u003e or \u003ccode\u003etmp-\u0026gt;right\u003c/code\u003e. We then recompute the total and return the temporary variable. Simple as that! The stopping condition is implemented in the class \u003ccode\u003epa\u0026lt;T, 0\u0026gt;\u003c/code\u003e, see my submission \u003ca href\u003d\"/contest/768/submission/29446581\" title\u003d\"Submission 29446581 by ivan100sic\"\u003e29446581\u003c/a\u003e for more details.\u003c/p\u003e\u003cp\u003eBut this is not all! We also need to be able to quickly merge two sets in our original problem! This appears impossible to do efficiently at first, but is actually quite simple and works very fast under some circumstances.\u003c/p\u003e\u003cp\u003eLet\u0027s see how we can merge (find the union of) two sets \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e. If one of the sets is empty, we return the other one. Otherwise, just merge the left half of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e with the left half of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and the right half of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e with the right half of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e. Now you\u0027re probably asking yourself, how does this even make sense? This is obviously \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e — and you\u0027re right, but, in the original problem, you will be merging small sets most of the time, and when one of the sets you merge is small (let\u0027s say it has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003c/span\u003e elements), this operation will create at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ae/bb/aebbe54910e6f579cdef2d4c07e0fda764bebc91.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e new nodes and take \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b0/cb/b0cb62375ef856ef1ae4b75cd86b67d199046ff4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time. To understand this, think of what happens when one of the sets has 1, 2, or 3 elements.\u003c/p\u003e\u003cp\u003eHere\u0027s the code:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ethis_t* merge(this_t* arr) {\n  if (arr-\u0026gt;total \u003d\u003d 0)\n    return this;\n\n  if (this-\u0026gt;total \u003d\u003d 0)\n    return arr;\n\n  this_t* tmp \u003d new this_t(*this);\n  tmp-\u0026gt;left \u003d tmp-\u0026gt;left-\u0026gt;merge(arr-\u0026gt;left);\n  tmp-\u0026gt;right \u003d tmp-\u0026gt;right-\u0026gt;merge(arr-\u0026gt;right);\n\n  return tmp;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen we calculate the sets on a tree, each set element will be merged into another set at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e times so the complexity (both time and memory) is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ca/4c/ca4c38da7d143fc87534d50aa6d551dd861caae9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. You now have access to all the sets, for each node.\u003c/p\u003e\u003cp\u003eLast, but not least, let\u0027s see how \u003ccode\u003elower_bound\u003c/code\u003e is computed. This, of course, does not create new nodes and should take \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time. We define \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elower\u003c/i\u003e_\u003ci\u003ebound\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e as the smallest element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e in the set such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e ≥ \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. If such an element does not exist, we return the capacity of the set. Here\u0027s one possible implementation:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint lower_bound(int x) {\n  if (total \u003d\u003d 0)\n    return 2*H;\n\n  if (x \u0026lt; H) {\n    int p \u003d left-\u0026gt;lower_bound(x);\n    if (p \u003d\u003d H) {\n      return H + right-\u0026gt;lower_bound(0);\n    else\n      return p;\n  } else\n    return H + right-\u0026gt;lower_bound(x - H);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe problem here is that we sometimes call \u003ccode\u003elower_bound\u003c/code\u003e in both directions. Fortunately, it is not so tragic, the actual complexity here really is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Why is that so? If the lower bound \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e does not exist, let\u0027s take \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e \u003d \u003ci\u003eN\u003c/i\u003e - 1\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e is the capacity of the set. We\u0027ll only visit array vertices which correspond to array segments which contain \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e and there\u0027s at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cc/bf/ccbfc1d8eab00d0c720ab11a20b5bc7416b0e95a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e of them. We may also visit some others but we will exit immediately as their total is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThis concludes the tutorial for this implementation of persistent sets.\u003c/p\u003e\u003cp\u003e\u003cem\u003eBut why didn\u0027t you just use a segment tree for the problem? After all, you are given a rooted tree, you can flatten it by assigning DFS numbers...\u003c/em\u003e\u003c/p\u003e\u003cp\u003eAs it turns out, the sets of sizes of subtrees of nodes are not the only thing I needed to compute. I also needed to compute \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3e/58/3e589edcfae412f332f430d1954f98c366c8cfa5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, and also \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/39/df/39df73ac2ae2d184b7296d505d266ce438862f31.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Also, I wanted to try a new approach and see if it\u0027s efficient enough. And as it turns out, it is! :)\u003c/p\u003e\u003cp\u003eHere\u0027s the code: \u003ca href\u003d\"/contest/768/submission/29446581\" title\u003d\"Submission 29446581 by ivan100sic\"\u003e29446581\u003c/a\u003e. Unfortunately, many comments are in Serbian and some names are meaningless.\u003c/p\u003e\u003cp\u003eRemark 1. It\u0027s also relatively easy to implement the order statistic query (find the kth largest element in the set).\u003c/p\u003e\u003cp\u003eRemark 2. You can also extend this to a multiset or a \u003ccode\u003emap\u0026lt;int, ?\u0026gt;\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eRemark 3. You can save even more memory by delaying the creation of a subarray until it is needed, similar to the implicit segment tree. This allows us to create sets which can contain the full range of integers or even long longs, not just ones in a relatively small range, like \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eRemark 4. You can accelerate finding the union or intersection of sets if you also store a hash value of each subarray. Then, only merge two sets if their hashes differ. This works particularly well if you often need to merge similar sets (those which differ in only a few elements). In the original problem this was not needed but it\u0027s a nice idea nonetheless.\u003c/p\u003e\u003c/div\u003e","tags":["data structures","implementation","persistent structures"]}}