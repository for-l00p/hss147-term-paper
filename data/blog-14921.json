{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1417189857,"rating":37,"authorHandle":"HandIeNeeded","modificationTimeSeconds":1417190388,"id":14921,"title":"\u003cp\u003eSingle Round Match 639 500 Problem\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eIn the last two hours I have been went through a quite exciting SRM. I didn\u0027t solve any problems during the macth. (In fact, I didn\u0027t open 250 at all. But it seems to be a nice choice, isn\u0027t it? :D) All my time went to 500 problem. I found it quite interesting. And I spend a lot of time coming up with an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e solution. And I\u0027d like to share with you guys.\u003c/p\u003e\u003cp\u003eHere we go! At first, it didn\u0027t take me too long to figure out that the order of folding by row or by column doesn\u0027t matter. (I hope you agree with me too.) If you can at first fold some rows then fold some columns to get one scheme, you can do it by folding some columns at first then some rows. So the order doesn\u0027t matter. So it leads us to focus on the position of the last scheme. As we all know, an valid scheme can be uniquely determined by the up-left corner and down-right corner. So I was wondering which units can be the up-left corner and down-right corner of the answer.\u003c/p\u003e\u003cp\u003eLeave all things behind, if we know which units can be the up-left corner and down-right corner of the answer, we can calculate the answer now. For each unit which can be the up-left corner of out last scheme, we just need to sum the count of the units which can be our down-right units for this up-left unit. It can be easily calculated in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e dp right? (You want to know how many ones in a sub-rectangle, Let\u0027s dp!). So in the end, all comes to determining which units can the our up-left corner and down-right corner of the answer.\u003c/p\u003e\u003cp\u003eWe know that up-left corner and down-right corner are similar. So We just need to determine which units can be up-left corner. It turns out we need to know can all rows above row[i] can be folded down to the row[i] and all columns on the left of col[i] can be fold down to the right col[i].(That was similar problem too!) And we can see there will be many comparisons of whole rows and columns. So I\u0027d like to hash the whole row into one number.And all we need to do is find out:\u003c/p\u003e\u003cp\u003eGiven a sequence \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, which numbers in this sequence be the leftmost one element after the fold.\u003c/p\u003e\u003cp\u003e(I spend a lot of time figuring out this one!), here\u0027s my way. Using one bool array to save this result. We know can[1] \u003d 1, and when we go from left to right, we know if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e can be the leftmost one, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e must be folded into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, and there maybe some other numbers be folder to the right of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, or there\u0027s only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e be folded into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. For the latter one, we know can[i-1] must be 1, (Other number should be folded to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e first.) For the former one, we just need check \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 2\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e, and same thing happens to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 2\u003c/sub\u003e\u003c/span\u003e, if can[i-2] \u003d 1, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 2\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e, we can fold all left numbers into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 2\u003c/sub\u003e\u003c/span\u003e and fold two numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 2\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e, so we may need check every number on the left of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, which takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e time. And we got what we want!\u003c/p\u003e\u003cp\u003eSo, to sum it up, we obtain a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e solution. That\u0027s what I want to share with you guys. (Maybe the hash is the key-point to cut the time down to the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e). However, I think it was a good solution. Any ideas and suggestions are welcome. :D\u003c/p\u003e\u003cp\u003eOh, here\u0027s my \u003ca href\u003d\"https://github.com/yuzhou627/ACM/blob/master/SRM/BoardFolding.cpp\"\u003ecode\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e","tags":["topcoder","srm"]}}