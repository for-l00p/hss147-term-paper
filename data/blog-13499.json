{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1408759133,"rating":5,"authorHandle":"EZ_lzh","modificationTimeSeconds":1408759662,"id":13499,"title":"\u003cp\u003eMy solution to 455E\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eIt\u0027s known that\u003c/p\u003e\u003cp\u003ef(1, j) \u003d a[j], 1 ≤ j ≤ n.\u003c/p\u003e\u003cp\u003ef(i, j) \u003d min(f(i - 1, j), f(i - 1, j - 1)) + a[j], 2 ≤ i ≤ n, i ≤ j ≤ n.\u003c/p\u003e\u003cp\u003eThe problem is to calculate f(xi,yi).\u003c/p\u003e\u003cp\u003eObviously, the final route of [xi,yi] would be like:\u003c/p\u003e\u003cp\u003e|\u003c/p\u003e\u003cp\u003e|\u003c/p\u003e\u003cp\u003e|\u003c/p\u003e\u003cp\u003e|\u003c/p\u003e\u003cp\u003e\\\u003c/p\u003e\u003cp\u003e\\\u003c/p\u003e \u003cpre\u003e\\\n\n   \\\n\n     \\\u003c/pre\u003e\u003cp\u003eSo f(xi,yi) \u003d min( a[j] * (xi — yi + j) + sum(yi) — sum(j)), yi — xi \u0026lt; j \u0026lt;\u003d yi.\u003c/p\u003e\u003cp\u003esum(i) represents Σa[k], 1 \u0026lt;\u003d k \u0026lt;\u003d i.\u003c/p\u003e\u003cp\u003eFor a query (xi, yi):\u003c/p\u003e\u003cp\u003eMarks that g[j] \u003d a[j] * (xi — yi + j) + sum(yi) — sum(j), yi — xi \u0026lt; j \u0026lt;\u003d yi.\u003c/p\u003e\u003cp\u003eA is better than B (a[A] \u0026lt; a[B]) if and only if g[A] \u0026lt; g[B], which equals\u003c/p\u003e\u003cp\u003e(a[A] * A — sum[A]) — (a[B] * B — sum[B])\u003c/p\u003e\u003cp\u003e------------------------------------------- \u0026gt; yi — xi\u003c/p\u003e \u003cpre\u003ea[A] - a[B]\u003c/pre\u003e\u003cp\u003eIf a lower convex hull between (yi — xi + 1) and yi is built, the problem will be solved by method of bisection.\u003c/p\u003e\u003cp\u003eFor there are many queries, I used a segment tree to store the convex hull.\u003c/p\u003e\u003cp\u003eTo build the convex hull, a balance tree can be used but not necessary. I sorted array a by merge sort, and built the convex hull using a stack.\u003c/p\u003e\u003cp\u003eSolving all queries online, The time complexity is O(nlgn + mlg^2n). It can be decline to O(nlgn + m) if produced offline.\u003c/p\u003e\u003c/div\u003e","tags":["segment tree","convex hull","merge sort"]}}