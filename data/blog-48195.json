{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1478186945,"rating":0,"authorHandle":"BigBag","modificationTimeSeconds":1478283195,"id":48195,"title":"\u003cp\u003eГрафы. Окончание.\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003e1)\u003c/strong\u003e DSU (disjoint-set union), СНМ (система непересекающихся множеств).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDSU\u003c/strong\u003e — это структура данных, которая позволяет выполнять следующие операции : \u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ccode\u003efind_set(v)\u003c/code\u003e \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e узнать в каком множестве находится вершина \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e;\u003c/li\u003e   \u003cli\u003e\u003ccode\u003eunion_sets(v1, v2)\u003c/code\u003e \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e объединить два множества, в которых находятся вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e1\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e2\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eБудем хранить множества в виде деревьев: одно дерево соответствует одному множеству. Корень дерева — это номер множества. Для реализации заведем массив \u003ccode\u003eparent\u003c/code\u003e, в котором для каждого элемента будем хранить номер его предка. Для корней деревьев будем считать, что их предок — они сами. Изначально, для всех \u003ccode\u003ei\u003c/code\u003e, \u003ccode\u003eparent[i] \u003d i;\u003c/code\u003e\u003c/p\u003e\u003cp\u003eУже можно написать наивную реализацию : \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint find_set(int v) {\n    if (v \u003d\u003d parent[v]) {\n        return v;\n    }\n    return find_set(parent[v]);\n}\n\nvoid union_sets(int v1, int v2) {\n    v1 \u003d find_set(v1);\n    v2 \u003d find_set(v2);\n    parent[v1] \u003d v2;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗаметим, что обе функции в худшем случае будут работать за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e. Приведем две эвристики, которые по отдельности ускоряют работу функций до \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c8/66/c866e70b5875095de99ad700f943dbe7ed528b12.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, а объединенные вместе дают сложность \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e1) Эвристика \u003cstrong\u003eсжатия пути\u003c/strong\u003e :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint find_set(int v) {\n    if (v \u003d\u003d parent[v]) {\n        return v;\n    }\n    return parent[v] \u003d find_set(parent[v]);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТеперь, \u003ccode\u003eparent[v]\u003c/code\u003e это не обязательно непосредственный предок вершины \u003ccode\u003ev\u003c/code\u003e, а просто какая-то вершина, находящаяся выше.\u003c/p\u003e\u003cp\u003e2) Эвристика \u003cstrong\u003eобъединения по рангу\u003c/strong\u003e : \u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid union_sets(int v1, int v2) {\n    v1 \u003d find_set(v1);\n    v2 \u003d find_set(v2);\n    if (sz[v1] \u0026gt; sz[v2]) {\n        swap(v1, v2);\n    }\n    parent[v1] \u003d v2;\n    sz[v2] +\u003d sz[v1];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗаведем вспомогательный массив \u003ccode\u003esz\u003c/code\u003e, где \u003ccode\u003esz[i]\u003c/code\u003e \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e рамер \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-го множества. Теперь, в объединении, будем подсоединять меньшее множество к большему.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадачи\u003c/strong\u003e : \u003ca href\u003d\"http://informatics.mccme.ru/mod/statements/view3.php?id\u003d1089\u0026amp;chapterid\u003d1376\"\u003eВес компоненты\u003c/a\u003e, \u003ca href\u003d\"http://informatics.mccme.ru/mod/statements/view3.php?id\u003d1089\u0026amp;chapterid\u003d2786\"\u003eРазрезание графа\u003c/a\u003e, \u003ca href\u003d\"//codeforces.com/problemset/problem/60/D\"\u003eСпаситель\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2)\u003c/strong\u003e Построение минимального остовного дерева.\u003c/p\u003e\u003cp\u003e2.1) Алгоритм \u003cstrong\u003eКрускала\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eОтсортируем ребра в порядке увеличения веса. Будем постепенно строить минимальные остов. Просматравая очередное ребро \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e-\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, проверим, лежат ли эти вершины в одной компоненте связности. Если нет, то добавим текущее ребро к ответу. Чтобы быстро выполнять эти операции, воспользуемся структурой данных \u003cstrong\u003edsu\u003c/strong\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epair\u0026lt;int, pair\u0026lt;int, int\u0026gt; \u0026gt; e[max_m];//изначальный граф, заданный списком ребер.\nvector\u0026lt;pair\u0026lt;int, pair\u0026lt;int, int\u0026gt; \u0026gt; \u0026gt; ans;\nsort(e, e + m);\nfor (int i \u003d 0; i \u0026lt; m; ++i) {\n    int a \u003d e[i].second.first, b \u003d e[i].second.second;\n    if (find_set(a) !\u003d find_set(b)) {\n        union_set(a, b);\n        ans.push_back(e[i]);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eИтоговая асимптотика \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d1/7d/d17d6c4f9d9e6f84e392b3c1f6286607956a4147.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003e2.2) Алгоритм \u003cstrong\u003eПрима\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eТакже, как и в алгоритме Крускала, строить минимальное остовное дерево будем постепенно. Разделим вершины на два множества. В первом будут вершины, уже добавленные в мин. ост., а во втором \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e все остальные. Изначально добавим в первое множество произвольную вершину. Теперь сделаем \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e - 1)\u003c/span\u003e итерацию алгоритма. На каждой итерации будем делать следующее. Найдем ребро минимального веса \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e-\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e такое, что вершина \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e лежит в первом множестве, а вершина \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e — во втором. Добавим это ребро к ответу, и переместим вершину \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e в первое множество.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint dist[max_n][max_n];//исходный граф, заданный матрицей смежности\nint num[max_n], mn_dist[max_n];\nfor (int i \u003d 1; i \u0026lt;\u003d n; ++i) {\n    mn_dist[i] \u003d dist[1][i];\n    num[i] \u003d 2;\n}\nnum[1] \u003d 1;\nfor (int i \u003d 1; i \u0026lt; n; ++i) {\n    int v \u003d -1;\n    for (int j \u003d 1; j \u0026lt;\u003d n; ++j) {\n        if (num[j] \u003d\u003d 2 \u0026amp;\u0026amp; (v \u003d\u003d -1 || mn_dist[v] \u0026gt; mn_dist[j])) {\n            v \u003d j;\n        }\n    }\n    num[v] \u003d 1;\n    for (int j \u003d 1; j \u0026lt;\u003d n; ++j) {\n        mn_dist[j] \u003d min(mn_dist[j], dist[v][j]);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eИтоговая асимптотика \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадачи\u003c/strong\u003e : \u003ca href\u003d\"//codeforces.com/contest/436/problem/C\"\u003eDungeons and Candies\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e3)\u003c/strong\u003e Метод двоичного подъема.\u003c/p\u003e\u003cp\u003eЭтод метод является аналогом бинарного поиска на деревьях. Заведем массив \u003ccode\u003ep[max_lev][max_n]\u003c/code\u003e, где \u003ccode\u003ep[i][v]\u003c/code\u003e \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e предок вершины \u003ccode\u003ev\u003c/code\u003e на глубине \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. \u003ccode\u003ep[0][v]\u003c/code\u003e можно посчитать с помощью одного запуска dfs. Для \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026gt; 1\u003c/span\u003e \u003ccode\u003ep[i][v] \u003d p[i - 1][p[i - 1][v]]\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eНахождение LCA с помошью метода двоичного подьема. В предыдущей теме рассказывалось как можно за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e проверить, является ли одна вершина предком другой. Пусть нужно найти LCA вершин \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e1\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e2\u003c/span\u003e. Заметим, что если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e1\u003c/span\u003e является предком \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e2\u003c/span\u003e, или наоборот, то можно сразу вернуть результат. Иначе с помощью бинарного поиска на дереве, найдем самую удаленную вершину \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e3\u003c/span\u003e от вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e1\u003c/span\u003e такую, что \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e3\u003c/span\u003e не является предком \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e2\u003c/span\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint lca(int v1, int v2) {\n    if (is_ancestor(v1, v2)) {\n        return v1;\n    }\n    if (is_ancestor(v2, v1)) {\n        return v2;\n    }\n    for (int i \u003d max_lev - 1; i \u0026gt;\u003d 0; --i) {\n        if (!is_ancestor(p[i][v1], v2)) {\n            v1 \u003d p[i][v1];\n        }\n    }\n    return p[0][v1];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТ.е. если выписать в ряд все веришины от корня до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e1\u003c/span\u003e, то этот алгоритм как-раз является бин. поиском по этому массиву.\u003c/p\u003e\u003cp\u003eНахождение LCA с помощью RMQ. Можно почитать \u003ca href\u003d\"http://e-maxx.ru/algo/lca\"\u003eздесь\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадачи\u003c/strong\u003e : \u003ca href\u003d\"//codeforces.com/contest/702/problem/E\"\u003eАнализ путей\u003c/a\u003e, \u003ca href\u003d\"//codeforces.com/group/JrUBa4QK0n/contest/100091\"\u003eТренировка 4\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e4)\u003c/strong\u003e \u003ca href\u003d\"http://e-maxx.ru/algo/2_sat\"\u003e2-SAT\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадачи\u003c/strong\u003e : \u003ca href\u003d\"//codeforces.com/contest/587/problem/D\"\u003eDuff в мафии\u003c/a\u003e, \u003ca href\u003d\"//codeforces.com/problemset/problem/568/C\"\u003eНовый язык\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e","tags":[]}}