{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1407858374,"rating":-17,"authorHandle":"selfcompiler","modificationTimeSeconds":1407858544,"id":13377,"title":"\u003cp\u003e2D BIT problem \u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI am trying to solve the problem \u003ca href\u003d\"http://www.spoj.com/problems/MATSUM/\"\u003eMATSUM\u003c/a\u003e on spoj.I try it using 2D Binary Indexed Tree.But keep getting Time Limit Exceeded.If my approach to solve this problem is not good enough then please suggest another methods.If my approach is correct then please guide me how to get rid-off from TLE. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMy code is below\u003c/strong\u003e \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eYour code here...\n#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstdio\u0026gt;\n#include\u0026lt;vector\u0026gt;\n#include\u0026lt;queue\u0026gt;\n#include\u0026lt;stack\u0026gt;\n#include\u0026lt;utility\u0026gt;\n#include\u0026lt;map\u0026gt;\n#include\u0026lt;stdlib.h\u0026gt;\n#include\u0026lt;string.h\u0026gt;\nusing namespace std;\n\n#define g getchar_unlocked()\n\nint scan()//fast input output\n{\n    int t\u003d0;\n    char c;\n    c\u003dg;\n    while(c\u0026lt;\u00270\u0027 || c\u0026gt;\u00279\u0027)\n    c\u003dg;\n    while(c\u0026gt;\u003d\u00270\u0027 \u0026amp;\u0026amp; c\u0026lt;\u003d\u00279\u0027)\n    {\n    t\u003d(t\u0026lt;\u0026lt;3)+(t\u0026lt;\u0026lt;1)+c-\u00270\u0027;\n    c\u003dg;\n    }//end fast input output\n    return(t);\n}\n\nvector\u0026lt;int\u0026gt; Matrix[1026];\nint N;  // MAXVAL for Binary indexed tree tree(1 based indexing)\nvoid initialize()\n{\n     scanf(\u0026quot;%d\u0026quot;,\u0026amp;N);\n     for(int i\u003d0;i\u0026lt;N;i++)\n      Matrix[i].resize(N+2);\n     return ; \n}\nint Freq_at_idx(int idx,int vec_idx)\n{\n    int sum\u003dMatrix[vec_idx][idx];\n    if(idx\u0026gt;0)\n    {\n     int z\u003didx-(idx\u0026amp;-idx);\n     idx--;\n     while(idx!\u003dz)\n     {\n                  sum-\u003dMatrix[vec_idx][idx];\n                  idx-\u003d(idx\u0026amp;-idx);\n     }\n             \n    }\n    return sum;\n}\nvoid update(int vec_idx,int idx,int v)\n{\n     while(idx\u0026lt;\u003dN)\n     {\n                  Matrix[vec_idx][idx]+\u003dv;\n                  idx+\u003d(idx\u0026amp;-idx);\n     }\n     return ;\n}\n\n// it gives the sum of all the elements from 1 to idx of vector Matrix[vec_idx]\n\nint Cumilative_Freq(int vec_idx,int idx)\n{\n    int sum\u003d0;\n    while(idx\u0026gt;0)\n    {\n        sum+\u003dMatrix[vec_idx][idx];\n        idx-\u003d(idx\u0026amp;-idx);\n    }\n    return sum;\n}\nvoid set_value(int x,int y,int v)\n{\n     int v1;\n     v1\u003dFreq_at_idx(y+1,x);\n     v\u003dv-v1;\n     if(v\u003d\u003d0)\n      return ;\n     update(x,y+1,v);\n}\nvoid get_sum(int x1,int y1,int x2,int y2)\n{\n     int sum\u003d0;\n     for(int i\u003dx1;i\u0026lt;\u003dx2;i++)\n     {\n             sum+\u003dCumilative_Freq(i,y2+1)-Cumilative_Freq(i,y1);\n     }\n     printf(\u0026quot;%d\\n\u0026quot;,sum);\n     return ;\n}\nint main()\n{\n    int x,y,v,x1,x2,y1,y2;\n    char str[5];\n    int tc;\n    //scanf(\u0026quot;%d\u0026quot;,\u0026amp;tc);\n    tc\u003dscan();\n    while(tc--)\n    {\n    initialize();\n    scanf(\u0026quot;%s\u0026quot;,str);\n    while(str[0]!\u003d\u0027E\u0027)\n    {\n             if(str[1]\u003d\u003d\u0027E\u0027)\n               {\n                   //scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;x,\u0026amp;y,\u0026amp;v);\n                   x\u003dscan();\n                   y\u003dscan();\n                   v\u003dscan();\n                   set_value(x,y,v);\n               } \n              else\n              {\n                   //scanf(\u0026quot;%d%d%d%d\u0026quot;,\u0026amp;x1,\u0026amp;y1,\u0026amp;x2,\u0026amp;y2);\n                   x1\u003dscan();\n                   y1\u003dscan();\n                   x2\u003dscan();\n                   y2\u003dscan();\n                   get_sum(x1,y1,x2,y2);\n              }\n              scanf(\u0026quot;%s\u0026quot;,str);    \n     }\n     for(int i\u003d0;i\u0026lt;N;i++)\n      Matrix[i].clear();\n    }\n    return 0;\n}\n\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["binary indexed tree","spoj"]}}