{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1407859488,"rating":34,"authorHandle":"Enchom","modificationTimeSeconds":1407865132,"id":13378,"title":"\u003cp\u003eBalkan Olympiad in Informatics 2014 Problems — Day 1\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eSo Day 1 passed and the problems aren\u0027t online. As they were quite tough I decided to put them here and see the community\u0027s solutions. I don\u0027t have the english papers and I don\u0027t have much time to write so I will just describe them shortly and try to include the most useful information.\u003c/p\u003e\u003ch4\u003eProblem 1 — Diameter\u003c/h4\u003e\u003cp\u003eYou are given a weighted tree of N nodes and a number K. You must perform a K-partitioning. That is you must choose K non-empty, non-intersecting subsets of nodes that cover all nodes. Each subset is called a partition. A diameter of a partition is the longest distance between a pair of nodes in the partition. A partition doesn\u0027t have to be connected, so distance is defined as the distance in the initial tree. A diameter of \u003cstrong\u003epartitioning\u003c/strong\u003e is the longest diameter of all partitions. Your task is to find the minimum possible diameter of K-partitioning.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e1\u0026lt;\u003dN\u0026lt;\u003d260,000\u003c/p\u003e\u003cp\u003e1\u0026lt;\u003dK\u0026lt;\u003dN\u003c/p\u003e\u003cp\u003e1\u0026lt;\u003dweight of edges of tree\u0026lt;\u003d1,000\u003c/p\u003e\u003cp\u003eSubtask 1 (10 points) : K\u003d1\u003c/p\u003e\u003cp\u003eSubtask 2 (15 points) : K\u003d2\u003c/p\u003e\u003cp\u003eSubtask 3 (30 points) : N\u0026lt;\u003d110,000\u003c/p\u003e\u003cp\u003eSubtask 4 (45 points) : no additional constraints\u003c/p\u003e\u003cp\u003eTime Limit : 1s\u003c/p\u003e\u003cp\u003eMemory Limit : 256MB\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eExample\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eInput:\u003c/p\u003e\u003cp\u003e5 2\u003c/p\u003e\u003cp\u003e1 2 1\u003c/p\u003e\u003cp\u003e1 3 1\u003c/p\u003e\u003cp\u003e2 4 1\u003c/p\u003e\u003cp\u003e2 5 1\u003c/p\u003e\u003cp\u003eOutput:\u003c/p\u003e\u003cp\u003e2\u003c/p\u003e\u003cp\u003eInput format is : n,m then n-1 lines \u0026quot;a b c\u0026quot; denoting an edge from a to b with weight c.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMy solution\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eDuring the competition I couldn\u0027t find any polynomial-time complexity solution, so I simply solved the K\u003d1 subtask in which you obviously have to find the diameter of the original tree which is a trivial problem.\u003c/p\u003e\u003cp\u003eP.S. Binary search for the answer possibly?\u003c/p\u003e\u003ch4\u003eProblem 2 — Hittites\u003c/h4\u003e\u003cp\u003eYou are given N codes in the form of strings of lower-case latin letters. You need to calculate the amount of different strings of length K that have at least one of the given codes as a substring. Print the amount modulo 10^9+7.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSubtask 1 (13 points):\u003c/p\u003e\u003cp\u003e1\u0026lt;\u003dK\u0026lt;\u003d5\u003c/p\u003e\u003cp\u003e1\u0026lt;\u003dN\u0026lt;\u003d10\u003c/p\u003e\u003cp\u003eSubtask 2 (19 points):\u003c/p\u003e\u003cp\u003e1\u0026lt;\u003dK\u0026lt;\u003d5,000\u003c/p\u003e\u003cp\u003e1\u0026lt;\u003dN\u0026lt;\u003d26\u003c/p\u003e\u003cp\u003eLength of each code is exactly 1.\u003c/p\u003e\u003cp\u003eSubtask 3 (29 points):\u003c/p\u003e\u003cp\u003e1\u0026lt;\u003dK\u0026lt;\u003d5,000\u003c/p\u003e\u003cp\u003eN\u003d1\u003c/p\u003e\u003cp\u003eSum of lengths of the N codes is at most 2,000.\u003c/p\u003e\u003cp\u003eSubtask 4 (39 points):\u003c/p\u003e\u003cp\u003e1\u0026lt;\u003dK\u0026lt;\u003d5,000\u003c/p\u003e\u003cp\u003e1\u0026lt;\u003dN\u0026lt;\u003d2,000\u003c/p\u003e\u003cp\u003eSum of lengths of the N codes is at most 2,000.\u003c/p\u003e\u003cp\u003eTime Limit \u003d 3s\u003c/p\u003e\u003cp\u003eMemory Limit \u003d 256MB\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eExample\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eInput:\u003c/p\u003e\u003cp\u003e3 2\u003c/p\u003e\u003cp\u003eaa\u003c/p\u003e\u003cp\u003edbe\u003c/p\u003e\u003cp\u003eOutput:\u003c/p\u003e\u003cp\u003e52\u003c/p\u003e\u003cp\u003eInput format is : n, followed by n lines with one string on each — the codes.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMy solution\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eI managed to solve this problem for full points. Here is my solution. It goes as the \u003ca href\u003d\"http://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_string_matching_algorithm\"\u003eAho-Corrasick algorithm\u003c/a\u003e. We build a trie and calculate the failure function on each node. Then for each node and for each letter on it we calculate a \u0026quot;reach\u0026quot; function. That is, where we would end up if we are in this node and this letter is added. Then I mark all nodes that lead to a successful word, that is those nodes in which if we end up — then we had some word as a substring. Finally I do DP-like calculations on K iterations. On each iteration each node \u003cstrong\u003ethat isn\u0027t marked\u003c/strong\u003e for each letter adds its value to the node it reaches according to the \u0026quot;reach\u0026quot; function. In the beginning the root is 1 and all others are 0. Finally I sum the values of all nodes that aren\u0027t marked after the k-th iteration and this is the amount of words that \u003cstrong\u003edon\u0027t\u003c/strong\u003e have any of the listed words as their substring. The answer is then 26^k — (number of words that don\u0027t have listed words as their substring).\u003c/p\u003e\u003cp\u003eSolution complexity is : O(26*L*K), where L is the total length of all strings. This manages to pass under 3 seconds.\u003c/p\u003e\u003ch4\u003eProblem 3 — Princes\u003c/h4\u003e\u003cp\u003eThere are three princes A,B and C. The king has N diamonds and wants to distribute them among the princes. The i-th diamond has value of 2^(i-1), so the values of the diamonds are 2^0, 2^1, 2^2...2^(N-1).\u003c/p\u003e\u003cp\u003eIn the beginning princes don\u0027t have any diamonds and in N steps the king chooses a diamond and a prince and gives the diamond to the prince. Let Aj,Bj and Cj be the corresponding values to the total value of the diamonds the princes have after the j-th iteration. Since A is the eldest and C is the youngest, the inequality Aj\u0026gt;\u003dBj\u0026gt;\u003dCj for all 1\u0026lt;\u003dj\u0026lt;\u003dN must hold.\u003c/p\u003e\u003cp\u003eEach process of distributing in which the equality holds for all j is called \u0026quot;fair\u0026quot;. Denote number of a diamond by \u003cem\u003edj\u003c/em\u003e and the prince it\u0027s given to by \u003cem\u003epj\u003c/em\u003e. The process of distributing is coded by the vector \u0026quot;_p1d1 p2d2 ... pNdN_\u0026quot;. Find the K-th fair distribution if they are sorted lexicographically.\u003c/p\u003e\u003cp\u003eWhen comparing two distributions lexicographically their elements are compared from left to right. An element is a pair of a prince and a diamon. For each element first the princes are compared (A\u0026lt;B\u0026lt;C) and then the numbers (1\u0026lt;2\u0026lt;3..\u0026lt;N).\u003c/p\u003e\u003cp\u003eFor example the process \u0026quot;Give diamond 3 to A, give diamond 2 to B, give diamond 4 to A, give diamond 1 to C\u0026quot; is coded by \u0026quot;A3 B2 A4 C1\u0026quot;.\u003c/p\u003e\u003cp\u003eExample of comparing is that the vector \u0026quot;A3 A4 A1 B2\u0026quot; is smaller than \u0026quot;A3 B2 A4 C1\u0026quot;.\u003c/p\u003e\u003cp\u003eThe first vector of length 4 is \u0026quot;A1 A2 A3 A4\u0026quot;, the second is \u0026quot;A1 A2 A4 A3\u0026quot; and so on.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSubtask 1 (11 points)\u003c/p\u003e\u003cp\u003e1\u0026lt;\u003dN\u0026lt;\u003d20\u003c/p\u003e\u003cp\u003e1\u0026lt;\u003dK\u0026lt;\u003d10^18\u003c/p\u003e\u003cp\u003eSubtask 2 (17 points)\u003c/p\u003e\u003cp\u003e1\u0026lt;\u003dN\u0026lt;\u003d50\u003c/p\u003e\u003cp\u003e1\u0026lt;\u003dK\u0026lt;\u003d10^200\u003c/p\u003e\u003cp\u003eSubtask 3 (31 points)\u003c/p\u003e\u003cp\u003e1\u0026lt;\u003dN\u0026lt;\u003d100\u003c/p\u003e\u003cp\u003e1\u0026lt;\u003dK\u0026lt;\u003d10^19\u003c/p\u003e\u003cp\u003eSubtask 4 (41 points)\u003c/p\u003e\u003cp\u003e1\u0026lt;\u003dN\u0026lt;\u003d100\u003c/p\u003e\u003cp\u003e1\u0026lt;\u003dK\u0026lt;\u003d10^300\u003c/p\u003e\u003cp\u003eTime Limit \u003d 3s\u003c/p\u003e\u003cp\u003eMemory Limit \u003d 256MB\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eExample\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eInput : 3 1\u003c/p\u003e\u003cp\u003eOutput : A1 A2 A3\u003c/p\u003e\u003cp\u003eInput : 3 3\u003c/p\u003e\u003cp\u003eOutput : A1 A3 B2\u003c/p\u003e\u003cp\u003eInput : 4 9 Output : A1 A4 A2 B3\u003c/p\u003e\u003cp\u003eInput format : n,k\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e During the competition it turned out the tests were wrong. They were fixed and the competition was extended by 45 minutes. However I have reasons to believe the new tests may not be correct either. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMy solution\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eI implemented a DP and a simple approach I won\u0027t explain now due to lack of time, however I managed to get it to pass only for cases in which I could use unsigned long long, that is subtasks 1 and 3, therefore i got 42 points.\u003c/p\u003e\u003cp\u003eSo in total I got 152 points which is 6th place. I\u0027d love to hear some solutions about diameter as it is the only task whose solution I have no clue of.\u003c/p\u003e\u003c/div\u003e","tags":[]}}