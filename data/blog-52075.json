{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1495221846,"rating":8,"authorHandle":"TripleM5da","modificationTimeSeconds":1495227744,"id":52075,"title":"\u003cp\u003eMentors Weekly Contest #6 (7sbi allah fel emt7nat wel bt3mlo)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003ethese will be a group of small hints for the problems.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem A\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003elet\u0027s just say that you build the palindrome for both ways left and right and you knowing the last element you put in the palindrome and the current sum left your answer will always be the same after calculating it once.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem B\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003ethis was not an ACE i repeat this was not an ACE you just needed to run a BFS from Ahmad to the rest of his teammates and save the shortest distance from Ahmad to any of his teammates using a map if Ahmad didn\u0027t visit this teammate then he is undefined.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem C\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eOne of the Good ones in this contest first you build a binary trie inserting the xor sum of all prefixes from 1 to i then move on all suffixes and erase the current from n — 1 to 0 and at every i erase the suffix from 0 to i then search on the trie for the maximum value. \u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem D\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003ethis is a relatively know trick like there is a prefix max for the array there is a prefix — sub — grid max for the 2D array you just need to make 4 2D arrays where for all i from 1 to n and j from 1 to m.\u003c/p\u003e\u003cp\u003efirst grid element (i, j) holds maximum for all sub — grid from (0, 0) to (i, j) all element where their position is (x,y) and x \u0026lt;\u003d i \u0026amp;\u0026amp; y \u0026lt;\u003d j — upper left sub — grids.\u003c/p\u003e\u003cp\u003esecond grid holds the same but for the sub — grid from (i, j) to (0,m-1) upwards this time of course — upper right sub — grids.\u003c/p\u003e\u003cp\u003ethird grid (n-1,0) to (i, j) — lower left sub — grids.\u003c/p\u003e\u003cp\u003efourth grid (i, j) to (n-1, m-1) — lower right sub — grids.\u003c/p\u003e\u003cp\u003elet\u0027s explain how the top left works you have n arrays where the i — the element in each array holds the prefix max for that array at element i.\u003c/p\u003e\u003cp\u003eafter that you have a 2D grid where element (i, j) is the maximum of the prefix j — th maximums for all arrays from 1 to i. \u003c/p\u003e\u003cp\u003eso after that you need only try all (i, j) and find the max first grid (i-1,j-1), second grid (i-1, j + 1), third grid (i + 1, j-1) and forth grid (i + 1, j + 1)\u003c/p\u003e\u003cp\u003emy implementation for the first grid : \u003ca href\u003d\"http://ideone.com/LNaJ1e\"\u003ehttp://ideone.com/LNaJ1e\u003c/a\u003e\u003c/p\u003e\u003cp\u003etry and make the rest.\u003c/p\u003e\u003cp\u003eof course Bashmohandes \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Amr.Ayman\" title\u003d\"Expert Amr.Ayman\"\u003eAmr.Ayman\u003c/a\u003e is more than welcome to explain his solution.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem E\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003ethe problem is to easily sort the players by the number of kills and have 2 pointers one at the beginning and the other at the first non — zero element if that element becomes 0 move the pointer to the right meaning player at the right pointer killed player at the left pointer and every time move the pointer at the left the answer is \u0026quot;NO\u0026quot; if the left pointer is equal to the right pointer. \u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem F\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003ethis problem represented my love for combinatorics first there is a rule that the number of ways to go from cell (1, 1) to cell (n, m) is C(n + m, m) or C(n + m, n).\u003c/p\u003e\u003cp\u003efor more information on this rule read this : \u003ca href\u003d\"https://www.topcoder.com/community/data-science/data-science-tutorials/basics-of-combinatorics/\"\u003ehttps://www.topcoder.com/community/data-science/data-science-tutorials/basics-of-combinatorics/\u003c/a\u003e\u003c/p\u003e\u003cp\u003eso we can easily find out that the number of ways to from cell (1, 1) to cell (n, m) without passing cell (x, y) is the number of ways to go from Cell (1, 1) to (n, m) C(n + m, n) — (number of ways to go from cell (1, 1) to cell (x, y) C(x + y, y) * number of ways to go from cell (x, y) to cell (n, m) C(n + m — x — y, m — y).\u003c/p\u003e\u003cp\u003ehowever the limits are big for a normal nCr so We will use the modular multiplicative inverse — based nCr where C(x, y)%mod equals x! * (y! ^ mod-2) * ((x-y)! ^ mod — 2).\u003c/p\u003e\u003cp\u003eet3sht.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem G\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eanswer can be easily deduced to be n * m + min(n, m)\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem H\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eliterally the easiest problem on the contest the probability that s[i] is correct is the number of occurrences of s[i] in the string / the size of the string so you just need to accumulate this value for all positions.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem I\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eOne of the Problems on Bashmohands Kee\u0027s List this problem took me about 20 minutes to get a correct idea and 2 — 3 hours to implement a fully working solution of course i am going to only explain the idea first you build a Segment or Fenwick tree over an array of size n all of 1 bits.\u003c/p\u003e\u003cp\u003enow for the first type of queries if the position is less than half the length then you just need only add all values from i-1 to the beginning to all values from i to the i + length of left side that you are rolling else the trick in this instead moving an n you just need to flip the sheet of paper and deal with it as it\u0027s flipped and roll the opposite side.\u003c/p\u003e\u003cp\u003equery of type 2 you need to find the answer of segment (l, r) using your chosen data structure.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem J\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003ethe gist of it that you need to check if you can put the first grid from the top — left corner and the second grid from the bottom right corner and check if they don\u0027t intersect of course you should be careful that you can always rotate the first or second girds.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}