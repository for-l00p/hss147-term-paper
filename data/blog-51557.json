{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1492091415,"rating":0,"authorHandle":"1am","modificationTimeSeconds":1492091415,"id":51557,"title":"\u003cp\u003eDay 5\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eA. Anya and Smartphone\u003c/h1\u003e\u003cp\u003ewe solved this problem by keeping two arrays; one for the order of the applications, the other that gives the index of an application in the order pos[app].\u003c/p\u003e\u003cp\u003eWhen we use an application, we swap the positions of the application and the one to left of it. To do that, we need to get the position of the application inputted, which is stored in pos[app]. Knowing the position, we swap in the order array the application at that position and position -1. All thats left to do is update the pos[app] array. The pos[app] decreases by one, and the application to the left of the app increases by one.\u003c/p\u003e\u003cp\u003eHere is the code for it: \u003ca href\u003d\"http://ideone.com/thKOBX\"\u003ehttp://ideone.com/thKOBX\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eB. Kefa and Company\u003c/h1\u003e\u003cp\u003eThis problem wants the difference between the poorest guy you invite and the richest guy to be less than d, and also to maximize the sum of the friendship factor of the people you invite. \u003c/p\u003e\u003cp\u003eWe inputted each person as a pair.\u003c/p\u003e\u003cp\u003eWe solved this problem using two pointers. First left and right pointers start at 0 (poorest person). Then if the difference between the money of the richest person (at r) and the poorest person (at l) is less than d, than we can move our right pointer and invite richer people. Otherwise, we move our left pointer to not include the poorest person. While we move we add or subtract the sum of their friendship factors.\u003c/p\u003e\u003cp\u003eHere is the code for it: \u003ca href\u003d\"http://ideone.com/v5Z0pM\"\u003ehttp://ideone.com/v5Z0pM\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eD.Books\u003c/h1\u003e\u003cp\u003eThis question is similar to the one before. We use two pointers on the books we will read. If the sum between the right and the left pointers are less than the time we have t, we can increase the right pointer.\u003c/p\u003e\u003cp\u003eNote that the right pointer will never need to go back in the opposite direction. \u003c/p\u003e\u003cp\u003eHere is the two pointers code: \u003ca href\u003d\"http://ideone.com/jYRjAi\"\u003ehttp://ideone.com/jYRjAi\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe first solved it using two pointers, then we solved it using cumulative sum on the time of the books and using a lowerbound to find our right.\u003c/p\u003e\u003cp\u003eHere is the lowerbound code: \u003ca href\u003d\"http://ideone.com/Ok59Ju\"\u003ehttp://ideone.com/Ok59Ju\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eC. Different is Good\u003c/h1\u003e\u003cp\u003eThis code is simple and just asks for us to find the frequency of each letter, and every time we add a letter than is already there, it needs to be changed, so we increase the answer.\u003c/p\u003e\u003cp\u003eThe only time there is no answer is if the length of the string is greater than 26.\u003c/p\u003e\u003cp\u003eHere is the code: \u003ca href\u003d\"http://ideone.com/f3GMyS\"\u003ehttp://ideone.com/f3GMyS\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}