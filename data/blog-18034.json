{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1432320588,"rating":58,"authorHandle":"Radewoosh","modificationTimeSeconds":1432320588,"id":18034,"title":"\u003cp\u003eCodeforces Round #304 (Div.2) editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eA. Soldier and Bananas\u003c/h2\u003e\u003cp\u003eWe can easily calculate the sum of money that we need to buy all the bananas that we want, let\u0027s name it x.\u003c/p\u003e\u003cp\u003eIf n \u0026gt;  \u003d x the answer is 0, because we don\u0027t need to borrow anything.\u003c/p\u003e\u003cp\u003eOtherwise the answer is x - n.\u003c/p\u003e\u003ch2\u003eB. Soldier and Badges\u003c/h2\u003e\u003cp\u003eLet\u0027s count the number of badges with coolness factor 1, 2 and so on. Then, let\u0027s look at the number of badges with value equal to 1. If it\u0027s greater than 1, we have to increase a value of every of them except for one. Then, we look at number of badges with value 2, 3 and so on up to 2n - 2 (because maximum value of badge which we can achieve is 2n - 1). It is easy to see that this is the correct solution. We can implement it in O(n), but solutions that work in complexity O(n^2) also passed.\u003c/p\u003e\u003ch2\u003eC. Soldier and Cards\u003c/h2\u003e\u003cp\u003eIt\u0027s easy to count who wins and after how many \u0026quot;fights\u0026quot;, but it\u0027s harder to say, that game won\u0027t end. How to do it?\u003c/p\u003e\u003cp\u003eFirstly let\u0027s count a number of different states that we can have in the game. Cards can be arranged in any one of n! ways. In every of this combination, we must separate first soldier\u0027s cards from the second one\u0027s. We can separate it in n + 1 places (because we can count the before and after deck case too).\u003c/p\u003e\u003cp\u003eSo war has (n + 1)! states. If we\u0027d do (n + 1)! \u0026quot;fights\u0026quot; and we have not finished the game yes, then we\u0027ll be sure that there is a state, that we passed at least twice. That means that we have a cycle, and game won\u0027t end.\u003c/p\u003e\u003cp\u003eAfter checking this game more accurately I can say that the longest path in the state-graph for n \u003d 10 has length 106, so it is enough to do 106 fights, but solutions that did about 40 millions also passed.\u003c/p\u003e\u003cp\u003eAlternative solution is to map states that we already passed. If we know, that we longest time needed to return to state is about 100, then we know that this solution is correct and fast.\u003c/p\u003e\u003ch2\u003eD. Soldier and Number Game\u003c/h2\u003e\u003cp\u003eFirstly we have to note, that second soldier should choose only prime numbers. If he choose a composite number x that is equal to p * q, he can choose first p, then q and get better score. So our task is to find a number of prime factors in factorization of n.\u003c/p\u003e\u003cp\u003eNow we have to note that factorization of number a! / b! is this same as factorization of numbers (b + 1)*(b + 2)*...*(a - 1)*a.\u003c/p\u003e\u003cp\u003eLet\u0027s count number of prime factor in factorization of every number from 2 to 5000000.\u003c/p\u003e\u003cp\u003eFirst, we use Sieve of Eratosthenes to find a prime diviser of each of these numbers. Then we can calculate a number of prime factors in factorization of a using the formula:\u003c/p\u003e\u003cp\u003eprimefactors[a] \u003d primefactors[a / primediviser[a]] + 1\u003c/p\u003e\u003cp\u003eWhen we know all these numbers, we can use a prefix sums, and then answer for sum on interval.\u003c/p\u003e\u003ch2\u003eE. Soldier and Traveling\u003c/h2\u003e\u003cp\u003eThere are few ways to solve this task, but I\u0027ll describe the simplest (in my opinion) one.\u003c/p\u003e\u003cp\u003eLet\u0027s build a flow network in following way:\u003c/p\u003e\u003cp\u003eMake a source.\u003c/p\u003e\u003cp\u003eMake a first group of vertices consisting of n vertices, each of them for one city.\u003c/p\u003e\u003cp\u003eConnect a source with ith vertex in first group with edge that has capacity ai.\u003c/p\u003e\u003cp\u003eMake a sink and second group of vertices in the same way, but use bi except for ai.\u003c/p\u003e\u003cp\u003eIf there is a road between cities i and j or i \u003d j. Make two edges, first should be connecting ith vertex from first group, and jth vertex from second group, and has infinity capacity. Second should be similar, but connect jth from first group and ith from second group.\u003c/p\u003e\u003cp\u003eThen find a maxflow, in any complexity.\u003c/p\u003e\u003cp\u003eIf maxflow is equal to sum of ai and is equal to sum of bi, then there exists an answer. How can we get it? We just have to check how many units are we pushing through edge connecting two vertices from different groups.\u003c/p\u003e\u003cp\u003eI told about many solutions, because every solution, which doesn\u0027t use greedy strategy, can undo it\u0027s previous pushes, and does it in reasonable complexity should pass.\u003c/p\u003e\u003c/div\u003e","tags":[]}}