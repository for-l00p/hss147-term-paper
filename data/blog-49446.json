{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1483188434,"rating":127,"authorHandle":"fjzzq2002","modificationTimeSeconds":1483189558,"id":49446,"title":"\u003cp\u003eusing merging segment tree to solve problems about sorted list\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eTwo months ago, I came across a problem.\u003c/p\u003e\u003cp\u003eInitially there are n elements, they are in n tiles.\u003c/p\u003e\u003cp\u003eThere are 3 kinds of queries:\u003c/p\u003e \u003col\u003e   \u003cli\u003emerge two tiles into one tile.\u003c/li\u003e   \u003cli\u003esplit one tile into two tiles. (Formally for a tile of size k, split it into two tiles of size k1 and k2, k\u003dk1+k2, the first tile contains the smallest k1 elements and the second tile contains the rest)\u003c/li\u003e   \u003cli\u003efind the k-th smallest element in one tile.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eRecently I found this technique \u003ca href\u003d\"http://blog.csdn.net/zawedx/article/details/51818475\"\u003ehttp://blog.csdn.net/zawedx/article/details/51818475\u003c/a\u003e (in Chinese) which can be used to solve this problem. This blog is my own explanation :p\u003c/p\u003e\u003cp\u003eFirst, let\u0027s suppose the values in the sorted lists are integers between 1~n. If not, you may just sort and map them.\u003c/p\u003e\u003cp\u003eLet\u0027s build a segment tree for every sorted list, segment trees are built based on values (1~n). In every node of a segment tree stores how many numbers are in this range, let\u0027s call this the value of a node.\u003c/p\u003e\u003cp\u003eIt seems that it requires O(nlogn) space to store every segment tree, but we can simply ignore the nodes that value\u003d0, and really allocate these nodes only when their value become \u0026gt;0.\u003c/p\u003e\u003cp\u003eSo for a sorted list with only one element, we simply build a chain of this value, so only O(logn) memory is needed.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint s[SZ]/*value of a node*/,ch[SZ][2]/*a node\u0027s two children*/;\n//make a seg with only node p, return in the first argument\n//call with sth. like build(root,1,n,value);\nvoid build(int\u0026amp; x,int l,int r,int p)\n{\n    x\u003d/*a new node*/; s[x]\u003d1;\n    if(l\u003d\u003dr) return;\n    int m\u003d(l+r)\u0026gt;\u0026gt;1;\n    if(p\u0026lt;\u003dm) build(ch[x][0],l,m,p);\n    else build(ch[x][1],m+1,r,p);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen we split a segment tree (sorted list), simply split two children recursively:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e//make a new node t2, split t1 to t1 and t2 so that s[t1]\u003dk\nvoid split(int t1,int\u0026amp; t2,int k)\n{\n    t2\u003d/*a new node*/;\n    int ls\u003ds[ch[t1][0]]; //size of t1\u0027s left child\n    if(k\u0026gt;ls) split(ch[t1][1],ch[t2][1],k-ls); //split the right child of t1\n    else swap(ch[t1][1],ch[t2][1]); //all right child belong to t2\n    if(k\u0026lt;ls) split(ch[t1][0],ch[t2][0],k); //split the left child of t1\n    s[t2]\u003ds[t1]-k; s[t1]\u003dk;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen we merge two sorted lists, merge them forcely:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e//merge trees t1\u0026amp;t2, return merged segment tree (t1 in fact)\nint merge(int t1,int t2)\n{\n    if(t1\u0026amp;\u0026amp;t2);else return t1^t2; //nothing to merge\n    ch[t1][0]\u003dmerge(ch[t1][0],ch[t2][0]);\n    ch[t1][1]\u003dmerge(ch[t1][1],ch[t2][1]);\n    s[t1]+\u003ds[t2]; /*erase t2, it\u0027s useless now*/ return t1;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAlso, just query k-th simply.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e//query k-th of segment tree x[l,r]\nint ask(int x,int l,int r,int k)\n{\n    if(l\u003d\u003dr) return l;\n    int ls\u003ds[ch[x][0]]; //how many nodes in left child\n    int m\u003d(l+r)\u0026gt;\u0026gt;1;\n    if(k\u0026gt;ls) return ask(ch[x][1],m+1,r,k-ls);\n    return ask(ch[x][0],l,m,k);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt looks very simple, isn\u0027t it? But its total complexity is in fact O(nlogn).\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProof\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eLet\u0027s investigate the total number of allocated segment tree nodes.\u003c/p\u003e\u003cp\u003eInitially we will allocate O(nlogn) such nodes (O(logn) for each).\u003c/p\u003e\u003cp\u003eFor every spliting attempt we will allocate at most O(logn) more, so it will also be O(nlogn) in total. The reason is obviously we will recursively split only either left child or right child of a node.\u003c/p\u003e\u003cp\u003eSo the total number of allocated segment tree nodes will at most be only O(nlogn).\u003c/p\u003e\u003cp\u003eLet\u0027s consider merging, except for \u0027nothing to merge\u0027, every time we call merge, the total number of allocated segment tree nodes will decrease by 1 (t2 isn\u0027t useful anymore). Obviously \u0027nothing to merge\u0027 will only be called when its father is really merged, so they will have nothing to do with complexity.\u003c/p\u003e\u003cp\u003ethe total number of allocated segment tree nodes is O(nlogn), for every useful merge it will decrease 1, so the total complexity of all merges is O(nlogn).\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eHappy new year~\u003c/p\u003e\u003c/div\u003e","tags":["segment trees","algorithmic techniques"]}}