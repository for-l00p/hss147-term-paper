{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1416978184,"rating":0,"authorHandle":"LouisCK","modificationTimeSeconds":1416978184,"id":14871,"title":"\u003cp\u003eWrong answer in ANARC07G on SPOJ, need help\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThis is a DP problem on trees and I tried to solve it using the following approach.\u003c/p\u003e\u003cp\u003eStore a DP state \u003ccode\u003eDP[current][mode] \u003d min_cost\u003c/code\u003e for sub-tree. mode is equal to 0 if the parent of the current node has not bought a family ticket and 1 if it has.\u003c/p\u003e\u003cp\u003eThe recurrence is:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eif(mode \u003d\u003d 0)\nDP[current][mode] \u003d min(cost_of_single_ticket + sum of DP[child][0] for all children, cost_of_family_ticket + sum of DP[child][1] for all children)\n\nelse\n\nDP[current][mode] \u003d min(sum of DP[child][0] for all children, cost_of_family_ticket + sum of DP[child][1] for all children)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe algorithm seems right but I am getting a wrong answer. Here is my code but it is very long and confusing. If you have already solved the problem could you provide some tricky test cases? \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\n\npublic class Main \n{\n    private static MyScanner sc;\n    private static PrintWriter out;\n  \n    private static int single_cost;\n    private static int family_cost;\n    private static HashMap\u0026lt;String, Integer\u0026gt; map;\n    private static ArrayList\u0026lt;String\u0026gt;[] Tree;\n    private static HashMap\u0026lt;String, Integer\u0026gt; times;\n    private static State[][] DP;\n    public static void main(String[] args)\n    {\n        sc \u003d new MyScanner();\n        out \u003d new PrintWriter(System.out);\n        single_cost \u003d sc.nextInt();\n        family_cost \u003d sc.nextInt();\n        int counter \u003d 1;\n        times \u003d new HashMap();\n        map \u003d new HashMap();\n        HashMap\u0026lt;String, ArrayList\u0026lt;String\u0026gt;\u0026gt; data \u003d new HashMap();\n        int unique_id \u003d 0;\n        data \u003d new HashMap();\n        boolean flag \u003d false;\n        while(!flag)\n        {\n            if(single_cost \u003d\u003d 0 \u0026amp;\u0026amp; family_cost \u003d\u003d 0) break;\n            String k \u003d sc.nextLine();\n           \n            \n            if(k.length() !\u003d 0)\n            {\n            String[] line \u003d k.split(\u0026quot;\\\\s+\u0026quot;);\n            if(isNumber(line[0]))\n            {\n                int nu_s \u003d Integer.parseInt(line[0]);\n                int nu_f \u003d Integer.parseInt(line[1]);\n                if(nu_s \u003d\u003d 0 \u0026amp;\u0026amp; nu_f \u003d\u003d 0)\n                {\n                    DP \u003d new State[map.size()][2];\n                    Tree \u003d new ArrayList[map.size()];\n                    for(int i \u003d 0; i \u0026lt; map.size(); i++) Tree[i] \u003d new ArrayList();\n                    for(String parent : data.keySet())\n                    {\n                        Tree[map.get(parent)] \u003d new ArrayList();\n                        for(String child : data.get(parent)) Tree[map.get(parent)].add(child);\n                    }\n                    \n                      for(String parent : data.keySet())\n                    {\n                        //System.out.println(\u0026quot;Adding \u0026quot; + parent);\n                        times.put(parent, 1);\n                      \n                    }\n                    \n                    for(String parent : data.keySet())\n                    {\n                        for(String child : data.get(parent))\n                        {\n                            if(times.containsKey(child)) times.put(child, times.get(child) + 1);\n                        } \n                        \n                    }\n                    \n                    ArrayList\u0026lt;String\u0026gt; roots \u003d get_root();\n                  //  System.out.println(root + \u0026quot; is the root.\u0026quot;);\n                    \n                    int s \u003d 0;\n                    int f \u003d 0;\n                    int c \u003d 0;\n                       \n                    for(String root : roots)\n                    {\n                        State t \u003d solver(root, 0);\n                      s +\u003d t.single_qty;\n                     f +\u003d t.family_qty;\n                      c +\u003d t.cost();\n                    }\n                      \n                      out.println((counter++) + \u0026quot;. \u0026quot; + s + \u0026quot; \u0026quot; + f + \u0026quot; \u0026quot; + c);\n                    flag \u003d true;\n                }\n                else\n                {\n                     DP \u003d new State[map.size()][2];\n                    Tree \u003d new ArrayList[map.size()];\n                      for(int i \u003d 0; i \u0026lt; map.size(); i++) Tree[i] \u003d new ArrayList();\n                    for(String parent : data.keySet())\n                    {\n                        Tree[map.get(parent)] \u003d new ArrayList();\n                        for(String child : data.get(parent)) Tree[map.get(parent)].add(child);\n                    }\n                    \n                      for(String parent : data.keySet())\n                    {\n                        //System.out.println(\u0026quot;Adding \u0026quot; + parent);\n                        times.put(parent, 1);\n                      \n                    }\n                    \n                    for(String parent : data.keySet())\n                    {\n                        for(String child : data.get(parent))\n                        {\n                            if(times.containsKey(child)) times.put(child, times.get(child) + 1);\n                        } \n                        \n                    }\n                    ArrayList\u0026lt;String\u0026gt; roots \u003d get_root();\n                  //  System.out.println(root + \u0026quot; is the root.\u0026quot;);\n                    \n                    int s \u003d 0;\n                    int f \u003d 0;\n                    int c \u003d 0;\n                       \n                    for(String root : roots)\n                    {\n                        State t \u003d solver(root, 0);\n                      s +\u003d t.single_qty;\n                     f +\u003d t.family_qty;\n                      c +\u003d t.cost();\n                    }\n                      \n                      out.println((counter++) + \u0026quot;. \u0026quot; + s + \u0026quot; \u0026quot; + f + \u0026quot; \u0026quot; + c);\n                      // new\n                    data \u003d new HashMap();\n                    times \u003d new HashMap();\n                    map \u003d new HashMap();\n                    unique_id \u003d 0;\n                    single_cost \u003d nu_s;\n                    family_cost \u003d nu_f;\n                \n                }\n            \n            }\n            \n            else\n            {\n                if(!map.containsKey(line[0])) map.put(line[0], unique_id++);\n                if(!data.containsKey(line[0])) data.put(line[0], new ArrayList());\n                \n                for(int i \u003d 1; i \u0026lt; line.length; i++)\n                {\n                  //  System.out.println(\u0026quot;Parent --\u0026gt;\u0026quot; + line[0]);\n                    if(!map.containsKey(line[i])) map.put(line[i], unique_id++);\n                    data.get(line[0]).add(line[i]);\n                  //  System.out.println(\u0026quot;Child \u0026quot; + i + \u0026quot; --\u0026gt;\u0026quot; + line[i]);\n                    \n                }\n            \n            }\n        \n        }\n        \n        }\n        \n     \n       \n\n\n        out.close();\n    }\n    \n    private static ArrayList\u0026lt;String\u0026gt; get_root()\n    {\n        ArrayList\u0026lt;String\u0026gt; L \u003d new ArrayList();\n        for(String node : times.keySet())\n        {\n            \n            if(times.get(node) \u003d\u003d 1) L.add(node);\n        }\n        return L;    \n    }\n    \n    private static boolean isNumber(String a)\n    {\n        try\n        {\n            int k \u003d Integer.parseInt(a);\n            return true;\n        }\n        catch(Exception e) {return false;}\n    \n    }\n    private static State solver(String current, int mode)\n    {\n     //   System.out.println(current + \u0026quot; --\u0026gt; \u0026quot; + mode);\n        if(Tree[map.get(current)].isEmpty())\n        {\n            if(mode \u003d\u003d 0)\n            {\n                State t \u003d new State();\n                t.single_qty +\u003d 1;\n               // System.out.println(\u0026quot;At \u0026quot; + current + \u0026quot; and sending \u0026quot; + t.cost()+\u0026quot; one single qty up mode 0\u0026quot;);\n                return t;\n            }\n            \n            else \n            {\n                \n              //  System.out.println(\u0026quot;At \u0026quot; + current + \u0026quot; and sending 0 one single qty up mode 1\u0026quot;);\n                return new State();\n            }\n        }\n        \n        else\n        {\n            if(DP[map.get(current)][mode] !\u003d null) return DP[map.get(current)][mode];\n            else\n            {\n                if(mode \u003d\u003d 0)\n                {\n                    State curr_state_one \u003d new State();\n                    curr_state_one.single_qty +\u003d 1;\n                    State t;\n                    for(String child : Tree[map.get(current)])\n                    {\n                        t \u003d solver(child, 0);\n                        curr_state_one.single_qty +\u003d t.single_qty;\n                        curr_state_one.family_qty +\u003d t.family_qty;\n                    }\n                    \n                    State curr_state_two \u003d new State();\n                    curr_state_two.family_qty +\u003d 1;\n                    \n                    for(String child : Tree[map.get(current)])\n                    {\n                        t \u003d solver(child, 1);\n                        curr_state_two.single_qty +\u003d t.single_qty;\n                        curr_state_two.family_qty +\u003d t.family_qty;\n                    \n                    }\n                    \n                    DP[map.get(current)][mode] \u003d curr_state_one.minimum(curr_state_two);\n                 //   System.out.println(\u0026quot;At \u0026quot; + current + \u0026quot; and sending \u0026quot;+ DP[map.get(current)][mode].cost() +\u0026quot; one single qty up mode 0\u0026quot;);\n                    return DP[map.get(current)][mode];\n                }\n                \n                else\n                {\n                    \n                     State curr_state_one \u003d new State();\n                     State t;\n                    for(String child : Tree[map.get(current)])\n                    {\n                        t \u003d solver(child, 0);\n                        curr_state_one.single_qty +\u003d t.single_qty;\n                        curr_state_one.family_qty +\u003d t.family_qty;\n                    }\n                    \n                    State curr_state_two \u003d new State();\n                    curr_state_two.family_qty +\u003d 1;\n                    \n                    for(String child : Tree[map.get(current)])\n                    {\n                        t \u003d solver(child, 1);\n                        curr_state_two.single_qty +\u003d t.single_qty;\n                        curr_state_two.family_qty +\u003d t.family_qty;\n                    \n                    }\n                    \n                    DP[map.get(current)][mode] \u003d curr_state_one.minimum(curr_state_two);\n                    \n                  //  System.out.println(\u0026quot;At \u0026quot; + current + \u0026quot; and sending \u0026quot;+ DP[map.get(current)][mode].cost() +\u0026quot; one single qty up mode 1\u0026quot;);\n                    return DP[map.get(current)][mode];\n                \n                \n                }\n                \n            \n            }\n        \n        }\n    \n    }\n    private static int max(int a, int b)\n    {\n        if(a \u0026gt; b) return a;\n        else return b;\n    }\n\n    private static int min(int a, int b)\n    {\n        if(a \u0026lt; b) return a;\n        else return b;\n\n    }\n    \n    private static class State\n    {\n        public int single_qty;\n        public int family_qty;\n        \n        public State()\n        {\n            single_qty \u003d 0;\n            family_qty \u003d 0;\n        }\n        \n        public int cost()\n        {\n            return (single_qty * single_cost) + (family_qty * family_cost); \n        }\n        \n        public State minimum(State t)\n        {\n            if(this.cost() \u0026lt; t.cost()) return this;\n            else return t;\n        }\n        \n        public void data_out(int index)\n        {\n            out.println(index + \u0026quot;. \u0026quot; + this.single_qty + \u0026quot; \u0026quot; + this.family_qty + \u0026quot; \u0026quot; + this.cost());\n        }\n    }\n public static class MyScanner \n    {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() \n      {\n         br \u003d new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() \n      {\n          while (st \u003d\u003d null || !st.hasMoreElements()) \n          {\n              try \n              {\n                  st \u003d new StringTokenizer(br.readLine());\n              } catch (IOException e) \n              {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() \n      {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() \n      {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() \n      {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine()\n      {\n          String str \u003d \u0026quot;\u0026quot;;\n\t  try \n          {\n\t     str \u003d br.readLine();\n\t  } catch (IOException e) \n          {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["dp on a tree","dynamic programming"]}}