{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1468953417,"rating":10,"authorHandle":"Noble_Mushtak","modificationTimeSeconds":1468978102,"id":46139,"title":"\u003cp\u003eOne 32-Bit Variable Solution to Contest 363 Div. 2 Problem C:\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eAfter the contest, I read other people\u0027s solution to Vacations and people kept using big dynamic programming arrays on Div. 2 Problem C, which confused me, so I decided to show all of you that this was unnecessary by \u003ca href\u003d\"//www.codeforces.com/contest/699/submission/19260364\"\u003esolving this problem using only one \u003ccode\u003euint_32\u003c/code\u003e variable in C\u003c/a\u003e. Using bit fields in a struct, we can \u003ca href\u003d\"//www.codeforces.com/contest/699/submission/19265786\"\u003eget this down to only three bytes\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThe intuition behind this solution is that you only need to keep track of what is possible from the day before and if nothing is possible, then you have to rest this day and everything will be possible the next day. I think it\u0027s kind of a greedy algorithm because unlike the DP algorithms, which seemed to take into account solutions where we rest early in order to do something the next day, this algorithm does something on every day when it can and rests only when it finds that it needs to. I do this because whether or not we rest early or the day after when we have to is irrelevant: We still end up resting one day, so the answer is the same. Thus, no dynamic programming is necessary and we only need to keep track of one answer at every point.\u003c/p\u003e\u003c/div\u003e","tags":["#363 (div. 2) c","dynamic programming","greedy","memory manipulation"]}}