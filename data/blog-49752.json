{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1484356729,"rating":0,"authorHandle":"Kole","modificationTimeSeconds":1484929471,"id":49752,"title":"\u003cp\u003eGrafovski algoritmi\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eBroj grafovskih algoritama je jako velik. Mi ćemo obraditi svega nekoliko njih, a ovde ću napisati ukratko nešto o svakom da čisto neki short-desc bude na jednom mestu.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eDFS\u003c/strong\u003e — Služi nam da obiđemo sve čvorove jednog grafa, tako da nikoja dva ne posetimo dva puta. Rekurzivan je, mada se naravno može kucati da bude iterativan što nikako ne preporučujem. Osnova za mnoge naprednije stvari i budući da je kraći od BFSa, za iste stvari se 99.99% ljudi opredeli da kuca DFS. DFS proizvodi tzv. DFS stablo upravo iz razloga što ćemo svaki čvor posetiti tačno jednom. Možemo tajmirati čvorove, za svaki čvor pamtimo vreme kad markiramo taj čvor i vreme kad završimo sa prolaskom kroz njegovo DFS podstablo. U stablu DFSom možemo naći udaljenosti svakog čvora od nekog početnog i tad ne moramo da koristimo BFS.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSloženost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eE\u003c/i\u003e + \u003ci\u003eV\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eBFS\u003c/strong\u003e — Služi nam da obiđemo sve čvorove jednog grafa, tako da nikoja dva ne posetimo dva puta. Nije rekurzivan i neophodan nam je \u003cem\u003ered (queue)\u003c/em\u003e u koji ubacujemo čvorove. Glavna razlika između DFSa i BFSa je u tome što DFS poprilično random konstruiše put kojim prolazi kroz graf, dok BFS to radi tako što pravi slojeve za svaku dužinu puta. BFSom tačno znamo koji su čvorovi na udaljenosti \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e, ... od početnog čvora i u netežinskom grafu nam služi da pronađemo najkraće puteve do svih ostalih čvorova.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSloženost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eE\u003c/i\u003e + \u003ci\u003eV\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eTopološko sortiranje\u003c/strong\u003e — Uređivanje čvorova grafa u niz tako da ako je čvor \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e predak čvora \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e u nizu \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e mora biti pre \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e. \u003cem\u003eSamo se setite Žeks i Bog.\u003c/em\u003e Ako sigurno znamo da je graf acikličan (što je uslov da se graf uopšte i može topološki sortirati) možemo koristiti DFS, inače Kahnov algoritam.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSloženost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eE\u003c/i\u003e + \u003ci\u003eV\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003chr /\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eDijkstra\u003c/strong\u003e — Nalazi najkraći put od nekog čvora do svih ostalih čvorova (tzv. SSSP algoritam) u težinskom grafu kom su sve težine nenegativne, što se u suštini gotovo isključivo i dešava. Koristiti \u003cem\u003epriority_queue\u003c/em\u003e kao osnovnu strukturu. Dijkstra formira shortest-path stablo koje nam služi da utvrdimo koja grana sigurno pripada nekom, koja grana sigurno ne pripada ni jednom i koja grana pripada svakom najkraćem putu.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSloženost \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c6/20/c620814683a82a13185448241fdf6157328cde09.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eBellman-Ford\u003c/strong\u003e — Isto što i Dijkstra, ali težine mogu biti negativne, jedino ne sme da postoji negativni ciklus jer takav ciklus proizvodi najkraći put \u003cspan class\u003d\"tex-span\"\u003e - ∞\u003c/span\u003e. Bellman-Ford lako pronalazi takav ciklus.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSloženost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eEV\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eFloyd-Warshall\u003c/strong\u003e — Pronalazi najkraći put za svaka dva čvora. Zbog ideje algoritma i složenosti, pogodno je čuvati grafu obliku matrice. Takođe može poslužiti za detekciju negativnog ciklusa.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSloženost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eV\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eKruskal\u003c/strong\u003e — Pronalazi minimalno razapinjuće stablo nekog težinskog grafa, koriteći se DSUom. Razapinjuće stablo je stablo koje povezuje sve čvorove nekog grafa, ali tako da je ukupan zbig njegovih grana najmanji moguć. Najintuitivniji algoritam koji ćete sresti.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSloženost \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a0/4c/a04c77de4839dfb342b3d61152c32a88a75cf796.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003ePrim\u003c/strong\u003e — Radi isto što i Kruskal, ali bez DSUa. Retko da je kad neophodan.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSloženost \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a0/4c/a04c77de4839dfb342b3d61152c32a88a75cf796.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eKosaraju\u003c/strong\u003e — Pronalazi jako povezane komponente grafa. Jako povezana komponenta grafa jeste podgraf datog grafa, tako da je za svaki čvor tog podgrafa moguće doći do svakog drugog čvora tog podgrafa. Ako bi posmatrali svaku SCC kao jedan čvor, dobili bi tzv. \u003cem\u003ekondenzancioni graf\u003c/em\u003e koji je DAG. Kosaraju funkcioniše tako što ,,topološki\u0027\u0027 sortiramo čvorove, a potom u tom poretku obilazimo čvorove, ali ovaj put inverznog grafa u odnosu na početni graf.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSloženost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eE\u003c/i\u003e + \u003ci\u003eV\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eTarjan SCC\u003c/strong\u003e — Takođe SCC algoritam, ali je vremenski efikasniji budući da zahteva samo jedan DFS. Kosaraju je dosta intuitivniji.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSloženost \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eE\u003c/i\u003e + \u003ci\u003eV\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eTarjanov algoritam za nalaženje mostova i artikulacionih tačaka\u003c/strong\u003e — Most je grana čijim uklanjanjem dobijamo dve komponente, a artikulaciona tačka čvor čijim uklanjanjem dobijamo dve komponente. Algoritam je neznatno proširenje DFSa i zasniva se na vremenu obilaska čvorova i na osnovu toga efikasno određujemo šta je most/artikulaciona tačka. Ovaj algoritam neće raditi za multigraf niti usmeren graf, tako da je pre toga potrebno graf načini neusmerenim i izbaciti sve duple grane, a onda uz eventualne dodatne provere utvrditi šta je most/artikulaciona tačka.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSloženost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eE\u003c/i\u003e + \u003ci\u003eV\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eFord-Fulkerson\u003c/strong\u003e — Pronalazi maksimalan protok neke protočne mreže, kao i za naleženje minimalnog reza. Takođe se može koristiti za maksimalno bipartitivno uparivanje bipartitivnog grafa. Nikad se ne koristi zbog šuntave složenosti.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSloženost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eE\u003c/i\u003e·| * \u003ci\u003ef\u003c/i\u003e|)\u003c/span\u003e, gde je \u003cspan class\u003d\"tex-span\"\u003e| * \u003ci\u003ef\u003c/i\u003e|\u003c/span\u003e maksimalan protok.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eEdmonds-Karp\u003c/strong\u003e — Isto pronalazi maksimalan protok, ali se za razliku od Ford-Fulkersona služi BFSom pa složenost nije određena protokom. Problematičan ako postoji podosta grana.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSloženost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eVE\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eDinic\u003c/strong\u003e — Isto pronalazi maksimalan protok, ali se koristi svojstvom blokirajućeg protoka i BFSa, pa je najjefikasniji od ova tri algoritma.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSloženost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eEV\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eHLD\u003c/strong\u003e — Vršimo dekompoziciju stabla u lance. Ideja je sledeća: lanac počinje korenom stabla. Ako postoji dete tog korena čija je veličina podstabla veća pod polovine veličine podstabla korena onda se u taj lanac dodaje i to dete. Inače od tog deteta započinje novi lanac. Potpuno ekvivalentno je da lanac nastvaljamo sa onim detetom koji ima najveće podstablo. Dobija se nešto \u003ca href\u003d\"https://i0.wp.com/blog.anudeep2011.com/wp-content/uploads/2014/04/graph-1.png\"\u003eovakvo\u003c/a\u003e. To nam omogućava da od svakog čvora do korena pređemo najviše \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e lanaca. Poenta je da omogućimo pronalazak LCA za dva čvora u \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. HLD se pre svega kuca ako želimo da nagradimo neku strukturu nad svakih lancem, tipa segmentno stablo ili Fenwickovo stablo, jer bi nam tada trebalo jedno segmentno stablo/neka druga struktura za sve lance, a lanci bi zauzimali tačno određene disjunktne intervale.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSloženost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eCentroid decomposition\u003c/strong\u003e — Vršimo dekompoziciju stabla na centroide. Centroid je čvor čijim uklanjanjem dobijamo još dva stabla svako veličine najviše N/2. Radeći to rekurzivno dobijamo stablo koje je sigurno visine \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e i koje ima ukupno \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e puteva od nekog čvora do korena. Dok smo kod HLDa preskakali lance, ovde se direktno čvor po čvor penjemo naviše, a složenost ostaje ista zbog visine takvog stabla. Nestvarno je šta možemo sa ovim, prilično napucana stvar.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSloženost \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eMoov algoritam na stablu\u003c/strong\u003e — Napredna tehnika koja se oslanja na tajmiranje čvorova i formiranje upita po stablu na osnovu toga. Kako je podstablo nekog čvora tačno podniz niza čvorova u pre-orde obilasku stabla, lako formiramo upite i na njih odgovaramo offline.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSloženost \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/22/50/22500e172249d00a66a23a55da44a7d90d7a3761.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003c/div\u003e","tags":[]}}