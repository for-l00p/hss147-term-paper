{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1490176116,"rating":19,"authorHandle":"stostap","modificationTimeSeconds":1490195544,"id":51136,"title":"\u003cp\u003eProblem with persistent treap\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi community,\u003c/p\u003e\u003cp\u003eI\u0027m big fan of treaps, but this task makes me feel stupid. \u003ca href\u003d\"https://www.e-olymp.com/en/problems/2957\"\u003ehttps://www.e-olymp.com/en/problems/2957\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThere is no English translate for some reason. Task: Given N single-element lists with integers 1..10^9, perform next queries:\u003c/p\u003e \u003cul\u003e   \u003cli\u003emerge L R -\u0026gt; take two already exist lists and create a new one, equal concat(L,R)\u003c/li\u003e   \u003cli\u003ehead L -\u0026gt; create two new lists: first contains first element of L, second — the rest of L.\u003c/li\u003e   \u003cli\u003etail L -\u0026gt; create two new lists: first contains all L without last element, second — last element.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eFor every new list you need to output sum of it\u0027s elements.\u003c/p\u003e\u003cp\u003eI\u0027ve did it with persistent treap — for every merge query: merge(root[L], root[R], root[++versions]), for head — split(root[L], root[nextV()], root[nextV()], 1) for tail — split(root[L], root[nextV()], root[nextV()], cnt[root[L]]-1);\u003c/p\u003e\u003cp\u003eBut this fails with \u0026quot;Memory Limit\u0026quot; as for every query it creates at least Log new nodes \u003c/p\u003e \u003cpre\u003e\u003ccode\u003etypedef long long LL;\n#define N 13000005\n#define MOD 1000000007\nint root[300005] , c;\nstruct Treap\n{\n    int sum[N];\n    int nodecnt;\n    int L[N] , R[N] , cnt[N];\n    int key[N];\n    void clear() {\n        nodecnt \u003d 0;\n    }\n    Treap () {clear();}\n    bool hey(int A , int B) {\n        return (LL)rand() * (cnt[A] + cnt[B]) \u0026lt; (LL)cnt[A] * RAND_MAX;\n    }\n    int newnode(int x) {\n        ++ nodecnt , L[nodecnt] \u003d R[nodecnt] \u003d 0;\n        cnt[nodecnt] \u003d 1 , key[nodecnt] \u003d x, sum[nodecnt] \u003d x;\n        return nodecnt;\n    }\n    int copynode(int A) {\n        if (!A) return 0;\n        ++ nodecnt , L[nodecnt] \u003d L[A] , R[nodecnt] \u003d R[A];\n        cnt[nodecnt] \u003d cnt[A] , key[nodecnt] \u003d key[A], sum[nodecnt] \u003d sum[A];\n        if (nodecnt \u003d\u003d 5000000 \u0026amp;mdash; 100) {\n          printf(\u0026quot;TREAP\\n\u0026quot;);\n          exit(0);\n        }\n        return nodecnt;\n    }\n    void pushup(int x) {\n        cnt[x] \u003d 1;\n        sum[x] \u003d key[x];\n        if (L[x]) {\n          cnt[x] +\u003d cnt[L[x]];\n          sum[x] \u003d (sum[x] + sum[L[x]]) % MOD;\n        }\n        if (R[x]) {\n          cnt[x] +\u003d cnt[R[x]];\n          sum[x] \u003d (sum[x] + sum[R[x]]) % MOD;\n        }\n    }\n    void merge(int\u0026amp; p , int x , int y) {\n        if (!x || !y) {\n            p \u003d 0;\n            if (x) p \u003d copynode(x);\n            if (y) p \u003d copynode(y);\n        }\n        else if ( hey(x , y) ) {\n            p \u003d copynode(x);\n            merge(R[p] , R[x] , y) , pushup(p);\n        }\n        else {\n            p \u003d copynode(y);\n            merge(L[p] , x , L[y]) , pushup(p);\n        }\n    }\n    void split(int p , int\u0026amp; x , int\u0026amp; y , int size) {\n        if (!size) {\n             x \u003d 0 , y \u003d copynode(p);\n             return;\n        }\n        if (cnt[L[p]] \u0026gt;\u003d size) {\n            y \u003d copynode(p);\n            split(L[p] , x , L[y] , size) , pushup(y);\n        }\n        else {\n            x \u003d copynode(p);\n            split(R[p] , R[x] , y , size \u0026amp;mdash; cnt[L[p]] \u0026amp;mdash; 1) , pushup(x);\n        }\n    }\n    void print(int p) {\n        if (L[p]) print(L[p]);\n        printf(\u0026quot;%d \u0026quot;, key[p]);\n        if (R[p]) print(R[p]);\n    }\n};\nTreap T;\nchar s[10];\n\nint main(void) {\n  int n;\n  scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n  int version \u003d 0;\n  REP(i, n) {\n    int x;\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;x);\n    root[++version] \u003d T.newnode(x);\n  }\n\n  int q;\n  scanf(\u0026quot;%d\u0026quot;, \u0026amp;q);\n  REP(i, q) {\n    if (version \u0026gt;\u003d 300005 \u0026amp;mdash; 50) {\n      printf(\u0026quot;TREAP2\\n\u0026quot;);\n      exit(0);\n    }\n    scanf(\u0026quot;%s\u0026quot;, \u0026amp;s);\n    if (s[0] \u003d\u003d \u0027m\u0027) {\n      int x,y;\n      scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;x, \u0026amp;y);\n      T.merge(root[++version], root[x], root[y]);\n      printf(\u0026quot;%d\\n\u0026quot;, T.sum[root[version]]);\n    }\n\n    if (s[0] \u003d\u003d \u0027h\u0027) {\n      int x;\n      scanf(\u0026quot;%d\u0026quot;, \u0026amp;x);\n      int v1 \u003d ++version;\n      int v2 \u003d ++version;\n      T.split(root[x], root[v1], root[v2], 1);\n      printf(\u0026quot;%d\\n%d\\n\u0026quot;, T.sum[root[v1]], T.sum[root[v2]]);\n    }\n\n    if (s[0] \u003d\u003d \u0027t\u0027) {\n      int x;\n      scanf(\u0026quot;%d\u0026quot;, \u0026amp;x);\n      int v1 \u003d ++version;\n      int v2 \u003d ++version;\n      T.split(root[x], root[v1], root[v2], T.cnt[root[x]] - 1);\n      printf(\u0026quot;%d\\n%d\\n\u0026quot;, T.sum[root[v1]], T.sum[root[v2]]);\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAny ideas how to improve it?\u003c/p\u003e\u003c/div\u003e","tags":["persistent","treap"]}}