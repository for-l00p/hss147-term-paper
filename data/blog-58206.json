{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1520362019,"rating":0,"authorHandle":"ragrag","modificationTimeSeconds":1520362083,"id":58206,"title":"\u003cp\u003eTrouble finding Second Best MST\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello, I\u0027m having trouble finding the correct Second best MST The procedures i follow are :\u003c/p\u003e\u003cp\u003eFinding MST by kruskal\u003c/p\u003e\u003cp\u003eIterate over all edges of the found MST and refrain from taking each edge individually\u003c/p\u003e\u003cp\u003eRerunning Kruskal to find MST\u003c/p\u003e\u003cp\u003etrace the minimum found MST\u003c/p\u003e\u003cp\u003eHere is my code\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    #define push_back pb\n    #define make_pair mp\n    vector \u0026lt; pair \u0026lt; int, int \u0026gt;\u0026gt; taken; //Used to store edges taken in MST\n\n    for (int i \u003d 0; i \u0026lt; e; i++) { //Finding initial MST\n        pair \u0026lt; int, ii \u0026gt; front \u003d EdgeList[i];\n        if (!isSameSet(front.second.first, front.second.second)) {\n            mst_cost +\u003d front.first;\n            taken.pb(mp(front.second.first, front.second.second)); //Adding taken edge \n            unionSet(front.second.first, front.second.second);\n        }\n\n    }\n\n    int secondMST \u003d INF;\n\n    for (int i \u003d 0; i \u0026lt; taken.size(); i++) {\n\n        initSet(n + 1);\n        int tempst \u003d 0;\n\n        for (int j \u003d 0; j \u0026lt; e; j++) {\n            pair \u0026lt; int, ii \u0026gt; front \u003d EdgeList[j];\n            if ((front.second.first \u003d\u003d taken[i].first) \u0026amp;\u0026amp; (front.second.second \u003d\u003d taken[i].second))\n                continue;\n\n            else if (!isSameSet(front.second.first, front.second.second)) {\n                tempst +\u003d front.first;\n                unionSet(front.second.first, front.second.second);\n            }\n        }\n        secondMST \u003d min(secondMST, tempst);\n    }\n\n    cout \u0026lt;\u0026lt; mst_cost \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; secondMST \u0026lt;\u0026lt; endl;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["ask a question","#algorithms","minimum spanning tree"]}}