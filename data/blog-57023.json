{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1515597980,"rating":3,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1515597980,"id":57023,"title":"\u003cp\u003eNotes on Codeforces Beta Round #107, Div2- A, B, C, D (union-find), E (segment tree and maximum subsequence sum)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/151/problem/A\" title\u003d\"Codeforces Round 107 (Div. 2)\"\u003e151A - Soft Drinking\u003c/a\u003e\u003c/p\u003e\u003cp\u003eSimply calculate the answer as the sample indicates.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/151/problem/B\" title\u003d\"Codeforces Round 107 (Div. 2)\"\u003e151B - Phone Numbers\u003c/a\u003e\u003c/p\u003e\u003cp\u003eA straightforward implementation problem. Take care of the output format.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/151/problem/C\" title\u003d\"Codeforces Round 107 (Div. 2)\"\u003e151C - Win or Freeze\u003c/a\u003e\u003c/p\u003e\u003cp\u003eNote that the player who can not move wins! Therefore, for the initially given integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e, if it is a prime number, the first player wins. \u003c/p\u003e\u003cp\u003eOtherwise, we decompose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e \u003d (\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sup\u003e(\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sup\u003e...\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is a prime divisor. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e only has two prime divisors, it is obvious that the second player wins. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e has more than two prime divisors, the first player definitely wins, since he can find any two prime divisors \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and write down integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e × \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, and then the second player has to face an integer that has only two prime divisors. \u003c/p\u003e\u003cp\u003eAs a general method, we can find a divisor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e, denoted as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e, which falls into interval [2, \\srqt{q}]. If such \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e can not be found, the first player wins. Otherwise, we have found two divisors of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e, i.e., \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e / \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e. Then, we test whether both of them are prime integers. If yes, the first player loses. Otherwise, it suffices to find any two prime divisors of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/151/problem/D\" title\u003d\"Codeforces Round 107 (Div. 2)\"\u003e151D - Quantity of Strings\u003c/a\u003e\u003c/p\u003e\u003cp\u003eOne of the methods is the same as mentioned in tutorials. We can start from some simple examples and find out some particular rules (or patterns) for different values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Then, we compute the answers according to different cases.\u003c/p\u003e\u003cp\u003eAnother method is using union-find. Each letter in the string can be viewed as a node, and a palindrome in fact has introduced edges among different nodes. The connected nodes must have the same letter and thus the number of connected components just indicates that we have these “positions” and each of them can be assigned with a number of letters, which is equal to the size of alphabet.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/151/problem/E\" title\u003d\"Codeforces Round 107 (Div. 2)\"\u003e151E - Smart Cheater\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe problem asks to find a segment for each passenger so that he and the conductor can earn as much money as possible. \u003c/p\u003e\u003cp\u003eSuppose that the segment \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e]\u003c/span\u003e is selected. Then, they can save money equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 2\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e + ...\u003c/span\u003e, while might be penalized with an expected amount of money equal to \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e + ...\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e - 1\u003c/sub\u003e) × \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e. Thus, the expectation should be \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e × \u003ci\u003ec\u003c/i\u003e) + (\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 2\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e - \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e × \u003ci\u003ec\u003c/i\u003e) + ...\u003c/span\u003e. It can be seen that the expectation can be viewed as the sum of expectation value of each neighboring stop. Therefore, the original problem can be reduced to such one that asks to find a consecutive subsequence which gives the maximum sum (a classical problem).\u003c/p\u003e\u003cp\u003eTo solve the reduced problem, we should adopt segment tree since the number of queries is large. The main idea is divide and conquer. Given a sequence with range of \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e, we divide it into two smaller sequences with ranges of \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003emid\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003emid\u003c/i\u003e + 1, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e, respectively. For \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e, the subsequence with maximum sum can only belong to the following three cases: 1) it is completely included in \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003emid\u003c/i\u003e]\u003c/span\u003e; 2) it is completely included in \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003emid\u003c/i\u003e + 1, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e; 3) it has intersection both with the two smaller sequences, and thus it must be the concatenation of “maximum suffix of the first sequence” and “maximum prefix of the second sequence”.\u003c/p\u003e\u003cp\u003eTherefore, for each node in the segment tree, we should store maximum prefix, maximum suffix, total sum, and maximum subsequence sum. Then, we can build the tree, and answer the queries.\u003c/p\u003e\u003c/div\u003e","tags":[]}}