{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1409007459,"rating":0,"authorHandle":"milesstevenson","modificationTimeSeconds":1409008374,"id":13550,"title":"\u003cp\u003eSGU 101. Domino\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ccode\u003eHello,\u003c/code\u003e\u003c/p\u003e\u003cp\u003eI am trying to work on a problem from acm.sgu and was wondering if I could ask for guidance in the right direction. The problem statement is here: \u003ca href\u003d\"http://acm.sgu.ru/problem.php?contest\u003d0\u0026amp;problem\u003d101\"\u003ehttp://acm.sgu.ru/problem.php?contest\u003d0\u0026amp;problem\u003d101\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe way I conceptualize it right now is that it is a DFS problem that can be solved similarly to how N-queens is solved. Is this correct?\u003c/p\u003e\u003cp\u003eFor the example input we have: \u003ccode\u003e(1)\u0026lt;1,2\u0026gt;\u003c/code\u003e \u003ccode\u003e(2)\u0026lt;2,4\u0026gt;\u003c/code\u003e \u003ccode\u003e(3)\u0026lt;2,4\u0026gt;\u003c/code\u003e \u003ccode\u003e(4)\u0026lt;6,4\u0026gt;\u003c/code\u003e \u003ccode\u003e(5)\u0026lt;2,1\u0026gt;\u003c/code\u003e\u003c/p\u003e\u003cp\u003eA tree or graph of sorts would need to be constructed and traversed like the following:\u003c/p\u003e\u003cp\u003eSo that I have an easier time modeling the process/structure in ASCII, let the node \u003ccode\u003e(k)*\u0026lt;i,j\u0026gt;\u003c/code\u003e represent both the pair \u003ccode\u003e(k)\u0026lt;i,j\u0026gt;\u003c/code\u003e and the reverse \u003ccode\u003e(k)\u0026lt;j,i\u0026gt;\u003c/code\u003e\u003c/p\u003e \u003cpre\u003e(1)*\u0026lt;1,2\u0026gt; ... (other combinations e.g (2)*,(3)*,etc.)\n                              /        \\         /        \\\n                        (2)*\u0026lt;2,4\u0026gt;     (3)*\u0026lt;2,4\u0026gt;  (4)*\u0026lt;6,4\u0026gt;   (5)*\u0026lt;2,1\u0026gt;\n                  /    /       \\            ..............\n         (3)*\u0026lt;2,4\u0026gt;  (4)*\u0026lt;6,4\u0026gt;  (5)*\u0026lt;2,1\u0026gt;\n       /    \\             ......\n (4)*\u0026lt;6,4\u0026gt; (5)*\u0026lt;2,1\u0026gt;\n      .......\u003c/pre\u003e\u003cp\u003eOfcourse with the * notation at each node, the reverse pair would need to be searched as well. I believe DFS can be used here to fine the correct sequence that matches the constraints given by the problem set. \u003cstrong\u003eSomething about this bugs me, though.\u003c/strong\u003e Because I\u0027ve never done any graph or tree problems, I don\u0027t understand whether I need to precompute a proper graph/tree to fit this problem or if new nodes at the next level down are to be created, checked, searched further or backtracked depending on whether they meet the constraints.\u003c/p\u003e\u003cp\u003eIs this the correct idea of DFS for this problem? If it is, is the tree/graph to be precomputed and then searched, or searched while being created dynamically depending on constraints. If not, could you lend advice on the correct approach for this sort of problem? As a bonus perhaps some sort of reference to follow for representing graphs/trees properly in this sort of situation with C++?\u003c/p\u003e\u003cp\u003eI only have a formal understanding of DFS, so my idea could very likely be wrong. \u003cstrong\u003eBecause I might have a bit of a conceptualization issue here, is it best for me to just read the chapter on graph data structures in CLRS first\u003c/strong\u003e (I intend to eventually do this, but only if I have to). Again I\u0027m sorry for the bad ASCII job but I figured it was worth sharing to show that I\u0027ve thought about the problem before asking for advice, though.\u003c/p\u003e\u003cp\u003eThank you for reading.\u003c/p\u003e\u003c/div\u003e","tags":["acm.sgu.ru"]}}