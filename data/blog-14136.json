{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1412601329,"rating":27,"authorHandle":"scipianus","modificationTimeSeconds":1412629095,"id":14136,"title":"\u003cp\u003eCodeforces Round #271 (Div. 2) Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/474/problem/A\" title\u003d\"Codeforces Round 271 (Div. 2)\"\u003e474A - Keyboard\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is an implementation problem, therefore most of the solution fit in the time limit. We can even save the keyboard in \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e strings and make a brute force search for each character to find its position and then print the left/right neighbour.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/474/problem/B\" title\u003d\"Codeforces Round 271 (Div. 2)\"\u003e474B - Worms\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThere are two solutions:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eWe can make partial sums (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e) and then make a binary search for each query \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to find the result \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e with the properties \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e - 1\u003c/sub\u003e \u0026lt; \u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e ≥ \u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. This solution has the complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e·\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eWe can precalculate the index of the pile for each worm and then answer for each query in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e. This solution has the complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003e\u003ca href\u003d\"/contest/474/problem/C\" title\u003d\"Codeforces Round 271 (Div. 2)\"\u003e474C - Captain Marmot\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFor each \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e points we want to see if we can rotate them with \u003cspan class\u003d\"tex-span\"\u003e90\u003c/span\u003e degrees such that we obtain a square. We can make a backtracking where we rotate each point \u003cspan class\u003d\"tex-span\"\u003e0, 1, 2\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e times and verify the figure obtained. If it\u0027s a square we update the minimal solution. Since we can rotate each point \u003cspan class\u003d\"tex-span\"\u003e0, 1, 2\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e times, for each regiment we have \u003cspan class\u003d\"tex-span\"\u003e4\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e\u003c/span\u003e configurations to check. So the final complexity is about \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/474/problem/D\" title\u003d\"Codeforces Round 271 (Div. 2)\"\u003e474D - Flowers\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe can notate each string as a binary string, instead of red and white flowers. A string of this type is good only if every maximal contigous subsequence of \u0026quot;\u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e\u0026quot; has the length divisible by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. We can make dynamic programming this way : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enr\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e \u003d the number of good strings of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. If the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th character is \u0026quot;\u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e\u0026quot; then we can have any character before and if the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th character is \u0026quot;\u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e\u0026quot; we must have another \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e \u0026quot;\u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e\u0026quot; characters before, so \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enr\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003enr\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e + \u003ci\u003enr\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e ≥ \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enr\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 1\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Then we compute the partial sums (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003enr\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003enr\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003enr\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e) and for each query the result will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003esum\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e. This solution has the complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003emaxVal\u003c/i\u003e + \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emaxVal\u003c/i\u003e\u003c/span\u003e is the maximum value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/474/problem/E\" title\u003d\"Codeforces Round 271 (Div. 2)\"\u003e474E - Pillars\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe have to find a substring \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eabs\u003c/i\u003e(\u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e - \u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/sub\u003e\u003c/sub\u003e) ≥ \u003ci\u003eD\u003c/i\u003e\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ej\u003c/i\u003e \u0026lt; \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Let\u0027s suppose that the values in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e are smaller. We can make dynamic programming this way : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebest\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e \u003d the maximal length of such a substring ending in the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th position, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebest\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003emax\u003c/i\u003e(\u003ci\u003ebest\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e) + 1\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e \u0026lt; \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e ≥ \u003ci\u003eD\u003c/i\u003e + \u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003eD\u003c/i\u003e\u003c/span\u003e. So we can easily search this maximum in a data structure, such as an segment tree or Fenwick tree. But those data structure must have the size of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003emaxH\u003c/i\u003e)\u003c/span\u003e which can be \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e. For our constraints we mantain the idea described above, but instead of going at some specific position in the data structure based on a value, we would normalize the values in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e and binary search the new index where we should go for an update or a query in the data structure. Therefore, the data structure will have the size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. The complexity of this solution is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e·\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/474/problem/F\" title\u003d\"Codeforces Round 271 (Div. 2)\"\u003e474F - Ant colony\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFor each subsequence \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e]\u003c/span\u003e we must find how many queens we have. A value is \u0026quot;queen\u0026quot; only if is the GCD of (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e + 1\u003c/sub\u003e, ..., \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e). Also, we must notice that the GCD of (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e + 1\u003c/sub\u003e, ..., \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e) can be only the minimum value from (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e + 1\u003c/sub\u003e, ..., \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e). So for each query we search in a data structure (a segment tree or a RMQ) the minimum value and the GCD of (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e + 1\u003c/sub\u003e, ..., \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e) and if these two values are equal then we output the answer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e - \u003ci\u003eL\u003c/i\u003e + 1 - \u003ci\u003enrValues\u003c/i\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enrValues\u003c/i\u003e\u003c/span\u003e is the number of values in the subsequence equal to the GCD and the minimum value. The complexity of this solution is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e·\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)·\u003ci\u003elog\u003c/i\u003e(\u003ci\u003evalMax\u003c/i\u003e) + \u003ci\u003et\u003c/i\u003e·\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)·\u003ci\u003elog\u003c/i\u003e(\u003ci\u003evalMax\u003c/i\u003e))\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003evalMax\u003c/i\u003e\u003c/span\u003e is the maximum value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e","tags":[]}}