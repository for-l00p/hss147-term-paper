{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1494071678,"rating":0,"authorHandle":"GrumpyKitten","modificationTimeSeconds":1494071710,"id":51870,"title":"\u003cp\u003eРазбор задач личного контеста от 6 мая.\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eЗадача А.\u003c/p\u003e\u003cp\u003eИзначально в пустой квадрат размера \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e мы поставим лесенку такого же размера. Затем заметим следующее: мы поставим лесенку размера \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e - 1\u003c/span\u003e по центру, после чего из 4х квадратов \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e - 1\u003c/span\u003e один будет полностью заполнен, а три оставшихся будут одинаковыми, с лесенками \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e - 1\u003c/span\u003e внутри. Значит, наша задача разбилась на 3 независимых за 1 шаг, то есть \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e) \u003d \u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e - 1) * 3\u003c/span\u003e при \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u0026gt;  \u003d 2\u003c/span\u003e. При \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 0\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 1\u003c/span\u003e ответ 1, а при \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u0026gt;  \u003d 2\u003c/span\u003e ответ \u003cspan class\u003d\"tex-span\"\u003e3\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e - 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eЗадача B.\u003c/p\u003e\u003cp\u003eПосчитаем, сколько каждую клетку массива покрывает отрезков. Для этого можно отсортировать массив из концов отрезков, далее идти по нему сканирующей прямой, когда встречаем начало отрезка — увеличиваем баланс, когда встречаем конец — уменьшаем. Далее ясно, что чем больше отрезков покрывает клетку, тем больше значение у неё должно быть. Поэтому сортируем все элементы, максимальный элемент сопоставляем максимальному покрытию отрезков и т.д. Обратите внимание, что в этой задаче легко можно получить ТЛ, если считывать с помощью \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecin\u003c/i\u003e\u003c/span\u003e. Так, решение за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e * \u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e с использованием \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecin\u003c/i\u003e\u003c/span\u003e работает 1.7 сек, с добавлением оптимизации ios::sync_with_stdio(false) 0.75 сек, с использованием scanf — 0.25 сек. Та же история с cout\\printf. Вывод — если у вас ТЛ в задаче, первым делом проверьте, что это не из-за считывания.\u003c/p\u003e\u003cp\u003eЗадача C\u003c/p\u003e\u003cp\u003eВ башне высотой \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e содержится \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e * (\u003ci\u003eh\u003c/i\u003e + 1) / 2\u003c/span\u003e кубиков, это значит, что максимально возможная высота будет равна \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003esqrt\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e + \u003ci\u003eg\u003c/i\u003e))\u003c/span\u003e. При фиксированной высоте если мы знаем, сколько использовано кубиков одного цвета, то знаем, сколько использовано другого. Воспользуемся динамическим программированием: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e — количество различных башен высотой \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, в которых содержится ровно \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e красных кубиков. Тогда следующий, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e, слой может состоять либо из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e красного, либо из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e синего кубика. Поэтому \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e] \u003d \u003ci\u003ed\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e - 1][\u003ci\u003ej\u003c/i\u003e] + \u003ci\u003ed\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e - 1][\u003ci\u003ej\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e (здесь аккуратно следим, чтобы выполнялось \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e \u0026gt;  \u003d 0\u003c/span\u003e). Получим асимптотику \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e * \u003ci\u003esqrt\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e + \u003ci\u003eg\u003c/i\u003e))\u003c/span\u003e и столько же памяти. Для того, чтобы уменьшить число используемой памяти, воспользуемся тем, что значение динамики на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e слое зависит только от \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003eго слоя, поэтому можно хранить не \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esqrt\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e + \u003ci\u003eq\u003c/i\u003e)\u003c/span\u003e слоев, а 2.\u003c/p\u003e\u003cp\u003eЗадача D\u003c/p\u003e\u003cp\u003eРазвернем задачу по времени — вместо удаления будем идти с конца и добавлять элементы. Тогда в каждый момент времени у нас массив разбивается на множество отрезков, отделенных друг от друга еще не добавленными элементами. Будет поддерживать СНМ на элементах массива, причем множества — это отрезки из уже добавленных элементов, в каждом множестве дополнительно поддерживаем сумму на данном отрезке. Тогда при добавлении очередного элемента мы заводим множество, которое соответствует одному этому элементу. Однако при добавлении этого элемента он мог соединить какие-то отрезки — проверяем это, пробуем соединить множества, с помощью новых отрезков пробуем обновить ответ.\u003c/p\u003e\u003cp\u003eЗадача Е\u003c/p\u003e\u003cp\u003eПереформулируем нашу задачу — у нас есть массив \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eа\u003c/i\u003e\u003c/span\u003e и число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Для каждого \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e мы с вероятностью \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e прибавляем его к числу k. Наша задача посчитать вероятность того, что мы прибавили хотя бы l чисел, при этом сумма получилась неотрицательной. Будем пытаться прибавить числа по очереди. Тогда, после того, как мы попробовали прибавить первые \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e чисел, результат может быть следующим: у нас получилась какая-то сумма, при этом мы сколько то чисел прибавили, и для каждой такой конфигурации нам интересно узнать вероятность получить её. Воспользуемся методом динамического программирования: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ekol\u003c/i\u003e][\u003ci\u003esum\u003c/i\u003e]\u003c/span\u003e — пусть уже попробовали прибавить \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e чисел, из которых прибавилось \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ekol\u003c/i\u003e\u003c/span\u003e, и получили в сумме \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e\u003c/span\u003e. Тогда \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1][\u003ci\u003ekol\u003c/i\u003e][\u003ci\u003esum\u003c/i\u003e] +  \u003d \u003ci\u003ed\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ekol\u003c/i\u003e][\u003ci\u003esum\u003c/i\u003e] * (1.0 - \u003ci\u003ep\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] / 100.0)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1][\u003ci\u003ekol\u003c/i\u003e + 1][\u003ci\u003esum\u003c/i\u003e + \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]] +  \u003d \u003ci\u003ed\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ekol\u003c/i\u003e][\u003ci\u003esum\u003c/i\u003e] * (\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] / 100.0)\u003c/span\u003e (здесь использую динамику вперед). После подсчета динамики нам нужно просуммировать все значения динамики \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e - 1][\u003ci\u003ekol\u003c/i\u003e][\u003ci\u003esum\u003c/i\u003e]\u003c/span\u003e такие, что \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ekol\u003c/i\u003e \u0026gt;  \u003d \u003ci\u003el\u003c/i\u003e\u003c/span\u003e, а \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e \u0026gt;  \u003d 0\u003c/span\u003e. Для того, чтобы это решение прошло, нужно обратить внимание на несколько моментов. Во-первых, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e\u003c/span\u003e по ходу программы может стать отрицательной, и это нормально. Для того, чтобы корректно хранить это в динамике, можно в массиве хранить число, равное \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e + \u003ci\u003eminsum\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eminsum\u003c/i\u003e\u003c/span\u003e — минимально возможное значение sum, которое может получиться по ходу выполнения алгоритма, в данном случае \u003cspan class\u003d\"tex-span\"\u003e - \u003ci\u003en\u003c/i\u003e\u003c/span\u003e). Во-вторых, нужно понять, что при значении \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e \u0026gt;  \u003d \u003ci\u003en\u003c/i\u003e\u003c/span\u003e, наша сумма точно не станет отрицательной. Это значит, что значение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e\u003c/span\u003e можно сверху ограничить \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, и считать, что в этом состоянии хранится информация про все состояния, в которых \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e \u0026gt;  \u003d \u003ci\u003en\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eЗадача F\u003c/p\u003e\u003cp\u003eРешение за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e * 3\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e: Переберём всевозможные конфигурации: у каждого кубика может быть 3 возможных состояния: мы не взяли его в итоговое множество, мы взяли его в множество, но без !, и мы взяли его в множество и прикрепили к нему !. Тогда всего состояний у нас получится \u003cspan class\u003d\"tex-span\"\u003e3\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. Для каждого такого состояния нам нужно проверить, что в нём использовано не более \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e восклицательных знаков, посчитать его сумму и проверить, равна ли она \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eПопробуем улучшить это решение. А именно, разделим предметы на два произвольных множества, в одном \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e элементов, в другом \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ep\u003c/i\u003e\u003c/span\u003e. Тогда итоговая конфигурация будет состоять из какой-то конфигурации первого множества + какой-то конфигурации второго. Для первого множества переберём всевозможные конфигурации, и сохраним сумму конфигурации в массиве \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003et\u003c/i\u003e]\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e — количество восклицательных знаков в конфигурации. Отсортируем эти массивы. Теперь переберем всевозможные конфигурации в другом множестве. Пусть в текущей конфигурации у нас \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e восклицательных знаков, а сумма равна \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e. Тогда нам нужно найти количество таких наборов из первого множества, у которых сумма равна \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e - \u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e, при этом восклицательных знаков используется не более \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - \u003ci\u003et\u003c/i\u003e\u003c/span\u003e. Переберем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026lt;  \u003d \u003ci\u003ek\u003c/i\u003e - \u003ci\u003et\u003c/i\u003e\u003c/span\u003e — количество восклицательных знаков в первом множестве, и найдем бинпоиском в массиве \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e количество элементов(каждый соответствует своей конфигурации из первого множества), равных \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e - \u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e. Получили итоговую асимптотику \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(3\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sup\u003e * \u003ci\u003ep\u003c/i\u003e + 3\u003csup class\u003d\"upper-index\"\u003e\u003c/sup\u003e(\u003ci\u003en\u003c/i\u003e - \u003ci\u003ep\u003c/i\u003e) * \u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e (считаем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e(3\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sup\u003e) \u003d \u003ci\u003ep\u003c/i\u003e\u003c/span\u003e). Теперь пусть \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e \u003d 13\u003c/span\u003e, тогда наше решение проходит по времени.\u003c/p\u003e\u003cp\u003eЭтот приём называется meet-in-the-middle, довольно популярная идея в среде спортивных программистов. \u003ca href\u003d\"https://neerc.ifmo.ru/wiki/index.php?title\u003dMeet-in-the-middle\"\u003ehttps://neerc.ifmo.ru/wiki/index.php?title\u003dMeet-in-the-middle\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}