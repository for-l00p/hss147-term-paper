{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1485687857,"rating":0,"authorHandle":"Algiz","modificationTimeSeconds":1485687857,"id":50096,"title":"\u003cp\u003eРешение D\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\nusing namespace std;\nconst int N \u003d 100000; // 10^5\nconst int INF \u003d 1000000000; // 10^9\n#define TASK \u0026quot;lamps\u0026quot;\ntypedef pair \u0026lt;int, int\u0026gt; Segment;\n\nconst Segment ALL \u003d make_pair(-INF, INF);\nconst Segment EMPTY \u003d make_pair(1, 0);\n\nvector\u0026lt;int\u0026gt; g[N];\nvector\u0026lt;Segment\u0026gt; childSeg[N], prefInt[N], suffInt[N];\nSegment segs[N], subtree[N];\nbool ans[N];\n\nSegment intersect(const Segment\u0026amp; a, const Segment\u0026amp; b) {\n    int l \u003d max(a.first, b.first);\n    int r \u003d min(a.second, b.second);\n    if (l \u0026gt; r)\n        return EMPTY;\n    return make_pair(l, r);\n}\n\nSegment extend(const Segment\u0026amp; a, const Segment\u0026amp; b) {\n    if (a.first \u0026gt; a.second)\n        return EMPTY;\n    if (b.first \u0026gt; b.second)\n        return EMPTY;\n    return make_pair(a.first + b.first, a.second + b.second);\n}\n\nSegment dfsCalcSubtree(int v, int p) {\n    if (g[v].size() \u003d\u003d 1 \u0026amp;\u0026amp; p !\u003d -1) {\n        return segs[v];\n    }\n    pair \u0026lt;int, int\u0026gt; subInters \u003d ALL;\n    int degree \u003d g[v].size();\n    for (int i \u003d 0; i \u0026lt; degree; ++i) {\n        int to \u003d g[v][i];\n        if (to !\u003d p) {\n            Segment tmp \u003d dfsCalcSubtree(to, v);\n            subInters \u003d intersect(subInters, tmp);\n            childSeg[v].push_back(tmp);\n        } else {\n            childSeg[v].push_back(ALL);\n        }\n    }\n\n    prefInt[v].resize(degree);\n    suffInt[v].resize(degree);\n\n    prefInt[v][0] \u003d childSeg[v][0];\n    suffInt[v][degree - 1] \u003d childSeg[v][degree - 1];\n    for (int i \u003d 1; i \u0026lt; degree; ++i) {\n        prefInt[v][i] \u003d intersect(childSeg[v][i], prefInt[v][i - 1]);\n        int j \u003d degree - i - 1;\n        suffInt[v][j] \u003d intersect(childSeg[v][j], suffInt[v][j + 1]);\n    }\n\n    if (subInters.first \u0026lt;\u003d subInters.second) {\n        subtree[v] \u003d subInters;\n    } else\n        subtree[v] \u003d EMPTY;\n    return extend(subtree[v], segs[v]);\n}\n\n\nvoid dfsCalc(int v, int p, const Segment\u0026amp; upSeg) {\n    if (g[v].size() \u003d\u003d 1 \u0026amp;\u0026amp; p !\u003d -1) {\n        ans[v] \u003d upSeg.first \u0026lt;\u003d upSeg.second;\n        return;\n    }\n    Segment res \u003d intersect(upSeg, subtree[v]);\n    ans[v] \u003d res.first \u0026lt;\u003d res.second;\n    int degree \u003d g[v].size();\n    for (int i \u003d 0; i \u0026lt; degree; ++i) {\n        int to \u003d g[v][i];\n        if (to !\u003d p) {\n            Segment pref \u003d (i \u0026gt; 0 ? prefInt[v][i - 1] : ALL);\n            Segment suff \u003d (i + 1 \u0026lt; degree ? suffInt[v][i + 1] : ALL);\n            Segment newUpSeg \u003d extend(\n                                    intersect(intersect(pref, suff), upSeg),\n                                    segs[v]);\n            if (g[v].size() \u003d\u003d 1) {\n                newUpSeg \u003d segs[v];\n            }\n            dfsCalc(to, v, newUpSeg);\n        }\n    }\n}\n\nint main() {\n    freopen(TASK\u0026quot;.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n    freopen(TASK\u0026quot;.out\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n    int n;\n    cin \u0026gt;\u0026gt; n;\n    assert(n \u0026lt;\u003d N);\n    for (int i \u003d 0; i + 1 \u0026lt; n; ++i) {\n        int x, y;\n        scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;x, \u0026amp;y);\n        --x;--y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    for (int i \u003d 0; i \u0026lt; n; ++i) {\n        scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;segs[i].first, \u0026amp;segs[i].second);\n    }\n\n    dfsCalcSubtree(0, -1);\n    dfsCalc(0, -1, ALL);\n\n    for (int v \u003d 0; v \u0026lt; n; ++v)\n        if (v + 1 \u003d\u003d n)\n            printf(\u0026quot;%d\\n\u0026quot;, ans[v]);\n        else\n            printf(\u0026quot;%d \u0026quot;, ans[v]);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}