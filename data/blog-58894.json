{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1523546703,"rating":58,"authorHandle":"liv1n9","modificationTimeSeconds":1523607482,"id":58894,"title":"\u003cp\u003e\u0027Meet in the middle\u0027 with shortest path problems of unweighted graph\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHi!\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eSorry for my bad English and also writing!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eMany of you may have heard about shortest path problems of unweighted graph problems which are solved by \u0027meet in the middle\u0027 technique (MITM), and also solved them. My teacher taught me the implementation, but understanding it correctly hadn\u0027t been easy for me, until now. I also tried to modify my teacher\u0027s implementation in a clean way, and it worked (at least it helped me get accepted solutions), which made me feel excited.\u003c/p\u003e\u003cp\u003eSo i\u0027m writing this blog to share with you my implementation and how does it work, because i believe that some of you might be also having problem in understanding and implementing it, and what i\u0027m writing could help you. I will write everything based on my experience, so there might be some mistakes, but i\u0027m trying my best.\u003c/p\u003e\u003ch3\u003eIntroduction\u003c/h3\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSimple MITM Problem\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003ch6\u003eProblem\u003c/h6\u003e \u003cul\u003e   \u003cli\u003eFor an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e integers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and an integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(1 ≤ \u003ci\u003en\u003c/i\u003e ≤ 40, 1 ≤ \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e, 1 ≤ \u003ci\u003eS\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e)\u003c/span\u003e. Find a minimum integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003em\u003c/i\u003e ≥ 0)\u003c/span\u003e so that exist a sequence \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e satisfy \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sub\u003e + ... + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e \u003d \u003ci\u003eS\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThis problem is not a graph problem, but it is a basic MITM problem, so introducing it here will help you understand the idea of MITM.\u003c/p\u003e\u003cp\u003eThe simple solution is just check all the ways of choosing, check whether sum of the choosed numbers equals \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e. If yes then we update the result. Time complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e, and because \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≤ 40\u003c/span\u003e, then this solution isn\u0027t able to run in required time. So we need a better solution.\u003c/p\u003e\u003ch6\u003eMITM solution\u003c/h6\u003e\u003cp\u003eWe divide array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e in to 2 parts: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a0/af/a0af7689f1146c3ebc6275e68c678aadff0da7ef.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/07/b4/07b4e2aafe3abdc8b373928b8cb951a6dfb26e6a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. With the first parts, we calculate all the possible ways of choosing, store the sum and the amount of choosed numbers of each way in an array, assume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e, then we sort array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e in increase order of the sum first, then the amount. We do the similar thing with second parts and array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eAfter that, we iterate on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e. For each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, we do binary search to find first position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e which \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e.\u003ci\u003esum\u003c/i\u003e \u003d \u003ci\u003eS\u003c/i\u003e - \u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e.\u003ci\u003esum\u003c/i\u003e\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e exist then it guaranteed that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e.\u003ci\u003eamount\u003c/i\u003e\u003c/span\u003e is smallest because Y was sorted like sorting \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e above. Our \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eresult\u003c/i\u003e \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003eresult\u003c/i\u003e, \u003ci\u003eY\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e.\u003ci\u003eamount\u003c/i\u003e + \u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e.\u003ci\u003eamount\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSo, instead of brute-force on inital size of data, which time complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e, applying MITM technique help us reduce the complexity to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ab/60/ab6077686550cddeeb8506e7822fd8aa9c187ba5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. It is really impressive!\u003c/p\u003e\u003ch6\u003eConclusion\u003c/h6\u003e\u003cp\u003eAs i understand it, MITM technique means you will divide initial set of data into 2 subsets with equivalent sizes, brute-forces on both subsets to get the results, then apply some algorithms with acceptable complexity to find the answer from those results. If brute-force algorithm has time complexity about \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e then MITM technique will help reduce the complexity to about \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c4/fc/c4fca06da3c4eaac43e0d62f0500a07367f8809b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003eUnweigthed graph problems\u003c/h3\u003e\u003cp\u003eNow we have more interesting problems. They are unweighted graph problems.\u003c/p\u003e\u003ch6\u003eProblem\u003c/h6\u003e \u003cul\u003e   \u003cli\u003eFor a permutation \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e integer from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(1 ≤ \u003ci\u003en\u003c/i\u003e ≤ 10)\u003c/span\u003e. You can swap two consecutive elements \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(1 ≤ \u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. Find minimum number of swaps to change \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e to another permutation \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u0027 \u003d \u003ci\u003ep\u003c/i\u003e\u0027\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u0027\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u0027\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSeem like there is nothing related to graph in the statement. But let\u0027s see: Assume one permutation is one vertex, then every swaps of a permutation\u0027s elements is an edges which connect this vertex with another vertex. So finding minimum number of swaps now becomes a simple BFS/shortest path problem.\u003c/p\u003e\u003cp\u003eNow let\u0027s analyze time complexity. We have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e!\u003c/span\u003e vertices, each vertex has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e adjacent vertices. We also have to store vertices\u0027s visited state by map, because their representations are hard to be stored by normal arrays. So total time complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eo\u003c/i\u003e(\u003ci\u003enlog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e!) × \u003ci\u003en\u003c/i\u003e!)\u003c/span\u003e. Of course, this complexity can not pass 1 second time limit. That why we need MITM technique to make the solution faster.\u003c/p\u003e\u003ch6\u003eMITM solution\u003c/h6\u003e\u003cp\u003eLet\u0027s remember the BFS algorithm to find shortest distance of a path start from vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/span\u003e to vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efinish\u003c/i\u003e\u003c/span\u003e:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003ePush \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/span\u003e into queue\u0027s back, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003evisited\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003etrue\u003c/i\u003e\u003c/span\u003e, let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e \u003d \u003ci\u003estart\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the shortest distance from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e to vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/sub\u003e \u003d 0\u003c/span\u003e,.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eWhile queue is not empty, pop queue\u0027s front which is vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, then push all vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e which are adjacent with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and haven\u0027t visited yet \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003evisited\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003efalse\u003c/i\u003e)\u003c/span\u003e into queue\u0027s back, then let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e + 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003evisited\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003etrue\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eResult\u003c/i\u003e \u003d \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003efinish\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eMITM solution is similar to BFS solution. Below is my implementation:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eLet both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efinish\u003c/i\u003e\u003c/span\u003e be roots. We BFS on 2 roots \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efinish\u003c/i\u003e\u003c/span\u003e at the same time, but using only one queue.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003ePush \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efinish\u003c/i\u003e\u003c/span\u003e into queue\u0027s back, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003evisited\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003evisited\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003efinish\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003etrue\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esrc\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the root of vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e in BFS progression. So \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esrc\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003estart\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esrc\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003efinish\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003efinish\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the shortest distance from vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to it\u0027s tree\u0027s root. So \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003efinish\u003c/i\u003e\u003c/sub\u003e \u003d 0\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eWhile queue is not empty, pop queue\u0027s front which is vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, then push all vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e which are adjacent with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and haven\u0027t visited yet \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003evisited\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003efalse\u003c/i\u003e)\u003c/span\u003e into queue\u0027s back, then let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e + 1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esrc\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003esrc\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003evisited\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003etrue\u003c/i\u003e\u003c/span\u003e. Especially, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e was visited and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/78/36/7836b5a4c54a5d66ac16d0a65074f70644d08aa8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e then we can immediately return \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eResult\u003c/i\u003e \u003d \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e + 1\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eInstead of pushing only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/span\u003e vertex into queue at first, we push both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efinish\u003c/i\u003e\u003c/span\u003e into queue. That means we will go from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efinish\u003c/i\u003e\u003c/span\u003e at the same time. It\u0027s like we BFS with 2 different trees, but using the same queue, not 2 separate queues at the same time. Also for each vertex u, we know which is it\u0027s root, and shortest distance from root to it (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esrc\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e). \u003c/p\u003e\u003cp\u003eThen for a vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e in front of queue, if there is an adjacent vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e which has different root (assume it is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efinish\u003c/i\u003e\u003c/span\u003e) of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e\u0027s root, which means they were from different BFS trees, then we return \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eresult\u003c/i\u003e \u003d \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e + 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSo with BFS you have to travel in a tree with depth \u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e to find the anwser, now you just have to travel in two trees with smaller depths, later we will prove that the smaller depth is about \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1b/50/1b50f8a7d0e7db85872dee229b3edf4a3c0df875.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. It sounds like MITM!\u003c/p\u003e\u003cp\u003eBut there is one thing that made me confused: Shortest path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e + shortest path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efinish\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e may be not equals shortest path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efinish\u003c/i\u003e\u003c/span\u003e (let\u0027s ignore \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e of the formula), so why can we return the anwser immediately when we meet a pair \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e like above? It took me a long time to find the anwser.\u003c/p\u003e\u003ch6\u003eMy proof\u003c/h6\u003e\u003cp\u003eSee the description of the queue below:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/e9/ce/e9ce6413cec2964da4aba4f749a7afc69fad05dc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is set of vetices which have shortest distance from root \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/span\u003e equals \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is set of vetices which have shortest distance from root \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efinish\u003c/i\u003e\u003c/span\u003e equals \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eSets are placed in chronology order. Set which is placed before another set means the vertices of that set were pushed into queue earlier.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eSets have red color means their vertices were poped out of the queue.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eSet has yellow color means there is one vertex belong to that set being in front of queue and being processed. Of course there is only one set which has yellow color.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eSets have green color means their vertices were pushed into queue and are waiting to be processed.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThere is one property that you need to remember:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eWhen a vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e are in front of queue, the maximum possible \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e which \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e has been pushed into queue is \u003cspan class\u003d\"tex-span\"\u003e ≤ \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e + 1\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(1)\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eOkay. Now we are going to find out why we can return the answer like what i said in my implementation. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e be the vertex in front of queue (being processed), \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e is the length of shortest path, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is the ajdacent vertex which has different root of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e\u0027s root.\u003c/p\u003e \u003cul\u003e   \u003cli\u003eIf there is one shortest path with length \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e (even) then we get the queue state like this:\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/8a/dd/8add7a942a6ea020f985eaa6f5b40931bb7855bc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e \u003cul\u003e   \u003cli\u003eIf the shortest path has length \u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e (odd) then we get another queue state:\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/d1/50/d150a74e472152b3630baa70bbe3dee79d3df7c6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eIn both cases, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7e/62/7e62eb1539f5c14d6625b7039b995edc2e232c20.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b2/1f/b21f414a49f8e82f897b90667b636dc509e4379d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, so \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow, if there were a vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u0027\u003c/span\u003e which \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u0027 \u0026lt; \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (be pushed into queue earlier), and has an ajdacent vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u0027\u003c/span\u003e which was visited, has different root and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u0027 + \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u0027 + 1 \u003d \u003ci\u003eS\u003c/i\u003e\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u0027 \u0026gt; \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. So \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u0027 - \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u0027 ≥ \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e + 1 - (\u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e - 1) \u003d \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e + 2 ≥ 2\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u0027 ≥ \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u0027 + 2\u003c/span\u003e. That is wrong because of property \u003cspan class\u003d\"tex-span\"\u003e(1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSo we can prove two things:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eWe can immediately return the answer at the first time we meet a satisfied pair \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf shortest length is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e then \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7e/62/7e62eb1539f5c14d6625b7039b995edc2e232c20.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b2/1f/b21f414a49f8e82f897b90667b636dc509e4379d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, then the depths of two BFS trees of MITM technique is about \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1b/50/1b50f8a7d0e7db85872dee229b3edf4a3c0df875.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003ePseudo code for my implementation:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evisited[start] \u003d visited[finish] \u003d true;\nD[start] \u003d D[finish] \u003d 0;\nsrc[start] \u003d start; src[finish] \u003d finish;\nqueue.push(start); queue.push(finish);\nwhile (!queue.empty()) {\n    vertex u \u003d queue.front(); queue.pop();\n    for (vertex v: adjacent(u)) {\n        if (!visited[v]) {\n            visited[v] \u003d true;\n            src[v] \u003d src[u];\n            D[v] \u003d D[u] + 1;\n            queue.push(v);\n        } else if (src[u] !\u003d src[v]) return D[u] + D[v] + 1;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow it\u0027s easy to implement it. Notice that instead of using \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003evisited\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e, you can use just only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e to do both by assiging \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003efinish\u003c/i\u003e\u003c/sub\u003e \u003d 1\u003c/span\u003e. Of course we need to adjust the returned result.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://www.hackerrank.com/contests/world-codesprint-april/challenges/gena/problem\"\u003eHere\u003c/a\u003e is one problem which can solve by MITM technique. Everything is similar, except finding adjacent vertices, which is a little bit complex. It can also be solve by simple BFS, so you can do both to compare their run times. In case you need my implementation, \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehere is it\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nvoid turn(ll \u0026amp;x, int i)\n{\n    x ^\u003d (1ll \u0026lt;\u0026lt; i);\n}\n\nint fb(ll x, ll y)\n{\n    for (int i \u003d 0; i \u0026lt; 10; i++) if ((x \u0026gt;\u0026gt; (y * 10 + i)) \u0026amp; 1) return i;\n    return 10;\n}\n\nint bfs(ll start, ll finish)\n{\n    if (start \u003d\u003d finish) return 0;\n    queue\u0026lt;ll\u0026gt; q;\n    map\u0026lt;ll, int\u0026gt; D;\n    map\u0026lt;ll, bool\u0026gt; src;\n    D[start] \u003d 1;\n    D[finish] \u003d 1;\n    src[start] \u003d true;\n    src[finish] \u003d false;\n    q.push(start);\n    q.push(finish);\n    while (!q.empty())\n    {\n        ll u \u003d q.front();\n        q.pop();\n        int t \u003d D[u];\n        bool p \u003d src[u];\n        for (int i \u003d 0; i \u0026lt; 4; i++)\n        {\n            for (int j \u003d 0; j \u0026lt; 4; j++)\n            {\n                if (i \u003d\u003d j) continue;\n                int x \u003d fb(u, i);\n                int y \u003d fb(u, j);\n                if (x !\u003d 10 and x \u0026lt; y)\n                {\n                    ll v \u003d u;\n                    turn(v, i * 10 + x);\n                    turn(v, j * 10 + x);\n                    if (!D[v])\n                    {\n                        D[v] \u003d t + 1;\n                        src[v] \u003d p;\n                        q.push(v);\n                    }\n                    else if (src[v] !\u003d p)\n                    {\n                        return D[v] + t - 1;\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nint main()\n{\n    ll start \u003d 0;\n    ll finish \u003d 0;\n    int n;\n    cin \u0026gt;\u0026gt; n;\n    for (int i \u003d 0; i \u0026lt; n; i++)\n    {\n        int x;\n        cin \u0026gt;\u0026gt; x;\n        turn(start, (x - 1) * 10 + i);\n        turn(finish, i);\n    }\n    cout \u0026lt;\u0026lt; bfs(start, finish);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cem\u003eby the way,\u003c/em\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eneed a rest?\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eGOT U!\n//#########+\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027;;;:::::,,,,,,,...............,\u0027########+##+#####+++##+#+++++++++++++++++++++++++++++++\n//+########++\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027;\u0027\u0027;;;;;:::::::,,,,,,,....,.............`..,:\u0027+#######++#++##++++++++++++++++++++++++++++\u0027\n//###########+\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027;;;;;;::::::::,,,,,,,,,,..,,,,,,,,,,,,,,,..,,...,:\u0027+###++++##+++++++++++++++++++++++++\u0027\n//###+#########\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027;;;;;;:::::,,,,,.,..,.......,,,,,,,,,,,,,,,,,,,,,,....:\u0027###++++++++++++++++++++++++\u0027\n//###+###########\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027;;;;;;:::::,,,,,,,,,.......,,,,,::::;;;;;::::::,,:,,,,,,.;##++#####+++++++++++++++\u0027\n//#################\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027;\u0027\u0027;;;;;;;;;:::::,,,,,,,..,,,,,:::::;;;;;\u0027\u0027;;\u0027\u0027\u0027;;;;;;;::::+#+###+#+++++++++++++++++\n//+##################\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027;;;;;;;:::::::::,:,,,,,,,:;;\u0027\u0027++#+++++++\u0027\u0027;;;;;;;;;#####+++++++++++++++++++\n//;+#################@+\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027;;;;;;;;::::::,,,:::;;:;\u0027#@@#####@@@@###++\u0027\u0027\u0027\u0027;;,;######++++++++++++++++\n//,;+###################\u0027;\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027;;\u0027;;;;;:;::::::::::,,;\u0027;+#@@@@@@@@@@@@@@##+++\u0027\u0027\u0027:,:+#####+#+++++++++++++\n//,:\u0027+###################+\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027;;\u0027;;;::::::::,,,,,,.,+@@@@@@@@@@@@@@@@@@@#+\u0027:,..;#######++++++++++++++\n//::;++###################+\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027;;;;;;;;;::::,,,,.,..;#@@@@@@#@@@@@@@@@@@+;:,..,.;+#+#####+++++++++++++\n//;;\u0027\u0027+++###################\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027;;;;;;;::,,.....,.....;#@@@#+++#@@+,.....,,,,\u0027##+#######+++++++++++\n//++++++++###################\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027;::::,,:::::,.,....................,,,:;+###########+++++++++++\n//##++++++####################+\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027;;;;;;::;;;:::::::::::::::::,,,,:;;+@##############+++++++++\n//++++++##++####################\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027;\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027;#@###############++++++++++\n//+++++++##+#####################+\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027#@####################+++++++\n//+++++++########################@#\u0027+\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027++\u0027\u0027\u0027\u0027++++++++++#@@@@@@@@@@@@@@@@@@@###################++++++++\n//###+++++########################@\u0027\u0027\u0027\u0027+++\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027+#@@@@@@@@@@@@@@@####################+++##+#+++\n//#####+++##########################\u0027\u0027\u0027\u0027\u0027++++\u0027\u0027\u0027\u0027\u0027++++\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027;;\u0027\u0027\u0027;;#@@@@@@@@@@@#####################++#####++++\n//#####++++########################@#\u0027\u0027\u0027\u0027\u0027+++++\u0027\u0027\u0027\u0027\u0027\u0027+++#+\u0027\u0027\u0027\u0027\u0027\u0027\u0027;;::::::::#@@@@@@#########################++###++++\n//#####++++########################@#\u0027;\u0027\u0027\u0027\u0027++++#@\u0027\u0027\u0027\u0027\u0027\u0027\u0027+++#+\u0027\u0027\u0027\u0027\u0027\u0027;:::,,,,,,+@@##########################+######+++\n//#####+++++#######################@@#\u0027;\u0027\u0027\u0027\u0027+++#@@#\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027++##+\u0027\u0027\u0027\u0027\u0027\u0027\u0027;:::,,,,,,+@##########################+###+++\n//####+++++++#######################@@+\u0027;\u0027\u0027\u0027\u0027++#@@@@+\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027+++#@+\u0027++\u0027\u0027\u0027\u0027\u0027\u0027;;::,,,,.:############################++\n//##+++++++++######################@@@@\u0027\u0027\u0027\u0027\u0027\u0027++#@@@@@@+\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027+++#@#\u0027\u0027\u0027+\u0027\u0027\u0027\u0027\u0027\u0027;;;:::,,,,.:\u0027#@#####################+\n//#+++++++++++######################@@@@\u0027\u0027\u0027\u0027\u0027+++@@#@@@@@+\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027++@@@@@@#+\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027;;;::,,,,,.;##################+\n//++++++++++++#######################@@@#\u0027\u0027\u0027\u0027\u0027++@@@###@@@@#\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027+#@@@@@@@@@@@+\u0027+\u0027+\u0027++\u0027\u0027\u0027\u0027\u0027;;;:\u0027###############++\n//++++++++++######################@##@@@@+\u0027\u0027\u0027\u0027++#@###@#@@@#@#\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027+#@@@@@@@@@@@@@@##+++#++\u0027\u0027\u0027;#################+\n//+++++++++###########################@@@+;\u0027\u0027\u0027++#@#####@@@@@@@@#\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027+@@@@@@@@@@@@@@@@@@@@@@@##################+\n//+++++++++#########################@@@@@@+\u0027\u0027\u0027++#@#######@@#@@@@@+\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027\u0027+@@@@@@@@@@@@@@@@#######################+\n//+++++++++#########################@##@@@+\u0027\u0027\u0027+#@########@@@@@@@@@@#\u0027\u0027\u0027\u0027\u0027\u0027;\u0027\u0027#@@@@@@@@@@@@#######################+##\n//#++++++++#######################@#@@@@@@@@@@@@#########@@###@@@@@@@@++\u0027\u0027+\u0027\u0027#@@@@@@@##############################+\n//#####+++########+################@@@@@@@@##@###########@@###@##@@@@@@@#++#@@@@@###################################\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch6\u003eExtended problem\u003c/h6\u003e\u003cp\u003eThe above problem is simply find shortest path between to vertices in graph. The next problem is also finding shortest path, but has a few differences:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eFor a graph \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e vertices numbered from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e edges and set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e source vetices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(1 ≤ \u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. Find a shortest path with different \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efinish\u003c/i\u003e\u003c/span\u003e vertices, and those vertices are belong to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eFirstly we push all source vertices into queue, set each of their \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esrc\u003c/i\u003e\u003c/span\u003e equals themself. After that we will do everything like the implementation we did. The proving is similar to what i did above.\u003c/p\u003e\u003ch3\u003eThe end\u003c/h3\u003e\u003cp\u003eThat is everything i want to share with you. I tried my best to help you understand the idea of my implementation and how does it work. Again, my knowledge is limited, so i may missed something, or made some mistakes in this blog.\u003c/p\u003e\u003cp\u003eThanks for reading!\u003c/p\u003e\u003c/div\u003e","tags":["meet in the middle","graph","shortest path"]}}