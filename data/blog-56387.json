{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1513437431,"rating":-1,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1513437431,"id":56387,"title":"\u003cp\u003eNotes on Codeforces Beta Round #101, A, B, C, D (Dij algorithm for sparse graph)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/141/problem/A\" title\u003d\"Codeforces Round 101 (Div. 2)\"\u003e141A - Amusing Joke\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe can adopt two hash tables to record the total number of letters appearing in the first two strings and the third string, respectively. Then, we check whether the two hash tables are exactly the same or not.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/141/problem/B\" title\u003d\"Codeforces Round 101 (Div. 2)\"\u003e141B - Hopscotch\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIt is clear that if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e%\u003ci\u003ea\u003c/i\u003e \u003d 0\u003c/span\u003e, it is definitely not inside any square. Otherwise, we first calculate which row does the point fall into, and then the left work is straightforward implementation.\u003c/p\u003e\u003cp\u003eNotice that the squares are infinitely extended from bottom to top, and the figure only serves as a simple illustration.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/141/problem/C\" title\u003d\"Codeforces Round 101 (Div. 2)\"\u003e141C - Queue\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThere exists a solution with complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eLet us denote the number of taller people standing in front of each person as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e. At first, we sort all the people in an increasing order of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e. Note that we are going to arrange all the people in this order, and the left work is to assign a reasonable height to eacg person. \u003c/p\u003e\u003cp\u003eWe enumerate each person, and find the tallest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e people standing in front of him, whose height are denoted as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ≤ \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e ≤ ... ≤ \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/sub\u003e\u003c/span\u003e and increase their height by one while “assigning” him a height of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e. If this succeeds till the last person is processed, then we have found a feasible answer.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/141/problem/D\" title\u003d\"Codeforces Round 101 (Div. 2)\"\u003e141D - Take-off Ramps\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe main idea is to transform the original problem into a shortest path version. Note that only positions like \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e matter, since for any other two positions, their distance (here, the distance corresponds to the time it costs to move between them) is a constant integer. For more details, one can check the tutorials (I also learned from that).\u003c/p\u003e\u003cp\u003eBesides, I think this is a very wonderful problem to practice several techniques.\u003c/p\u003e\u003cp\u003e1) Data compression: note that the given range is too large to directly store the positions based on arrays. Thus, one should first compress (or “remap”) the given data into smaller range. A neat method has been introduced in the last notes.\u003c/p\u003e\u003cp\u003e2) Dij algorithm based on priority queue: For sparse graph, using priority queue can achieve a complexity of order \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eElogE\u003c/i\u003e)\u003c/span\u003e. I have found a very well written code \u003ca href\u003d\"/contest/141/submission/1029303\" title\u003d\"Submission 1029303 by edward_mj\"\u003e1029303\u003c/a\u003e, and I think one can check the “spfa” function there.\u003c/p\u003e\u003cp\u003e3) struct and STL in C++: a well designed struct and STL can simplify the relationship among various data and help write neat codes. I think the code \u003ca href\u003d\"/contest/141/submission/1029303\" title\u003d\"Submission 1029303 by edward_mj\"\u003e1029303\u003c/a\u003e has also clearly shown how powerful they are.\u003c/p\u003e\u003c/div\u003e","tags":[]}}