{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1423111277,"rating":355,"authorHandle":"DarthPrince","modificationTimeSeconds":1431953120,"id":16221,"title":"\u003cp\u003eAlgorithm Gym :: Graph Algorithms\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eWelcome to the new episode of \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/PrinceOfPersia\" title\u003d\"Candidate Master PrinceOfPersia\"\u003ePrinceOfPersia\u003c/a\u003e presents: Fun with algorithms ;)\u003c/p\u003e\u003cp\u003eYou can find all the definitions here in the book \u0026quot;Introduction to graph theory\u0026quot;, Douglas.B West. Important graph algorithms :\u003c/p\u003e\u003ch2\u003eDFS\u003c/h2\u003e\u003cp\u003eThe most useful graph algorithms are search algorithms. DFS (Depth First Search) is one of them.\u003c/p\u003e\u003cp\u003eWhile running DFS, we assign colors to the vertices (initially white). Algorithm itself is really simple :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003edfs (v):\n        color[v] \u003d gray\n        for u in adj[v]:\n                if color[u] \u003d\u003d white\n                        then dfs(u)\n        color[v] \u003d black\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBlack color here is not used, but you can use it sometimes.\u003c/p\u003e\u003cp\u003eTime complexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch4\u003eDFS tree\u003c/h4\u003e\u003cp\u003eDFS tree is a rooted tree that is built like this :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003elet T be a new tree\ndfs (v):\n        color[v] \u003d gray\n        for u in adj[v]:\n                if color[u] \u003d\u003d white\n                        then dfs(u) and par[u] \u003d v (in T)\n\n        color[v] \u003d black\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eLemma:\u003c/strong\u003e There is no cross edges, it means if there is an edge between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e \u003d \u003ci\u003epar\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e \u003d \u003ci\u003epar\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e.\u003c/p\u003e\u003ch4\u003eStarting time, finishing time\u003c/h4\u003e\u003cp\u003eStarting time of a vertex is the time we enter it (the order we enter it) and its finishing time is the time we leave it. Calculating these are easy :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eTIME \u003d 0\ndfs (v):\n        st[v] \u003d TIME ++\n        color[v] \u003d gray\n        for u in adj[v]:\n                if color[u] \u003d\u003d white\n                        then dfs(u)\n        color[v] \u003d black\n        ft[v] \u003d TIME // or we can use TIME ++\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt is useable in specially data structure problems (convert the tree into an array).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eLemma:\u003c/strong\u003e If we run \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edfs\u003c/i\u003e(\u003ci\u003eroot\u003c/i\u003e)\u003c/span\u003e in a rooted tree, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is an ancestor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e if and only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003est\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003est\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003eft\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003eft\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e .\u003c/p\u003e\u003cp\u003eSo, given arrays \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003est\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eft\u003c/i\u003e\u003c/span\u003e we can rebuild the tree.\u003c/p\u003e\u003ch4\u003eFinding cut edges\u003c/h4\u003e\u003cp\u003eThe code below works properly because the lemma above (first lemma):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eh[root] \u003d 0\npar[v] \u003d -1\ndfs (v):\n        d[v] \u003d h[v]\n        color[v] \u003d gray\n        for u in adj[v]:\n                if color[u] \u003d\u003d white\n                        then par[u] \u003d v and dfs(u) and d[v] \u003d min(d[v], d[u])\n                        if d[u] \u0026gt; h[v]\n                                then the edge v-u is a cut edge\n                else if u !\u003d par[v])\n                        then d[v] \u003d min(d[v], h[u])\n        color[v] \u003d black\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn this code, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e] \u003d \u003c/span\u003e height of vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in the DFS tree and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e] \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003eh\u003c/i\u003e[\u003ci\u003ew\u003c/i\u003e]\u003c/span\u003e where there is at least vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e in subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in the DFS tree where there is an edge between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch4\u003eFinding cut vertices\u003c/h4\u003e\u003cp\u003eThe code below works properly because the lemma above (first lemma):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eh[root] \u003d 0\npar[v] \u003d -1\ndfs (v):\n        d[v] \u003d h[v]\n        color[v] \u003d gray\n        for u in adj[v]:\n                if color[u] \u003d\u003d white\n                        then par[u] \u003d v and dfs(u) and d[v] \u003d min(d[v], d[u])\n                        if d[u] \u0026gt;\u003d h[v] and (v !\u003d root or number_of_children(v) \u0026gt; 1)\n                                then the edge v is a cut vertex\n                else if u !\u003d par[v])\n                        then d[v] \u003d min(d[v], h[u])\n        color[v] \u003d black\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn this code, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e] \u003d \u003c/span\u003e height of vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in the DFS tree and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e] \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003eh\u003c/i\u003e[\u003ci\u003ew\u003c/i\u003e]\u003c/span\u003e where there is at least vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e in subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in the DFS tree where there is an edge between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch4\u003eFinding Eulerian tours\u003c/h4\u003e\u003cp\u003eIt is quite like DFS, with a little change :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector E\ndfs (v):\n        color[v] \u003d gray\n        for u in adj[v]:\n                erase the edge v-u and dfs(u)\n        color[v] \u003d black\n        push v at the end of e\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e is the answer.\u003c/p\u003e\u003cp\u003eProblems: \u003ca href\u003d\"/contest/500/problem/D\" title\u003d\"Good Bye 2014\"\u003e500D - New Year Santa Network\u003c/a\u003e, \u003ca href\u003d\"/contest/475/problem/B\" title\u003d\"Bayan 2015 Contest Warm Up\"\u003e475B - Strongly Connected City\u003c/a\u003e\u003c/p\u003e\u003ch2\u003eBFS\u003c/h2\u003e\u003cp\u003eBFS is another search algorithm (Breadth First Search). It is usually used to calculate the distances from a vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e to all other vertices in unweighted graphs.\u003c/p\u003e\u003cp\u003eCode :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e        BFS(v):\n                for each vertex i\n                        do d[i] \u003d inf\n                d[v] \u003d 0\n                queue q\n                q.push(v)\n                while q is not empty\n                        u \u003d q.front()\n                        q.pop()\n                        for each w in adj[u]\n                                if d[w] \u003d\u003d inf\n                                        then d[w] \u003d d[u] + 1, q.push(w)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDistance of vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTime complexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch4\u003eBFS tree\u003c/h4\u003e\u003cp\u003eBFS tree is a rooted tree that is built like this :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003elet T be a new tree\n        BFS(v):\n                for each vertex i\n                        do d[i] \u003d inf\n                d[v] \u003d 0\n                queue q\n                q.push(v)\n                while q is not empty\n                        u \u003d q.front()\n                        q.pop()\n                        for each w in adj[u]\n                                if d[w] \u003d\u003d inf\n                                        then d[w] \u003d d[u] + 1, q.push(w) and par[w] \u003d u (in T)\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eSCC\u003c/h2\u003e\u003cp\u003eThe most useful and fast-coding algorithm for finding SCCs is Kosaraju.\u003c/p\u003e\u003cp\u003eIn this algorithm, first of all we run DFS on the graph and sort the vertices in decreasing of their finishing time (we can use a stack).\u003c/p\u003e\u003cp\u003eThen, we start from the vertex with the greatest finishing time, and for each vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e that is not yet in any SCC, do : for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is reachable by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is not yet in any SCC, put it in the SCC of vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. The code is quite simple.\u003c/p\u003e\u003cp\u003eProblems: \u003ca href\u003d\"http://www.spoj.com/problems/CAPCITY/\"\u003eCAPCITY\u003c/a\u003e, \u003ca href\u003d\"http://www.spoj.com/problems/BOTTOM/\"\u003eBOTTOM\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eShortest path\u003c/h1\u003e\u003cp\u003eShortest path algorithms are algorithms to find some shortest paths in directed or undirected graphs.\u003c/p\u003e\u003ch2\u003eDijkstra\u003c/h2\u003e\u003cp\u003eThis algorithm is a single source shortest path (from one source to any other vertices). Pay attention that you can\u0027t have edges with negative weight.\u003c/p\u003e\u003cp\u003ePseudo code :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003edijkstra(v) :\n        d[i] \u003d inf for each vertex i\n        d[v] \u003d 0\n        s \u003d new empty set\n        while s.size() \u0026lt; n\n                x \u003d inf\n                u \u003d -1\n                for each i in V-s //V is the set of vertices\n                        if x \u0026gt;\u003d d[i]\n                                then x \u003d d[i], u \u003d i\n                insert u into s\n                // The process from now is called Relaxing\n                for each i in adj[u]\n                        d[i] \u003d min(d[i], d[u] + w(u,i))\n                        \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThere are two different implementations for this. Both are useful (C++11).\u003c/p\u003e\u003cp\u003eOne) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint mark[MAXN];\nvoid dijkstra(int v){\n\tfill(d,d + n, inf);\n\tfill(mark, mark + n, false);\n\td[v] \u003d 0;\n\tint u;\n\twhile(true){\n\t\tint x \u003d inf;\n\t\tu \u003d -1;\n\t\tfor(int i \u003d 0;i \u0026lt; n;i ++)\n\t\t\tif(!mark[i] and x \u0026gt;\u003d d[i])\n\t\t\t\tx \u003d d[i], u \u003d i;\n\t\tif(u \u003d\u003d -1)\tbreak;\n\t\tmark[u] \u003d true;\n\t\tfor(auto p : adj[u]) //adj[v][i] \u003d pair(vertex, weight)\n\t\t\tif(d[p.first] \u0026gt; d[u] + p.second)\n\t\t\t\td[p.first] \u003d d[u] + p.second;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTwo) \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/78/cb/78cbd240f0f43a574eca1a110cf408f9808f17ab.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e1) Using \u003ccode\u003estd :: set\u003c/code\u003e :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid dijkstra(int v){\n\tfill(d,d + n, inf);\n\td[v] \u003d 0;\n\tint u;\n\tset\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt; s;\n\ts.insert({d[v], v});\n\twhile(!s.empty()){\n\t\tu \u003d s.begin() -\u0026gt; second;\n\t\ts.erase(s.begin());\n\t\tfor(auto p : adj[u]) //adj[v][i] \u003d pair(vertex, weight)\n\t\t\tif(d[p.first] \u0026gt; d[u] + p.second){\n\t\t\t\ts.erase({d[p.first], p.first});\n\t\t\t\td[p.first] \u003d d[u] + p.second;\n\t\t\t\ts.insert({d[p.first], p.first});\n\t\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e2) Using \u003ccode\u003estd :: priority_queue\u003c/code\u003e (better):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ebool mark[MAXN];\nvoid dijkstra(int v){\n\tfill(d,d + n, inf);\n\tfill(mark, mark + n, false);\n\td[v] \u003d 0;\n\tint u;\n\tpriority_queue\u0026lt;pair\u0026lt;int,int\u0026gt;,vector\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt;, less\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt; \u0026gt; pq;\n\tpq.push({d[v], v});\n\twhile(!pq.empty()){\n\t\tu \u003d pq.top().second;\n\t\tpq.pop();\n\t\tif(mark[u])\n\t\t\tcontinue;\n\t\tmark[u] \u003d true;\n\t\tfor(auto p : adj[u]) //adj[v][i] \u003d pair(vertex, weight)\n\t\t\tif(d[p.first] \u0026gt; d[u] + p.second){\n\t\t\t\td[p.first] \u003d d[u] + p.second;\n\t\t\t\tpq.push({d[p.first], p.first});\n\t\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eProblem: \u003ca href\u003d\"//codeforces.com/gym/100571/problem/D\"\u003eShortestPath Query\u003c/a\u003e\u003c/p\u003e\u003ch2\u003eFloyd-Warshall\u003c/h2\u003e\u003cp\u003eFloyd-Warshal algorithm is an all-pairs shortest path algorithm using dynamic programming.\u003c/p\u003e\u003cp\u003eIt is too simple and undrestandable :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eFloyd-Warshal()\n\td[v][u] \u003d inf for each pair (v,u)\n\td[v][v] \u003d 0 for each vertex v\n\tfor k \u003d 1 to n\n\t\tfor i \u003d 1 to n\n\t\t\tfor j \u003d 1 to n\n\t\t\t\td[i][j] \u003d min(d[i][j], d[i][k] + d[k][j])\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTime complexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch2\u003eBellman-Ford\u003c/h2\u003e\u003cp\u003eBellman-Ford is an algorithm for single source shortest path where edges can be negative (but if there is a cycle with negative weight, then this problem will be NP).\u003c/p\u003e\u003cp\u003eThe main idea is to relax all the edges exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e times (read relaxation above in dijkstra). You can prove this algorithm using induction.\u003c/p\u003e\u003cp\u003eIf in the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e step, we relax an edge, then we have a negative cycle (this is if and only if).\u003c/p\u003e\u003cp\u003eCode :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eBellman-Ford(int v)\n\td[i] \u003d inf for each vertex i\n\td[v] \u003d 0\n\tfor step \u003d 1 to n\n\t\tfor all edges like e\n\t\t\ti \u003d e.first // first end\n\t\t\tj \u003d e.second // second end\n\t\t\tw \u003d e.weight\n\t\t\tif d[j] \u0026gt; d[i] + w\n\t\t\t\tif step \u003d\u003d n\n\t\t\t\t\tthen return \u0026quot;Negative cycle found\u0026quot;\n\t\t\t\td[j] \u003d d[i] + w\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTime complexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch2\u003eSPFA\u003c/h2\u003e\u003cp\u003eSPFA (Shortest Path Faster Algorithm) is a fast and simple algorithm (single source) that its complexity is not calculated yet. But if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e \u003d \u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e it\u0027s better to use the first implementation of Dijkstra.\u003c/p\u003e\u003cp\u003eThe origin of this algorithm is unknown. It\u0027s said that at first Chinese coders used it in programming contests.\u003c/p\u003e\u003cp\u003eIts code looks like the combination of Dijkstra and BFS :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eSPFA(v):\n\td[i] \u003d inf for each vertex i\n\td[v] \u003d 0\n\tqueue q\n\tq.push(v)\n\twhile q is not empty\n\t\tu \u003d q.front()\n\t\tq.pop()\n\t\tfor each i in adj[u]\n\t\t\tif d[i] \u0026gt; d[u] + w(u,i)\n\t\t\t\tthen d[i] \u003d d[u] + w(u,i)\n\t\t\t\tif i is not in q\n\t\t\t\t\tthen q.push(i)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTime complexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eUnknown\u003c/i\u003e!\u003c/span\u003e.\u003c/p\u003e\u003ch1\u003eMST\u003c/h1\u003e\u003cp\u003eMST \u003d Minimum Spanning Tree :) (if you don\u0027t know what it is, google it).\u003c/p\u003e\u003cp\u003eBest MST algorithms :\u003c/p\u003e\u003ch2\u003eKruskal\u003c/h2\u003e\u003cp\u003eIn this algorithm, first we sort the edges in ascending order of their weight in an array of edges.\u003c/p\u003e\u003cp\u003eThen in order of the sorted array, we add ech edge if and only if after adding it there won\u0027t be any cycle (check it using DSU).\u003c/p\u003e\u003cp\u003eCode :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eKruskal()\n\tsolve all edges in ascending order of their weight in an array e\n\tans \u003d 0\n\tfor i \u003d 1 to m\n\t\tv \u003d e.first\n\t\tu \u003d e.second\n\t\tw \u003d e.weight\n\t\tif merge(v,u) // there will be no cycle\n\t\t\tthen ans +\u003d w\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTime complexity : \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ee/d7/eed729b1a4d27042b962a6e751911990d39898bb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003ch2\u003ePrim\u003c/h2\u003e\u003cp\u003eIn this approach, we act like Dijkstra. We have a set of vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e, in each step we add the nearest vertex to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e, in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e (distance of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e from \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/97/01/9701a520f9b09305c264a9c7262f5b44a74f0740.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eweight\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e is the weight of the edge from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e) .\u003c/p\u003e\u003cp\u003eSo, pseudo code will be like this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ePrim()\n\tS \u003d new empty set\n\tfor i \u003d 1 to n\n\t\td[i] \u003d inf\n\twhile S.size() \u0026lt; n\n\t\tx \u003d inf\n\t\tv \u003d -1\n\t\tfor each i in V - S // V is the set of vertices\n\t\t\tif x \u0026gt;\u003d d[v]\n\t\t\t\tthen x \u003d d[v], v \u003d i\n\t\td[v] \u003d 0\n\t\tS.insert(v)\n\t\tfor each u in adj[v]\n\t\t\tdo d[u] \u003d min(d[u], w(v,u))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eC++ code:\u003c/p\u003e\u003cp\u003eOne) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ebool mark[MAXN];\nvoid prim(){\n\tfill(d, d + n, inf);\n\tfill(mark, mark + n, false);\n\tint x,v;\n\twhile(true){\n\t\tx \u003d inf;\n\t\tv \u003d -1;\n\t\tfor(int i \u003d 0;i \u0026lt; n;i ++)\n\t\t\tif(!mark[i] and x \u0026gt;\u003d d[i])\n\t\t\t\tx \u003d d[i], v \u003d i;\n\t\tif(v \u003d\u003d -1)\n\t\t\tbreak;\n\t\td[v] \u003d 0;\n\t\tmark[v] \u003d true;\n\t\tfor(auto p : adj[v]){ //adj[v][i] \u003d pair(vertex, weight)\n\t\t\tint u \u003d p.first, w \u003d p.second;\n\t\t\td[u] \u003d min(d[u], w);\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTwo) \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5f/ff/5fff706ccec9c6485dd07d40e394ba3e06265b71.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid prim(){\n\tfill(d, d + n, inf);\n\tset\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt; s;\n\tfor(int i \u003d 0;i \u0026lt; n;i ++)\n\t\ts.insert({d[i],i});\n\tint v;\n\twhile(!s.empty()){\n\t\tv \u003d s.begin() -\u0026gt; second;\n\t\ts.erase(s.begin());\n\t\tfor(auto p : adj[v]){\n\t\t\tint u \u003d p.first, w \u003d p.second;\n\t\t\tif(d[u] \u0026gt; w){\n\t\t\t\ts.erase({d[u], u});\n\t\t\t\td[u] \u003d w;\n\t\t\t\ts.insert({d[u], u});\n\t\t\t}\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs Dijkstra you can use \u003ccode\u003estd :: priority_queue\u003c/code\u003e instead of \u003ccode\u003estd :: set\u003c/code\u003e.\u003c/p\u003e\u003ch2\u003eMaximum Flow\u003c/h2\u003e\u003cp\u003eYou can read all about maximum flow \u003ca href\u003d\"http://en.wikipedia.org/wiki/Maximum_flow_problem\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eI only wanna put the source code here (EdmondsKarp):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ealgorithm EdmondsKarp\n    input:\n        C[1..n, 1..n] (Capacity matrix)\n        E[1..n, 1..?] (Neighbour lists)\n        s             (Source)\n        t             (Sink)\n    output:\n        f             (Value of maximum flow)\n        F             (A matrix giving a legal flow with the maximum value)\n    f :\u003d 0 (Initial flow is zero)\n    F :\u003d array(1..n, 1..n) (Residual capacity from u to v is C[u,v] - F[u,v])\n    forever\n        m, P :\u003d BreadthFirstSearch(C, E, s, t, F)\n        if m \u003d 0\n            break\n        f :\u003d f + m\n        (Backtrack search, and write flow)\n        v :\u003d t\n        while v ≠ s\n            u :\u003d P[v]\n            F[u,v] :\u003d F[u,v] + m\n            F[v,u] :\u003d F[v,u] - m\n            v :\u003d u\n    return (f, F)\n\t\n\t\n\t\nalgorithm BreadthFirstSearch\n    input:\n        C, E, s, t, F\n    output:\n        M[t]          (Capacity of path found)\n        P             (Parent table)\n    P :\u003d array(1..n)\n    for u in 1..n\n        P[u] :\u003d -1\n    P[s] :\u003d -2 (make sure source is not rediscovered)\n    M :\u003d array(1..n) (Capacity of found path to node)\n    M[s] :\u003d ∞\n    Q :\u003d queue()\n    Q.offer(s)\n    while Q.size() \u0026gt; 0\n        u :\u003d Q.poll()\n        for v in E[u]\n            (If there is available capacity, and v is not seen before in search)\n            if C[u,v] - F[u,v] \u0026gt; 0 and P[v] \u003d -1\n                P[v] :\u003d u\n                M[v] :\u003d min(M[u], C[u,v] - F[u,v])\n                if v ≠ t\n                    Q.offer(v)\n                else\n                    return M[t], P\n    return 0, P\n\t\n\t\n\t\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEdmondsKarp pseudo code using Adjacency nodes:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ealgorithm EdmondsKarp\n    input:\n        graph (Graph with list of Adjacency nodes with capacities,flow,reverse and destinations)\n        s             (Source)\n        t             (Sink)\n    output:\n        flow             (Value of maximum flow)\n    flow :\u003d 0 (Initial flow to zero)\n    q :\u003d array(1..n) (Initialize q to graph length)\n    while true\n        qt :\u003d 0            (Variable to iterate over all the corresponding edges for a source)\n        q[qt++] :\u003d s    (initialize source array)\n        pred :\u003d array(q.length)    (Initialize predecessor List with the graph length)\n        for qh\u003d0;qh \u0026lt; qt \u0026amp;\u0026amp; pred[t] \u003d\u003d null\n            cur :\u003d q[qh]\n            for (graph[cur]) (Iterate over list of Edges)\n                 Edge[] e :\u003d  graph[cur]  (Each edge should be associated with Capacity)\n                 if pred[e.t] \u003d\u003d null \u0026amp;\u0026amp; e.cap \u0026gt; e.f\n                    pred[e.t] :\u003d e\n                    q[qt++] : \u003d e.t\n        if pred[t] \u003d\u003d null\n            break\n        int df :\u003d MAX VALUE (Initialize to max integer value)\n        for u \u003d t; u !\u003d s; u \u003d pred[u].s\n            df :\u003d min(df, pred[u].cap - pred[u].f)\n        for u \u003d t; u !\u003d s; u \u003d pred[u].s\n            pred[u].f  :\u003d pred[u].f + df\n            pEdge :\u003d array(PredEdge)\n            pEdge :\u003d graph[pred[u].t]\n            pEdge[pred[u].rev].f :\u003d pEdge[pred[u].rev].f - df;\n        flow :\u003d flow + df\n    return flow\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003eDinic\u0027s algorithm\u003c/h4\u003e\u003cp\u003eHere is Dinic\u0027s algorithm as you wanted.\u003c/p\u003e\u003cp\u003eInput: A network \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e \u003d ((\u003ci\u003eV\u003c/i\u003e, \u003ci\u003eE\u003c/i\u003e), \u003ci\u003ec\u003c/i\u003e, \u003ci\u003es\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eOutput: A max \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e - \u003ci\u003et\u003c/i\u003e\u003c/span\u003e flow.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e1.set f(e) \u003d 0 for each e in E\n2.Construct G_L from G_f of G. if dist(t) \u003d\u003d inf, then stop and output f \n3.Find a blocking flow fp in G_L\n4.Augment flow f by fp  and go back to step 2.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTime complexity : \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/39/9b/399b8dc87c41658dd7f74dff7a2ad00ec441ba8f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eTheorem:\u003c/strong\u003e Maximum flow \u003d minimum cut.\u003c/p\u003e\u003ch3\u003eMaximum Matching in bipartite graphs\u003c/h3\u003e\u003cp\u003eMaximum matching in bipartite graphs is solvable also by maximum flow like below :\u003c/p\u003e\u003cp\u003eAdd two vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e, \u003ci\u003eT\u003c/i\u003e\u003c/span\u003e to the graph, every edge from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e (graph parts) has capacity \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, add an edge from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e with capacity \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to every vertex in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e, add an edge from every vertex in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e with capacity \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFinally, answer \u003d maximum matching from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e .\u003c/p\u003e\u003cp\u003eBut it can be done really easier using DFS.\u003c/p\u003e\u003cp\u003eAs, you know, a bipartite matching is the maximum matching if and only if there is no augmenting path (read Introduction to graph theory).\u003c/p\u003e\u003cp\u003eThe code below finds a augmenting path:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ebool dfs(int v){// v is in X, it reaturns true if and only if there is an augmenting path starting from v\n\tif(mark[v])\n\t\treturn false;\n\tmark[v] \u003d true;\n\tfor(auto \u0026amp;u : adj[v])\n\t\tif(match[u] \u003d\u003d -1 or dfs(match[u])) // match[i] \u003d the vertex i is matched with in the current matching, initially -1\n\t\t\treturn match[v] \u003d u, match[u] \u003d v, true;\n\treturn false;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAn easy way to solve the problem is:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor(int i \u003d 0;i \u0026lt; n;i ++)if(match[i] \u003d\u003d -1){\n\tmemset(mark, false, sizeof mark);\n\tdfs(i);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut there is a faster way:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ewhile(true){\n\tmemset(mark, false, sizeof mark);\n\tbool fnd \u003d false;\n\tfor(int i \u003d 0;i \u0026lt; n;i ++) if(match[i] \u003d\u003d -1 \u0026amp;\u0026amp; !mark[i])\n\t\tfnd |\u003d dfs(i);\n\tif(!fnd)\n\t\tbreak;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn both cases, time complexity \u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eProblem: \u003ca href\u003d\"/contest/498/problem/C\" title\u003d\"Codeforces Round 284 (Div. 1)\"\u003e498C - Array and Operations\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eTrees\u003c/h1\u003e\u003cp\u003eTrees are the most important graphs.\u003c/p\u003e\u003cp\u003eIn the last lectures we talked about segment trees on trees and heavy-light decomposition.\u003c/p\u003e\u003ch2\u003ePartial sum on trees\u003c/h2\u003e\u003cp\u003eWe can also use partial sum on trees.\u003c/p\u003e\u003cp\u003eExample: Having a rooted tree, each vertex has a value (initially 0), each query gives you numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is an ancestor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e) and asks you to increase the value of all vertices in the path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSo, we have an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e, and for each query, we increase \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e by 1 and decrease \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003epar\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]]\u003c/span\u003e by 1. The we run this (like a normal partial sum):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid dfs(int v){\n\tfor(auto u : adj[v])\n\t\tif(u - par[v])\n\t\t\tdfs(u), p[v] +\u003d p[u];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eDSU on trees\u003c/h2\u003e\u003cp\u003eWe can use DSU on a rooted tree (not tree DSUs, DSUs like vectors).\u003c/p\u003e\u003cp\u003eFor example, in each node, we have a vector, all nodes in its subtree (this can be used only for offline queries, because we may have to delete it for memory usage). \u003c/p\u003e\u003cp\u003eHere again we use DSU technique, we will have a vector \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003c/span\u003e for every node. When we want to have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e we should merge the vectors of its children. I mean if its children are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e].\u003ci\u003esize\u003c/i\u003e() ≤ \u003ci\u003eV\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e].\u003ci\u003esize\u003c/i\u003e() ≤ ... ≤ \u003ci\u003eV\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e].\u003ci\u003esize\u003c/i\u003e()\u003c/span\u003e, we will put all elements from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e]\u003c/span\u003e for every \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e and then, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e] \u003d \u003ci\u003eV\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e]\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eUsing this trick, time complexity will be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/78/cb/78cbd240f0f43a574eca1a110cf408f9808f17ab.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eC++ example (it\u0027s a little complicated) :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etypedef vector\u0026lt;int\u0026gt; vi;\nvi *V[MAXN];\nvoid dfs(int v, int par \u003d -1){\n\tint mx \u003d 0, chl \u003d -1;\n\tfor(auto u : adj[v])if(par - u){\n\t\tdfs(u,v);\n\t\tif(mx \u0026lt; V[u]-\u0026gt;size()){\n\t\t\tmx \u003d V[u]-\u0026gt;size();\n\t\t\tchl \u003d u;\n\t\t}\n\t}\n\tfor(auto u : adj[v])if(par - u and chl - u){\n\t\tfor(auto a : *V[u])\n\t\t\tV[chl]-\u0026gt;push_back(a);\n\t\tdelete V[u];\n\t}\n\tif(chl + 1)\n\t\tV[v] \u003d V[chl];\n\telse{\n\t\tV[v] \u003d new vi;\n\t\tV[v]-\u0026gt;push_back(v);\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eLCA\u003c/h2\u003e\u003cp\u003eLCA of two vertices in a rooted tree, is their lowest common ancestor.\u003c/p\u003e\u003cp\u003eThere are so many algorithms for this, I will discuss the important ones.\u003c/p\u003e\u003cp\u003eEach algorithm has complexities \u003cspan class\u003d\"tex-span\"\u003e \u0026lt; \u003ci\u003eO\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)), \u003ci\u003eO\u003c/i\u003e(\u003ci\u003eg\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)) \u0026gt; \u003c/span\u003e, it means that this algorithm\u0027s preprocess is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e and answering a query is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eg\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e .\u003c/p\u003e\u003cp\u003eIn all algorithms, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e] \u003d \u003c/span\u003e height of vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eOne) Brute force \u003cspan class\u003d\"tex-span\"\u003e \u0026lt; \u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e), \u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e) \u0026gt; \u003c/span\u003e\u003c/strong\u003e \u003c/p\u003e\u003cp\u003eThe simplest approach. We go up enough to achieve the goal.\u003c/p\u003e\u003cp\u003ePreproccess :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid dfs(int v,int p \u003d -1){\n\tif(par + 1)\n\t\th[v] \u003d h[p] + 1;\n\tpar[v] \u003d p;\n\tfor(auto u : adj[v])\tif(p - u)\n\t\tdfs(u,v);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eQuery :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint LCA(int v,int u){\n\tif(v \u003d\u003d u)\n\t\treturn v;\n\tif(h[v] \u0026lt; h[u])\n\t\tswap(v,u);\n\treturn LCA(par[v], u);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eTwo) SQRT decomposition \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/26/43/264322f3af5fdebf0993ddd2e0d08b0fa5964630.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/strong\u003e \u003c/p\u003e\u003cp\u003eI talked about SQRT decomposition in the first lecture.\u003c/p\u003e\u003cp\u003eHere, we will cut the tree into \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4f/74/4f7439f1176d1dea4c4cc372f2dd0c8ff0db5b54.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eH\u003c/i\u003e\u003c/span\u003e \u003d height of the tree), starting from \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e of them contains all vertices with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e in interval \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0a/82/0a8296bb5244cfb025f41731083a86f3969d2f41.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eAlso, for each vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e piece, we store \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e that is, its lowest ancestor in the piece number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003ePreprocess:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid dfs(int v,int p \u003d -1){\n\tif(par + 1)\n\t\th[v] \u003d h[p] + 1;\n\tpar[v] \u003d p;\n\tif(h[v] % SQRT \u003d\u003d 0)\n\t\tr[v] \u003d p;\n\telse\n\t\tr[v] \u003d r[p];\n\tfor(auto u : adj[v])\tif(p - u)\n\t\tdfs(u,v);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eQuery:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint LCA(int v,int u){\n\tif(v \u003d\u003d u)\n\t\treturn v;\n\tif(h[v] \u0026lt; h[u])\n\t\tswap(v,u);\n\tif(h[v] \u003d\u003d h[u])\n\t\treturn (r[v] \u003d\u003d r[u] ? LCA(par[v], par[u]) : LCA(r[v], r[u]));\n\tif(h[v] - h[u] \u0026lt; SQRT)\n\t\treturn LCA(par[v], u);\n\treturn LCA(r[v], u);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eThree) Sparse table \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/75/b7/75b73098fefd4e07e225bfe409b665e9d668ac0c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s introduce you an order of tree vertices, \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/haas\" title\u003d\"International master haas\"\u003ehaas\u003c/a\u003e and I named it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eEuler\u003c/i\u003e \u003ci\u003eorder\u003c/i\u003e\u003c/span\u003e. It is like DFS order, but every time we enter a vertex, we write it\u0027s number down (even when we come from a child to this node in DFS).\u003c/p\u003e\u003cp\u003eCode for calculate this :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;int\u0026gt; euler;\nvoid dfs(int v,int p \u003d -1){\n\teuler.push_back(v);\n\tfor(auto u : adj[v])\tif(p - u)\n\t\tdfs(u,v), euler.push_back(v);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf we have a \u003ccode\u003evector\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt;\u003c/code\u003e instead of this and push \u003ccode\u003e{h[v], v}\u003c/code\u003e in the vector, and the first time \u003ccode\u003e{h[v], v}\u003c/code\u003e is appeared is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e] \u0026lt; \u003ci\u003es\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLCA\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e, \u003ci\u003eu\u003c/i\u003e) \u003d (\u003ci\u003emin\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e \u003d \u003ci\u003es\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003es\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/sup\u003e\u003ci\u003eeuler\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]).\u003ci\u003esecond\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFor this propose we can use RMQ problem, and the best algorithm for that, is to use Sparse table.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eFour) Something like Sparse table :) \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/69/a0/69a04fe8b9591fe427ce8df428e15a87075870f8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThis is the most useful and simple (among fast algorithms) algorithm.\u003c/p\u003e\u003cp\u003eFor each vector \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, we store its \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e-th ancestor. This can be done in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/78/cb/78cbd240f0f43a574eca1a110cf408f9808f17ab.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Then, for each query, we find the lowest ancestors of them which are in the same height, but different (read the source code for understanding).\u003c/p\u003e\u003cp\u003ePreprocess:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint par[MAXN][MAXLOG]; // initially all -1\nvoid dfs(int v,int p \u003d -1){\n\tpar[v][0] \u003d p;\n\tif(p + 1)\n\t\th[v] \u003d h[p] + 1;\n\tfor(int i \u003d 1;i \u0026lt; MAXLOG;i ++)\n\t\tif(par[v][i-1] + 1)\n\t\t\tpar[v][i] \u003d par[par[v][i-1]][i-1];\n\tfor(auto u : adj[v])\tif(p - u)\n\t\tdfs(u,v);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eQuery:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint LCA(int v,int u){\n\tif(h[v] \u0026lt; h[u])\n\t\tswap(v,u);\n\tfor(int i \u003d MAXLOG - 1;i \u0026gt;\u003d 0;i --)\n\t\tif(par[v][i] + 1 and h[par[v][i]] \u0026gt;\u003d h[u])\n\t\t\tv \u003d par[v][i];\n\t// now h[v] \u003d h[u]\n\tif(v \u003d\u003d u)\n\t\treturn v;\n\tfor(int i \u003d MAXLOG - 1;i \u0026gt;\u003d 0;i --)\n\t\tif(par[v][i] - par[u][i])\n\t\t\tv \u003d par[v][i], u \u003d par[u][i];\n\treturn par[v][0];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eFive) Advance RMQ \u003cspan class\u003d\"tex-span\"\u003e \u0026lt; \u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e), \u003ci\u003eO\u003c/i\u003e(1) \u0026gt; \u003c/span\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eIn the third approach, we said that LCA can be solved by RMQ.\u003c/p\u003e\u003cp\u003eWhen you look at the vector \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eeuler\u003c/i\u003e\u003c/span\u003e you see that for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e that \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003eeuler\u003c/i\u003e.\u003ci\u003esize\u003c/i\u003e()\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eeuler\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e].\u003ci\u003efirst\u003c/i\u003e - \u003ci\u003eeuler\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1].\u003ci\u003efirst\u003c/i\u003e| \u003d 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSo, we can convert the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eeuler\u003c/i\u003e\u003c/span\u003e from its size(we consider its size is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + 1\u003c/span\u003e) into a binary sequence of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e (if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eeuler\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e].\u003ci\u003efirst\u003c/i\u003e - \u003ci\u003eeuler\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1].\u003ci\u003efirst\u003c/i\u003e \u003d 1\u003c/span\u003e we put \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e otherwise \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eSo, we have to solve the problem on a binary sequence \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e .\u003c/p\u003e\u003cp\u003eTo solve this restricted version of the problem we need to partition \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e into blocks of size \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/27/a0/27a0c37a27f0ddf092e89ac7e7dcac2b7cf8d5bc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u0027[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e be the minimum value for the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e block in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e be the position of this minimum value in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e. Both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e are \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c6/f4/c6f489bbb188f10ecfe9b94569d494906a4e6552.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e long. Now, we preprocess \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u0027\u003c/span\u003e using the Sparse Table algorithm described in lecture 1. This will take \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/05/c1/05c11b9ae431219c5d81e13bf361b2d0c55237fe.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time and space. After this preprocessing we can make queries that span over several blocks in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e. It remains now to show how the in-block queries can be made. Note that the length of a block is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/27/a0/27a0c37a27f0ddf092e89ac7e7dcac2b7cf8d5bc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, which is quite small. Also, note that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e is a binary array. The total number of binary arrays of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/68/b2/68b2f5f5f9c70b75df33b78d584fada783d1e3ed.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. So, for each binary block of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e we need to lock up in a table \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e the value for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eRMQ\u003c/i\u003e\u003c/span\u003e between every pair of indices. This can be trivially computed in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9a/1c/9a1c05761df95a83805878bed53725df220b0d53.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time and space. To index table \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e, preprocess the type of each block in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and store it in array \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/68/db/68db49e667b9b77123b60481cf7c501874f40334.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. The block type is a binary number obtained by replacing \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e + 1\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e (as described above).\u003c/p\u003e\u003cp\u003eNow, to answer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eRMQA\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e we have two cases:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e are in the same block, so we use the value computed in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e are in different blocks, so we compute three values: the minimum from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to the end of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e\u0027s block using \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e, the minimum of all blocks between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e\u0027s and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e\u0027s block using precomputed queries on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e\u0027 and the minimum from the beginning of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e\u0027s block to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, again using \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e; finally return the position where the overall minimum is using the three values you just computed.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eSix) Tarjan\u0027s algorithm \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ena\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e is the inverse ackermann function)\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eTarjan\u0027s algorithm is offline; that is, unlike other lowest common ancestor algorithms, it requires that all pairs of nodes for which the lowest common ancestor is desired must be specified in advance. The simplest version of the algorithm uses the union-find data structure, which unlike other lowest common ancestor data structures can take more than constant time per operation when the number of pairs of nodes is similar in magnitude to the number of nodes. A later refinement by Gabow \u0026amp; Tarjan (1983) speeds the algorithm up to linear time.\u003c/p\u003e\u003cp\u003eThe pseudocode below determines the lowest common ancestor of each pair in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e, given the root \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e of a tree in which the children of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e are in the set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e.children. For this offline algorithm, the set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e must be specified in advance. It uses the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eMakeSet\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eFind\u003c/i\u003e\u003c/span\u003e, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eUnion\u003c/i\u003e\u003c/span\u003e functions of a disjoint-set forest. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eMakeSet\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e)\u003c/span\u003e removes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to a singleton set, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eFind\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e)\u003c/span\u003e returns the standard representative of the set containing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eUnion\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e merges the set containing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e with the set containing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eTarjanOLCA\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e)\u003c/span\u003e is first called on the root \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e function TarjanOLCA(u)\n     MakeSet(u);\n     u.ancestor :\u003d u;\n     for each v in u.children do\n         TarjanOLCA(v);\n         Union(u,v);\n         Find(u).ancestor :\u003d u;\n     u.colour :\u003d black;\n     for each v such that {u,v} in P do\n         if v.colour \u003d\u003d black\n             print \u0026quot;Tarjan\u0027s Lowest Common Ancestor of \u0026quot; + u +\n                   \u0026quot; and \u0026quot; + v + \u0026quot; is \u0026quot; + Find(v).ancestor + \u0026quot;.\u0026quot;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEach node is initially white, and is colored black after it and all its children have been visited. The lowest common ancestor of the pair \u003cspan class\u003d\"tex-span\"\u003e{\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e}\u003c/span\u003e is available as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eFind\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e.ancestor immediately (and only immediately) after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is colored black, provided \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is already black. Otherwise, it will be available later as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eFind\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e).\u003ci\u003eancestor\u003c/i\u003e\u003c/span\u003e, immediately after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is colored black.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e function MakeSet(x)\n     x.parent :\u003d x\n     x.rank   :\u003d 0\n \n function Union(x, y)\n     xRoot :\u003d Find(x)\n     yRoot :\u003d Find(y)\n     if xRoot.rank \u0026gt; yRoot.rank\n         yRoot.parent :\u003d xRoot\n     else if xRoot.rank \u0026lt; yRoot.rank\n         xRoot.parent :\u003d yRoot\n     else if xRoot !\u003d yRoot\n         yRoot.parent :\u003d xRoot\n         xRoot.rank :\u003d xRoot.rank + 1\n  \n function Find(x)\n     if x.parent \u003d\u003d x\n        return x\n     else\n        x.parent :\u003d Find(x.parent)\n        return x.parent\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["tutorial","graphs","algorithm-gym"]}}