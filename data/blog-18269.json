{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1433169308,"rating":3,"authorHandle":"mochow","modificationTimeSeconds":1433169379,"id":18269,"title":"\u003cp\u003eCounting Inversions of Length N\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThere is this classical problem of counting number of inversions in an array.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eLet A[0...n - 1] be an array of n distinct positive integers. If i \u0026lt; j and A[i] \u0026gt; A[j] then the pair (i, j) is called an inversion of A. \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis problem can be found \u003ca href\u003d\"http://www.spoj.com/problems/INVCNT/\"\u003ehere.\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI found \u003ca href\u003d\"//codeforces.com/problemset/problem/61/E\"\u003ethis\u003c/a\u003e problem on CF where we need to find number of such triples \u003ccode\u003e(i,j,k)\u003c/code\u003e such that \u003ccode\u003ei\u0026lt;j\u0026lt;k and A[i]\u0026gt;A[j]\u0026gt;A[k].\u003c/code\u003e\u003c/p\u003e\u003cp\u003eI solved both of the problems using BIT. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eFor the second problem, I counted number of numbers greater than A[i] at its left (left[i]) and number of numbers less than A[i] at its right (right[i]). So the output is summation of right[i]*left[i] for all i from 0 to n-1.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eNow I have a question, what if the problem is counting inversions of length N? It means we need to find number of such combinations \u003ccode\u003e(i,j,k,...) such that i\u0026lt;j\u0026lt;k\u0026lt;... and A[i]\u0026gt;A[j]\u0026gt;A[k]\u0026gt;...\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eWhat should be a generalized solution for this problem?\u003c/p\u003e\u003c/div\u003e","tags":["data structures","inversions","binary indexed tree"]}}