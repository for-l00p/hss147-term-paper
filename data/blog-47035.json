{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1473475501,"rating":0,"authorHandle":"I_love_Hoang_Yen","modificationTimeSeconds":1473479891,"id":47035,"title":"\u003cp\u003eSP Training 9 — Solutions\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003e[problem:208692A]\u003c/h1\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/2d/4e/2d4e7f2190107c7dfde4f0625bfbd138fd068eee.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eQuan sát hình vẽ, ta nhận thấy:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eHầu hết các hình vuông 2x2 đều có 2 ô đen và 2 ô trắng\u003c/li\u003e   \u003cli\u003eChỉ những hình vuông 2x2 trên đường chéo có đúng 1 ô đen hoặc đúng 1 ô trắng.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eNhư vậy có nghĩa là, nếu hình chữ nhật có góc trái dưới ở \u003cspan class\u003d\"tex-span\"\u003e(0, 0)\u003c/span\u003e và góc phải trên ở \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e, thì kết quả là:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003emax(0,\n  (x - 1) * (y - 1)  // số hình vuông 2x2\n  - min(x, y) + 1    // số hình vuông 2x2 trên đường chéo\n)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eĐể tính số hình vuông 2x2 trong bảng hình chữ nhật bất kỳ, ta dùng kĩ thuật tương tự như mảng cộng dồn trên 2D:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ef(x2, y2) - f(x1, y2) - f(x2, y1) + f(x1, y1)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCài đặt vô cùng đơn giản:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ca href\u003d\"http://ideone.com/E5acNW\"\u003ehappyboy99x\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://ideone.com/WSBsOe\"\u003ekc97ble\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e\u003ch1\u003e[problem:208692B]\u003c/h1\u003e\u003ch2\u003eN^6\u003c/h2\u003e\u003cp\u003eTrước hết ta xét cài đặt đơn giản N^6 như sau:\u003c/p\u003e\u003cp\u003eDuyệt qua tất cả các toạ độ của 3 điểm A, B, C. Tính diện tích tam giác, nếu bằng S thì ta tăng kết quả lên 1.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eres \u003d 0;\nfor(int ax \u003d 0; ax \u0026lt;\u003d x; ++ax)\n  for(int ay \u003d 0; ay \u0026lt;\u003d y; ++ay)\n    for(int bx \u003d ax; bx \u0026lt;\u003d x; ++bx)\n      for(int by \u003d bx \u003d\u003d ax ? ay + 1 : 0; by \u0026lt;\u003d y; ++by)\n        for(int cx \u003d bx; cx \u0026lt;\u003d x; ++cx)\n          for(int cy \u003d cx \u003d\u003d bx ? by + 1 : 0; cy \u0026lt;\u003d y; ++cy) {\n            if (abs((bx - ax) * (cy - ay) - (by - ay) * (cx - ax)) \u003d\u003d 2 * s)\n              res +\u003d 1;\n          }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eĐộ phức tạp của cài đặt này là \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e)\u003c/span\u003e, nhưng vẫn đủ nhanh để pass tất cả các test (????).\u003c/p\u003e\u003cp\u003eĐể hiểu tại sao, ta thêm 1 biến đếm để đếm số phép tính của chương trình trên (số lần ta phải tính diện tích):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint res \u003d 0;\nint cnt \u003d 0; // đếm số lần lặp\nfor(int ax \u003d 0; ax \u0026lt;\u003d x; ++ax)\n  for(int ay \u003d 0; ay \u0026lt;\u003d y; ++ay)\n    for(int bx \u003d ax; bx \u0026lt;\u003d x; ++bx)\n      for(int by \u003d bx \u003d\u003d ax ? ay + 1 : 0; by \u0026lt;\u003d y; ++by)\n        for(int cx \u003d bx; cx \u0026lt;\u003d x; ++cx)\n          for(int cy \u003d cx \u003d\u003d bx ? by + 1 : 0; cy \u0026lt;\u003d y; ++cy) {\n            cnt +\u003d 1;\n            if (abs((bx - ax) * (cy - ay) - (by - ay) * (cx - ax)) \u003d\u003d 2 * s)\n              res +\u003d 1;\n          }\n\ncout \u0026lt;\u0026lt; \u0026quot;cnt \u003d \u0026quot; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eKết quả thu được là \u003ccode\u003ecnt \u003d 147455840\u003c/code\u003e, khoảng hơn 100 triệu. Vì các phép toán đơn giản nên hoàn toàn đủ để chạy trong thời gian cho phép.\u003c/p\u003e\u003cp\u003eĐể giải thích tại sao, chú ý rằng ở đây ta chỉ for các điểm B lớn hơn A và các điểm C lớn hơn B.\u003c/p\u003e\u003cp\u003eGiả sử ta xét bài toán trên 1D, nếu ta for như sau:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor i \u003d 1..N\n  for j \u003d i+1 .. N\n    for k \u003d j+1 .. N\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ethì số phép tính là \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e * (\u003ci\u003eN\u003c/i\u003e - 1) * (\u003ci\u003eN\u003c/i\u003e - 2) / 6\u003c/span\u003e, giảm đi 6 lần. Tuy nhiên trong bài này vì là 2D nên số phép tính còn giảm đi rất nhiều.\u003c/p\u003e\u003cp\u003eCode:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ca href\u003d\"http://ideone.com/YrcAtx\"\u003ehappyboy99x\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e\u003ch2\u003eN^5\u003c/h2\u003e\u003cp\u003eNhận thấy, vì diện tích tam giác cố định, nên nếu ta đã biết 5 trong 6 toạ độ, thì việc tính toạ độ còn lại rất đơn giản. Cụ thể hơn:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eGiả sử ta for 5 biến: \u003ccode\u003eA.x\u003c/code\u003e, \u003ccode\u003eA.y\u003c/code\u003e, \u003ccode\u003eB.x\u003c/code\u003e, \u003ccode\u003eB.y\u003c/code\u003e và \u003ccode\u003eC.x\u003c/code\u003e (nói cách khác ta xác định 2 điểm A và B, rồi cố định toạ độ x của điểm C)\u003c/li\u003e   \u003cli\u003eNếu \u003ccode\u003eA.x \u003d\u003d B.x\u003c/code\u003e, trường hợp này ta xử lý riêng. Do số lần trường hợp này xảy ra chỉ là \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e\u003c/span\u003e, nên ta duyệt luôn \u003ccode\u003eC.y\u003c/code\u003e\u003c/li\u003e   \u003cli\u003eNếu \u003ccode\u003eA.x !\u003d B.x\u003c/code\u003e, bằng việc giải phương trình toán học, ta tính được 2 nghiệm của \u003ccode\u003eC.y\u003c/code\u003e. Nếu \u003ccode\u003eC.y\u003c/code\u003e nằm trong khoảng \u003cspan class\u003d\"tex-span\"\u003e[0, \u003ci\u003eY\u003c/i\u003e]\u003c/span\u003e thì ta tăng kết quả.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eCode:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ca href\u003d\"http://ideone.com/TYe9yF\"\u003ekc97ble\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e\u003ch2\u003eN^3\u003c/h2\u003e\u003cp\u003eBài này còn có cách với độ phức tạp \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003c/span\u003e, cài đặt cũng rất đơn giản, xin nhường lại cho bạn đọc.\u003c/p\u003e\u003ch1\u003e[problem:208692D]\u003c/h1\u003e\u003ch2\u003eĐếm nghịch thế\u003c/h2\u003e\u003cp\u003eGiả sử ta cần đếm số cặp nghịch thế của 1 dãy cho trước (không có thao tác thay đổi các số), thì ta có thể dễ dàng đếm bằng BIT:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (i \u003d 0; i \u0026lt; n; ++i) {\n    bit.count(0, a[i] - 1);  // đếm số số trong khoảng [0, a[i])\n    bit.update(a[i], + 1);   // thêm 1 số có giá trị a[i]\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eTruy vấn thay đổi\u003c/h2\u003e\u003cp\u003eBản chất của bài toán nghịch thế như trên là có 2 chiều: index và giá trị.\u003c/p\u003e\u003cp\u003eỞ cách đếm nghịch thế (offline) trên, ta xử lý lần lượt theo chiều index, nên có thể sử dụng CTDL 1D với chiều giá trị.\u003c/p\u003e\u003cp\u003eKhi thêm các truy vấn, thực chất bài toán trở thành 3D: thời gian, index và giá trị. Ta buộc phải xử lý theo trục thời gian, nên bài toán chỉ có thể đưa về 2D. Do đó cần sử dụng các CTDL 2D để giải quyết.\u003c/p\u003e\u003ch2\u003eCách 1: chia block\u003c/h2\u003e\u003cp\u003eChia dãy số thành \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e block, mỗi block có \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e phần tử. (Nói cách khác là \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e \u003d \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eNói theo cách hiểu về chiều của bài toán, thì ta chia block để xử lý chiều index. Sau đó ta dùng BIT để quản lý chiều giá trị.\u003c/p\u003e\u003cp\u003eNghĩa là:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eChia dãy thành \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e block, mỗi block gồm \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e phần tử\u003c/li\u003e   \u003cli\u003eỞ mỗi block, dùng 1 BIT để quản lý các số.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eBan đầu, ta khởi tạo số nghịch thế của dãy, và với mỗi block, ta thêm các số của block đó vào trong BIT:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (block \u003d 0; block \u0026lt; K; ++block) {\n    int from \u003d block * K, to \u003d from + K - 1;  // chú ý khi code thật phải cẩn thận `to` nhảy ra ngoài mảng (\u0026gt; N)\n    for (int i \u003d from; i \u0026lt;\u003d to; ++i) {\n        bit[block].update(a[i]);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eMỗi khi sửa 1 số \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003eX\u003c/i\u003e) \u003d \u003ci\u003eY\u003c/i\u003e\u003c/span\u003e, xét các cặp nghịch thế bị thay đổi (thêm vào hoặc mất đi)\u003c/p\u003e \u003cul\u003e   \u003cli\u003eGọi \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003c/span\u003e là giá trị cũ của \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003eX\u003c/i\u003e)\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eBlock trước \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eblock\u003c/i\u003e(\u003ci\u003eX\u003c/i\u003e)\u003c/span\u003e, bỏ đi các số lớn hơn \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003c/span\u003e, thêm vào các số lớn hơn \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eBlock sau \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eblock\u003c/i\u003e(\u003ci\u003eX\u003c/i\u003e)\u003c/span\u003e, bỏ đi các số nhỏ hơn \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003c/span\u003e, thêm vào các số nhỏ hơn \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eVới \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eblock\u003c/i\u003e(\u003ci\u003eX\u003c/i\u003e)\u003c/span\u003e, ta làm tương tự 2 trường hợp trên.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eĐến đây, các thao tác đều đưa về 1D.\u003c/p\u003e\u003ch2\u003eCách 2: Cây trong cây\u003c/h2\u003e\u003cp\u003eBIT1D:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint get1D(int u) { // lấy đoạn 1 - u\n    int res \u003d 0;\n    for(; u \u0026gt; 0; u -\u003d u \u0026amp; -u) {\n        res +\u003d node[u];\n    }\n    return res;\n}\n\nvoid update1D(int u, int val) { // cập nhật vị trí u\n    for(; u \u0026lt; n; u +\u003d u \u0026amp; -u) {\n        node[u] +\u003d val;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHình dung: mỗi nút của BIT là 1 cây BIT. Từ đó ta có thể code lại các thao tác update và get như sau:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint get2D(int u, int v) {  // lấy tổng hình chữ nhật (1, 1) - (u, v)\n    int res \u003d 0;\n    for (; u \u0026gt; 0; u -\u003d u \u0026amp; -u) {  // đang xét đến cây u\n        for(int x \u003d v; x \u0026gt; 0; x -\u003d x \u0026amp; -x) { // xét trên cây node[u]\n            res +\u003d node[u][v];\n        }\n    }\n    return res;\n}\nvoid update2D(int u, int v, int val) { // cập nhật điểm (u, v)\n    for(; u \u0026lt; n; u +\u003d u \u0026amp; -u) {  // đang xét cây u\n        for(int x \u003d v; x \u0026lt; n; x +\u003d x \u0026amp; -x) {\n            node[u][v] +\u003d val;\n        }\n    }\n}\n\n// node[u][v] là 1 cấu trúc dữ liệu kiểu mảng 2D, ví dụ có thể dùng map \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCài đặt như trên bị lợn, do mảng node quá lớn (hoặc nếu dùng map thì bị thêm log). Ngoài ra số nút truy cập vào cũng nhiều hơn cần thiết.\u003c/p\u003e\u003cp\u003eĐể giảm độ phức tạp, ta chỉ xét những nút cần động vào. Để làm được việc này, ta cần biết trước tất cả các truy vấn mà ta sẽ phải thực hiện, sau đó chỉ thêm các nút cần thiết vào cây:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid fakeUpdate(int u, int v) {\n    for(int x \u003d u; x \u0026lt;\u003d n; x +\u003d x \u0026amp; -x)\n        nodes[x].push_back(v);\n}\n\nvoid fakeGet(int u, int v) {\n    for(int x \u003d u; x \u0026gt; 0; x -\u003d x \u0026amp; -x)\n        nodes[x].push_back(v);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e2 hàm fakeUpdate và fakeGet tạo ra tất cả các nút cần thiết.\u003c/p\u003e\u003cp\u003eSau đấy, để thực hiện truy vấn thì ta làm kiểu này:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid update(int u, int v) {\n    for(int x \u003d u; x \u0026lt;\u003d n; x +\u003d x \u0026amp; -x)\n        for(int y \u003d lower_bound(nodes[x].begin(), nodes[x].end(), v) - nodes[x].begin() + 1; y \u0026lt;\u003d nodes[x].size(); y +\u003d y \u0026amp; -y)\n            f[x][y]++;\n}\n\nint get(int u, int v) {\n    int res \u003d 0;\n    for(int x \u003d u; x \u0026gt; 0; x -\u003d x \u0026amp; -x)\n        for(int y \u003d upper_bound(nodes[x].begin(), nodes[x].end(), v) - nodes[x].begin(); y \u0026gt; 0; y -\u003d y \u0026amp; -y)\n            res +\u003d f[x][y];\n    return res;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eChú ý là sau khi tìm được tất cả các nút cần truy vấn, ta nén lại (đánh số từ 1 đến số nút trên mỗi cây BIT), và từ đó thực hiện truy vấn nhanh chóng.\u003c/p\u003e\u003c/div\u003e","tags":[]}}