{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1479631188,"rating":9,"authorHandle":"boJack_horseman","modificationTimeSeconds":1479633995,"id":48486,"title":"\u003cp\u003eA very simple algorithm of creating a type of fractals.\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;graphics.h\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n\nusing namespace std;\n\nstruct point{\n\tint x,y;\n} P[100],p1,p2;\nint p\u003d0;\n\ndouble angle(point a,point b){\n\treturn atan2(b.y-a.y,b.x-a.x);\n}\n\ndouble dist(point a,point b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));\n}\n\nvoid fractal(point a,point b,int k){\n\t\n\tdouble alpha \u003d angle(a,b)-angle(P[1],P[p]);\n\t\n\tpoint A[p+2];\n\tA[1] \u003d a;\n\t\n\tfor(int i \u003d 2;i\u0026lt;\u003dp;i++){\n\t\tA[i].y \u003d A[1].y + sin(alpha+angle(P[1],P[i]))*dist(P[1],P[i])*dist(a,b)/dist(P[1],P[p]);\n\t\tA[i].x \u003d A[1].x + cos(alpha+angle(P[1],P[i]))*dist(P[1],P[i])*dist(a,b)/dist(P[1],P[p]);\t\t\n\t}\n\t\n\tfor(int i \u003d 1;i\u0026lt;p;i++)\n\t\tif(k) fractal(A[i],A[i+1],k-1);\t\n\t\telse line(A[i].x, A[i].y,A[i+1].x, A[i+1].y);\n}\n\nvoid init(){\n   int gd \u003d DETECT,gm;\n   initgraph(\u0026amp;gd,\u0026amp;gm,NULL);\n}\n\nvoid read(){\n   ifstream cin(\u0026quot;fractal.in\u0026quot;);\t\n   cin \u0026gt;\u0026gt; p;\n   for(int i \u003d 1;i\u0026lt;\u003dp;i++) cin \u0026gt;\u0026gt; P[i].x \u0026gt;\u0026gt; P[i].y;\n}\n\nint main(){\n   read();\n   init();\n   cleardevice();\n\n   fractal(P[1],P[p],5); \n\t   \n   delay(60*1000);\n   closegraph();\n   return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOnce I wanted to play with fractals, but I couldn\u0027t find a lightweight and easy tool for doing this. And I decided to create one. There are many approaches to creating fractals I was based on idea that we can create a fractal if we have a set of segments that are connected to each other and every segment we replace with the entire shape: \u003ca href\u003d\"https://www.youtube.com/watch?v\u003dYiGBNNDDgH0\u0026amp;feature\u003dyoutu.be\u0026amp;t\u003d155\"\u003ehttps://www.youtube.com/watch?v\u003dYiGBNNDDgH0\u0026amp;feature\u003dyoutu.be\u0026amp;t\u003d155\u003c/a\u003e; \u003c/p\u003e\u003cp\u003eI don\u0027t think this algorithm needs explanation, there is a quite simple math. And my question is: what algorithm would you use? what other approaches do you know?\u003c/p\u003e\u003cp\u003eP.S: I know my algorithm may be slightly optimised but I am too lazy to do this. P.S.S There is my tool based on this algorithm: \u003ca href\u003d\"https://play.google.com/store/apps/details?id\u003dwcreations.fractal\"\u003eFractal Maker\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["#fractals","#algorithms","#geometry","#math"]}}