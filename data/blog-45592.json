{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1466586040,"rating":133,"authorHandle":"Gassa","modificationTimeSeconds":1466691437,"id":45592,"title":"\u003cp\u003eCodeforces Marathon Round 1 — discussion\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThe Codeforces Marathon Round 1 is over (\u003ca href\u003d\"/blog/entry/45592?#comment-301795\"\u003eresults comment\u003c/a\u003e). As the final solutions are being tested, I think many participants will want to share ideas and learn alternative approaches. I\u0027ll start with the ideas I tried myself, both successful and not; as I\u0027ve seen in the submissions, the contestants have more ideas, but I hope they will share themselves. For each of the solutions below, the numbers in square brackets are minimum, mean and maximum score when running on 1000 tests locally. I have to note in advance that the constants and technicalities in the solutions are not considered optimal: the score just shows approximate relation between ideas and may often be improved a bit. -----\u003c/p\u003e\u003ch6\u003e\u003cstrong\u003eSolution 1\u003c/strong\u003e [\u003ccode\u003e4099 4159.699 4288\u003c/code\u003e]: random.\u003c/h6\u003e\u003cp\u003eJust print 5000 random bits 100 times.\u003c/p\u003e\u003ch6\u003e\u003cstrong\u003eSolution 2\u003c/strong\u003e [\u003ccode\u003e4160 4226.294 4365\u003c/code\u003e]: last bit memorization.\u003c/h6\u003e\u003cp\u003eThe last checked bit is always wrong. For example, if the answer for an attempt is the number 4050, it means that the error number 2000 happened exactly on position 4050 of our string. Let us fix the right value of this bit. When subsequent random strings are generated, all fixed bits have their known values, and other bits are generated randomly.\u003c/p\u003e\u003ch6\u003e\u003cstrong\u003eSolution 3\u003c/strong\u003e [\u003ccode\u003e4182 4291.374 4453\u003c/code\u003e]: find several bits.\u003c/h6\u003e\u003cp\u003eThis is a two-part solution. In the first part (90 attempts) the attempts go in 45 pairs. The first attempt of pair \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is generated randomly (except for the fixed bits which we already know). The second attempt of pair \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e differs just in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th bit and in the last checked bit.\u003c/p\u003e\u003cp\u003eWhat information can we learn from such a pair? For example, let the first attempt give the result 3980, and the second one (with bits 1 and 3980 changed) resulted in 3975. This means that, firstly, bit 1 was right in the first attempt (because it got further). Secondly, error 2000 of the second attempt is error 1999 of the first one, so between bits 3975 and 3980, there are no errors.\u003c/p\u003e\u003cp\u003eSimilarly, if the result of the second attempt is greater, for example, 3981, we know that bit 1 was right in the second attempt, and also that there are no errors between 3980 and 3981 (this time, it does not help because there are no bits either).\u003c/p\u003e\u003cp\u003eFor a pair of attempts, we find the exact values of three bits on average.\u003c/p\u003e\u003cp\u003eIn the second part of the solution (the remaining 10 attempts), let us just generate random strings except that we take fixed bits into account. There are 135 fixed bits on average, and one more after every attempt.\u003c/p\u003e\u003ch6\u003e\u003cstrong\u003eSolution 4\u003c/strong\u003e [\u003ccode\u003e4260 4369.927 4498\u003c/code\u003e]: find several bits symmetrically.\u003c/h6\u003e\u003cp\u003eThis is a two-part solution. In the first part (90 attempts), the first attempt is random, and each subsequent (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th) attempt takes the previous one and inverts bit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and the last checked bit. As in solution 3, observing the change in answer, we can not only find the true value of bit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e for future use, but also find two bits on average around 4000. However, now we find three bits in each attempt, not in each pair. Note that we can\u0027t put the right values of the first 89 bits right away, so the bits we learn at the end are more symmetrically distributed around 4000.\u003c/p\u003e\u003cp\u003eIn the second part of the solution (the remaining 10 attempts), let us just generate random strings except that we take fixed bits into account. There are 267 fixed bits on average, and one more after every attempt.\u003c/p\u003e \u003chr /\u003e\u003cp\u003e\u003cem\u003eThat\u0027s it for my solutions which find some particular bits.\u003c/em\u003e Looking at the preliminary scoreboard, we can conclude that more than half of the participants invented something better. The useful heuristic to take to other solutions is to always memorize that the last checked bit is wrong.\u003c/p\u003e \u003chr /\u003e\u003ch6\u003e\u003cstrong\u003eSolution 5\u003c/strong\u003e [\u003ccode\u003e4429 4533.129 4671\u003c/code\u003e]: segment inversion.\u003c/h6\u003e\u003cp\u003eSplit our 5000 bits into segments of length, say, 45. For the first attempt, generate a random string, and in each subsequent attempt, invert the next segment. After inverting, we compare two numbers and know for sure which version was better: inverted or non-inverted; choose the best of the two and proceed to next attempt.\u003c/p\u003e\u003cp\u003eWhy does this work at all? Intuitively, the average deviation on a segment is large enough, so there will be enough segments for which inversion changes the answer much: for example, if a segment contained 19 right bits out of 45, after inverting, there will be 26 of them. If, on the contrary, we transformed 26 into 19 — return the 26 (and the previous result, too) by inverting back.\u003c/p\u003e\u003cp\u003eThe constant 45 is a rough estimate; it seems that many participants chose 40 in similar-looking solutions.\u003c/p\u003e\u003ch6\u003e\u003cstrong\u003eSolution 6\u003c/strong\u003e [\u003ccode\u003e4399 4582.368 4723\u003c/code\u003e]: segment inversion with recycling.\u003c/h6\u003e\u003cp\u003ePut the 4000 first bit positions in the \u0026quot;present\u0026quot; pool, and the remaining 1000 positions in the \u0026quot;future\u0026quot; pool. For the first attempt, take 79 random bits from the \u0026quot;present\u0026quot; pool and invert them all. If the result changed by more than 10, it means that the inverted \u0026quot;segment\u0026quot; has a large enough deviation. Let\u0027s use it: fix all these 79 bits in the better of the two states (either leave every bit as it is, or invert every bit). Otherwise, let\u0027s also put the bits into the better of two states, but instead of fixing the bits, put them into the \u0026quot;future\u0026quot; pool.\u003c/p\u003e\u003cp\u003eWhen the \u0026quot;present\u0026quot; pool is empty, look at the \u0026quot;future\u0026quot; pool, move all bits visited at least once (bit 4999 is most likely not visited) to the new \u0026quot;present\u0026quot; pool and continue.\u003c/p\u003e\u003cp\u003eAs we now reuse bits which don\u0027t give us much profit when fixed, we can take longer \u0026quot;segments\u0026quot;: their length is 79 instead of 45 in solution 5. This means that the average deviation in a \u0026quot;segment\u0026quot; also increased.\u003c/p\u003e\u003cp\u003eThe constants 79 and 10 were chosen by a small search.\u003c/p\u003e\u003ch6\u003e\u003cstrong\u003eSolution 7\u003c/strong\u003e [\u003ccode\u003e4539 4702.079 4878\u003c/code\u003e]: segment inversion with recycling and memorizing.\u003c/h6\u003e\u003cp\u003eDo everything as in solution 6, but recall the idea from the previous line of solutions: the last checked bit is always wrong. The profit from this idea has almost no dependence on large segment inversion.\u003c/p\u003e\u003cp\u003eIn this version, it made sense to make the segment even longer: the constants 79 and 10 changed to 99 and 18.\u003c/p\u003e \u003chr /\u003e\u003cp\u003e\u003cem\u003eThese were solutions with segment inversion.\u003c/em\u003e The best of them achieves the rank of 20-30 in the preliminary scoreboard. The weak sides are that we change only a small portion of the string, and as a result get only few bits of information on average. Additionally, we fix the whole good segment forever. Which of these can be improved and how is a story for some of the top performers to tell.\u003c/p\u003e \u003chr /\u003e\u003ch6\u003e\u003cstrong\u003eSolution 8\u003c/strong\u003e [\u003ccode\u003e4251 4403.645 4594\u003c/code\u003e]: discrete probabilistic in each position.\u003c/h6\u003e\u003cp\u003eLet us make 99 random attempts. In each of the 5000 positions, memorize the probable bits. For each attempt with result at least 4000, mark its bits up to the last checked one as probable in their positions. For each attempt with result less than 4000, invert it and mark inverted bits up to the last checked one as probable.\u003c/p\u003e\u003cp\u003eIn the last attempt, for each position, choose the option which was marked more times as probable.\u003c/p\u003e\u003ch6\u003e\u003cstrong\u003eSolution 9\u003c/strong\u003e [\u003ccode\u003e4433 4601.678 4773\u003c/code\u003e]: discrete probabilistic in each position with memorizing.\u003c/h6\u003e\u003cp\u003eLet us try to improve the previous solution.\u003c/p\u003e\u003cp\u003eFirst, recall that the last checked bit is always wrong, and fix all such bits.\u003c/p\u003e\u003cp\u003eSecond, learn to use not only the sign of the result (trivially: is it less than 4000), but also the magnitude. For example, if 2000 errors are somehow distributed among 4001 bits, it is less informative than 2000 errors distributed among 4100 bits.\u003c/p\u003e\u003cp\u003eTaking fixed bits into account, we can translate each attempt into a piece of information of the form \u0026quot;there are 1999 errors in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e bits\u0026quot;. In each of these \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e bits, record that the probability of it being right is \u003cspan class\u003d\"tex-span\"\u003e1999 / \u003ci\u003et\u003c/i\u003e\u003c/span\u003e. In the end, just take an average of all such records.\u003c/p\u003e\u003cp\u003eIn the last attempt, for each position, choose the option which turned out to be more probable.\u003c/p\u003e \u003chr /\u003e\u003cp\u003e\u003cem\u003eAround one third of the contestants implemented something better than the described solutions which calculate probabilities separately in every position.\u003c/em\u003e\u003c/p\u003e \u003chr /\u003e\u003cp\u003eThe next idea is full inversion. Let us use attempts in pairs, and the second attempt of each pair be full bitwise inversion of the first. Each such pair of attempts gives information in the form \u0026quot;in the segment from \u003ccode\u003elo\u003c/code\u003e to \u003ccode\u003ehi\u003c/code\u003e, there are exactly \u003ccode\u003eerr\u003c/code\u003e errors\u0026quot;. Indeed, let the first attempt of a pair give result 4015, and the second 3980. In total, there are 4000 errors in the segments \u003ccode\u003e[1, 3980]\u003c/code\u003e and \u003ccode\u003e[1, 4015]\u003c/code\u003e. Moreover, there are exactly 3980 errors in total from 1 to 3980: each bit was once in each of the two possible states. So, there are exactly 20 errors from bit 3981 to bit 4015.\u003c/p\u003e\u003cp\u003eWe can now perform different operations with these segments: intersect them, search for a string conforming to all gathered information, if it is too hard to find, search for the most conforming string. My solutions with such segments get mean results between 4400 and 4500, but are already technically involved. Sure one can do better.\u003c/p\u003e \u003chr /\u003e\u003cp\u003eA bit of problem history. Initially, it was designed as a hard probabilistic problem for a contest with ACM ICPC rules. The plan was to try several approaches and see if the simple and weak ones can be separated from thoughtful and strong by choosing the appropriate constraints. However, the first few solution ideas refused to line up in an order resembling their complexity, so I had to put the problem on hold. On the other side, this problem fits well in a contest with partial scoring since there are a few quite different approaches which are easy enough to invent and implement.\u003c/p\u003e\u003cp\u003eLast but not least, I owe my thanks to Natalya Ginzburg (\u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/naagi\" title\u003d\"Candidate Master naagi\"\u003enaagi\u003c/a\u003e), Andrei Lopatin (\u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/KOTEHOK\" title\u003d\"Master KOTEHOK\"\u003eKOTEHOK\u003c/a\u003e) and Mike Mirzayanov (\u003ca class\u003d\"rated-user user-admin\" href\u003d\"/profile/MikeMirzayanov\" title\u003d\"Headquarters, MikeMirzayanov\"\u003eMikeMirzayanov\u003c/a\u003e) for their help in preparing and running the contest.\u003c/p\u003e\u003c/div\u003e","tags":["marathon"]}}