{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1419197347,"rating":60,"authorHandle":"Corei13","modificationTimeSeconds":1429042290,"id":15310,"title":"\u003cp\u003eC++11 Template Metaprogramming â€” Compile Time Computations\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThe main challenges with compile time computations are\u003c/p\u003e \u003cul\u003e   \u003cli\u003ewe can only work with constants (so no looping is possible)\u003c/li\u003e   \u003cli\u003emaximum recursion depth is very limited compared to runtime computations (for example, maximum recursion depth is only 900 in g++)\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eHere is an example of how to use template meta programming for compile time computations. The example shows how to implement primality checking in compile time, but the same principle can be applied to other problems. For instance, in the main function, replacing \u003ccode\u003eGenerate \u0026lt;level, Prime\u0026gt;::value\u003c/code\u003e by \u003ccode\u003eGenerate \u0026lt;level, Sqrt\u0026gt;::value\u003c/code\u003e will generate integer square roots for all numbers between \u003ccode\u003e[0, 2^level)\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nnamespace Helpers {\n    template \u0026lt;int lhs, int rhs\u0026gt;\n    struct Plus {\n        static const int value \u003d lhs + rhs;\n    };\n    struct True {\n        static const bool value \u003d true;\n    };\n    struct False {\n        static const bool value \u003d false;\n    };\n    // Array \u0026lt;T, T args...\u0026gt; contains the array {args...} of size ::size at ::value\n    // For example if A \u003d Array \u0026lt;int, 1, 2, 3\u0026gt;, then A::value[] \u003d {1, 2, 3} and A::size \u003d 3\n    template \u0026lt;typename T, T... args\u0026gt;\n    struct Array {\n        static const T value[sizeof...(args)];\n        static const int size \u003d sizeof...(args);\n    };\n    template \u0026lt;typename T, T... args\u0026gt;\n    const T Array \u0026lt;T, args...\u0026gt;::value[sizeof...(args)] \u003d {args...};\n}\n\n// Sqrt \u0026lt;N\u0026gt;::value is the integer square root of N\ntemplate \u0026lt;int N\u0026gt;\nstruct Sqrt {\n    template \u0026lt;int lo, int hi\u0026gt;\n    struct Helper {\n        static const int mid \u003d (lo + hi + 1) / 2;\n        static const int value \u003d conditional \u0026lt; (N / mid \u0026lt; mid), Helper \u0026lt; lo, mid - 1 \u0026gt;, Helper \u0026lt;mid, hi\u0026gt; \u0026gt;::type::value;\n    };\n    template \u0026lt;int n\u0026gt;\n    struct Helper \u0026lt;n, n\u0026gt; {\n        static const int value \u003d n;\n    };\n    static const int value \u003d Helper \u0026lt;0, N\u0026gt;::value;\n};\n\n\n// Prime \u0026lt;N\u0026gt;::value is true if and only if N is a prime\ntemplate \u0026lt;int N\u0026gt;\nstruct Prime {\n    // Helper::value is true iff any prime in [lo, hi] divides N\n    template \u0026lt;int lo, int hi\u0026gt;\n    struct Helper {\n        static const int mid \u003d (lo + hi) / 2;\n        static const bool value \u003d conditional \u0026lt; Helper \u0026lt;lo, mid\u0026gt;::value, Helpers::True, Helper \u0026lt; mid + 1, hi \u0026gt;\u0026gt;::type::value;\n    };\n    template \u0026lt;int d\u0026gt;\n    struct Helper \u0026lt;d, d\u0026gt; {\n        static const bool value \u003d Prime \u0026lt;d\u0026gt;::value and N % d \u003d\u003d 0;\n    };\n    static const bool value \u003d not conditional \u0026lt; (N \u0026lt;\u003d 1), Helpers::True, Helper \u0026lt;1, Sqrt \u0026lt;N\u0026gt;::value\u0026gt; \u0026gt;::type::value;\n};\n\n/*\n    Generate \u0026lt;N, F\u0026gt; contains the Helpers::Array with ::value \u003d {F\u0026lt;0\u0026gt;::value, ..., F\u0026lt;2 ^ N - 1\u0026gt;::value} at ::value\n    Example:\n        using A \u003d Generate\u0026lt;5, Sqrt\u0026gt;::value;\n        for (int i \u003d 0; i \u0026lt; A::size; ++i) {\n            cout \u0026lt;\u0026lt; A::value[i] \u0026lt;\u0026lt; endl;\n        }\n*/\n\ntemplate \u0026lt;int N, template \u0026lt;int\u0026gt; class F\u0026gt;\nstruct Generate {\n    template \u0026lt;int n, int... args\u0026gt;\n    struct Helper {\n        using value \u003d typename Helper \u0026lt; n - 1, args..., Helpers::Plus \u0026lt;args, sizeof...(args)\u0026gt;::value... \u0026gt;::value;\n    };\n\n    template \u0026lt;int... args\u0026gt;\n    struct Helper \u0026lt;0, args...\u0026gt; {\n        using value \u003d Helpers::Array \u0026lt;decltype(F \u0026lt;0\u0026gt;::value), F \u0026lt;args\u0026gt;::value...\u0026gt;;\n    };\n    using value \u003d typename Helper \u0026lt;N, 0\u0026gt;::value;\n};\n\n\nint main(int argc, char const *argv[]) {\n    const int level \u003d 10; // for primes upto 2^level\n    using A \u003d Generate \u0026lt;level, Prime\u0026gt;::value;\n    cout \u0026lt;\u0026lt; A::size \u0026lt;\u0026lt; endl;\n    for (int i \u003d 0; i \u0026lt; A::size; ++i) {\n        cout \u0026lt;\u0026lt; \u0026quot;\u0026gt; \u0026quot; \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; A::value[i] \u0026lt;\u0026lt; endl;\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["c++11","template","metaprogrammimg"]}}