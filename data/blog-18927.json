{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1435482809,"rating":72,"authorHandle":"xuanquang1999","modificationTimeSeconds":1436170390,"id":18927,"title":"\u003cp\u003eCodeforces Round #310 Editorial for Div2A — Div2D (Div1B)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello everyone, this is my editorial for Round #310. I decided to write one since the author of this round didn\u0027t have time to do it. Currently, there\u0027s only Div2A and Div2B available, and I\u0027ll try to write editorial for Div1A and Div1B soon (about Div1C and Div1D, \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/microtony\" title\u003d\"Candidate Master microtony\"\u003emicrotony\u003c/a\u003e has already written a nice tutorial for them (you can check out \u003ca href\u003d\"//codeforces.com/blog/entry/18923\"\u003ehere\u003c/a\u003e), and Div1E is too difficult for me).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD\u003c/strong\u003e: Div2C-Div1A is available now!\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD2\u003c/strong\u003e: Div2D-Div1B is available now!\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/556/A\"\u003eDiv2A — Case of the Zeros and Ones\u003c/a\u003e\u003c/h1\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/5a/1f/5a1f6c39bb2d16a657ac40295a62235243733d1f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eFirst, we can come up with a naive solution. While there\u0027s still some position i that \u0027remove-able\u0027 (\u003ccode\u003e(s[i] \u003d \u00270\u0027 and s[i+1] \u003d \u00271\u0027)\u003c/code\u003e or \u003ccode\u003e(s[i] \u003d \u00271\u0027 and s[i+1] \u003d \u00270\u0027)\u003c/code\u003e), we\u0027ll remove \u003ccode\u003es[i]\u003c/code\u003e and \u003ccode\u003es[i+1]\u003c/code\u003e from the string. However, in the worst case (contain all character \u003ccode\u003e\u00270\u0027\u003c/code\u003e first, then character \u003ccode\u003e\u00271\u0027\u003c/code\u003e or vise-versa), the complexity is \u003cstrong\u003eO(n^2)\u003c/strong\u003e and will surely got TLE.\u003c/p\u003e\u003cp\u003eWe should optimize this solution by using stack. Push each character in string s to the stack, and while pushing, check if the top two element of the stack is \u003ccode\u003e(\u00270\u0027 and \u00271\u0027)\u003c/code\u003e or \u003ccode\u003e(\u00271\u0027 and \u00270\u0027)\u003c/code\u003e (or we can simply write \u003ccode\u003eabs(stack[top]-stack[top-1) \u003d 1\u003c/code\u003e). If this happen, remove them from stack (\u003ccode\u003etop:\u003dtop-2\u003c/code\u003e). The answer is the number of character left in the stack.\u003c/p\u003e\u003cp\u003e\u003cem\u003eSolution using Stack\u003c/em\u003e: \u003ca href\u003d\"/contest/556/submission/11816506\" title\u003d\"Submission 11816506 by xuanquang1999\"\u003e11816506\u003c/a\u003e\u003c/p\u003e\u003cp\u003eSound a bit too complicated for Div2A, right? There must be a more simple solution. We should notice that if there\u0027s still some zero and one in the string, there must be at least one position that \u0027remove-able\u0027. So, we can remove one character \u003ccode\u003e\u00270\u0027\u003c/code\u003e and one character \u003ccode\u003e\u00271\u0027\u003c/code\u003e from the string until one type of character run out. We can come up with more simple solution with these analysis: just count the number of character \u003ccode\u003e\u00270\u0027\u003c/code\u003e and \u003ccode\u003e\u00271\u0027\u003c/code\u003e in the string, and the answer is \u003ccode\u003eabs(cnt0-cnt1)\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003cem\u003eSolution with some analysis\u003c/em\u003e: \u003ca href\u003d\"/contest/556/submission/11830868\" title\u003d\"Submission 11830868 by xuanquang1999\"\u003e11830868\u003c/a\u003e\u003c/p\u003e\u003cp\u003eBoth of the solution has complexity \u003cstrong\u003eO(n)\u003c/strong\u003e.\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"//codeforces.com/contest/556/problem/B\"\u003eDiv2B — Case of Fake Numbers\u003c/a\u003e\u003c/h1\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/da/a8/daa8e1819eb1a3c448bffdb75d16d983e381520a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eTo solve this problem, first, we should notice that after \u003ccode\u003en\u003c/code\u003e action, the gear will turn back to the initial state. So, if solution exist, the number of action to get it must be less than \u003ccode\u003en\u003c/code\u003e. We can get an solution: just keep performing the action until we get the require structure (answer is \u003ccode\u003e\u0027Yes\u0027\u003c/code\u003e) or the number of action goes equal \u003ccode\u003en\u003c/code\u003e (answer is \u003ccode\u003e\u0027No\u0027\u003c/code\u003e). Complexity is \u003cstrong\u003eO(n^2)\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003e\u003cem\u003eMy solution\u003c/em\u003e: \u003ca href\u003d\"/contest/556/submission/11816203\" title\u003d\"Submission 11816203 by xuanquang1999\"\u003e11816203\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis solution is already fast enough to get AC. But we can easily optimize it further. We can notice that we will need \u003ccode\u003ek \u003d (n-a[1]) mod n\u003c/code\u003e move to get a[1] equal to 0, so we can just calculate a[i] after \u003ccode\u003ek\u003c/code\u003e move (whick is \u003ccode\u003e(a[i]-k+n) mod n, with i mod 2 \u003d 0\u003c/code\u003e and \u003ccode\u003e(a[i]-k+n) mod n, with i mod 2 \u003d 1\u003c/code\u003e) and check if this is the required structure. Complexity is now \u003cstrong\u003eO(n)\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003e\u003cem\u003eThe better solution\u003c/em\u003e: \u003ca href\u003d\"/contest/556/submission/11816999\" title\u003d\"Submission 11816999 by xuanquang1999\"\u003e11816999\u003c/a\u003e\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"//codeforces.com/contest/555/problem/A\"\u003eDiv2C-Div1A — Case of Matryoshkas\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eTo make thing easier to explain, we will use \u0027Box\u0027 instead of \u0027Matryoshkas\u0027 (Now this problem\u0027s name should be \u0027Case of Box\u0027 :D)\u003c/p\u003e\u003cp\u003eConsider the following test:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e7 3\n2 1 2 6\n3 3 4 5\n1 7\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe following image demonstrate the test:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/19/ff/19ffed4138d08c3e29acf9acbdf0f3e7a4480b7f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eWe know that we can put box \u003ccode\u003ea\u003c/code\u003e in box \u003ccode\u003eb\u003c/code\u003e only if box b doesn\u0027t contain any other boxes or contained in any other box. So, that mean box \u003ccode\u003eb\u003c/code\u003e must be alone. So, it would be make sense if we put all the box, which still inside some other box, out (in an appropriate order). However, we don\u0027t have to do this with the sequence \u003ccode\u003e1, 2, ..., x\u003c/code\u003e since nothing can be put in box \u003ccode\u003e1\u003c/code\u003e, and we can just put that sequence of box in box \u003ccode\u003ex+1\u003c/code\u003e later. For example, with the above test, the process is described in below picture.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/9f/f2/9ff23518f99d494de4ea1c1a618323f52d67923d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThis process take \u003ccode\u003en-(k-1)-x\u003c/code\u003e moves.\u003c/p\u003e\u003cp\u003eThen, we can put sequence of box \u003ccode\u003e1, 2, ..., x\u003c/code\u003e in box \u003ccode\u003ex+1\u003c/code\u003e, box \u003ccode\u003ex+1\u003c/code\u003e in box \u003ccode\u003ex+2\u003c/code\u003e, ... box \u003ccode\u003en-1\u003c/code\u003e in box \u003ccode\u003en\u003c/code\u003e. For example, with the above test, the process is described in below picture (again).\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/54/4c/544ca1d961ec81c71e2905e4c1b92809ff6ad94f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cimg alt\u003d\" \" src\u003d\"/predownloaded/30/d8/30d8145fdb57446fd87c84c8f1cb137ea00bca64.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThis process take \u003ccode\u003en-x\u003c/code\u003e moves. \u003c/p\u003e\u003cp\u003eThe final answer is \u003ccode\u003e(n-(k-1)-x)+(n-x)\u003c/code\u003e \u003d \u003ccode\u003e2*(n-x)-k+1\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003cem\u003eMy solution:\u003c/em\u003e \u003ca href\u003d\"/contest/555/submission/11821602\" title\u003d\"Submission 11821602 by xuanquang1999\"\u003e11821602\u003c/a\u003e\u003c/p\u003e\u003cp\u003eComplexity: \u003cstrong\u003eO(n)\u003c/strong\u003e\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"//codeforces.com/contest/555/problem/B\"\u003eDiv2D-Div1B — Case of Fugitive\u003c/a\u003e\u003c/h1\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/f6/33/f6337ab394b9aa3932ada11906321f0e536e6b4f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eCall \u003ccode\u003eb(lb, rb, jth)\u003c/code\u003e the \u003ccode\u003ej-th\u003c/code\u003e bridge to build has required length from \u003ccode\u003elb\u003c/code\u003e to \u003ccode\u003erb\u003c/code\u003e (inclusive). We know that \u003ccode\u003eb[j] \u003d (li[j+1]-ri[j], ri[j+1]-li[j], j)\u003c/code\u003e. Call \u003ccode\u003ec(len, ith)\u003c/code\u003e the \u003ccode\u003ei-th\u003c/code\u003e available bridge that has length of \u003ccode\u003elen\u003c/code\u003e, with \u003ccode\u003ec[i] \u003d (a[i], i)\u003c/code\u003e. We will also need array \u003ccode\u003eans[i]\u003c/code\u003e to store the answer for the \u003ccode\u003ei-th\u003c/code\u003e bridge to build.\u003c/p\u003e\u003cp\u003eNow, we\u0027ll assign \u003ccode\u003eans[i] \u003d -1\u003c/code\u003e. Sort \u003ccode\u003eb\u003c/code\u003e in increase of \u003ccode\u003elb\u003c/code\u003e, then increase of \u003ccode\u003erb\u003c/code\u003e. Sort \u003ccode\u003ec\u003c/code\u003e in increase of \u003ccode\u003elen\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eNow, we will iterate each element of c from left to right. For each c[i], we will consider all the bridge to build that has minimum length less or equal to \u003ccode\u003ec[i].len\u003c/code\u003e (\u003ccode\u003ewhile(b[j].lb \u0026lt;\u003d c[i].len) ++j\u003c/code\u003e) and add them to the \u0027to_build\u0027 list. Then, choose the bridge in \u0027to_build\u0027 list that has the smallest \u003ccode\u003erb\u003c/code\u003e and we\u0027ll get \u003ccode\u003eans[b[j].jth] \u003d c[i].ith\u003c/code\u003e (remember to check that \u003ccode\u003ec[i].len \u0026lt;\u003d b[j].rb\u003c/code\u003e, too!). At the end, if there\u0027s still some \u003ccode\u003eans[i] \u003d -1\u003c/code\u003e, then there is no answer. Otherwise, say \u0027Yes\u0027 and print all \u003ccode\u003eans[i]\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eWe\u0027ll have \u003cstrong\u003eO(n^2 + m log m)\u003c/strong\u003e solution now. To improve this, we need to find the bridge in \u0027to_build\u0027 list that has the smallest \u003ccode\u003erb\u003c/code\u003e in \u003cstrong\u003eO(log n)\u003c/strong\u003e, which can be done by using \u003ccode\u003eC++\u003c/code\u003e \u003ccode\u003estd::set\u003c/code\u003e to store the \u0027to_build\u0027 list.\u003c/p\u003e\u003cp\u003e\u003cem\u003eMy solution\u003c/em\u003e: \u003ca href\u003d\"/contest/555/submission/11830446\" title\u003d\"Submission 11830446 by xuanquang1999\"\u003e11830446\u003c/a\u003e\u003c/p\u003e\u003cp\u003eComplexity: \u003cstrong\u003eO(n log n + m log m)\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}