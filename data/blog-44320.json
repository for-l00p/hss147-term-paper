{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1460460538,"rating":0,"authorHandle":"YamiNoKirin","modificationTimeSeconds":1460460538,"id":44320,"title":"\u003cp\u003eQuestion About Tarjan\u0027s Algorithm for Strongly Connected Components\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eMy question, as I have mentioned in the title, refers to Tarjan\u0027s algorithm for SCC. The issue would be that if I keep a global variable level that never decreases, a correct result will be achieved. On the other hand, if level is a parameter for the Dfs and starts at 1 for every component, the result is no longer correct. How do the two algorithms differ?\u003c/p\u003e\u003cp\u003eHere is a correct version of the algorithm: level does not get reinitialised for each Dfs.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n\nusing namespace std;\n\nconst int MaxN \u003d 100005;\n\nifstream cin(\u0026quot;ctc.in\u0026quot;);\nofstream cout(\u0026quot;ctc.out\u0026quot;);\n\nvector \u0026lt;int\u0026gt; G[MaxN], StrongCom, partial_ans;\nvector \u0026lt;vector \u0026lt;int\u0026gt;\u0026gt; Ans;\n\nint depth[MaxN], highest[MaxN], UseRmv[MaxN];\nint n, m, level;\n\nvoid BuildStrongComp(int end_node) {\n  int curr_node;\n\n  do {\n    curr_node \u003d StrongCom.back();\n    StrongCom.pop_back();\n    partial_ans.push_back(curr_node);\n    UseRmv[curr_node] \u003d 2;\n  } while(!StrongCom.empty() and curr_node !\u003d end_node);\n\n  Ans.push_back(partial_ans);\n  partial_ans.clear();\n}\n\nvoid Dfs(int node \u003d 1) {\n  UseRmv[node] \u003d 1;\n  depth[node] \u003d ++level;\n  highest[node] \u003d level;\n  StrongCom.push_back(node);\n\n  for(auto nxt: G[node]) {\n    if(UseRmv[nxt] \u003d\u003d 0) {\n      Dfs(nxt);\n      highest[node] \u003d min(highest[node], highest[nxt]);\n    }\n    else if(UseRmv[nxt] \u003d\u003d 1) {\n      highest[node] \u003d min(highest[node], highest[nxt]);\n    }\n  }\n\n  if(highest[node] \u003d\u003d depth[node]) {\n    BuildStrongComp(node);\n  }\n}\n\nint main() {\n  cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\n  for(int i \u003d 1; i \u0026lt;\u003d m; ++i) {\n    int a, b;\n    cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n    G[a].push_back(b);\n  }\n\n  for(int i \u003d 1; i \u0026lt;\u003d n; ++i) {\n    if(UseRmv[i]) {\n      continue;\n    }\n\n    Dfs(i);\n  }\n\n  cout \u0026lt;\u0026lt; Ans.size() \u0026lt;\u0026lt; \u0027\\n\u0027;\n\n  for(auto ans: Ans) {\n    for(auto it: ans) {\n      cout \u0026lt;\u0026lt; it \u0026lt;\u0026lt; \u0027 \u0027;\n    }\n\n    cout \u0026lt;\u0026lt; \u0027\\n\u0027;\n  }\n  return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe second and apparently wrong version of the same code would be the following:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n\nusing namespace std;\n\nconst int MaxN \u003d 100005;\n\nifstream cin(\u0026quot;ctc.in\u0026quot;);\nofstream cout(\u0026quot;ctc.out\u0026quot;);\n\nvector \u0026lt;int\u0026gt; G[MaxN], StrongCom, partial_ans;\nvector \u0026lt;vector \u0026lt;int\u0026gt;\u0026gt; Ans;\n\nint depth[MaxN], highest[MaxN], UseRmv[MaxN];\nint n, m;\n\nvoid BuildStrongComp(int end_node) {\n  int curr_node;\n\n  do {\n    curr_node \u003d StrongCom.back();\n    StrongCom.pop_back();\n    partial_ans.push_back(curr_node);\n    UseRmv[curr_node] \u003d 2;\n  } while(!StrongCom.empty() and curr_node !\u003d end_node);\n\n  Ans.push_back(partial_ans);\n  partial_ans.clear();\n}\n\nvoid Dfs(int node \u003d 1, int level \u003d 1) {\n  UseRmv[node] \u003d 1;\n  depth[node] \u003d level;\n  highest[node] \u003d level;\n  StrongCom.push_back(node);\n\n  for(auto nxt: G[node]) {\n    if(UseRmv[nxt] \u003d\u003d 0) {\n      Dfs(nxt, level + 1);\n      highest[node] \u003d min(highest[node], highest[nxt]);\n    }\n    else if(UseRmv[nxt] \u003d\u003d 1) {\n      highest[node] \u003d min(highest[node], highest[nxt]);\n    }\n  }\n\n  if(highest[node] \u003d\u003d depth[node]) {\n    BuildStrongComp(node);\n  }\n}\n\nint main() {\n  cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\n  for(int i \u003d 1; i \u0026lt;\u003d m; ++i) {\n    int a, b;\n    cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n    G[a].push_back(b);\n  }\n\n  for(int i \u003d 1; i \u0026lt;\u003d n; ++i) {\n    if(UseRmv[i]) {\n      continue;\n    }\n\n    Dfs(i);\n  }\n\n  cout \u0026lt;\u0026lt; Ans.size() \u0026lt;\u0026lt; \u0027\\n\u0027;\n\n  for(auto ans: Ans) {\n    for(auto it: ans) {\n      cout \u0026lt;\u0026lt; it \u0026lt;\u0026lt; \u0027 \u0027;\n    }\n\n    cout \u0026lt;\u0026lt; \u0027\\n\u0027;\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["tarjan","scc","ask a question"]}}