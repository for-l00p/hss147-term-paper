{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1460891890,"rating":50,"authorHandle":"Alex_2oo8","modificationTimeSeconds":1461096968,"id":44408,"title":"\u003cp\u003eEditorial for CROC 2016 Finals and Codeforces Round #347\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/664/problem/A\" title\u003d\"Codeforces Round 347 (Div. 2)\"\u003e664A - Complicated GCD\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAuthor of the idea — \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/GlebsHP\" title\u003d\"Grandmaster GlebsHP\"\u003eGlebsHP\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe examine two cases:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e — the segment consists of a single number, hence the answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u0026lt; \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e — we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egcd\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003ea\u003c/i\u003e + 1, \u003ci\u003ea\u003c/i\u003e + 2, ..., \u003ci\u003eb\u003c/i\u003e) \u003d \u003ci\u003egcd\u003c/i\u003e(\u003ci\u003egcd\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003ea\u003c/i\u003e + 1), \u003ci\u003ea\u003c/i\u003e + 2, ..., \u003ci\u003eb\u003c/i\u003e) \u003d \u003ci\u003egcd\u003c/i\u003e(1, \u003ci\u003ea\u003c/i\u003e + 2, ..., \u003ci\u003eb\u003c/i\u003e) \u003d 1\u003c/span\u003e.\u003c/li\u003e \u003c/ol\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint main() {\n    string a, b;\n    cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\n    if (a \u003d\u003d b) cout \u0026lt;\u0026lt; a;\n    else cout \u0026lt;\u0026lt; 1;\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/663/problem/A\" title\u003d\"Codeforces Round 347 (Div. 1)\"\u003e663A - Rebus\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAuthor of the idea — \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/gen\" title\u003d\"Master gen\"\u003egen\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst we check whether any solution exists at all. For that purpose, we calculate the number of positive (the first one and any other with the \u003cspan class\u003d\"tex-span\"\u003e + \u003c/span\u003e sign) and negative elements (with the \u003cspan class\u003d\"tex-span\"\u003e - \u003c/span\u003e sign) in the sum. Let them be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eneg\u003c/i\u003e\u003c/span\u003e, respectively. Then the minimum value of the sum that can be possibly obtained is equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e \u003d (1 · \u003ci\u003epos\u003c/i\u003e - \u003ci\u003en\u003c/i\u003e · \u003ci\u003eneg\u003c/i\u003e)\u003c/span\u003e, as each positive number can be \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, but all negative can be \u003cspan class\u003d\"tex-span\"\u003e - \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Similarly, the maximum possible value is equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e \u003d (\u003ci\u003en\u003c/i\u003e · \u003ci\u003epos\u003c/i\u003e - 1 · \u003ci\u003eneg\u003c/i\u003e)\u003c/span\u003e. The solution therefore exists if and only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e ≤ \u003ci\u003emax\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow suppose a solution exists. Let\u0027s insert the numbers into the sum one by one from left to right. Suppose that we have determined the numbers for some prefix of the expression with the sum of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e. Let the sign of the current unknown be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esgn\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e + 1\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e) and there are some unknown numbers left to the right, excluding the examined unknown, among them \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e_\u003ci\u003eleft\u003c/i\u003e\u003c/span\u003e positive and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eneg\u003c/i\u003e_\u003ci\u003eleft\u003c/i\u003e\u003c/span\u003e negative elements. Suppose that the current unknown number takes value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. How do we find out whether this leads to a solution? The answer is: in the same way we checked it in the beginning of the solution. Examine the smallest and the largest values of the total sum that we can get. These are equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e_\u003ci\u003eleft\u003c/i\u003e \u003d (\u003ci\u003eS\u003c/i\u003e + \u003ci\u003esgn\u003c/i\u003e · \u003ci\u003ex\u003c/i\u003e + \u003ci\u003epos\u003c/i\u003e_\u003ci\u003eleft\u003c/i\u003e - \u003ci\u003en\u003c/i\u003e · \u003ci\u003eneg\u003c/i\u003e_\u003ci\u003eleft\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e_\u003ci\u003eleft\u003c/i\u003e \u003d (\u003ci\u003eS\u003c/i\u003e + \u003ci\u003esgn\u003c/i\u003e · \u003ci\u003ex\u003c/i\u003e + \u003ci\u003en\u003c/i\u003e · \u003ci\u003epos\u003c/i\u003e_\u003ci\u003eleft\u003c/i\u003e - \u003ci\u003eneg\u003c/i\u003e_\u003ci\u003eleft\u003c/i\u003e)\u003c/span\u003e, respectively. Then we may set the current number to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e_\u003ci\u003eleft\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e ≤ \u003ci\u003emax\u003c/i\u003e_\u003ci\u003eleft\u003c/i\u003e\u003c/span\u003e holds. To find the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, we can solve a system of inequalities, but it is easier simply to check all possible values from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eBONUS\u003c/strong\u003e Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e be the number of unknowns in the rebus. Prove that the complexity of the described solution (implementation shown below) is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e + \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e, not \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e · \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nchar s[100];\n\nint main() {\n    int k \u003d 0, n, pos \u003d 1, neg \u003d 0;\n    while (true) {\n        char c;\n        scanf(\u0026quot; %c\u0026quot;, \u0026amp;c);\n        scanf(\u0026quot; %c\u0026quot;, \u0026amp;c);\n\n        if (c \u003d\u003d \u0027\u003d\u0027) break;\n        if (c \u003d\u003d \u0027+\u0027) pos++;\n        if (c \u003d\u003d \u0027-\u0027) neg++;\n\n        s[k++] \u003d c;\n    }\n\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\n    if (pos - n * neg \u0026gt; n || n * pos - neg \u0026lt; n) {\n        printf(\u0026quot;Impossible\\\\n\u0026quot;);\n\n        return 0;\n    }\n\n    printf(\u0026quot;Possible\\\\n\u0026quot;);\n\n    int S \u003d 0;\n    for (int i \u003d 0; i \u0026lt; k; i++) {\n        int sgn \u003d 1;\n        if (i \u0026gt; 0 \u0026amp;\u0026amp; s[i - 1] \u003d\u003d \u0027-\u0027) sgn \u003d -1;\n\n        if (sgn \u003d\u003d 1) pos--;\n        if (sgn \u003d\u003d -1) neg--;\n\n        for (int x \u003d 1; x \u0026lt;\u003d n; x++)\n            if (S + x * sgn + pos - n * neg \u0026lt;\u003d n \u0026amp;\u0026amp; S + x * sgn + n * pos - neg \u0026gt;\u003d n) {\n                printf(\u0026quot;%d %c \u0026quot;, x, s[i]);\n\n                S +\u003d x * sgn;\n\n                break;\n            }\n\t}\n\n    printf(\u0026quot;%d \u003d %d\\\\n\u0026quot;, abs(n - m), n);\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/662/problem/D\" title\u003d\"CROC 2016 - Final Round [Private, For Onsite Finalists Only]\"\u003e662D - International Olympiad\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAuthor of the idea — \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Alex_2oo8\" title\u003d\"International Grandmaster Alex_2oo8\"\u003eAlex_2oo8\u003c/a\u003e\u003c/p\u003e\u003cp\u003eConsider the abbreviations that are given to the first Olympiads. The first \u003cspan class\u003d\"tex-span\"\u003e10\u003c/span\u003e Olympiads (from year \u003cspan class\u003d\"tex-span\"\u003e1989\u003c/span\u003e to year \u003cspan class\u003d\"tex-span\"\u003e1998\u003c/span\u003e) receive one-digit abbreviations (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eIAO\u003c/i\u003e\u00279, \u003ci\u003eIAO\u003c/i\u003e\u00270, ..., \u003ci\u003eIAO\u003c/i\u003e\u00278\u003c/span\u003e). The next \u003cspan class\u003d\"tex-span\"\u003e100\u003c/span\u003e Olympiads (\u003cspan class\u003d\"tex-span\"\u003e1999 - 2098\u003c/span\u003e) obtain two-digit abbreviations, because all one-digit abbreviations are already taken, but the last two digits of \u003cspan class\u003d\"tex-span\"\u003e100\u003c/span\u003e consecutive integers are pairwise different. Similarly, the next \u003cspan class\u003d\"tex-span\"\u003e1000\u003c/span\u003e Olympiads get three-digit abbreviations and so on.\u003c/p\u003e\u003cp\u003eNow examine the inversed problem (extract the year from an abbreviation). Let the abbreviation have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e digits, then we know that all Olympiads with abbreviations of lengths \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e - 1), (\u003ci\u003ek\u003c/i\u003e - 2), ..., 1\u003c/span\u003e have passed before this one. The number of such Olympiads is \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/sup\u003e + 10\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e - 2\u003c/sup\u003e + ... + 10\u003csup class\u003d\"upper-index\"\u003e1\u003c/sup\u003e \u003d \u003ci\u003eF\u003c/i\u003e\u003c/span\u003e and the current Olympiad was one of the \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e of the following. Therefore this Olympiad was held in years between \u003cspan class\u003d\"tex-span\"\u003e(1989 + \u003ci\u003eF\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(1989 + \u003ci\u003eF\u003c/i\u003e + 10\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e - 1)\u003c/span\u003e. As this segment consists of exactly \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e consecutive natural numbers, it contains a single number with a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e-digit suffix that matches the current abbreviation. It is also the corresponding year.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nchar s[42];\n\nint main() {\n    int n;\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    while (n--) {\n        scanf(\u0026quot; %s\u0026quot;, s);\n        \n        int k \u003d strlen(s + 4), year \u003d atoi(s + 4), F \u003d 0, tenPow \u003d 10;\n        for (int i \u003d 1; i \u0026lt; k; i++) {\n            F +\u003d tenPow;\n            tenPow *\u003d 10;\n        }\n        \n        while (year \u0026lt; 1989 + F) year +\u003d tenPow;\n        \n        printf(\u0026quot;%d\\\\n\u0026quot;, year);\n    }\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/662/problem/B\" title\u003d\"CROC 2016 - Final Round [Private, For Onsite Finalists Only]\"\u003e662B - Graph Coloring\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAuthor of the problem — \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/gen\" title\u003d\"Master gen\"\u003egen\u003c/a\u003e\u003c/p\u003e\u003cp\u003eExamine the two choices for the final color separately, and pick the best option afterwards. Now suppose we want to color the edges red.\u003c/p\u003e\u003cp\u003eEach vertex should be recolored at most once, since choosing a vertex two times changes nothing (even if the moves are not consecutive). Thus we need to split the vertices into two sets \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e, the vertices that are recolored and the vertices that are not affected, respectively. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e be two vertices connected by a red edge. Then for the color to remain red, both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e should belong to the same set (either \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e). On the other hand, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e are connected by a blue edge, then exactly one of the vertices should be recolored. In that case \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e should belong to different sets (one to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e and the other to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eThis problem reduces to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e-\u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e graph coloring, which can be solved by either \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eDFS\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eBFS\u003c/i\u003e\u003c/span\u003e. As the graph may be disconnected, we need to process the components separately. If any component does not have a \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e-\u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e coloring, there is no solution. Otherwise we need to add the smallest of the two partite sets of the \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e-\u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e coloring of this component to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e, as we require \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e to be of minimum size.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nconst int MX \u003d 100000;\n\nint n, vis[MX];\nvector\u0026lt;pair\u0026lt;int, char\u0026gt;\u0026gt; G[MX];\nvector\u0026lt;int\u0026gt; part[3];\n\nbool dfs(int v, int p, char c) {\n    if (vis[v] !\u003d 0) {\n        return vis[v] \u003d\u003d p;\n    }\n\n    vis[v] \u003d p;\n    part[p].push_back(v);\n\n    for (auto x : G[v]) {\n        if (dfs(x.first, x.second \u003d\u003d c ? p : p ^ 3, c) \u003d\u003d false)\n            return false;\n    }\n\n    return true;\n}\n\nvector\u0026lt;int\u0026gt; solve(char c) {\n    memset(vis, 0, sizeof vis);\n\n    vector\u0026lt;int\u0026gt; ans;\n    for (int i \u003d 0; i \u0026lt; n; i++)\n        if (vis[i] \u003d\u003d 0) {\n            part[1].clear();\n            part[2].clear();\n\n            if (dfs(i, 1, c) \u003d\u003d false) {\n                for (int j \u003d 0; j \u0026lt; n + 1; j++) ans.push_back(-1);\n\n                return ans;\n            }\n\n            int f \u003d 1;\n            if (part[2].size() \u0026lt; part[1].size()) f \u003d 2;\n\n            ans.insert(ans.end(), part[f].begin(), part[f].end());\n        }\n\n    return ans;\n}\n\nint main() {\n    int m;\n    scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;n, \u0026amp;m);\n    for (int i \u003d 0; i \u0026lt; m; i++) {\n        int u, v;\n        char c;\n        scanf(\u0026quot;%d %d %c\u0026quot;, \u0026amp;u, \u0026amp;v, \u0026amp;c);\n        u--;\n        v--;\n\n        G[u].emplace_back(v, c);\n        G[v].emplace_back(u, c);\n    }\n\n    auto f \u003d solve(\u0027R\u0027);\n    auto g \u003d solve(\u0027B\u0027);\n\n    if (g.size() \u0026lt; f.size()) f \u003d g;\n\n    if (f.size() \u0026gt; n) {\n        printf(\u0026quot;-1\\\\n\u0026quot;);\n\n        return 0;\n    }\n\n    printf(\u0026quot;%d\\\\n\u0026quot;, (int)f.size());\n    for (int x : f) printf(\u0026quot;%d \u0026quot;, x + 1);\n    printf(\u0026quot;\\\\n\u0026quot;);\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/662/problem/A\" title\u003d\"CROC 2016 - Final Round [Private, For Onsite Finalists Only]\"\u003e662A - Gambling Nim\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAuthor of the idea — \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/GlebsHP\" title\u003d\"Grandmaster GlebsHP\"\u003eGlebsHP\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIt is known that the first player loses if and only if the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exor\u003c/i\u003e\u003c/span\u003e-sum of all numbers is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. Therefore the problem essentially asks to calculate the number of ways to arrange the cards in such a fashion that the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exor\u003c/i\u003e\u003c/span\u003e-sum of the numbers on the upper sides of the cards is equal to zero.\u003c/p\u003e\u003cp\u003eLet \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5a/07/5a07257c8766716c25acbd5644aec945cb61dc2e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7a/cc/7acc6d5d3a593baa08d6f44f581d456cb5d16392.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Suppose that the cards with indices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e are faced with numbers of type \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e and all the others with numbers of type \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. Then the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exor\u003c/i\u003e\u003c/span\u003e-sum of this arrangement is equal to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/42/c3/42c31f00de7ff9f309c0c137c2c27bfb3f0a7b19.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, that is, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/72/44/7244d9271197772274e44b9a13d8cf315b6f5b29.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Hence we want to find the number of subsets \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exor\u003c/i\u003e\u003c/span\u003e-sum of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNote that we can replace \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9e/0b/9e0b91d8cb9816ef80427c62e7f1c5e31f49cf18.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, as applying \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e is the same as applying \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f2/bb/f2bbb555f2b47c6a9a7da6157732a0ad0be64777.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Thus we can freely replace \u003cspan class\u003d\"tex-span\"\u003e{\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e}\u003c/span\u003e with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9e/0b/9e0b91d8cb9816ef80427c62e7f1c5e31f49cf18.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8b/78/8b78d29c2420d7b29ba2daf1c63abf79bb78ef4c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. This means that we can apply the following procedure to simplify the set of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e:\u003c/p\u003e \u003col\u003e   \u003cli\u003ePick \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e with the most significant bit set to one\u003c/li\u003e   \u003cli\u003eReplace each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e with the bit in that position set to one to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c9/19/c9198ce7cfa25837ffd06edb1df8143642c3f7dd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/li\u003e   \u003cli\u003eRemove \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e from the set\u003c/li\u003e   \u003cli\u003eRepeat steps \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e-\u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e with the remaining set\u003c/li\u003e   \u003cli\u003eAdd \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e back to the set\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eAfter this procedure we get a set that contains \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e zeros and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e numbers with the property that the positions of the most significant bit set to one strictly decrease. How do we check now whether it is possible to obtain a subset with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exor\u003c/i\u003e\u003c/span\u003e-sum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e? As we have at most one number with a one in the most significant bit, then it tells us whether we should include that number in the subset or not. Similarly we apply the same argument for all other bits. If we don\u0027t obtain a subset with the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exor\u003c/i\u003e\u003c/span\u003e-sum equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e, then there is no such subset at all. If we do get a subset with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exor\u003c/i\u003e\u003c/span\u003e-sum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e, then the total number of such subsets is equal to \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e, as for each of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e non-zero numbers we already know whether it must be include in such a subset or not, but any subset of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e zeros doesn\u0027t change the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exor\u003c/i\u003e\u003c/span\u003e-sum. In this case the probability of the second player winning the game is equal to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f0/9f/f09f2f9b528be400d3e40c4f37f4931484efae89.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, so the first player wins with probability \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/2a/c5/2ac53acb198284c282942323ad5d61466940cf98.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nconst int size \u003d 1000 * 1000 + 1;\nconst int ssize \u003d 100;\n\nint n;\nlong long a[size], b[size];\nlong long ort[ssize];\nlong long p[ssize];\n\nint main() {\n    long long cur \u003d 0ll;\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        scanf(\u0026quot;%lld%lld\u0026quot;, \u0026amp;a[i], \u0026amp;b[i]);\n        cur ^\u003d a[i];\n        a[i] ^\u003d b[i];\n    }\n    a[n] \u003d cur;\n\n    int len \u003d 0;\n    for (int i \u003d 0; i \u0026lt;\u003d n; i++) {\n        for (int j \u003d 0; j \u0026lt; len; j++) {\n            if (a[i] \u0026amp; p[j])\n                a[i] ^\u003d ort[j];\n        }\n        if (a[i]) {\n            ort[len++] \u003d a[i];\n            p[len - 1] \u003d ((a[i] ^ (a[i] - 1)) + 1) \u0026gt;\u0026gt; 1;\n        }        \n    }\n    if (a[n]) {\n        printf(\u0026quot;1/1\\\\n\u0026quot;);\n    } else {\n        printf(\u0026quot;%lld/%lld\\\\n\u0026quot;, (1ll \u0026lt;\u0026lt; len) - 1, (1ll \u0026lt;\u0026lt; len));\n    }\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/662/problem/C\" title\u003d\"CROC 2016 - Final Round [Private, For Onsite Finalists Only]\"\u003e662C - Binary Table\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAuthor of the idea — \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Alex_2oo8\" title\u003d\"International Grandmaster Alex_2oo8\"\u003eAlex_2oo8\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst let\u0027s examine a slow solution that works in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e · \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e. Since each row can be either inverted or not, the set of options of how we can invert the rows may be encoded in a bitmask of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, an integer from \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e - 1)\u003c/span\u003e, where the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th bit is equal to 1 if and only if we invert the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th row. Each column also represents a bitmask of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e (the bits correspond to the values of that row in each of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e rows). Let the bitmask of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th column be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecol\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, and the bitmask of the inverted rows be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e. After inverting the rows the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th column will become \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/79/d4/79d4af2340bdd62e94ce7bb27da7a46942588371.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Suppose that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/79/d4/79d4af2340bdd62e94ce7bb27da7a46942588371.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e contains \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/26/ee/26ee4d70f89ce059fa618931e57fc1de1d6ef3f0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e ones. Then we can obtain either \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e ones in this column, depending on whether we invert the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th column itself. It follows that for a fixed bitmask \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e the minimum possible number of ones that can be obtained is equal to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/57/e4/57e4f5acd9bad2f578ccd385745276064c95c9e4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eNow we want to calculate this sum faster than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003em\u003c/i\u003e)\u003c/span\u003e. Note that we are not interested in the value of the mask \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/79/d4/79d4af2340bdd62e94ce7bb27da7a46942588371.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e itself, but only in the number of ones it contains (from \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e). Therefore we may group the columns by the value of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9e/a6/9ea659b605d2db1d8386b1f1e0be2a33039ca980.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003emask\u003c/i\u003e]\u003c/span\u003e be the number of such \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/99/cb/99cb2c4f314314fd2a951a98870d13dafcb66aed.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, then for a fixed bitmask \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e we can calculate the sum in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e — \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/18/f4/18f4692ae91952aa58326922ad5b76ba29ff2d45.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eWhat remains is to calculate the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003emask\u003c/i\u003e]\u003c/span\u003e in a quick way. As the name suggests, we can use dynamic programming for this purpose. The value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[0][\u003ci\u003emask\u003c/i\u003e]\u003c/span\u003e can be found in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003em\u003c/i\u003e)\u003c/span\u003e for all bitmasks \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e: each column \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecol\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e increases \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[0][\u003ci\u003ecol\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e]\u003c/span\u003e by 1. For \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u0026gt; 0\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecol\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e differ in exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e bits. Suppose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecol\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e differ in position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e. Then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecol\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/80/b9/80b9ba404ad384c575c76752c4d29f404412e0cf.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e differ in exactly \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e - 1)\u003c/span\u003e bits. The number of such columns is equal to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1d/f9/1df9d8d63bc9e4a3d63c9170e7883f0c4eef5c11.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, except we counted in also the number of columns \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecol\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e that differ with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/80/b9/80b9ba404ad384c575c76752c4d29f404412e0cf.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e in bit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e (thus, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecol\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e have the same value in bit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e). Thus we need to subtract \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e - 2][\u003ci\u003emask\u003c/i\u003e]\u003c/span\u003e, but again, except the columns among these that differ with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e in bit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e. Let \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/92/f7/92f7a1937661e9dbbb57dc0d7f15a01e8bd230c4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e; by expanding this inclusion-exclusion type argument, we get that the number of masks we are interested in can be expressed as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e - 1][\u003ci\u003enext\u003c/i\u003e] - \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e - 2][\u003ci\u003emask\u003c/i\u003e] + \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e - 3][\u003ci\u003enext\u003c/i\u003e] - \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e - 4][\u003ci\u003emask\u003c/i\u003e] + \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e - 5][\u003ci\u003enext\u003c/i\u003e] - ...\u003c/span\u003e. By summing all these expressions for each bit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, we get \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003emask\u003c/i\u003e] · \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, since each column is counted in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e times (for each of the bits \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e where the column differs from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eTherefore, we are now able to count the values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003emask\u003c/i\u003e]\u003c/span\u003e in time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e · \u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e using the following recurrence:\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a3/59/a3590e816e0d749a219bbb970efc9dd59985b464.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThis is still a tad slow, but we can speed it up to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e · \u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e, for example, in a following fashion:\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ce/c2/cec25b96569e46fb16784f1ca2ed0e9c034f397e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e  \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3c/12/3c126c587fd61553d727f714854f9cf414e968d1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/61/f3/61f3b47b9d7da5fcfb365dc1e5bc54ebc2cdc5c4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eBONUS\u003c/strong\u003e Are you able to come up with an even faster solution?\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nchar s[100000];\nint col[100000], dp[21][1 \u0026lt;\u0026lt; 20];\n\nint main() {\n    int n, m;\n    scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;n, \u0026amp;m);\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        scanf(\u0026quot; %s\u0026quot;, s);\n\n        for (int j \u003d 0; j \u0026lt; m; j++) col[j] |\u003d (s[j] - \u00270\u0027) \u0026lt;\u0026lt; i;\n    }\n\n    for (int i \u003d 0; i \u0026lt; m; i++) dp[0][col[i]]++;\n\n    for (int k \u003d 1; k \u0026lt;\u003d n; k++)\n        for (int mask \u003d 0; mask \u0026lt; (1 \u0026lt;\u0026lt; n); mask++) {\n            int sum \u003d k \u0026gt; 1 ? (k - 2 - n) * dp[k - 2][mask] : 0;\n            for (int p \u003d 0; p \u0026lt; n; p++) sum +\u003d dp[k - 1][mask ^ (1 \u0026lt;\u0026lt; p)];\n\n            dp[k][mask] \u003d sum / k;\n        }\n\n    int ans \u003d n * m;\n    for (int mask \u003d 0; mask \u0026lt; (1 \u0026lt;\u0026lt; n); mask++) {\n        int cnt \u003d 0;\n        for (int k \u003d 0; k \u0026lt;\u003d n; k++) cnt +\u003d min(k, n - k) * dp[k][mask];\n\n        ans \u003d min(ans, cnt);\n    }\n\n    printf(\u0026quot;%d\\\\n\u0026quot;, ans);\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/662/problem/E\" title\u003d\"CROC 2016 - Final Round [Private, For Onsite Finalists Only]\"\u003e662E - To Hack or not to Hack\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAuthor of the idea — \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Alex_2oo8\" title\u003d\"International Grandmaster Alex_2oo8\"\u003eAlex_2oo8\u003c/a\u003e\u003c/p\u003e\u003cp\u003eObservation number one — as you are the only participant who is able to hack, the total score of any other participant cannot exceed \u003cspan class\u003d\"tex-span\"\u003e9000\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e problems for \u003cspan class\u003d\"tex-span\"\u003e3000\u003c/span\u003e points). Hence hacking at least \u003cspan class\u003d\"tex-span\"\u003e90\u003c/span\u003e solutions automatically guarantees the first place (the hacks alone increase the score by \u003cspan class\u003d\"tex-span\"\u003e9000\u003c/span\u003e points).\u003c/p\u003e\u003cp\u003eNow we are left with the problem where the number of hacks we make is at most \u003cspan class\u003d\"tex-span\"\u003e90\u003c/span\u003e. We can try each of the \u003cspan class\u003d\"tex-span\"\u003e6\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003c/span\u003e possible score assignments for the problems in the end of the round. As we know the final score for each problem, we can calculate the maximum number of hacks we are allowed to make so the problem gets the assigned score. This is also the exact amount of hacks we will make in that problem. As we know the number of hacks we will make, we can calculate our final total score. Now there are at most \u003cspan class\u003d\"tex-span\"\u003e90\u003c/span\u003e participants who we can possibly hack. We are interested only in those who are on top of us. By hacking we want to make their final score less than that of us. This problem can by solved by means of dynamic programming:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e — the maximum number of participants among the top \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e, whom we can push below us by hacking first problem \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e times, second problem \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e times and third problem \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e times.\u003c/p\u003e\u003cp\u003eThe recurrence: we pick a subset of solutions of the current participant that we will hack, and if after these hacks we will push him below us, we update the corresponding dp state. For example, if it is enough to hack the first and the third problems, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e + 1][\u003ci\u003ei\u003c/i\u003e + 1][\u003ci\u003ej\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e + 1] \u003d \u003ci\u003emax\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e + 1][\u003ci\u003ei\u003c/i\u003e + 1][\u003ci\u003ej\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e + 1], \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e] + 1)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eBONUS\u003c/strong\u003e Can you solve this problem if each hack gives only \u003cspan class\u003d\"tex-span\"\u003e10\u003c/span\u003e points, not \u003cspan class\u003d\"tex-span\"\u003e100\u003c/span\u003e?\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\n\n#define time ololo\n\nusing namespace std;\n\nint time[5000][3], n, solved[3], canHack[3], score[3], willHack[3], bestPlace, dp[2][90][90][90], ci, li;\n\nint submissionScore(int sc, int tm) {\n    if (tm \u003d\u003d 0) return 0;\n\n    return sc * (250 - abs(tm)) / 250;\n}\n\nint calcScore(int p) {\n    int sum \u003d 0;\n    for (int i \u003d 0; i \u0026lt; 3; i++) sum +\u003d submissionScore(score[i], time[p][i]);\n\n    return sum;\n}\n\nint countHacks(int p) {\n    int cnt \u003d 0;\n    for (int i \u003d 0; i \u0026lt; 3; i++) cnt +\u003d time[p][i] \u0026lt; 0;\n\n    return cnt;\n}\n\nint solve() {\n    memset(dp, 0, sizeof dp);\n\n    int myScore \u003d 0;\n    for (int i \u003d 0; i \u0026lt; 3; i++) myScore +\u003d 100 * willHack[i] + submissionScore(score[i], time[0][i]);\n\n    ci \u003d 0;\n    li \u003d 1;\n    for (int p \u003d 1; p \u0026lt; n; p++)\n        if (countHacks(p) \u0026gt; 0 \u0026amp;\u0026amp; calcScore(p) \u0026gt; myScore) {\n            ci ^\u003d 1;\n            li ^\u003d 1;\n\n            for (int i \u003d 0; i \u0026lt;\u003d willHack[0]; i++)\n                for (int j \u003d 0; j \u0026lt;\u003d willHack[1]; j++)\n                    for (int k \u003d 0; k \u0026lt;\u003d willHack[2]; k++)\n                        dp[ci][i][j][k] \u003d dp[li][i][j][k];\n\n            for (int ii \u003d 0; ii \u0026lt; 2; ii++)\n                for (int jj \u003d 0; jj \u0026lt; 2; jj++)\n                    for (int kk \u003d 0; kk \u0026lt; 2; kk++) {\n                        if (ii \u003d\u003d 1 \u0026amp;\u0026amp; time[p][0] \u0026gt;\u003d 0) continue;\n                        if (jj \u003d\u003d 1 \u0026amp;\u0026amp; time[p][1] \u0026gt;\u003d 0) continue;\n                        if (kk \u003d\u003d 1 \u0026amp;\u0026amp; time[p][2] \u0026gt;\u003d 0) continue;\n\n                        int s \u003d submissionScore(score[0], time[p][0]) * (ii ^ 1)\n                              + submissionScore(score[1], time[p][1]) * (jj ^ 1)\n                              + submissionScore(score[2], time[p][2]) * (kk ^ 1);\n\n                        if (s \u0026gt; myScore) continue;\n\n                        for (int i \u003d ii; i \u0026lt;\u003d willHack[0]; i++)\n                            for (int j \u003d jj; j \u0026lt;\u003d willHack[1]; j++)\n                                for (int k \u003d kk; k \u0026lt;\u003d willHack[2]; k++)\n                                    dp[ci][i][j][k] \u003d max(dp[ci][i][j][k], dp[li][i - ii][j - jj][k - kk] + 1);\n                    }\n        }\n\n    int res \u003d 1 - dp[ci][willHack[0]][willHack[1]][willHack[2]];\n    for (int p \u003d 1; p \u0026lt; n; p++) if (calcScore(p) \u0026gt; myScore) res++;\n\n    return res;\n}\n\nvoid brute(int p) {\n    if (p \u003d\u003d 3) {\n        int res \u003d solve();\n\n        bestPlace \u003d min(bestPlace, res);\n\n        return;\n    }\n\n    for (int i \u003d 0; i \u0026lt; 6; i++) {\n        int mn \u003d i \u003d\u003d 5 ? 0 : (n \u0026gt;\u0026gt; (i + 1)) + 1;\n        int mx \u003d (n \u0026gt;\u0026gt; i);\n\n        if (solved[p] \u0026gt;\u003d mn \u0026amp;\u0026amp; solved[p] - canHack[p] \u0026lt;\u003d mx) {\n            score[p] \u003d 500 * (i + 1);\n            willHack[p] \u003d min(canHack[p], solved[p] - mn);\n\n            brute(p + 1);\n        }\n    }\n}\n\nint main() {\n    memset(solved, 0, sizeof solved);\n    memset(canHack, 0, sizeof canHack);\n    \n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    for (int i \u003d 0; i \u0026lt; n; i++)\n        for (int j \u003d 0; j \u0026lt; 3; j++) {\n            scanf(\u0026quot;%d\u0026quot;, \u0026amp;time[i][j]);\n\n            solved[j] +\u003d time[i][j] !\u003d 0;\n            canHack[j] +\u003d time[i][j] \u0026lt; 0;\n        }\n\n    if (canHack[0] + canHack[1] + canHack[2] \u0026gt; 89) {\n        printf(\u0026quot;1\\\\n\u0026quot;);\n\n        return 0;\n    }\n\n    bestPlace \u003d n;\n    brute(0);\n\n    printf(\u0026quot;%d\\\\n\u0026quot;, bestPlace);\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}