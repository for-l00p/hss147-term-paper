{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1521385765,"rating":-1,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1521385765,"id":58440,"title":"\u003cp\u003eNotes on Codeforces Beta Round #124, Div2- A, B, C, D, Div1- E\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/197/problem/A\" title\u003d\"Codeforces Round 124 (Div. 2)\"\u003e197A - Plate Game\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe trick is that if the first player can put down a circle, then he will win. The strategy is to put the first circle exactly on the center, and as long as the second player can put one circle, the first player can simply put another one on the center-symmetric position. Thus, the problem has been reduced to determining whether the first circle can be put on the table or not.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/197/problem/B\" title\u003d\"Codeforces Round 124 (Div. 2)\"\u003e197B - Limit\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFor \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e2/7f/e27f9139c4bf86307f5b2306f7706e9fb8f7b6c9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, it can be written as \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ff/12/ff12d8c4ed7b766cae6a4cb278090c9973a6f2ea.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/76/38/7638be2bd6bd95dd0fe8bb470fd2782e1e440678.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is similar). Thus, as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e -  \u0026gt; ∞\u003c/span\u003e, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3b/5c/3b5c8ee1f6aa86e2d24152460740f0d7ad48b444.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, we can further reduce the term \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003em\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e based on the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003em\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/197/problem/C\" title\u003d\"Codeforces Round 124 (Div. 2)\"\u003e197C - Lexicographically Maximum Subsequence\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe should first select all the “z”. By denoting the position of the last “z” as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, we should further select all the “y” with indices larger than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Suppose that the last position of “y” is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, and we select all the “x” with indices larger than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. The above process is repeated until we reach the end of the given string. If some letters do not appear in the given string, we can simply skip them.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/197/problem/D\" title\u003d\"Codeforces Round 124 (Div. 2)\"\u003e197D - Infinite Maze\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe main observation is that starting from “S”, if and only if we can reach two different points \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e, while \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e%\u003ci\u003en\u003c/i\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e%\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e%\u003ci\u003em\u003c/i\u003e \u003d \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e%\u003ci\u003em\u003c/i\u003e\u003c/span\u003e, then the answer is yes (see proof in tutorials). \u003c/p\u003e\u003cp\u003eI can only prove the “if” part. We can construct a scheme to go infinitely far away. We can draw a line from “S” to \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003c/span\u003e, and from “S” to \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e, respectively. Although these may not be straight lines (in fact they are paths), we can still treat them as “straight” and thus they form an angle. Next, \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e also serves as \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003c/span\u003e of some other “S*”, and “S*” also has its own \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e. If we repeat the above step, one can see that they just form some pattern which consists of the same copy but have infinite extension.\u003c/p\u003e\u003cp\u003eAs for the implementation, we can just use simple bfs and adopt some extra indicators to tell to which board the current \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003c/span\u003e belongs.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/196/problem/E\" title\u003d\"Codeforces Round 124 (Div. 1)\"\u003e196E - Opening Portals\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI follow the turotials.\u003c/p\u003e\u003cp\u003eAt first, we run a “parallel” Dij\u0027s algorithm to find out, for each node, the distance to its nearest portal node. This algorithm can be implemented based on SPFA (shortest path faster algorithm, and one can find a large number of materials on the internet). Specifically, we use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e to denote the distance from node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to its nearest portal node, amd use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epre\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e to denote this nearest portal node. These two arrays should be updated in the SPFA framework.\u003c/p\u003e\u003cp\u003eNext, we try to construct a new graph which only describes the “distance” among portal nodes. We can enumerate each edge given in the original graph, and for each edge connecting two nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, we find the corresponding two portal nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epre\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epre\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e. We add a virtual edge between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epre\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epre\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e, with weight of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e] + \u003ci\u003ew\u003c/i\u003e + \u003ci\u003edis\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e denotes the weight of edge between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. After constructing the new graph, we can run Kruskal\u0027s algorithm to find the MST.\u003c/p\u003e\u003cp\u003eHowever, I still have two questions... \u003c/p\u003e\u003cp\u003e1) How to prove that the shortest path (virtual path) between any two portal nodes are always included in the new graph. We only know that for some two portal nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, the shortest path must go through some edge in the original graph. This means that if we want to find this shortest path, there must exist at least one edge having \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e as its two nearest portal nodes, but how to guarantee this...\u003c/p\u003e\u003cp\u003e2) I think this is a “steiner tree” problem (see \u003ca href\u003d\"/contest/152/problem/E\" title\u003d\"Codeforces Round 108 (Div. 2)\"\u003e152E - Garden\u003c/a\u003e), and if I am correct, this is NP-hard and it is weird to have a polynomial solution. Where am I wrong...\u003c/p\u003e\u003c/div\u003e","tags":[]}}