{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1466151004,"rating":0,"authorHandle":"MarcoXerox","modificationTimeSeconds":1466151004,"id":45483,"title":"\u003cp\u003eTLE despite output\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eLink to latest submission in Haskell: \u003ca href\u003d\"//codeforces.com/contest/373/submission/18538608\"\u003ehttp://codeforces.com/contest/373/submission/18538608\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe submission implements a greedy algorithm, well-tested against small inputs. For I/O, ByteStrings and readInts are used. Previous profiling indicates that receiving the input consisting of 5e5 ints is the bottleneck. However, even when these I/O optimizations and that my program shows an output \u0026quot;250264\u0026quot;, I still receive TLE verdict. I would be glad to know why. Below are some profiling information for your reference. Profiling with RTSOPTS and No O2 gives the following results. Test case is: \u0026quot;500000\\n1\\n2\\n3\\n4\\n...500000\\n\u0026quot; total time \u003d 0.10 secs (101 ticks @ 1000 us, 1 processor) COST CENTRE MODULE %time %alloc\u003c/p\u003e\u003cp\u003esolve.(...) Main 35.6 23.3 main Main 29.7 55.0 fastRead Main 19.8 20.0 solve\u0027 Main 14.9 1.7\u003c/p\u003e\u003c/div\u003e","tags":["fast input","haskell","judge","time limit error"]}}