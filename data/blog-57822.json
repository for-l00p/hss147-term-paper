{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1518823376,"rating":20,"authorHandle":"RaresC","modificationTimeSeconds":1521391059,"id":57822,"title":"\u003cp\u003eDifferent Look at Segment Trees and Constant Query Time\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello everyone. I just wanted to share something with all of you that I thought of. I found it interesting, and I think some of you may find it interesting as well. There\u0027s quite a lot going on, and I\u0027m not sure how useful it really is in the end, but may be interesting nonetheless.\u003c/p\u003e\u003cp\u003eIt will be useful to be familiar with segment trees. If not, I encourage you to read up on those.\u003c/p\u003e\u003cp\u003eWe\u0027ll be able to answer range queries (for any type of query that a segment tree can support) in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time, with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e9/82/e9824f6612c4b83669d669fe6fd4d9e558305dfd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e preprocessing.\u003c/p\u003e\u003ch2\u003eThe Problem\u003c/h2\u003e\u003cp\u003eI think it\u0027s important we take a little step back, and really think about what segment trees do at a more abstract level. We are given a list \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e \u003d {\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e}\u003c/span\u003e. As we move forward, we\u0027ll denote \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e] ≡ {\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e}\u003c/span\u003e. Our goal is to create a set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e \u003d {\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e}\u003c/span\u003e where each element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is a contiguous sub-sequence of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e. Answering a query \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e consists of finding the smallest partition \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/af/5c/af5c706c2b97031489cf8800195592ffa7e59f72.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e of the range \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e\u003c/p\u003e\u003cp\u003eIn actuality, the goal is to compute some function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e for each query \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e. So, how is partitioning related? We want to compute \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/13/4e/134e4f7fe77fb408c2b2e8b15df11f3fc6424ec2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, and we have the additional restriction that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e has the following property:\u003c/p\u003e\u003cp\u003eGiven any two adjacent ranges, \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e], [\u003ci\u003ej\u003c/i\u003e + 1, \u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e, it must be true that the answer to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e must be completely determined by the values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ej\u003c/i\u003e + 1, \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e. We say that we merge \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ej\u003c/i\u003e + 1, \u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e to produce \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e. So, if we are capable of finding a partition \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e of \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e, we can merge all of the elements of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e to compute the answer to our query. All we need to do is to precompute the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ep\u003c/i\u003e)\u003c/span\u003e for all \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/aa/ad/aaadbc9ece5ab61a593df7da94056452da230a48.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e at the beginning. \u003c/p\u003e\u003cp\u003eWe haven\u0027t specified what \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e must be. However, we know that we want \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eP\u003c/i\u003e|\u003c/span\u003e to be small to reduce preprocessing time, but also for \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eX\u003c/i\u003e|\u003c/span\u003e to be small (for all possible queries) in order to reduce query time. \u003c/p\u003e\u003ch2\u003eSegment Trees\u003c/h2\u003e\u003cp\u003eThis is an existing data structure, which I\u0027m sure most of you are very familiar with, so I won\u0027t go into detail here. The only aspect we need from segment trees is the set of ranges which it precomputes. Below is a picture of a segment tree. If you haven\u0027t see this before, it should give you a feel for what ranges are used.\u003c/p\u003e\u003cp\u003eLooking back at the partitioning idea we talked about, segment trees are a way of partitioning any range into \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e parts, and each element is also contained in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/75/5c/755c0e72a8f6c5be4007a41acbae4bf024107b8c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e elements of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/41/cc/41cc23bac69d1bac4dd9992f7d239d651f85dd61.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch2\u003eA Graph Construction\u003c/h2\u003e\u003cp\u003eLet\u0027s create a graph \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e \u003d (\u003ci\u003eP\u003c/i\u003e, \u003ci\u003eE\u003c/i\u003e)\u003c/span\u003e, where each node in the vertex set, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e, represents one of the ranges of a segment tree. Additionally, let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d [\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e], \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e \u003d [\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e]\u003c/span\u003e. Then \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8f/dc/8fdc383ba181a3ddbe8a1b6d677b3814f969e25d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + 1 \u003d \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e. More simply put, there is an edge between two nodes if the ranges they represent are adjacent. Moreover, this is a directed edge from the node that \u0027lies on the left\u0027 to the node that is on the \u0027right\u0027. \u003c/p\u003e\u003cp\u003eWe also define the length of a node to be the length of the range it represents, and we define a node\u0027s column by its left endpoint. So, we say that a node \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e is in column \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/25/c8/25c883f887a61ca2e197917fab1fac9fd38ce191.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch2\u003eConstructing Partitions\u003c/h2\u003e\u003cp\u003eAny path in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e is a partition. In order to answer a query \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e, we need to find the shortest path from a node in column \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to a node whose right endpoint is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Something like BFS would work here, but we have a very structured graph with some nice properties which will make the task much simpler, as we\u0027ll see. \u003c/p\u003e\u003cp\u003eHere\u0027s an initial naive algorithm that finds an optimal partition. By optimal, we mean that there does not exist any other partition of \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e using fewer nodes. \u003c/p\u003e\u003cp\u003eStep 1: Find the longest node in column \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e completely contained in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e. Say it has length \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eStep 2: Solve the sub-problem of finding optimal partition for the query \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u0027 \u003d [\u003ci\u003ei\u003c/i\u003e + 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sup\u003e, \u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e. Go to Step 1 until \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u0027\u003c/span\u003e is empty.\u003c/p\u003e\u003cp\u003eThis is essentially finding the same partition that a segment tree would find, only doing so in a different manner. So, the size of the partition we find is also \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Finding the longest node in a column will take us at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/75/5c/755c0e72a8f6c5be4007a41acbae4bf024107b8c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time as well since that is the height of each column. So, overall this is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/74/10/7410a69421c6ee91a5842650f56f6dd28c3fad9a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. This is is worse than a segment tree, but don\u0027t worry, there\u0027s a quick fix.\u003c/p\u003e\u003ch4\u003eReduction to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/h4\u003e\u003cp\u003eWe need a small observation. \u003c/p\u003e\u003cp\u003eThe optimal partition will consist of two sequences. The first contains nodes of increasing length, and the second contains nodes of decreasing length. To see why this is true, think about what happens if we need to start decreasing the length at some point. If a node of length \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e is followed directly by a node of length \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e, with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e \u0026lt; \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e, then no node of length greater than or equal to \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e will be chosen again. Think about it if it\u0027s not clear why. This implies that there is an increasing sequence followed by a decreasing one. \u003c/p\u003e\u003cp\u003eSo, why does this help? Searching for the largest node in a column which is contained in the query is much simpler. In total, we will only traverse the graph up and down at most once. We can now find a partition in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time. \u003c/p\u003e\u003ch2\u003eOne More Observation\u003c/h2\u003e\u003cp\u003eFirst, a definition. We call the longest node in a column a \u0027maximal\u0027 node. \u003c/p\u003e\u003cp\u003eLet\u0027s only look at the nodes in the increasing sequence of the partition. All elements, except perhaps the last one in the increasing sequence, are maximal nodes. This very specifically defines the path that we walk on the graph, at least for the increasing half. What about the decreasing sequence?\u003c/p\u003e\u003ch2\u003eThe Decreasing Sequence: An Equivalent Problem\u003c/h2\u003e\u003cp\u003eCreate a graph \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u0027\u003c/span\u003e with the same vertex set as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e and if \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/13/a4/13a4394e46d0912826f35cc621453784c6cf4182.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, then \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8c/3e/8c3ef2ecffeebbd2047bceb0c975cbecb540636e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Essentially, we reverse the direction of edges. We will also define columns differently. We say that a node \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e is in column \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, not in column \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e as before. \u003c/p\u003e\u003cp\u003eNote that the increasing sequence in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u0027\u003c/span\u003e directly corresponds to the decreasing sequence in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e. So, instead of finding the decreasing sequence in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e, we find the increasing sequence in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u0027\u003c/span\u003e.\u003c/p\u003e\u003ch2\u003eOne Final Observation\u003c/h2\u003e\u003cp\u003eEvery node is a maximal node in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e or in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u0027\u003c/span\u003e. I won\u0027t prove this here since this post is long enough. However, here is a picture of the two graphs side by side, to more easily convince yourselves. \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/fc/46/fc460e863069448eb89f76f708bfe0b5a232a7be.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s clean up a little bit. We said that \u0026quot;All elements, except perhaps the last one in the increasing sequence, are maximal nodes\u0026quot;. Now, we can say that \u003c/p\u003e \u003cul\u003e   \u003cli\u003eAll elements in the increasing sequence are maximal nodes in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e and all elements in the decreasing sequence are maximal nodes in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u0027\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThis only makes use of the previous observation. If the last element in the increasing sequence is not maximal in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e, we can view it instead as the first element of the decreasing sequence, making it maximal in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u0027\u003c/span\u003e. So, we can represent any range query as the union of a path of increasing maximal nodes in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e and a path of increasing maximal nodes in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u0027\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSo, we have found a very nice property of the optimal partition. At each step, we know exactly which node to choose next. In fact, from the very beginning, we know exactly which nodes to choose: The maximal ones. \u003c/p\u003e\u003cp\u003eSo, let\u0027s precompute the answer to all paths consisting of maximal nodes. How many of these paths are there? Well, there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e maximal nodes at which a path must begin, and each successive element in a maximal path has increasing length, so a path has length at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. We then have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e paths we need to precompute the answer for. We use similar merging technique as in segment trees to do this. (Note that we initially need to compute the answer for each node in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e). We also need to proceed in the same fashion for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u0027\u003c/span\u003e. \u003c/p\u003e\u003ch2\u003eReduction to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cd/60/cd609b05b5bc5d82ab32907fda94102d347c048a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/h2\u003e\u003cp\u003eTo find the increasing sequence when partitioning a query \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e, we only need to look at paths which begin in column \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. So, when we store the answers to paths, we group them by left endpoint, and sort by increasing length. To find the longest path which is completely contained, we can now do a simple binary search. \u003c/p\u003e\u003cp\u003eThe number of paths that begin at a specific column is at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Using binary search, we then have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cd/60/cd609b05b5bc5d82ab32907fda94102d347c048a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time to find the increasing sequence. We perform an identical operation in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u0027\u003c/span\u003e to find the decreasing path. \u003c/p\u003e\u003cp\u003eA nice aspect of this approach is that we partition any query using exactly two precomputed ranges, no matter what \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is. The only thing keeping us from having \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e query time is the time it takes to actually find those two ranges. Let\u0027s work on that. \u003c/p\u003e\u003ch2\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e Query Time\u003c/h2\u003e\u003cp\u003eThe idea here is similar to that of sparse tables. All nodes in a path are of lengths that are powers of two. So, we can precompute the largest power of two smaller than or equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u003d 1, 2, ..., \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. This gives us an idea of where the last node in the path is. \u003c/p\u003e\u003cp\u003eFor any query \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e, we find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e, the largest power of two which is smaller than or equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e. There are now two cases: 1) the path starting in column \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and ending in a node of length \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e is completely contained in the query range. In this case, that\u0027s our answer. 2) It\u0027s not completely contained. Let\u0027s look at the path which ends at the node preceding the one of length \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. This path has length less than \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e (it\u0027s clearly upper bounded by \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e0\u003c/sup\u003e + 2\u003csup class\u003d\"upper-index\"\u003e1\u003c/sup\u003e + ... + 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ec\u003c/i\u003e - 1\u003c/sup\u003e \u0026lt; 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e). Therefore, this path is completely contained in our query. So, that can be our answer. \u003c/p\u003e\u003cp\u003eBoth cases above can be carried out in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time. Proceed similarly for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u0027\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eSo, we have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e preprocessing time, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e query time.\u003c/p\u003e\u003ch2\u003eConclusion\u003c/h2\u003e\u003cp\u003eI hope all of you found this as interesting as I did. And possibly, you may find some applications that I\u0027ve overlooked. \u003c/p\u003e\u003cp\u003e-Rares\u003c/p\u003e\u003c/div\u003e","tags":["segment tree","data structures","range query"]}}