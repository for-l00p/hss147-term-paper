{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1518309372,"rating":-20,"authorHandle":"CodingKnight","modificationTimeSeconds":1518336541,"id":57682,"title":"\u003cp\u003eFor C++ lovers and lifelong learners: Interesting information about new features in C++17\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThe ISO International Standard ISO/IEC 14882:2017(E) – Programming Language C++, known as C++17, is the result of excellent efforts by the ISO C++ Standard Foundation Committee to introduce new simple and elegant powerful features to C++.\u003c/p\u003e\u003cp\u003eAdrian D. Finlay, Software Engineer, summarized on Nov 17, 2017, the new C++17 language features that are helpful to competitive programming lovers as well as to professional software engineers and software developers as follows.\u003c/p\u003e\u003cp\u003e\u0026quot;The never-ending journey into learning C++ features….\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eNew Language Features\u003c/strong\u003e\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eAddition of __has_include macro \u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eUTF 8 Character Literals\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eHexadecimal Floating Point Literals\u003c/p\u003e\u003c/li\u003e   \u003cli\u003eNew rules for deduction of single member list using auto\u003c/li\u003e   \u003cli\u003e\u003cp\u003eUpdate to __cplusplus value\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003einline variables\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eNew Syntax for Nested Namespace definitions\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eInitializers added to if/switch statements\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003econstexpr if\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eNew standard attributes \u003ca href\u003d\"./fallthrough.html\"\u003efallthrough\u003c/a\u003e, \u003ca href\u003d\"./maybe_unused.html\"\u003emaybe_unused\u003c/a\u003e \u0026amp;\u003ca href\u003d\"./nodiscard.html\"\u003enodiscard\u003c/a\u003e ^\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eAttributes for Enumerator \u0026amp; Namespaces\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eError message for static_assert now optional\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eStructured binding declarations\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eKeyword typename now allowed in lieu of class in a template’s template paramater\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eConstant evaluation for non-type template arguments\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eClass template argument deduction\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eExtensions on over-aligned Memory Allocation\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eFold expressions\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eList-style Initialization of Enumerations\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eSpecifying non-type template parameters with auto\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003econstexpr lambda expressions\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eLambda this by value (*this)\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eExtending Aggregate Initialization to Base Types\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eUnknown Attributes Required to be Ignored\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003ePack Expansions legal in using declarations\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eGeneralization of Range-based for loop\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThe byte data type ^^\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eUsing attribute namespaces without repetition\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eStricter Order of Evaluation Rules\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eException Specifications are part of type definitions\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eTemplate-Template Parameters match compatible arguments\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eGuaranteed Copy Elision\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eChanges to Specification on Inheriting Constructors\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003e^These are three features grouped into one, which consequently when expanded would make the new feature list count 35.\u003c/p\u003e\u003cp\u003e^^This is implemented in std::byte () and is not a part of the actual language such as the other primitive data types. It is considered a basic type as much as std::string is considered a basic type.\u003c/p\u003e\u003cp\u003eC++17 also introduced a revision to Elementary string conversions\u0026quot;.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://medium.com/@afinlay/new-language-features-language-changes-in-c-17-7e953ff64c65\"\u003eThe Complete Blog posted on Medium.com\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["c++17","language features"]}}