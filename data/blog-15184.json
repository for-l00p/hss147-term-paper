{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1418728430,"rating":0,"authorHandle":"islam-al-aarag","modificationTimeSeconds":1421974553,"id":15184,"title":"\u003cp\u003eRound 2 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eAnalogous Sets\u003c/h3\u003e\u003cp\u003eThe solution for n \u003d 2, makes it look like there is a pattern for the answer  so the best thing to do is to write a simulation to try everything. The  simulation can work for n up to 15. We will notice that for n \u0026lt; 15  the only with answers are 2,4 and 8. So it looks like only powers of 2 have answers.  Using the outputs for 2, 4 and 8 you can spot the pattern for n \u003d 2^k which  can be constructed using divide and conquer. You simply take the answer for n/2  add it to the beginning, and then take that answer increment it all by n  swap rows and add it to the end.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/mO8ohr\"\u003ehttp://ideone.com/mO8ohr\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eAstronomy Problem\u003c/h3\u003e\u003cp\u003eThe limits for this problem is really small (3000 for all test cases) making  a O(N^2) solution possible. Simply pre-compute all pairs and store the  information in a data structure.  We want to store the frequency of each triple of distance.  Here are two ways to store this information using C++11 features: \u003cbr /\u003e  1. unordered_map: \u003cbr /\u003e      This is the new standard for hash_map (there is also an unordered_set). \u003cbr /\u003e      To create your own hash function for a custom class type: \u003cbr /\u003e        * Define operator\u003d\u003d for that type. \u003cbr /\u003e        * Create a struct with the following method inside: \u003cbr /\u003e            size_t operator()(MyClass const\u0026amp; my_object) const; \u003cbr /\u003e        In this method, you can reuse existing hash functions for primitive types  and combine them to return the hash of the object overall.        e.g. hash()(my_object.v1) ^ (hash()(my_object.v2) \u0026lt;\u0026lt; 1) \u003cbr /\u003e        * Pass this hasher class to the unordered_map as another template attribute \u003cbr /\u003e  2. tuple: \u003cbr /\u003e      * like a pair, but any number \u003cbr /\u003e      * create them with make_tuple \u003cbr /\u003e      * Can simplify operator\u0026lt; and other comparisons. \u003cbr /\u003e      * To read from a tuple, use tie. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/gyNKb8\"\u003ehttp://ideone.com/gyNKb8\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eFigure Skating\u003c/h3\u003e\u003cp\u003eTry to write the description of the moves as is in the statement but in the  form of regular expression and you will get the following \u003cbr /\u003e  G -\u0026gt; AF (R | E) \u003cbr /\u003e  R -\u0026gt; (F | L) (LE | SE | AG) \u003cbr /\u003e  E -\u0026gt; FST \u003cbr /\u003e  T -\u0026gt; F (AR | AE | SE) \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s try to convert the grammar to Chomsky Normal Form (read about it, very helfpul in parsing problems) \u003cbr /\u003e  G -\u0026gt; AG | FR | FE | eps \u003cbr /\u003e  R -\u0026gt; FR | LR | LE | SE | AG \u003cbr /\u003e  E -\u0026gt; FE | ST \u003cbr /\u003e  T -\u0026gt; FT | AR | AE | SE \u003cbr /\u003e\u003c/p\u003e\u003cp\u003ewhere eps is an empty sequence. \u003cbr /\u003e  Now each sequences is just of 4 types G, R, E and T and can be formed by using only the 4 types  You can easily form a linear recurrence for each type e.g  R(n) \u003d 2 R(n — 1) + 2 E(n — 1) + G(n — 1) \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eNow you just construct the matrix and do exponentation\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/IwYRt2\"\u003ehttp://ideone.com/IwYRt2\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eGame of Col on Bamboo Forests\u003c/h3\u003e\u003cp\u003eFor each chain in the forest: \u003cbr /\u003e if its size is 1: Then Alice wins since he starts. so it\u0027s a winning position (grundy number \u003d 1) size \u0026gt; 1: When Alice choose the first position, there will always at least one node in the chain that Alice can\u0027t use and Bob can (Here Bob will be smart, and save that block to the end of the game). So now, after this first step, if the rest of the chain led to the fact that Bob need to make the last move, then he can do it and Alice lose because the saved blocked is not accessible by him. However if the rest of the chain made Alice do the last step, then here Bob can use the block he secured to make the the final step at the game and win. So Bob always wins in that case. (grundy number \u003d 0) \u003cbr /\u003e Given the above observations, we need to select K from the N chains so that the XOR value of the grundy numbers !\u003d 0.\u003cbr /\u003e We can do that with the following DP where the state is the (index of the current chain), (Remaining number of chains from K), (0 or 1) and the transitions will become as follows: \u003cbr /\u003e Leave the current chain or Take the current chain \u003cbr /\u003e DP[i][rem][x] \u003d (DP[i + 1][rem][x] + DP[i + 1][rem — 1][x ^ XOR_Value[i]]) % MOD\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/kwKNVT\"\u003ehttp://ideone.com/kwKNVT\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eJingles of a String\u003c/h3\u003e\u003cp\u003eLet\u0027s compute the answer for jingles of substrings starting at a certain index  you will notice that, the further you move from that index to the right, the size  of your jingle can only increase. Starting at each index we will increase the size  of the jingle by only 1 at a time by finding the nearest index of a character not  already in the jingle. This can be simply done by precomputing a next array.  While constructing jingles (you can keep that as a mask) you shall keep track of  the longest substring that consisted of that jingle so far and increment the answer  as you proceed in an array of size 2^26.  The code needed some optimizations like avoiding to memset the 2^26 array by using  the case number as a marker, also counting bits in a mask smartly using divide and conquer.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/P0wcdH\"\u003ehttp://ideone.com/P0wcdH\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eChip Installation\u003c/h3\u003e\u003cp\u003eThis a direct 2SAT problem. The only tricky part is that you need to make exactly one of 2 variables true (not only the oring) which is equivalent to (x || y) \u0026amp;\u0026amp; ( || )\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/3QFm3Y\"\u003ehttp://ideone.com/3QFm3Y\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eDvisible Substrings\u003c/h3\u003e\u003cp\u003eA dynamic programming problem, for each non terminal i we calculate the following suff[i][k] \u003d how many suffixes mod n have value k. pref[i][k][l] \u003d how many prefixes mod n have value k, and length q where 10\u003csup\u003eq\u003c/sup\u003e mod n \u003d l. using those we can count the number of substrings that are divisible by n.\u003c/p\u003e\u003cp\u003eCode1: \u003ca href\u003d\"http://ideone.com/DqWW9i\"\u003ehttp://ideone.com/DqWW9i\u003c/a\u003e \u003cbr /\u003e Code2: \u003ca href\u003d\"http://ideone.com/qvI4ZN\"\u003ehttp://ideone.com/qvI4ZN\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eSquary Sets\u003c/h3\u003e\u003cp\u003eThis is a backtracking problem in which you try everything. Writing a backtracking  solution requires extra care since the search space is usually very large.  Some advice that prune the search space is the following: \u003cbr /\u003e  1) Generate the numbers in increasing order.\u003cbr /\u003e  2) Prune dead ends early.\u003cbr /\u003e  3) Only move to a promising state.\u003cbr /\u003e  4) Memoize states to avoid repetition.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eCode1: \u003ca\u003ehttp://ideone.com/rpjiaW\u003cbr /\u003e\u003c/a\u003e Code2: \u003ca href\u003d\"http://ideone.com/sCuFBP\"\u003ehttp://ideone.com/sCuFBP\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eSQRT(Nim)\u003c/h3\u003e\u003cp\u003eIn Nim games, it\u0027s alwys a smart idea to run a simulation and check  for patterns. One you do that, you will see that the pattern is  you have a series of WINS followed by exactly 1 LOSE and this repeats  somehow. Close inspection reveals that the number of WINS depends on  the value of the next perfect square (should be suspected from the name)  where you have k WINS if current + k \u0026lt; next square otherwise you have k+1  followed by 1 LOSE and then you repeat the rule. A solution can be written  in O(sqrt(n)).\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/w0z2v4\"\u003ehttp://ideone.com/w0z2v4\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eSubstring Search\u003c/h3\u003e\u003cp\u003eThe problem is just a string matching problem which is expected to be  solved by a string matching algorithm (e.g KMP). The only problems lies  in the comparsion where aba should be equal to cdc since they are the same  pattern. Luckily, this can be easily solved with adding some extra DP.  Lets fix the comparison issue for a naive algorithm and then see we  can augment the KMP. Assume you are comparing s1.substring(i, j) to s2  and the two characters at index i don\u0027t match. This shouldn\u0027t be a problem  as long as 2 conditions are met: \u003cbr /\u003e  1) The character in string s1 never appeared before or appeared and was matched  to the same character in s2. \u003cbr /\u003e  2) The character in string s2 never appeared before or appeared and was matched  to the same characer in s1.\u003cbr /\u003e  How can we check for these conditions? We simply need to keep track of the closest  previous index of the same type of each character and check if it\u0027s either in the  compared substring or not and if yes the corresponding character is the same.  This same check can be augmented to KMP\u0027s both failure and matching function.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/MvNTpy\"\u003ehttp://ideone.com/MvNTpy\u003c/a\u003e\u003c/p\u003e\u003ch3\u003ePerfect Lodging\u003c/h3\u003e\u003cp\u003eAn undirected graph has to be constructed from the given directed graph where two nodes are connected if each of them can stay with the other. The problem then becomes direct maximum matching on a general graph, an easy way to tell whether there\u0027s a perfect matching or not it is to use \u003ca href\u003d\"http://e-maxx.ru/algo/tutte_matrix\"\u003etutte\u0027s matrix.\u003c/a\u003e\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/I8v8Ci\"\u003ehttp://ideone.com/I8v8Ci\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eTravel Agency\u003c/h3\u003e\u003cp\u003eFirst we observe that for a node k to be critical on some path between (i, j), it has to be an articulation point in the graph since (i, j) would be disconnected if we remove it\u003c/p\u003e\u003cp\u003eTo solve this problem we study the dfs tree of the undirected graph where the edges are classified as forward/backward edges. \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/d4/0a/d40a67ff6309faa49a0af0fca1d5977cdbb9dd62.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eA Node is an articulation point if one of it\u0027s children subtrees does not have back edge to one of it\u0027s ancestors. For example Node D is an articulation point, since F does not have a back edge to A or B. While Node B is not an articulation point, since D has a back edge to A.\u003c/p\u003e\u003cp\u003eNow for any node i that is an articulation point has a child j where no back edges go from Tj to ancestors of i, then all paths that go from any node in Tj to any node not in Tj must pass by i, we then can use this property to calculate the answer for each node.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/0TYSad\"\u003ehttp://ideone.com/0TYSad\u003c/a\u003e Finding Articulation points: \u003ca href\u003d\"http://e-maxx.ru/algo/cutpoints\"\u003ehttp://e-maxx.ru/algo/cutpoints\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eNumbers\u003c/h3\u003e\u003cp\u003eA little observation leads you to notice that among all numbers of certain length l, only one of them is canidate to be the best answer. Now it\u0027s always better if that number is 10^(l-1) but it might not be divisible so u simply need to find the number closest to it that\u0027s divisble. Now repeat that for each length and find the minimum over all.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/5ZRKnk\"\u003ehttp://ideone.com/5ZRKnk\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eHigh Speed Trains\u003c/h3\u003e\u003cp\u003eWhen you see counting the number of ways, your first though should be dynamic programming. You will need to try connecting every possible pair of nodes and count all the ways. Your state will contain how many cities are connected so far and how many are not (the index of current city is just their sum). At each city, you decide to either: \u003cbr /\u003e 1) Not connect it to any of the past cities (leave it unconnected for now \u003cbr /\u003e 2) Connect to any subset (2^con) of the already connected city \u003cbr /\u003e 3) Connect it to a subset of the unconnected cities. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eYour base case is when you reach the last city and all of them are already connected. When you run it on the first couple of cases, you will find 2 things: \u003cbr /\u003e 1) You need BigInteger for the answer. \u003cbr /\u003e 2) The running time is very slow for large cases. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eLuckily, there is only 100 cases so you can hard code the answer\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/Z1AOmz\"\u003ehttp://ideone.com/Z1AOmz\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eA Graph Game\u003c/h3\u003e\u003cp\u003eOne thing we should think about when we face game theory problems is winning states and losing states, a state is a winning state if one of it\u0027s next states is a losing state, while a state is a losing state if all it\u0027s next states are winning states.\u003c/p\u003e\u003cp\u003eWe often are able to identify winning states and losing states by trying to play several games and several examples \u003c/p\u003e\u003cp\u003eLet\u0027s check some of them \u003c/p\u003e\u003cp\u003ea b \u003cbr /\u003e since both nodes has no edges, thus starting at any of them gives a loss. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003ea----b \u003cbr /\u003e obviously starting from both positions leads to a win. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003ea----b \u003cbr /\u003e   \\ \u003cbr /\u003e    \\ \u003cbr /\u003e     \\c \u003cbr /\u003e starting at a gives a win, starting from either b or c gives a loss. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eNow that the graph is bipartite and the constraints should give some intuition that the problem is somehow related to bipartite matching, what we can see from the previous small examples is that:-\u003c/p\u003e\u003cp\u003eIf a node has no edges thus starting at this node is a loss. \u003cbr /\u003e If a node is essential in the maximum matching (i.e if we remove this node the maximum matching will be reduced by 1) then being at this node is a win. \u003cbr /\u003e If a node is not essential in maximum matching (i.e we can remove this node and augmenting the graph such that the maximum matching does not decrease) then this node a loss. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eNow that we have something, time to prove it. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003ethere exists A winning state\u0027s next is always a losing state, why ? \u003cbr /\u003e If we remove a node X (paired with with some node Y) that is essentially needed to achieve the maximum matching then the maximum matching will decrease by 1, and this node\u0027s pair Y will either have no edges (losing) or will have edges that allows it to be matched but since the matching has already decreased by 1, then Y is not essential in the new maximum matching (i.e Y can be unmatched keeping the new maximum matching as it is)\u003c/p\u003e\u003cp\u003eA losing state\u0027s next is always a winning state, why ? \u003cbr /\u003e After we remove a node X that is not essentially needed in maximum matching, the size of the maximum matching will not change, also all nodes adjacent to X will be essentially needed in the maximum matching, why ? because of one of them was not needed then we could match it with the removed X and that contradicts with the matching being maximum.\u003c/p\u003e\u003cp\u003eThis completes the proof, game theory problems are more of guess and check you can\u0027t do much if you don\u0027t a good guess or it\u0027s a famous game like NIM or something you can apply grundy numbers in.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/8UcP00\"\u003ehttp://ideone.com/8UcP00\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}