{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1514033441,"rating":14,"authorHandle":"Miyukine","modificationTimeSeconds":1514286922,"id":56575,"title":"\u003cp\u003eSolutions for MeetIT training contest\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eDisclaimer\u003c/strong\u003e \u003c/p\u003e\u003cp\u003eThe post will be mostly in Polish, as it will just contain solutions for training contests. I found Codeforces the most convenient place for writing them and allowing the participants comment.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003ePierwszy krok (23 grudnia)\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eObydwa zadania pochodzą z 11 oia. Szczegółowe rozwiązania można przeczytać w niebieskiej książeczce olimpiady.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eMost\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTo było dzisiaj łatwiejsze zadanie. Wiele osób skończyło z 10 punktami, nieuważnie testując swoje rozwiązanie. Zadanie wydaje się proste, chociaż ma pewien haczyk. Rozwiązanie zachłanne niestety nie do końca działa.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003ePosortujmy elementy tablicy. Spróbujmy policzyć wynik programowaniem dynamicznym. Często opłaca nam się przeprawiać osobę najszybszą z ostatnią osobą. To jednak nie zawsze jest optymalne.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eJest jeszcze drugi rodzaj ruchu -- możemy wziąć dwie najwolniejsze osoby, a latarkę wrócą wcześniej przewiezieni najszybsi. Z tego już można napisać programowanie dynamiczne, które dostaje 100 pkt.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTurniej\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTo było trudniejsze zadanie, co zresztą widać po wynikach. Łączy w sobie odrobinę kminy z odrobiną klepania.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eZasymulujmy turniej raz i spójrzmy, kto wygrał. Co możemy o nim powiedzieć?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eKluczowa obserwacja: Niech W będzie wygranym w turnieju. Wówczas osoba X może wygrać turniej wtedy i tylko wtedy, gdy istnieje ciąg X -\u0026gt; Y -\u0026gt; ... -\u0026gt; W, gdzie strzałki oznaczają: \u0026quot;Jest w stanie wygrać z\u0026quot;. Dowód idzie dość prosto -- wyobraźmy sobie kolejność meczy gdzie W wygrywa, usuńmy wszystkie mecze z zawodnikami \u0026quot;X, Y, ..., W\u0026quot;, a następnie dorzućmy na koniec turnieju w odwrotnej kolejności (tak, żeby na końcu X został niepokonany).\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 3\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTeraz mamy już proste zadanie grafowe -- chcemy sprawdzić, dla których wierzchołków X istnieje ścieżka z X do W. To oczywiście oznacza, że istnieje ścieżka z W do X w grafie z odwróconymi krawędziami. Można więc puścić BFSa. Krawędzi jest jednak pesymistycznie O(n^2). Co teraz?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 4\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eMożemy trzymać zbiór wszystkich nieodwiedzonych wierzchołków. Przeglądając jakiś wierzchołek Q w bfsie będziemy po prostu patrzeć, do których z tych wierzchołków da się dojść z Q. A da się wtedy i tylko wtedy, gdy taki nowy wierzchołek nie jest na liście Q. To pozwala nam w miarę łatwo zasymulować tę procedurę setem lub przy pomocy struktury find \u0026amp; union.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eWiecznie drugi (24 grudnia)\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eDzisiejsze zadania były z 2 etapu 17 oia i powinny się wykazywać trudnością większą niż poprzednie. Czasem do wejścia do finału wystarczą tylko 4 bruty ;)\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eKlocki\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eJest jedna obserwacja, która praktycznie rozwala całe zadanie. Dla danego k przedział \u0026lt;a; b\u0026gt; jest dobry wtedy i tylko wtedy, gdy średnia na tym przedziale jest \u0026gt;\u003d k, czyli suma większa niż (b-a+1)*k. Łatwo wykazać, że to warunek konieczny i pokazać algorytm, który przekłada klocki żeby było w porządku.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003ePoprzednia obserwacja wystarcza już do uzyskania dużej liczby punktów za mn log n w zasadzie jakkolwiek. Żeby to zbić do liniówki potrzebujemy jeszcze jednej obserwacji — jeśli szukamy przedziału o średniej \u0026gt;\u003d k, to możemy od każdej liczby odjąć k, a następnie szukać najdłuższego przedziału o nieujemnej sumie. Na to ostatnie istnieje banalny zachłanny algorytm liniowy, zwany algorytmem Kadane\u0027a.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eChomiki\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eMożemy potraktować tę sytuację jako graf, a kolejne przejścia jako krawędzie.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eMamy jakiś prosty podproblem tekstowy — to haszowanie lub funkcja prefiksowa od KMP.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 3\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eMamy jeszcze jakiś prosty podproblem grafowy — a, jak wiadomo, wszystko na ścieżkach w dowolnych grafach robi się w n^3 log M potęgowaniem macierzy. Pełne rozwiązanie w książeczce OI.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eTrzej muszkieterowie (26 grudnia)\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eTrudniej już nie będzie :) 10 oi, ale zadania z siekierą. Myślałem, że autostrady są łatwiejsze, bo źle zrozumiałem na początku treść.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eAutostrady\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTo miało być łatwiejsze zadanie i chyba było. Ciekawostka — wzorcówka ma 400 linii i kodzi drzewo splay. Spokojnie, da się łatwiej.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eSkoro chcemy podzielić wierzchołki na dwie grupy to interesować nas będą grafy dwudzielne.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eZauważmy, że dwie autostrady reprezentowane przez odcinki (a1, a2) i (b1, b2) nie mogą być zbudowane po jednej stronie wtedy i tylko wtedy, gdy te odcinki zahaczają się (czyli zachodzi a1 \u0026lt; b1 \u0026lt; a2 \u0026lt; b2 lub b1 \u0026lt; a1 \u0026lt; b2 \u0026lt; a2). Z tego możemy już zbudować graf, który pesymistycznie ma \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e krawędzi i puścić na nim zwykłego dfsa do dwudzielnego grafu.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 3\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eWystarczy tylko przyspieszyć proces wyszukiwania krawędzi tak jak robiliśmy to w zadaniu turniej. Będziemy trzymać zbiór nieodwiedzonych wierzchołków, a następnie sprowadzimy szukanie krawędzi do zadania na drzewo przedziałowe.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 4\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003ePowiedzmy, że obsługujemy przedział \u0026lt;a, b\u0026gt; w bfsie i chcemy znaleźć krawędzie (oczywiście tylko wśród wierzchołków, których BFS jeszcze nie odwiedził). Wówczas (jeden z przypadków, drugi analogicznie) interesują nas odcinki, których lewy koniec leży w \u0026lt;a+1, b-1\u0026gt; a prawy koniec gdzieś po prawej stronie w \u0026lt;b+1, inf\u0026gt;. Wobec tego, możemy znaleźć maksymalny prawy koniec na przedziale \u0026lt;a+1, b-1\u0026gt; (i tu drzewo). Jeśli tworzy krawędź, to go usuniemy i wrzucimy na kolejkę, a w przeciwnym wypadku żaden z tych przedziałów nie może tworzyć krawędzi z naszym. Każdy odcinek wrzucimy i usuniemy co najwyżej raz, a zapytań na drzewie będzie \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlogn\u003c/i\u003e)\u003c/span\u003e i taka jest też złożoność całego algorytmu.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTrójmian\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eMówiłem już, że rzucający zadanie nie musi umieć go zrobić? :)))))\u003c/p\u003e\u003cp\u003eNieco poważniej — to zadanie miało przypomnieć o pewnym nieśmiertelnym sposobie rozwiązywania zadań. (Patrz hint 1).\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eWśród dziwacznych operacji i wzorów warto zawsze napisać rozwiązanie brutalne, a potem zobaczyć co się dzieje. Napisz bruta i zobacz co się dzieje :)))))\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eMożna zauważyć dwie zależności, które pozwalają nam napisać efektywne rozwiązanie. Więcej w książeczce 10 OI.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["solutions","polish","polish oi"]}}