{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1461655874,"rating":-17,"authorHandle":"2742195759","modificationTimeSeconds":1461655874,"id":44557,"title":"\u003cp\u003ecodeforces638B\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e坑爹,题意居然是这样的. 他是,给你一个DNA,这个DNA中每个字母只会出现一次,然后分解得到了很多的碎片,问还原原来的DNA碎片就可以,也就是出入会有一个保证,保证一定是ab , bs 之后,不会出现b了,因为如果出现了,那么原来的DNA就包含两个b,也就不是满足题目意思.这样的话,就直接DFS就可以了,一个一个来,每一个字母建一个点.连边就可以.\u003c/p\u003e\u003ch1\u003einclude \u003c/h1\u003e\u003ch1\u003einclude \u003c/h1\u003e\u003ch1\u003einclude \u003c/h1\u003e\u003ch1\u003einclude \u003c/h1\u003e\u003ch1\u003einclude \u003c/h1\u003e\u003ch1\u003einclude \u003c/h1\u003e\u003ch1\u003einclude \u003c/h1\u003e\u003ch1\u003einclude \u003c/h1\u003e\u003ch1\u003einclude \u003c/h1\u003e\u003ch1\u003einclude \u003c/h1\u003e\u003ch1\u003edefine PI acos(-1.0)\u003c/h1\u003e\u003ch1\u003edefine CLR(a, b) memset(a, (b), sizeof(a))\u003c/h1\u003e\u003ch1\u003edefine fi first\u003c/h1\u003e\u003ch1\u003edefine se second\u003c/h1\u003e\u003ch1\u003edefine ll o\u0026lt;\u0026lt;1\u003c/h1\u003e\u003ch1\u003edefine rr o\u0026lt;\u0026lt;1|1\u003c/h1\u003e\u003cp\u003eusing namespace std; typedef long long LL; typedef pair\u0026lt;int, int\u0026gt; pii; const int MAXN \u003d 2*1e5 + 1; const int pN \u003d 1e6;// \u0026lt;\u003d 10^7 const int INF \u003d 0x3f3f3f3f; const int MOD \u003d 1e9 + 7; void add(LL \u0026amp;x, LL y) { x +\u003d y; x %\u003d MOD; } vector next[30]; bool vis[30], mark[30]; string res \u003d \u0026quot;\u0026quot;; int in[30]; void DFS(int u) {  vis[u] \u003d true; res +\u003d u + \u0027a\u0027;  for(int i \u003d 0; i \u0026lt; next[u].size(); i++) {  int v \u003d next[u][i];  if(in[v] !\u003d 0 \u0026amp;\u0026amp; vis[v] \u003d\u003d false) {  DFS(v);  }  } } int main() {  int n; cin \u0026gt;\u0026gt; n; string a;  for(int i \u003d 0; i \u0026lt; n; i++) {  cin \u0026gt;\u0026gt; a;  for(int j \u003d 0; j \u0026lt; a.size(); j++) {  if(j !\u003d a.size() — 1) {  next[a[j]-\u0027a\u0027].push_back(a[j+1]-\u0027a\u0027);  in[a[j+1]-\u0027a\u0027]++;  }  mark[a[j]-\u0027a\u0027] \u003d true;  }  }  for(int i \u003d 0; i \u0026lt; 26; i++) {  if(in[i] \u003d\u003d 0 \u0026amp;\u0026amp; mark[i]) {  DFS(i);  }  }  cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl;  return 0; }\u003c/p\u003e\u003c/div\u003e","tags":["dfs","string","题意"]}}