{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1519856838,"rating":0,"authorHandle":"leaomatheus","modificationTimeSeconds":1519869133,"id":58097,"title":"\u003cp\u003eMenor ancestral comum em árvore (LCA)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eTexto recomendado como referência: \u003ca\u003ehttps://www.topcoder.com/community/data-science/data-science-tutorials/range-minimum-query-and-lowest-common-ancestor/#Lowest%20Common%20Ancestor%20(LCA\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eO menor ancestral comum (Lowest Common Ancestor, ou LCA) é definido como o primeiro nó que dois nós tem em comum em uma árvore. Na árvore abaixo, o LCA entre 4 e 5 é o nó 2. Observe que 1 também é ancestral comum, mas estamos interessados no com maior profundidade.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/cc/4f/cc4fa69907347f5ce90385a5c4cb44b95bfb8bd0.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch3\u003eImplementação\u003c/h3\u003e\u003cp\u003eA solução para o problema é conhecida. Primeiro, precomputamos a altura de todos os nós, que é a distância do nó até a raiz. Em seguida, subimos o nó mais fundo até que as alturas fiquem iguais e em seguida subimos ambos simultaneamente até que encontramos o nó comum.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint height[CNT];      // CNT é o total de nós\nvector\u0026lt;int\u0026gt; sons[CNT];\nint parent[CNT];     // Link pro pai\n\n// precomputa altura dos nos, comecando da raiz\nvoid dfs(int no, int altura) {\n   height[no] \u003d altura;\n   for (int i \u003d 0; i \u0026lt; sons[no].size(); i++) {\n       dfs(sons[no][i], altura+1);\n   }\n}\n\n// Indice do no em comum\nint lca(int a, int b) {\n    while (height[a] \u0026gt; height[b]) a \u003d parent[a];\n    while (height[a] \u0026lt; height[b]) b \u003d parent[b];\n\n   // A partir daqui, a e b estao a mesma altura\n    while (a !\u003d b) { a \u003d parent[a]; b \u003d parent[b]; }\n    return a;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eBinary Lifting\u003c/h3\u003e\u003cp\u003eO problema desse código é que ele passa por todas as arestas para encontrar o LCA. Para otimizar, usamos a técnica de Binary Lifting. A ideia é precomputar alguns pais para cada nó. Mais precisamente, para cada nó precomputamos logN pais -- o pai que está a distância 1 (o próprio pai da definição), a distância 2 (avô), distância 4, distância 8 ... distância 2^k. Observe que k é no máximo log(altura da árvore).\u003c/p\u003e\u003cp\u003ePrecomputar isso é simples. O pai de um nó a distância 8 é o pai a distância 4 do meu pai a distância 4, por exemplo. Com código fica mais claro.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (int no \u003d 1; no \u0026lt;\u003d N; no++) parent[no][0] \u003d PAI       // O pai 0 é o próprio pai\n \nfor (int i \u003d 1; i \u0026lt;\u003d LOGN; i++) {   // Supondo que LOGN seja o log da altura máxima\n    for (int no \u003d 1; no \u0026lt;\u003d N; no++) {\n        if (parent[no][i-1] \u0026gt; 0)     // Se esse nó tem um pai a essa distância\n            parent[no][i] \u003d parent[parent[no][i-1]][i-1];   // Link para pai do pai\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ePara encontrar o LCA, a ideia é a mesma, o que muda é apenas a velocidade em que subimos na árvore. Podemos pular nós que não sejam interessante. Por exemplo, supomos que o nó A está a profundidade 18 e nó B está a profundidade 3. Isso indica que devemos subir A 15 vezes. Mas para fazer isso, podemos subir A 8 + 4 + 2 + 1 vezes. Podemos subir qualquer valor, dado que qualquer número pode ser expresso como a soma de potências de 2 diferentes. Para isso, simplesmente testamos quanto podemos subir.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint lca(int a, int b) {\n    if (height[a] \u0026gt; height[b]) {\n        for (int i \u003d LOGN; i \u0026gt;\u003d 0; i--) {\n            if (height[parent[a][i]] \u0026lt; height[b]) a \u003d parent[a][i];\n        }\n        a \u003d parent[a][0];\n    }\n    if (height[b] \u0026gt; height[a]) {\n        for (int i \u003d LOGN; i \u0026gt;\u003d 0; i--) {\n            if (height[parent[b][i]] \u0026lt; height[a]) b \u003d parent[b][i];\n        }\n        b \u003d parent[b][0];\n    }\n\n    if (a \u003d\u003d b) return a;\n    for (int i \u003d LOGN; i \u0026gt;\u003d 0; i--) {\n        if (parent[a][i] !\u003d parent[b][i]) { a \u003d parent[a][i]; b \u003d parent[b][i]; }\n    }\n    a \u003d parent[a]; b \u003d parent[b];\n    return a;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEssa ténica pode ser utilizada para qualquer contexto que precisamos precomputar informações sobre um nó até o k-esimo pai dele -- uma variação interessante é achar a soma na árvore, sendo que cada aresta tem um peso. Para isso, a ideia é parecida.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// Executa dos nós mais altos para os mais baixos.\nfor (int no \u003d 1; no \u0026lt;\u003d N; no++) {\n    soma[no][0] \u003d SOMA_PARA_PAI;\n    parent[no][0] \u003d PAI;\n}\n\nfor (int i \u003d 1; i \u0026lt;\u003d LOGN; i++) {   // Supondo que LOGN seja o log da altura máxima\n    for (int no \u003d 1; no \u0026lt;\u003d N; no++) {\n        if (parent[no][i-1] \u0026gt; 0)        // Se esse nó tem um pai a essa distância\n            soma[no][i] \u003d soma[parent[no][i-1]][i-1] + soma[no][i-1];   // Link para pai do pai\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eProblemas sugeridos:\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/932/D\"\u003eCodeforces Round #463\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/191/C\"\u003eMashup Training #1 — Codeforces Round #191\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://www.urionlinejudge.com.br/judge/en/problems/view/2703\"\u003eFinal Brasileira 2017\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}