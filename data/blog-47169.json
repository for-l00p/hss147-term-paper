{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1474127332,"rating":173,"authorHandle":"zscoder","modificationTimeSeconds":1474131894,"id":47169,"title":"\u003cp\u003eCodeforces Round #372 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eWe hope everyone enjoyed the problems. Here is the editorial for the problems. I tried to make it more detailed but there might be some parts that might not be explained clearly.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/716/problem/A\"\u003eDiv. 2 A — Crazy Computer\u003c/a\u003e\u003c/h2\u003e\u003cp\u003ePrerequisites : None\u003c/p\u003e\u003cp\u003eThis is a straightforward implementation problem. Iterate through the times in order, keeping track of when is the last time a word is typed, keeping a counter for the number of words appearing on the screen. Increment the counter by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e whenever you process a new time. Whenever the difference between the time for two consecutive words is greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e, reset the counter to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. After that, increment it by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eTime Complexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e, since the times are already sorted.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode (O(n))\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int N \u003d 1e5 + 3;\nll a[N];\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, c; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; c;\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tcin \u0026gt;\u0026gt; a[i];\n\t}\n\t//sort(a, a + n);\n\tint cnt \u003d 0;\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tif(i \u003d\u003d 0) cnt++;\n\t\telse\n\t\t{\n\t\t\tif(a[i] - a[i - 1] \u0026lt;\u003d c) cnt++;\n\t\t\telse cnt \u003d 1;\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; cnt;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/716/problem/B\"\u003eDiv. 2 B — Complete The Word\u003c/a\u003e\u003c/h2\u003e\u003cp\u003ePrerequisites : None\u003c/p\u003e\u003cp\u003eFirstly, if the length of the string is less than \u003cspan class\u003d\"tex-span\"\u003e26\u003c/span\u003e, output \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e immediately.\u003c/p\u003e\u003cp\u003eWe want to make a substring of length \u003cspan class\u003d\"tex-span\"\u003e26\u003c/span\u003e have all the letters of the alphabet. Thus, the simplest way is to iterate through all substrings of length \u003cspan class\u003d\"tex-span\"\u003e26\u003c/span\u003e (there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e such substrings), then for each substring count the number of occurrences of each alphabet, ignoring the question marks. After that, if there exist a letter that occurs twice or more, this substring cannot contain all letters of the alphabet, and we process the next substring. Otherwise, we can fill in the question marks with the letters that have not appeared in the substring and obtain a substring of length \u003cspan class\u003d\"tex-span\"\u003e26\u003c/span\u003e which contains all letters of the alphabet. After iterating through all substrings, either there is no solution, or we already created a nice substring. If the former case appears, output \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e. Otherwise, fill in the remaining question marks with random letters and output the string.\u003c/p\u003e\u003cp\u003eNote that one can optimize the solution above by noting that we don\u0027t need to iterate through all \u003cspan class\u003d\"tex-span\"\u003e26\u003c/span\u003e letters of each substring we consider, but we can iterate through the substrings from left to right and when we move to the next substring, remove the front letter of the current substring and add the last letter of the next substring. This optimization is not required to pass.\u003c/p\u003e\u003cp\u003eWe can still optimize it further and make the complexity purely \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003es\u003c/i\u003e|)\u003c/span\u003e. We use the same trick as above, when we move to the next substring, we remove the previous letter and add the new letter. We store a frequency array counting how many times each letter appear in the current substring. Additionally, store a counter which we will use to detect whether the current substring can contain all the letters of the alphabet in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e. When a letter first appear in the frequency array, increment the counter by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. If a letter disappears (is removed) in the frequency array, decrement the counter by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. When we add a new question mark, increment the counter by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. When we remove a question mark, decrement the counter by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. To check whether a substring can work, we just have to check whether the counter is equal to \u003cspan class\u003d\"tex-span\"\u003e26\u003c/span\u003e. This solution works in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003es\u003c/i\u003e|)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTime Complexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003es\u003c/i\u003e|·26\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003es\u003c/i\u003e|·26)\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003es\u003c/i\u003e|)\u003c/span\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode (O(26^2*|s|)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int N \u003d 10000;\nint cnt[27];\nstring s; int n;\n\nbool valid()\n{\n\tfor(int i \u003d 0; i \u0026lt; 26; i++)\n\t{\n\t\tif(cnt[i] \u0026gt;\u003d 2) return false;\n\t}\n\treturn true;\n}\n\nvoid fillall()\n{\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tif(s[i] \u003d\u003d \u0027?\u0027) s[i] \u003d \u0027A\u0027;\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin \u0026gt;\u0026gt; s;\n\tn \u003d s.length();\n\tif(n \u0026lt; 26) {cout \u0026lt;\u0026lt; -1; return 0;}\n\tfor(int i \u003d 25; i \u0026lt; n; i++)\n\t{\n\t\tmemset(cnt, 0, sizeof(cnt));\n\t\tfor(int j \u003d i; j \u0026gt;\u003d i - 25; j--)\n\t\t{\n\t\t\tcnt[s[j]-\u0027A\u0027]++;\n\t\t}\n\t\tif(valid())\n\t\t{\n\t\t\t//cout \u0026lt;\u0026lt; \u0026quot;GG \u0026quot; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t\t\tint cur \u003d 0;\n\t\t\twhile(cnt[cur]\u0026gt;0) cur++;\n\t\t\tfor(int j \u003d i - 25; j \u0026lt;\u003d i; j++)\n\t\t\t{\n\t\t\t\tif(s[j] \u003d\u003d \u0027?\u0027)\n\t\t\t\t{\n\t\t\t\t\ts[j] \u003d cur + \u0027A\u0027;\n\t\t\t\t\tcur++;\n\t\t\t\t\twhile(cnt[cur]\u0026gt;0) cur++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfillall();\n\t\t\tcout \u0026lt;\u0026lt; s;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; -1;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode (O(26*|s|)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int N \u003d 10000;\nint cnt[27];\nstring s; int n;\n\nbool valid()\n{\n\tfor(int i \u003d 0; i \u0026lt; 26; i++)\n\t{\n\t\tif(cnt[i] \u0026gt;\u003d 2) return false;\n\t}\n\treturn true;\n}\n\nvoid fillall()\n{\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tif(s[i] \u003d\u003d \u0027?\u0027) s[i] \u003d \u0027A\u0027;\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin \u0026gt;\u0026gt; s;\n\tn \u003d s.length();\n\tif(n \u0026lt; 26) {cout \u0026lt;\u0026lt; -1; return 0;}\n\tfor(int i \u003d 0; i \u0026lt; 26; i++) cnt[s[i]-\u0027A\u0027]++;\n\tif(valid())\n\t{\n\t\tint cur \u003d 0;\n\t\twhile(cnt[cur]\u0026gt;0) cur++;\n\t\tfor(int i \u003d 0; i \u0026lt; 26; i++)\n\t\t{\n\t\t\tif(s[i] \u003d\u003d \u0027?\u0027)\n\t\t\t{\n\t\t\t\ts[i] \u003d cur + \u0027A\u0027;\n\t\t\t\tcur++;\n\t\t\t\twhile(cnt[cur]\u0026gt;0) cur++;\n\t\t\t}\n\t\t}\n\t\tfillall();\n\t\tcout \u0026lt;\u0026lt; s;\n\t\treturn 0;\n\t}\n\tfor(int i \u003d 26; i \u0026lt; n; i++)\n\t{\n\t\tcnt[s[i]-\u0027A\u0027]++; cnt[s[i-26]-\u0027A\u0027]--;\n\t\tif(valid())\n\t\t{\n\t\t\t//cout \u0026lt;\u0026lt; \u0026quot;GG \u0026quot; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t\t\tint cur \u003d 0;\n\t\t\twhile(cnt[cur]\u0026gt;0) cur++;\n\t\t\tfor(int j \u003d i - 25; j \u0026lt;\u003d i; j++)\n\t\t\t{\n\t\t\t\tif(s[j] \u003d\u003d \u0027?\u0027)\n\t\t\t\t{\n\t\t\t\t\ts[j] \u003d cur + \u0027A\u0027;\n\t\t\t\t\tcur++;\n\t\t\t\t\twhile(cnt[cur]\u0026gt;0) cur++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfillall();\n\t\t\tcout \u0026lt;\u0026lt; s;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; -1;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode (O(|s|)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int N \u003d 50000;\nint cnt[27];\nstring s; int n;\nint counter;\n\nbool valid()\n{\n    //cout \u0026lt;\u0026lt; counter \u0026lt;\u0026lt; endl;\n\treturn (counter \u003d\u003d 26);\n}\n\nvoid fillall()\n{\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tif(s[i] \u003d\u003d \u0027?\u0027) s[i] \u003d \u0027A\u0027;\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin \u0026gt;\u0026gt; s;\n\tn \u003d s.length();\n\tif(n \u0026lt; 26) {cout \u0026lt;\u0026lt; -1; return 0;}\n\tcounter \u003d 0;\n\tfor(int i \u003d 0; i \u0026lt; 26; i++)\n\t{\n\t\tif(s[i] \u003d\u003d \u0027?\u0027)\n\t\t{\n\t\t\tcounter++; continue;\n\t\t}\n\t\tcnt[s[i]-\u0027A\u0027]++;\n\t\tif(cnt[s[i]-\u0027A\u0027] \u003d\u003d 1) counter++;\n\t}\n\tif(valid())\n\t{\n\t\tint cur \u003d 0;\n\t\twhile(cnt[cur]\u0026gt;0) cur++;\n\t\tfor(int i \u003d 0; i \u0026lt; 26; i++)\n\t\t{\n\t\t\tif(s[i] \u003d\u003d \u0027?\u0027)\n\t\t\t{\n\t\t\t\ts[i] \u003d cur + \u0027A\u0027;\n\t\t\t\tcur++;\n\t\t\t\twhile(cnt[cur]\u0026gt;0) cur++;\n\t\t\t}\n\t\t}\n\t\tfillall();\n\t\tcout \u0026lt;\u0026lt; s;\n\t\treturn 0;\n\t}\n\tfor(int i \u003d 26; i \u0026lt; n; i++)\n\t{\n\t\tif(s[i] !\u003d \u0027?\u0027) {cnt[s[i]-\u0027A\u0027]++; if(cnt[s[i]-\u0027A\u0027]\u003d\u003d1) counter++;}\n\t\tif(s[i-26] !\u003d \u0027?\u0027) {cnt[s[i-26]-\u0027A\u0027]--; if(cnt[s[i-26]-\u0027A\u0027]\u003d\u003d0) counter--;}\n\t\tif(s[i-26] \u003d\u003d \u0027?\u0027) counter--;\n\t\tif(s[i] \u003d\u003d \u0027?\u0027) counter++;\n\t\tif(valid())\n\t\t{\n\t\t\tint cur \u003d 0;\n\t\t\twhile(cnt[cur]\u0026gt;0) cur++;\n\t\t\tfor(int j \u003d i - 25; j \u0026lt;\u003d i; j++)\n\t\t\t{\n\t\t\t\tif(s[j] \u003d\u003d \u0027?\u0027)\n\t\t\t\t{\n\t\t\t\t\ts[j] \u003d cur + \u0027A\u0027;\n\t\t\t\t\tcur++;\n\t\t\t\t\twhile(cnt[cur]\u0026gt;0) cur++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfillall();\n\t\t\tcout \u0026lt;\u0026lt; s;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; -1;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/715/problem/A\"\u003eDiv. 2 C/Div. 1 A — Plus and Square Root\u003c/a\u003e\u003c/h2\u003e\u003cp\u003ePrerequisites : None\u003c/p\u003e\u003cp\u003eFirstly, let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e(1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e be the number on the screen before we level up from level \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e. Thus, we require all the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003es to be perfect square and additionally to reach the next \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e via pressing the plus button, we require \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c5/86/c586e72fca9dbb7f177ff3cbec8967a491055400.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/aa/c2/aac274b8280bd9c82b125bfeaf2c5b5e4d8fa5cb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for all \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Additionally, we also require \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to be a multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Thus, we just need to construct a sequence of such integers so that the output numbers does not exceed the limit \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eThere are many ways to do this. The third sample actually gave a large hint on my approach. If you were to find the values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e from the second sample, you\u0027ll realize that it is equal to \u003cspan class\u003d\"tex-span\"\u003e4, 36, 144, 400\u003c/span\u003e. You can try to find the pattern from here. My approach is to use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d [\u003ci\u003ei\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e + 1)]\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e. Clearly, it is a perfect square for all \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e and when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 100000\u003c/span\u003e, the output values can be checked to be less than \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eUnable to parse markup [type\u003dCF_TEX]\u003c/p\u003e which is a multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e, and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a3/11/a311e176cc40ae33a3dbba31d04debbeb2d17143.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is also a multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e.\u003cp\u003eThe constraints \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e must be a multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e was added to make the problem easier for Div. 1 A.\u003c/p\u003e\u003cp\u003eTime Complexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode (O(n))\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll n; cin \u0026gt;\u0026gt; n;\n\tfor(ll i \u003d 1; i \u0026lt;\u003d n; i++)\n\t{\n\t\tif(i \u003d\u003d 1) cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t\telse cout \u0026lt;\u0026lt; i*(i+1)*(i+1)-(i-1) \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t}\n\treturn 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/715/problem/B\"\u003eDiv. 2 D/Div. 1 B — Complete The Graph\u003c/a\u003e\u003c/h2\u003e\u003cp\u003ePrerequisites : Dijkstra\u0027s Algorithm\u003c/p\u003e\u003cp\u003eThis problem is actually quite simple if you rule out the impossible conditions. Call the edges that does not have fixed weight variable edges. First, we\u0027ll determine when a solution exists.\u003c/p\u003e\u003cp\u003eFirstly, we ignore the variable edges. Now, find the length of the shortest path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e. If this length is \u003cspan class\u003d\"tex-span\"\u003e \u0026lt; \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e, there is no solution, since even if we replace the \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e weights with any positive weight the shortest path will never exceed this shortest path. Thus, if the length of this shortest path is \u003cspan class\u003d\"tex-span\"\u003e \u0026lt; \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e, there is no solution. (If no path exists we treat the length as \u003cspan class\u003d\"tex-span\"\u003e∞\u003c/span\u003e.)\u003c/p\u003e\u003cp\u003eNext, we replace the edges with \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e weight with weight \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Clearly, among all the possible graphs you can generate by replacing the weights, this graph will give the minimum possible shortest path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e, since increasing any weight will not decrease the length of the shortest path. Thus, if the shortest path of this graph is \u003cspan class\u003d\"tex-span\"\u003e \u0026gt; \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e, there is no solution, since the shortest path will always be \u003cspan class\u003d\"tex-span\"\u003e \u0026gt; \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. If no path exists we treat the length as \u003cspan class\u003d\"tex-span\"\u003e∞\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eOther than these two conditions, there will always be a way to assign the weights so that the shortest path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e is exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e! How do we prove this? First, consider all paths from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e that has at least one \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e weight edge, as changing weights won\u0027t affect the other paths. Now, we repeat this algorithm. Initially, assign all the weights as \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Then, sort the paths in increasing order of length. If the length of the shortest path is equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e, we\u0027re done. Otherwise, increase the weight of one of the variable edges on the shortest path by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Note that this will increase the lengths of some of the paths by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. It is not hard to see that by repeating these operations the shortest path will eventually have length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e, so an assignment indeed exists.\u003c/p\u003e\u003cp\u003eNow, we still have to find a valid assignment of weights. We can use a similar algorithm as our proof above. Assign \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to all variable edges first. Next, we first find and keep track of the shortest path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e. Note that if this path has no variable edges it must have length exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e or strictly more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e, so either we\u0027re already done or the shortest path contains variable edges and the length is strictly less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. (otherwise we\u0027re done)\u003c/p\u003e\u003cp\u003eFrom now on, whenever we assign weight to a variable edge (after assigning \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to every variable edge), we call the edge assigned.\u003c/p\u003e\u003cp\u003eNow, mark all variable edges not on the shortest path we found as \u003cspan class\u003d\"tex-span\"\u003e∞\u003c/span\u003e weight. (we can choose any number greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e∞\u003c/span\u003e) Next, we will find the shortest path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e, and replace the weight of an unassigned variable edge such that the length of the path becomes equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. Now, we don\u0027t touch the assigned edges again. While the shortest path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e is still strictly less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e, we repeat the process and replace a variable edge that is not assigned such that the path length is equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. Note that this is always possible, since otherwise this would\u0027ve been the shortest path in one of the previous steps. Eventually, the shortest path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e will have length exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. It is easy to see that we can repeat this process at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e times because we are only replacing the edges which are on the initial shortest path we found and there are less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e edges to replace (we only touch each edge at most once). Thus, we can find a solution after less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e iterations. So, the complexity becomes \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e6/3b/e63b4b46b664c087752b322832846052f2e037b5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. This is sufficient to pass all tests.\u003c/p\u003e\u003cp\u003eWhat if the constraints were \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e? Can we do better? \u003c/p\u003e\u003cp\u003eYes! Thanks to \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/HellKitsune\" title\u003d\"Grandmaster HellKitsune\"\u003eHellKitsune\u003c/a\u003e who found this solution during testing. First, we rule out the impossible conditions like we did above. Then, we assign all the variable edges with \u003cspan class\u003d\"tex-span\"\u003e∞\u003c/span\u003e weight. We enumerate the variable edges arbitarily. Now, we binary search to find the minimal value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e such that if we make all the variable edges numbered from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e have weight \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and the rest \u003cspan class\u003d\"tex-span\"\u003e∞\u003c/span\u003e, then the shortest path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e has length \u003cspan class\u003d\"tex-span\"\u003e ≤ \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. Now, note that if we change the weight of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e∞\u003c/span\u003e the length of shortest path will be more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. (if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e equals the number of variable edges, the length of the shortest path is still more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e or it will contradict the impossible conditions) If the weight is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, the length of the shortest path is \u003cspan class\u003d\"tex-span\"\u003e ≤ \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. So, if we increase the weight of edge \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e repeatedly, the length of the shortest path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e will eventually reach \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e, since this length can increase by at most \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e in each move. So, since the length of shortest path is non-decreasing when we increase the weight of this edge, we can binary search for the correct weight. This gives an \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/05/45/054565df4bdac71ddb58da1594736c752ef6e1eb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e solution.\u003c/p\u003e\u003cp\u003eTime Complexity : \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cd/34/cd342536aa1bd866ea6332dd3a2774125e87869a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e or \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/05/45/054565df4bdac71ddb58da1594736c752ef6e1eb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode (O(mnlogn))\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int N \u003d 1001;\nconst int M \u003d 10001;\nconst ll INF \u003d ll(1e18);\n\nvector\u0026lt;ii\u0026gt; adj[N];\nvector\u0026lt;int\u0026gt; adj2[N];\nint L[M]; int R[M];\nll d1[N];\nll d2[N];\nint par[N];\nll dist[N][N];\n\nint n, m, l, s, e;\n\nvoid dijkstra()\n{\n\td1[s] \u003d 0;\n\tpriority_queue\u0026lt;ii, vector\u0026lt;ii\u0026gt;, greater\u0026lt;ii\u0026gt; \u0026gt; pq;\n\tpq.push(ii(0, s));\n\tint cnt \u003d 0;\n\twhile(!pq.empty())\n\t{\n\t\tcnt++;\n\t\tint u \u003d pq.top().se; ll d \u003d pq.top().fi; pq.pop();\n\t\tfor(int i \u003d 0; i \u0026lt; adj[u].size(); i++)\n\t\t{\n\t\t\tint v \u003d adj[u][i].fi; ll w \u003d adj[u][i].se;\n\t\t\tif(d + w \u0026lt; d1[v])\n\t\t\t{\n\t\t\t\td1[v] \u003d d + w;\n\t\t\t\tpq.push(ii(d1[v], v));\n\t\t\t}\n\t\t}\n\t}\n\tcerr \u0026lt;\u0026lt; \u0026quot;DIJKSTRA OPERATIONS : \u0026quot; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\nbool dijkstra2()\n{\n\td2[s] \u003d 0;\n\tpriority_queue\u0026lt;ii, vector\u0026lt;ii\u0026gt;, greater\u0026lt;ii\u0026gt; \u0026gt; pq;\n\tpq.push(ii(0, s));\n\twhile(!pq.empty())\n\t{\n\t\tint u \u003d pq.top().se; ll d \u003d pq.top().fi; pq.pop();\n\t\tfor(int i \u003d 0; i \u0026lt; adj2[u].size(); i++)\n\t\t{\n\t\t\tint v \u003d adj2[u][i]; ll w \u003d dist[u][v];\n\t\t\tif(d + abs(w) \u0026lt; d2[v])\n\t\t\t{\n\t\t\t\td2[v] \u003d d + abs(w);\n\t\t\t\tpar[v] \u003d u;\n\t\t\t\tpq.push(ii(d2[v], v));\n\t\t\t}\n\t\t}\n\t}\n\tif(d2[e] \u0026gt; l) return false;\n\tint cur \u003d e;\n\twhile(cur !\u003d s)\n\t{\n\t\tint p \u003d par[cur];\n\t\tif(dist[p][cur] \u0026lt; 0)\n\t\t{\n\t\t\tdist[p][cur] \u003d -2; dist[cur][p] \u003d -2;\n\t\t}\n\t\tcur \u003d par[cur];\n\t}\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; n; j++)\n\t\t{\n\t\t\tif(dist[i][j] \u003d\u003d -1)\n\t\t\t{\n\t\t\t\tdist[i][j] \u003d INF;\n\t\t\t}\n\t\t}\n\t}\n\tcur \u003d e;\n\twhile(cur !\u003d s)\n\t{\n\t\tint p \u003d par[cur];\n\t\tif(dist[p][cur] \u0026lt; 0)\n\t\t{\n\t\t\tdist[p][cur] \u003d -1; dist[cur][p] \u003d -1;\n\t\t}\n\t\tcur \u003d par[cur];\n\t}\n\treturn true;\n}\n\nvoid print()\n{\n\tcout \u0026lt;\u0026lt; \u0026quot;YES\\n\u0026quot;;\n\tfor(int i \u003d 0; i \u0026lt; m; i++)\n\t{\n\t\tint u \u003d L[i]; int v \u003d R[i];\n\t\tll d \u003d dist[u][v];\n\t\tif(d \u0026lt; 0) d \u003d -d;\n\t\tcout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t}\n}\n\nbool relax()\n{\n\tfor(int i \u003d 0; i \u0026lt; n; i++) d2[i] \u003d INF;\n\tmemset(par, -1, sizeof(par)); //shouldn\u0027t be neccesary\n\td2[s] \u003d 0;\n\tpriority_queue\u0026lt;ii, vector\u0026lt;ii\u0026gt;, greater\u0026lt;ii\u0026gt; \u0026gt; pq;\n\tpq.push(ii(0, s));\n\twhile(!pq.empty())\n\t{\n\t\tint u \u003d pq.top().se; ll d \u003d pq.top().fi; pq.pop();\n\t\tfor(int i \u003d 0; i \u0026lt; adj2[u].size(); i++)\n\t\t{\n\t\t\tint v \u003d adj2[u][i]; ll w \u003d dist[u][v];\n\t\t\tif(d + abs(w) \u0026lt; d2[v])\n\t\t\t{\n\t\t\t\td2[v] \u003d d + abs(w);\n\t\t\t\tpar[v] \u003d u;\n\t\t\t\tpq.push(ii(d2[v], v));\n\t\t\t}\n\t\t}\n\t}\n\t//cerr \u0026lt;\u0026lt; d2[e] \u0026lt;\u0026lt; \u0027\\n\u0027;\n\tif(d2[e] \u003d\u003d l) return true;\n\tint cur \u003d e; bool meet \u003d false;\n\twhile(cur !\u003d s)\n\t{\n\t\tint p \u003d par[cur];\n\t\tif(!meet \u0026amp;\u0026amp; dist[p][cur] \u0026lt; 0)\n\t\t{\n\t\t\tll d \u003d abs(dist[p][cur]);\n\t\t\tdist[p][cur] \u003d d + l - d2[e];\n\t\t\tdist[cur][p] \u003d d + l - d2[e];\n\t\t\t//cerr \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl;\n\t\t\tmeet \u003d true;\n\t\t}\n\t\tif(meet) break;\n\t\tcur \u003d par[cur];\n\t}\n\treturn false;\n}\n\nint dist1[N][N];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; l \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e;\n\tmemset(dist1, -1, sizeof(dist1));\n\tfor(int i \u003d 0; i \u0026lt; m; i++)\n\t{\n\t\tint u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w;\n\t\tif(w \u0026gt; 0) \n\t\t{\n\t\t\tadj[u].pb(ii(v, w)); adj[v].pb(ii(u, w));\n\t\t\tadj2[u].pb(v); adj2[v].pb(u);\n\t\t\tdist1[u][v] \u003d w; dist1[v][u] \u003d w;\n\t\t\tdist[u][v] \u003d w; dist[v][u] \u003d w;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tadj2[u].pb(v); adj2[v].pb(u);\n\t\t\tdist[u][v] \u003d -1; dist[v][u] \u003d -1;\n\t\t}\n\t\tL[i] \u003d u; R[i] \u003d v;\n\t}\t\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\td1[i] \u003d INF; d2[i] \u003d INF;\n\t}\n\tdijkstra(); //cerr \u0026lt;\u0026lt; d1[e] \u0026lt;\u0026lt; \u0027\\n\u0027;\n\tif(d1[e] \u0026lt; l)\n\t{\n\t\tcout \u0026lt;\u0026lt; \u0026quot;NO\\n\u0026quot;;\n\t\treturn 0;\n\t}\n\tif(d1[e] \u003d\u003d l)\n\t{\n\t\tcout \u0026lt;\u0026lt; \u0026quot;YES\\n\u0026quot;;\n\t\tfor(int i \u003d 0; i \u0026lt; m; i++)\n\t\t{\n\t\t\tint u \u003d L[i]; int v \u003d R[i];\n\t\t\tll d \u003d dist1[u][v];\n\t\t\tif(d \u0026lt;\u003d 0) d \u003d INF;\n\t\t\tcout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t\t}\n\t\treturn 0;\n\t}\n\tbool tmp \u003d dijkstra2();\n\tif(!tmp)\n\t{\n\t\tcout \u0026lt;\u0026lt; \u0026quot;NO\\n\u0026quot;;\n\t\treturn 0;\n\t}\n\t//cerr \u0026lt;\u0026lt; d2[e] \u0026lt;\u0026lt; \u0027\\n\u0027;\n\tint cnt \u003d 0;\n\twhile(!relax()) \n\t{\n\t\trelax(); cnt++;\n\t}\n\tcerr \u0026lt;\u0026lt; \u0026quot;RELAXATIONS DONE : \u0026quot; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0027\\n\u0027;\n\tprint();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode (O(mlogn(logm+logL))\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int N \u003d 1001;\nconst int M \u003d 10001;\nconst ll INF \u003d ll(1e18);\n\nint n, m, l, s, e;\n\nstruct edge\n{\n\tint to; ll w; int label;\n\tedge(int _to, int _w, int _label){to \u003d _to, w \u003d _w, label \u003d _label;}\n};\n\nint edgecnt \u003d -1;\nvector\u0026lt;edge\u0026gt; adj[N];\nll dist[N];\nset\u0026lt;ii\u0026gt; used;\n\nll dijk(int p, ll val)\n{\n\tfor(int i \u003d 0; i \u0026lt; n; i++) dist[i] \u003d INF;\n\tdist[s] \u003d 0;\n\tpriority_queue\u0026lt;ii, vector\u0026lt;ii\u0026gt;, greater\u0026lt;ii\u0026gt; \u0026gt; pq;\n\tpq.push(ii(0, s));\n\twhile(!pq.empty())\n\t{\n\t\tint u \u003d pq.top().se; ll d \u003d pq.top().fi; pq.pop();\n\t\tfor(int i \u003d 0; i \u0026lt; adj[u].size(); i++)\n\t\t{\n\t\t\tedge tmp \u003d adj[u][i];\n\t\t\tint v \u003d tmp.to; ll w \u003d tmp.w; int lab \u003d tmp.label;\n\t\t\tif(lab \u0026gt;\u003d 0)\n\t\t\t{\n\t\t\t\tif(lab \u0026lt; p) w \u003d 1;\n\t\t\t\telse if(lab \u003d\u003d p) w \u003d val;\n\t\t\t\telse w \u003d ll(1e14);\n\t\t\t}\n\t\t\tif(d + w \u0026lt; dist[v])\n\t\t\t{\n\t\t\t\tdist[v] \u003d d + w;\n\t\t\t\tpq.push(ii(dist[v], v));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[e];\n}\n\nvoid setw(int p, ll val)\n{\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; adj[i].size(); j++)\n\t\t{\n\t\t\tint lab \u003d adj[i][j].label;\n\t\t\tif(lab \u0026gt;\u003d 0)\n\t\t\t{\n\t\t\t\tif(lab \u0026lt; p)\n\t\t\t\t{\n\t\t\t\t\tadj[i][j].w \u003d 1;\n\t\t\t\t}\n\t\t\t\telse if(lab \u003d\u003d p)\n\t\t\t\t{\n\t\t\t\t\tadj[i][j].w \u003d val;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tadj[i][j].w \u003d INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid print()\n{\n\tcout \u0026lt;\u0026lt; \u0026quot;YES\\n\u0026quot;;\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; adj[i].size(); j++)\n\t\t{\n\t\t\tedge tmp \u003d adj[i][j];\n\t\t\tint v \u003d tmp.to; ll w \u003d tmp.w; \n\t\t\tif(used.find(ii(i, v)) \u003d\u003d used.end())\n\t\t\t{\n\t\t\t\tcout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; w \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t\t\t\tused.insert(ii(i, v)); used.insert(ii(v, i));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; l \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e;\n\tfor(int i \u003d 0; i \u0026lt; m; i++)\n\t{\n\t\tint u, v, w;\n\t\tcin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w;\n\t\tint lab \u003d -1;\n\t\tif(w \u003d\u003d 0) \n\t\t{\n\t\t\tlab \u003d ++edgecnt;\n\t\t}\n\t\tadj[u].pb(edge(v, w, lab));\n\t\tadj[v].pb(edge(u, w, lab));\n\t}\n\tll x \u003d dijk(edgecnt, 1); ll y \u003d dijk(-1, 1);\n\tif(!(x \u0026lt;\u003d l \u0026amp;\u0026amp; l \u0026lt;\u003d y))\n\t{\n\t\tcout \u0026lt;\u0026lt; \u0026quot;NO\\n\u0026quot;;\n\t\treturn 0;\n\t}\n\tll lo \u003d -1; ll hi \u003d edgecnt;\n\tll mid, ans;\n\twhile(lo \u0026lt;\u003d hi)\n\t{\n\t\tmid \u003d (lo+hi)/2;\n\t\tif(dijk(mid, 1) \u0026lt;\u003d l)\n\t\t{\n\t\t\tans \u003d mid;\n\t\t\thi \u003d mid - 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlo \u003d mid + 1;\n\t\t}\n\t}\n\t//now [0..ans] as 1 will give \u0026lt;\u003d L whereas [0..ans - 1] as 1 will give \u0026gt; L\n\tif(ans \u003d\u003d -1)\n\t{\n\t\tsetw(-1, 0);\n\t\tprint();\n\t\treturn 0;\n\t}\n\tlo \u003d 1; hi \u003d INF;\n\tint ans2 \u003d 0;\n\twhile(lo \u0026lt;\u003d hi)\n\t{\n\t\tmid \u003d (lo+hi)\u0026gt;\u0026gt;1;\n\t\tif(dijk(ans, mid) \u0026lt;\u003d l)\n\t\t{\n\t\t\tans2 \u003d mid;\n\t\t\tlo \u003d mid + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\thi \u003d mid - 1;\n\t\t}\n\t}\n\t//cerr \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; ans2 \u0026lt;\u0026lt; \u0027\\n\u0027;\n\tsetw(ans, ans2);\n\tprint();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/715/problem/C\"\u003eDiv. 2 E/Div. 1 C — Digit Tree\u003c/a\u003e\u003c/h2\u003e\u003cp\u003ePrerequisites : Tree DP, Centroid Decomposition, Math\u003c/p\u003e\u003cp\u003eCompared to the other problems, this one is more standard. The trick is to first solve the problem if we have a fixed vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e as root and we want to find the number of paths passing through \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e that works. This can be done with a simple tree dp. For each node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, compute the number obtained when going from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e down to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and the number obtained when going from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e up to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e, where each number is taken modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e. This can be done with a simple dfs. To calculate the down value, just multiply the value of the parent node by \u003cspan class\u003d\"tex-span\"\u003e10\u003c/span\u003e and add the value on the edge to it. To calculate the up value, we also need to calculate the height of the node. (i.e. the distance from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e) Then, if we let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e be the height of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e be the digit on the edge connecting \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to its parent and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eval\u003c/i\u003e\u003c/span\u003e be the up value of the parent of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, then the up value for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is equal to \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eh\u003c/i\u003e - 1\u003c/sup\u003e·\u003ci\u003ed\u003c/i\u003e + \u003ci\u003eval\u003c/i\u003e\u003c/span\u003e. Thus, we can calculate the up and down value for each node with a single dfs.\u003c/p\u003e\u003cp\u003eNext, we have to figure out how to combine the up values and down values to find the number of paths passing through \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e that are divisible by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e. For this, note that each path is the concatenation of a path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e are pairs of vertices from different subtrees, and the paths that start from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e and end at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e. For the paths that start and end at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e the answer can be easily calculated with the up and down values (just iterate through all nodes as the other endpoint). For the other paths, we iterate through all possible \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, and find the number of vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e such that going from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e will give a multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e. Since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is fixed, we know its height and down value, which we denote as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e respectively. So, if the up value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eup\u003c/i\u003e\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eup\u003c/i\u003e·10\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/sup\u003e + \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e must be a multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e. So, we can solve for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eup\u003c/i\u003e\u003c/span\u003e to be \u003cspan class\u003d\"tex-span\"\u003e - \u003ci\u003ed\u003c/i\u003e·10\u003csup class\u003d\"upper-index\"\u003e - \u003ci\u003eh\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e. Note that in this case the multiplicative inverse of \u003cspan class\u003d\"tex-span\"\u003e10\u003c/span\u003e modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e is well-defined, as we have the condition \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cc/01/cc010bb0783dfd849110ad2d02c83e233a8392af.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. To find the multiplicative inverse of \u003cspan class\u003d\"tex-span\"\u003e10\u003c/span\u003e, we can find \u003cspan class\u003d\"tex-span\"\u003eφ(\u003ci\u003eM\u003c/i\u003e)\u003c/span\u003e and since by Euler\u0027s Formula we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003eφ(\u003ci\u003eM\u003c/i\u003e)\u003c/sup\u003e ≡ 1(\u003ci\u003emodM\u003c/i\u003e)\u003c/span\u003e if \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/84/32/843276633b1c65779fe6f51219cb1b4e037fecdc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003eφ(\u003ci\u003eM\u003c/i\u003e) - 1\u003c/sup\u003e ≡ \u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e - 1\u003c/sup\u003e(\u003ci\u003emodM\u003c/i\u003e)\u003c/span\u003e, which is the multiplicative inverse of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e (in this case we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d 10\u003c/span\u003e) modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e. After that, finding the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eup\u003c/i\u003e\u003c/span\u003e value can be done by binary exponentiation.\u003c/p\u003e\u003cp\u003eThus, we can find the unique value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eup\u003c/i\u003e\u003c/span\u003e such that the path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is a multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e. This means that we can just use a map to store the up values of all nodes and also the up values for each subtree. Then, to find the number of viable nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, find the required value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eup\u003c/i\u003e\u003c/span\u003e and subtract the number of suitable nodes that are in the same subtree as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e from the total number of suitable nodes. Thus, for each node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, we can find the number of suitable nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ad/df/addf515f80186b9011354b0c9e896674a83cfe70.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time. \u003c/p\u003e\u003cp\u003eNow, we have to generalize this for the whole tree. We can use centroid decomposition. We pick the centroid as the root \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e and find the number of paths passing through \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e as above. Then, the other paths won\u0027t pass through \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e, so we can remove \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e and split the tree into more subtrees, and recursively solve for each subtree as well. Since each subtree is at most half the size of the original tree, and the time taken to solve the problem where the path must pass through the root for a single tree takes time proportional to the size of the tree, this solution works in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/50/c4/50c40842c957123edbaeea224668606d1a4cb214.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time, where the other \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/75/5c/755c0e72a8f6c5be4007a41acbae4bf024107b8c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e comes from using maps.\u003c/p\u003e\u003cp\u003eTime Complexity : \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/50/c4/50c40842c957123edbaeea224668606d1a4cb214.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int N \u003d 1e5 + 1;\nconst int MAX \u003d 1e9;\nint MOD, n;\n\nbool isprime[100001];\nvector\u0026lt;ll\u0026gt; primes;\nvector\u0026lt;ii\u0026gt; adj[N];\nint subsize[N];\nbool visited[N];\nint treesize;\nvi clrlist;\nll up[N];\nll down[N];\nint h[N];\nint PHI;\nint dppart[N];\n\nll mult(ll a, ll b)\n{\n\treturn (a*b)%MOD;\n}\n\nll add(ll a, ll b)\n{\n\treturn (a+b+MOD)%MOD;\n}\n\nll modpow(ll a, ll b)\n{\n\tll r \u003d 1;\n\twhile(b)\n\t{\n\t\tif(b\u0026amp;1) r\u003d(r*a)%MOD;\n\t\ta\u003d(a*a)%MOD;\n\t\tb\u0026gt;\u0026gt;\u003d1;\n\t}\n\treturn r;\n}\n\nvoid Sieve(int n)\n{\n\tmemset(isprime, 1, sizeof(isprime));\n\tisprime[1] \u003d false;\n\tfor(int i \u003d 2; i \u0026lt;\u003d n; i++)\n\t{\n\t\tif(isprime[i])\n\t\t{\n\t\t\tprimes.pb(i);\n\t\t\tfor(int j \u003d 2*i; j \u0026lt;\u003d n; j +\u003d i)\n\t\t\t{\n\t\t\t\tisprime[j] \u003d false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint phi(int n)\n{\n\tll num \u003d 1; ll num2 \u003d n;\n\tfor(ll i \u003d 0; primes[i]*primes[i] \u0026lt;\u003d n; i++)\n\t{\n\t\tif(n%primes[i]\u003d\u003d0)\n\t\t{\n\t\t\tnum2/\u003dprimes[i];\n\t\t\tnum*\u003d(primes[i]-1);\n\t\t}\n\t\twhile(n%primes[i]\u003d\u003d0)\n\t\t{\n\t\t\tn/\u003dprimes[i];\n\t\t}\n\t}\n\tif(n\u0026gt;1)\n\t{\n\t\tnum2/\u003dn; num*\u003d(n-1);\n\t}\n\tn \u003d 1;\n\tnum*\u003dnum2;\n\treturn num;\n}\n\nll inv(ll a)\n{\n\treturn modpow(a, PHI-1);\n}\n\nvoid dfs(int u, int par)\n{\n\tif(par \u003d\u003d -1) clrlist.clear();\n\tsubsize[u] \u003d 1; clrlist.pb(u);\n\tfor(int i \u003d 0; i \u0026lt; adj[u].size(); i++)\n\t{\n\t\tint v \u003d adj[u][i].fi;\n\t\tif(visited[v]) continue;\n\t\tif(v \u003d\u003d par) continue;\n\t\tdfs(v, u);\n\t\tsubsize[u] +\u003d subsize[v];\n\t}\t\n\tif(par \u003d\u003d -1) treesize \u003d subsize[u];\n}\n\nint centroid(int u, int par)\n{\n\tfor(int i \u003d 0; i \u0026lt; adj[u].size(); i++)\n\t{\n\t\tint v \u003d adj[u][i].fi;\n\t\tif(visited[v]) continue;\n\t\tif(v \u003d\u003d par) continue;\n\t\tif(subsize[v]*2 \u0026gt; treesize) return centroid(v, u);\n\t}\n\treturn u;\n}\n\nint parts \u003d 0;\nvoid fill(int u, int p, int cent)\n{\n\tif(p \u003d\u003d cent)\n\t{\n\t\tdppart[u] \u003d parts;\n\t\tparts++;\n\t}\n\telse if(p !\u003d -1)\n\t{\n\t\tdppart[u] \u003d dppart[p];\n\t}\n\tfor(int i \u003d 0; i \u0026lt; adj[u].size(); i++)\n\t{\n\t\tint v \u003d adj[u][i].fi; int w \u003d adj[u][i].se;\n\t\tif(v \u003d\u003d p || visited[v]) continue;\n\t\tdown[v] \u003d add(mult(down[u], 10), w);\n\t\tup[v] \u003d add(up[u], mult(modpow(10, h[u]), w));\n\t\th[v] \u003d h[u] + 1;\n\t\tfill(v, u, cent);\n\t\t//cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; up[v] \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; up[u] \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t}\n}\n\nll solve(int cent)\n{\n\tfor(int i \u003d 0; i \u0026lt; clrlist.size(); i++)\n\t{\n\t\tup[clrlist[i]] \u003d 0; down[clrlist[i]] \u003d 0; h[clrlist[i]] \u003d 0;\n\t}\n\tparts \u003d 0;\n\tfill(cent, -1, cent); parts--;\n\tdppart[cent] \u003d -1; \n\tmap\u0026lt;ll,ll\u0026gt; tot; //only count up\n\tvector\u0026lt;map\u0026lt;ll,ll\u0026gt; \u0026gt; vec; //only count up, but in specific subtree\n\tvec.resize(parts+1);\n\ttot[0]++;\n\tfor(int i \u003d 0; i \u0026lt; clrlist.size(); i++)\n\t{\n\t\tint u \u003d clrlist[i];\n\t\t//cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; up[u] \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; down[u] \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t\tif(u \u003d\u003d cent) continue;\n\t\ttot[up[u]]++;\n\t\tvec[dppart[u]][up[u]]++;\n\t}\n\tll ans \u003d 0;\n\tfor(int i \u003d 0; i \u0026lt; clrlist.size(); i++)\n\t{\n\t\tint u \u003d clrlist[i];\n\t\tint ht \u003d h[u];\n\t\tint pt \u003d dppart[u];\n\t\tif(u \u003d\u003d cent)\n\t\t{\n\t\t\tans +\u003d (tot[0] - 1); //exclude cent as the vertex\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll val \u003d ((-down[u])%MOD+MOD)%MOD;\n\t\t\tval \u003d mult(val, inv(modpow(10, ht)));\n\t\t\tans +\u003d (tot[val] - vec[pt][val]);\n\t\t}\n\t}\n\treturn ans;\n}\n\nll compsolve(int u)\n{\n\tdfs(u, -1);\n\tint cent \u003d centroid(u, -1);\n\tll ans \u003d solve(cent);\n\t//cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; cent \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0027\\n\u0027;\n\tvisited[cent] \u003d true;\n\tfor(int i \u003d 0; i \u0026lt; adj[cent].size(); i++)\n\t{\n\t\tint v \u003d adj[cent][i].fi;\n\t\tif(!visited[v]) ans +\u003d compsolve(v);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; MOD;\n\tif(MOD \u003d\u003d 1)\n\t{\n\t\tcout \u0026lt;\u0026lt; ll(n)*ll(n - 1);\n\t\treturn 0;\n\t}\n\tSieve(100000); PHI \u003d phi(MOD);\n\tfor(int i \u003d 0; i \u0026lt; n - 1; i++) //tree is 0-indexed\n\t{\n\t\tint u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w;\n\t\tadj[u].pb(ii(v, w)); adj[v].pb(ii(u, w));\n\t}\n\tcout \u0026lt;\u0026lt; compsolve(0) \u0026lt;\u0026lt; \u0027\\n\u0027;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/715/problem/D\"\u003eDiv. 1 D — Create a Maze\u003c/a\u003e\u003c/h2\u003e\u003cp\u003ePrerequisites : None\u003c/p\u003e\u003cp\u003eThe solution to this problem is quite simple, if you get the idea. Thanks to \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/dans\" title\u003d\"Grandmaster dans\"\u003edans\u003c/a\u003e for improving the solution to the current constraints which is much harder than my original proposal.\u003c/p\u003e\u003cp\u003eNote that to calculate the difficulty of a given maze, we can just use dp. We write on each square (room) the number of ways to get from the starting square to it, and the number written on \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e will be the sum of the numbers written on \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e - 1, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e - 1)\u003c/span\u003e, and the edge between \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e - 1, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e is blocked, we don\u0027t add the number written on \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e - 1, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e and similarly for \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e - 1)\u003c/span\u003e. We\u0027ll call the rooms squares and the doors as edges. We\u0027ll call locking doors as edge deletions.\u003c/p\u003e\u003cp\u003eFirst, we look at several attempts that do not work. \u003c/p\u003e\u003cp\u003eWrite \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e in its binary representation. To solve the problem, we just need to know how to construct a maze with difficulty \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + 1\u003c/span\u003e from a given maze with difficulty \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. The most direct way to get from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is to increase both dimensions of the maze by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Let\u0027s say the bottom right square of the grid was \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e and increased to \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e + 1, \u003ci\u003en\u003c/i\u003e + 1)\u003c/span\u003e. So, the number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is written at \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. Then, we can block off the edge to the left of \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e + 1, \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e and above \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e + 1)\u003c/span\u003e. This will make the numbers in these two squares equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, so the number in square \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e + 1, \u003ci\u003en\u003c/i\u003e + 1)\u003c/span\u003e would be \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, as desired. To create \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + 1\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, we can increase both dimensions by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, remove edges such that \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e + 1, \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e contains \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e while \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e + 1)\u003c/span\u003e contains \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e (this requires deleting most of the edges joining the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e-th column and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e + 1)\u003c/span\u003e-th column. Thus, the number in \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e would be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + 1\u003c/span\u003e. This would\u0027ve used way too many edge deletions and the size of the grid would be too large. This was the original proposal.\u003c/p\u003e\u003cp\u003eThere\u0027s another way to do it with binary representation. We construct a grid with difficulty \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003ex\u003c/i\u003e + 1\u003c/span\u003e from a grid with difficulty \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. The key idea is to make use of surrounding \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003es and maintaining it with some walls so that \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003ex\u003c/i\u003e + 1\u003c/span\u003e can be easily constructed. This method is shown in the picture below. This method would\u0027ve used around \u003cspan class\u003d\"tex-span\"\u003e120 × 120\u003c/span\u003e grid and \u003cspan class\u003d\"tex-span\"\u003e480\u003c/span\u003e edge deletions, which is too large to pass. \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/f3/75/f37543a2bbe33f89ce1ece33fe165aa1d786eba1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eNow, what follows is the AC solution. Since it\u0027s quite easy once you get the idea, I recommend you to try again after reading the hint. To read the full solution, click on the spoiler tag.\u003c/p\u003e\u003cp\u003eHint : Binary can\u0027t work since there can be up to \u003cspan class\u003d\"tex-span\"\u003e60\u003c/span\u003e binary digits for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e and our grid size can be at most \u003cspan class\u003d\"tex-span\"\u003e50\u003c/span\u003e. In our binary solution we used a \u003cspan class\u003d\"tex-span\"\u003e2 × 2\u003c/span\u003e grid to multiply the number of ways by \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e. What about using other grid sizes instead?\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eFull Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eOur AC solution uses base \u003cspan class\u003d\"tex-span\"\u003e6\u003c/span\u003e instead of binary. Write \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e in base \u003cspan class\u003d\"tex-span\"\u003e6\u003c/span\u003e. Note that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e has at most \u003cspan class\u003d\"tex-span\"\u003e24\u003c/span\u003e digits in base \u003cspan class\u003d\"tex-span\"\u003e6\u003c/span\u003e, so to add a new digit we can increase the dimensions by \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e and the number of deleted edges can be up to \u003cspan class\u003d\"tex-span\"\u003e12\u003c/span\u003e per digit. We\u0027ll construct such a way. This method is explained in the picture below. The key is to first construct a grid which has \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e in it, then find a way to get \u003cspan class\u003d\"tex-span\"\u003e6\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003ei\u003c/i\u003e ≤ 5\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e by maintaining a wall of \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003es around the squares. This method uses a \u003cspan class\u003d\"tex-span\"\u003e50 × 50(2·24 + 2 \u003d 50)\u003c/span\u003e grid and at most \u003cspan class\u003d\"tex-span\"\u003e24·12 + 2 \u003d 290\u003c/span\u003e edge deletions and will get AC.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/39/65/396500eab5871bd133e7458731b59b246875daef.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eOf course, this might not be the only way to solve this problem. Can you come up with other ways of solving this or reducing the constraints even further? (Open Question)\u003c/p\u003e\u003cp\u003eTime Complexity : \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ad/8a/ad8ae8f15cfcf70b858df83673ce1f8f6bb1d7fd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int INF \u003d 1e9 + 7;\nconst int MOD \u003d 1e9 + 7;\n\ntypedef pair\u0026lt;ii,ii\u0026gt; move;\n\nset\u0026lt;move\u0026gt; ans;\nint curx, cury;\n\nbool isvalid(move x)\n{\n\tif(x.fi.fi \u0026gt; 0 \u0026amp;\u0026amp; x.se.fi \u0026gt; 0 \u0026amp;\u0026amp; x.fi.se \u0026gt; 0 \u0026amp;\u0026amp; x.se.se \u0026gt; 0 \u0026amp;\u0026amp; x.fi.fi \u0026lt;\u003d curx \u0026amp;\u0026amp; x.fi.se \u0026lt;\u003d cury \u0026amp;\u0026amp; x.se.fi \u0026lt;\u003d curx \u0026amp;\u0026amp; x.se.se \u0026lt;\u003d cury) return true;\n\treturn false;\n}\n\nvoid edge(int x1, int y1, int x2, int y2)\n{\n\tans.insert(mp(mp(x1, y1), mp(x2, y2)));\n}\n\nvoid add(int bit)\n{\n\tint x \u003d curx;\n\tedge(x,x+2,x,x+3);\n\tedge(x+1,x+2,x+1,x+3);\n\tedge(x+2,x,x+3,x);\n\tedge(x+2,x+1,x+3,x+1);\n\tedge(x-2,x+3,x-1,x+3);\n\tedge(x,x+4,x+1,x+4);\n\tedge(x+3,x-2,x+3,x-1);\n\tedge(x+4,x,x+4,x+1);\n\tedge(x-1,x+1,x,x+1);\n\tif(bit%3\u003d\u003d0) edge(x-1,x+2,x,x+2);\n\tif(bit%3!\u003d2) edge(x+2,x-1,x+2,x);\n\tif(bit\u0026lt;3) edge(x+1,x-1,x+1,x);\n\tcurx +\u003d 2; cury +\u003d 2;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll t; cin \u0026gt;\u0026gt; t;\n\tvector\u0026lt;int\u0026gt; digits;\n\twhile(t)\n\t{\n\t\tdigits.pb(t%6);\n\t\tt/\u003d6;\n\t}\n\treverse(digits.begin(), digits.end());\n\tedge(1, 2, 2, 2);\n\tedge(2, 1, 2, 2);\n\tcurx \u003d 2; cury \u003d 2;\n\tfor(int i \u003d 0; i \u0026lt; digits.size(); i++)\n\t{\n\t\tadd(digits[i]);\n\t}\n\tcout \u0026lt;\u0026lt; curx \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; cury \u0026lt;\u0026lt; \u0027\\n\u0027;\n\tvector\u0026lt;move\u0026gt; clr;\n\tfor(set\u0026lt;move\u0026gt;::iterator it \u003d ans.begin(); it !\u003d ans.end(); it++)\n\t{\n\t\tif(!isvalid(*it))\n\t\t{\n\t\t\tclr.pb(*it);\n\t\t}\n\t}\n\tfor(int i \u003d 0; i \u0026lt; clr.size(); i++)\n\t{\n\t\tans.erase(clr[i]);\n\t}\n\tcout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; \u0027\\n\u0027;\n\tfor(set\u0026lt;move\u0026gt;::iterator it \u003d ans.begin(); it !\u003d ans.end(); it++)\n\t{\n\t\tmove tmp \u003d (*it);\n\t\tcout \u0026lt;\u0026lt; tmp.fi.fi \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; tmp.fi.se \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; tmp.se.fi \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; tmp.se.se \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/715/problem/E\"\u003eDiv. 1 E — Complete The Permutations\u003c/a\u003e\u003c/h2\u003e\u003cp\u003ePrerequisites : Math, Graph Theory, DP, Any fast multiplication algorithm\u003c/p\u003e\u003cp\u003eWe\u0027ll slowly unwind the problem and reduce it to something easier to count. First, we need to determine a way to tell when the distance between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e is exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. This is a classic problem but I\u0027ll include it here for completeness.\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e denote the inverse permutation of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e. So, the minimum number of swaps to transform \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e is the minimum number of swaps to transform \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e\u003c/span\u003e into the identity permutation. Construct the graph where the edges are \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/08/ba/08babce1184692fd7c56af8685f1053a20fbb9f0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for all \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Now, note that the graph is equivalent to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0e/c1/0ec1e8043076de56c41d16f19b281b8b0d495c3e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and is composed of disjoint cycles after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e are filled completely. Note that the direction of the edges doesn\u0027t matter so we consider the edges to be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/00/3d/003d89b62f70cb7b2f681bac9df043093ecfa838.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for all \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Note that if the number of cycles of the graph is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e, then the minimum number of swaps needed to transform \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e would be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003et\u003c/i\u003e\u003c/span\u003e. (Each swap can break one cycle into two) This means we just need to find the number of ways to fill in the empty spaces such that the number of cycles is exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow, some of the values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e are known. The edges can be classified into four types : \u003c/p\u003e\u003cp\u003eA-type : The edges of the form \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b3/2b/b32b8a60144cb166390bed5d191d570fcaba2e31.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, i.e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is known, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e isn\u0027t.\u003c/p\u003e\u003cp\u003eB-type : The edges of the form \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ab/23/ab23af303f13812b9d1bc60eb793a96dfe70dabc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, i.e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is known, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e isn\u0027t.\u003c/p\u003e\u003cp\u003eC-type : The edges of the form \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e9/96/e9967a473139a5ddda8935793b3fd6d3ada3723c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, i.e. both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e are known.\u003c/p\u003e\u003cp\u003eD-type : The edges of the form \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e5/e4/e5e4c6c74ee89480275d622bc87f60e12f64138f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, i.e. both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e are unknown.\u003c/p\u003e\u003cp\u003eNow, the problem reduces to finding the number of ways to assign values to the question marks such that the number of cycles of the graph is exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. First, we\u0027ll simplify the graph slightly. While there exists a number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e appears twice (clearly it can\u0027t appear more than twice) among the edges, we will combine the edges with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e together to simplify the graph. If there\u0027s an edge \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5e/23/5e23afa54aacc09fb47e3a3b6264ef890446521f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, then we increment the total number of cycles by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and remove this edge from the graph. If there is an edge \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6b/61/6b61436f5c77b5d2d690b91c5f5d572d0aea61e4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ef/10/ef102434d07f5e26f09ca83553257614176cac2f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e might be some given numbers or question marks, then we can merge them together to form the edge \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ad/00/ad0092285fa30a24e4196bebcf8ce07b18e7224d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Clearly, these are the only cases for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to appear twice. Hence, after doing all the reductions, we\u0027re reduced to edges where each known number appears at most once, i.e. all the known numbers are distinct. We\u0027ll do this step in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e. For each number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, store the position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and also the position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, if it has already been given and \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e otherwise. So, we need to remove a number when the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e stored are both positive. We iterate through the numbers from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. If we need to remove a number, we go to the two positions where it occur and replace the two edges with the new merged one. Then, recompute the positions for all numbers (takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time). So, for each number, we used \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time. (to remove naively and update positions) Thus, the whole complexity for this part is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e. (It is possible to do it in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e with a simple dfs as well. Basically almost any correct way of doing this part that is at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e works, since the constraints for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is low)\u003c/p\u003e\u003cp\u003eNow, suppose there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e edges left and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e known numbers remain. Note that in the end when we form the graph we might join edges of the form \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e1/6a/e16a7482a5e2744f1e2a3258a208419622624b88.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/06/c7/06c77c67d17220aa7a382371fa67488fc83142c9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e are either fixed numbers or question marks) together. So, the choice for the \u003cspan class\u003d\"tex-span\"\u003e?\u003c/span\u003e can be any of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e - \u003ci\u003ep\u003c/i\u003e\u003c/span\u003e remaining unused numbers. Note that there will be always \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e - \u003ci\u003ep\u003c/i\u003e\u003c/span\u003e such pairs so we need to multiply our answer by \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003em\u003c/i\u003e - \u003ci\u003ep\u003c/i\u003e)!\u003c/span\u003e in the end. Also, note that the \u003cspan class\u003d\"tex-span\"\u003e?\u003c/span\u003e are distinguishable, and order is important when filling in the blanks.\u003c/p\u003e\u003cp\u003eSo, we can actually reduce the problem to the following : Given integers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e, \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e denoting the number of A-type, B-type, C-type, D-type edges respectively. Find the number of ways to create \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e cycles using them, for all \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ek\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Note that the answer is only dependent on the values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e, \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e as the numbers are all distinct after the reduction.\u003c/p\u003e\u003cp\u003eFirst, we\u0027ll look at how to solve the problem for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d 1\u003c/span\u003e. We need to fit all the edges in a single cycle. First, we investigate what happens when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e \u003d 0\u003c/span\u003e. Note that we cannot have a B-type and C-type edge before an A-type or C-type edge, since all numbers are distinct so these edges can\u0027t be joined together. Similarly, an A or C-type edge cannot be directly after a B or C-type edge. Thus, with these restrictions, it is easy to see that the cycle must contain either all A-type edges or B-type edges. So, the answer can be easily calculated. It is also important to note that if we ignore the cyclic property then a contiguous string of edges without D must be of the form AA...BB.. or AA...CBB..., where there is only one C, and zero or more As and Bs.\u003c/p\u003e\u003cp\u003eNow, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e ≥ 1\u003c/span\u003e, we can fix one of the D-type edges as the front of the cycle. This helps a lot because now we can ignore the cyclic properties. (we can place anything at the end of the cycle because D-type edges can connect with any type of edges) So, we just need to find the number of ways to make a length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e string with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e As, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e Bs, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e Cs and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e - 1\u003c/span\u003e Ds. In fact, we can ignore the fact that the A-type edges, B-type edges, C-type edges and D-type edges are distinguishable and after that multiply the answer by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e!\u003ci\u003eb\u003c/i\u003e!\u003ci\u003ec\u003c/i\u003e!(\u003ci\u003ed\u003c/i\u003e - 1)!\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe can easily find the number of valid strings we can make. First, place all the Ds. Now, we\u0027re trying to insert the As, Bs and Cs into the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e empty spaces between, after and before the Ds. The key is that by our observation above, we only care about how many As, Bs and Cs we insert in each space since after that the way to put that in is uniquely determined. So, to place the As and Bs, we can use the balls in urns formula to find that the number of ways to place the As is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7a/55/7a55d4c358a2a3ff6b221528ee7d0027200eca23.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and the number of ways to place the Bs is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/17/0e/170e12a8dc084aae9fd5c601493a1d6f04bddec1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. The number of ways to place the Cs is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/60/58/6058c54e8a2c2d39c34e2f0968e51d8072637e47.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, since we choose where the Cs should go.\u003c/p\u003e\u003cp\u003eThus, it turns out that we can find the answer in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e (with precomputing binomial coefficients and factorials) when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d 1\u003c/span\u003e. We\u0027ll use this to find the answer for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. In the general case, there might be cycles that consists entirely of As and entirely of Bs, and those that contains at least one D. We call them the A-cycle, B-cycle and D-cycles respectively. \u003c/p\u003e\u003cp\u003eNow, we precompute \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e, the number of ways to form \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e cycles using \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e distinguishable As. This can be done with a simple dp in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e. We iterate through the number of As we\u0027re using for the first cycle. Then, suppose we use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e As. The number of ways to choose which of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e As to use is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5e/8a/5e8ae7a582bcb0ea314533575b0944eb4c04d305.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and we can permute them in \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003em\u003c/i\u003e - 1)!\u003c/span\u003e ways inside the cycle. (not \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e!\u003c/span\u003e because we have to account for all the cyclic permutations) Also, after summing this for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e, we have to divide the answer by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, to account for overcounting the candidates for the first cycle (the order of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e cycles are not important)\u003c/p\u003e\u003cp\u003eThus, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e can be computed in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e. First, we see how to compute the answer for a single \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Fix \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e, \u003ci\u003ee\u003c/i\u003e, \u003ci\u003ef\u003c/i\u003e\u003c/span\u003e, the number of A-cycles, B-cycles, number of As in total among the A-cycles and number of Bs in total among the B-cycles. Then, since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is fixed, we know that the number of D-cycles is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. Now, we can find the answer in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e. First, we can use the values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ee\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e), \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e), \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ed\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e to determine the number of ways to place the Ds, and the As, Bs that are in the A-cycles and B-cycles. Then, to place the remaining As, Bs and Cs, we can use the same method as we did for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d 1\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e, since the number of spaces to place them is still the same. (You can think of it as each D leaves an empty space to place As, Bs and Cs to the right of it) After that, we multiply the answer by \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ca/1d/ca1d22acfae7e110e7c5665fee5964039ab62866.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e to account for the choice of the set of As and Bs used in the A-only and B-only cycles. Thus, the complexity of this method is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e)\u003c/span\u003e for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e)\u003c/span\u003e in total, which is clearly too slow.\u003c/p\u003e\u003cp\u003eWe can improve this by iterating through all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e, \u003ci\u003ee\u003c/i\u003e, \u003ci\u003ef\u003c/i\u003e\u003c/span\u003e instead. So, for this to work we need to precompute \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ee\u003c/i\u003e, 0)\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e) + \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ee\u003c/i\u003e, 1)\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e - 1) + ... + \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ee\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e)\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e, 0)\u003c/span\u003e, which we can write as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e, \u003ci\u003ee\u003c/i\u003e, \u003ci\u003ef\u003c/i\u003e)\u003c/span\u003e. Naively doing this precomputation gives \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e)\u003c/span\u003e. Then, we can calculate the answer by iterating through all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e, \u003ci\u003ee\u003c/i\u003e, \u003ci\u003ef\u003c/i\u003e\u003c/span\u003e and thus getting \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e per query and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e)\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. This is still too slow to pass \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 250\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe should take a closer look of what we\u0027re actually calculating. Note that for a fixed pair \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e, \u003ci\u003ef\u003c/i\u003e\u003c/span\u003e, the values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e, \u003ci\u003ee\u003c/i\u003e, \u003ci\u003ef\u003c/i\u003e)\u003c/span\u003e can be calculated for all possible \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5d/1f/5d1f29f648247e77966a5b1703590aea2a6a75b6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e1.58\u003c/sup\u003e)\u003c/span\u003e by using Number Theoretic Transform or Karatsuba\u0027s Algorithm respectively. (note that the modulus has been chosen for NFT to work) This is because if we fix \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e, \u003ci\u003ef\u003c/i\u003e\u003c/span\u003e, then we\u0027re precisely finding the coefficients of the polynomial \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ee\u003c/i\u003e, 0)\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e0\u003c/sup\u003e + \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ee\u003c/i\u003e, 1)\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e1\u003c/sup\u003e + ... + \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ee\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e)\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e)(\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e, 0)\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e0\u003c/sup\u003e + \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e, 1)\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e1\u003c/sup\u003e + ... + \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e)\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e, so this can be handled with NFT/Karatsuba.\u003c/p\u003e\u003cp\u003eThus, the precomputation of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e, \u003ci\u003ee\u003c/i\u003e, \u003ci\u003ef\u003c/i\u003e)\u003c/span\u003e can be done in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/24/55/24556e0112c768d9a302dc56670a8320538d44f1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3.58\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNext, suppose we fixed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e. We will calculate the answer for all possible \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5d/1f/5d1f29f648247e77966a5b1703590aea2a6a75b6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e similar to how we calculated \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e, \u003ci\u003ee\u003c/i\u003e, \u003ci\u003ef\u003c/i\u003e)\u003c/span\u003e. This time, we\u0027re multiplying the following two polynomials : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ed\u003c/i\u003e, 0)\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e0\u003c/sup\u003e + \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ed\u003c/i\u003e, 1)\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e1\u003c/sup\u003e + ... + \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ed\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e)\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(0, \u003ci\u003ee\u003c/i\u003e, \u003ci\u003ef\u003c/i\u003e)\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e0\u003c/sup\u003e + \u003ci\u003eg\u003c/i\u003e(1, \u003ci\u003ee\u003c/i\u003e, \u003ci\u003ef\u003c/i\u003e)\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e1\u003c/sup\u003e + ... + \u003ci\u003eg\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003ee\u003c/i\u003e, \u003ci\u003ef\u003c/i\u003e)\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. Again, we can calculate this using any fast multiplication method, so the entire solution takes \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/24/55/24556e0112c768d9a302dc56670a8320538d44f1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3.58\u003c/sup\u003e)\u003c/span\u003e, depending on which algorithm is used to multiply polynomials.\u003c/p\u003e\u003cp\u003eNote that if you\u0027re using NFT/FFT, there is a small trick that can save some time. When we precompute the values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e, \u003ci\u003ee\u003c/i\u003e, \u003ci\u003ef\u003c/i\u003e)\u003c/span\u003e, we don\u0027t need to do inverse FFT on the result and leave it in the FFTed form. After that, when we want to find the convolution of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ed\u003c/i\u003e, \u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ee\u003c/i\u003e, \u003ci\u003ef\u003c/i\u003e)\u003c/span\u003e, we just need to apply FFT to the first polynomial and multiply them. This reduces the number of FFTs and it reduced my solution runtime by half.\u003c/p\u003e\u003cp\u003eTime Complexity : \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/24/55/24556e0112c768d9a302dc56670a8320538d44f1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3.58\u003c/sup\u003e)\u003c/span\u003e, depending on whether NFT or Karatsuba is used.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode (NFT)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int N \u003d 251;\nconst int MOD \u003d 998244353;\nll inv2;\nll prt;\nll iprt;\n\nll dpncr[N][N];\nll fact[N];\nll inverse[N];\nll g[N][N];\nll sumg[N][N][N];\n\nvector\u0026lt;ii\u0026gt; perm;\nint A, B, C, D;\n\nll modpow(ll a, ll b)\n{\n\tll r \u003d 1;\n\twhile(b)\n\t{\n\t\tif(b\u0026amp;1) r \u003d (r*a)%MOD;\n\t\ta \u003d (a*a)%MOD;\n\t\tb\u0026gt;\u0026gt;\u003d1;\n\t}\n\treturn r;\n}\n\nll inv(ll a)\n{\n\treturn modpow(a, MOD - 2);\n}\n\nll choose(int n, int m)\n{\n\tif(m \u0026lt; 0) return 0;\n\tif(n \u0026lt; m) return 0;\n\tif(m \u003d\u003d 0) return 1;\n\tif(n \u003d\u003d m) return 1;\n\tif(dpncr[n][m] !\u003d -1) return dpncr[n][m];\n\tdpncr[n][m] \u003d choose(n - 1, m - 1) + choose(n - 1, m);\n\tdpncr[n][m] +\u003d MOD; dpncr[n][m] %\u003d MOD;\n\treturn dpncr[n][m];\n}\n\nvoid computefact()\n{\n\tfact[0] \u003d 1;\n\tfor(ll i \u003d 1; i \u0026lt; N; i++)\n\t{\n\t\tfact[i] \u003d (fact[i - 1]*i)%MOD;\n\t}\n\tfor(ll i \u003d 1; i \u0026lt; N; i++)\n\t{\n\t\tinverse[i] \u003d modpow(i, MOD - 2);\n\t}\n}\n\nvoid print(vector\u0026lt;ii\u0026gt;\u0026amp; vec)\n{\n\tfor(int i \u003d 0; i \u0026lt; vec.size(); i++)\n\t{\n\t\tcout \u0026lt;\u0026lt; vec[i].fi \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; vec[i].se \u0026lt;\u0026lt; endl;\n\t}\n\tcout \u0026lt;\u0026lt; \u0026quot;------------------------------------------------\u0026quot; \u0026lt;\u0026lt; endl;\n}\n\nvoid printans(vector\u0026lt;ll\u0026gt;\u0026amp; vec)\n{\n\tfor(int i \u003d 0; i \u0026lt; vec.size(); i++)\n\t{\n\t\tcout \u0026lt;\u0026lt; vec[i] \u0026lt;\u0026lt; \u0027 \u0027;\n\t}\n\tcout \u0026lt;\u0026lt; endl;\n}\n\nvoid printansi(vector\u0026lt;int\u0026gt;\u0026amp; vec)\n{\n\tfor(int i \u003d 0; i \u0026lt; vec.size(); i++)\n\t{\n\t\tcout \u0026lt;\u0026lt; vec[i] \u0026lt;\u0026lt; \u0027 \u0027;\n\t}\n\tcout \u0026lt;\u0026lt; endl;\n}\n\nvoid calcpos(vector\u0026lt;ii\u0026gt;\u0026amp; pos)\n{\n\tpos.resize(perm.size());\n\tfor(int i \u003d 0; i \u0026lt; perm.size(); i++)\n\t{\n\t\tpos[i] \u003d ii(-1, -1);\n\t}\n\tfor(int i \u003d 1; i \u0026lt; perm.size(); i++)\n\t{\n\t\tif(perm[i].fi \u0026gt; 0)\n\t\t{\n\t\t\tpos[perm[i].fi].fi \u003d i;\n\t\t}\n\t\tif(perm[i].se \u0026gt; 0)\n\t\t{\n\t\t\tpos[perm[i].se].se \u003d i;\n\t\t}\n\t}\n}\n\nint reduce()\n{\n\tint n \u003d perm.size() - 1;\n\tvector\u0026lt;ii\u0026gt; pos;\n\tint cnt \u003d 0;\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++) //Do a reduction\n\t{\n\t\tcalcpos(pos);\n\t\t//print(pos);\n\t\tif(pos[i].fi \u0026gt; 0 \u0026amp;\u0026amp; pos[i].se \u0026gt; 0)\n\t\t{\n\t\t\tif(pos[i].fi \u003d\u003d pos[i].se) \n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tii tmp1 \u003d perm[pos[i].fi];\n\t\t\t\tfor(vector\u0026lt;ii\u0026gt;::iterator it \u003d perm.begin(); it !\u003d perm.end(); it++)\n\t\t\t\t{\n\t\t\t\t\tif((*it) \u003d\u003d tmp1)\n\t\t\t\t\t{\n\t\t\t\t\t\tperm.erase(it); break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint p1 \u003d pos[i].se; int l \u003d perm[p1].fi; ii tmp1 \u003d perm[p1];\n\t\t\tint p2 \u003d pos[i].fi; int r \u003d perm[p2].se; ii tmp2 \u003d perm[p2];\n\t\t\tfor(vector\u0026lt;ii\u0026gt;::iterator it \u003d perm.begin(); it !\u003d perm.end(); it++)\n\t\t\t{\n\t\t\t\tif((*it) \u003d\u003d tmp1)\n\t\t\t\t{\n\t\t\t\t\tperm.erase(it); break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(vector\u0026lt;ii\u0026gt;::iterator it \u003d perm.begin(); it !\u003d perm.end(); it++)\n\t\t\t{\n\t\t\t\tif((*it) \u003d\u003d tmp2)\n\t\t\t\t{\n\t\t\t\t\tperm.erase(it); break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tperm.pb(ii(l, r));\n\t\t}\n\t}\n\t//count A, B, C, D\n\tfor(int i \u003d 1; i \u0026lt; perm.size(); i++)\n\t{\n\t\tif(perm[i].fi \u0026gt; 0 \u0026amp;\u0026amp; perm[i].se \u0026gt; 0)\n\t\t{\n\t\t\tassert(perm[i].fi !\u003d perm[i].se);\n\t\t\tC++;\n\t\t}\n\t\telse if(perm[i].fi \u0026gt; 0)\n\t\t{\n\t\t\tA++;\n\t\t}\n\t\telse if(perm[i].se \u0026gt; 0)\n\t\t{\n\t\t\tB++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tD++;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nll mult(ll a, ll b)\n{\n\tll r \u003d (a*b)%MOD;\n\tr \u003d (r+MOD)%MOD;\n\treturn r;\n}\n\nll add(ll a, ll b)\n{\n\tll r \u003d ((a+b)%MOD+MOD)%MOD;\n\treturn r;\n}\n\nll F(ll a, ll b, ll c, ll d)\n{\n\tll ans \u003d 1;\n\tif(d \u003d\u003d 0)\n\t{\n\t\tif(a \u003d\u003d 0 \u0026amp;\u0026amp; b \u003d\u003d 0 \u0026amp;\u0026amp; c \u003d\u003d 0) return 1;\n\t\telse return 0;\n\t}\n\tans \u003d mult(ans, fact[a]);\n\tans \u003d mult(ans, fact[b]);\n\tans \u003d mult(ans, fact[c]);\n\tans \u003d mult(ans, choose(a+d-1, d-1));\n\tans \u003d mult(ans, choose(b+d-1, d-1));\n\tans \u003d mult(ans, choose(d, C));\n\treturn ans;\n}\n\nconst int LG \u003d 9;\nconst int root_pw \u003d (1\u0026lt;\u0026lt;LG);\nvoid fft (vector\u0026lt;int\u0026gt; \u0026amp; a, bool invert) \n{\n\tint n \u003d (int) a.size();\n \n\tfor (int i\u003d1, j\u003d0; i\u0026lt;n; ++i) {\n\t\tint bit \u003d n \u0026gt;\u0026gt; 1;\n\t\tfor (; j\u0026gt;\u003dbit; bit\u0026gt;\u0026gt;\u003d1)\n\t\t\tj -\u003d bit;\n\t\tj +\u003d bit;\n\t\tif (i \u0026lt; j)\n\t\t\tswap (a[i], a[j]);\n\t}\n \n\tfor (int len\u003d2; len\u0026lt;\u003dn; len\u0026lt;\u0026lt;\u003d1) {\n\t\tint wlen \u003d invert ? iprt : prt;\n\t\tfor (int i\u003dlen; i\u0026lt;root_pw; i\u0026lt;\u0026lt;\u003d1)\n\t\t\twlen \u003d int((wlen*1LL*wlen)%MOD);\n\t\tfor (int i\u003d0; i\u0026lt;n; i+\u003dlen) {\n\t\t\tint w \u003d 1;\n\t\t\tfor (int j\u003d0; j\u0026lt;len/2; ++j) {\n\t\t\t\tint u \u003d a[i+j]; int v \u003d int((a[i+j+len/2]*1LL*w)%MOD);\n\t\t\t\ta[i+j] \u003d u+v \u0026lt; MOD ? u+v : u+v-MOD;\n\t\t\t\ta[i+j+len/2] \u003d u-v \u0026gt;\u003d 0 ? u-v : u-v+MOD;\n\t\t\t\tw \u003d int (w * 1LL * wlen % MOD);\n\t\t\t}\n\t\t}\n\t}\n\tif (invert) {\n\t\tll nrev \u003d inv(n);\n\t\tfor (int i\u003d0; i\u0026lt;n; ++i)\n\t\t\ta[i] \u003d int((a[i]*1LL*nrev)%MOD);\n\t}\n}\n\nvoid multiply(vector\u0026lt;int\u0026gt;\u0026amp; a, vector\u0026lt;int\u0026gt;\u0026amp; b, vector\u0026lt;int\u0026gt;\u0026amp; res)\n{\n\tvector\u0026lt;int\u0026gt; fa(a.begin(), a.end()), fb(b.begin(), b.end());\n\tint n \u003d 1;\n\twhile(n \u0026lt; max(a.size(), b.size())) n \u0026lt;\u0026lt;\u003d 1;\n\tfa.resize(n); fb.resize(n);\n\t//cerr \u0026lt;\u0026lt; \u0026quot;A : \u0026quot;; printansi(fa); cerr \u0026lt;\u0026lt; \u0026quot;B : \u0026quot;; printansi(fb);\n\tfft(fa, 0); fft(fb, 0);\n\t//cerr \u0026lt;\u0026lt; \u0026quot;INVERT ONCE : \u0026quot;;\n\t//printans(fa); printans(fb);\n\t//fft(fa, 1); fft(fb, 1); cerr \u0026lt;\u0026lt; \u0026quot;INVERT BACK A: \u0026quot;; printans(fa); cerr \u0026lt;\u0026lt; \u0026quot;INVERT BACK B: \u0026quot;; printans(fb);\n\tres.resize(n);\n\tfor(int i \u003d 0; i \u0026lt; n; i++) res[i] \u003d int((fa[i]*1LL*fb[i])%MOD);\n\t//printans(fa);\n\tfft(res, 1);\n\t//cerr \u0026lt;\u0026lt; \u0026quot;CONVOLUTION : \u0026quot;; printansi(res);\n\t\n}\n\nvoid computeg(int n)\n{\n\tg[0][0] \u003d 1;\n\tg[1][1] \u003d 1;\n\tfor(int i \u003d 2; i \u0026lt;\u003d n; i++)\n\t{\n\t\tfor(int j \u003d 1; j \u0026lt;\u003d i; j++)\n\t\t{\n\t\t\tfor(int k \u003d 1; k \u0026lt;\u003d i; k++)\n\t\t\t{\n\t\t\t\tg[i][j] \u003d add(g[i][j], mult(g[i-k][j-1], mult(choose(i, k), fact[k-1])));\n\t\t\t}\n\t\t\t//cerr \u0026lt;\u0026lt; g[i][j] \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t\t\tg[i][j] \u003d mult(g[i][j], inverse[j]);\n\t\t\t//cerr \u0026lt;\u0026lt; \u0026quot;G : \u0026quot; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; g[i][j] \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t\t}\n\t}\n\tfor(int i \u003d 0; i \u0026lt;\u003d A; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt;\u003d B; j++)\n\t\t{\n\t\t\tvector\u0026lt;int\u0026gt; gi; vector\u0026lt;int\u0026gt; gj;\n\t\t\tgi.resize(n+1); gj.resize(n+1);\n\t\t\tfor(int k \u003d 0; k \u0026lt;\u003d n; k++)\n\t\t\t{\n\t\t\t\tgi[k] \u003d int(g[i][k]);\n\t\t\t\tgj[k] \u003d int(g[j][k]);\n\t\t\t\t//cerr \u0026lt;\u0026lt; gi[k] \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; gj[k] \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t\t\t}\n\t\t\tvector\u0026lt;int\u0026gt; res;\n\t\t\tmultiply(gi, gj, res);\n\t\t\tfor(int k \u003d 0; k \u0026lt;\u003d n; k++)\n\t\t\t{\n\t\t\t\tsumg[i][j][k] \u003d res[k];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin \u0026gt;\u0026gt; n; perm.resize(n+1);\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++)\n\t{\n\t\tcin \u0026gt;\u0026gt; perm[i].fi;\n\t}\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++)\n\t{\n\t\tcin \u0026gt;\u0026gt; perm[i].se;\n\t}\n\tll tmpmult \u003d 7*17;\n\ttmpmult \u003d mult(tmpmult, modpow(2, 23 - LG)); \n\tprt \u003d modpow(3, tmpmult);\n\tinv2 \u003d inv(2);\n\tiprt \u003d inv(prt);\n\tA \u003d 0; B \u003d 0; C \u003d 0; D \u003d 0;\n\tmemset(dpncr, -1, sizeof(dpncr));\n\tmemset(sumg, 0, sizeof(sumg));\n\tmemset(g, 0, sizeof(g));\n\tmemset(fact, 0, sizeof(fact));\n\tmemset(inverse, 0, sizeof(inverse));\n\tint cycles \u003d reduce();\n\tcomputefact(); \n\tcomputeg(n);\n\t//cerr \u0026lt;\u0026lt; h(1, 0, 0) \u0026lt;\u0026lt; endl;\n\t\n\tvector\u0026lt;ll\u0026gt; ans; ans.assign(n+1, 0);\n\t\n\tif(D - C \u0026lt; 0)\n\t{\n\t\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t\t{\n\t\t\tcout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0027 \u0027;\n\t\t}\n\t\tcout \u0026lt;\u0026lt; endl;\n\t\treturn 0;\n\t}\n\n\tfor(int i \u003d 0; i \u0026lt;\u003d A; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt;\u003d B; j++)\n\t\t{\n\t\t\tll coef \u003d 1;\n\t\t\tcoef \u003d mult(coef, F(A-i,B-j,C,D));\n\t\t\tif(A \u0026gt; 0) coef \u003d mult(coef, choose(A, i));\n\t\t\tif(B \u0026gt; 0) coef \u003d mult(coef, choose(B, j));\n\t\t\tvector\u0026lt;int\u0026gt; gi; vector\u0026lt;int\u0026gt; gj;\n\t\t\tgi.resize(n+1); gj.resize(n+1);\n\t\t\tfor(int k \u003d 0; k \u0026lt;\u003d n - cycles; k++)\n\t\t\t{\n\t\t\t\tgi[k] \u003d int(g[D][k]);\n\t\t\t\tgj[k] \u003d int(sumg[i][j][k]);\n\t\t\t}\n\t\t\tvector\u0026lt;int\u0026gt; res;\n\t\t\tmultiply(gi, gj, res);\n\t\t\t//cout \u0026lt;\u0026lt; gi.size() \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; gj.size() \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; res.size() \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; cycles \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t\t\tfor(int k \u003d 0; k \u0026lt;\u003d n - cycles; k++)\n\t\t\t{\n\t\t\t\tint moves \u003d n - (k + cycles);\n\t\t\t\tans[moves] \u003d add(ans[moves], mult(res[k], coef));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i \u003d 0; i \u0026lt; ans.size(); i++)\n\t{\n\t\tans[i] \u003d mult(ans[i], fact[D-C]);\n\t}\n\t\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tcout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0027 \u0027;\n\t}\n\tcout \u0026lt;\u0026lt; endl;\n\t\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode (Karatsuba)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int N \u003d 251;\nconst int MOD \u003d 998244353;\nll inv2;\nll prt;\nll iprt;\n\nll dpncr[N][N];\nll fact[N];\nll inverse[N];\nll g[N][N];\nll sumg[N][N][N];\n\nvector\u0026lt;ii\u0026gt; perm;\nint A, B, C, D;\n\nll modpow(ll a, ll b)\n{\n\tll r \u003d 1;\n\twhile(b)\n\t{\n\t\tif(b\u0026amp;1) r \u003d (r*a)%MOD;\n\t\ta \u003d (a*a)%MOD;\n\t\tb\u0026gt;\u0026gt;\u003d1;\n\t}\n\treturn r;\n}\n\nll inv(ll a)\n{\n\treturn modpow(a, MOD - 2);\n}\n\nll choose(int n, int m)\n{\n\tif(m \u0026lt; 0) return 0;\n\tif(n \u0026lt; m) return 0;\n\tif(m \u003d\u003d 0) return 1;\n\tif(n \u003d\u003d m) return 1;\n\tif(dpncr[n][m] !\u003d -1) return dpncr[n][m];\n\tdpncr[n][m] \u003d choose(n - 1, m - 1) + choose(n - 1, m);\n\tdpncr[n][m] +\u003d MOD; dpncr[n][m] %\u003d MOD;\n\treturn dpncr[n][m];\n}\n\nvoid computefact()\n{\n\tfact[0] \u003d 1;\n\tfor(ll i \u003d 1; i \u0026lt; N; i++)\n\t{\n\t\tfact[i] \u003d (fact[i - 1]*i)%MOD;\n\t}\n\tfor(ll i \u003d 1; i \u0026lt; N; i++)\n\t{\n\t\tinverse[i] \u003d modpow(i, MOD - 2);\n\t}\n}\n\nvoid print(vector\u0026lt;ii\u0026gt;\u0026amp; vec)\n{\n\tfor(int i \u003d 0; i \u0026lt; vec.size(); i++)\n\t{\n\t\tcout \u0026lt;\u0026lt; vec[i].fi \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; vec[i].se \u0026lt;\u0026lt; endl;\n\t}\n\tcout \u0026lt;\u0026lt; \u0026quot;------------------------------------------------\u0026quot; \u0026lt;\u0026lt; endl;\n}\n\nvoid printans(vector\u0026lt;ll\u0026gt;\u0026amp; vec)\n{\n\tfor(int i \u003d 0; i \u0026lt; vec.size(); i++)\n\t{\n\t\tcout \u0026lt;\u0026lt; vec[i] \u0026lt;\u0026lt; \u0027 \u0027;\n\t}\n\tcout \u0026lt;\u0026lt; endl;\n}\n\nvoid printansi(vector\u0026lt;int\u0026gt;\u0026amp; vec)\n{\n\tfor(int i \u003d 0; i \u0026lt; vec.size(); i++)\n\t{\n\t\tcout \u0026lt;\u0026lt; vec[i] \u0026lt;\u0026lt; \u0027 \u0027;\n\t}\n\tcout \u0026lt;\u0026lt; endl;\n}\n\nvoid calcpos(vector\u0026lt;ii\u0026gt;\u0026amp; pos)\n{\n\tpos.resize(perm.size());\n\tfor(int i \u003d 0; i \u0026lt; perm.size(); i++)\n\t{\n\t\tpos[i] \u003d ii(-1, -1);\n\t}\n\tfor(int i \u003d 1; i \u0026lt; perm.size(); i++)\n\t{\n\t\tif(perm[i].fi \u0026gt; 0)\n\t\t{\n\t\t\tpos[perm[i].fi].fi \u003d i;\n\t\t}\n\t\tif(perm[i].se \u0026gt; 0)\n\t\t{\n\t\t\tpos[perm[i].se].se \u003d i;\n\t\t}\n\t}\n}\n\nint reduce()\n{\n\tint n \u003d perm.size() - 1;\n\tvector\u0026lt;ii\u0026gt; pos;\n\tint cnt \u003d 0;\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++) //Do a reduction\n\t{\n\t\tcalcpos(pos);\n\t\t//print(pos);\n\t\tif(pos[i].fi \u0026gt; 0 \u0026amp;\u0026amp; pos[i].se \u0026gt; 0)\n\t\t{\n\t\t\tif(pos[i].fi \u003d\u003d pos[i].se) \n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tii tmp1 \u003d perm[pos[i].fi];\n\t\t\t\tfor(vector\u0026lt;ii\u0026gt;::iterator it \u003d perm.begin(); it !\u003d perm.end(); it++)\n\t\t\t\t{\n\t\t\t\t\tif((*it) \u003d\u003d tmp1)\n\t\t\t\t\t{\n\t\t\t\t\t\tperm.erase(it); break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint p1 \u003d pos[i].se; int l \u003d perm[p1].fi; ii tmp1 \u003d perm[p1];\n\t\t\tint p2 \u003d pos[i].fi; int r \u003d perm[p2].se; ii tmp2 \u003d perm[p2];\n\t\t\tfor(vector\u0026lt;ii\u0026gt;::iterator it \u003d perm.begin(); it !\u003d perm.end(); it++)\n\t\t\t{\n\t\t\t\tif((*it) \u003d\u003d tmp1)\n\t\t\t\t{\n\t\t\t\t\tperm.erase(it); break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(vector\u0026lt;ii\u0026gt;::iterator it \u003d perm.begin(); it !\u003d perm.end(); it++)\n\t\t\t{\n\t\t\t\tif((*it) \u003d\u003d tmp2)\n\t\t\t\t{\n\t\t\t\t\tperm.erase(it); break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tperm.pb(ii(l, r));\n\t\t}\n\t}\n\t//count A, B, C, D\n\tfor(int i \u003d 1; i \u0026lt; perm.size(); i++)\n\t{\n\t\tif(perm[i].fi \u0026gt; 0 \u0026amp;\u0026amp; perm[i].se \u0026gt; 0)\n\t\t{\n\t\t\tassert(perm[i].fi !\u003d perm[i].se);\n\t\t\tC++;\n\t\t}\n\t\telse if(perm[i].fi \u0026gt; 0)\n\t\t{\n\t\t\tA++;\n\t\t}\n\t\telse if(perm[i].se \u0026gt; 0)\n\t\t{\n\t\t\tB++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tD++;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nll mult(ll a, ll b)\n{\n\tll r \u003d (a*b)%MOD;\n\tr \u003d (r+MOD)%MOD;\n\treturn r;\n}\n\nll add(ll a, ll b)\n{\n\tll r \u003d ((a+b)%MOD+MOD)%MOD;\n\treturn r;\n}\n\nll F(ll a, ll b, ll c, ll d)\n{\n\tll ans \u003d 1;\n\tif(d \u003d\u003d 0)\n\t{\n\t\tif(a \u003d\u003d 0 \u0026amp;\u0026amp; b \u003d\u003d 0 \u0026amp;\u0026amp; c \u003d\u003d 0) return 1;\n\t\telse return 0;\n\t}\n\tans \u003d mult(ans, fact[a]);\n\tans \u003d mult(ans, fact[b]);\n\tans \u003d mult(ans, fact[c]);\n\tans \u003d mult(ans, choose(a+d-1, d-1));\n\tans \u003d mult(ans, choose(b+d-1, d-1));\n\tans \u003d mult(ans, choose(d, C));\n\treturn ans;\n}\n\nll buffer[20001], bufferpos, siz \u003d 1024;\nconst int LG \u003d 4;\n\nvoid multiply(int size, ll a[], ll b[], ll r[])\n{\n\tif(size \u0026lt;\u003d (1\u0026lt;\u0026lt;LG))\n\t{\n\t\tfor(int i \u003d 0; i \u0026lt; size*2; i++) r[i] \u003d 0;\n\t\tfor(int i \u003d 0; i \u0026lt; size; i++)\n\t\t{\n\t\t\tif(a[i])\n\t\t\t{\n\t\t\t\tfor(int j \u003d 0; j \u0026lt; size; j++)\n\t\t\t\t{\n\t\t\t\t\tr[i+j] +\u003d a[i]*b[j];\n\t\t\t\t\tr[i+j] %\u003d MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i \u003d 0; i \u0026lt; size*2; i++)\n\t\t{\n\t\t\tr[i] %\u003d MOD;\n\t\t}\n\t\treturn ;\n\t}\n\tint s \u003d size/2;\n\tmultiply(s, a, b, r);\n\tmultiply(s, a+s, b+s, r+size);\n\tll *a2 \u003d buffer+bufferpos; bufferpos +\u003d s;\n\tll *b2 \u003d buffer+bufferpos; bufferpos +\u003d s;\n\tll *r2 \u003d buffer+bufferpos; bufferpos +\u003d size;\n\tfor(int i \u003d 0; i \u0026lt; s; i++)\n\t{\n\t\ta2[i] \u003d a[i] + a[i+s];\n\t\tif(a2[i]\u0026gt;\u003dMOD) a2[i]-\u003dMOD;\n\t}\n\tfor(int i \u003d 0; i \u0026lt; s; i++)\n\t{\n\t\tb2[i] \u003d b[i] + b[i+s];\n\t\tif(b2[i]\u0026gt;\u003dMOD) b2[i]-\u003dMOD;\n\t}\n\tmultiply(s, a2, b2, r2);\n\tfor(int i \u003d 0; i \u0026lt; size; i++)\n\t{\n\t\tr2[i] -\u003d (r[i] + r[i+size]);\n\t}\n\tfor(int i \u003d 0; i \u0026lt; size; i++)\n\t{\n\t\tr[i+s] +\u003d r2[i];\n\t\tr[i+s]%\u003dMOD;\n\t\tif(r[i+s]\u0026lt;0) r[i+s]+\u003dMOD;\n\t}\n\tbufferpos -\u003d (s+s+size);\n}\nll gi[N+5]; ll gj[N+5];\n\nvoid computeg(int n)\n{\n\tg[0][0] \u003d 1;\n\tg[1][1] \u003d 1;\n\tfor(int i \u003d 2; i \u0026lt;\u003d n; i++)\n\t{\n\t\tfor(int j \u003d 1; j \u0026lt;\u003d i; j++)\n\t\t{\n\t\t\tfor(int k \u003d 1; k \u0026lt;\u003d i; k++)\n\t\t\t{\n\t\t\t\tg[i][j] \u003d add(g[i][j], mult(g[i-k][j-1], mult(choose(i, k), fact[k-1])));\n\t\t\t}\n\t\t\tg[i][j] \u003d mult(g[i][j], inverse[j]);\n\t\t}\n\t}\n\tfor(int i \u003d 0; i \u0026lt;\u003d A; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt;\u003d B; j++)\n\t\t{\n\t\t\tsiz \u003d 512;\n\t\t\twhile(siz/2 \u0026gt;\u003d n+1) siz\u0026gt;\u0026gt;\u003d1;\n\t\t\tfor(int k \u003d 0; k \u0026lt; siz; k++)\n\t\t\t{\n\t\t\t\tif(k \u0026lt;\u003d n)\n\t\t\t\t{\n\t\t\t\t\tgi[k] \u003d g[i][k];\n\t\t\t\t\tgj[k] \u003d g[j][k];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tgi[k] \u003d gj[k] \u003d 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll *res \u003d buffer+bufferpos;\n\t\t\tbufferpos+\u003d2*siz;\n\t\t\tmultiply(siz,gi,gj,res);\n\t\t\tfor(int k \u003d 0; k \u0026lt;\u003d n; k++)\n\t\t\t{\n\t\t\t\tsumg[i][j][k] \u003d res[k];\n\t\t\t}\n\t\t\tbufferpos-\u003d2*siz;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin \u0026gt;\u0026gt; n; perm.resize(n+1);\n\t\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++)\n\t{\n\t\tcin \u0026gt;\u0026gt; perm[i].fi;\n\t}\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++)\n\t{\n\t\tcin \u0026gt;\u0026gt; perm[i].se;\n\t}\n\t\n\tA \u003d 0; B \u003d 0; C \u003d 0; D \u003d 0;\n\tmemset(dpncr, -1, sizeof(dpncr));\n\tmemset(sumg, 0, sizeof(sumg));\n\tmemset(g, 0, sizeof(g));\n\tmemset(fact, 0, sizeof(fact));\n\tmemset(inverse, 0, sizeof(inverse));\n\tint cycles \u003d reduce();\n\tcomputefact(); computeg(n);\n\tvector\u0026lt;ll\u0026gt; ans; ans.assign(n+1, 0);\n\t\n\tif(D - C \u0026lt; 0)\n\t{\n\t\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t\t{\n\t\t\tcout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0027 \u0027;\n\t\t}\n\t\tcout \u0026lt;\u0026lt; endl;\n\t\treturn 0;\n\t}\n\t\n\tfor(int i \u003d 0; i \u0026lt;\u003d A; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt;\u003d B; j++)\n\t\t{\n\t\t\tll coef \u003d 1;\n\t\t\tcoef \u003d mult(coef, F(A-i,B-j,C,D));\n\t\t\tif(A \u0026gt; 0) coef \u003d mult(coef, choose(A, i));\n\t\t\tif(B \u0026gt; 0) coef \u003d mult(coef, choose(B, j));\n\t\t\tsiz \u003d 512;\n\t\t\twhile(siz/2 \u0026gt;\u003d n-cycles+1) siz\u0026gt;\u0026gt;\u003d1;\n\t\t\tfor(int k \u003d 0; k \u0026lt; siz; k++)\n\t\t\t{\n\t\t\t\tif(k \u0026lt;\u003d n-cycles)\n\t\t\t\t{\n\t\t\t\t\tgi[k] \u003d g[D][k];\n\t\t\t\t\tgj[k] \u003d sumg[i][j][k];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tgi[k] \u003d gj[k] \u003d 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll *res \u003d buffer+bufferpos;\n\t\t\tbufferpos+\u003d2*siz;\n\t\t\tmultiply(siz,gi,gj,res);\n\t\t\tfor(int k \u003d 0; k \u0026lt;\u003d n - cycles; k++)\n\t\t\t{\n\t\t\t\tint moves \u003d n - (k + cycles);\n\t\t\t\tans[moves] \u003d add(ans[moves], mult(res[k], coef));\n\t\t\t}\n\t\t\tbufferpos-\u003d2*siz;\n\t\t}\n\t}\n\t\n\tfor(int i \u003d 0; i \u0026lt; ans.size(); i++)\n\t{\n\t\tans[i] \u003d mult(ans[i], fact[D-C]);\n\t}\n\t\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tcout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0027 \u0027;\n\t}\n\tcout \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}