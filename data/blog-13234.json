{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1406652080,"rating":0,"authorHandle":"aropan","modificationTimeSeconds":1505812936,"id":13234,"title":"\u003cp\u003eРазбор задач \u0026quot;ШО. Тренировка 20\u0026quot;\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eЕсли какие-то неточности или совсем неястности, то находим меня и сообщаем. Поехали.\u003c/p\u003e\u003ch4\u003e[problem:100445A]\u003c/h4\u003e\u003cp\u003eДля того, чтобы быстро считать сумму на интервале нужно предварительно просчитать частичные суммы:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    s[0] \u003d 1;\n    for (int i \u003d 1; i \u0026lt;\u003d n; ++i) {\n        s[i] \u003d s[i - 1] + a[i];\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗатем сумма на интервале от \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e равна \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e. Следовательно надо посчитать количество таких пар \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e, что \u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003ej\u003c/i\u003e ≤ \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e| \u0026gt; \u003ci\u003eM\u003c/i\u003e\u003c/span\u003e. Это найти достаточно просто, если предварительно отсортировать \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e и воспользоваться методом двух указателей:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    sort(s, s + n + 1);\n    ll ans \u003d 0;\n    for (int i \u003d 0, l \u003d 0, r \u003d 0; i \u0026lt;\u003d n; ++i) {\n        while (s[l] - s[i] \u0026gt; m) ++l;\n        while (r \u0026lt;\u003d n \u0026amp;\u0026amp; s[r] - s[i] \u0026lt;\u003d m) ++r;\n        ans +\u003d l + (n + 1 - r);\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e[problem:100445B]\u003c/h4\u003e\u003cp\u003eДавайте рассмотрим сумму отдельно по каждому биту, т.е. будем считать сколько раз определенный бит вошел в нашу конечную сумму. Тогда для каждого интервала потребуется узнать, сколько чисел на этом интервале содержат единицы на определенном бите. Замечаем закономерность, что на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-ом бите среди первых \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e чисел (начиная от нуля) будет нуль, затем \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e чисел будет с единицей в этом бите, а затем опять \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e чисел с нулем. У меня получилась такая функция:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003elong long bit_count(long long l, long long r, int i)\n{\n    if (l) {\n        return bit_count(0, r, i) - bit_count(0, l - 1, i);\n    }\n    int m \u003d 1LL \u0026lt;\u0026lt; i;\n    long long res \u003d (r / m) * (m \u0026gt;\u0026gt; 1) + max(0LL, (r % m) - (m \u0026gt;\u0026gt; 1) + 1);\n    return res;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДальше для каждого интервала надо знать, сколько было чисел до этого интервала с единицами в бите, а сколько с нулями, и рассмотреть сколькими способами будет получена единица в текущем бите (не забываем, что арифметические операции с ответом нужно делать по указанному модулю):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    for (int i \u003d 1; i \u0026lt;\u003d 60; ++i) {\n        o \u003d z \u003d 0;\n        for (int j \u003d 0; j \u0026lt; n; ++j) {\n            x \u003d bit_count(l[j], r[j], i);\n            y \u003d r[j] - l[j] + 1 - x;\n            ans +\u003d z * x + o * y;\n            z +\u003d y;\n            o +\u003d x;\n        }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e[problem:100445C]\u003c/h4\u003e\u003cp\u003eЭто задача является модификацией задачи, в которой нужно найти расстояние между всеми парами вершин в взвешенном дереве. Требуется рассмотреть каждое ребро и узнать сколько раз оно будет добавлено в ответ. В немодифицированной версии это произведение количества вершин по разные стороны от ребра. В этой задачи можно сказать, что проходя по ребру количество наших вершин в поддереве удваивается, тогда наши множители будут корректно обробатываться (это можно заметить, если рассмотреть множители относительно какой-нибудь одной вершинки):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid dfs_first(int curr, int prev)\n{\n    s[curr] \u003d 1;\n    c[curr] \u003d 1;\n    foreach(it, e[curr]) { // итерируемся по ребрам\n        dest \u003d it-\u0026gt;first; // соседняя вершинка\n        dist \u003d it-\u0026gt;second; // длина ребра\n        if (dest \u003d\u003d prev) { // пропускаем, если ребро направлено вверх\n            continue;\n        }\n        dfs_first(dest, curr); // обрабатываем поддереве\n        // пересчитываем нужные значения\n        s[curr] +\u003d 2 * s[dest]; // количество вершин, если после перехода их количество удваивается\n        c[curr] +\u003d c[dest]; // количество вершин в поддереве\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eА теперь просчитанную информацию можно использовать, для того, чтобы просчитать какое количество вершин с \u0026quot;удвоением\u0026quot; будет приходить к текущему ребру сверху:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid dfs_second(int curr, int prev, ll S)\n{\n    S +\u003d s[curr];\n    foreach(it, e[curr]) {\n        int dest \u003d it-\u0026gt;first;\n        int dist \u003d it-\u0026gt;second;\n        if (dest \u003d\u003d prev) {\n            continue;\n        }\n        S -\u003d 2 * s[dest];\n        dfs_second(dest, curr, 2 * S);\n        ans +\u003d dist * (S * c[dest] + s[dest] * (n - c[dest]));\n        S +\u003d 2 * s[dest];\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНе забываем делать вычисление по модулю.\u003c/p\u003e\u003ch4\u003e[problem:100445D]\u003c/h4\u003e\u003cp\u003eЗадача на тему жадности. Можно свести задачу к выполнению заданий, у которых есть время выполнения и дедлайн. В такой постановки с заданиями надо обрабатывать задания по возврастанию дедлайнов и для очередного задания проверить можно ли его добавить просто так или, предварительно удалив один, улучшить время, а иначе пропускаем:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// предварительно отсортируем транзакции по неубыванию A + B\nforeach (it, a) { // итерируемся по уже отсортированным задачам\n    if (t \u0026lt;\u003d it-\u0026gt;B || it-\u0026gt;A \u0026lt; (*s.rbegin())) { // смотрим можем ли добавить или улучшить\n        if (t \u0026gt; it-\u0026gt;B) { // если улучшить, то выкидываем худший\n            int v \u003d *s.rbegin();\n            t -\u003d v;\n            s.erase(s.find(v));\n        }\n        // добавляем текущий\n        t +\u003d it-\u0026gt;A;\n        s.insert(it-\u0026gt;A);\n    }\n}\n// по всей видимости можно было использовать heap, не знаю зачем я использовал multiset :)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДля того, чтобы свести задачу к заданиям с дедлайнами, надо рассмотреть условие, при котором транзакции могут быть добавлены, если их добавлять с конца.\u003c/p\u003e\u003ch4\u003e[problem:100445E]\u003c/h4\u003e\u003cp\u003eДавайте рассмотрим пару чисел \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e, у которых отличается только последний бит. Для любого \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e ровно одно из значений \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/27/e3/27e3833e8417b3ee461f0d644aad987fd9e57774.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e и \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f0/43/f043f7a23a49f482cbe0a0da9dcd6f3f2ca0eb0d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e будет содержать нечетное количество единиц. Тогда интервал можно интервал \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e можно представить как количество пар, у которых отличается только последний бит, и ещё не более двух чисел (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, если они не вошли в эти пары). Пары можно достаточно легко обрабатывать, а вот отдельные числа надо научиться пересекать с интервалами. За \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e это будет долго. Давайте посмотрим, сколько чисел на интервале от \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e будет при \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7b/ea/7beade55e90846d70020a3d03521d3458b66751b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e с \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e давать число с нечетным количество единиц. Как и с частичными суммами ответ может быть получен через \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003eR\u003c/i\u003e, \u003ci\u003eX\u003c/i\u003e) - \u003ci\u003eF\u003c/i\u003e(\u003ci\u003eL\u003c/i\u003e - 1, \u003ci\u003eX\u003c/i\u003e)\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e, \u003ci\u003eM\u003c/i\u003e)\u003c/span\u003e ответ для \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e \u003d 0\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e \u003d \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e \u003d \u003ci\u003eM\u003c/i\u003e\u003c/span\u003e. Как же считать ответ, когда \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e \u003d 0\u003c/span\u003e. Можно написать динамику по битам, а затем порассуждать и прийти к такой формуле:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003elong long f(long long n, long long m):\n    return (n \u0026gt;\u0026gt; 1) + ((n \u0026amp; 1) || (__builtin_popcountll(n ^ m) \u0026amp; 1))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВидим, что значение функции зависит только от значения \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e и от его четности, т.е. значения с одинаковой четностью по \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e можно суммировать, а затем уже от четности \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e смотреть сколько будет добавлено к ответу.\u003c/p\u003e\u003ch4\u003e[problem:100445F]\u003c/h4\u003e\u003cp\u003eСразу напрашивается решение за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e, давайте на него и ориентироваться. Понятно, что наш прямоугольник будет уникальным, если никакую из его сторон нельзя будет сдвинуть в сторону уменьшения прямоугольника так, чтобы множество уничтоженных кораблей не изменилось, т.е. вдоль каждой стороны прямоугольника должен стоять корабль, который будет уничтожен этим выстрелом.\u003c/p\u003e\u003cp\u003eДавайте зафиксируем координаты прямоугольник по \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e-ам. Таких вариантов будет не более \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e, так как фиксировать \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e, в котором нет границы корабля не имеет смысла. Теперь зафиксируем правую границу прямоугольника \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e, которая может быть правой границей корабля, который находится в зафиксированной полоске по \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e. Теперь надо быстро посчитать количество подходящих левых границ. В качестве левой границы также может быть только левая граница корабля, который находится в зафиксированной полоске. И если смотреть левые границы по увеличению размера прямоугольника, то начиная с определенного момента у верхней и у нижней границы появятся корабли и это будет означать, что все границы левее текущей нам будут также подходить. Чтобы все это было быстро, достаточно обрабатывать корабли, которые находятся в нашей \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e-полоске, по неубыванию правой границе кораблей и фиксировать, какие из кораблей имеют такую же нижнюю/верхнюю границу как и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e-полоска.\u003c/p\u003e\u003cp\u003eВ листинге ниже \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e требуется мысленно поменять местами, чтобы получить соответствие с вышеописанным разбором :).\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// предварительно сжали координаты\n// два for перебирают границы полоски\nfor (int i \u003d 1; i \u0026lt;\u003d ny1; ++i) {\n    for (int j \u003d ny2; j \u0026gt;\u003d 1; --j) {\n        t \u003d b \u003d 0;\n        for (int l \u003d 0, r \u003d 0; l \u0026lt; n; l \u003d r) {\n            mx \u003d 0;\n            while (r \u0026lt; n \u0026amp;\u0026amp; x2[p[r]] \u003d\u003d x2[p[l]]) { // обрабатываем все корабли с одинаковой правой границей\n                if (i \u0026lt;\u003d y1[p[r]] \u0026amp;\u0026amp; y2[p[r]] \u0026lt;\u003d j) {\n                    // обновляем насколько далеко находится левая граница корабля который косается верхней и нижней части полоски\n                    if (i \u003d\u003d y1[p[r]]) {\n                        t \u003d max(t, x1[p[r]]);\n                    }\n                    if (j \u003d\u003d y2[p[r]]) {\n                        b \u003d max(b, x1[p[r]]);\n                    }\n                    mx \u003d max(mx, x1[p[r]]);\n                    modify(x1[p[r]]); // modify не увеличивает значение на 1, а присваивает 1\n                }\n                ++r;\n            }\n            mx \u003d min(mx, min(t, b));\n            ans +\u003d findsum(mx); // сумма на префиксе\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["analysis","bos","training","20"]}}