{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1485102068,"rating":9,"authorHandle":"kefaa","modificationTimeSeconds":1485349646,"id":49942,"title":"\u003cp\u003eРазбор контеста 22.01.2017 \u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eМои (или авторские) коды к задачам (без легких задач): \u003ca href\u003d\"http://ideone.com/KxBn34\"\u003eA\u003c/a\u003e, \u003ca href\u003d\"http://ideone.com/Vi4MwD\"\u003eC\u003c/a\u003e, \u003ca href\u003d\"http://ideone.com/lND8AG\"\u003eD\u003c/a\u003e, \u003ca href\u003d\"http://ideone.com/81ofqN\"\u003eE\u003c/a\u003e, \u003ca href\u003d\"http://ideone.com/YwKkD5\"\u003eF\u003c/a\u003e, \u003ca href\u003d\"//codeforces.com/contest/377/submission/7425997\"\u003eG\u003c/a\u003e, \u003ca href\u003d\"http://ideone.com/30wxLr\"\u003eH\u003c/a\u003e, \u003ca href\u003d\"http://ideone.com/6woHVl\"\u003eJ\u003c/a\u003e, \u003ca href\u003d\"http://ideone.com/NICL1P\"\u003eK\u003c/a\u003e, \u003ca href\u003d\"http://ideone.com/9bCdSK\"\u003eL\u003c/a\u003e, \u003ca href\u003d\"http://ideone.com/97mYQ3\"\u003eM\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"http://dl.gsu.by/task.jsp?cid\u003d19\u0026amp;nid\u003d215455\"\u003eЗадача А. USACO\\2008\\April\\Silver\\2 — \u0026quot;Word Power\u0026quot;\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eДля каждого имени \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e и строки-шаблона \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e необходимо научиться понимать, входит ли шаблон в имя как подпоследовательность. Сделать это очень просто можно за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003eS\u003c/i\u003e| + |\u003ci\u003eT\u003c/i\u003e|)\u003c/span\u003e так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003ebool ok(string s, string t){\n    int ptr \u003d 0;\n    for(int i \u003d 0; i \u0026lt; s.length(); ++i) {\n        if(s[i] \u003d\u003d t[ptr]) ptr++;\n        if(ptr \u003d\u003d t.length()) return true;\n    }\n    return false;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e\u003ca href\u003d\"http://dl.gsu.by/task.jsp?cid\u003d19\u0026amp;nid\u003d1275285\"\u003eЗадача С. USACO\\2014\\April\\Bronze\\1 — \u0026quot;ODOMETER_BRONZE\u0026quot;\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eДавайте переберем все числа, которые удовлетворяют нашему условию и проверим, что они удовлетворяют заданному промежутку. Давайте посмотрим на любое хорошее число. Очевидно, что его можно охарактеризовать длиной, основной цифрой (преобладающей), дополнительной цифрой и ее позицией. Ну так давайте переберем эти параметры четырьмя циклами построим соответствующее число и проверим на принадлежность промежутку. Красиво сгенерить число по 4 параметрам \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003elength\u003c/i\u003e, \u003ci\u003emainDigit\u003c/i\u003e, \u003ci\u003eposition\u003c/i\u003e, \u003ci\u003eextraDigit\u003c/i\u003e)\u003c/span\u003e можно так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003elong long gen(int length, int main_digit, int position, int extra_digit) {\n     long long val\u003d0;\n     for(int i \u003d 0; i \u0026lt; length - position - 1; ++i) val \u003d val * 10 + main_digit;\n     val \u003d val * 10 + extra_digit;\n     for(int i \u003d 0; i \u0026lt; position; ++i) val \u003d val * 10 + main_digit;\n     return val;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВажно не забыть, что нельзя, чтобы основной цифрой был \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, не считая случая, когда дополнительная будет на старшей позиции; то есть разрешить, например \u003cspan class\u003d\"tex-span\"\u003e40000\u003c/span\u003e, но запретить \u003cspan class\u003d\"tex-span\"\u003e000300\u003c/span\u003e.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/445/B\"\u003eЗадача D. Codeforces Round #254 (Div. 2) problem B; DZY Loves Chemistry\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eКаждая компонента связности увеличивает ответ в 2^(ее размер — 1) раз.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"http://dl.gsu.by/task.jsp?cid\u003d19\u0026amp;nid\u003d1071426\"\u003eЗадача E. USACO\\2012\\November\\Bronze\\1 — \u0026quot;COWFIND\u0026quot;\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eПростая задача, но стоит показать красивый код\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e   int cnt \u003d 0, res \u003d 0;\n   for (int i \u003d 1; i \u0026lt; n; ++i){\n      if (s[i] \u003d\u003d \u0027)\u0027 \u0026amp;\u0026amp; s[i - 1] \u003d\u003d \u0027)\u0027) res +\u003d cnt;\n      if (s[i] \u003d\u003d \u0027(\u0027 \u0026amp;\u0026amp; s[i - 1] \u003d\u003d \u0027(\u0027) cnt++; \n   }\n   cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl;\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e\u003ca href\u003d\"http://dl.gsu.by/task.jsp?cid\u003d19\u0026amp;nid\u003d1071426\"\u003eЗадача F. USACO \\2014\\December\\Silver\\1 — \u0026quot;Piggy Back\u0026quot;\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eДля того, чтобы коровы шли вместе, им обеим необходимо добраться кратчайшим путем до некоторой вершины, а потом из этой вершины до амбара. Сперва давайте посчитаем кратчайшие расстояния до всех вершин, начиная из \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e и назовем полученные массивы расстояний \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e1, \u003ci\u003ed\u003c/i\u003e2, \u003ci\u003edn\u003c/i\u003e\u003c/span\u003e. Вычислить эти массивы можно обычным бфсом, считая, что каждое ребро имеет вес 1. Давайте переберем, в какой вершине встретятся коровы (пусть \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e) и обновим ответ значением \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e1[\u003ci\u003ev\u003c/i\u003e]·\u003ci\u003eB\u003c/i\u003e + \u003ci\u003ed\u003c/i\u003e2[\u003ci\u003ev\u003c/i\u003e]·\u003ci\u003eE\u003c/i\u003e + \u003ci\u003edn\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]·\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/377/A?locale\u003dru\"\u003eЗадача G. Codeforces Round #222 (Div. 1) problem A\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eПервое решение. Если есть компонента связности в матрице размера \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, а нам необходимо превратить \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e клеток в стены, то это то же самое, что оставить \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e клеток свободными, а остальные запретить. Поэтому давайте запустим бфс из любой точки матрицы, и запомним только \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e посещенных первых клеток, остальные запретим.\u003c/p\u003e\u003cp\u003eВторое решение. Задача \u0026quot;Метро\u0026quot;. задан связный граф, необходимо найти такой порядок удаления вершин, что после удаления любой вершины в заданном порядке оставшийся граф будет связен. Очевидно, что данная задача эквивалентна нашей за исключением, что нужно удалить только первые \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e вершин. \u003c/p\u003e\u003cp\u003eЗадача решается просто (вектор \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eanswer\u003c/i\u003e\u003c/span\u003e — ответ на задачу):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003evector \u0026lt;int\u0026gt; answer;\nbool used[maxn];\nvector\u0026lt;int\u0026gt; g[maxn];\n\nvoid dfs(int v) {\n    used[v] \u003d true;\n    for(int x: g[v]) { \n        if (used[x] \u003d\u003d false) {\n            dfs(x);\n        }\n    } \n    answer.push_back(v);\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eФормально, такое решение можно доказать следующим образом. Давайте решим нашу задачу для дерева: очевидно, что если каждый раз из дерева удалять любой лист, то оно останется связным. Для обычного графа можно найти любое его остовное дерево и решить задачу для него. Кажется, что приведенный код будет выполнять именно это.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"http://dl.gsu.by/task.jsp?cid\u003d19\u0026amp;nid\u003d1387426\"\u003eЗадача H. USACO \\2014\\December\\Silver\\2 — \u0026quot;MARATHON_SILVER\u0026quot;\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eДавайте считать \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e — минимальное суммарное расстояние, если последний пункт, который мы посетили, был \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e и всего мы уже пропустили \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e контрольных точек. Чтобы посчитать это значение, переберем, какую последнюю точку \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e мы посетили, и тогда можно обновить текущее значение числом \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e - (\u003ci\u003ei\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e - 1)] + \u003ci\u003edistance\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e, \u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edistance\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e — манхэттэнское расстояние между точками \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. Детали можно посмотреть в коде. \u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/sxp2f6SJzo/contest/211274/problem/I\"\u003eЗадача I. Максимальный поток минимальной стоимости\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eЗадача создана для того чтобы показать, что на любом контесте необходимо читать и решать все задачи, какое страшное бы у нее не было условие/название/ограничения :). 1000 тестов я сделал, чтобы показать, что не стоит терять время в ожидании вердикта по задаче, что иногда может отнять относительно большое количество времени (ну или такое бывает только у меня?). В самой задаче важно не забыть, что если два числа влезают в int, то их сумма необязательно.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"http://dl.gsu.by/task.jsp?cid\u003d19\u0026amp;nid\u003d1119187\"\u003eЗадача J. USACO \\2013\\April\\Bronze\\2 — \u0026quot;BLINK\u0026quot;\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eДля решения задачи нужно воспользоваться несколькими фактами. \u003c/p\u003e\u003cp\u003eВо-первых, число различных состояний \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e лампочек (включена ли каждая лампочка или нет) ровно \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e, то есть не превосходит \u003cspan class\u003d\"tex-span\"\u003e65536\u003c/span\u003e, что довольно мало. Каждое состояние можно задать двоичной маской из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e бит, где на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-ой позиции стоит \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-ая лампочка горит и \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e иначе или обычным массивом из 0 или 1.\u003c/p\u003e\u003cp\u003eВо-вторых, если в два каких-то момента времени состояния всех \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e лампочек одинаковы, то это значит, что в следующие для них моменты новые состояния тоже будут одинаковы, потому что переход из предыдущего состояния в следующее не зависит от времени. \u003c/p\u003e\u003cp\u003eКомбинируя наши наблюдения, можно понять, что процесс изменения состояний лампочек периодичен, а точнее, будет иметь некоторый предпериод вначале, после которого любое состояние (которое может быть достижимо в данном периоде) будет повторяться через равные промежутки времени, равные длине периода. Это означает, что нам нет смысла моделировать все состояния во все оставшиеся \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e моментов времени, потому что через каждые \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e (длина периода) секунд все придет к тому, с чего мы начали. Поэтому можно просто сделать \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/fd/d2/fdd2abab31d602dd6fbebdfcb520bb1ad3e76cb0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e и продолжить моделировать дальше. Асимптотика составит \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e, если пользоваться битмасками или \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sup\u003e·\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e, если пользоваться массивом. Советую посмотреть авторское решение.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"http://dl.gsu.by/task.jsp?cid\u003d19\u0026amp;nid\u003d158094\"\u003eЗадача K. Респа\\2007\\День 2\\2 — \u0026quot;Крестики-нолики 2007\u0026quot;\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eДавайте построим следующую сеть, на ней найдем любой максимальный поток и по полученному потоку восстановим ответ.\u003c/p\u003e\u003cp\u003eВ сети будет \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e + \u003ci\u003eM\u003c/i\u003e + 2\u003c/span\u003e вершины: исток, сток, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e вершин для строк (первая доля), \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e для столбцов (вторая доля). Давайте для каждой строки посчитаем, сколько еще плюсов необходимо доставить в нее (остальные неизвестные клетки нужно сделать минусами), чтобы плюсов было поровну с минусами, и проведем из истока в первую долю в соответствующую нашей строке вершину ребро с такой пропускной способностью. Аналогично сделаем для столбцов, проведя ребра из вершин второй доли в сток. Из вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e первой доли проведем ребро в вершину \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e второй доли с пропускной способностью \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, если клетка \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eij\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e поля содержит вопрос. \u003c/p\u003e\u003cp\u003eНесложно догадаться, что максимальный поток в такой сети будет означать максимальное количество вопросов, которые можно заменить на плюсы, чтобы плюсов в каждой строке и столбце было не больше минусов. Так как по условию ответ всегда существует, то величиной максимального потока будет количество плюсов во всей матрице, которые еще не стоят, что будет гарантировать равенство количеств плюсов и минусов в каждой строке и каждом столбце. Чтобы восстановить ответ нужно просто посмотреть на величину потока на каждом ребре из первой доли во вторую. \u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"http://dl.gsu.by/task.jsp?cid\u003d19\u0026amp;nid\u003d211899\"\u003eЗадача L. USACO \\2008\\February\\Gold\\3 — \u0026quot;Hotel\u0026quot;\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eДавайте будем говорить, что если комната \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e свободна, то в ячейке некоторого массива \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e будет стоять \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e иначе. Таким образом, задача будет сводиться к нахождению самого левого отрезка заданной длины в этом массиве, целиком состоящего из единиц.\u003c/p\u003e\u003cp\u003eПостроим дерево отрезков над таким массивом, каждая вершина которого будет хранить в себе следующие величины: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epref\u003c/i\u003e\u003c/span\u003e — максимальная длина префикса отрезка, за который отвечает наша вершина, целиком состоящего из единиц, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esuff\u003c/i\u003e\u003c/span\u003e — аналогично для суффикса, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e — длина всего отрезка и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emx\u003c/i\u003e\u003c/span\u003e — максимальная длина подотрезка из единиц внутри нашего отрезка. Имея такую информацию для левого и правого сына, можно легко обновить информация для себя. Пусть мы сейчас в вершине \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, ее левый сын — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eleft\u003c/i\u003e\u003c/span\u003e, а правый — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eright\u003c/i\u003e\u003c/span\u003e. Обновить \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e по значениям сыновей можно так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e//len\nv.len \u003d left.len + right.len;\n\n//pref\nif (left.pref \u003d\u003d left.len) v.pref \u003d left.len + right.pref;\nelse v.pref \u003d left.pref;\n\n//suff\nif (right.suff \u003d\u003d right.len) v.suff \u003d left.suff + right.len;\nelse v.suff \u003d right.suff;\n\n//mx\n\nv.mx \u003d max(left.mx, right.mx);\nv.mx \u003d max(v.mx, left.suff + right.pref);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбъяснение. Понятно, что новая длина равна сумме длин сыновей. Чтобы обновить максимальную длину префикса нужно взять значение префикса у левого сына. Однако, если левый сын целиком состоит из единиц, то длина максимального префикса увеличится на длину префикса правого сына. Аналогично обновляется и суффикс. Максимальный отрезок из единиц равен либо максимальному отрезку из единиц, целиком помещающемся в левом сыне, либо в правом сыне, либо он будет находится и в левом сыне, и в правом. В таком случае длина наибольшего такого отрезка это максимальная длина суффикса левого сына + максимальная длина префикса правого.\u003c/p\u003e\u003cp\u003eТеперь научимся, зная такую информацию, отвечать на запрос на поселение. Сделаем это обычным спуском по дереву, запустившись из корня. \u003c/p\u003e\u003cp\u003eДавайте для любой вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e научимся отвечать на такой запрос, считая, что у нас в распоряжении есть только отрезок, за который она отвечает. Очевидно, что ответ на такой запрос у корня дерева отрезков даст нам верный ответ на весь запрос. Итак, если максимум \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emx\u003c/i\u003e\u003c/span\u003e в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e меньше \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e (длины в запросе), то мы не сможем поселить вообще. Иначе, если длина максимального префикса у \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e не меньше \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, то ответом будет левая граница отрезка, за который отвечает \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. Иначе, если максимум в левом сыне \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eleft\u003c/i\u003e.\u003ci\u003emx\u003c/i\u003e\u003c/span\u003e не меньше \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, то сделаем точно такой же запрос к левому сыну. Иначе, оптимальный отрезок может начинаться где-то в левом сыне и заканчиваться в правом. Это возможно, только когда \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eleft\u003c/i\u003e.\u003ci\u003esuff\u003c/i\u003e + \u003ci\u003eright\u003c/i\u003e.\u003ci\u003epref\u003c/i\u003e ≥ \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. В таком случае, ответ на запрос это самая левая позиция в левом сыне, суффикс которой полностью состоит из единиц, то есть \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eleft\u003c/i\u003e.\u003ci\u003erightBorder\u003c/i\u003e - \u003ci\u003eleft\u003c/i\u003e.\u003ci\u003esuff\u003c/i\u003e + 1\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003erightBorder\u003c/i\u003e\u003c/span\u003e — правая граница отрезка, за который отвечает отрезок). Если ни один из описанных случаев не выполняется, ответ содержится в правом сыне и поэтому можно рекурсивно спросить ответ у него.\u003c/p\u003e\u003cp\u003eПосле того, как мы нашли необходимую левую границу, необходимо поселить жильцов на соответствующий отрезок. Для этого нужно весь этот отрезок покрасить в ноль в дереве отрезков. Для этого придется прикрутить ленивое проталкивание :). Запрос на выселение — такой же, за исключением, что надо красить в единицу. \u003c/p\u003e\u003cp\u003eЭто может звучать страшно, но в коде это не так и много, советую посмотреть. Пока что там мой старый (быдло)код, и я может быть перепишу его (но это неточно).\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"http://dl.gsu.by/task.jsp?cid\u003d19\u0026amp;nid\u003d157682\"\u003eЗадача M. Респа\\2007\\День 1\\1 — \u0026quot;Последовательный XOR\u0026quot;\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eВо-первых, необходимо прояснить, что же от нас хотят в задаче. На самом деле, если ответом на задачу будет число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, то оно могло быть получено только из некоторого непрерывного подотрезка массива. Если мы схлопывали два каких-то числа не из отрезка, на котором было получено число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, то на самом деле, в этом не было нужды — это никак не повлияло на ответ.\u003c/p\u003e\u003cp\u003eДальше \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7b/ea/7beade55e90846d70020a3d03521d3458b66751b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e означает операцию \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exor\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eЗначит, задача сводится к нахождению непрерывного подотрезка массива, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7b/ea/7beade55e90846d70020a3d03521d3458b66751b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e элементов которого максимален. \u003c/p\u003e\u003cp\u003eПусть мы имеем некоторый отрезок \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e..\u003ci\u003er\u003c/i\u003e\u003c/span\u003e. Чему равен \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b3/1a/b31ac8b710147be2720c09a615be419fb3212685.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e всех элементов в нем? \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/19/86/1986255ebe5494f7abb10916a5cc49473a31e8cf.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Пусть \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4d/5c/4d5c084ba28c1e2bfc85435e3165e75a3803390e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. В таком случае, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/10/e5/10e5877e4419a0d40484d9b152a245025b9f315c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (используя свойства ксора. Мы как будто взяли ксор всех первых \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e чисел массива, но вычеркнули из него первые \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e - 1\u003c/span\u003e, \u0026quot;проксорив\u0026quot; с \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eСтало немного проще: нужно для каждого \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e находить такое \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e, что \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3d/5d/3d5dbeb86e29aa6c8b983fa5f2acb98099720e11.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e максимально. Давайте перебирать правую границу \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e и для нее искать оптимальное значение. Для этого воспользуемся бором. Давайте для каждого \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e добавлять в бор битовое значение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e как обычную строку, от старших бит к младшим (будем считать, что каждое число имеет 62 бита (добавим ведущие нули), то есть все строки строки будут иметь 62 символа). Как теперь по имеющемуся бору и заданному \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e искать оптимальное \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, присутствующее в нем? Здесь будем жадно спускаться по бору. Посмотрим на старший бит числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. Пусть он равен \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. Тогда, если в боре есть хоть один путь, начинающийся с \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e (то есть существует хоть одно число в боре, у которого \u003cspan class\u003d\"tex-span\"\u003e61\u003c/span\u003e-ый бит равен \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e), то, выбрав любое число с таким битом, мы добавим к ответу \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e61\u003c/sup\u003e\u003c/span\u003e (потому что ксор битов \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, стоящих на \u003cspan class\u003d\"tex-span\"\u003e61\u003c/span\u003e-ой позиции, добавит к ответу \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e61\u003c/sup\u003e\u003c/span\u003e), что всегда выгоднее, чем выбрать путь, начинающийся с \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, потому что для любого \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e (у нас сейчас \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e \u003d 61\u003c/span\u003e) \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/sup\u003e \u0026gt; 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ez\u003c/i\u003e - 1\u003c/sup\u003e + 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ez\u003c/i\u003e - 2\u003c/sup\u003e + ... + 2\u003csup class\u003d\"upper-index\"\u003e0\u003c/sup\u003e\u003c/span\u003e. То есть, как бы хорошо мы не старались, набрать больше, чем мы наберем, пойдя в 1, мы уже не сможем никогда. Поэтому, если такой путь существует, спустимся именно в него. Иначе придется смириться и пойти другим путем, никак не увеличив ответ. После этого решим задачу для \u003cspan class\u003d\"tex-span\"\u003e60\u003c/span\u003e-ого бита, потом для \u003cspan class\u003d\"tex-span\"\u003e59\u003c/span\u003e-ого и так далее. Аналогично, если текущий бит числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e равен \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, то выгодно пойти путем, ведущим в \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. \u003c/p\u003e\u003c/div\u003e","tags":["никто","не","читает","разборы"]}}