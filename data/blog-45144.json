{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1464705794,"rating":257,"authorHandle":"MikeMirzayanov","modificationTimeSeconds":1464708405,"id":45144,"title":"\u003cp\u003eg++: beware of the signed overflow\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi!\u003c/p\u003e\u003cp\u003eI know that it will be obvious for real C++-masters, but for me it is small surprise. I used to think that signed overflow in C ++ does not cause real undefined behavior on a particular platform. That is, it is clear that depending on the big-endianness/little-endian result may be different.\u003c/p\u003e\u003cp\u003eI found short and funny example:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\nint main()\n{\n    for (int i \u003d 0; i \u0026lt; 300; i++)\n        std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; i * 12345678 \u0026lt;\u0026lt; std::endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBeing compiled with \u003ccode\u003e-O2\u003c/code\u003e on modern g++ it will run infinitely. Suddenly, right?\u003c/p\u003e\u003c/div\u003e","tags":["g++","ub"]}}