{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1519488070,"rating":5,"authorHandle":"leaomatheus","modificationTimeSeconds":1519494128,"id":58014,"title":"\u003cp\u003eDigit DP (DP em digitos)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eFormulando o problema\u003c/h2\u003e\u003cp\u003eDP em dígitos é uma subclasse de problemas de DP que são resolvidos de um jeito semelhante. Em geral, os problemas são da forma: \u003cem\u003eDado um intervalo A e B, quantos números x, A \u0026lt;\u003d x \u0026lt;\u003d B, tem uma propriedade específica\u003c/em\u003e\u003c/p\u003e\u003cp\u003eUma variação comum é achar o maior no intervalo com essa propriedade. Para ser mais específico, vamos usar como exemplo o problema: quantos x existem tal que a soma dos dígitos é exatamente 100.\u003c/p\u003e\u003ch2\u003eObservações iniciais\u003c/h2\u003e\u003cp\u003eSe o intervalo A a B é pequeno o suficiente, podemos iterar por todos esses números em O(B-A) e checar manualmente número por número, mas isso não é desejado para B-A muito grandes.\u003c/p\u003e\u003cp\u003eUm truque simples é que computar quantos números existem entre A e B é igual a computar quantos existem de 0 a B — quantos de 0 a A-1.\u003c/p\u003e\u003cp\u003eMas antes, imagine que não existe restrição de número superior, apenas no número de dígitos. Por exemplo, queremos saber quantos números existem de 00000 a 99999 -- qualquer número de 5 dígitos é válido. Nesse caso, utilizamos de programação dinâmica e dizemos que \u003cem\u003edp[n][sum]\u003c/em\u003e é o estado que diz quantos dígitos faltam adicionar à resposta e quão longe estamos da soma ideial. A recorrência é da forma:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003edp[n][sum] \u003d dp[n-1][sum-0] + dp[n-1][sum-1] + ... + dp[n-1][sum-9]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOu:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003edp[5][100] \u003d dp[4][99] + dp[4][98] + ... + dp[4][91]\ndp[5][99] \u003d dp[4][99] + dp[4][98] + ... + dp[4][90] ...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eQueremos computar justamente dp[n][100]. Obviamente, dp[0][sum] é 1 se sum for 100, ou 0 caso contrário, pois nesse caso não podemos colocar nenhum dígito. Um jeito recursivo de calcular está abaixo. Observe que na recursão memorizamos as respostas, para que elas não sejam computadas várias vezes. Por exemplo: dp[4][99] é utilizada para computar dp[5][100] e dp[5][99], e não é interessante calcular tudo de novo. Por isso, memorizamos.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint dp[N][100];            // N numero maximo de digitos\nmemset(dp, -1, sizeof(dp)) // Preenche a matriz toda com -1\n\nint calc(int digit, int sum) {\n    if (sum \u0026lt; 0) return 0; // soma abaixo do valor\n    if (digit \u003d\u003d 0) return (soma \u003d\u003d 100); // retorna 1 se soma for 100 e 0 caso contrario\n    \n    int\u0026amp; ans \u003d dp[digit][sum];         // Cria uma referencia pro valor\n    if (ans !\u003d -1) return ans;         // Se diferente de -1, ja foi computado\n   \n    ans \u003d 0;\n    for (int d \u003d 0; d \u0026lt;\u003d 9; d++) {\n        ans +\u003d calc(digit-1, sum - d);\n    }\n    return ans;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eCalculando a resposta\u003c/h2\u003e\u003cp\u003eO problema da solução anterior é que temos um limitante superior, mas ele será util daqui para frente. Imagine que o limitante superior é \u003cem\u003e03234\u003c/em\u003e. Para o primeiro dígito, não temos opção, ele só pode ser \u00270\u0027.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e0 _ _ _ _ \n0 3 2 3 4\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ePara o segundo dígito, temos 4 opções no entanto, podemos colocar 0, 1, 2 e 3. Observe que, se colocamos 0, 1 ou 2, todos os outros dígitos podem ser qualquer coisa (perdemos a restrição). A variável \u003cem\u003eans\u003c/em\u003e tem a resposta que queremos. Podemos usar a pd anterior para calcular o que acontece no primeiro caso:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e0 0 x x x \n0 3 2 3 4\nans +\u003d pd[3][100]\n\n0 1 x x x \n0 3 2 3 4\nans +\u003d pd[3][99]\n\n0 2 x x x \n0 3 2 3 4\nans +\u003d pd[3][98]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSe colocamos 3, ficamos preso a restrição entretanto.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e0 3 _ _ _ \n0 3 2 3 4\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ePodemos repetir esse processo iterativamente:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint compute(int bound) {\n    int ans \u003d 0, acum \u003d 100;\n    int n \u003d get_num_digits(bound); // Numero de digitos de bound\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        int limit \u003d get_ith_digit(i, bound);\n        for (int d \u003d 0; d \u0026lt; limit; d++) {\n            ans +\u003d calc(n-i-1, acum - d); // Faltam colocar n-i-1 digitos e a soma acumulado é decrementada\n        }\n        acum -\u003d d;\n    }\n    return ans;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003ePD alternativa\u003c/h2\u003e\u003cp\u003eO método acima pode ser encurtado (e aplicado em mais lugares) da seguinte forma: colocamos um bit a mais na pd para dizer se estamos menores ou não que limitante superior. Lembrando que, se o número atual é menor que o limitante inferior, podemos colocar qualquer coisa nesse valor. Se estamos presos ao limitante inferior, temos a restrição dos números ainda. Começamos presos ao limitante inferior.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint bound;\nint n \u003d get_num_digits(bound);\nint dp[N][100][2];\n\nmemset(dp, -1, sizeof(dp)); // Seta a matriz -1\nint calc(int digit, int sum, int isLess) {\n    if (sum \u0026lt; 0) return 0; // soma abaixo do valor\n    if (digit \u003d\u003d 0) return (soma \u003d\u003d 100); // retorna 1 se soma for 100 e 0 caso contrario\n    \n    int\u0026amp; ans \u003d dp[digit][sum][isLess];         // Cria uma referencia pro valor\n    if (ans !\u003d -1) return ans;         // Se diferente de -1, ja foi computado\n   \n    ans \u003d 0;\n    int limit \u003d get_ith_digit(n-digit, bound); // Limite com base no valor do limitante superior\n    if (isLess) limit \u003d 9;                     // Se estamos fora do limitante, podemos colocar qualquer digito ate 9\n    \n    for (int d \u003d 0; d \u0026lt;\u003d limit; d++) {\n        ans +\u003d calc(digit-1, sum - d, isLess | (d \u0026lt; limit)); // Operacao de \u0026quot;or\u0026quot; entre os bits\n    }\n    return ans;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEssa PD pode ser modificada ainda para inserir um limitante inferior, seguindo a mesma logica anterior, mas agora adicionando uma variavel booleana que indica se o valor atual é maior do que o limitante superior.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint lower_bound, upper_bound;\nint n \u003d get_num_digits(upper_bound);\nint dp[N][100][2][2];\n\nmemset(dp, -1, sizeof(dp)); // Seta a matriz -1\nint calc(int digit, int sum, int isLess, int isMore) {\n    if (sum \u0026lt; 0) return 0; // soma abaixo do valor\n    if (digit \u003d\u003d 0) return (soma \u003d\u003d 100); // retorna 1 se soma for 100 e 0 caso contrario\n    \n    int\u0026amp; ans \u003d dp[digit][sum][isLess][isMore];         // Cria uma referencia pro valor\n    if (ans !\u003d -1) return ans;         // Se diferente de -1, ja foi computado\n   \n    ans \u003d 0;\n    int hi \u003d get_ith_digit(n-digit, upper_bound); // Limite com base no valor do limitante superior\n    int lo \u003d get_ith_digit(n-digit, lower_bound); // Limite com base no valor do limitante inferior\n    \n    if (isLess) hi \u003d 9;        // Se estamos fora do limitante, podemos colocar qualquer digito ate 9\n    if (isMore) lo \u003d 0;        // Se estamos fora do limitante, podemos colocar qualquer digito a partir de 0\n    \n    for (int d \u003d lo; d \u0026lt;\u003d hi; d++) {\n        ans +\u003d calc(digit-1, sum - d, isLess | (d \u0026lt; limit), isMore | (d \u0026gt; limit)); // Operacao de \u0026quot;or\u0026quot; entre os bits\n    }\n    return ans;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eProblemas sugeridos\u003c/h2\u003e\u003cp\u003eEm ordem de dificuldade\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ca href\u003d\"http://www.spoj.com/problems/GONE/\"\u003eGONE\u003c/a\u003e,\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://www.spoj.com/problems/RAONE/\"\u003eRAONE\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://www.spoj.com/problems/LUCIFER/\"\u003eLUCIFER\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://www.spoj.com/problems/NUMTSN/\"\u003eNUMTSN\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://www.spoj.com/problems/LOTGAME/\"\u003eLot Game — Google Code Jam\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://github.com/leaomatheus/ITA-CP/blob/master/Digit%20DP/workchef.cpp\"\u003eWorkchef\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://vjudge.net/problem/LightOJ-1205\"\u003ePalindromic\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"//codeforces.com/gym/100886/problem/G\"\u003eMaximum Product\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e\u003ca href\u003d\"https://github.com/leaomatheus/ITA-CP/tree/master/Digit%20DP\"\u003eSoluções de problemas citados\u003c/a\u003e PS: \u003ca href\u003d\"https://www.urionlinejudge.com.br/judge/pt/problems/view/1138\"\u003eFinal brasileira de 2010\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["digit dp"]}}