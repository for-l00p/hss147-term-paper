{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1522078215,"rating":0,"authorHandle":"Qrort","modificationTimeSeconds":1522078215,"id":58570,"title":"\u003cp\u003eКак хранить взвешенные рёбра? (C++)\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eМожно написать свою структуру:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estruct edge {\n  int to, weight;\n  edge(int p, int q) { //эта штука называется конструктор: она собирает нам edge по p и q\n    to \u003d p;\n    weight \u003d q;\n  }\n};\nvector \u0026lt;edge\u0026gt; g[N]; //давайте в g[v] хранить все рёбра с одним концом в v\n//...\ncin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; weight;\ng[a].push_back(edge(b, weight));\ng[b].push_back(edge(a, weight));\n//...\nedge cur \u003d g[12][14];\ncout \u0026lt;\u0026lt; cur.to \u0026lt;\u0026lt; cur.weight; //обращаться вот так\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eА можно просто хранить пары:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector \u0026lt;pair \u0026lt;int, int\u0026gt;\u0026gt; g[N];\n//...\ncin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; weight;\ng[a].push_back(make_pair(b, weight)); //можно так\ng[b].push_back({a, weight}); //а можно так, если у вас компилятор версии c++11 или позднее\n//...\npair \u0026lt;int, int\u0026gt; cur \u003d g[3][22];\ncout \u0026lt;\u0026lt; cur.first \u0026lt;\u0026lt; cur.second; //обращаться вот так\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}