{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1460635899,"rating":68,"authorHandle":"Arpa","modificationTimeSeconds":1528970611,"id":44351,"title":"\u003cp\u003e[Tutorial] Sack (dsu on tree)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eChanges are available in history section.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eHi!\u003c/p\u003e\u003cp\u003eMost of the people know about dsu but what is the \u0026quot;dsu on tree\u0026quot;?\u003c/p\u003e\u003cp\u003eIn Iran, we call this technique \u0026quot;Guni\u0026quot; (the word means \u0026quot;sack\u0026quot; in English), instead of \u0026quot;dsu on tree\u0026quot;.\u003c/p\u003e\u003cp\u003eI will explain it and post ends with several problems in CF that can be solved by this technique.\u003c/p\u003e\u003ch1\u003eWhat is the dsu on tree?\u003c/h1\u003e\u003cp\u003eWith dsu on tree we can answer queries of this type:\u003c/p\u003e\u003cp\u003eHow many vertices in the subtree of vertex \u003ccode\u003ev\u003c/code\u003e has some property in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/92/33/9233e5a9ea86381add3ad78777a93e32e45fa5b8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time (for all of the queries)?\u003c/p\u003e\u003cp\u003eFor example:\u003c/p\u003e\u003cp\u003eGiven a tree, every vertex has color. Query is \u003cstrong\u003ehow many vertices in subtree of vertex \u003ccode\u003ev\u003c/code\u003e are colored with color \u003ccode\u003ec\u003c/code\u003e?\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s see how we can solve this problem and similar problems.\u003c/p\u003e\u003cp\u003eFirst, we have to calculate the size of the subtree of every vertice. It can be done with simple dfs:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint sz[maxn];\nvoid getsz(int v, int p){\n    sz[v] \u003d 1;  // every vertex has itself in its subtree\n    for(auto u : g[v])\n        if(u !\u003d p){\n            getsz(u, v);\n            sz[v] +\u003d sz[u]; // add size of child u to its parent(v)\n        }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow we have the size of the subtree of vertex \u003ccode\u003ev\u003c/code\u003e in \u003ccode\u003esz[v]\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eThe naive method for solving that problem is this code(that works in O(N ^ 2) time)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint cnt[maxn];\nvoid add(int v, int p, int x){\n    cnt[ col[v] ] +\u003d x;\n    for(auto u: g[v])\n        if(u !\u003d p)\n            add(u, v, x)\n}\nvoid dfs(int v, int p){\n    add(v, p, 1);\n    //now cnt[c] is the number of vertices in subtree of vertex v that has color c. You can answer the queries easily.\n    add(v, p, -1);\n    for(auto u : g[v])\n        if(u !\u003d p)\n            dfs(u, v);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow, how to improve it? There are several styles of coding for this technique.\u003c/p\u003e\u003ch3\u003e1. easy to code but \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ca/4c/ca4c38da7d143fc87534d50aa6d551dd861caae9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/h3\u003e \u003cpre\u003e\u003ccode\u003emap\u0026lt;int, int\u0026gt; *cnt[maxn];\nvoid dfs(int v, int p){\n    int mx \u003d -1, bigChild \u003d -1;\n    for(auto u : g[v])\n       if(u !\u003d p){\n           dfs(u, v);\n           if(sz[u] \u0026gt; mx)\n               mx \u003d sz[u], bigChild \u003d u;\n       }\n    if(bigChild !\u003d -1)\n        cnt[v] \u003d cnt[bigChild];\n    else\n        cnt[v] \u003d new map\u0026lt;int, int\u0026gt; ();\n    (*cnt[v])[ col[v] ] ++;\n    for(auto u : g[v])\n       if(u !\u003d p \u0026amp;\u0026amp; u !\u003d bigChild){\n           for(auto x : *cnt[u])\n               (*cnt[v])[x.first] +\u003d x.second;\n       }\n    //now (*cnt[v])[c] is the number of vertices in subtree of vertex v that has color c. You can answer the queries easily.\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e2. easy to code and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/h3\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;int\u0026gt; *vec[maxn];\nint cnt[maxn];\nvoid dfs(int v, int p, bool keep){\n    int mx \u003d -1, bigChild \u003d -1;\n    for(auto u : g[v])\n       if(u !\u003d p \u0026amp;\u0026amp; sz[u] \u0026gt; mx)\n           mx \u003d sz[u], bigChild \u003d u;\n    for(auto u : g[v])\n       if(u !\u003d p \u0026amp;\u0026amp; u !\u003d bigChild)\n           dfs(u, v, 0);\n    if(bigChild !\u003d -1)\n        dfs(bigChild, v, 1), vec[v] \u003d vec[bigChild];\n    else\n        vec[v] \u003d new vector\u0026lt;int\u0026gt; ();\n    vec[v]-\u0026gt;push_back(v);\n    cnt[ col[v] ]++;\n    for(auto u : g[v])\n       if(u !\u003d p \u0026amp;\u0026amp; u !\u003d bigChild)\n           for(auto x : *vec[u]){\n               cnt[ col[x] ]++;\n               vec[v] -\u0026gt; push_back(x);\n           }\n    //now (*cnt[v])[c] is the number of vertices in subtree of vertex v that has color c. You can answer the queries easily.\n    // note that in this step *vec[v] contains all of the subtree of vertex v.\n    if(keep \u003d\u003d 0)\n        for(auto u : *vec[v])\n            cnt[ col[u] ]--;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e3. heavy-light decomposition style \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/h3\u003e \u003cpre\u003e\u003ccode\u003eint cnt[maxn];\nbool big[maxn];\nvoid add(int v, int p, int x){\n    cnt[ col[v] ] +\u003d x;\n    for(auto u: g[v])\n        if(u !\u003d p \u0026amp;\u0026amp; !big[u])\n            add(u, v, x)\n}\nvoid dfs(int v, int p, bool keep){\n    int mx \u003d -1, bigChild \u003d -1;\n    for(auto u : g[v])\n       if(u !\u003d p \u0026amp;\u0026amp; sz[u] \u0026gt; mx)\n          mx \u003d sz[u], bigChild \u003d u;\n    for(auto u : g[v])\n        if(u !\u003d p \u0026amp;\u0026amp; u !\u003d bigChild)\n            dfs(u, v, 0);  // run a dfs on small childs and clear them from cnt\n    if(bigChild !\u003d -1)\n        dfs(bigChild, v, 1), big[bigChild] \u003d 1;  // bigChild marked as big and not cleared from cnt\n    add(v, p, 1);\n    //now cnt[c] is the number of vertices in subtree of vertex v that has color c. You can answer the queries easily.\n    if(bigChild !\u003d -1)\n        big[bigChild] \u003d 0;\n    if(keep \u003d\u003d 0)\n        add(v, p, -1);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e4. My invented style \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/h3\u003e\u003cp\u003eThis implementation for \u0026quot;Dsu on tree\u0026quot; technique is new and invented by me. This implementation is easier to code than others. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003est\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e dfs starting time of vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eft\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e be it\u0027s finishing time and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ever\u003c/i\u003e[\u003ci\u003etime\u003c/i\u003e]\u003c/span\u003e is the vertex which it\u0027s starting time is equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etime\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint cnt[maxn];\nvoid dfs(int v, int p, bool keep){\n    int mx \u003d -1, bigChild \u003d -1;\n    for(auto u : g[v])\n       if(u !\u003d p \u0026amp;\u0026amp; sz[u] \u0026gt; mx)\n          mx \u003d sz[u], bigChild \u003d u;\n    for(auto u : g[v])\n        if(u !\u003d p \u0026amp;\u0026amp; u !\u003d bigChild)\n            dfs(u, v, 0);  // run a dfs on small childs and clear them from cnt\n    if(bigChild !\u003d -1)\n        dfs(bigChild, v, 1);  // bigChild marked as big and not cleared from cnt\n    for(auto u : g[v])\n\tif(u !\u003d p \u0026amp;\u0026amp; u !\u003d bigChild)\n\t    for(int p \u003d st[u]; p \u0026lt; ft[u]; p++)\n\t\tcnt[ col[ ver[p] ] ]++;\n    cnt[ col[v] ]++;\n    //now cnt[c] is the number of vertices in subtree of vertex v that has color c. You can answer the queries easily.\n    if(keep \u003d\u003d 0)\n        for(int p \u003d st[v]; p \u0026lt; ft[v]; p++)\n\t    cnt[ col[ ver[p] ] ]--;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut why it is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e? You know that why dsu has \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0f/23/0f239d055af9bea3474df8b031eb77f1e3db2398.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time (for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e queries); the code uses the same method. Merge smaller to greater.\u003c/p\u003e\u003cp\u003eIf you have heard \u003ccode\u003eheavy-light decomposition\u003c/code\u003e you will see that function \u003ccode\u003eadd\u003c/code\u003e will go light edges only, because of this, code works in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time.\u003c/p\u003e\u003cp\u003eAny problems of this type can be solved with same \u003ccode\u003edfs\u003c/code\u003e function and just differs in \u003ccode\u003eadd\u003c/code\u003e function.\u003c/p\u003e\u003cp\u003eHmmm, this is what you want, problems that can be solved with this technique:\u003c/p\u003e\u003cp\u003e(List is sorted by difficulty and my code for each problem is given, my codes has \u003ccode\u003eheavy-light\u003c/code\u003e style)\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/600/problem/E\" title\u003d\"Educational Codeforces Round 2\"\u003e600E - Lomsat gelral\u003c/a\u003e : \u003ccode\u003eheavy-light decomposition\u003c/code\u003e style : \u003ca href\u003d\"https://paste.ubuntu.com/p/z7792STp56/\"\u003eLink\u003c/a\u003e, easy style : \u003ca href\u003d\"https://paste.ubuntu.com/p/7VRXTsTjdv/\"\u003eLink\u003c/a\u003e. I think this is the easiest problem of this technique in CF and it\u0027s good to start coding with this problem.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/570/problem/D\" title\u003d\"Codeforces Round 316 (Div. 2)\"\u003e570D - Tree Requests\u003c/a\u003e : \u003ca href\u003d\"/contest/570/submission/17961189\" title\u003d\"Submission 17961189 by Arpa\"\u003e17961189\u003c/a\u003e Thanks to \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Sorasorasora\" title\u003d\"Expert Sorasorasora\"\u003eSorasorasora\u003c/a\u003e; this problem is also good for start coding.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://acm.sgu.ru/problem.php?contest\u003d0\u0026amp;problem\u003d507\"\u003eSgu507\u003c/a\u003e (SGU is unavailable, read the problem statements \u003ca href\u003d\"https://vjudge.net/problem/SGU-507\"\u003ehere\u003c/a\u003e) This problem is also good for the start.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://www.hackerearth.com/practice/algorithms/graphs/depth-first-search/practice-problems/algorithm/the-grass-type/\"\u003eHackerEarth, The Grass Type\u003c/a\u003e This problem is also good for start (See \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/bhishma\" title\u003d\"Specialist bhishma\"\u003ebhishma\u003c/a\u003e\u0027s comment \u003ca href\u003d\"#comment-332421\"\u003ebelow\u003c/a\u003e).\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/246/problem/E\" title\u003d\"Codeforces Round 151 (Div. 2)\"\u003e246E - Blood Cousins Return\u003c/a\u003e : \u003ca href\u003d\"/contest/246/submission/15409328\" title\u003d\"Submission 15409328 by Arpa\"\u003e15409328\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/208/problem/E\" title\u003d\"Codeforces Round 130 (Div. 2)\"\u003e208E - Blood Cousins\u003c/a\u003e : \u003ca href\u003d\"/contest/208/submission/16897324\" title\u003d\"Submission 16897324 by Arpa\"\u003e16897324\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://www.ioinformatics.org/locations/ioi11/contest/\"\u003eIOI 2011, Race\u003c/a\u003e (See \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/SaSaSaS\" title\u003d\"Candidate Master SaSaSaS\"\u003eSaSaSaS\u003c/a\u003e\u0027s comment \u003ca href\u003d\"#comment-332425\"\u003ebelow\u003c/a\u003e).\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/291/problem/E\" title\u003d\"Croc Champ 2013 - Qualification Round\"\u003e291E - Tree-String Problem\u003c/a\u003e : See \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/bhargav104\" title\u003d\"Expert bhargav104\"\u003ebhargav104\u003c/a\u003e\u0027s comment \u003ca href\u003d\"#comment-316011\"\u003ebelow\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/343/problem/D\" title\u003d\"Codeforces Round 200 (Div. 1)\"\u003e343D - Water Tree\u003c/a\u003e : \u003ca href\u003d\"/contest/343/submission/15063078\" title\u003d\"Submission 15063078 by Arpa\"\u003e15063078\u003c/a\u003e Note that problem is not easy and my code doesn\u0027t use this technique (dsu on tree), but \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/AmirAz\" title\u003d\"Candidate Master AmirAz\"\u003eAmirAz\u003c/a\u003e \u0027s solution to this problem uses this technique : \u003ca href\u003d\"/contest/343/submission/14904379\" title\u003d\"Submission 14904379 by AmirAz\"\u003e14904379\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/375/problem/D\" title\u003d\"Codeforces Round 221 (Div. 1)\"\u003e375D - Tree and Queries\u003c/a\u003e : \u003ca href\u003d\"/contest/375/submission/15449102\" title\u003d\"Submission 15449102 by Arpa\"\u003e15449102\u003c/a\u003e Again note that problem is not easy :)).\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/716/problem/E\" title\u003d\"Codeforces Round 372 (Div. 2)\"\u003e716E - Digit Tree\u003c/a\u003e : \u003ca href\u003d\"/contest/716/submission/20776957\"\u003e20776957\u003c/a\u003e A hard problem. Also can be solved with centroid decomposition.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/741/problem/D\" title\u003d\"Codeforces Round 383 (Div. 1)\"\u003e741D - Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths\u003c/a\u003e : \u003ca href\u003d\"/contest/741/submission/22796438\" title\u003d\"Submission 22796438 by Arpa\"\u003e22796438\u003c/a\u003e A hard problem. You must be very familiar with Dsu on tree to solve it.\u003c/p\u003e\u003cp\u003eFor Persian users, there is another problem in Shaazzz contest round #4 (season 2016-2017) problem 3 that is a very hard problem with this technique.\u003c/p\u003e\u003cp\u003eIf you have another problem with this tag, give me to complete the list :)).\u003c/p\u003e\u003cp\u003eAnd after all, special thanks from \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/amd\" title\u003d\"Grandmaster amd\"\u003eamd\u003c/a\u003e who taught me this technique.\u003c/p\u003e\u003c/div\u003e","tags":["dsu on tree","sack","guni"]}}