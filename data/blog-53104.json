{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1499181626,"rating":-3,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1499182014,"id":53104,"title":"\u003cp\u003eNotes on Codeforces Beta Round #58, A, B(Index-based Binary Search, Pseudocodes)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA. A Student\u0027s Dream\u003c/p\u003e\u003cp\u003eWe use Gn and Bn to denote the number of fingers of hands, which the girl and boy hold, respectively. According to the problem, Bn\u0026gt;\u003dGn-1 should hold, since otherwise at least two fingers of the girl will touch. Moreover, Bn\u0026lt;\u003d2*(Gn+1) should hold as well, since otherwise at least three fingers of the boy will touch.\u003c/p\u003e\u003cp\u003eB. Tyndex.Brome\u003c/p\u003e\u003cp\u003eWe first deal with the address entered by the user. As only lowercase letters are involved, we can adopt 26 arrays and use each of them to store all the positions at which the corresponding letter has appeared in the entered address, and sort the positions in an increasing order. Then, we calculate the value of the error function for each potential address. As the problem requires, for each letter at position j in some potential address, we try to find the closest position at which the same letter appears in the entered address. To find this, we can implement index-based binary search on the previously stored array H[n], and find the position i such that H[i]\u003d\u0026lt;j\u0026lt;H[i+1]. Thus, min(j-H[i],H[i+1]-j) is just the value of error function for the current letter.\u003c/p\u003e\u003cp\u003eIn fact, I find it more difficult than I thought to write a correct index-based binary search... Therefore, I give some of the details that I think are quite important.\u003c/p\u003e\u003cp\u003eSuppose that a[0],a[1],...,a[n-1] have been sorted in an increasing order, and T is the \u0026quot;target\u0026quot;. The following index-based binary search will find the largest a[num_L] such that a[num_L]\u0026lt;\u003dT\u0026lt;a[num_L+1] (assuming that num_L+1 is reasonable, i.e., num_L+1\u0026lt;\u003dn-1). The comments have been added in the corresponding places.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint num_L\u003d0;  // num_L denotes the left border, and one should guarantee that a[0]\u0026lt;\u003dT, which can be tested in advance;  if a[0]\u0026gt;T, it is even not necessary to implement such a binary search;\nint num_R\u003dn-1; // num_R denotes the right border, and one should guarantee that it is initialized so that the whole range can be covered\nwhile (num_L\u0026lt;num_R)  // note that the termination condition is num_L\u0026lt;num_R but not num_L\u0026lt;\u003dnum_R, while the latter one might lead to an infinite loop\n{\n\tint num_M\u003d(num_L+num_R+1)/2;  // num_M denotes the middle point which we are going to check, and note that using (num_L+num_R)/2 might lead to an infinite loop as well\n\tif (a[num_M]\u0026gt;T)  // this is not a[num_M]\u0026gt;\u003dT, since we are to find a[num_L]\u0026lt;\u003dT rather than a[num_L]\u0026lt;T\n\t{\n\t\tnum_R\u003dnum_M-1;  // update the right border as num_M-1 for the next loop; note that here is not num_R\u003dnum_M, since num_M has been checked and it can definitely not satisfy a[num_M]\u0026lt;\u003dT in the current loop\n\t}\n\telse\n\t{\n\t\tnum_L\u003dnum_M;  //update the left border as num_M for the next loop; note that this is not num_M+1, since we can only guarantee that num_M is safe for the next loop as a[num_M]\u0026lt;\u003dT holds in the current loop\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOne can check that, when the loop terminates, num_L will always satisfy that a[num_L]\u0026lt;\u003dT\u0026lt;a[num_L+1].\u003c/p\u003e\u003c/div\u003e","tags":[]}}