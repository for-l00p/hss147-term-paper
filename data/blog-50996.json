{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1489599708,"rating":186,"authorHandle":"gepardo","modificationTimeSeconds":1489604013,"id":50996,"title":"\u003cp\u003eCodeforces Round #404. Editorial.\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThis is an editorial for the problems of the today\u0027s contest. I tried my best to describe the solutions for the problems as detailed as possible, but if something is not understandable for you, you can write in comments! :)\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/785/problem/A\" title\u003d\"Codeforces Round 404 (Div. 2)\"\u003e785A - Anton and Polyhedrons\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003e404 Not Found\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"785A\"\u003eTutorial is loading...\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;map\u0026gt;\n\nusing namespace std;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tmap\u0026lt;string, int\u0026gt; vals;\n\tvals[\u0026quot;Tetrahedron\u0026quot;]  \u003d 4;\n\tvals[\u0026quot;Cube\u0026quot;]         \u003d 6;\n\tvals[\u0026quot;Octahedron\u0026quot;]   \u003d 8;\n\tvals[\u0026quot;Dodecahedron\u0026quot;] \u003d 12;\n\tvals[\u0026quot;Icosahedron\u0026quot;]  \u003d 20;\n\tint n; cin \u0026gt;\u0026gt; n;\n\tint res \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\tstring s; cin \u0026gt;\u0026gt; s;\n\t\tres +\u003d vals[s];\n\t}\n\tcout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eJava code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.*;\nimport java.util.*;\n\npublic class PolyhedronSums {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader reader \u003d new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter writer \u003d new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tHashMap\u0026lt;String, Integer\u0026gt; vals \u003d new HashMap\u0026lt;String, Integer\u0026gt;();\n\t\tvals.put(\u0026quot;Tetrahedron\u0026quot;, 4);\n\t\tvals.put(\u0026quot;Cube\u0026quot;, 6);\n\t\tvals.put(\u0026quot;Octahedron\u0026quot;, 8);\n\t\tvals.put(\u0026quot;Dodecahedron\u0026quot;, 12);\n\t\tvals.put(\u0026quot;Icosahedron\u0026quot;, 20);\n\t\tint n \u003d Integer.parseInt(reader.readLine());\n\t\tint res \u003d 0;\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\t\tres +\u003d vals.get(reader.readLine());\n\t\t}\t\n\t\twriter.write(Integer.toString(res));\n\t\treader.close();\n\t\twriter.close();\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ePython code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003evals \u003d {\n\t\u0027Tetrahedron\u0027: 4,\n\t\u0027Cube\u0027: 6,\n\t\u0027Octahedron\u0027: 8,\n\t\u0027Dodecahedron\u0027: 12,\n\t\u0027Icosahedron\u0027: 20\n}\n\nn \u003d int(input())\nans \u003d 0\nfor i in range(0, n):\n\tans +\u003d vals[input()]\nprint(ans)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/785/problem/B\" title\u003d\"Codeforces Round 404 (Div. 2)\"\u003e785B - Anton and Classes\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThink of what periods to take if Anton attends chess classes earlier than programming classes and vice versa.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"785B\"\u003eTutorial is loading...\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n\nconst int infinity \u003d 1234567890;\n\nusing namespace std;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tint n; cin \u0026gt;\u0026gt; n;\n\tvector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; a(n);\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\tcin \u0026gt;\u0026gt; a[i].first \u0026gt;\u0026gt; a[i].second;\n\t}\n\tint m; cin \u0026gt;\u0026gt; m;\n\tvector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; b(m);\n\tfor (int i \u003d 0; i \u0026lt; m; i++) {\n\t\tcin \u0026gt;\u0026gt; b[i].first \u0026gt;\u0026gt; b[i].second;\n\t}\n\tint minR1 \u003d infinity, maxL1 \u003d -infinity;\n\tint minR2 \u003d infinity, maxL2 \u003d -infinity;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\tmaxL1 \u003d max(maxL1, a[i].first);\n\t\tminR1 \u003d min(minR1, a[i].second);\t\n\t}\n\tfor (int i \u003d 0; i \u0026lt; m; i++) {\n\t\tmaxL2 \u003d max(maxL2, b[i].first);\n\t\tminR2 \u003d min(minR2, b[i].second);\t\n\t}\n\tint res \u003d max(maxL2 - minR1, maxL1 - minR2);\n\tcout \u0026lt;\u0026lt; max(res, 0) \u0026lt;\u0026lt; endl;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eJava code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.*;\nimport java.util.*;\n\npublic class TwoSegments {\n\tpublic static final int infinity \u003d 1234567890;\n\t\n\tpublic static class Segment {\n\t\tpublic int l;\n\t\tpublic int r;\n\n\t\tpublic Segment(int aL, int aR) {\n\t\t\tl \u003d aL;\n\t\t\tr \u003d aR;\n\t\t} \n\t}\n\t\n\tprivate static Segment[] readList(BufferedReader reader) throws Exception {\n\t\tint n \u003d Integer.parseInt(reader.readLine());\n\t\tSegment[] res \u003d new Segment[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\t\tStringTokenizer tokenizer \u003d new StringTokenizer(reader.readLine());\t\t\n\t\t\tint l \u003d Integer.parseInt(tokenizer.nextToken());\n\t\t\tint r \u003d Integer.parseInt(tokenizer.nextToken());\n\t\t\tres[i] \u003d new Segment(l, r);\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader reader \u003d new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter writer \u003d new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tSegment[] a \u003d readList(reader);\n\t\tSegment[] b \u003d readList(reader);\n\t\tint minR1 \u003d infinity, maxL1 \u003d -infinity;\n\t\tint minR2 \u003d infinity, maxL2 \u003d -infinity;\n\t\tfor (int i \u003d 0; i \u0026lt; a.length; i++) {\n\t\t\tmaxL1 \u003d Math.max(maxL1, a[i].l);\n\t\t\tminR1 \u003d Math.min(minR1, a[i].r);\t\n\t\t}\n\t\tfor (int i \u003d 0; i \u0026lt; b.length; i++) {\n\t\t\tmaxL2 \u003d Math.max(maxL2, b[i].l);\n\t\t\tminR2 \u003d Math.min(minR2, b[i].r);\t\n\t\t}\n\t\tint res \u003d Math.max(maxL2 - minR1, maxL1 - minR2);\n\t\twriter.write(Integer.toString(Math.max(res, 0)));\n\t\treader.close();\n\t\twriter.close();\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ePython code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003einfinity \u003d 1234567890\nminR1 \u003d minR2 \u003d infinity\nmaxL1 \u003d maxL2 \u003d -infinity\nn \u003d int(input())\nfor i in range(0, n):\n\t(l, r) \u003d map(int, input().split())\n\tmaxL1 \u003d max(maxL1, l)\n\tminR1 \u003d min(minR1, r)\nm \u003d int(input())\nfor i in range(0, m):\n\t(l, r) \u003d map(int, input().split())\n\tmaxL2 \u003d max(maxL2, l)\n\tminR2 \u003d min(minR2, r)\nres \u003d max(maxL2 - minR1, maxL1 - minR2);\nprint(max(res, 0))\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/785/problem/C\" title\u003d\"Codeforces Round 404 (Div. 2)\"\u003e785C - Anton and Fairy Tale\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis problem had weak pretests. It was made intentionally to cause more hacks. And I have warned you about it in the announcement :)\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eModel the process to determine how the number of corns in the barn changes.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"785C\"\u003eTutorial is loading...\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstdint\u0026gt;\n\nusing namespace std;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tint64_t n, m;\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tif (n \u0026lt;\u003d m) {\n\t\tcout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl;\n\t} else {\n\t\tn -\u003d m;\n\t\tint64_t l \u003d 0, r \u003d 2e9;\n\t\twhile (l \u0026lt; r) {\n\t\t\tint64_t m \u003d (l + r) / 2;\n\t\t\tint64_t val \u003d m * (m+1) / 2;\n\t\t\tif (val \u0026gt;\u003d n) {\n\t\t\t\tr \u003d m;\n\t\t\t} else {\n\t\t\t\tl \u003d m+1;\n\t\t\t}\n\t\t}\n\t\tcout \u0026lt;\u0026lt; l + m \u0026lt;\u0026lt; endl;\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eJava code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.*;\nimport java.util.*;\n\npublic class SparrowsJava {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader reader \u003d new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter writer \u003d new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tStringTokenizer tokenizer \u003d new StringTokenizer(reader.readLine());\n\t\tlong n \u003d Long.parseLong(tokenizer.nextToken());\n\t\tlong m \u003d Long.parseLong(tokenizer.nextToken());\t\n\t\tif (n \u0026lt;\u003d m) {\n\t\t\twriter.write(Long.toString(n));\n\t\t} else {\n\t\t\tn -\u003d m;\n\t\t\tlong l \u003d 0, r \u003d (long)2e9;\n\t\t\twhile (l \u0026lt; r) {\n\t\t\t\tlong med \u003d (l + r) / 2;\n\t\t\t\tlong val \u003d med * (med+1) / 2;\n\t\t\t\tif (val \u0026gt;\u003d n) {\n\t\t\t\t\tr \u003d med;\n\t\t\t\t} else {\n\t\t\t\t\tl \u003d med+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\twriter.write(Long.toString(l + m));\n\t\t}\n\t\treader.close();\n\t\twriter.close();\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ePython code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e(n, m) \u003d map(int, input().split())\nif n \u0026lt;\u003d m:\n\tprint(n)\nelse:\n\taM \u003d m\n\tn -\u003d m\n\t(l, r) \u003d (0, int(2e9))\n\twhile l \u0026lt; r:\n\t\tm \u003d (l + r) // 2;\n\t\tval \u003d m * (m+1) // 2;\n\t\tif val \u0026gt;\u003d n:\n\t\t\tr \u003d m\n\t\telse:\n\t\t\tl \u003d m+1\n\tprint(l + aM)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/785/problem/D\" title\u003d\"Codeforces Round 404 (Div. 2)\"\u003e785D - Anton and School - 2\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eSolve a simplified version of the problem. Let our sequence first contains \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e opening brackets and then contains \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e closing brackets, and the last opening bracket must necessarily appear in our RSBS. Use a naive solution to see how the answer looks. Think what to do next.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"785D\"\u003eTutorial is loading...\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;cstdint\u0026gt;\n\nusing namespace std;\n\nint mod \u003d (int)1e9 + 7;\n\nint64_t extGcd(int64_t a, int64_t b, int64_t\u0026amp; x, int64_t\u0026amp; y) { \n\tif (!a) {\n\t\tx \u003d 0;\n\t\ty \u003d 1;\n\t\treturn b;\n\t}\n\tint64_t x1, y1;\n\tint64_t d \u003d extGcd(b % a, a, x1, y1);\n\tx \u003d y1 - (b / a) * x1;\n\ty \u003d x1;\n\treturn d;\n}\n\ninline int addMod(int a, int b, int m \u003d mod) {\n\treturn ((int64_t)a + b) % m;\n}\n\ninline int mulMod(int a, int b, int m \u003d mod) {\n\treturn ((int64_t)a * b) % m;\n}\n\ninline int divMod(int a, int b, int m \u003d mod) {\n\tint64_t x, y;\n\tint64_t g \u003d extGcd(b, m, x, y);\n\tif (g !\u003d 1) {\n\t\tcerr \u0026lt;\u0026lt; \u0026quot;Bad gcd!\u0026quot; \u0026lt;\u0026lt; endl;\n\t\tfor (;;);\n\t}\n\tx \u003d (x % m + m) % m;\n\treturn mulMod(a, x, m);\n}\n\nconst int factRange \u003d 1000000;\nint fact[factRange];\n\ninline void precalcFactorials() {\n\tfact[0] \u003d 1;\n\tfor (int i \u003d 1; i \u0026lt; factRange; i++) {\n\t\tfact[i] \u003d mulMod(fact[i-1], i);\n\t}\n}\n\ninline int F(int n) {\n\treturn (n \u0026lt; 0) ? 0 : fact[n];\n}\n\ninline int C(int k, int n) {\n\treturn divMod(F(n), mulMod(F(n-k), F(k)));\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tstring s; \n\tcin \u0026gt;\u0026gt; s;\n\tint len \u003d s.size();\n\tprecalcFactorials();\n\tvector\u0026lt;int\u0026gt; opnLeft(len), clsRight(len);\n\topnLeft[0] \u003d (s[0] \u003d\u003d \u0027(\u0027) ? 1 : 0;\n\tfor (int i \u003d 1; i \u0026lt; len; i++) {\n\t\topnLeft[i] \u003d opnLeft[i-1] + ((s[i] \u003d\u003d \u0027(\u0027) ? 1 : 0);\n\t}\n\tclsRight[len-1] \u003d (s[len-1] \u003d\u003d \u0027)\u0027) ? 1 : 0;\n\tfor (int i \u003d len-2; i \u0026gt;\u003d 0; i--) {\n\t\tclsRight[i] \u003d clsRight[i+1] + ((s[i] \u003d\u003d \u0027)\u0027) ? 1 : 0);\n\t}\n\tint res \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; len; i++) {\n\t\tif (s[i] !\u003d \u0027(\u0027 || clsRight[i] \u003d\u003d 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tint add \u003d C(opnLeft[i], opnLeft[i] + clsRight[i] - 1);\n\t\tres \u003d addMod(res, add);\n\t}\n\tcout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eJava code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.*;\nimport java.util.*;\n\npublic class BracketsJava {\n\tpublic static int mod \u003d (int)1e9 + 7;\n\t\n\tpublic static class ExtGcdResult {\n\t\tlong x;\n\t\tlong y;\n\t}\n\t\n\tpublic static long extGcd(long a, long b, ExtGcdResult res) { \n\t\tif (a \u003d\u003d 0) {\n\t\t\tres.x \u003d 0L;\n\t\t\tres.y \u003d 1L;\n\t\t\treturn b;\n\t\t}\n\t\tExtGcdResult newRes \u003d new ExtGcdResult();\n\t\tlong d \u003d extGcd(b % a, a, newRes); \n\t\tres.x \u003d newRes.y - (b / a) * newRes.x;\n\t\tres.y \u003d newRes.x;\n\t\treturn d; \n\t}\n\t\n\tpublic static final int addMod(int a, int b) { \n\t\treturn (int)(((long)a + b) % mod); \n\t}\n\n\tpublic static final int mulMod(int a, int b) { \n\t\treturn (int)(((long)a * b) % mod); \n\t}\n\t\n\tpublic static final int divMod(int a, int b) { \n\t\tExtGcdResult res \u003d new ExtGcdResult();\n\t\tlong g \u003d extGcd(b, mod, res); \n\t\tif (g !\u003d 1) {\n\t\t\tSystem.out.println(\u0026quot;Bad gcd!\u0026quot;);\n\t\t\tfor (;;);\n\t\t}\n\t\tint q \u003d (int)((res.x % mod + mod) % mod); \n\t\treturn mulMod(a, q); \n\t}\n\t\n\tpublic static final int[] precalcFactorials() {\n\t\tint[] fact \u003d new int[factRange];\n\t\tfact[0] \u003d 1;\n\t\tfor (int i \u003d 1; i \u0026lt; factRange; i++) {\n\t\t\tfact[i] \u003d mulMod(fact[i-1], i);\n\t\t}\n\t\treturn fact;\n\t}\n\n\tpublic static final int factRange \u003d 1000000;\n\tpublic static final int[] fact \u003d precalcFactorials();\n\t\n\tpublic static final int F(int n) {\n\t\treturn (n \u0026lt; 0) ? 0 : fact[n];\n\t}\n\t\n\tpublic static final int C(int k, int n) {\n\t\tint res \u003d divMod(F(n), mulMod(F(n-k), F(k)));\n\t\treturn divMod(F(n), mulMod(F(n-k), F(k)));\n\t} \n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader reader \u003d new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter writer \u003d new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tString s \u003d reader.readLine();\n\t\tint len \u003d s.length();\n\t\tint[] opnLeft \u003d new int[len], clsRight \u003d new int[len];\n\t\topnLeft[0] \u003d (s.charAt(0) \u003d\u003d \u0027(\u0027) ? 1 : 0;\n\t\tfor (int i \u003d 1; i \u0026lt; len; i++) {\n\t\t\topnLeft[i] \u003d opnLeft[i-1] + ((s.charAt(i) \u003d\u003d \u0027(\u0027) ? 1 : 0);\n\t\t}\n\t\tclsRight[len-1] \u003d (s.charAt(len-1) \u003d\u003d \u0027)\u0027) ? 1 : 0;\n\t\tfor (int i \u003d len-2; i \u0026gt;\u003d 0; i--) {\n\t\t\tclsRight[i] \u003d clsRight[i+1] + ((s.charAt(i) \u003d\u003d \u0027)\u0027) ? 1 : 0);\n\t\t}\n\t\tint res \u003d 0;\n\t\tfor (int i \u003d 0; i \u0026lt; len; i++) {\n\t\t\tif (s.charAt(i) !\u003d \u0027(\u0027 || clsRight[i] \u003d\u003d 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint add \u003d C(opnLeft[i], opnLeft[i] + clsRight[i] - 1);\n\t\t\tres \u003d addMod(res, add);\n\t\t}\t\t\n\t\twriter.write(Integer.toString(res));\n\t\treader.close();\n\t\twriter.close();\t\t\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/785/problem/E\" title\u003d\"Codeforces Round 404 (Div. 2)\"\u003e785E - Anton and Permutation\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI\u0027m sorry that this problem was not original. I will try my best to prevent this from happening again.\u003c/p\u003e\u003cp\u003eIf you have TL or ML in this problem, don\u0027t think that the time/memory limits are too strict. The model solution works in 1.2 seconds and consumes 9 MB memory.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eDivide all the queries in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/db/32db1127ebe513f1f747c2fc33bc4f0a6c619cc5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e blocks. Then divide the positions to the mobile (those ones that will change in this block) and immoblile. Think what to do next.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"785E\"\u003eTutorial is loading...\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e// Thanks to netman for the idea for this wonderful solution :)\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;cstdint\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n\nusing namespace std;\n\nclass SQRTDecomposition {\n\tprivate:\n\t\tint n, sz;\n\t\tvector\u0026lt;int\u0026gt; val;\n\t\tvector\u0026lt;int\u0026gt; blocks;\n\tpublic:\n\t\tinline void add(int v, int delta) {\n\t\t\tval[v] +\u003d delta;\n\t\t\tblocks[v / sz] +\u003d delta;\n\t\t}\n\t\t\n\t\tinline int sum(int l, int r) {\t\n\t\t\tif (l \u0026lt; 0) {\n\t\t\t\tl \u003d 0;\n\t\t\t}\n\t\t\tif (r \u0026gt;\u003d n) {\n\t\t\t\tr \u003d n;\n\t\t\t}\n\t\t\tr++;\n\t\t\tint res \u003d 0;\n\t\t\tint lBlock \u003d (l + sz - 1) / sz, rBlock \u003d r / sz;\n\t\t\tfor (int i \u003d lBlock; i \u0026lt; rBlock; i++) {\n\t\t\t\tres +\u003d blocks[i];\n\t\t\t}\n\t\t\tint lBlockR \u003d lBlock * sz, rBlockR \u003d rBlock * sz;\n\t\t\tif (lBlockR \u0026gt;\u003d rBlockR) {\n\t\t\t\tfor (int i \u003d l; i \u0026lt; r; i++) {\n\t\t\t\t\tres +\u003d val[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i \u003d l; i \u0026lt; lBlockR; i++) {\n\t\t\t\t\tres +\u003d val[i];\n\t\t\t\t}\n\t\t\t\tfor (int i \u003d rBlockR; i \u0026lt; r; i++) {\n\t\t\t\t\tres +\u003d val[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tinline void clear() {\n\t\t\tval.assign(val.size(), 0);\n\t\t\tblocks.assign(blocks.size(), 0);\n\t\t}\n\t\t\n\t\tSQRTDecomposition(int n, int sz)\n\t\t\t: n(n), sz(sz), val(n, 0), blocks((n + sz - 1) / sz, 0) {\n\t\t}\n};\n\nstruct ToProcess {\n\tint x, y1, y2, sgn, id;\n};\n\nconst int BLOCK_SZ_Q \u003d 256;\nconst int BLOCK_SZ_N \u003d 512;\nconst int MAX_N \u003d 200000;\n\nint n, q;\nvector\u0026lt;ToProcess\u0026gt; sortedL[MAX_N], sortedR[MAX_N];\nSQRTDecomposition sum(MAX_N, BLOCK_SZ_N);\nint64_t ans[MAX_N], preAns[MAX_N];\npair\u0026lt;int, int\u0026gt; queries[MAX_N];\nvector\u0026lt;int\u0026gt; goods;\nint p[MAX_N];\nbool good[MAX_N];\n\ninline void add(int q, int sgn, int id) {\n\tif (q-1 \u0026gt;\u003d 0) {\n\t\tsortedL[q-1].push_back({q-1, p[q]+1, n-1, sgn, id});\n\t}\n\tif (q+1 \u0026lt; n) {\n\t\tsortedR[q+1].push_back({q+1, 0, p[q]-1, sgn, id});\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\tp[i] \u003d i;\n\t}\n\tfor (int i \u003d 0; i \u0026lt; q; i++) {\n\t\tcin \u0026gt;\u0026gt; queries[i].first \u0026gt;\u0026gt; queries[i].second;\n\t\tqueries[i].first--; queries[i].second--;\n\t}\n\tint64_t cnt \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; q; i +\u003d BLOCK_SZ_Q) {\n\t\tint iEnd \u003d min(q, i + BLOCK_SZ_Q);\n\t\tfor (int j \u003d 0; j \u0026lt; n; j++) {\n\t\t\tgood[j] \u003d false;\n\t\t}\n\t\tfor (int j \u003d i; j \u0026lt; iEnd; j++) {\n\t\t\tgood[queries[j].first] \u003d true;\n\t\t\tgood[queries[j].second] \u003d true;\n\t\t}\n\t\tgoods.clear();\n\t\tfor (int j \u003d 0; j \u0026lt; n; j++) {\n\t\t\tif (good[j]) {\n\t\t\t\tgoods.push_back(j);\n\t\t\t}\n\t\t}\n\t\tint64_t goodCnt \u003d 0;\n\t\tfor (int j \u003d 0; j \u0026lt; n; j++) {\n\t\t\tsortedL[j].clear();\n\t\t\tsortedR[j].clear();\n\t\t}\n\t\tfor (int j \u003d i; j \u0026lt; iEnd; j++) {\n\t\t\tint a \u003d queries[j].first, b \u003d queries[j].second;\n\t\t\tif (a \u003d\u003d b) {\n\t\t\t\tans[j] +\u003d goodCnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int k \u003d 0; k \u0026lt; (int)goods.size(); k++) {\n\t\t\t\tint q \u003d goods[k];\n\t\t\t\tif (q \u003d\u003d a || q \u003d\u003d b) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((p[q] \u0026lt; p[a] \u0026amp;\u0026amp; q \u0026gt; a) ||\n\t\t\t\t    (p[q] \u0026gt; p[a] \u0026amp;\u0026amp; q \u0026lt; a)) {\n\t\t\t\t\tgoodCnt--;\n\t\t\t\t}\n\t\t\t\tif ((p[q] \u0026lt; p[b] \u0026amp;\u0026amp; q \u0026gt; b) ||\n\t\t\t\t    (p[q] \u0026gt; p[b] \u0026amp;\u0026amp; q \u0026lt; b)) {\n\t\t\t\t\tgoodCnt--;\n\t\t\t\t}\n\t\t\t\tif ((p[q] \u0026lt; p[b] \u0026amp;\u0026amp; q \u0026gt; a) ||\n\t\t\t\t    (p[q] \u0026gt; p[b] \u0026amp;\u0026amp; q \u0026lt; a)) {\n\t\t\t\t\tgoodCnt++;\n\t\t\t\t}\n\t\t\t\tif ((p[q] \u0026lt; p[a] \u0026amp;\u0026amp; q \u0026gt; b) ||\n\t\t\t\t    (p[q] \u0026gt; p[a] \u0026amp;\u0026amp; q \u0026lt; b)) {\n\t\t\t\t\tgoodCnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((a \u0026lt; b \u0026amp;\u0026amp; p[a] \u0026gt; p[b]) ||\n\t\t\t\t(a \u0026gt; b \u0026amp;\u0026amp; p[a] \u0026lt; p[b])) {\n\t\t\t\tgoodCnt--;\n\t\t\t} else {\n\t\t\t\tgoodCnt++;\n\t\t\t}\n\t\t\tans[j] +\u003d goodCnt;\n\t\t\tadd(a, -1, j);\n\t\t\tadd(b, -1, j);\n\t\t\tswap(p[a], p[b]);\n\t\t\tadd(a, +1, j);\n\t\t\tadd(b, +1, j);\n\t\t}\n\t\tsum.clear();\n\t\tfor (int j \u003d 0; j \u0026lt; n; j++) {\n\t\t\tif (!good[j]) {\n\t\t\t\tsum.add(p[j], 1);\n\t\t\t}\n\t\t\tfor (int k \u003d 0; k \u0026lt; (int)sortedL[j].size(); k++) {\n\t\t\t\tToProcess \u0026amp;cur \u003d sortedL[j][k];\n\t\t\t\tint64_t res \u003d sum.sum(cur.y1, cur.y2);\n\t\t\t\tres *\u003d cur.sgn;\n\t\t\t\tpreAns[cur.id] +\u003d res;\n\t\t\t}\n\t\t}\n\t\tsum.clear();\n\t\tfor (int j \u003d n-1; j \u0026gt;\u003d 0; j--) {\n\t\t\tif (!good[j]) {\n\t\t\t\tsum.add(p[j], 1);\n\t\t\t}\n\t\t\tfor (int k \u003d 0; k \u0026lt; (int)sortedR[j].size(); k++) {\n\t\t\t\tToProcess \u0026amp;cur \u003d sortedR[j][k];\n\t\t\t\tint64_t res \u003d sum.sum(cur.y1, cur.y2);\n\t\t\t\tres *\u003d cur.sgn;\n\t\t\t\tpreAns[cur.id] +\u003d res;\n\t\t\t}\n\t\t}\n\t\tfor (int j \u003d i; j \u0026lt; iEnd; j++) {\n\t\t\tif (j !\u003d i) {\n\t\t\t\tpreAns[j] +\u003d preAns[j-1];\t\n\t\t\t}\n\t\t\tans[j] +\u003d cnt + preAns[j];\n\t\t}\n\t\tcnt \u003d ans[iEnd - 1];\n\t}\n\tfor (int i \u003d 0; i \u0026lt; q; i++) {\n\t\tcout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eJava code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.*;\nimport java.util.*;\n\npublic class InversionNSqrtNNoVectors {\n\tprivate static final int BLOCK_SZ_Q \u003d 256;\n\tprivate static final int BLOCK_SZ_N \u003d 512;\n\t\n\tpublic static class ToProcess {\n\t\tpublic int x, y1, y2, sgn, id;\n\t\t\n\t\tpublic void set(int pX, int pY1, int pY2, int pSgn, int pId) {\n\t\t\tx \u003d pX;\n\t\t\ty1 \u003d pY1;\n\t\t\ty2 \u003d pY2;\n\t\t\tsgn \u003d pSgn;\n\t\t\tid \u003d pId;\n\t\t}\n\t\t\n\t\tpublic ToProcess() {\n\t\t}\n\t}\n\t\n\tpublic static class ToProcessCompareAsc implements Comparator\u0026lt;ToProcess\u0026gt; {\n\t\t@Override\n\t\tpublic int compare(ToProcess o1, ToProcess o2) {\n\t\t\treturn o1.x - o2.x;\n\t\t}\n\t}\n\t\n\tpublic static class ToProcessCompareDesc implements Comparator\u0026lt;ToProcess\u0026gt; {\n\t\t@Override\n\t\tpublic int compare(ToProcess o1, ToProcess o2) {\n\t\t\treturn o2.x - o1.x;\n\t\t}\n\t}\n\t\n\tstatic int n, q;\n\tstatic int[] p;\n\tstatic ToProcess[] queryL, queryR;\n\tstatic int queryLCnt, queryRCnt;\n\tstatic SQRTDecomposition sum;\n\tstatic ToProcessCompareAsc ascCmp \u003d new ToProcessCompareAsc();\n\tstatic ToProcessCompareDesc descCmp \u003d new ToProcessCompareDesc();\n\t\n\tpublic static final void add(int q, int sgn, int id) {\n\t\tif (q-1 \u0026gt;\u003d 0) {\n\t\t\tqueryL[queryLCnt++].set(q-1, p[q]+1, n-1, sgn, id);\n\t\t}\n\t\tif (q+1 \u0026lt; n) {\n\t\t\tqueryR[queryRCnt++].set(q+1, 0, p[q]-1, sgn, id);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader reader \u003d new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter writer \u003d new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tStringTokenizer tokenizer \u003d new StringTokenizer(reader.readLine());\n\t\tn \u003d Integer.parseInt(tokenizer.nextToken());\n\t\tq \u003d Integer.parseInt(tokenizer.nextToken());\n\t\tint[] qL \u003d new int[q], qR \u003d new int[q];\n\t\tlong[] ans \u003d new long[q], preAns \u003d new long[q];\n\t\tp \u003d new int[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\t\tp[i] \u003d i;\n\t\t}\n\t\tfor (int i \u003d 0; i \u0026lt; q; i++) {\n\t\t\ttokenizer \u003d new StringTokenizer(reader.readLine());\n\t\t\tqL[i] \u003d Integer.parseInt(tokenizer.nextToken()) - 1;\n\t\t\tqR[i] \u003d Integer.parseInt(tokenizer.nextToken()) - 1;\n\t\t}\n\t\tlong cnt \u003d 0;\n\t\tboolean[] good \u003d new boolean[n];\n\t\tint[] goods \u003d new int[n];\n\t\tint goodsSize \u003d 0;\n\t\tqueryL \u003d new ToProcess[4 * BLOCK_SZ_Q]; queryR \u003d new ToProcess[4 * BLOCK_SZ_Q];\n\t\tfor (int j \u003d 0; j \u0026lt; 4 * BLOCK_SZ_Q; j++) {\n\t\t\tqueryL[j] \u003d new ToProcess();\n\t\t\tqueryR[j] \u003d new ToProcess();\n\t\t}\n\t\tSQRTDecomposition sum \u003d new SQRTDecomposition(n, BLOCK_SZ_N);\n\t\tfor (int i \u003d 0; i \u0026lt; q; i +\u003d BLOCK_SZ_Q) {\n\t\t\tint iEnd \u003d Math.min(q, i + BLOCK_SZ_Q);\n\t\t\tArrays.fill(good, false);\n\t\t\tfor (int j \u003d i; j \u0026lt; iEnd; j++) {\n\t\t\t\tgood[qL[j]] \u003d true;\n\t\t\t\tgood[qR[j]] \u003d true;\n\t\t\t}\n\t\t\tgoodsSize \u003d 0;\n\t\t\tfor (int j \u003d 0; j \u0026lt; n; j++) {\n\t\t\t\tif (good[j]) {\n\t\t\t\t\tgoods[goodsSize++] \u003d j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong goodCnt \u003d 0;\n\t\t\tqueryLCnt \u003d 0;\n\t\t\tqueryRCnt \u003d 0;\n\t\t\tfor (int j \u003d i; j \u0026lt; iEnd; j++) {\n\t\t\t\tint a \u003d qL[j], b \u003d qR[j];\n\t\t\t\tif (a \u003d\u003d b) {\n\t\t\t\t\tans[j] +\u003d goodCnt;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int k \u003d 0; k \u0026lt; goodsSize; k++) {\n\t\t\t\t\tint q \u003d goods[k];\n\t\t\t\t\tif (q \u003d\u003d a || q \u003d\u003d b) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif ((p[q] \u0026lt; p[a] \u0026amp;\u0026amp; q \u0026gt; a) ||\n\t\t\t\t\t\t(p[q] \u0026gt; p[a] \u0026amp;\u0026amp; q \u0026lt; a)) {\n\t\t\t\t\t\tgoodCnt--;\n\t\t\t\t\t}\n\t\t\t\t\tif ((p[q] \u0026lt; p[b] \u0026amp;\u0026amp; q \u0026gt; b) ||\n\t\t\t\t\t\t(p[q] \u0026gt; p[b] \u0026amp;\u0026amp; q \u0026lt; b)) {\n\t\t\t\t\t\tgoodCnt--;\n\t\t\t\t\t}\n\t\t\t\t\tif ((p[q] \u0026lt; p[b] \u0026amp;\u0026amp; q \u0026gt; a) ||\n\t\t\t\t\t\t(p[q] \u0026gt; p[b] \u0026amp;\u0026amp; q \u0026lt; a)) {\n\t\t\t\t\t\tgoodCnt++;\n\t\t\t\t\t}\n\t\t\t\t\tif ((p[q] \u0026lt; p[a] \u0026amp;\u0026amp; q \u0026gt; b) ||\n\t\t\t\t\t\t(p[q] \u0026gt; p[a] \u0026amp;\u0026amp; q \u0026lt; b)) {\n\t\t\t\t\t\tgoodCnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((a \u0026lt; b \u0026amp;\u0026amp; p[a] \u0026gt; p[b]) ||\n\t\t\t\t\t(a \u0026gt; b \u0026amp;\u0026amp; p[a] \u0026lt; p[b])) {\n\t\t\t\t\tgoodCnt--;\n\t\t\t\t} else {\n\t\t\t\t\tgoodCnt++;\n\t\t\t\t}\n\t\t\t\tans[j] +\u003d goodCnt;\n\t\t\t\tadd(a, -1, j);\n\t\t\t\tadd(b, -1, j);\n\t\t\t\tint tmp \u003d p[a];\n\t\t\t\tp[a] \u003d p[b];\n\t\t\t\tp[b] \u003d tmp;\n\t\t\t\tadd(a, +1, j);\n\t\t\t\tadd(b, +1, j);\n\t\t\t}\n\t\t\tsum.clear();\n\t\t\tArrays.sort(queryL, 0, queryLCnt, ascCmp);\n\t\t\tint curL \u003d 0;\n\t\t\tfor (int j \u003d 0; j \u0026lt; n; j++) {\n\t\t\t\tif (!good[j]) {\n\t\t\t\t\tsum.add(p[j], 1);\n\t\t\t\t}\n\t\t\t\tfor (; curL \u0026lt; queryLCnt; curL++) {\n\t\t\t\t\tToProcess cur \u003d queryL[curL];\n\t\t\t\t\tif (cur.x !\u003d j) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint res \u003d sum.sum(cur.y1, cur.y2);\n\t\t\t\t\tres *\u003d cur.sgn;\n\t\t\t\t\tpreAns[cur.id] +\u003d res;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum.clear();\n\t\t\tArrays.sort(queryR, 0, queryRCnt, descCmp);\n\t\t\tint curR \u003d 0;\n\t\t\tfor (int j \u003d n-1; j \u0026gt;\u003d 0; j--) {\n\t\t\t\tif (!good[j]) {\n\t\t\t\t\tsum.add(p[j], 1);\n\t\t\t\t}\n\t\t\t\tfor (; curR \u0026lt; queryRCnt; curR++) {\n\t\t\t\t\tToProcess cur \u003d queryR[curR];\n\t\t\t\t\tif (cur.x !\u003d j) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint res \u003d sum.sum(cur.y1, cur.y2);\n\t\t\t\t\tres *\u003d cur.sgn;\n\t\t\t\t\tpreAns[cur.id] +\u003d res;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j \u003d i; j \u0026lt; iEnd; j++) {\n\t\t\t\tif (j !\u003d i) {\n\t\t\t\t\tpreAns[j] +\u003d preAns[j-1];\t\n\t\t\t\t}\n\t\t\t\tans[j] +\u003d cnt + preAns[j];\n\t\t\t}\n\t\t\tcnt \u003d ans[iEnd - 1];\n\t\t}\n\t\tfor (int i \u003d 0; i \u0026lt; q; i++) {\n\t\t\twriter.write(Long.toString(ans[i]));\n\t\t\twriter.newLine();\n\t\t}\n\t\treader.close();\n\t\twriter.close();\n\t}\n}\n\nclass SQRTDecomposition {\n\tprivate int n;\n\tprivate int sz;\n\tprivate int[] val;\n\tprivate int[] blocks;\n\t\n\tpublic final void add(int v, int delta) {\n\t\tval[v] +\u003d delta;\n\t\tblocks[v / sz] +\u003d delta;\n\t}\n\t\t\n\tpublic final int sum(int l, int r) {\t\n\t\tif (l \u0026lt; 0) {\n\t\t\tl \u003d 0;\n\t\t}\n\t\tif (r \u0026gt;\u003d n) {\n\t\t\tr \u003d n;\n\t\t}\n\t\tr++;\n\t\tint res \u003d 0;\n\t\tint lBlock \u003d (l + sz - 1) / sz, rBlock \u003d r / sz;\n\t\tfor (int i \u003d lBlock; i \u0026lt; rBlock; i++) {\n\t\t\tres +\u003d blocks[i];\n\t\t}\n\t\tint lBlockR \u003d lBlock * sz, rBlockR \u003d rBlock * sz;\n\t\tif (lBlockR \u0026gt;\u003d rBlockR) {\n\t\t\tfor (int i \u003d l; i \u0026lt; r; i++) {\n\t\t\t\tres +\u003d val[i];\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i \u003d l; i \u0026lt; lBlockR; i++) {\n\t\t\t\tres +\u003d val[i];\n\t\t\t}\n\t\t\tfor (int i \u003d rBlockR; i \u0026lt; r; i++) {\n\t\t\t\tres +\u003d val[i];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic void clear() {\n\t\tArrays.fill(val, 0);\n\t\tArrays.fill(blocks, 0);\n\t}\n\t\t\n\tSQRTDecomposition(int pN, int pSz) {\n\t\tn \u003d pN;\n\t\tsz \u003d pSz;\n\t\tval \u003d new int[n];\n\t\tblocks \u003d new int[(n + sz - 1) / sz];\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eAlternative solution from \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Vladik\" title\u003d\"Candidate Master Vladik\"\u003eVladik\u003c/a\u003e:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;iomanip\u0026gt;\n\n#define sqr(a) (a)*(a)\n#define all(a) (a).begin(), (a).end()\nusing namespace std;\n\ntemplate \u0026lt;typename T\u0026gt;\nT next_int() {\n    T ans \u003d 0, t \u003d 1;\n    char ch;\n    do { ch \u003d getchar(); } while(ch \u0026lt;\u003d \u0027 \u0027) ;\n    if(ch \u003d\u003d \u0027-\u0027) {\n        t \u003d -1;\n        ch \u003d getchar();\n    }\n    while(ch \u0026gt;\u003d \u00270\u0027 \u0026amp;\u0026amp; ch \u0026lt;\u003d \u00279\u0027) {\n        ans \u003d ans * 10 + (ch - \u00270\u0027);\n        ch \u003d getchar();\n    }\n    return ans * t;\n}\n\nstring next_token() {\n    char ch;\n    string ans \u003d \u0026quot;\u0026quot;;\n    do { ch \u003d getchar(); } while(ch \u0026lt;\u003d \u0027 \u0027) ;\n    while(ch \u0026gt;\u003d \u0027 \u0027) {\n        ans +\u003d ch;\n        ch \u003d getchar();\n    }\n    return ans;\n}\n\nconst long long INF \u003d (long long)1e18 + 227 + 1;\nconst int INFINT \u003d (int)1e9 + 227 + 1;\nconst int MAXN \u003d (int)2e5 + 227 + 1;\nconst int MOD \u003d (int)1e9 + 7;\nconst long double EPS \u003d 1e-9;\n\nlong long bin_pow(long long n, long long k) {\n    if(!k) return 1;\n    long long ans \u003d bin_pow(n, k / 2);\n    ans \u003d ans * ans % MOD;\n    if(k % 2) ans \u003d ans * n % MOD;\n    return ans;\n}\n\nstruct tree {\n    int size_block;\n    int len; \n \n    tree(int len) : len(len) {\n        size_block \u003d sqrt(len);\n \n        kek.resize(len / size_block + 1, vector\u0026lt;int\u0026gt;(size_block, 0));\n \n        pr_block.resize(len / size_block + 1, 0);\n    }\n \n    vector\u0026lt;int\u0026gt; pr_block;\n    vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; kek;\n \n    void inc(int pos, int num) {\n        int x \u003d pos / size_block;\n \n        for(int i \u003d pos % size_block; i \u0026lt; size_block; i++) {\n            kek[x][i] +\u003d num;\n        }\n \n        for(int i \u003d 0; i \u0026lt;\u003d len / size_block; i++)\n            if(i \u003d\u003d 0) {\n                pr_block[i] \u003d kek[i][size_block - 1];\n            } else {\n                pr_block[i] \u003d pr_block[i - 1] + kek[i][size_block - 1]; \n            }\n    }\n \n    int f(int a) {\n        return a / size_block;\n    }\n \n    long long get(vector\u0026lt;int\u0026gt; \u0026amp;a, int l, int r, bool ok \u003d 1) {\n        if(ok \u003d\u003d 1) {\n            l %\u003d size_block;\n            r %\u003d size_block;\n        }\n \n        return a[r] - (l ? a[l - 1] : 0);\n    }\n \n    int get(int l, int r) {\n        if(l \u0026gt; r) return 0;\n\n        r \u003d min(r, len);\n  \n        if(f(l) \u003d\u003d f(r))\n            return get(kek[f(l)], l, r);\n     \n        int ans \u003d 0;\n \n        if(l % size_block) {\n            ans +\u003d get(kek[f(l)], l, size_block - 1);\n \n            l +\u003d size_block - l % size_block;\n        }\n \n        if(r % size_block !\u003d size_block - 1) {\n            ans +\u003d get(kek[f(r)], 0, r);\n \n            r -\u003d r % size_block + 1;\n        }\n \n        ans +\u003d get(pr_block, f(l), f(r), 0);\n \n        return ans;\n    }\n \n    int get_pref(int p) {\n        return get(1, p - 1);\n    }\n\n    int get_suff(int p) {\n        return get(p + 1, len);\n    }\n} ;\n\nstruct mda {\n    vector\u0026lt;int\u0026gt; a;\n    vector\u0026lt;tree\u0026gt; t;\n    int len, sz;\n    long long ans;\n\n    mda(int len) : len(len) {\n        sz \u003d 2000;\n        ans \u003d 0;\n\n        a.resize(len + 1);\n        for(int i \u003d 1; i \u0026lt;\u003d len; i++)\n            a[i] \u003d i;\n\n        for(int i \u003d 1; i \u0026lt;\u003d len; i +\u003d sz) {\n            t.push_back(tree(len));\n            for(int j \u003d i; j \u0026lt; i + sz \u0026amp;\u0026amp; j \u0026lt;\u003d len; j++)\n                add(j, j);\n        }\n    }\n\n    int get_pref(int L, int R, int k) {\n        int ans \u003d 0;\n\n        for(int l \u003d 1; l \u0026lt;\u003d R; l +\u003d sz) {\n            int r \u003d l + sz - 1;\n\n            if(r \u0026lt; L || l \u0026gt; R) continue;\n\n            if(L \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026lt;\u003d R)\n                ans +\u003d t[(l - 1) / sz].get_pref(k);\n            else\n                for(int i \u003d max(l, L); i \u0026lt;\u003d min(r, R); i++) \n                    ans +\u003d (a[i] \u0026lt; k);\n        }\n\n        return ans;\n    }\n\n    int get_suff(int L, int R, int k) {\n        int ans \u003d 0;\n\n        for(int l \u003d 1; l \u0026lt;\u003d R; l +\u003d sz) {\n            int r \u003d l + sz - 1;\n\n            if(r \u0026lt; L || l \u0026gt; R) continue;\n\n            if(L \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026lt;\u003d R)\n                ans +\u003d t[(l - 1) / sz].get_suff(k);\n            else\n                for(int i \u003d max(l, L); i \u0026lt;\u003d min(r, R); i++) \n                    ans +\u003d (a[i] \u0026gt; k);\n        }\n\n        return ans;\n    }\n\n    void del(int p, int k) {\n        p \u003d (p - 1) / sz;\n        t[p].inc(k, -1);\n    }\n\n    void add(int p, int k) {\n        p \u003d (p - 1) / sz;\n        t[p].inc(k, 1);\n    }\n\n    void sw(int i, int j) {\n        if(i \u003d\u003d j) return;\n        if(i \u0026gt; j) swap(i, j);\n\n        ans -\u003d get_pref(i, j, a[i]);\n        ans -\u003d get_suff(i, j, a[j]);\n\n        if(a[i] \u0026gt; a[j]) ans++;\n\n        del(i, a[i]);\n        del(j, a[j]);\n        swap(a[i], a[j]);\n        add(i, a[i]);\n        add(j, a[j]);\n\n        ans +\u003d get_pref(i, j, a[i]);\n        ans +\u003d get_suff(i, j, a[j]);\n\n        if(a[i] \u0026gt; a[j]) ans--;\n    }\n} ;\n\nint main() {\n    // freopen(\u0026quot;.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\n    int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\n    mda t(n);\n\n    for(int i \u003d 0; i \u0026lt; m; i++) {\n        int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n\n        t.sw(x, y);\n        \n        cout \u0026lt;\u0026lt; t.ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eAlternative solution from \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/netman\" title\u003d\"Master netman\"\u003enetman\u003c/a\u003e:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eJava code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.*;\nimport java.util.*;\n\npublic class NsqrtNlogNnetman implements Runnable {\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n        InputReader(InputStream in) {\n            reader \u003d new BufferedReader(new InputStreamReader(in), 32768);\n            tokenizer \u003d null;\n        }\n        String next() {\n            while (tokenizer \u003d\u003d null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer \u003d new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static class Fenwick {\n        int[] ft;\n        Fenwick(int n) {\n            ft \u003d new int[n];\n        }\n        void add(int r, int val) {\n            while (r \u0026lt; ft.length) {\n                ft[r] +\u003d val;\n                r |\u003d r + 1;\n            }\n        }\n        int sum(int r) {\n            int res \u003d 0;\n            while (r \u0026gt;\u003d 0) {\n                res +\u003d ft[r];\n                r \u003d (r \u0026amp; (r + 1)) - 1;\n            }\n            return res;\n        }\n        void clear() {\n            Arrays.fill(ft, 0);\n        }\n    }\n\n    static class Query {\n        int x, bound, sign, id;\n        Query(int x, int bound, int sign, int id) {\n            this.x \u003d x;\n            this.bound \u003d bound;\n            this.sign \u003d sign;\n            this.id \u003d id;\n        }\n    }\n\n    static void getOnPrefSmaller(List\u0026lt;Query\u0026gt; qrs, int r, int y, int id, int sign) {\n        qrs.add(new Query(r, y, sign, id));\n    }\n\n    static void getOnPrefBetween(List\u0026lt;Query\u0026gt; qrs, int r, int x, int y, int id, int sign) {\n        getOnPrefSmaller(qrs, r, y, id, sign);\n        getOnPrefSmaller(qrs, r, x, id, -sign);\n    }\n\n    static void getOnSegmentBetween(List\u0026lt;Query\u0026gt; qrs, int l, int r, int x, int y, int id, int sign) {\n        if (x \u0026gt; y) return;\n        getOnPrefBetween(qrs, r, x, y, id, sign);\n        getOnPrefBetween(qrs, l, x, y, id, -sign);\n    }\n\n    @Override\n    public void run() {\n\n        InputReader in \u003d new InputReader(System.in);\n        PrintWriter out \u003d new PrintWriter(System.out);\n\n        int n \u003d in.nextInt();\n        int q \u003d in.nextInt();\n\n        int[] l \u003d new int[q];\n        int[] r \u003d new int[q];\n\n        for (int i \u003d 0; i \u0026lt; q; i++) {\n            l[i] \u003d in.nextInt() - 1;\n            r[i] \u003d in.nextInt() - 1;\n        }\n\n        int[] perm \u003d new int[n];\n\n        for (int i \u003d 0; i \u0026lt; n; i++) {\n            perm[i] \u003d n - i - 1;\n        }\n\n        final int BLOCK \u003d 300;\n\n        long inv \u003d 0L;\n\n        boolean[] isInteresting \u003d new boolean[n];\n\n        long[] add \u003d new long[q];\n\n        Fenwick f \u003d new Fenwick(n);\n\n        for (int i \u003d 0; i \u0026lt; q; i +\u003d BLOCK) {\n            int from \u003d i, to \u003d Math.min(i + BLOCK, q) - 1;\n            List\u0026lt;Integer\u0026gt; lst \u003d new ArrayList\u0026lt;\u0026gt;();\n            for (int j \u003d from; j \u0026lt;\u003d to; j++) {\n                lst.add(l[j]);\n                lst.add(r[j]);\n            }\n            lst.sort(Integer::compareTo);\n            lst \u003d new ArrayList\u0026lt;\u0026gt;(new HashSet\u0026lt;\u0026gt;(lst));\n            int[] interestingPositions \u003d lst.stream().mapToInt(x -\u0026gt; x).toArray();\n            for (int pos : interestingPositions) {\n                isInteresting[pos] \u003d true;\n            }\n            List\u0026lt;Query\u0026gt; qrs \u003d new ArrayList\u0026lt;\u0026gt;();\n            for (int j \u003d from; j \u0026lt;\u003d to; j++) {\n                if (l[j] \u003d\u003d r[j]) continue;\n                if (l[j] \u0026gt; r[j]) {\n                    int tmp \u003d l[j];\n                    l[j] \u003d r[j];\n                    r[j] \u003d tmp;\n                }\n                if (perm[l[j]] \u0026lt; perm[r[j]]) {\n                    getOnSegmentBetween(qrs, l[j], r[j], perm[l[j]], perm[r[j]], j,-1);\n                    int leftValue \u003d perm[l[j]];\n                    int rightValue \u003d perm[r[j]];\n                    for (int pos : interestingPositions) {\n                        if (pos \u0026gt; l[j] \u0026amp;\u0026amp; pos \u0026lt; r[j] \u0026amp;\u0026amp; perm[pos] \u0026gt; leftValue \u0026amp;\u0026amp; perm[pos] \u0026lt; rightValue) {\n                            add[j] -\u003d 2;\n                        }\n                    }\n                    add[j]--;\n                } else {\n                    getOnSegmentBetween(qrs, l[j], r[j], perm[r[j]], perm[l[j]], j,1);\n                    int leftValue \u003d perm[l[j]];\n                    int rightValue \u003d perm[r[j]];\n                    for (int pos : interestingPositions) {\n                        if (pos \u0026gt; l[j] \u0026amp;\u0026amp; pos \u0026lt; r[j] \u0026amp;\u0026amp; perm[pos] \u0026gt; rightValue \u0026amp;\u0026amp; perm[pos] \u0026lt; leftValue) {\n                            add[j] +\u003d 2;\n                        }\n                    }\n                    add[j]++;\n                }\n                int tmp \u003d perm[l[j]];\n                perm[l[j]] \u003d perm[r[j]];\n                perm[r[j]] \u003d tmp;\n            }\n            qrs.sort(Comparator.comparingInt(a -\u0026gt; -a.x));\n\n            f.clear();\n            for (int pos \u003d 0; pos \u0026lt; n; pos++) {\n                if (!isInteresting[pos]) {\n                    f.add(perm[pos], 1);\n                }\n                while (!qrs.isEmpty() \u0026amp;\u0026amp; qrs.get(qrs.size() - 1).x \u003d\u003d pos) {\n                    Query t \u003d qrs.get(qrs.size() - 1);\n                    qrs.remove(qrs.size() - 1);\n                    add[t.id] +\u003d 2 * t.sign * f.sum(t.bound);\n                }\n            }\n            for (int j \u003d from; j \u0026lt;\u003d to; j++) {\n                inv +\u003d add[j];\n                out.println(inv);\n            }\n            for (int pos : interestingPositions) {\n                isInteresting[pos] \u003d false;\n            }\n        }\n\n\n\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        new Thread(null, new NsqrtNlogNnetman(), \u0026quot;1\u0026quot;, 1L \u0026lt;\u0026lt; 28).run();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["editorial","anton","404","contest","hits","tag not found"]}}