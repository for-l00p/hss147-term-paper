{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1421660498,"rating":20,"authorHandle":"iSea","modificationTimeSeconds":1421663855,"id":15882,"title":"\u003cp\u003eCodeForces 285 \u0026amp; 286\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eSimple \u0026amp; Quick Summary.\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003eCF 285\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eA: The key point is \u003cstrong\u003eForest\u003c/strong\u003e. So find the vertex node with degree of 1, we can get an edge. Repeat it until no more found.\u003c/p\u003e\u003cp\u003eB: Conversion between Factorial base and Normal decimal base. Use a binary indexed tree to keep numbers have appeared and find the amount of numbers less than the current number. Basically:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eNormal -\u0026gt; Factorial \u003ccode\u003efnum[i] \u003d num[i] - less_than_i\u003c/code\u003e\u003c/li\u003e   \u003cli\u003eFactorial -\u0026gt; Normal binary search \u003ccode\u003ek\u003c/code\u003e that \u003ccode\u003ek - less_than_k \u003d fnum[i]\u003c/code\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eC: I \u003cstrong\u003emisunderstood\u003c/strong\u003e the meaning during the contest: find the number of sub-strings which can be rearranged to be a palindrome.\u003c/p\u003e\u003cp\u003eThen I tried to use a naive method, divide the array to K(usually sqrt(n)) blocks. For each block, use \u003ccode\u003eset\u0026lt;int\u0026gt;\u003c/code\u003e to record its state, do a \u0026quot;swap line\u0026quot; with each start point. The complexity can be reached \u003ccode\u003eO(N*sqrt(N)*log(N))\u003c/code\u003e, also huge.\u003c/p\u003e\u003cp\u003eThe right task is: find the number of sub-strings which can be rearranged to make the total string to be a palindrome.\u003c/p\u003e\u003cp\u003eIt should be easier, but still not interesting. So let it go.\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003eCF 286\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eA: This is a strange problem. I failed to find the point of problem A while solving the CF-style contest for the first time.\u003c/p\u003e\u003cp\u003eAssume there are N grids, given the amount of goods on each grid. Goal of the game is to collect as many goods as possible.\u003c/p\u003e\u003cp\u003eNow you can jump between grids, the step must be positive, and if the previous step is \u003ccode\u003el\u003c/code\u003e, the current step can only be \u003ccode\u003el\u003c/code\u003e, \u003ccode\u003el+1\u003c/code\u003e or \u003ccode\u003el-1\u003c/code\u003e. The limits of N is 30000.\u003c/p\u003e\u003cp\u003eHere is the key, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e ≤ 30000\u003c/span\u003e. As we know \u003cspan class\u003d\"tex-span\"\u003e(1 + 2 + ... + \u003ci\u003es\u003c/i\u003e) \u003d \u003ci\u003es\u003c/i\u003e * (\u003ci\u003es\u003c/i\u003e + 1) / 2\u003c/span\u003e, even if we keep increasing(or decreasing, the same) the step length in every step, the maximum s is about 250, to reach the final destination.\u003c/p\u003e\u003cp\u003eSo the dp state is about [position(30000)][step(-250,250)], approximate to 15 millions. But be careful, \u003ccode\u003emap\u003c/code\u003e or \u003ccode\u003eunordered_map\u003c/code\u003e is too heavy to keep the state, just use a big array.\u003c/p\u003e\u003cp\u003eB: Rebuild a directed graph to keep the original connectivity. It\u0027s \u003cstrong\u003eNOT\u003c/strong\u003e necessary to use the original edge.\u003c/p\u003e\u003cp\u003eBecause we can rebuild it by our own way, a simple cycle to make all pairs of vertices connected. So for each connected component, by the way, here we treat the edge to be bi-directed, if it\u0027s a DAG, a tree is enough, otherwise use a cycle.\u003c/p\u003e\u003cp\u003eIt\u0027s totally a different problem if you can only delete useless edges to keep the original connectivity. First find all the SCC(Strong Connected Component), shrink the original map to a DAG forest. Then for an edge i-\u0026gt;j, if there exists i-\u0026gt;k and k-\u0026gt;j as the same time, we can delete it. Just like the Floyd algorithm. The total complexity can be \u003ccode\u003eO(N^3)\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eD: Color the edge of a map with a specified color, and a colored map will be simple. For each query (u, v), find the number of different color in which they are connected.\u003c/p\u003e\u003cp\u003eHash vertex ID in each colored map, and use a disjointed set to keep the connectivity. Then do an offline traversal. One optimization is keep the color set for each vertex, only loop it when both of the vertices have that color. And verify it by looping the vertex with smaller number of colors.\u003c/p\u003e\u003cp\u003eFortunately, it got Accepted. (And the only one I had passed TAT)\u003c/p\u003e\u003c/div\u003e","tags":["tutorial","summary"]}}