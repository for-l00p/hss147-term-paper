{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1502781658,"rating":3,"authorHandle":"puf","modificationTimeSeconds":1502782237,"id":53861,"title":"\u003cp\u003eProblem on queries\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eWe have array of zeros of length N. There are 3 types of queries in the problem:\u003c/p\u003e \u003col\u003e   \u003cli\u003eAdd 1 to all nums with indexes in range [l, r].\u003c/li\u003e   \u003cli\u003eSubtract 1 from all nums with indexes in range [l, r].\u003c/li\u003e   \u003cli\u003ePrint count of zeros in [l, r].\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eIn each step there are no negative numbers.\u003c/p\u003e\u003cp\u003eI am solving it so: Make sqrt-decomposition, for each block store deque, where d[i] is count of i in the block. When we need to add 1 to all nums in the block, just push_front(0), it\u0027ll shift all the values by 1. Similarly pop_front(), when we subtracting 1 from all nums in the block. If block isn\u0027t fully in the range manually change counts. For 3rd query type summarise d[0] for blocks inside the range, for first\u0026amp;last blocks run cycle and count zeros. Complexity \u003cem\u003eO(NâˆšN)\u003c/em\u003e\u003c/p\u003e\u003cp\u003eIs this solution correct? Are there solutions faster?\u003c/p\u003e\u003c/div\u003e","tags":[]}}