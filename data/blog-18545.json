{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1434252910,"rating":1,"authorHandle":"forthright48","modificationTimeSeconds":1498143910,"id":18545,"title":"\u003cp\u003eAndrew Stankevich Contest 3 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eContest Link — \u003ca href\u003d\"//codeforces.com/group/j9VlExDLmA/contest/100198\"\u003ehttp://codeforces.com/group/j9VlExDLmA/contest/100198\u003c/a\u003e\u003c/h3\u003e \u003cdiv\u003e \u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100198/problem/A\" title\u003d\"2003-2004 Summer Petrozavodsk Camp, Andrew Stankevich Contest 3 (ASC 3)\"\u003e100198A - Areas\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eStep 1: Find all intersection points of N lines. Let\u0027s call each intersection points nodes.\u003c/p\u003e\u003cp\u003eStep 2: Add edges between each node. How? For each line, find which nodes lie on it. Sort them according to their edges. Then add an edge between each adjacent nodes.\u003c/p\u003e\u003cp\u003eThis will convert the graph into a planar graph. We have to find the areas enclosed by the nodes in this graph. After conversion, there can be three different states.\u003c/p\u003e\u003cp\u003eState 1: No nodes. This happens when all lines are parallel. Number of finite area is 0.\u003c/p\u003e\u003cp\u003eState 2: Single chain of nodes. This happens when one or more parallel lines are cut with another line. Number of finite area is 0 for this case too.\u003c/p\u003e\u003cp\u003eState 3: A planar graph where each node has a degree of at least 2. This is because, if there is node with degree 1, then it will be a leaf. And if we try to create leaf, the graph will become state 2. So we will have to add another line to bring it out of state 2 ( since we want to create a leaf in state 3) and this line will always add a degree to the leaf.\u003c/p\u003e\u003cp\u003eWe will cover only state 3, since answer of other two is trivial. Notice few things now.\u003c/p\u003e\u003cp\u003eNote 1: Due to the nature of the problem (line-line intersection) there will be one gigantic polygon. There won’t be chunks of disjoint polygon. \u003c/p\u003e\u003cp\u003eNote 2: Each small area will be surrounded by a set of edges. For each small area, let us traverse it’s surrounding edges in counter clockwise order. How many times will each edge be traversed? The edges that form the boundary of the polygon will be traversed once, whereas the internal edges will be traversed twice. To be more specific, each internal edges will be traversed once in each direction.\u003c/p\u003e\u003cp\u003eNow for each direction of each edge (for now, we will consider only the internal edges), let us run a DFS(a,b). The dfs will work in the following manner. Let us say, we started a dfs with edge (a,b). Then it will try to go to some other node c, which is connected to b. There are many and it will chose a node c, such that, c lies counter clockwise with respect to line ab. Still there could be many. We chose the one which forms the smallest angle abc. If no such node exists, we failed.\u003c/p\u003e\u003cp\u003eAfter finding c, we run DFS(b,c). We will eventually form a cycle that will connect to original node a. This is always the case for internal nodes due to the nature of the problem. For boundary edges, only one direction forms cycle, the other one fails to reach a cycle. We simply ignore it. In both cases, success or failure of DFS, when tracing back, we will remove the edges we just traversed. Since those edges will no longer contribute to any other small areas.\u003c/p\u003e\u003cp\u003eWhenever we find a cycle, we add it to our result. We repeat this until we find all small areas. When we run out of edges, we run out of small areas. Don’t forget to ignore the areas that are smaller than 1e-8.\u003c/p\u003e\u003cp\u003eMy Solution: \u003ca href\u003d\"//codeforces.com/group/j9VlExDLmA/contest/100198/submission/11579708\"\u003eSubmission\u003c/a\u003e, \u003ca href\u003d\"http://ideone.com/k1TD2O\"\u003eIdeone\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100198/problem/B\" title\u003d\"2003-2004 Summer Petrozavodsk Camp, Andrew Stankevich Contest 3 (ASC 3)\"\u003e100198B - Beloved Sons\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eGiven N sons, and list of the girls they like, we have to assign them each son with a girl. The graph is bipartite (sons on left, girls on right), so it is a bipartite matching problem ( not maximum matching though ). We don\u0027t want to maximize number of matches ( marriages ) in this problem, our goal is to make King happy.\u003c/p\u003e\u003cp\u003eHow much King loves each son is given as in integer value. So let us sort the sons in non-increasing order of how much they are liked by King. Now, let us perform Kuhn\u0027s Algorithm on the graph. Whenever we find a match, we add \u003ccode\u003eAi*Ai\u003c/code\u003e to the result for that particular son.\u003c/p\u003e\u003cp\u003eThis works cause Kuhn\u0027s algorithm finds matching for sons one by one ( in the order we provided ). When it finds matching, it means it is possible to match the current son without breaking matching for previous sons (matching might be rearranged). If in any situation, we cannot increase matching, but instead have the option to break one of previous matching to assign the current son a girl, why should we? The current son is loved less by the King than any of its previous brothers. So it is always optimal to make previous sons happy than the current one.\u003c/p\u003e\u003cp\u003eMy Submission: \u003ca href\u003d\"//codeforces.com/group/j9VlExDLmA/contest/100198/submission/7626424\"\u003eSubmission\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100198/problem/C\" title\u003d\"2003-2004 Summer Petrozavodsk Camp, Andrew Stankevich Contest 3 (ASC 3)\"\u003e100198C - Strange Counter\u003c/a\u003e\u003c/h3\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100198/problem/D\" title\u003d\"2003-2004 Summer Petrozavodsk Camp, Andrew Stankevich Contest 3 (ASC 3)\"\u003e100198D - Data Transmission\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eBy — \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/triveni\" title\u003d\"Candidate Master triveni\"\u003etriveni\u003c/a\u003e\u003c/p\u003e\u003cp\u003ePush Relabel using Gap Heuristics algorithm for max flow can be used to solve the problem. Note that push relabel algorithms can perform better over augmenting path algorithms in graphs where the graph is locally dense and mostly sparse. You can read more about the algorithm for more insights. \u003ca href\u003d\"http://ideone.com/uoPqmw\"\u003eCode\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100198/problem/E\" title\u003d\"2003-2004 Summer Petrozavodsk Camp, Andrew Stankevich Contest 3 (ASC 3)\"\u003e100198E - Strong Defence\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eRun a bfs from source. Suppose distance of target from source is x. Then, bfs will travel level by level towards the target. Let there be p1 nodes that are exactly 1 unit away from source, p2 nodes 2 units away and so on. \u003c/p\u003e\u003cp\u003eNow, imagine for the first level, if we block each of p1 nodes from reaching their parent, will it be possible to reach from target to source anymore? No. So we will assign all the roads going from p1 nodes to their parent one type of crystal. Using the same reasoning, if we block out all paths from p2 nodes to their parent, then target cannot reach source. \u003c/p\u003e\u003cp\u003eSo, number of different crystal to be used will be number of units from source to sink. Each type of crystal will block out each level. \u003c/p\u003e\u003cp\u003eNotice that we are blocking roads that we don\u0027t need to block to separate target and source. But it doesn\u0027t matter. We are given 3 conditions, each crystal type can cut out source and target, number of crystal needs to be maximum and two ships will not block same hypertunnel. Our solution is satisfying all of these. So it is valid.\u003c/p\u003e\u003cp\u003eMy Submission: \u003ca href\u003d\"//codeforces.com/group/j9VlExDLmA/contest/100198/submission/7637534\"\u003eSubmission\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100198/problem/F\" title\u003d\"2003-2004 Summer Petrozavodsk Camp, Andrew Stankevich Contest 3 (ASC 3)\"\u003e100198F - Weird Dissimilarity\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eBy \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Boxer\" title\u003d\"Expert Boxer\"\u003eBoxer\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst of all , we have to be careful using the alphabet because characters may be negative , this depends of the implementation , i really recomend to use a map\u0026lt; int , int \u0026gt; to avoid this issue.\u003c/p\u003e\u003cp\u003eLet\u0027s go to the solution , let L \u003d lenght of string alpha and beta in an optimal solution , we can see that this L \u0026lt;\u003d |lambda| + |u| because in the worst case we have to match every lamba character with a non u character and every u character with a non lambda character and the another matchs of type non lambda and non u are not optimal.\u003c/p\u003e\u003cp\u003eThen we can formulate a dp( x , y ) \u003d min disimilarity with x characters of lambda and y characters of u matched\u003c/p\u003e\u003cp\u003eOur transicions are:\u003c/p\u003e\u003cp\u003eTake a new lamba with a non u \u003c/p\u003e\u003cp\u003ecostLambda( x ) + dp( x + 1 , y )\u003c/p\u003e\u003cp\u003eTake a non lambda with a new u\u003c/p\u003e\u003cp\u003ecostU( x ) + dp( x + 1 , y )\u003c/p\u003e\u003cp\u003eTake a new lambda with a new u\u003c/p\u003e\u003cp\u003ecostLambdaU( x , y ) + dp( x + 1 , y + 1 )\u003c/p\u003e\u003cp\u003eAnd our Base Case is\u003c/p\u003e\u003cp\u003edp( n , m ) \u003d 0\u003c/p\u003e\u003cp\u003eAnd after that we have to reconstruct one solution of that dp.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/edJYigj9\"\u003eSubmission\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100198/problem/G\" title\u003d\"2003-2004 Summer Petrozavodsk Camp, Andrew Stankevich Contest 3 (ASC 3)\"\u003e100198G - PL/Cool\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eBy — \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/triveni\" title\u003d\"Candidate Master triveni\"\u003etriveni\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/1/submission/27910917\"\u003eCode\u003c/a\u003e. This problem is mostly about parsing the input properly. Note that there can be spaces in the expression to evaluate. So handle that carefully. Apart from that, we can use DSU (Disjoint Set Union) data structure to handle the \u003cem\u003edefine\u003c/em\u003e operations. We should also map all the \u003cem\u003eoperands\u003c/em\u003e to integers so that we can use simplest implementation of DSU.\u003c/p\u003e\u003cp\u003eSuppose there is a operation like \u003cstrong\u003edefine oldVal newVal\u003c/strong\u003e. We should first check if \u003cem\u003eoldVal\u003c/em\u003e has already been defined before. This can be done by simply checking if parent[oldVal] is equal to oldVal or not (assuming we initialized parent of each node to be same). Similarly we should check for cycles. And finally we can do assignment \u003cem\u003eparent[oldVal] \u003d newVal\u003c/em\u003e. \u003c/p\u003e\u003cp\u003eEvaluation part is pretty standard one. Just note that \u003cstrong\u003e^\u003c/strong\u003e operation should be handled carefully because it is evaluated from right to left. In my code, I have first evaluated all the \u003cstrong\u003e^\u003c/strong\u003e operations and then used the standard method to evaluate the reduced expression.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100198/problem/H\" title\u003d\"2003-2004 Summer Petrozavodsk Camp, Andrew Stankevich Contest 3 (ASC 3)\"\u003e100198H - Royal Federation\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eBy — \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/triveni\" title\u003d\"Candidate Master triveni\"\u003etriveni\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/1/submission/27907761\"\u003eCode\u003c/a\u003e. There always exist an answer to the problem. The following procedure can be used to find a solution. Note that I will be using term \u003cem\u003enode\u003c/em\u003e to refer to a city.\u003c/p\u003e \u003col\u003e   \u003cli\u003eRoot the tree at node 1 (or any node of choice). Do dfs from root node to evaluate the answer.\u003c/li\u003e   \u003cli\u003eFor any node \u003cstrong\u003eu\u003c/strong\u003e we will assign province to all the nodes in the subtree rooted at \u003cstrong\u003eu\u003c/strong\u003e except for atmost \u003cstrong\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e - 1\u003c/span\u003e\u003c/strong\u003e node. We will return the list of these nodes which we could not assign a province.\u003c/li\u003e   \u003cli\u003eThis is trivially true for the leaves. Now suppose we are at some node \u003cstrong\u003eu\u003c/strong\u003e. Find the list of unassigned nodes for each child using dfs. Note that for each child the number of unassigned nodes is less than \u003cstrong\u003eb\u003c/strong\u003e.\u003c/li\u003e   \u003cli\u003eNow we combine unassigned nodes of two or more child untill total number of nodes is no less than \u003cstrong\u003eb\u003c/strong\u003e. At this stage we assign a new province to these nodes. And the headquarter is assigned as node \u003cstrong\u003eu\u003c/strong\u003e for this province. We repeat this untill atmost \u003cstrong\u003eb-1\u003c/strong\u003e nodes are remaining.\u003c/li\u003e   \u003cli\u003eNote that after step 4. We can have atmost \u003cstrong\u003eb-1\u003c/strong\u003e unassigned nodes still remaining. We now add the node \u003cstrong\u003eu\u003c/strong\u003e to the list. If the size is \u003cspan class\u003d\"tex-span\"\u003e ≥ \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e then we assign these nodes a new province, headquarter at node \u003cstrong\u003eu\u003c/strong\u003e and return empty list. Otherwise we return the list of unassigned nodes.\u003c/li\u003e   \u003cli\u003eWhen we are node \u003cstrong\u003e1\u003c/strong\u003e we can have atmost \u003cstrong\u003eb-1\u003c/strong\u003e nodes still remaining, we will assign these nodes the same province as we did to the node that was last assigned a province. Note that size of this province is still less than \u003cstrong\u003e3b\u003c/strong\u003e.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eEnd of the procedure.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100198/problem/I\" title\u003d\"2003-2004 Summer Petrozavodsk Camp, Andrew Stankevich Contest 3 (ASC 3)\"\u003e100198I - Two Cylinders\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThis problem requires knowledge about Calculus and strong imagination power. \u003c/p\u003e\u003cp\u003eThe cross-sectional area of the intersection is a square. It\u0027s kind of tough to explain with words, so I suggest you watch this video. Note that the radius of two cylinders in the video is 1. \u003ca href\u003d\"https://www.youtube.com/watch?v\u003drASKzEbMXIQ\"\u003eYoutube Video\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIn our case, the equation is going to boil down to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d5/c5/d5c5cd2a1960c7136085bd93a5c337fd93286ae4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Integrating this using calculus is going to be tough. So we will just use numerical methods to find the integration.\u003c/p\u003e\u003cp\u003eI used \u003ca href\u003d\"https://en.wikipedia.org/?title\u003dSimpson%27s_rule\"\u003eComposite Simpson\u0027s Rule\u003c/a\u003e to find approximate volume. \u003c/p\u003e\u003cp\u003eMy Solution: \u003ca href\u003d\"http://ideone.com/p9FkQi\"\u003eIdeone\u003c/a\u003e, \u003ca href\u003d\"//codeforces.com/group/j9VlExDLmA/contest/100198/submission/11629629\"\u003eSubmission\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["maxflow","push-relabel"]}}