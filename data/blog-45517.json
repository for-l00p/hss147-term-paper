{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1466268771,"rating":66,"authorHandle":"Errichto","modificationTimeSeconds":1471336223,"id":45517,"title":"\u003cp\u003eTCO16 Round 2C — with Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eRemember to register.\u003c/p\u003e\u003cp\u003e--- EDIT, the contest is over ---\u003c/p\u003e\u003ch1\u003eBearBall, 250 points\u003c/h1\u003e\u003cp\u003eThere is a special case when all points are in one line. Otherwise, for any pair of bears the number of throws is 1 or 2.\u003c/p\u003e\u003cp\u003eSo, for each points you should count how many points are directly reachable from this one. You achieve it by sorting other points. The complexity should be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/85/39/853954cfbd77fbe92e70495737229693dccedd7b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProof that 2 throws are enough\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eImagine a line going through starting and ending point. From points not on this line, choose the one closest to the line (any of closest ones in case of ties).\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode for BearBall\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.util.Arrays;\n\npublic class BearBall {\n\tpublic int countThrows(int[] x, int[] y) {\n\t\tint n \u003d x.length;\n\t\tint answer \u003d 0;\n\t\tfor(int i \u003d 0; i \u0026lt; n; ++i) {\n\t\t\t// sort other points by angle\n\t\t\tPoint[] p \u003d new Point[n-1];\n\t\t\tint tmp \u003d 0;\n\t\t\tfor(int j \u003d 0; j \u0026lt; n; ++j) if(i !\u003d j)\n\t\t\t\tp[tmp++] \u003d new Point(x[j] - x[i], y[j] - y[i]);\n\t\t\tArrays.sort(p);\n\t\t\t// check if all are collinear\n\t\t\tif(p[0].compareTo(p[n-2]) \u003d\u003d 0) {\n\t\t\t\tanswer \u003d 0; // forget what was calculated so far\n\t\t\t\tfor(int a \u003d 0; a \u0026lt; n; ++a)\n\t\t\t\t\tfor(int b \u003d a + 1; b \u0026lt; n; ++b)\n\t\t\t\t\t\tanswer +\u003d 2 * (b - a);\n\t\t\t\treturn answer;\n\t\t\t}\n\t\t\tfor(int j \u003d 0; j \u0026lt; n - 1; ++j) {\n\t\t\t\t++answer; // the first point in this direction\n\t\t\t\twhile(j + 1 \u0026lt; n - 1 \u0026amp;\u0026amp; p[j].compareTo(p[j+1]) \u003d\u003d 0) {\n\t\t\t\t\tanswer +\u003d 2; // not the first point in this direction\n\t\t\t\t\t++j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n}\n\nclass Point implements Comparable\u0026lt;Point\u0026gt; {\n\tint x, y;\n\tPoint(int _x, int _y) { x \u003d _x; y \u003d _y; }\n\tpublic int compareTo(Point other) {\n\t\tif(isRight() !\u003d other.isRight())\n\t\t\treturn isRight() ? 1 : -1;\n\t\treturn x * other.y - y * other.x;\n\t}\n\tvoid write() {\n\t\tSystem.out.println(x + \u0026quot; \u0026quot; + y);\n\t}\n\tboolean isRight() {\n\t\treturn x \u0026gt; 0 || (x \u003d\u003d 0 \u0026amp;\u0026amp; y \u0026gt; 0);\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch1\u003eBearGridRect, 600 points\u003c/h1\u003e\u003cp\u003eHint: use flows, maybe mincost.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ewhat graph?\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eLayers:\u003c/p\u003e \u003col\u003e   \u003cli\u003esource\u003c/li\u003e   \u003cli\u003eone vertex for each row\u003c/li\u003e   \u003cli\u003eone vertex for each rectangle\u003c/li\u003e   \u003cli\u003eone vertex for each rectangle\u003c/li\u003e   \u003cli\u003eone vertex for each column\u003c/li\u003e   \u003cli\u003esink\u003c/li\u003e \u003c/ol\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode for BearGridRect\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.util.*;\n\npublic class BearGridRect {\n\tint n, m;\n\tint row(int i) { return i; }\n\tint column(int i) { return n + i; }\n\tint query1(int i) { return 2 * n + i; }\n\tint query2(int i) { return 2 * n + m + i; }\n\tpublic int[] findPermutation(int tmp_n, int[] r1, int[] r2, int[] c1, int[] c2, int[] cnt) {\n\t\tn \u003d tmp_n;\n\t\tm \u003d r1.length;\n\t\tint s \u003d 2 * n + 2 * m;\n\t\tint t \u003d 2 * n + 2 * m + 1;\n\t\tint total \u003d 2 * n + 2 * m + 2;\n\t\tMinCostMaxFlow f \u003d new MinCostMaxFlow();\n\t\tf.init(total);\n\t\t\n\t\tboolean visited[][] \u003d new boolean[n][n];\n\t\tint cnt_sum \u003d 0;\n\t\t\n\t\tfor(int i \u003d 0; i \u0026lt; m; ++i) {\n\t\t\tcnt_sum +\u003d cnt[i];\n\t\t\tf.add(query1(i), query2(i), cnt[i], 0);\n\t\t\tfor(int r \u003d r1[i]; r \u0026lt;\u003d r2[i]; ++r)\n\t\t\t\tfor(int c \u003d c1[i]; c \u0026lt;\u003d c2[i]; ++c) {\n\t\t\t\t\tf.add(row(r), query1(i), 1, 0);\n\t\t\t\t\tf.add(query2(i), column(c), 1, 0);\n\t\t\t\t\tvisited[r][c] \u003d true;\n\t\t\t\t}\n\t\t}\n\t\tfor(int r \u003d 0; r \u0026lt; n; ++r)\n\t\t\tfor(int c \u003d 0; c \u0026lt; n; ++c)\n\t\t\t\tif(!visited[r][c])\n\t\t\t\t\tf.add(row(r), column(c), 1, 1);\n\t\t\n\t\tfor(int r \u003d 0; r \u0026lt; n; ++r)\n\t\t\tf.add(s, row(r), 1, 0);\n\t\tfor(int c \u003d 0; c \u0026lt; n; ++c)\n\t\t\tf.add(column(c), t, 1, 0);\n\t\t\n\t\tint[] ans \u003d f.findFlow(s, t);\n\t\tint total_flow \u003d ans[0];\n\t\tint total_cost \u003d ans[1];\n\t\tif(total_flow !\u003d n || cnt_sum + total_cost !\u003d n) {\n\t\t\tint tmp[] \u003d {-1};\n\t\t\treturn tmp;\n\t\t}\n\t\tans \u003d new int[n];\n\t\tfor(int r \u003d 0; r \u0026lt; n; ++r) {\n\t\t\tfor(int c \u003d 0; c \u0026lt; n; ++c) {\n\t\t\t\tif(f.flow[row(r)][column(c)] \u0026gt; 0)\n\t\t\t\t\tans[r] \u003d c;\n\t\t\t\tfor(int i \u003d 0; i \u0026lt; m; ++i)\n\t\t\t\t\tif(f.flow[row(r)][query1(i)] \u0026gt; 0 \u0026amp;\u0026amp; f.flow[query2(i)][column(c)] \u0026gt; 0) {\n\t\t\t\t\t\tans[r] \u003d c;\n\t\t\t\t\t\tf.flow[row(r)][query1(i)] \u003d f.flow[query2(i)][column(c)] \u003d 0;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n\nclass MinCostMaxFlow { // from http://web.mit.edu/~ecprice/acm/acm08/MinCostMaxFlow.java\n\tboolean found[];\n\tint N, cap[][], flow[][], cost[][], dad[], dist[], pi[];\n\t\n\tvoid init(int N) {\n\t\tthis.N \u003d N;\n\t\tcap \u003d new int[N][N];\n\t\tcost \u003d new int[N][N];\n\t}\n\tvoid add(int from, int to, int ca, int cos) {\n\t\tcap[from][to] \u003d ca;\n\t\tcost[from][to] \u003d cos;\n\t}\n\t\n\tstatic final int INF \u003d Integer.MAX_VALUE / 2 - 1;\n\t\n\tboolean search(int source, int sink) {\n\t\tArrays.fill(found, false);\n\t\tArrays.fill(dist, INF);\n\t\tdist[source] \u003d 0;\n\n\t\twhile (source !\u003d N) {\n\t\t\tint best \u003d N;\n\t\t\tfound[source] \u003d true;\n\t\t\tfor (int k \u003d 0; k \u0026lt; N; k++) {\n\t\t\t\tif (found[k]) continue;\n\t\t\t\tif (flow[k][source] !\u003d 0) {\n\t\t\t\t\tint val \u003d dist[source] + pi[source] - pi[k] - cost[k][source];\n\t\t\t\t\tif (dist[k] \u0026gt; val) {\n\t\t\t\t\t\tdist[k] \u003d val;\n\t\t\t\t\t\tdad[k] \u003d source;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flow[source][k] \u0026lt; cap[source][k]) {\n\t\t\t\t\tint val \u003d dist[source] + pi[source] - pi[k] + cost[source][k];\n\t\t\t\t\tif (dist[k] \u0026gt; val) {\n\t\t\t\t\t\tdist[k] \u003d val;\n\t\t\t\t\t\tdad[k] \u003d source;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dist[k] \u0026lt; dist[best]) best \u003d k;\n\t\t\t}\n\t\t\tsource \u003d best;\n\t\t}\n\t\tfor (int k \u003d 0; k \u0026lt; N; k++)\n\t\t\tpi[k] \u003d Math.min(pi[k] + dist[k], INF);\n\t\treturn found[sink];\n\t}\n\t\n\tint[] findFlow(int source, int sink) {\n\t\tfound \u003d new boolean[N];\n\t\tflow \u003d new int[N][N];\n\t\tdist \u003d new int[N+1];\n\t\tdad \u003d new int[N];\n\t\tpi \u003d new int[N];\n\t\t\n\t\tint totflow \u003d 0, totcost \u003d 0;\n\t\twhile (search(source, sink)) {\n\t\t\tint amt \u003d INF;\n\t\t\tfor (int x \u003d sink; x !\u003d source; x \u003d dad[x])\n\t\t\t\tamt \u003d Math.min(amt, flow[x][dad[x]] !\u003d 0 ? flow[x][dad[x]] :\n\t\t\tcap[dad[x]][x] - flow[dad[x]][x]);\n\t\t\tfor (int x \u003d sink; x !\u003d source; x \u003d dad[x]) {\n\t\t\t\tif (flow[x][dad[x]] !\u003d 0) {\n\t\t\t\t\tflow[x][dad[x]] -\u003d amt;\n\t\t\t\t\ttotcost -\u003d amt * cost[x][dad[x]];\n\t\t\t\t} else {\n\t\t\t\t\tflow[dad[x]][x] +\u003d amt;\n\t\t\t\t\ttotcost +\u003d amt * cost[dad[x]][x];\n\t\t\t\t}\n\t\t\t}\n\t\t\ttotflow +\u003d amt;\n\t\t}\n\t\treturn new int[]{ totflow, totcost };\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch1\u003eBearCircleGame, 800 points\u003c/h1\u003e\u003cp\u003eDynamic programming. Iterate over the number of remaining players, from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. In each moment, you need an array of size with probabilities — for each number of bears what is the probability that Limak is this far from the starting bear. Then, for each bear we need probability that he loses and thus we will know the next array (for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eremaining\u003c/i\u003e - 1\u003c/span\u003e remaining bears).\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e loses with probability \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/2e/c2/2ec25d7ee48efb20d2bc40021e39becf50488129.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eTry to first write \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e approach — find cycle in a sequence of indices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + 1 - \u003ci\u003ek\u003c/i\u003e, \u003ci\u003ea\u003c/i\u003e + 1 - 2\u003ci\u003ek\u003c/i\u003e, \u003ci\u003ea\u003c/i\u003e + 1 - 3\u003ci\u003ek\u003c/i\u003e...\u003c/span\u003e and then over indices in the cycle sum up \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c2/4e/c24e11228246bbf470f7c9d9cdc74a2f90b5b990.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e is the size of cycle and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e says which place this index has in the cycle.\u003c/p\u003e\u003cp\u003eTo make it faster, notice that the answer for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e will be similar. It\u0027s enough to multiply (or divide, whatever) by the sum by two, and then add one value.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode for BearCircleGame\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003epublic class BearCircleGame {\n\tint mod \u003d 1000 * 1000 * 1000 + 7;\n\tint mul(int a, int b) {\n\t\treturn (int) ((long) a * b % mod);\n\t}\n\tint my_pow(int a, int b) {\n\t\tint r \u003d 1;\n\t\twhile(b \u0026gt; 0) {\n\t\t\tif(b % 2 \u003d\u003d 1) r \u003d (int) ((long) r * a % mod);\n\t\t\ta \u003d (int) ((long) a * a % mod);\n\t\t\tb /\u003d 2;\n\t\t}\n\t\treturn r;\n\t}\n\tint inv(int a) { return my_pow(a, mod - 2); }\n\t\n\tpublic int winProbability(int n, int k) {\n\t\tint dp[] \u003d new int[n];\n\t\tdp[0] \u003d 1; // probability that Limak starts\n\t\tfor(int remaining \u003d n; remaining \u0026gt;\u003d 2; --remaining) {\n\t\t\tint old[] \u003d dp;\n\t\t\tdp \u003d new int[remaining - 1];\n\t\t\tboolean vis[] \u003d new boolean[remaining];\n\t\t\tfor(int starting \u003d 0; starting \u0026lt; remaining; ++starting) if(!vis[starting]) {\n\t\t\t\tint p \u003d 0;\n\t\t\t\tint x \u003d starting;\n\t\t\t\tint div \u003d 1;\n\t\t\t\tint cycle_size \u003d 0;\n\t\t\t\tdo {\n\t\t\t\t\tvis[x] \u003d true;\n\t\t\t\t\t++cycle_size;\n\t\t\t\t\tdiv \u003d mul(div, inv(2));\n\t\t\t\t\tp \u003d (p + mul(old[x], div)) % mod;\n\t\t\t\t\tx \u003d ((x - k) % remaining + remaining) % remaining;\n\t\t\t\t} while(x !\u003d starting);\n\t\t\t\t\n\t\t\t\tint power_two \u003d 1;\n\t\t\t\tfor(int i \u003d 0; i \u0026lt; cycle_size; ++i)\n\t\t\t\t\tpower_two \u003d 2 * power_two % mod;\n\t\t\t\tif(power_two \u003d\u003d 1) {\n\t\t\t\t\tSystem.out.println(\u0026quot;assert inv(0)\u0026quot;);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t// multiply by 2^c/(2^c-1) (because it\u0027s geometric  series)\n\t\t\t\tint mul_by \u003d mul(power_two, inv(power_two - 1));\n\t\t\t\t\n\t\t\t\tdo {\n\t\t\t\t\tint dead \u003d (x + k - 1) % remaining;\n\t\t\t\t\tif(dead !\u003d 0) {\n\t\t\t\t\t\tint nxt \u003d (dead \u003d\u003d remaining-1) ? 0 : dead;\n\t\t\t\t\t\tdp[nxt] \u003d mul(p, mul_by);\n\t\t\t\t\t}\n\t\t\t\t\tp \u003d (p - mul(old[x], inv(2)) + mod) % mod;\n\t\t\t\t\tp \u003d 2 * p % mod;\n\t\t\t\t\tp \u003d (p + mul(old[x], div)) % mod; // div \u003d\u003d inv(2)^c\n\t\t\t\t\tx \u003d ((x - k) % remaining + remaining) % remaining;\n\t\t\t\t} while(x !\u003d starting);\n\t\t\t}\n\t\t}\n\t\treturn dp[0];\n\t}\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch1\u003eWINNERS\u003c/h1\u003e \u003col\u003e   \u003cli\u003e\u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/liymsheep\" title\u003d\"International Grandmaster liymsheep\"\u003eliymsheep\u003c/a\u003e, who solved all three problems\u003c/li\u003e   \u003cli\u003e\u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/ACRush\" title\u003d\"International Grandmaster ACRush\"\u003eACRush\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/kriii\" title\u003d\"Grandmaster kriii\"\u003ekriii\u003c/a\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eAnd congratulations to \u003ca class\u003d\"rated-user user-legendary\" href\u003d\"/profile/Petr\" title\u003d\"Legendary grandmaster Petr\"\u003e\u003cspan class\u003d\"legendary-user-first-letter\"\u003eP\u003c/span\u003eetr\u003c/a\u003e for solving all problems and thus winning the parallel round.\u003c/p\u003e\u003c/div\u003e","tags":["tco","tco 16","bear","limak"]}}