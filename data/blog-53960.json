{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1503153899,"rating":123,"authorHandle":"flash_7","modificationTimeSeconds":1507584464,"id":53960,"title":"\u003cp\u003eDigit DP\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eWrote this article a long ago but during solving a problem recently thought of sharing this article publicly. Hope it will help some contestants to understand the idea clearly.\u003c/p\u003e\u003cp\u003eDigit dp is a very easy technique and also useful to solve many dynamic programming problems. Seeing the name “Digit DP” it’s easy to guess that we are going to do something using the digits. Yes we are actually going to play with digits. Let’s explain the concept using a classical problem.\u003c/p\u003e\u003ch4\u003eProblem\u003c/h4\u003e\u003cp\u003eHow many numbers \u003cstrong\u003ex\u003c/strong\u003e are there in the range \u003cstrong\u003ea\u003c/strong\u003e to \u003cstrong\u003eb\u003c/strong\u003e, where the digit \u003cstrong\u003ed\u003c/strong\u003e occurs exactly \u003cstrong\u003ek\u003c/strong\u003e times in \u003cstrong\u003ex\u003c/strong\u003e? There may have several solutions including number theory or combinatorics, but let’s see how we can solve this problem using digit dp.\u003c/p\u003e\u003ch4\u003eSolve for range (zero to a)\u003c/h4\u003e\u003cp\u003eUsing digit dp we always focus on building a number satisfying all the conditions. If we finally manage to build that number then we say, yes we have got one ;-) But how we’ll build that number? For the time being let’s say \u003cstrong\u003ea\u003c/strong\u003e is zero. So we need to find the total numbers which are not greater than \u003cstrong\u003eb\u003c/strong\u003e and also satisfy the given conditions.\u003c/p\u003e\u003ch4\u003eBuilding a sequence of digits\u003c/h4\u003e\u003cp\u003eLet’s consider the number as a sequence of digits. Let’s name the sequence \u003cstrong\u003esq\u003c/strong\u003e. Initially \u003cstrong\u003esq\u003c/strong\u003e is empty. We’ll try to add new digits from left to right to build the sequence. In each recursive call we’ll place a digit in our current position and will call recursively to add a digit in the next position. But can we place any of the digits from \u003cstrong\u003e0\u003c/strong\u003e to \u003cstrong\u003e9\u003c/strong\u003e in our current position? Of course not, because we need to make sure that the number is not getting larger than \u003cstrong\u003eb\u003c/strong\u003e.\u003c/p\u003e\u003ch4\u003eInformation we need to place a digit at the current position\u003c/h4\u003e\u003cp\u003eLet’s say during the building of the sequence, currently we are at position \u003cstrong\u003epos\u003c/strong\u003e. We have already placed some digits in position from \u003cstrong\u003e1\u003c/strong\u003e to \u003cstrong\u003epos-1\u003c/strong\u003e. So now we are trying to place a digit at current position \u003cstrong\u003epos\u003c/strong\u003e. If we knew the whole sequence we have build so far till position \u003cstrong\u003epos-1\u003c/strong\u003e then we could easily find out which digits we can place now. But how?\u003c/p\u003e\u003cp\u003eYou can see that, in the sequence \u003cstrong\u003esq\u003c/strong\u003e the left most digit is actually the most significant digit. And the significance get decreased from left to right. So if there exist any position \u003cstrong\u003et\u003c/strong\u003e (1\u0026lt;\u003dt\u0026lt;pos) where sq[t] \u0026lt; b[t] then we can place any digit in our current position. Because the sequence has already become smaller than \u003cstrong\u003eb\u003c/strong\u003e no matter which digit we place in the later positions. Note, b[t] means the digit at position \u003cstrong\u003et\u003c/strong\u003e at number \u003cstrong\u003eb\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eBut if there was no \u003cstrong\u003et\u003c/strong\u003e that satisfy that condition then at position \u003cstrong\u003epos\u003c/strong\u003e, we can’t place any digit greater than b[pos]. Because then the number will become larger than \u003cstrong\u003eb\u003c/strong\u003e.\u003c/p\u003e\u003ch4\u003eDo we really need the whole sequence?\u003c/h4\u003e\u003cp\u003eNow imagine, do we really need that whole sequence to find if a valid \u003cstrong\u003et\u003c/strong\u003e exist? If we placed any digit in our previous position which was smaller than its corresponding digit in \u003cstrong\u003eb\u003c/strong\u003e then couldn’t we just pass the information somehow so that we can use it later? Yes, using an extra parameter \u003cstrong\u003ef1\u003c/strong\u003e(true/false) in our function we can handle that. Whenever we place a digit at position \u003cstrong\u003et\u003c/strong\u003e which is smaller than b[t] we can make \u003cstrong\u003ef1\u003c/strong\u003e \u003d \u003cstrong\u003e1\u003c/strong\u003e for the next recursive call. So whenever we are at any position later, we don’t actually need the whole sequence. Using the value of \u003cstrong\u003ef1\u003c/strong\u003e we can know if the sequence have already become smaller than \u003cstrong\u003eb\u003c/strong\u003e.\u003c/p\u003e\u003ch4\u003eExtra condition\u003c/h4\u003e\u003cp\u003eSo far we focused on building the sequence \u003cstrong\u003esq\u003c/strong\u003e, but we have forgotten that there is an extra condition which is, digit \u003cstrong\u003ed\u003c/strong\u003e will have to occur exactly \u003cstrong\u003ek\u003c/strong\u003e times in sequence \u003cstrong\u003esq\u003c/strong\u003e. We need another parameter \u003cstrong\u003ecnt\u003c/strong\u003e. \u003cstrong\u003ecnt\u003c/strong\u003e is basically the number of times we have placed digit \u003cstrong\u003ed\u003c/strong\u003e so far in our sequence \u003cstrong\u003esq\u003c/strong\u003e. Whenever we place digit \u003cstrong\u003ed\u003c/strong\u003e in our sequence \u003cstrong\u003esq\u003c/strong\u003e we just increment \u003cstrong\u003ecnt\u003c/strong\u003e in our next recursive call.\u003c/p\u003e\u003cp\u003eIn the base case when we have built the whole sequence we just need to check if \u003cstrong\u003ecnt\u003c/strong\u003e is equal to \u003cstrong\u003ek\u003c/strong\u003e. If it is then we return \u003cstrong\u003e1\u003c/strong\u003e, otherwise we return \u003cstrong\u003e0\u003c/strong\u003e.\u003c/p\u003e\u003ch4\u003eFinal DP States\u003c/h4\u003e\u003cp\u003eIf we have understood everything so far then it\u0027s easy to see that we need total three states for DP memoization. At which position we are, if the number has already become smaller than \u003cstrong\u003eb\u003c/strong\u003e and the frequency of digit \u003cstrong\u003ed\u003c/strong\u003e till now.\u003c/p\u003e\u003ch4\u003eSolve for range (a to b)\u003c/h4\u003e\u003cp\u003eUsing the above approach we can find the total valid numbers in the range \u003cstrong\u003e0\u003c/strong\u003e to \u003cstrong\u003eb\u003c/strong\u003e. But in the original problem the range was actually \u003cstrong\u003ea\u003c/strong\u003e to \u003cstrong\u003eb\u003c/strong\u003e. How to handle that? Well, first we can find the result for range \u003cstrong\u003e0\u003c/strong\u003e to \u003cstrong\u003eb\u003c/strong\u003e and then just remove the result for range \u003cstrong\u003e0\u003c/strong\u003e to \u003cstrong\u003ea-1\u003c/strong\u003e. Then what we are left off is actually the result from range \u003cstrong\u003ea\u003c/strong\u003e to \u003cstrong\u003eb\u003c/strong\u003e.\u003c/p\u003e\u003ch4\u003eHow to solve for range a to b in a single recursion?\u003c/h4\u003e\u003cp\u003eIn the above approach we used an extra parameter \u003cstrong\u003ef1\u003c/strong\u003e which helped us to make sure the sequence is not getting larger than \u003cstrong\u003eb\u003c/strong\u003e. Can’t we do the similar thing so that the sequence does not become smaller than \u003cstrong\u003ea\u003c/strong\u003e? Yes of course. For that, we need to maintain an extra parameter \u003cstrong\u003ef2\u003c/strong\u003e which will say if there exist a position \u003cstrong\u003et\u003c/strong\u003e such that sq[t] \u0026gt; a[t]. Depending on the value of \u003cstrong\u003ef2\u003c/strong\u003e we can select the digits in our current position so that the sequence does not become smaller than \u003cstrong\u003ea\u003c/strong\u003e. Note: We also have to maintain the condition for \u003cstrong\u003ef1\u003c/strong\u003e parallely so that the sequence remains valid.\u003c/p\u003e\u003ch4\u003eProblem List\u003c/h4\u003e \u003col\u003e   \u003cli\u003e\u003ca href\u003d\"https://vjudge.net/problem/LightOJ-1068\"\u003eInvestigation\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://toph.co/p/lids\"\u003eLIDS\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"//codeforces.com/contest/628/problem/D\"\u003eMagic Numbers\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://vjudge.net/problem/LightOJ-1205\"\u003ePalindromic Numbers\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://www.codechef.com/problems/DGTCNT\"\u003eChef and Digits\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"//codeforces.com/gym/100886/problem/G\"\u003eMaximum Product\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://www.spoj.com/problems/TAP2012C/en/\"\u003eCantor\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://vjudge.net/problem/LightOJ-1122\"\u003eDigit Count\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://www.codechef.com/problems/DIGIMU\"\u003eLogan and DIGIT IMMUNE numbers\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://devskill.com/CodingProblems/ViewProblem/392\"\u003eSanvi and Magical Numbers\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://www.spoj.com/problems/CPCRC1C/\"\u003eSum of Digits\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://www.spoj.com/problems/PR003004/\"\u003eDigit Sum\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://www.spoj.com/problems/RAONE/\"\u003eRa-One Numbers\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://www.spoj.com/problems/LUCIFER/\"\u003eLUCIFER Number\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://www.spoj.com/problems/NUMTSN/\"\u003e369 Numbers\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://www.codechef.com/problems/WORKCHEF\"\u003eChef and special numbers\u003c/a\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eIs there some other problems? Some suggestions are really welcomed :)\u003c/p\u003e\u003c/div\u003e","tags":["dynamic programming","number theory","digit dp"]}}