{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1403776708,"rating":57,"authorHandle":"Wsl_F","modificationTimeSeconds":1403809130,"id":12844,"title":"\u003cp\u003eДерево отрезков (для любой ассоциативной функции) + картинки + код\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eТема данного поста — не нова, но, наверняка, кому-нибудь пригодится:) Начнём с примера задачи, в которой используется дерево отрезков.\u003c/p\u003e\u003cp\u003eИмеется массив из n (n≤10^5) целых чисел, нужно находить сумму на отрезке от l до r (0≤l,r≤n-1) и изменять значение i-го \u003cbr /\u003e (0≤i≤n-1) элемента. Количество запросов m (m≤10^5).\u003c/p\u003e\u003cp\u003eОчевидно, что наивное решение работает за O(n*m), а дерево отрезков дает возможность решать данную задачу с асимптотикой O(m*log2n).\u003c/p\u003e\u003cp\u003eСуществует множество разных видов деревьев отрезков. В данной статье дерево отрезков – структура данных, которая по имеющейся последовательности из n чисел умеет выполнять быстро (за логарифмическое время) 2 вида запросов:\u003c/p\u003e\u003cp\u003e1) Изменить значение i-го элемента \u003cbr /\u003e 2) Вычислить значение некоторой фиксированной ассоциативной функции на отрезке от l до r.\u003c/p\u003e\u003cp\u003eЧто же собой представляет дерево отрезков(ДО)? ДО – бинарное дерево (обычно, для удобства дополняют до полного нулевыми элементами), в котором листьями являются элементы исходного массива, а в каждой вершине записано значение функции f от двух сыновей. То есть в листах записано значение функции на отрезке длинной 1, в родителе записано значение функции на отрезке длинны 2, в родителе которого – 4… таким образом, в каждой вершине записано значение функции на некотором отрезке, что и послужило поводом для такого названия. \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"http://i.pixs.ru/storage/7/2/6/SegmentTre_3092356_12721726.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eДля нашего примера задачи функция f – сумма, тогда ДО для четырех элементов будет выглядеть следующим образом:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/1f/68/1f680d31bb5bca8826dde9099665bd3c2c311e37.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eЕсли же у нас количество элементов (n) не является степенью двойки, то мы дополним их нулями. (В общем случае, когда мы работает с типом данных Т и функцией f, то ноль — такое значение, что для любого x из T верно f(x,ноль)\u003dx.) Например, ДО сумм для 3 элементов будет выглядеть так:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/42/80/4280545adf0151b3ea39878eade45e3d20dfd5b6.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eКак же хранить ДО? Существует 2 способа: \u003cbr /\u003e • структуры на указателях; \u003cbr /\u003e • линейный массив.\u003c/p\u003e\u003cp\u003eНа сколько мне известно, первый способ используют только для персистентных ДО. Мы же пока разбираем самую обычную и простую модификацию ДО, поэтому воспользуемся вторым способом. Создадим линейный массив a из 2*nMax элементов, где nMax – наименьшая степень двойки, которая не превосходит n. В первом элементе (a[1]) будем хранить корень дерева, а для каждой вершины i её сыновья хранятся в ячейках с номерами 2*i (левый сын), 2*i+1 (правый сын). Почему для хранения достаточно 2*nMax элементов? Мы имеем nMax листов, у них nMax/2 родителей, у них nMax/4 … и 1 корень, очевидно, что эта сумма (1+2+4+…+ nMax/4+ nMax/2+ nMax) равняется 2*nMax-1.\u003c/p\u003e\u003cp\u003eНа рисунке проставим возле каждой вершины ее индекс в массиве:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/78/55/7855abb6bd3d9d16d68769abc2bbb68cff2f5a59.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eА в массив дерево будет уложено следующим образом:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/c6/7b/c67bb8f70a66d03510523b31c85d6995fdee1676.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eТеперь определим, какие операции мы хотим выполнять с нашим ДО: \u003cbr /\u003e 1) построить ДО; \u003cbr /\u003e 2) узнать значение i-го элемента; \u003cbr /\u003e 3) изменить значение i-го элемента; \u003cbr /\u003e 4) найти значение функции на отрезке от l до r.\u003cbr /\u003e\u003c/p\u003e\u003ch3\u003eРазберем по очереди все операции.\u003c/h3\u003e\u003ch4\u003e1 Построить дерево отрезков.\u003c/h4\u003e\u003cp\u003eПусть у нас есть массив b из n элементов. Для начала нам нужно найти nMax (наименьшая степень двойки, которая не превосходит n). Это можно реализовать как через формулу:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003enMax \u003d (1 \u0026lt;\u0026lt; (int)(log2(1.0*(n-1)) + 1);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eтак и простеньким циклом:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003enMax\u003d 1;\nwhile (nMax\u0026lt;n) nMax\u0026lt;\u0026lt;\u003d 1;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДалее нужно заполнить массив a нулями (соответствующего типа) и заполнить листы ДО значениями из массива b (мы помним, что в ДО индексы листьев от nMax до 2*nMax-1):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (int i\u003d0; i\u0026lt;n; i++)\n    a[nMax+i]\u003d b[i];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНа данный момент имеем:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/45/ae/45aed9a39d67300edf9719e24db117fdca7e7b4d.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eТеперь осталось только заполнить значения во всех родителях. Это можно сделать за один линейный проход (помним, что у i-ой вершины сыновья с индексами 2*i и 2*i+1, а в вершине мы храним значение функции от двух сыновей):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e        for (int i\u003dnMax-1; i\u0026gt;0; i--)\n            a[i]\u003d f(a[2*i],a[2*i+1]);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТаким образом мы построили ДО с асимптотикой O(nMax) \u003d O(n).\u003c/p\u003e\u003ch4\u003e2 Узнать значение i-го элемента.\u003c/h4\u003e\u003cp\u003eКак уже писалось ранее у нашего ДО листья имеют индексы от nMax до 2*nMax-1, поэтому значение i-го элемента элемента находиться в ячейке с индексом nMax+i: return a[nMax+i] Очевидно, что данный запрос выполняется за константу.\u003c/p\u003e\u003ch4\u003e3 Изменить значение i-го элемента.\u003c/h4\u003e\u003cp\u003eЕсли мы изменим значение в листе дерева, то все значения на пути к корню от данного листа перестанут соответствовать действительности, поэтому их нужно пересчитать, в остальных же останутся корректные значения. Как известно, глубина полного бинарного дерева из m вершин равна log2m, поэтому мы должны выполнить данную операцию за логарифмическое время. Например, изменим a2 на a2 I :\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/f1/f0/f1f0813fd5d1dfe32b14bbbc333c17c25429daf0.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eКрасным цветом выделены вершины, в которых нужно изменить значения. \u003c/p\u003e\u003cp\u003eЧто бы «обновить» ДО нам нужно записать в лист новое значение, а затем подняться до корня, каждый раз пересчитывая значение функции в вершине. Изменить значение в листе очень просто (вспомним, что индексы листьев от nMax до 2*nMax-1). Значение i-го листа имеет индекс nMax+i :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e       a[nMax+i]\u003d newValue;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТеперь осталось подняться до корня, это можно сделать с помощью цикла:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e        while (i\u0026gt;1)\n        {\n          i/\u003d 2;\n          a[i]\u003d f(a[2*i],a[2*i+1]);\n        }\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e4 Найти значение функции на отрезке от l до r.\u003c/h4\u003e\u003cp\u003eНаконец-то, мы добрались до самого интересного запроса. Стоит отметить, что частный случай, когда l\u003dr разобран в пункте 2 и выполняется за константу, в общем же случае асимптотика логарифмическая.\u003c/p\u003e\u003cp\u003eВведем определения.\u003c/p\u003e\u003cp\u003eФундаментальный отрезок – такой отрезок, для которого существует вершина в дереве, хранящая значение функции на данном отрезке.\u003c/p\u003e\u003cp\u003eУровень. Уровень корня – 1, а для каждого сына уровень на единицу больше, чем у родителя.\u003c/p\u003e\u003cp\u003eДля того, что бы вычислить значение функции на отрезке, нам необходимо разбить его на МИНИМАЛЬНОЕ количество фундаментальных отрезков. Что бы найти значение для любой вершины (кроме листа), нам нужно знать значения для сыновей. Мы будем спускаться по ДО. Изначально встаем в корень. Пусть мы находимся в какой-то вершине. Рассмотрим 3 возможных случая: отрезок [l..r] совпадает с отрезком, соответствующим текущей вершине, отрезок [l..r] полностью принадлежит одному из сыновей, отрезок принадлежит обоим сыновьям. В первом случае просто возвращаем посчитанное значение из ДО, во-втором – спускаемся в данного сына, в-третьем же случае разобьем данный отрезок на два: [l..правый конец левого сына] и [левый конец правого сына..r]. Рекурсивно вычислим значения для каждого из них.\u003c/p\u003e\u003cp\u003eРассмотрим на примере. Пусть у нас есть ДО для 8 элементов, запишем, какой отрезок соответствует каждой вершине:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/84/19/84198540ca6e412040568c63c055202f7593f9a1.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eА теперь посмотрим, как будет выполняться запрос для отрезка [1..5]. \u003c/p\u003e\u003cp\u003eСначала встаем в корень — наш отрезок принадлежит обоим сыновьям. Значит, нам нужно разбить его на 2 отрезка: [1..3] и [4..5]. Для каждого из них рекурсивно вычислить значение. Далее отрезок [1..3] опять принадлежит 2 сыновьям, разбиваем его на 2 отрезка: [1..1] и [2..3]. Отрезок [1..1] принадлежит только правому сыну, спускаемся в него и видим, что отрезок [1..1] – фундаментальный. Берем для него значение из вершины, и поднимаемся до 2 уровня (вершина [0..3]). Для левого сына мы уже рекурсивно посчитали, теперь посчитаем для правого: спускаемся в него. Отрезок [2..3] – фундаментальный, берем значение из вершины. Возвращаемся в [0..3] и уже можем вычислить значение для отрезка [1..3], так как значение функции уже вычислили для обеих его частей. Возвращаемся в корень и спускаемся в правого сына [4..7], наш подотрезок ([4..5]) принадлежит только одному левому сыну, спускаемся в него. Вершине соответствует отрезок [4..5], следовательно, он — фундаментальный, берем из вершины значение. Возвращаемся в корень и вычисляем ответ. \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"http://i.pixs.ru/storage/7/9/4/SegmentTre_5057003_12721794.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eПочему этот запрос выполниться за логарифмическое время? Как известно, глубина (количество уровней) дерева из n вершин равняется log2n, кроме того, утверждается, что на каждом уровне мы посетим не более 4 вершин, таким образом, мы посетим O (log2n) вершин. Рассмотрим код. Для вычисления значения на отрезке нам понадобится вызвать рекурсивную функцию от 5 аргументов, для удобства напишем функцию, которая по 2 аргументам (границы отрезка для запроса) вызывает функцию 5-и аргументов и возвращает значение:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eT query(int l, int r)\n{// return value function f on the segment [l;r]\nreturn query(l,r,0,nMax-1,1);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТеперь наша рекурсивная функция:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eT query(int l, int r, int leftPosition, int rightPosition, int v) \n{// return value function f on the intersection segments [l;r] and [leftPosition;rightPosition]\n // l – левая граница запроса\n // r – правая граница запроса\n // v – текущая вершина дерева отрезков\n // [leftPosition; rightPosition] – отрезок соответствующий v\n\nif (r\u0026lt;l) return zero;\n//если отрезок не существует, то возвращаем ноль.\nif (l\u003d\u003dleftPosition \u0026amp;\u0026amp; r\u003d\u003drightPosition) return a[v];\n// если отрезок фундаментальный,то возвращаем значение из вершины\n// раз мы дошли сюда, то отрезок принадлежит сыновьям\nint middle\u003d (leftPosition+rightPosition)/2;\n// вычисляем правую границу левого сына\nreturn f(query(l,min(middle,r),leftPosition,middle,v*2),\n    query(max(l,middle+1),r,middle+1,rightPosition,v*2+1));\n// рекурсивно вычисляем запросы для сыновей\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eМой \u003ca href\u003d\"https://github.com/WslF/SomeCode/blob/master/SegmentTree.cpp\"\u003eкод\u003c/a\u003e класса дерево отрезков единичная модификация.\u003c/p\u003e\u003cp\u003eСкоро выложу несколько примеров задач с решениями с использованием опубликованного \u003ca href\u003d\"https://github.com/WslF/SomeCode/blob/master/SegmentTree.cpp\"\u003eкласса\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eP.S. Буду рад конструктивным замечаниям/предложениям по написанию статьи/кода\u003c/p\u003e\u003cp\u003eUPD: вот \u003ca href\u003d\"//codeforces.com/blog/entry/12847\"\u003eпримеры\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["дерево отрезков","картинки","код","segment tree"]}}