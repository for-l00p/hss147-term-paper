{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1507358594,"rating":0,"authorHandle":"Messi","modificationTimeSeconds":1507960527,"id":55025,"title":"\u003cp\u003eРазбор контеста Contest 07.10.2017 (ACM) \u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cem\u003e\u003cstrong\u003eA. Количество позиций\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\u003cp\u003eМожно было перебирать каждую позицию и проверять подходит ли она под условия a ≤  i - 1 и n - i ≤ b (для i от 1 до n). Первое условие можно преобразовать в a + 1 ≤ i, а условие n - i ≤ b в n - b ≤ i, тогда общее условие можно записать max(a + 1, n - b) ≤ i и тогда наш ответ можно вычислить по формуле n - max(a + 1, n - b) + 1. \u003ca href\u003d\"//codeforces.com/contest/124/submission/835581\"\u003eАвторское решение\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003e\u003cstrong\u003eB. Игра с бумагой\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\u003cp\u003eIt’s easy to see that described process is equivalent to the following loop:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ewhile a \u0026gt; 0 and b \u0026gt; 0:\n    if a ⩾ b:\n         a \u003d a - b\n    else:\n         b \u003d b - a\n    ans \u003d ans + 1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut such naive approach will obviously lead to verdict TLE, since it makes ~10, 2015 - 03 - 1912 operations even on the third sample test. The key idea is to replace repeating subtraction operations with integer division operations. This leads to the logarithmic-time solution that looks similar to the Euclid algorithm:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ewhile a \u0026gt; 0 and b \u0026gt; 0:\n    if a ⩾ b:\n        ans \u003d ans + a div b\n        a \u003d a mod b\n    else:\n        ans \u003d ans + b div a\n        b \u003d b mod a\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eC. Задача Бахгольда\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВ данной задаче требовалось разложить число N (1 \u0026lt; N) на максимальное число простых слагаемых, необязательно различных.\u003c/p\u003e\u003cp\u003eЗаметим, что если N — четное, то в его разложении мы можем использовать только 2 — минимальное простое. Так как оно минимальное, то и количество слагаемых будет максимально возможным.\u003c/p\u003e\u003cp\u003eДля нечетного случая необходимо заметить, что мы можем представить это, как разложение числа N - 1 на все 2 c заменой последнего слагаемого с 2 на 3.\u003c/p\u003e\u003cp\u003eОчевидно, что использование любого другого простого числа лишь уменьшит количество слагаемых, так как уже третье простое число 5 представимо в виде суммы двух простых 2 и 3.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eD. Т-простые числа\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eМожно показать, что Т-простыми являются только квадраты простых чисел, и их не так и много — столько, сколько есть простых чисел, не больших \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9b/2a/9b2a790c1c22e01d5bd845aa03ede7423d12e465.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003d \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e. Вычислим все эти числа (например, с помощью решета Эратосфена) и запишем в массив или std::set, тогда на каждый запрос можно отвечать, просто проверяя (двоичным поиском для версии с массивом), есть ли данное число среди заранее вычисленных.\u003c/p\u003e\u003cp\u003eСложность решения линейная от \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e — \u003cem\u003eO\u003c/em\u003e(\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6e/c4/6ec4380efe55c2469d9cb5a5f9dcf98c45515824.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e) или \u003cem\u003eO\u003c/em\u003e(\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/80/01/8001a5a7cde77f2d1397a962cc5afd101cb1024a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e), где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e \u003d \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e12\u003c/sup\u003e\u003c/span\u003e можно вывести и более точную оценку). \u003ca href\u003d\"https://pastebin.com/WPTQycY4\"\u003eКод решения\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eE. Праздник равенства\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eРаз не можем уменьшать числа, то нам придётся увеличить все числа как минимум до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e,  \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e,  ...,  \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e. Если все числа равны \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e,  \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e,  ...,  \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e, то их не имеет смысла увеличивать дальше, так как мы на это только потратим лишние бурли.\u003c/p\u003e\u003cp\u003eТаким образом, следует найти \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e,  \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e,  ...,  \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e с помощью одного прохода по массиву. И потом ещё раз пройти, прибавляя к общей сумме разность максимального элемента и очередного. То есть, посчитав \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/span\u003e, для очередного элемента количество бурлей затраченных на его увеличение равно \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/span\u003e - \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Таким образом, ответ будет равен сумма всех \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003emax\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e для \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eАсимптотика такого решения — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eF. Dreamoon и ступеньки\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eWe can show that the maximum number of moves possible is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and minimal moves needed is , so the problem equals to determine the minimal integer that is a multiple of m in the range .\u003c/p\u003e\u003cp\u003eOne way to find the minimal number which is a multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e and greater than or equal to a number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is , we can compare this number to the upper bound \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e to determine if there is a valid solution.\u003c/p\u003e\u003cp\u003eAlthough best practice is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e enumeration of each possible number of moves would also work.\u003c/p\u003e\u003cp\u003etime complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e\u003c/p\u003e\u003cp\u003esample code: \u003ca href\u003d\"https://pastebin.com/6i6hkaDQ\"\u003eКод решения\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eG. Куплю лопату\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВ этой задаче необходимо найти такое минимальное \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, чтобы выполнялось одно из следующих равенств: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e·\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e mod 10 \u003d 0 или же \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e·\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e mod 10 \u003d r. Можно легко увидеть, что такое \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e всегда существует и оно не может превышать 10, потому что \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e·10\u003c/span\u003e mod 10 \u003d 0. Переберём \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e циклом, если для текущего \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e одно из неравенств выполняется, выводим ответ. Асимптотика такого решения — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e\u003c/span\u003e(const), где const \u003d 10.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eH. Чет и нечет\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВ задаче про четные и нечетные числа требуется понять, как будет выглядеть последовательность чисел от 1 до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, если выписать сначала все нечетные числа, а затем — четные. Для того, чтобы определить, какое число стоит на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e-м месте, нужно посчитать индекс в массиве, с которого начнутся четные числа, и вывести соответствующее \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e либо нечетное число из первой половины массива, либо четное из второй.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eI. Они повсюду\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eСначала найдем все различные буквы, которые есть в строке. Сделать это можно с помощью массива для букв или множества. Затем заведем массив \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e равно минимальной длине подстроки, которая заканчивается в позиции \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e и содержит все различные буквы, имеющиеся в строке. Если для какой-то позиции \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e такой подстроки нет, будем хранить в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e какое-нибудь больше число, большее длины строки, например, \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eТеперь нужно перебрать все различные буквы строки в любом порядке. Пусть текущая буква равна \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e. Проитерируемся по строке слева направо и будем хранить в переменной \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elast\u003c/i\u003e\u003c/span\u003e последнее вхождение буквы \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e. Изначально \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elast\u003c/i\u003e\u003c/span\u003e \u003d  - 1. Пусть текущая позиции строки равна \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e \u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e выполним присвоение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elast\u003c/i\u003e\u003c/span\u003e \u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Если для текущей позиции \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e значение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elast\u003c/i\u003e\u003c/span\u003e равно  -1 нужно выполнить присвоение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e \u003d \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e (так как нет ни одной подстроки, заканчивающейся в позиции \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e и содержащей все различные буквы исходной строки). В противном случае, нужно обновить \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e \u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(\u003ci\u003elen\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e],  \u003ci\u003ei\u003c/i\u003e  -  \u003ci\u003elast\u003c/i\u003e  +  1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eОтветом будет минимальное значение среди всех элементов массива \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e после рассмотрения всех различных букв.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eJ. Точки на прямой\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eПереберем правую точку из тройки, при этом будем поддерживать указатель на самую левую точку, которая отстоит от текущей на расстояние не большее, чем d. Мы легко можем определить количество точек внутри отрезка между двумя указателями (не включая правую точку). Обозначим это количество через k. Тогда ясно, что существует ровно k * (k - 1) / 2 троек точек, в которых самая правая точка совпадает с текущей, которую мы перебираем. Осталось просуммировать ответы для всех таких точек.\u003c/p\u003e\u003c/div\u003e","tags":["теория чисел","нод","простые числа","бинарный поиск","два указателя"]}}