{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1433950606,"rating":35,"authorHandle":"HYEA","modificationTimeSeconds":1433951202,"id":18462,"title":"\u003cp\u003eSplay tree and its implementation.\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI chose Splay tree as my Balanced Binary Search Tree if I have to implement it.\u003c/p\u003e\u003cp\u003eThere are few reasons.\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eIt always give amortized O(lg n) time complexity.  This is reason why I\u0027m not using treap or skip list. But I think skip list is meaningful than only usage for BBST.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIt is easy to remember.  Unlike other balanced binary tree, such as Red-black tree or AVL tree or 2-3 tree, it has same logic for searching, finding and deleting. Also, Making node as root is straight-forward.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eI have implemented Red-black tree once with guidebook in IOI training camp. It took long. (maybe 2h?) But I implemented Splay tree with only 1h in my first implementation. I only saw wikipedia once to implement it just before I started to code.\u003c/p\u003e\u003cp\u003eMy code is following.\u003c/p\u003e\u003cp\u003eIts major part is Splay and It is very simple! Anything other is same with just BST.\u003c/p\u003e\u003cp\u003eMaybe implementation of Erase is easier than other BST.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;cstdio\u0026gt;\n#include\u0026lt;cstdlib\u0026gt;\nstruct Node{\n\tNode *l;\n\tNode *r;\n\tNode *p;\n\tint v;\n};\nNode *root;\nvoid rightRotate(Node *P)\n{\n\tNode *T\u003dP-\u0026gt;l;\n\tNode *B\u003dT-\u0026gt;r;\n\tNode *D\u003dP-\u0026gt;p;\n\tif(D)\n\t{\n\t\tif(D-\u0026gt;r\u003d\u003dP) D-\u0026gt;r\u003dT;\n\t\telse D-\u0026gt;l\u003dT;\n\t}\n\tif(B)\n\t\tB-\u0026gt;p\u003dP;\n\tT-\u0026gt;p\u003dD;\n\tT-\u0026gt;r\u003dP;\n\t\n\tP-\u0026gt;p\u003dT;\n\tP-\u0026gt;l\u003dB;\n}\nvoid leftRotate(Node *P)\n{\n\tNode *T\u003dP-\u0026gt;r;\n\tNode *B\u003dT-\u0026gt;l;\n\tNode *D\u003dP-\u0026gt;p;\n\tif(D)\n\t{\n\t\tif(D-\u0026gt;r\u003d\u003dP) D-\u0026gt;r\u003dT;\n\t\telse D-\u0026gt;l\u003dT;\n\t}\n\tif(B)\n\t\tB-\u0026gt;p\u003dP;\n\tT-\u0026gt;p\u003dD;\n\tT-\u0026gt;l\u003dP;\n\t\n\tP-\u0026gt;p\u003dT;\n\tP-\u0026gt;r\u003dB;\n}\n\nvoid Splay(Node *T)\n{\n\twhile(true)\n\t{\n\t\tNode *p\u003dT-\u0026gt;p;\n\t\tif(!p) break;\n\t\tNode *pp\u003dp-\u0026gt;p;\n\t\tif(!pp)//Zig\n\t\t{\n\t\t\tif(p-\u0026gt;l\u003d\u003dT)\n\t\t\t\trightRotate(p);\n\t\t\telse\n\t\t\t\tleftRotate(p);\n\t\t\tbreak;\n\t\t}\n\t\tif(pp-\u0026gt;l\u003d\u003dp)\n\t\t{\n\t\t\tif(p-\u0026gt;l\u003d\u003dT)\n\t\t\t{//ZigZig\n\t\t\t\trightRotate(pp);\n\t\t\t\trightRotate(p);\n\t\t\t}\n\t\t\telse\n\t\t\t{//ZigZag\n\t\t\t\tleftRotate(p);\n\t\t\t\trightRotate(pp);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(p-\u0026gt;l\u003d\u003dT)\n\t\t\t{//ZigZag\n\t\t\t\trightRotate(p);\n\t\t\t\tleftRotate(pp);\n\t\t\t}\n\t\t\telse\n\t\t\t{//ZigZig\n\t\t\t\tleftRotate(pp);\n\t\t\t\tleftRotate(p);\n\t\t\t}\n\t\t}\n\t}\n\troot\u003dT;\n}\nvoid Insert(int v)\n{\n\tif(!root)\n\t{\n\t\troot\u003d(Node *)malloc(sizeof(Node));\n\t\troot-\u0026gt;l\u003dNULL;\n\t\troot-\u0026gt;r\u003dNULL;\n\t\troot-\u0026gt;p\u003dNULL;\n\t\troot-\u0026gt;v\u003dv;\n\t\treturn;\n\t}\n\tNode *P\u003droot;\n\twhile(true)\n\t{\n\t\tif(P-\u0026gt;v\u003d\u003dv) break; // not multiset\n\t\tif(v \u0026lt; (P-\u0026gt;v) )\n\t\t{\n\t\t\tif(P-\u0026gt;l) P\u003dP-\u0026gt;l;\n\t\t\telse\n\t\t\t{\n\t\t\t\tP-\u0026gt;l\u003d(Node *)malloc(sizeof(Node));\n\t\t\t\tP-\u0026gt;l-\u0026gt;p\u003dP;\n\t\t\t\tP-\u0026gt;l-\u0026gt;r\u003dNULL;\n\t\t\t\tP-\u0026gt;l-\u0026gt;l\u003dNULL;\n\t\t\t\tP-\u0026gt;l-\u0026gt;v\u003dv;\n\t\t\t\tP\u003dP-\u0026gt;l;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(P-\u0026gt;r) P\u003dP-\u0026gt;r;\n\t\t\telse\n\t\t\t{\n\t\t\t\tP-\u0026gt;r\u003d(Node *)malloc(sizeof(Node));\n\t\t\t\tP-\u0026gt;r-\u0026gt;p\u003dP;\n\t\t\t\tP-\u0026gt;r-\u0026gt;r\u003dNULL;\n\t\t\t\tP-\u0026gt;r-\u0026gt;l\u003dNULL;\n\t\t\t\tP-\u0026gt;r-\u0026gt;v\u003dv;\n\t\t\t\tP\u003dP-\u0026gt;r;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tSplay(P);\n}\nvoid Inorder(Node *R)\n{\n\tif(!R) return;\n\tInorder(R-\u0026gt;l);\n\tprintf(\u0026quot;v: %d \u0026quot;,R-\u0026gt;v);\n\tif(R-\u0026gt;l) printf(\u0026quot;l: %d \u0026quot;,R-\u0026gt;l-\u0026gt;v);\n\tif(R-\u0026gt;r) printf(\u0026quot;r: %d \u0026quot;,R-\u0026gt;r-\u0026gt;v);\n\tputs(\u0026quot;\u0026quot;);\n\tInorder(R-\u0026gt;r);\n}\nNode* Find(int v)\n{\n\tif(!root) return NULL;\n\tNode *P\u003droot;\n\twhile(P)\n\t{\n\t\tif(P-\u0026gt;v\u003d\u003dv)\n\t\t\tbreak;\n\t\tif(v\u0026lt;(P-\u0026gt;v))\n\t\t{\n\t\t\tif(P-\u0026gt;l)\n\t\t\t\tP\u003dP-\u0026gt;l;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(P-\u0026gt;r)\n\t\t\t\tP\u003dP-\u0026gt;r;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tSplay(P);\n\tif(P-\u0026gt;v\u003d\u003dv) return P;\n\telse return NULL;\n}\nbool Erase(int v)\n{\n\tNode *N\u003dFind(v);\n\tif(!N) return false;\n\tSplay(N); //check once more;\n\tNode *P\u003dN-\u0026gt;l;\n\tif(!P)\n\t{\n\t\troot\u003dN-\u0026gt;r;\n\t\troot-\u0026gt;p\u003dNULL;\n\t\tfree(N);\n\t\treturn true;\n\t}\n\twhile(P-\u0026gt;r) P\u003dP-\u0026gt;r;\n\tif(N-\u0026gt;r)\n\t{\n\t\tP-\u0026gt;r\u003dN-\u0026gt;r;\n\t\tN-\u0026gt;r-\u0026gt;p\u003dP;\n\t}\n\troot\u003dN-\u0026gt;l;\n\troot-\u0026gt;p\u003dNULL;\n\tfree(N);\n\treturn true;\n}\nint main()\n{\n\twhile(true)\n\t{\n\t\tint t;\n\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;t);\n\t\tif(t!\u003d0 \u0026amp;\u0026amp; t!\u003d-1) Insert(t);\n\t\telse if(t\u003d\u003d0)\n\t\t{\n\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;t);\n\t\t\tif(!Find(t))\n\t\t\t\tprintf(\u0026quot;Couldn\u0027t Find %d!\\n\u0026quot;,t);\n\t\t\telse\n\t\t\t\tprintf(\u0026quot;Found %d!\\n\u0026quot;,t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;t);\n\t\t\tif(Erase(t))\n\t\t\t\tprintf(\u0026quot;Deleted %d!\\n\u0026quot;,t);\n\t\t\telse\n\t\t\t\tprintf(\u0026quot;Couldn\u0027t Find %d!\\n\u0026quot;,t);\n\t\t}\n\t\tif(root) printf(\u0026quot;root: %d\\n\u0026quot;,root-\u0026gt;v);\n\t\tInorder(root);\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["splay tree","bbst","implementation"]}}