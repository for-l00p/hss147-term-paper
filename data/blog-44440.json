{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1461074730,"rating":52,"authorHandle":"AngryBacon","modificationTimeSeconds":1461075582,"id":44440,"title":"\u003cp\u003eConstruct Suffix Automaton for a Trie\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi,\u003c/p\u003e\u003cp\u003eLike some other suffix data structures, suffix automaton can be applied to a trie naturally. It is obvious that the number of states and transitions are linear.\u003c/p\u003e\u003cp\u003eThere\u0027s a natural construction algorithm. Let SAM(T) be the suffix automaton for trie T. If we add a new leaf v to trie T, whose father is u with character c. We can obtain SAM(T add v) by the almost same extend function:\u003c/p\u003e \u003cp\u003eHere is an example of extend function, \u0027last\u0027 is the corresponding state after u added:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\nint sa_extend (int last, char c) {\n\tint cur \u003d sz++;\n\tst[cur].len \u003d st[last].len + 1;\n\tint p;\n\tfor (p\u003dlast; p!\u003d-1 \u0026amp;\u0026amp; !st[p].next.count(c); p\u003dst[p].link)\n\t\tst[p].next[c] \u003d cur;\n\tif (p \u003d\u003d -1)\n\t\tst[cur].link \u003d 0;\n\telse {\n\t\tint q \u003d st[p].next[c];\n\t\tif (st[p].len + 1 \u003d\u003d st[q].len)\n\t\t\tst[cur].link \u003d q;\n\t\telse {\n\t\t\tint clone \u003d sz++;\n\t\t\tst[clone].len \u003d st[p].len + 1;\n\t\t\tst[clone].next \u003d st[q].next;\n\t\t\tst[clone].link \u003d st[q].link;\n\t\t\tfor (; p!\u003d-1 \u0026amp;\u0026amp; st[p].next[c]\u003d\u003dq; p\u003dst[p].link)\n\t\t\t\tst[p].next[c] \u003d clone;\n\t\t\tst[q].link \u003d st[cur].link \u003d clone;\n\t\t}\n\t}\n\treturn cur;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI applied this method successfully on some problems. However, how to analyse the time complexity? The amortized analysis of the \u0027redirect operation\u0027 can not be applied to a trie at first glance. If the time complexity is actually not linear, how to hack it?\u003c/p\u003e\u003c/div\u003e","tags":["suffix automaton","string algorithms","algorithm complexity"]}}