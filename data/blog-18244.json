{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1433043078,"rating":0,"authorHandle":"t3rminated","modificationTimeSeconds":1433043727,"id":18244,"title":"\u003cp\u003eA Problem on Perfect Matching\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI was solving \u003ca href\u003d\"http://www.codechef.com/JAN14/problems/SEAGRP/\"\u003ethis\u003c/a\u003e its problem on perfect matching in a graph.I have to tell whether a graph can be perfect matched.I used \u003ca href\u003d\"http://en.wikipedia.org/wiki/Tutte_matrix\"\u003etutte matrix\u003c/a\u003e and \u003ca href\u003d\"http://en.wikipedia.org/wiki/Gaussian_elimination\"\u003eGaussian elimination\u003c/a\u003e method to find whether a perfect matching exists but i don\u0027t know why my code doesn\u0027t works , please help!\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\nusing namespace std;\n\n#define ll long long\n#define mod 10000+7\n#define MAX 101\nll r,i,j,k;\n\nll lcm(ll x,ll y)\n{\n    ll t;\n    while (y !\u003d 0)\n    {\n      t\u003dy;\n      y\u003dx%y;\n      x\u003dt;\n    }\n    return x;\n}\nll random_number_generator()\n{\n\t// Declare variable to hold seconds on clock.\n\ntime_t seconds;\n\n// Get value from system clock and\n// place in seconds variable.\n\ntime(\u0026amp;seconds);\n\n// Convert seconds to a unsigned\n// integer.\n\nsrand((unsigned ll) seconds);\n\n// Output random values.\n\nreturn (rand()+mod) % mod;\n}\n\nll det(ll a[101][101]) /*this code converts mtrix to upper triangle so dterminant can be found by taking product of just diagonal elements*/\n{ll l,d1,d2;\n for(i\u003d0;i\u0026lt;r-1;i++)\n       {\n           for(j\u003di+1;j\u0026lt;r;j++)\n           {\n             l\u003dlcm(a[i][i],a[j][i]);\n             if(l!\u003d0\u0026amp;\u0026amp;(a[i][i]!\u003d0\u0026amp;\u0026amp;a[j][i]!\u003d0))\n             {\n               l\u003d(a[i][i]*a[j][i])/l;\n               d1\u003dl/a[i][i];\n               d2\u003dl/a[j][i];\n               a[j][i]\u003d0;\n               for(k\u003di+1;k\u0026lt;r;k++)\n               {\n                 a[j][k]\u003d(d2*a[j][k])-(d1*a[i][k]);\n               }\n             }\n           }\n        }\n        ll p \u003d1;\n        for(int i \u003d 0 ;i \u0026lt; r; i++)\n        {\n        \t\n        \tp \u003d (p * a[i][i]+mod)%mod;\n        \tp \u003d (p * a[i][r-1-i] + mod)%mod;\n        }\n        return p;\n} \n\nint main(int argc, char const *argv[])\n{\n\tll t;\n\tcin \u0026gt;\u0026gt; t;\n\n\twhile(t--)\n\t{\n\t\tll n , m;\n\t\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\n\t\tr\u003dn;\nll a[101][101];\n\n\t\tfor(ll i \u003d 0; i \u0026lt;\u003d n; i++)\n\t\t{\n\t\t\tfor(ll j \u003d 0; j \u0026lt;\u003d n; j++)\n\t\t\t\ta[i][j] \u003d 0;\n\t\t}\n\n\t\tll rnd \u003d random_number_generator();\n\n\t\twhile(m--)\n\t\t{\n\t\t\tll x , y;\n\t\t\tcin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n\t\t\tx--;y--;\n\t\t\tll rnd \u003d random_number_generator();\n\n\t\t\tif(x \u0026lt; y)\n\t\t\t\ta[x][y] \u003d (rnd);\n\t\t\telse if(x \u0026gt; y)\n\t\t\t\ta[x][y] \u003d (-rnd);\n\n\t\t\ta[y][x] \u003d -a[x][y];\n\t\t}\n\n\t\tll dete \u003d det(a);\n\n\t\tif(dete \u003d\u003d 0)\n\t\t\tcout \u0026lt;\u0026lt; \u0026quot;NO\u0026quot; \u0026lt;\u0026lt; endl;\n\t\telse\n\t\t\tcout \u0026lt;\u0026lt; \u0026quot;YES\u0026quot; \u0026lt;\u0026lt; endl;\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["tutte matrix","gaussian elimination","perfect matching","codechef"]}}