{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1491032215,"rating":1,"authorHandle":"TripleM5da","modificationTimeSeconds":1491037907,"id":51361,"title":"\u003cp\u003eMentors Weekly Contest #4 — Introducing Floyd — Warshall.\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eProblem A:\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eyou just need to notice that this is a modified LCS problem between alphabetical string and a string given to you so at each step holding current index of string and current index of alphabetical string called \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eidx\u003c/i\u003e1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eidx\u003c/i\u003e2\u003c/span\u003e you can skip the current letter and add to your answer solve(idx1, idx2 + 1) or skip the current element from the string solve(idx1 + 1, idx2) or if s1[idx1] is equal to s2[idx2] you can solve(idx1 + 1, idx2 + 1).\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem B:\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eyou just need to check every contiguous sub — sequence of size k from left to right if the number of lights is less than 2 just use a greedy approach and light the last house then the one before until the number is equal to 2 it to switch between a sub — sequence and the next on in O(1) you just need to add a[i] to your current sum and subtract a[i — k] from it.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem C:\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003ethis is also a modified knapsack problem so you can use backtrack to find the all the sums and on your path mark those who you visited and at the end of the array backtrack on those who you didn\u0027t visit and find if you can make a sum equal to the sum of those who you visited by using elements you didn\u0027t visit then save all the sums you can make and move with all the sums on the bars array and add (bar[i] + sum[i]) to a set and just print the size of the set at the end.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem D:\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eNow this is an interesting problem to solve first there is a little observation the maximum sum of digits you can have in a number is 108 in the number 99999999 using this you can just fix the length of the number and it\u0027s sum and use dynamic programming to count how many numbers with length i and sum j are divisible by j and less than the number given with a state being current index , current sum , mod (aka : current num % j), is the number less than number.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem E:\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eNow this problem is pretty straight forward and the problem would be in implementation so first for the problem solution, first you need to take the houses that are positioned before the station in an array and those after it in another separate array after that you just need to process every house from farthest to closest for more details on how to do that here is my implementation for this problem. \u003ca href\u003d\"http://ideone.com/4mgEsT\"\u003ehttp://ideone.com/4mgEsT\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem F:\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eAnother straight forward problem however this one is easy to implement noticing that as the time increases the number of computers set — up increases means that the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003etime\u003c/i\u003e)\u003c/span\u003e is a monotonic function where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003etime\u003c/i\u003e)\u003c/span\u003e \u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etime\u003c/i\u003e / \u003ci\u003eX\u003c/i\u003e\u003c/span\u003e + \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etime\u003c/i\u003e / \u003ci\u003eY\u003c/i\u003e\u003c/span\u003e so we can use lower bound binary search to find the lowest time at which \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e ≤ \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003etime\u003c/i\u003e)\u003c/span\u003e. \u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem G:\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eSomething that surprised me during the contest was that there was actually no submissions in this problem with it being an ace, if we know that there is a number which will be added \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e times and another one which will be added \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 2\u003c/span\u003e times why not maximize those number so we just need to sort the array given to us and add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eai\u003c/i\u003e * (\u003ci\u003ei\u003c/i\u003e - 1)\u003c/span\u003e to the answer.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem H:\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eafter a little brute force you can find that the answer depends on integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e where x \u003d n%4. if x \u003d 1 answer is 8, if x \u003d 2 answer is 4, if x \u003d 3 answer \u003d 2 if x \u003d 0 answer is 6, of course if n \u003d\u003d 0 answer is 1. however here we are dealing with strings so to find the modulus of a string you need to loop on all it\u0027s digits from left to right with an integer and update this integer like this x \u003d (x * 10 + (s[i] — \u00270\u0027) ) % mod.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem I:\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTODO.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem H:\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTODO.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem K:\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eif we describe this problem with no update the easy part would be to check every substring of length 7 if it\u0027s equal to \u0026quot;Desmond\u0026quot; now about the updates we know that the parts that are affected by the updates are the parts which this letter are in which are at most 13 substring so we just need to check all substrings which the letter is there.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem L:\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eOur highlight of the Contest the Graph Problem first if you don\u0027t know Floyd — Warshall you need to read the blog which is/(is going to be) posted about it.\u003c/p\u003e\u003cp\u003econsidering that the number of nodes is \u003cspan class\u003d\"tex-span\"\u003e ≤ \u003c/span\u003e 100 we can just run Floyd on the whole graph and the find the shortest path between any two nodes in O(1).\u003c/p\u003e\u003cp\u003eafter that we use dynamic programming with a state of (current index, current town, where_i_need_to_go) so first we check if i don\u0027t have anything loaded i can only go to the source of the current index and save the destination in and go to state current_idx + 1, source[current_index], dest[current_index] with cost dist[cur_town][source[cur_idx]] else i can do a thing of two either go to the destination i need to go to then i go to state (cur_idx, where_i_need_to_go, 0(aka:nothing loaded)) with cost dp[cur_town][where_i_need_to_go].\u003c/p\u003e\u003cp\u003eor i go load the current source then from the source deliver the one that was loaded first to go to state(cur_idx + 1, where_i_need_to_go, dest[cur_idx]) with cost dist[cur_town][source[cur_idx]] + dist[source[cur_idx]][where_i_need_to_go] and minimze on the answers.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}