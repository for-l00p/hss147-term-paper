{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1497922001,"rating":0,"authorHandle":"Shade100","modificationTimeSeconds":1497922001,"id":52754,"title":"\u003cp\u003eSuffix Array Help\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi! I\u0027m having trouble understanding this \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e implementation of suffix array construction :\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#define MAX_N 100010 // second approach: O(n log n)\nchar T[MAX_N]; // the input string, up to 100K characters\nint n; // the length of input string\n\nint RA[MAX_N], tempRA[MAX_N]; // rank array and temporary rank array\nint SA[MAX_N], tempSA[MAX_N]; // suffix array and temporary suffix array\n\nint c[MAX_N]; // for counting/radix sort\n\nvoid countingSort(int k) { // O(n)\n\n    int i, sum, maxi \u003d max(300, n); // up to 255 ASCII chars or length of n\n    memset(c, 0, sizeof c); // clear frequency table\n\n    for (i \u003d 0; i \u0026lt; n; i++){ // count the frequency of each integer rank\n        c[i + k \u0026lt; n ? RA[i + k] : 0]++;\n    }\n    for (i \u003d sum \u003d 0; i \u0026lt; maxi; i++) {\n        int t \u003d c[i]; c[i] \u003d sum; sum +\u003d t; \n    }\n    for (i \u003d 0; i \u0026lt; n; i++){ // shuffle the suffix array if necessary\n        tempSA[c[SA[i]+k \u0026lt; n ? RA[SA[i]+k] : 0]++] \u003d SA[i];\n    }\n    for (i \u003d 0; i \u0026lt; n; i++){ // update the suffix array SA\n        SA[i] \u003d tempSA[i];\n    }\n}\n\nvoid constructSA() { // this version can go up to 100000 characters\n    int i, k, r;\n    for (i \u003d 0; i \u0026lt; n; i++) RA[i] \u003d T[i]; // initial rankings\n    for (i \u003d 0; i \u0026lt; n; i++) SA[i] \u003d i; //initial SA: {0, 1, 2, ..., n-1}\n\n    for (k \u003d 1; k \u0026lt; n; k \u0026lt;\u0026lt;\u003d 1) { // repeat sorting process log n times\n        countingSort(k); //actually radix sort:sort based on the second item\n        countingSort(0); // then (stable) sort based on the first item\n\n        tempRA[SA[0]] \u003d r \u003d 0; // re-ranking; start from rank r \u003d 0\n\n        // compare adjacent suffixes\n        for (i \u003d 1; i \u0026lt; n; i++){\n            // if same pair \u003d\u0026gt; same rank r; otherwise,increase r\n            tempRA[SA[i]] \u003d (RA[SA[i]] \u003d\u003d RA[SA[i-1]] \u0026amp;\u0026amp; RA[SA[i]+k] \u003d\u003d RA[SA[i-1]+k]) ? r : ++r;           \n        }\n\n        for (i \u003d 0; i \u0026lt; n; i++){// update the rank array RA\n            RA[i] \u003d tempRA[i];\n        }\n\n        if (RA[SA[n-1]] \u003d\u003d n-1) break; // nice optimization trick\n    } \n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eIn particular:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (i \u003d 0; i \u0026lt; n; i++) { // count the frequency of each integer rank\n\tc[i + k \u0026lt; n ? RA[i + k] : 0]++;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e is used as the rank for an empty string when it is also the rank of the smallest suffix, as seen below.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etempRA[SA[0]] \u003d r \u003d 0; // re-ranking; start from rank r \u003d 0\n\n// compare adjacent suffixes\nfor (i \u003d 1; i \u0026lt; n; i++) {\n\t// if same pair \u003d\u0026gt; same rank r; otherwise,increase r\n\ttempRA[SA[i]] \u003d (RA[SA[i]] \u003d\u003d RA[SA[i - 1]] \u0026amp;\u0026amp; RA[SA[i] + k] \u003d\u003d RA[SA[i - 1] + k]) ? r : ++r;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eSA\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] + \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e can go out of bounds.\u003c/p\u003e\u003cp\u003eThese seem like bugs, but the algorithm works, but strangely only when a sentinel character such as $ is appended to the end. Why?\u003c/p\u003e\u003cp\u003eThanks in advance!\u003c/p\u003e\u003c/div\u003e","tags":["suffix array","strings","help"]}}