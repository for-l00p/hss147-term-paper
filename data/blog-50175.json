{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1485963262,"rating":12,"authorHandle":"MathLimitExceeded","modificationTimeSeconds":1485963262,"id":50175,"title":"\u003cp\u003eChecking For Perfect Squares Without Overflows\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi\u003c/p\u003e\u003cp\u003eI am solving a problem that is conceptually simple.\u003c/p\u003e\u003cp\u003eGiven an integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, such that \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ex\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e17\u003c/sup\u003e\u003c/span\u003e, check if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e \u003d 5\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e + 2\u003ci\u003ex\u003c/i\u003e + 1\u003c/span\u003e is a perfect square. I have solved this using Big Integers and long doubles in C++ (with a binary search to find the root) and used PyPy to get it accepted in Python but I did not receive satisfaction in solving it this way.\u003c/p\u003e\u003cp\u003eAlso, \u003ccode\u003e__int128\u003c/code\u003e do not work on SPOJ for some reason :/\u003c/p\u003e\u003cp\u003eI think Big Integer may be an overkill for such a problem and the uncertainty with floating point precision is never re-assuring. Hence, my question is, is there any way to solve this problem without Big Integers or long doubles in C++?\u003c/p\u003e\u003cp\u003eThanks\u003c/p\u003e\u003c/div\u003e","tags":[]}}