{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1271430755,"rating":16,"authorHandle":"emo","modificationTimeSeconds":1271430858,"id":313,"title":"SRM - 467","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003eHere is the funny(?!) story behind of \u003ca href\u003d\"http://www.topcoder.com/stat?c\u003dcoder_room_stats\u0026amp;rd\u003d14151\u0026amp;cr\u003d22637798\"\u003emy SRM - 467\u003c/a\u003e\u003cbr /\u003e\u003cbr /\u003eLast night, after a very bad performance in codeforces beta round#10 I thought I am really in bad form and after having a very short sleep it could be even worse.\u003cbr /\u003e\u003cbr /\u003e\u003ch3\u003e250\u003c/h3\u003eThis problem is a combination of simulation and probability. I just simulate over all of the possible slots of walking ans sum up the region where Professor will encounter a late present by John. Late me call this region L, the late region. If i\u003csup\u003eth\u003c/sup\u003e slot of walking starts at t\u003csub\u003ei\u003c/sub\u003e then add overlapping region of [bestArrival, worstArrival] and [t\u003csub\u003ei\u003c/sub\u003e, t\u003csub\u003ei\u003c/sub\u003e + walkTime - lateTime] to the L. The result is L / (worstArrival - bestArrival). \u003cbr /\u003e\u003cbr /\u003eAfter quickly code this, I found that last two samples giving me wrong output and observed that bestArrival and worstArrival can be same. So I specially handle this case, as I know it will always return 1.0 or 0.0 in this special case.\u003cbr /\u003e\u003cbr /\u003eI found each of the idea of this problem quickly, but still it took 20 minutes. 20 long minutes before I submit.\u003cbr /\u003e\u003cbr /\u003e\u003ch3\u003e500\u003c/h3\u003eI was stuck here for a while and suddenly became excited, because I thought that I have discern a matrix exponentiation idea. After coding for a few minutes I realized that it is wrong. For thinking from beginning, I draw a table in paper and found that it is nothing but the well known problem, - \u0026quot;how many paths in a grid from (0, 0) to (M, N)\u0026quot;, the solution is choose(N + M, M). In this problem you can find easily that N \u003d n - 1, and M \u003d k + 1. Even after finding this it took me a while to understand that it will take only a loop of at most 50 iterations as k \u0026lt;\u003d 50 here. All I need is mod inverse, and as the number given to mod by is a prime, it is easy.  Thus I managed to submit just 2/3 minutes before coding phase ending.\u003cbr /\u003e\u003cbr /\u003e\u003ch3\u003e1000\u003c/h3\u003eI didn\u0027t open this problem. Most of the times I do not have time to open 1000. So no wonder at all.\u003cbr /\u003e\u003cbr /\u003e\u003ch3\u003eChallenge Phase\u003cbr /\u003e\u003c/h3\u003eI can\u0027t realize why I was so excited to challenge a correct solution. I can\u0027t even explain whats wrong I saw in that code. All I saw biginteger in that code and thought it will fail. Stupid me, just wasted 25 points, nothing else.\u003cbr /\u003e\u003cbr /\u003eI don\u0027t find any reason to get this story of an ordinary coder interesting. BTW, this was my 45th consecutive SRM. :)\u003cbr /\u003e\u003cbr /\u003econgratulations to \u003ca href\u003d\"http://www.topcoder.com/tc?module\u003dMemberProfile\u0026amp;cr\u003d22692969\"\u003erng_58\u003c/a\u003e for win \u003ca href\u003d\"http://www.topcoder.com/stat?c\u003dround_overview\u0026amp;rd\u003d14151\"\u003ethis match\u003c/a\u003e.\u003c/div\u003e","tags":["srm","проверяющая система","тестирование"]}}