{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1270165412,"rating":13,"authorHandle":"ItsNear","modificationTimeSeconds":1272005882,"id":245,"title":"Опять про C#, в этот раз хорошее :о)","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003eПеречитав все, чем я был недоволен С# тут я выяснил, что кроме отсутствия SortedSet, который был объявлен только в .NET 4.0, C# тут абсолютно perfect. CBR7 это подтвердил.\u003cbr /\u003e\u003cbr /\u003eХарактерно, что после всего четырех месяцев работы на C# я уже чуствую неудобство работы на других языках. Как однажды сказал один крутой (для меня :о)) ACM-щик, \u0026quot;я пишу не на С++, я пишу на STL\u0026quot;. Вот также и тут, я пишу не на C#, я пишу на Linq :о) Потому что без Linq С# это таже самая Java, только без BigInteger (BigInteger появился тоже только в .NET 4.0). И поэтому я должен сказать спасибо Михаилу,  так как реально сегодня нормальной версии C# с Linq почти нигде на регулярных соревнованиях нет (и на TC и у снарка C# cтарый, без Linq).\u003cbr /\u003e\u003cbr /\u003eТеперь немного рекламы. Почему же я тащусь от C#.\u003cbr /\u003e1. Мне не надо писать тип объекта, который я создаю. На С++ это не проблема, но на Java в принципе она проявляется, хотя, конечно, Java программисты на нее не обращают внимания. Допустим,\u003cbr /\u003eList\u0026lt;int\u0026gt; q \u003d new List\u0026lt;int\u0026gt;( );\u003cbr /\u003eТупо - я пишу тип дважды. Конечно, это плохой пример - любая интегрированная среда сразу после набора слова new предложит по Enter или типа того тим переменной, и реально человек наберет List\u0026lt;int\u0026gt; только однажны. Но что, если мне надо\u003cbr /\u003e(тип переменной) q \u003d SomeClass.SomeMethod( ).SomeOtherMethod( )...\u003cbr /\u003eЯ не хочу задумываться, какого типа будет возвращаемое значение этого SomeOtherMethod, я могу вообще теоретически не знать до набора этой строки, какой будет тип. В C# на этот случай есть ключевое слово var.\u003cbr /\u003evar lst \u003d new List\u0026lt;int\u0026gt;( );\u003cbr /\u003evar q \u003d SomeClass.SomeMethod( ).SomeOtherMethod( )...\u003cbr /\u003eВсегда, когда компилятор может сам понять тип переменной (то есть грубо говоря всегда, когда вы ее сразу инициализируете), ее тип можно не указывать лапками.\u003cbr /\u003e\u003cbr /\u003e2. Мне не надо создавать типы данных под все подряд\u003cbr /\u003eЯ хочу создать переменную, с тремя полями: id, x и y. Когда параметров два, C++ шники всегда юзают pair - это круто, в Java даже для двух надо делать отдельный тип. В любом случае, если полей три, то на C++ тоже надо создавать новый тип. На C# все проще\u003cbr /\u003evar q \u003d new { id \u003d 4, x \u003d 4, name \u003d 5 };\u003cbr /\u003eИ все, мне не надо проматывать код чтобы создать новый класс. Но вы не прочуствуете всей мощи этого, пока не прочитаете пункт 3.\u003cbr /\u003e\u003cbr /\u003e3. А теперь, когда у меня есть непонятные типы, я хочу их сортировать. Я не хочу переопределять операторы, мне лень это делать :о Приходит на помощь Linq. Допустим, что qs - это массив чего-то типа q, который я создал на прошлом шагу\u003cbr /\u003evar qs_sorted \u003d ( from q in qs orderby q.id select q );\u003cbr /\u003eИ все. Никаких переопределений операторов :о)\u003cbr /\u003eЯ хочу отфильтровать его, оставив только те, где x \u0026lt; 10?\u003cbr /\u003evar qs_filtered \u003d ( from q in qs where q.x \u0026lt; 10 orderby q.id select q );\u003cbr /\u003eЯ хочу при этом получить только x и y, и откинуть id?\u003cbr /\u003evar qs_xy \u003d ( from q in qs where q.x \u0026lt; 10 orderby q.id let x \u003d q.x let y \u003d q.y select new { x, y }  );\u003cbr /\u003e \u003cbr /\u003e4. Это уже не про язык или платформу, а про среду. Почему многие любят C++? Потому что там можно записать макросы для циклов. На топкодере почти у всех есть макрос для фора. Потому что в 90% случаев фор делается по проторенной дорожке for( i \u003d 0; i \u0026lt; n; ++ i ) или for( i \u003d n - 1; i \u0026gt;\u003d 0; -- i ). Меняется только i и n. Разумеется, у всех набита рука вбивать это дело, но хочется все-таки вбивать только i и n. Поэтому макросы типа FOR(i,n) или rep(i,n) или типа того очень популярны. В Visual Studio мы делаем так. Пишем for, дважды бьем кнопку Tab, нам сразу разворачивается вся конструкция и курсор установлен на то место, где мы хотим вбить название переменной. И название сразу i. Меняем название на j, все три вхождения i меняются на j. Жмем tab, попадаем на length, меняем length на то, что нам надо, скажем n, жмем Enter и попадаем в тело цикла. Надо цикл с конца - делаем все тоже самое, написав в начале forr вместо for. Эта фишка называется Code Snippets, и она реально крутая. Не удивлюсь, если в других средах разработки она тоже есть.\u003cbr /\u003e\u003cbr /\u003e5. Добавим к этому перегрузку операторов, которая все-таки есть, параметры по умолчанию для методов, причем более мощные, чем в C++ - грубо говоря вы не обязаны предоставлять параметры для функции по порядку, вы можете сделать 100 параметров, все с значениями по умолчанию, а потом вызвать эту функцию, передав только 18-ый и 99-ый. В С++ вы обязаны передавать параметры начиная с начала и поюзать значения по умолчанию только для подрядидущих с конца параметров.\u003cbr /\u003eНо видимо это все уже олимпиаднику не надо :о)\u003cbr /\u003e\u003cbr /\u003eС учетом SortedSet и BigInteger в .NET4.0 C# в принципе будет иметь все, что надо в стандартной библиотеке. Сегодня приходится использовать SortedDictionary вместо SortedSet, что немного тупо :о( И для длинной арифметики приходится писать на Java не редко.\u003cbr /\u003eКстати, в .NET 4.0 для BigInteger перегружены все опреаторы, и с ним можно тискаться как с любыми другими типами :о) Это вам не громоздкие конструкции на Java писать с тонной вызовов методов :о\u003c/div\u003e","tags":["c#"]}}