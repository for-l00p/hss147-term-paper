{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1275158277,"rating":14,"authorHandle":"Shtrix","modificationTimeSeconds":1275159138,"id":411,"title":"Короткий разбор задач CF #15","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv style\u003d\"text-align: left;\"\u003eА)          Необходимо было отсортировать все дома по возрастанию координаты центра х. Для каждой пары последовательных домов (x_i, a_i) и (x_(i+1), a_(i+1)) определить расстояние между домами:\u003c/div\u003e\u003cdiv style\u003d\"text-align: left;\"\u003ed \u003d x_(i + 1) - x_i + a_(i+1) / 2 + a_i / 2;\u003c/div\u003e\u003cdiv style\u003d\"text-align: left;\"\u003eесли d \u0026gt; T то ans \u003d ans + 2\u003c/div\u003e\u003cdiv style\u003d\"text-align: left;\"\u003eесли d \u003d\u003d T то ans \u003d ans + 1\u003c/div\u003e\u003cdiv style\u003d\"text-align: left;\"\u003eиначе ничего не делаем\u003c/div\u003e\u003cdiv\u003eв конце к ответу нужно было добавить два, чтобы еще закрыть крайние позиции.\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003eB)            Для простоты написания, нужно было заметить, что геометрическое место точек которые можно выжечь лазером это два прямоугольника. Оставалось только посчитать их суммарную площадь, что делается очень просто по формуле включения-исключения. И не забудьте про 64 битное целое!\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003eС)             Еще раз извиняюсь за ошибку в описании входа. Прочитав немного материала по теории игр и числам \u003ca href\u003d\"http://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%A8%D0%BF%D1%80%D0%B0%D0%B3%D0%B0-%D0%93%D1%80%D0%B0%D0%BD%D0%B4%D0%B8\"\u003eШпрага Гранди\u003c/a\u003e вам станет очевидно, что для решения этой задачи достаточно проксорить все числа: x_1, x_1 + 1, ... x_1+m_1-1, x_2, x_2 + 1, .. x_2+m_2 ... x_n, x_n + 1, ... x_n + m_n - 1 и определить является ли результат нулем или нет. Что правда учитывая их количество вам не удастся вложится в ТЛ. По-этому заметим что Вам требуется проксорить не просто какие-то числа, а несколько отрезков вида [x_i, x_i + m_i - 1]. Пускай f([a,b]) \u003d a^(a+1)^(a+2)..^(b - 1) ^ b.\u003c/div\u003e\u003cdiv\u003eТак как f([x_i, x_i + m_i - 1]) \u003d f([1, x_i + m_i - 1]) ^ f([1, x_i  - 1]); можно ксорить отрезок за О(1), учитывая то что f([1,x]) можно считать так:\u003c/div\u003e\u003cdiv\u003e\u003cdiv\u003eif (x mod 4 \u003d\u003d 0) f(x) \u003d x;\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003eif (x mod 4 \u003d\u003d 1) f(x) \u003d 1;\u003c/div\u003e\u003cdiv\u003eif (x mod 4 \u003d\u003d 2) f(x) \u003d x + 1;\u003c/div\u003e\u003cdiv\u003eif (x mod 4 \u003d\u003d 3) f(x) \u003d 0;\u003c/div\u003e\u003cdiv\u003eтогда имеем сложность решения О(N)\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003eD)              Решать ее стоило так:\u003c/div\u003e\u003cdiv\u003e1. Перебрать все левые верхние углы прямоугольников годных для размещения города и для каждого из них посчитать количество земли которую бы было необходимо вывезти для того, чтобы построить город. Для этого нам необходимо считать сумму на прямоугольнике и минимум. Первое делается частичными суммами, а второе на выбор либо \u003ca href\u003d\"http://e-maxx.ru/algo/segment_tree\"\u003eдвумерным деревом отрезков\u003c/a\u003e, либо для этого можно приспособить \u003ca href\u003d\"http://e-maxx.ru/algo/stacks_for_minima\"\u003eочередь с минимумом за О(1) \u003c/a\u003e(вместо нее также подойдет эмуляция ее с помощью STL-евских \u003ca href\u003d\"http://www.cplusplus.com/reference/stl/multiset/\"\u003emultiset\u003c/a\u003e и \u003ca href\u003d\"http://www.cplusplus.com/reference/stl/priority_queue/\"\u003epriority_queue\u003c/a\u003e).\u003c/div\u003e\u003cdiv\u003e2. После первого этапа необходимо собрать все данные в массив в форме (\u0026lt;количество вывезенной земли,  координата верхнего угла\u0026gt;) и отсортировать его в лексикографическом порядке (по увеличению количества земли).\u003c/div\u003e\u003cdiv\u003e3. Пройтись по уже отсортированному массиву проверяя можно ли поставить в данной клетке левый верхний угол города. Для этого нужно оценить не накладывается ли он на уже поставленный. Это можно делать заведя массив булеанов used[][] в котором будут отмечаться уже покрытые клетки. При добавлении города нужно будет просто оббегать весь прямоугольник и проставлять в его клетках true, а при запросе на возможность покрытия будем смотреть \u003cu\u003eтолько\u003c/u\u003e на угловые клетки. (Так \u0026quot;халтурить\u0026quot; можно потому что у нас все прямоугольники одинакового размера и статической ориентации). Не сложно посчитать, что таким образом будет выполнено в сумме не более N*M операций.\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003eE)           Можно было перейти к графу \u003ca href\u003d\"http://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C_%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%BE%D0%B2_%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D0%B8_%D0%B3%D1%80%D0%B0%D1%84%D0%BE%D0%B2\"\u003eдвойственному\u003c/a\u003e данному и обнаружить, что он дерево, а также установить взаимно однозначное соответствие между путями о которых шла речь в условии и не пустыми компонентами связности включающих корень данного дерева. Такие компоненты легко считать используя ДП по дереву: DP[u] \u003d (DP[child1] + 1) * (DP[child2] + 1), DP[leaf] \u003d 1. Но конечно такое решение не укладывалось в ТЛ и потому нужно было используя уравнение ДП свести к комбинаторной формуле благодаря рекуррентному соотношению между \u0026quot;нишами\u0026quot;(поддеревья которые идут от края карты вглубь). \u003c/div\u003e\u003c/div\u003e","tags":["cf beta round #15"]}}