{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1265126502,"rating":0,"authorHandle":"OSt","modificationTimeSeconds":1266696517,"id":43,"title":"Java vs C++ для промышленного программирования","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv class\u003d\"from-renderer\"\u003e\u003cp\u003eВсем привет. Продолжаю серию статей про любимый язык программирования.\u003c/p\u003e \u003cp\u003eНа этот раз коснёмся вечного вопроса \u0026quot;Java vs C++\u0026quot; в   масштабах промышленного программирования.\u003c/p\u003e \u003cp\u003e \u003c/p\u003e \u003cp\u003eХотя некоторые вещи касаются вполне и выбора языка на ранних стадиях   обучения, в том числе некоторые вещи применимы и для выбора языка для   олимпиад. Я собственно так и выбрал Java :)\u003c/p\u003e \u003cp\u003eСамым авторитетным для меня источником стала статья моего тренера -   Федора Владимировича Меньшикова. Эта статья как раз была и написана,   когда встал вопрос \u0026quot;Что изучать после Pascal\u0026quot; :)\u003c/p\u003e \u003cp\u003ePS: Все копирайты соблюдены. Статья публикуется с разрешения автора.\u003c/p\u003e \u003chr /\u003e \u003cp\u003e   \u003cbr /\u003e\u003c/p\u003e \u003cp\u003eВы интересовались, какой язык лучше изучать - C++ или Ява. Я написал   на \u003cbr /\u003eкаждом из них десятки тысяч строк кода, поэтому попробую   расписать \u003cbr /\u003eдостоинства и недостатки каждого.\u003cbr /\u003e   \u003cbr /\u003eНебольшой   обзор разницы идеологий языков далее.\u003cbr /\u003e   \u003cbr /\u003e   \u003cbr /\u003eРассмотрим вопрос применимости языков для промышленного   программирования - \u003cbr /\u003eсоздания программ в десятки и сотни тысяч   строк кода.\u003cbr /\u003e   \u003cbr /\u003eЯзыки будем сравнивать по двум критериям:\u003cbr /\u003e1. Как известно,   основное требование к программе - корректная работа. \u003cbr /\u003eПоэтому   основным критерием сравнения будет \u0026quot;насколько язык располагает к   \u003cbr /\u003eсовершению ошибок.\u0026quot;\u003cbr /\u003e2. Вторым фактором будет   \u0026quot;насколько удобно писать на языке\u0026quot;.\u003cbr /\u003e   \u003cbr /\u003e   \u003cbr /\u003eКритерий 1. Насколько язык располагает к совершению   ошибок.\u003cbr /\u003eОшибка 1.1. Обращение к чему-то несуществующему.\u003cbr /\u003e   \u003cbr /\u003eКогда происходит обращение к неизвестно чему, то и программа   работает \u003cbr /\u003eнеизвестно как. Скажем, в 255 случаях из 256 она может   работать, а в 1 \u003cbr /\u003eслучае может сбоить. А ещё это \u0026quot;неизвестно   что\u0026quot; может оказаться данными \u003cbr /\u003eдругого модуля программы.\u003cbr /\u003e   \u003cbr /\u003eОшибка 1.1.1. Обращение к несуществующему элементу массива.\u003cbr /\u003e   \u003cbr /\u003eЯзык Ява, как и C#, гарантирует, что при индексации массива   нельзя \u003cbr /\u003eобратиться к несуществующему элементу массива. Если   обращение к \u003cbr /\u003eнесуществующему элементу произошло, генерируется исключение.\u003cbr /\u003e   \u003cbr /\u003eЯзык C++ унаследовал классические массивы от языка Си, а в языке   Си \u003cbr /\u003eпроверки при индексации массива не только отсутствуют, но и   вообще \u003cbr /\u003eневозможны, поскольку в процедуры, например, не   передаётся длина \u003cbr /\u003eобрабатываемого массива, только ссылка на его начало.\u003cbr /\u003e   \u003cbr /\u003eОднако C++ не заставляет пользоваться классическими массивами.   На C++ можно \u003cbr /\u003eнаписать шаблон класса, имитирующего работу с   массивом с проверкой \u003cbr /\u003eдиапазонов. Всё различие будет заключаться   в описании переменной:\u003cbr /\u003eStaticArray\u0026lt;int, 5\u0026gt;   a;\u003cbr /\u003eвместо\u003cbr /\u003eint a[5];\u003cbr /\u003eа работа с таким   \u0026quot;массивом\u0026quot; может происходить ровно тем же образом, как   \u003cbr /\u003eработа с классическим массивом.\u003cbr /\u003e   \u003cbr /\u003eЯ для себя такой шаблон написал, и подобные шаблоны используются   в крупных \u003cbr /\u003eпроектах, однако для чего-нибудь маленького вроде   решения олимпиадной \u003cbr /\u003eзадачи такой способ сделать язык безопасным   не проходит - на написание \u003cbr /\u003eStaticArray никто не захочет тратить   такое драгоценное на олимпиаде время.\u003cbr /\u003e   \u003cbr /\u003eОшибка 1.1.2. Обращение к уже несуществующему объекту через указатель.\u003cbr /\u003e   \u003cbr /\u003eЯзык Ява, как и C#, гарантирует, что объект не удаляется, пока к   нему можно \u003cbr /\u003eобратиться через указатель. Поэтому обратиться к уже   удалённому объекту \u003cbr /\u003eневозможно.\u003cbr /\u003e   \u003cbr /\u003eВ языке C++ программист сам отвечает за удаление объектов, так   что никто \u003cbr /\u003eему не мешает создать два указателя на объект, через   один указатель этот \u003cbr /\u003eобъект удалить, а через второй потом   поработать с тем местом, где объект лежал.\u003cbr /\u003e   \u003cbr /\u003eОднако C++ не заставляет пользоваться классическими указателями.   В C++ \u003cbr /\u003eможно написать шаблон класса, имитирующего указатель с   проверкой отсутствия \u003cbr /\u003eобращений к объекту после его удаления. Ещё   большую ценность представляет \u003cbr /\u003eкласс так называемых   \u0026quot;умных\u0026quot; указателей, которые сами удаляют объекты, на   \u003cbr /\u003eкоторые указывают, как только исчезает последняя ссылка. Как и в   случае с \u003cbr /\u003eмассивами, всё различие в использовании такого шаблона   будет в описании \u003cbr /\u003eпеременной:\u003cbr /\u003ePtr\u0026lt;MyClass\u0026gt;   p;\u003cbr /\u003eвместо\u003cbr /\u003eMyClass *p;\u003cbr /\u003e   \u003cbr /\u003eЯ в большом проекте использую такой шаблон, но для чего-нибудь   маленького \u003cbr /\u003eвроде олимпиадных задач писать такой шаблон ну очень накладно.\u003cbr /\u003e   \u003cbr /\u003eОшибка 1.1.3. Удаление объекта изнутри его самогО.\u003cbr /\u003e   \u003cbr /\u003eКак я уже упоминал, в Яве программист не может сам удалить   объект, поэтому \u003cbr /\u003eпроблемы нет. А в C++ программист сам отвечает   за удаление объекта. Особый \u003cbr /\u003eслучай - когда прямо или косвенно   удаляется объект, в котором находится \u003cbr /\u003eисполнение. Проблема   заключается в том, что после удаления объекта все его \u003cbr /\u003eполя   являются недействительными, и после удаления самого себя нужно строго   \u003cbr /\u003eвыйти из процедуры, ни к чему больше не притрагиваясь. Как   правило это не \u003cbr /\u003eтак просто, если не знаешь, что ты себя удалил.   Решением является в том \u003cbr /\u003eобъекте, который провоцирует удаление,   проверять, не в удаляемом ли объекте \u003cbr /\u003eсейчас находится поток   управления. Решение работает, но такие проверки - \u003cbr /\u003eэто, конечно,   дополнительные усилия со стороны программиста.\u003cbr /\u003e   \u003cbr /\u003eОшибка 1.2. Использование неинициализированных переменных.\u003cbr /\u003e   \u003cbr /\u003eКак в случае с обращением к неизвестно чему (1.1.1) можно   получить \u003cbr /\u003eнеизвестно какой результат, так и в случае обращения к   переменной, в \u003cbr /\u003eкоторую значение не было занесено заранее, ничего   хорошего ждать не приходится.\u003cbr /\u003e   \u003cbr /\u003eВ Яве, как и в C#, гарантируется, что все поля объекта при   создании \u003cbr /\u003eзануляются. Если это int - значение 0, если boolean -   false, если объект - \u003cbr /\u003enull.\u003cbr /\u003e   \u003cbr /\u003eВ C++ зануления нет, и это очень опасно. Реально сталкивался с   проблемой \u003cbr /\u003eневоспроизводимых ошибок. При одном состоянии памяти   программа переходит в \u003cbr /\u003eсостояние ошибки, при другом состоянии   памяти замечательно работает. Ошибка \u003cbr /\u003eоказалась в отсутствии   инициализации поля в одном (!) из двух конструкторов.\u003cbr /\u003e   \u003cbr /\u003eОднако в C++ есть возможность переопределить операцию new, так   что она \u003cbr /\u003eбудет не только выделять память, но и занулять место под   динамической \u003cbr /\u003eпеременной. В моём проекте на C++ все классы   унаследованы от класса с таким \u003cbr /\u003eпереопределённым оператором new.\u003cbr /\u003e   \u003cbr /\u003eКак и в случае с прочими упоминавшимися возможностями, написание   такого \u003cbr /\u003eпереопределения оператора new дело не совсем тривиальное,   и в маленьких \u003cbr /\u003eпроектах вроде олимпиадных задач нет возможности   тратить на это время.\u003cbr /\u003e   \u003cbr /\u003eОшибка 1.3. Отсутствие удаления/закрытия ресурса.\u003cbr /\u003e   \u003cbr /\u003eЕсли по предыдущим пунктам могло сложиться впечатление, что Ява   намного \u003cbr /\u003eлучше C++, то этот пункт будет скорее в пользу C++.\u003cbr /\u003e   \u003cbr /\u003eКак выглядят внутренности обычной процедуры обработки   файла:\u003cbr /\u003e\u0026lt;открыть файл\u0026gt;\u003cbr /\u003e\u0026lt;читать и обрабатывать   данные\u0026gt;\u003cbr /\u003e\u0026lt;закрыть файл\u0026gt;\u003cbr /\u003e   \u003cbr /\u003eПока последовательность действий линейна, всё хорошо, открытый   файл будет \u003cbr /\u003eзакрыт. Но что если в ходе обработки файла случится   исключение или будет \u003cbr /\u003eжелание выйти через return из функции?   Будет ли файл корректно закрыт?\u003cbr /\u003e   \u003cbr /\u003eВ Яве для гарантированного закрытия таких ресурсов приходится   операторы \u003cbr /\u003e\u0026lt;читать и обрабатывать данные\u0026gt; заключать в блок   try-finally. На самом деле \u003cbr /\u003eне очень эстетично выглядит, а уж   когда несколько переменных таким образом \u003cbr /\u003eгарантированно закрыть   надо - тут уже синтаксис получается туши свет. И что \u003cbr /\u003eсамое   противное - ничто не обязывает программиста писать блок finally, так   \u003cbr /\u003eчто ничто не поддерживает систему гарантированного освобождения ресурсов.\u003cbr /\u003e   \u003cbr /\u003eВ C++ в смысле освобождения ресурсов всё, наоборот, хорошо. Язык   \u003cbr /\u003eгарантирует вызов деструкторов всех локальных объектов при   выходе из \u003cbr /\u003eпроцедуры любым способом - и через return, и через   исключение. Поэтому всё, \u003cbr /\u003eчто нужно - это обернуть ресурс в   объект, и в конструкторе объекта \u003cbr /\u003eпрописать открытие ресурса, а в   деструкторе - закрытие. И в тексте основной \u003cbr /\u003eпроцедуры не   появляется никаких finally, и где бы этот объект не   \u003cbr /\u003eиспользовался, везде при любых обстоятельствах освобождение   ресурса \u003cbr /\u003eгарантируется.\u003cbr /\u003e   \u003cbr /\u003eОшибка 1.4. Неожиданные для программиста свойства языка.\u003cbr /\u003e   \u003cbr /\u003eЯзык C++ имеет ряд особенностей, из-за которых программы могут   работать не \u003cbr /\u003eтак, как ожидает программист, а чтобы они работали   как надо нужно что-то \u003cbr /\u003eнеочевидное изменить. Такие особенности   просто нужно знать и учитывать. \u003cbr /\u003eПроблема в том, что люди,   начинающие писать на C++, этих особенностей не \u003cbr /\u003eзнают, и узнаЮт   об этих граблях только через некоторое время. Существуют \u003cbr /\u003eдаже   книжки о таких граблях. Мне нравится книга Скотта Мейерса (он же   \u003cbr /\u003eМайерс, он же Мэйерс) \u0026quot;Эффективное использование C++\u0026quot;.\u003cbr /\u003e   \u003cbr /\u003eВ Яве таких особенностей практически нет. С одним похожим   случаем я \u003cbr /\u003eстолкнулся только при использовании одного класса   стандартной библиотеки, а \u003cbr /\u003eв C++ таких особенностей десяток в   самОм языке.\u003cbr /\u003e   \u003cbr /\u003e   \u003cbr /\u003eКритерий 2. Насколько удобно писать на языке.\u003cbr /\u003e   \u003cbr /\u003eВозможность 2.1. Циклический импорт.\u003cbr /\u003e   \u003cbr /\u003eИногда два класса зависят друг от друга. В компиляторе может   быть, скажем, \u003cbr /\u003eтакая ситуация: в выражении (скажем, при   приведении к какому-то типу) может \u003cbr /\u003eвстречаться тип, а в типе   (скажем, в описании диапазона индексов массива) \u003cbr /\u003eможет   встречаться выражение. Первый должен вызвать методы второго, а второй   \u003cbr /\u003e- методы первого. Возникает вопрос, кто кого должен импортировать.\u003cbr /\u003e   \u003cbr /\u003eВ Яве этот вопрос решается просто - циклический импорт разрешён,   классы \u003cbr /\u003eдруг друга увидят. В C++ циклический импорт запрещён,   кого-то нужно \u003cbr /\u003eобъявлять первым. Решение на C++, конечно же,   существует и заключается в \u003cbr /\u003eнаследовании от интерфейсного класса   с чисто виртуальными функциями, но как \u003cbr /\u003eзаумно это звучит, так же   плохо это и выглядит, хотя замечательно работает.\u003cbr /\u003e   \u003cbr /\u003eВозможность 2.2. Библиотеки шаблонов структур данных.\u003cbr /\u003e   \u003cbr /\u003eКак C++, так и Ява, в отличие от Паскаля, оба содержат   библиотеки с \u003cbr /\u003eшаблонами вроде std::vector, std::map и т.п.   Например, std::map - это \u003cbr /\u003eаналог массива, только индексы не   обязаны быть целыми числами, достаточно \u003cbr /\u003eуметь сравнивать две   переменные типа ключа на меньше. Эффективная \u003cbr /\u003eреализация подобных   структур данных для каждого конкретного случая \u003cbr /\u003eпотребовала бы от   программиста титанических усилий - а тут всё уже готово, \u003cbr /\u003eбери и пользуйся.\u003cbr /\u003e   \u003cbr /\u003eК сожалению, стандартные контейнеры C++ поступают в духе Си и не   \u003cbr /\u003eобеспечивают никаких проверок диапазонов и т.п. К счастью,   существует \u003cbr /\u003eбесплатно распространяемая библиотека STLPort, где   можно включить режим \u003cbr /\u003eпроверок. Но её нужно скачивать и   устанавливать, с известными компиляторами \u003cbr /\u003eона не поставляется.\u003cbr /\u003e   \u003cbr /\u003eА ещё очень хочется оторвать руки тому, кто в C++ у std::vector   (массив с \u003cbr /\u003eвозможностью роста) значение функции size() сделал   беззнаковым числом. \u003cbr /\u003eПосле этого цикл\u003cbr /\u003efor (int i \u003d 0; i \u0026lt;   a.size(); i++)\u003cbr /\u003eприходится записывать или как\u003cbr /\u003efor (int i \u003d 0;   i \u0026lt; (int)a.size(); i++)\u003cbr /\u003eили как\u003cbr /\u003efor   (std::vector\u0026lt;int\u0026gt;::size_type i \u003d 0; i \u0026lt; a.size();   i++)\u003cbr /\u003eили получать предупреждение компилятора о сравнении числа со   знаком и числа \u003cbr /\u003eбез знака.\u003cbr /\u003e   \u003cbr /\u003eВозможность 2.3. Исключения.\u003cbr /\u003e   \u003cbr /\u003eКак C++, так и Ява, в отличие от Оберона, оба поддерживают исключения.\u003cbr /\u003e   \u003cbr /\u003eЧто должен сделать компилятор при обнаружении ошибки? Сообщить о   ней - и на \u003cbr /\u003eэтом в принципе миссия завершена. Традиционный подход   в простеньком \u003cbr /\u003eкомпиляторе - после выдачи ошибки просто завершить   программу с помощью \u003cbr /\u003eсредств вроде exit() C++, System.exit() Явы   или halt() Паскаля. А что если \u003cbr /\u003eкомпилятор встроен в редактор?   Всё-то он не должен выносить, должна \u003cbr /\u003eзавершиться только стадия   компиляции. Вот тут как раз исключения и могут \u003cbr /\u003eпомочь. Они   позволяют из процедуры выдачи ошибки перескочить на самый   \u003cbr /\u003eверхний уровень без дополнительного кода в процедурах   синтаксического \u003cbr /\u003eанализа. Помнится, я писал компилятор на   Обероне, так там раз 200 в \u003cbr /\u003eсинтаксическом анализаторе   встречалась строка IF error THEN EXIT; END; Вот \u003cbr /\u003eкакие ужасы   могут твориться в языке без поддержки исключений.\u003cbr /\u003e   \u003cbr /\u003e   \u003cbr /\u003eВот краткий обзор возможностей языков. В плане обеспечения   надёжности для \u003cbr /\u003eбольших проектов C++ и Ява практически равны. Для   надёжных набольших \u003cbr /\u003eпроектов Ява, похоже, подходит лучше. А для   тех, кто считает, что пишет \u003cbr /\u003eтолько правильные программы, в   которых нет ошибок и которые не нуждаются в \u003cbr /\u003eотладке, безусловно,   подходит \u0026quot;чистый\u0026quot; C++. :-)\u003cbr /\u003e\u003c/p\u003e \u003ch3\u003e   PS:\u003cbr /\u003e\u003c/h3\u003e \u003cp\u003eПрошу не оценивать данную статью, ибо за её качество ответственность   несёт сам автор.\u003c/p\u003e \u003cp\u003eЯ не имею никакого права получать за неё + или - ,т.к. она не моя. \u003c/p\u003e \u003cp\u003eЛично мне она понравилась, считаю её весьма ценной и выложил   исключительно для того, чтобы народ смог оценить кое-какие грани   рассматриваемых языков и сделать нужный выбор.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e","tags":["c++","java","меньшиков ф.в."]}}