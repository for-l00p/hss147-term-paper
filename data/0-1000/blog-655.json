{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1284167822,"rating":0,"authorHandle":"onlyone","modificationTimeSeconds":1284167946,"id":655,"title":"Solution of A\\B\\C @ Round#27","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003eA: it\u0027s very easy. a bool vis[] is ok.\u003cbr /\u003e\u003cbr /\u003eB: it can think as a directional Graph. xi-\u0026gt;yi. there are two (a ,b), they appeer time less than N-1. we can do dfs from a to b, to check whether a can reach b, if it can, cout  a b , else cout b a.\u003cbr /\u003eps:What a bad thing is I got WA during the contest, because I wrote  a \u0027j\u0027 as i. \u003d \u003d....\u003cbr /\u003e\u003cbr /\u003eC: let change the sequence to a sequence only have -1,0, 1. \u003cbr /\u003e   s[1] \u003d 0, if in[i]-in[i-1] \u0026gt; 0, s[i] \u003d 1, else if less than 0, s[i] \u003d -1, no change to oh. \u003cbr /\u003e\u003cbr /\u003eFirst, we can know, if the shortest unordered subsequence exist, the length is 3, and the first number can be one of the three. scan S[i] from 2-\u0026gt;N, if S[i]!\u003d0, break,b\u003di, then continue scan, if exist S[i]+S[b]\u003d\u003d0,break, c \u003d i, then the ouordered subS exist.\u003cbr /\u003esub is 0 1 -1 or 0 -1 1,\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003eFrom -100 0 100 98 \u003d\u0026gt;0 1 1 -1, but as the method above, a \u003d 1, b \u003d 2, c \u003d 4, but they are ordered. the ans should be a, c-1, c. a is always 1.\u003cbr /\u003e\u003cbr /\u003ewhy?   b is the first 1(-1), c is the first -1(1), so the number between b and c, is less than numb[b] \u0026amp;\u0026amp; larger than numb[c] / larger than b \u0026amp;\u0026amp; less than c, also may equal to numb[b] so compare \u0026quot;numb[c-1] to numb[a]\u0026quot; is the same \u0026quot;numb[b] to numb[a]\u0026quot; \u003cspan\u003e\u003c/span\u003e,larger or less. numb[c] only compared to numb[c-1] from the S[]. so a c-1 c can be the ans.\u003cbr /\u003e\u003cbr /\u003e/* my code:\u003cbr /\u003eval[1] \u003d 0;\u003cbr /\u003e          scanf(\u0026quot;%d\u0026quot;,\u0026amp;a);\u003cbr /\u003e          for (i \u003d 2; i \u0026lt;\u003d N; i++)\u003cbr /\u003e          {\u003cbr /\u003e              scanf(\u0026quot;%d\u0026quot;,\u0026amp;b);\u003cbr /\u003e              val[i] \u003d (b-a);\u003cbr /\u003e              a \u003d b;\u003cbr /\u003e              if (val[i]\u0026lt;0) val[i] \u003d -1;\u003cbr /\u003e              else if (val[i]\u0026gt;0) val[i] \u003d 1;\u003cbr /\u003e          }\u003cbr /\u003e      //    if (N \u0026lt;\u003d 2) {printf(\u0026quot;0\\n\u0026quot;);continue ;}\u003cbr /\u003e          \u003cbr /\u003e          k \u003d 1;\u003cbr /\u003e          a \u003d 1;\u003cbr /\u003e          \u003cbr /\u003e          for (i \u003d 2; i \u0026lt;\u003d N; i++)\u003cbr /\u003e              if (val[i]) break;\u003cbr /\u003e          \u003cbr /\u003e          if (i \u0026lt;\u003d N)\u003cbr /\u003e          {\u003cbr /\u003e             b \u003d i;\u003cbr /\u003e             k++;\u003cbr /\u003e             for (i++; i \u0026lt;\u003d N; i++)\u003cbr /\u003e             if (val[i]+val[b]\u003d\u003d0)\u003cbr /\u003e                break;                \u003cbr /\u003e             \u003cbr /\u003e             if (i\u0026lt;\u003dN)\u003cbr /\u003e             {\u003cbr /\u003e              k++;\u003cbr /\u003e              b \u003d i-1;\u003cbr /\u003e              c \u003d i;\u003cbr /\u003e             }\u003cbr /\u003e          }\u003cbr /\u003e\u003cbr /\u003e*/\u003cbr /\u003e\u003cbr /\u003eI was Hacked by others. After thinking problem E, I find the bug -100 0 100 98, but the contest is over.\u003cbr /\u003e\u003cbr /\u003eThis Round....How tragical I am !!!\u003cbr /\u003eI will do better the next Round.\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003eI want to know how to solve the Problem D and Problem E, can you help me? thanks..\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003e \u003c/div\u003e","tags":["codeforces format","solution","разбор"]}}