{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1284388633,"rating":0,"authorHandle":"Tahlil","modificationTimeSeconds":1284447311,"id":665,"title":"Is my solution to problem D( Ring Road 2 ) of the last contest is correct ??","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv\u003eI read the tutorial of contest 27 . But in that time i already coded a solution which is greedy i think. Here is what i do\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003e1) I calculate for each segment, with how many segment it intersects.\u003c/div\u003e\u003cdiv\u003e2)Then for each segment 1 to m\u003c/div\u003e\u003cdiv\u003e\u003cspan style\u003d\"white-space: pre;\"\u003e \u003c/span\u003e--if it has min one intersection and if it doesn\u0027t intersect with others who are already been put outside and if it is not already been put outside , I color it to keep track of the segments put outside.And i also store this segment so that i can check it with the other segments who will be put outside in the future to check intersection.Then break and go to step 1.\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003eAnd i do the above process until i find that i can not put anymore segments outside. And at last i check if there is any collision between the segments. If there then i output impossible else i output who are colored as outside and who are not colored as inside :)\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003eBut this code fails for test case 23 :( \u003c/div\u003e\u003cdiv\u003eIs my procedure is ok ?? Can anyone explain please.  Here is my code \u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e#include \u0026lt;sstream\u0026gt;\u003c/div\u003e\u003cdiv\u003e#include \u0026lt;queue\u0026gt;\u003c/div\u003e\u003cdiv\u003e#include \u0026lt;set\u0026gt;\u003c/div\u003e\u003cdiv\u003e#include \u0026lt;map\u0026gt;\u003c/div\u003e\u003cdiv\u003e#include \u0026lt;cstdio\u0026gt;\u003c/div\u003e\u003cdiv\u003e#include \u0026lt;cstdlib\u0026gt;\u003c/div\u003e\u003cdiv\u003e#include \u0026lt;cctype\u0026gt;\u003c/div\u003e\u003cdiv\u003e#include \u0026lt;cmath\u0026gt;\u003c/div\u003e\u003cdiv\u003e#include \u0026lt;iostream\u0026gt;\u003c/div\u003e\u003cdiv\u003e#include \u0026lt;string\u0026gt;\u003c/div\u003e\u003cdiv\u003e#include \u0026lt;vector\u0026gt;\u003c/div\u003e\u003cdiv\u003e#include \u0026lt;algorithm\u0026gt;\u003c/div\u003e\u003cdiv\u003e#include \u0026lt;string.h\u0026gt;\u003c/div\u003e\u003cdiv\u003e#define inf 99999999\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003eusing namespace std;\u003c/div\u003e\u003cdiv\u003etypedef struct\u003c/div\u003e\u003cdiv\u003e{\u003c/div\u003e\u003cdiv\u003e    int x,y,cnt;\u003c/div\u003e\u003cdiv\u003e}Ind;\u003c/div\u003e\u003cdiv\u003eInd ar[110],arr [110];\u003c/div\u003e\u003cdiv\u003eint flg[110];\u003c/div\u003e\u003cdiv\u003ebool fl;\u003c/div\u003e\u003cdiv\u003eint i,j,ed,mn,mx,node,edge;\u003c/div\u003e\u003cdiv\u003evoid find()  // checking for every segment how many times intersected with other segments\u003c/div\u003e\u003cdiv\u003e{\u003c/div\u003e\u003cdiv\u003e    int i,j;\u003c/div\u003e\u003cdiv\u003e    fl \u003d 0;\u003c/div\u003e\u003cdiv\u003e    for(i\u003d0;i\u0026lt;edge;i++)\u003c/div\u003e\u003cdiv\u003e    {\u003c/div\u003e\u003cdiv\u003e        ar[i].cnt\u003d0;\u003c/div\u003e\u003cdiv\u003e        if(!flg[i])\u003c/div\u003e\u003cdiv\u003e            for(j\u003d0;j\u0026lt;edge;j++)\u003c/div\u003e\u003cdiv\u003e            {\u003c/div\u003e\u003cdiv\u003e                if(i\u003d\u003dj || flg[j])continue;\u003c/div\u003e\u003cdiv\u003e                if(ar[i].x\u0026gt;\u003dar[j].x \u0026amp;\u0026amp; ar[i].y\u0026lt;\u003dar[j].y)continue;\u003c/div\u003e\u003cdiv\u003e                if(ar[i].x\u0026gt;\u003dar[j].y || ar[i].y\u0026lt;\u003dar[j].x)continue;\u003c/div\u003e\u003cdiv\u003e                if(ar[i].x\u0026lt;\u003dar[j].x \u0026amp;\u0026amp; ar[i].y\u0026gt;\u003dar[j].y)continue;\u003c/div\u003e\u003cdiv\u003e                ar[i].cnt++;\u003c/div\u003e\u003cdiv\u003e                fl \u003d 1;\u003c/div\u003e\u003cdiv\u003e            }\u003c/div\u003e\u003cdiv\u003e    }\u003c/div\u003e\u003cdiv\u003e}\u003c/div\u003e\u003cdiv\u003ebool chek(int i)  // checking if puting outside the current segment causes intersection with other segments which are already outside\u003c/div\u003e\u003cdiv\u003e{\u003c/div\u003e\u003cdiv\u003e    int j;\u003c/div\u003e\u003cdiv\u003e    for(j\u003d0;j\u0026lt;ed;j++)\u003c/div\u003e\u003cdiv\u003e    {\u003c/div\u003e\u003cdiv\u003e        if(ar[i].x\u0026gt;\u003darr[j].x \u0026amp;\u0026amp; ar[i].y\u0026lt;\u003darr[j].y)continue;\u003c/div\u003e\u003cdiv\u003e        if(ar[i].x\u0026gt;\u003darr[j].y || ar[i].y\u0026lt;\u003darr[j].x)continue;\u003c/div\u003e\u003cdiv\u003e        if(ar[i].x\u0026lt;\u003darr[j].x \u0026amp;\u0026amp; ar[i].y\u0026gt;\u003darr[j].y)continue;\u003c/div\u003e\u003cdiv\u003e        return 0;\u003c/div\u003e\u003cdiv\u003e    }\u003c/div\u003e\u003cdiv\u003e    return 1;\u003c/div\u003e\u003cdiv\u003e}\u003c/div\u003e\u003cdiv\u003eint main()\u003c/div\u003e\u003cdiv\u003e{\u003c/div\u003e\u003cdiv\u003e    //freopen(\u0026quot;out.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\u003c/div\u003e\u003cdiv\u003e    while(cin\u0026gt;\u0026gt;node\u0026gt;\u0026gt;edge)\u003c/div\u003e\u003cdiv\u003e    {\u003c/div\u003e\u003cdiv\u003e        for(i\u003d0;i\u0026lt;edge;i++)\u003c/div\u003e\u003cdiv\u003e        {\u003c/div\u003e\u003cdiv\u003e            cin\u0026gt;\u0026gt;ar[i].x\u0026gt;\u0026gt;ar[i].y;\u003c/div\u003e\u003cdiv\u003e            mn \u003d min (ar[i].x,ar[i].y);\u003c/div\u003e\u003cdiv\u003e            mx \u003d max (ar[i].x,ar[i].y);\u003c/div\u003e\u003cdiv\u003e            ar[i].x \u003d mn;\u003c/div\u003e\u003cdiv\u003e            ar[i].y \u003d mx;\u003c/div\u003e\u003cdiv\u003e        }\u003c/div\u003e\u003cdiv\u003e        ed\u003d0;\u003c/div\u003e\u003cdiv\u003e        do\u003c/div\u003e\u003cdiv\u003e        {\u003c/div\u003e\u003cdiv\u003e            find();\u003c/div\u003e\u003cdiv\u003e            fl\u003d0;\u003c/div\u003e\u003cdiv\u003e            for(i\u003d0;i\u0026lt;edge;i++)\u003c/div\u003e\u003cdiv\u003e            {\u003c/div\u003e\u003cdiv\u003e                if(ar[i].cnt \u0026amp;\u0026amp; chek(i) \u0026amp;\u0026amp; !flg[i])\u003c/div\u003e\u003cdiv\u003e                {\u003c/div\u003e\u003cdiv\u003e                    arr[ed].x \u003d ar[i].x;\u003c/div\u003e\u003cdiv\u003e                    arr[ed++].y \u003d ar[i].y;\u003c/div\u003e\u003cdiv\u003e                    flg[i]\u003d1;\u003c/div\u003e\u003cdiv\u003e                    fl\u003d1;\u003c/div\u003e\u003cdiv\u003e                    break;\u003c/div\u003e\u003cdiv\u003e                }\u003c/div\u003e\u003cdiv\u003e            }\u003c/div\u003e\u003cdiv\u003e        }while(fl);\u003c/div\u003e\u003cdiv\u003e        find();\u003c/div\u003e\u003cdiv\u003e        if(fl)\u003c/div\u003e\u003cdiv\u003e        {\u003c/div\u003e\u003cdiv\u003e            cout\u0026lt;\u0026lt;\u0026quot;Impossible\u0026quot;;\u003c/div\u003e\u003cdiv\u003e            return 0;\u003c/div\u003e\u003cdiv\u003e        }\u003c/div\u003e\u003cdiv\u003e        for(i\u003d0;i\u0026lt;edge;i++)\u003c/div\u003e\u003cdiv\u003e        {\u003c/div\u003e\u003cdiv\u003e            //\u003c/div\u003e\u003cdiv\u003e            if(flg[i])cout\u0026lt;\u0026lt;\u0026quot;o\u0026quot;;\u003c/div\u003e\u003cdiv\u003e            else  cout\u0026lt;\u0026lt;\u0026quot;i\u0026quot;;\u003c/div\u003e\u003cdiv\u003e        }\u003c/div\u003e\u003cdiv\u003e    }\u003c/div\u003e\u003cdiv\u003e    return 0;\u003c/div\u003e\u003cdiv\u003e}\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["beta round 27","greedy","help"]}}