{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1269377577,"rating":0,"authorHandle":"Xorand","modificationTimeSeconds":1269377577,"id":209,"title":"Help! Задача C - Наибольшая правильная скобочная подстрока","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eПревышен предел времени на тесте 10. Не понимаю, что я делаю не так. Неужели есть более простое и быстрое решение? HELP! HELP! HELP! Подкиньте идею)\u003c/p\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e#include \u0026lt;iostream\u0026gt;\u003cbr /\u003e#include \u0026lt;string\u0026gt;\u003c/p\u003eusing namespace std;\u003cbr /\u003e\u003cbr /\u003elong Seq(string s)\u003cbr /\u003e{\u003cbr /\u003e   long seq\u003d0;\u003cbr /\u003e   long i\u003d0;\u003cbr /\u003e   i\u003ds.find(\u0026quot;()\u0026quot;);\u003cbr /\u003e   while (i\u0026lt;s.length()-1)\u003cbr /\u003e   {  \u003cbr /\u003e      for (long j\u003di;j\u0026lt;s.length()-2;j++)\u003cbr /\u003e      {\u003cbr /\u003e         s[j]\u003ds[j+2];\u003cbr /\u003e      }     \u003cbr /\u003e    s.resize(s.length()-2);\u003cbr /\u003e    seq+\u003d2;          \u003cbr /\u003e    i\u003ds.find(\u0026quot;()\u0026quot;);\u003cbr /\u003e   }\u003cbr /\u003e   if (s.length()\u0026gt;0)\u003cbr /\u003e   {\u003cbr /\u003e      seq\u003d0;\u003cbr /\u003e   }\u003cbr /\u003e   return seq;\u003cbr /\u003e}\u003cbr /\u003evoid main()\u003cbr /\u003e{\u003cbr /\u003e   string cmd;\u003cbr /\u003e   cin\u0026gt;\u0026gt;cmd;\u003cbr /\u003e   long maxl \u003d 0, num \u003d 0;\u003cbr /\u003e   for (long i \u003d 0; i \u0026lt; cmd.length(); i++)\u003cbr /\u003e      for (long j \u003d cmd.length() - 1; j \u0026gt;\u003d i; j--)\u003cbr /\u003e      {\u003cbr /\u003e         if ((j - i + 1) % 2 \u003d\u003d 0 \u0026amp;\u0026amp; (j - i + 1) \u0026gt;\u003d maxl)\u003cbr /\u003e         {                        \u003cbr /\u003e            long ibuf \u003d Seq(cmd.substr(i, j - i + 1));\u003cbr /\u003e            if (maxl \u003d\u003d ibuf) num++;\u003cbr /\u003e            else if (maxl \u0026lt; ibuf) { maxl \u003d ibuf; num \u003d 1; }\u003cbr /\u003e         }                \u003cbr /\u003e      }\u003cbr /\u003e   if (maxl \u003d\u003d 0) num \u003d 1; \u003cbr /\u003e   cout\u0026lt;\u0026lt;maxl\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;num\u0026lt;\u0026lt;endl;\u003cbr /\u003e}\u003cp\u003eЗдесь метод Seq возвращает длину правильной последовательности s,\u003cbr /\u003emaxl хранит максимальную длину правильной последовательности,\u003cbr /\u003enum - количество последовательностей длины maxl\u003c/p\u003e\u003c/div\u003e","tags":["help","задача c","ошибка на тесте 10"]}}