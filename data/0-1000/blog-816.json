{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1288561749,"rating":11,"authorHandle":"NALP","modificationTimeSeconds":1288561749,"id":816,"title":"Школьная индивидуальная олимпиада #1 - Codeforces Beta Round #38. (Разбор задачи F)","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eЗадача F. \u0026quot;Умный мальчик\u0026quot;\u003c/h1\u003eЭта задача решается методом динамического программирования, где состояние - это текущая записанная на доске строка, а хранимое значение - это тройка \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bd/35/bd351a867446618f5f7aa62a45196c95a595fd59.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eresult\u003c/i\u003e\u003c/span\u003e - это результат игры для игрока, который в данный момент ходит (проиграл он, или выиграл), \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e - это максимальное количество очков у него, и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e - минимальное количество очков у соперника. \u003cbr /\u003e\u003cbr /\u003eТогда мы перебираем букву, перебираем куда мы ее поставим, и пытаемся улучшить текущий ответ. Для этого мы используем следующий критерий: наше состояние выигрышное тогда и только тогда, когда существует ход в проигрышное состояние. Из всех ходов, гарантирующих наш выигрыш, вы выберем такое, чтобы наши очки были максимальны, а при равенстве - очки соперника минимальны. Если наше состояние - проигрышное, то выбирать по этому критерию надо вообще из всех переходов.\u003cbr /\u003e\u003cbr /\u003eКоличество очков, которое получает игрок при записи новой строки, можно было считать, используя, например, префикс-функцию, но замечу, что решения, которые использовали встроенные в языки функции проверки вхождения одной строки в другую, тоже проходили по времени.\u003cbr /\u003e\u003cbr /\u003eХранить все состояния было проще всего в структуре данных map (или HashMap, TreeMap и подобные), но вполне адекватным решением было хранить результаты в массиве d[][][], где первое измерение - номер строки из алфавита, второе и третье измерение - начало и конец вхождения текущей строки в эту строку из алфавита.\u003cbr /\u003e\u003c/div\u003e","tags":["разбор"]}}