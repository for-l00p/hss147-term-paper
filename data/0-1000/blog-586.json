{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1281221176,"rating":0,"authorHandle":"Chortos-2","modificationTimeSeconds":1448372575,"id":586,"title":"\u003cp\u003eA Solution of the Industrial Nim Problem\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/15/problem/C\"\u003eIndustrial Nim\u003c/a\u003e is the problem C of beta contest #15. Here I present and explain in detail an efficient solution of the problem that runs in time linear in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, which is at most \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e.\u003c/p\u003e \u003cp\u003e \u003c/p\u003e \u003cp\u003eFirst of all, notice that the problem statement mentions ‘a well-known game Nim’. It also describes the rules but not the winning strategy; yet you are asked to determine which player wins. All of this means that if you do not know anything related to the winning strategy, you can simply look up the \u003ca href\u003d\"http://en.wikipedia.org/wiki/Nim\"\u003eNim game on Wikipedia\u003c/a\u003e and see if it has any useful information. It indeed does; specifically, you need to know that the winner in the Nim game, assuming both players play perfectly, is uniquely defined by the \u003ca href\u003d\"http://en.wikipedia.org/wiki/Exclusive_or\"\u003eexclusive-or (XOR) sum\u003c/a\u003e of the stone heap sizes: if the sum is zero, then the first player loses, otherwise the first player wins. If you did not know this beforehand, you could have looked or, however unlikely, logically devised this on your own. I am not sure I can prove this fact, so I will just say the Wikipedia article includes a proof in case you are interested in it.\u003c/p\u003e \u003cp\u003eNow we have a straightforward solution of the problem: just XOR together the number of stones in every dumper and output ‘bolik’ if the sum is zero and ‘tolik’ otherwise. XOR is supported as an atomic operation in all programming languages I program in (in particular, in languages with syntax inspired by C, including C itself, two integers can be XOR’ed using the ^ binary operator), so there should be no problem in implementing this. However, the limits imposed on input data make this solution extremely slow: indeed, there can be up to \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e quarries, and every quarry can have up to \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e16\u003c/sup\u003e\u003c/span\u003e dumpers, so in total we can be required to calculate the XOR sum of \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e × 10\u003csup class\u003d\"upper-index\"\u003e16\u003c/sup\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e21\u003c/sup\u003e\u003c/span\u003e integers, which is, well, quite many. So we are now in dire need of a fast way to XOR together all these \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e21\u003c/sup\u003e\u003c/span\u003e integers.\u003c/p\u003e \u003cp\u003eNow it is the time to notice that these are not just any arbitrarily chosen integers: to remind you, we have a number of quarries and each consists of dumpers with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e + 1, \u003ci\u003ex\u003c/i\u003e + 2, ..., \u003ci\u003ex\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e - 1\u003c/span\u003e stones. Put in other words, each quarry has all integers from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e - 1\u003c/span\u003e inclusive, or, in other words yet again, all integers up to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e - 1\u003c/span\u003e except all integers up to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - 1\u003c/span\u003e. What if we could somehow add together all positive integers up to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e - 1\u003c/span\u003e and subtract the sum of all integers up to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - 1\u003c/span\u003e, only substituting exclusive disjunction (XOR) for addition? And indeed we can. To understand this, you have to notice two nice properties that exclusive disjunction has: it is \u003ca href\u003d\"http://en.wikipedia.org/wiki/Associativity\"\u003eassociative\u003c/a\u003e, meaning that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e2/88/e288896aed9bfd422226a4914ef0407b8d887d32.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (where the \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7b/ea/7beade55e90846d70020a3d03521d3458b66751b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e operator denotes XOR), and it is the \u003ca href\u003d\"http://en.wikipedia.org/wiki/Inverse_function\"\u003einverse\u003c/a\u003e of itself, meaning that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f2/0b/f20bc57eab8ad3a8732dae363c675e956ca0b880.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. The first property justifies our addition-subtraction approach itself, while the second one gives the definition for XOR subtraction: it is the very same XOR. Combining all this, we have:\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/65/b1/65b12d91945d0da5f2f75882ef73ba4afd3b98f8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e \u003cp\u003ewhere $f(x)$ is the XOR sum of all positive integers up to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e inclusive. The conclusion we should draw from this is that if we can quickly calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e - 1)\u003c/span\u003e for a given \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, we can simply calculate \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/fa/64/fa64fdaac54801d966755d3f5a49995fcd5774ff.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for every quarry and take the XOR sum of all these values. As the number of quarries is just \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e, this should yield a very fast solution of the problem.\u003c/p\u003e \u003cp\u003eThe last trick is to notice that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e - 1)\u003c/span\u003e itself follows a nice pattern as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e changes; for every four consecutive values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e starting with zero (assuming the XOR sum of an empty set it zero), this sum is equal to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - 1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. For example, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(1 - 1) \u003d 1 - 0 \u003d 0\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(9 - 1) \u003d 9 - 1 \u003d 8\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(10 - 1) \u003d 1\u003c/span\u003e; the general form is easily provable by mathematical induction. We also have to take care to avoid integer overflows but no dumper has more than \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e16\u003c/sup\u003e + 10\u003csup class\u003d\"upper-index\"\u003e16\u003c/sup\u003e - 1 ≈ 2\u003csup class\u003d\"upper-index\"\u003e54.15\u003c/sup\u003e\u003c/span\u003e stones, so we only need 55 bits to store any XOR sum we ever calculate. Thus, 64-bit integers are more than sufficiently long, and the final code in C looks thus:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;stdio.h\u0026gt;\nlong long xorsum_1_to_x_but_1(long long x)\n{\n  switch (x % 4)\n  {\n  case 0:\n    return 0;\n  case 1:\n    return x — 1;\n  case 2:\n    return 1;\n  case 3:\n    return x;\n  }\n}\nint main(void)\n{\n  long long xorsum \u003d 0;\n  int i;\n  scanf(\u0026quot;%u\u0026quot;,\u0026amp;i);\n  while (i--) // repeat i times in total\n  {\n    long long x, m;\n    scanf(\u0026quot;%I64u%I64u\u0026quot;, \u0026amp;x, \u0026amp;m);\n    xorsum ^\u003d xorsum_1_to_x_but_1(x) ^ xorsum_1_to_x_but_1(x + m);\n  }\n  puts(xorsum ? \u0026quot;tolik\u0026quot; : \u0026quot;bolik\u0026quot;);\n  return 0;\n}\u003c/code\u003e\u003c/pre\u003e \u003cp\u003eFinally, another implementation note. Unfortunately, Ruby’s long integer input is too slow even for this solution to finish before the time limit, so Ruby is not an appropriate programming language choice this time (notice how there is no Ruby submission in the \u003ca href\u003d\"//codeforces.com/contest/15/status/C\"\u003esubmission list\u003c/a\u003e for this problem), but other languages work just fine. You might also have luck with emulating long integers in Ruby on your own; I am going to try this myself sometime.\u003c/p\u003e\u003c/div\u003e","tags":["nim","solution"]}}