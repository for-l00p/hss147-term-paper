{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1276713088,"rating":34,"authorHandle":"ArtDitel","modificationTimeSeconds":1276762800,"id":463,"title":"Codeforces Beta Round #18(Div. 2) Tutorial","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"http://codeforces.ru/blog/entry/462\"\u003eContest discussion\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eProblem А. Triangle\u003c/h3\u003e\u003cp\u003e\u003cu\u003ePythagorean theorem, brute force\u003c/u\u003e\u003c/p\u003e\u003cp\u003eIn this problem you should implement a function, which takes three points and checks whether they form a right-angled triangle. There are a lot of ways to do so, but the simplest one is using a Pythagorean theorem.\u003c/p\u003e\u003cp\u003e \u003c/p\u003e\u003cp\u003eYou should use squared distances instead of taking roots to overcome problems related to precision errors.\u003c/p\u003e\u003cp\u003eTo examine a triangle on almost-rightness, you can try to move each point in each of four possible directions and check the new triangle using our function. It\u0027s good and easy to use two arrays: dx\u003d{-1,0,1,0} and dy\u003d{0,1,0,-1} for moving. Then we can get the new coordinates of shifted point simply using the following code:\u003cbr /\u003e\u003c/p\u003e\u003cblockquote\u003efor (int i \u003d 0; i \u0026lt; 4; i ++)\u003c/blockquote\u003e\u003cblockquote\u003e{\u003c/blockquote\u003e\u003cblockquote\u003e\u003cblockquote\u003eint x \u003d dx[i] + px;\u003c/blockquote\u003e\u003c/blockquote\u003e\u003cblockquote\u003e\u003cblockquote\u003eint y \u003d dy[i] + py;\u003c/blockquote\u003e\u003c/blockquote\u003e\u003cblockquote\u003e\u003cp\u003e}\u003c/p\u003e\u003c/blockquote\u003e\u003ch3\u003eProblem B. Platforms\u003c/h3\u003e\u003cp\u003e\u003cu\u003eSimulation\u003c/u\u003e\u003c/p\u003e\u003cp\u003eIllustrative picture:\u003c/p\u003e\u003cp\u003e\u003cimg src\u003d\"http://s40.radikal.ru/i089/1006/10/c50af7e13d4d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eIn this problem you were to determine a coordinate where the grasshoper would fall down. To do so, let\u0027s keep the position of grasshoper at a certain moment of time.\u003cbr /\u003eTo avoid TLE one should \u0026quot;move\u0026quot; the grasshoper along a platform in \u003cem\u003eO(1)\u003c/em\u003e time (not in the cycle). The grasshoper will do  \u003cem\u003ej \u003d (right\u003csub\u003ei\u003c/sub\u003e-x)/d\u003c/em\u003e jumps along platform \u0026quot;\u003cem\u003ei\u003c/em\u003e\u0026quot;, where \u003cem\u003ex\u003c/em\u003e is the grasshoper\u0027s coordinate (he\u0027s standing at the platform), and \u003cem\u003eright\u003csub\u003ei\u003c/sub\u003e\u003c/em\u003e is a right coordinate of the platform. So we can move the grasshoper on \u003cem\u003ej*d\u003c/em\u003e to the right at once.\u003c/p\u003e\u003ch3\u003e Problem C. Stripe\u003cbr /\u003e\u003c/h3\u003e\u003cp\u003e\u003cu\u003eBrute force\u003c/u\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eOne should keep two sums S1 ans S2, where S1 is the sum of all numbers on the left part of the stripe, and S2 is the sum of the right one. At the beginning S1 \u003d 0 and S2 equals to the sum of all numbers of the stripe. Then we move the border of the parts within a cycle from left to right recalculating the values of S1 and S2 each iteration and increasing the answer when it\u0027s necessary.\u003cbr /\u003e\u003c/p\u003e\u003ch3\u003eProblem D. Seller Bob\u003cbr /\u003e\u003c/h3\u003e\u003cp\u003e\u003cu\u003eGreedy, long arithmetics\u003c/u\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eIn this problem we need big integers because the number 2\u003csup\u003e2000\u003c/sup\u003e doesn\u0027t fit in int64.\u003cbr /\u003eWe are given an assertion that for every memory stick there will be at most one potential customer. Since 2\u003csup\u003ex \u003c/sup\u003e\u0026gt; 2\u003csup\u003ex-1\u003c/sup\u003e + 2\u003csup\u003ex-2\u003c/sup\u003e + ... 2\u003csup\u003e0\u003c/sup\u003e, the earnings of selling the most expensive stick will be greater than the earnings of selling all other sticks. So we first try to sell the most expensive stick, then the second one and so on. So one should try to sell sticks in descending order of their costs.\u003cbr /\u003e\u003c/p\u003e\u003ch3\u003e Probelm E. Flag 2\u003cbr /\u003e\u003c/h3\u003e\u003cp\u003e\u003cu\u003eDynamic programming\u003c/u\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eIn this problem one should use dynamic programming. Consider the function \u003cem\u003eDP(level, A, B)\u003c/em\u003e (where \u003cem\u003eA\u003c/em\u003e and \u003cem\u003eB\u003c/em\u003e are the numbers of colors, from 0 to 25), which returns the minimal number of repaintings required to repaint the first level rows. The last row will be like \u003cem\u003eABABAB...\u003c/em\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eConsider recalculating of this function. First, calculate the number of repaintings required for row \u003cem\u003elevel\u003c/em\u003e to be like \u003cem\u003eABABAB...\u003c/em\u003e (let \u003cem\u003eD\u003c/em\u003e will be this number). Obviously, the row can be painted so if the color of the first element of the previous row is not \u0026quot;\u003cem\u003eA\u003c/em\u003e\u0026quot; and the second one - not \u0026quot;\u003cem\u003eB\u003c/em\u003e\u0026quot; (it\u0027s a condition of adjacent cells not to have the same color) or it should be the first row. So \u003cem\u003eDP(level, A, B) \u003d min(DP(level-1, i, j)) + D , i \u003d 0..25, j \u003d 0..25, i !\u003d j, i !\u003d B, j !\u003d A.\u003c/em\u003e\u003cbr /\u003e\u003cbr /\u003eEstimate the run time of our program: \u003cem\u003eO(N*26*26*(M+26*26))\u003c/em\u003e, this value is smaller than \u003cem\u003e4*10\u003csup\u003e8\u003c/sup\u003e\u003c/em\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003e\u003csup\u003e\u003cbr /\u003e\u003c/sup\u003e\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eGreat t\u003c/strong\u003e\u003cstrong\u003ehanks to \u003ca href\u003d\"http://codeforces.ru/profile/OBepkJIokEP\"\u003eIlya Akolzin\u003c/a\u003e for his help in  translation\u003c/strong\u003e\u003cem\u003e\u003csup\u003e\u003cbr /\u003e\u003c/sup\u003e\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e","tags":["beta round #18","tutorial"]}}