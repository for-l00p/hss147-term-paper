{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1269477435,"rating":12,"authorHandle":"DmitryKlenov","modificationTimeSeconds":1269477435,"id":213,"title":"Codeforces Beta Round #5 - Tutorial","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003eAs there is no tutorial of Codeforces Beta Round #5 in English, I have decided to write this one. Possibly, some ideas will be similar to ones, expressed in Russian tutorial made by SkidanovAlex, but I hope everybody will find some useful in this problem analysis too.\u003cbr /\u003e\u003cbr /\u003e\u003ch3\u003e\u003cb\u003eProblems A and B.\u003c/b\u003e\u003c/h3\u003e\u003cbr /\u003eBoth are implementation problems. The only difficult, many participants faced with - to read data correctly. It is recommended to use \u003ci\u003egets(s)\u003c/i\u003e or \u003ci\u003egetline(cin, s)\u003c/i\u003e in C++, \u003ci\u003ereadLine()\u003c/i\u003e method of BufferedReader class in Java.\u003cbr /\u003e\u003cbr /\u003e\u003ch3\u003e\u003cb\u003eProblem C.\u003c/b\u003e\u003c/h3\u003e\u003cbr /\u003eFirst of all, for each closing bracket in our string let\u0027s define 2 values:\u003cbr /\u003e\u003cul\u003e\u003cli\u003ed[j] \u003d position of corresponding open bracket, or -1 if closing bracket doesn\u0027t belong to any regular bracket sequence.\u003c/li\u003e\u003cli\u003e c[j] \u003d position of \u003cb\u003eearliest\u003c/b\u003e opening bracket, such that substring  s(c[j], j) (both boundaries are inclusive) is a regular bracket  sequence. Let\u0027s consider c[j] to be -1 if closing bracket doesn\u0027t belong  to any regular bracket sequence.\u003cbr /\u003e \u003c/li\u003e\u003c/ul\u003eIt can be seen, that c[j] defines the beginning position of the longest regular bracket sequence, which will end in position j. So, having c[j] answer for the problem can be easily calculated.\u003cbr /\u003e\u003cbr /\u003eBoth d[j] and c[j] can be found with following algorithm, which uses stack.\u003cbr /\u003e\u003col\u003e\u003cli\u003eIterate through the characters of the string.\u003c/li\u003e\u003cli\u003eIf current character is opening bracket, put its position into the  stack.\u003c/li\u003e\u003cli\u003eIf current character is closing bracket, there are 2 subcases:\u003c/li\u003e\u003c/ol\u003e\u003cul\u003e\u003cli\u003eStack is empty - this means that current closing bracket doesn\u0027t have  corresponding open one. Hence, both d[j] and c[j] are equal to -1.\u003c/li\u003e\u003cli\u003e Stack is not empty - we will have position of the corresponding open  bracket on the top of the stack - let\u0027s put it to d[j] and remove this position from the  stack. Now it is obvious, that c[j] is equal at least to d[j]. But probably, there is a better value for c[j]. To find this out,  we just need to look at the position d[j] - 1. If there is a closing bracket at this position, and c[d[j] - 1] is  not -1, than we have 2 regular bracket sequences s(c[d[j] - 1], d[j] -  1) and s(d[j], j), which can be concatenated into one larger regular  bracket sequence. So we put c[j] to be c[d[j] - 1] for this case.\u003c/li\u003e\u003c/ul\u003e\u003cbr /\u003e\u003ch3\u003e\u003cb\u003eProblem D.\u003c/b\u003e\u003c/h3\u003e\u003cbr /\u003eThis problem can be solved by careful case handling. Let\u0027s construct O(1) solution for it.\u003cbr /\u003e\u003cbr /\u003eFirst of all, let\u0027s define 2 functions:\u003cbr /\u003e\u003cbr /\u003e\u003col\u003e\u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edist\u003c/i\u003e(\u003ci\u003espeed\u003c/i\u003e, \u003ci\u003etime\u003c/i\u003e)\u003c/span\u003e - calculates the distance will be covered in specified time, if car\u0027s current speed is speed. This function will not take car\u0027s speed limit into account. Also it assumes, that car is always driven with maximum acceleration \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. It is obvious that required distance is equal to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b8/98/b898aef001070b97d143da04cda7f71b63cf24e3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/li\u003e\u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etravelTime\u003c/i\u003e(\u003ci\u003edistance\u003c/i\u003e, \u003ci\u003espeed\u003c/i\u003e)\u003c/span\u003e - calculates the time, required to  travel specified distance, if car have starting speed equal to speed. This  function will also take care about car\u0027s speed limit.\u003cbr /\u003eWe will have the following quadratic equation for time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/37/1e/371ee2e13be96e4b266f726d4c08fa61189a3f66.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. This equation will have exactly 2 different roots. Using  Viete\u0027s formulas it can be concluded, that one root of the equation is  non-positive and other is non-negative. Let\u0027s define the larger root  of the equation as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etAll\u003c/i\u003e\u003c/span\u003e. It will be the answer, if there is no car\u0027s  speed limit. To take the limit into account let\u0027s find the time,  required to gain car\u0027s max speed. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etMax\u003c/i\u003e \u003d (\u003ci\u003ev\u003c/i\u003e - \u003ci\u003espeed\u003c/i\u003e) / \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etMax\u003c/i\u003e ≥  \u003ci\u003etAll\u003c/i\u003e\u003c/span\u003e, function should just returns \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etAll\u003c/i\u003e\u003c/span\u003e as a result. Otherwise result  is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etMax\u003c/i\u003e\u003c/span\u003e hours to achieve car\u0027s maximal speed plus \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003edistance\u003c/i\u003e - \u003ci\u003edist\u003c/i\u003e(\u003ci\u003espeed\u003c/i\u003e, \u003ci\u003etMax\u003c/i\u003e)) / \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e hours to cover remaining distance.\u003c/li\u003e\u003c/ol\u003e\u003cbr /\u003eHaving these functions, solution will be the following:\u003cbr /\u003e\u003cbr /\u003e\u003col\u003e\u003cli\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e ≤ \u003ci\u003ew\u003c/i\u003e\u003c/span\u003e, answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etravelTime\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, 0)\u003c/span\u003e.\u003c/li\u003e\u003cli\u003eCalculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etw\u003c/i\u003e \u003d \u003ci\u003ew\u003c/i\u003e / \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e -  time, required to gain speed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e\u003cli\u003eConsider \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edw\u003c/i\u003e \u003d \u003ci\u003edist\u003c/i\u003e(0, \u003ci\u003etw\u003c/i\u003e)\u003c/span\u003e.\u003c/li\u003e\u003cli\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edw\u003c/i\u003e ≥ \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e, we will pass the point there sign is placed before we  gain speed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e. Answer for this case is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etravelTime\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, 0)\u003c/span\u003e as well.\u003c/li\u003e\u003cli\u003eOtherwise, we will gain speed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e before the sign. Let\u0027s consider segment  of the road \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003edw\u003c/i\u003e, \u003ci\u003ed\u003c/i\u003e]\u003c/span\u003e. We need to find out the best strategy to drive it.  It is obvious, that we definitely should have speed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e at the both ends  of this segment. Also we know, that acceleration is equal to  deceleration. Taking these facts into account we can see, that the  speed in the optimal solution will be symmetrical with respect to the  middle of the segment \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003edw\u003c/i\u003e, \u003ci\u003ed\u003c/i\u003e]\u003c/span\u003e. Hence answer for this case will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etw\u003c/i\u003e + 2 *  \u003ci\u003etravelTime\u003c/i\u003e(0.5 * (\u003ci\u003ed\u003c/i\u003e - \u003ci\u003edw\u003c/i\u003e), \u003ci\u003ew\u003c/i\u003e) + \u003ci\u003etravelTime\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e - \u003ci\u003ed\u003c/i\u003e, \u003ci\u003ew\u003c/i\u003e)\u003c/span\u003e.\u003cbr /\u003e\u003c/li\u003e\u003c/ol\u003e\u003cb\u003e\u003cbr /\u003e\u003c/b\u003e\u003ch3\u003e\u003cb\u003eProblem E.\u003c/b\u003e\u003c/h3\u003e\u003cbr /\u003eLet\u0027s reduce the problem from the circle to the straight line. Perform the following actions to do it:\u003cbr /\u003e\u003cbr /\u003e\u003col\u003e\u003cli\u003eFind the hill with the maximal height (if it is not unique, choose any).\u003c/li\u003e\u003cli\u003eRotate all the sequence in such a way that hill with maximal height goes  first. \u003c/li\u003e\u003cli\u003eFor convenience, add one more hill with maximum height to the end of the  sequence. (It will represent the first hill, which goes after the last  in the circle order).\u003c/li\u003e\u003c/ol\u003eNow we have almost the same problem on the straight line. One exception is that now first hill is doubled.\u003cbr /\u003e\u003cbr /\u003e\u003ci\u003eGeneral idea of the solution:\u003c/i\u003e\u003cbr /\u003e\u003cbr /\u003eConsider there is a pair of hills, such that these hills are visible from each other. Let\u0027s define hill with lower height (if heights are equal - with lower position) as \u003ci\u003eresponsible\u003c/i\u003e for adding this pair to the answer.\u003cbr /\u003e\u003cbr /\u003eFrom this point of view, hill x will adds to the answer 3 kinds of hills as his pair:\u003cbr /\u003e\u003cul\u003e\u003cli\u003eFirst hill to the left of the x, which is strictly higher than x. (Let\u0027s define its position as l[x])\u003c/li\u003e\u003cli\u003eFirst hill to the right of the x, which is strictly higher than x.  (Let\u0027s call this hill y and define it\u0027s position as r[x]).\u003c/li\u003e\u003cli\u003eAll hills that are as high as x and are located between x and y. (Let\u0027s  define this count as c[x]).\u003c/li\u003e\u003c/ul\u003eArrays r[x] and c[x] can be calculated by the following piece of code:\u003cbr /\u003e\u003cbr /\u003ec[n] \u003d 0;\u003cbr /\u003efor(int i \u003d n - 1; i \u0026gt;\u003d 0; --i) {\u003cbr /\u003e    r[i] \u003d i + 1;\u003cbr /\u003e    while (r[i] \u0026lt; n \u0026amp;\u0026amp; height[i] \u0026gt; height[r[i]]) r[i] \u003d r[r[i]];\u003cbr /\u003e    if (r[i] \u0026lt; n \u0026amp;\u0026amp; height[i] \u003d\u003d height[r[i]]) {\u003cbr /\u003e        c[i] \u003d c[r[i]] + 1;\u003cbr /\u003e        r[i] \u003d r[r[i]];\u003cbr /\u003e    }\u003cbr /\u003e}\u003cbr /\u003e\u003cbr /\u003eI am not going to prove here, that it works for the O(N) time, but believe it does :)\u003cbr /\u003e\u003cbr /\u003ePay attention, that r[x] is undefined for hills with maximum height and this algorithm will find r[x] \u003d n for such hills.\u003cbr /\u003e\u003cbr /\u003eArray l[x] can be found in a similar way.\u003cbr /\u003e\u003cbr /\u003eHaving l[x], r[x] and c[x], it\u0027s not so difficult to calculate the answer. We should just notice, that:\u003cbr /\u003e\u003cul\u003e\u003cli\u003eEach hill will add c[x] pairs to the answer.\u003c/li\u003e\u003cli\u003eEach hill, lower than maximal, will also add 2 pairs (x, l[x]) and (x,  r[x]) to the answer. The only corner case here is l[x] \u003d 0 and r[x] \u003d n, because (x, 0) and  (x, n) is the same pair of hills in the original problem, where hills  are circled.\u003cbr /\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e","tags":["codeforces beta round #5","tutorial"]}}