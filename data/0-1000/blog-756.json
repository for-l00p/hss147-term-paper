{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1287220350,"rating":5,"authorHandle":"yeputons","modificationTimeSeconds":1290804142,"id":756,"title":"Подсчет количества единичек в числе: сравнение скорости алгоритмов","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003eВроде бы простая задача: посчитать количество единичек в числе.\u003cbr /\u003eЯ знаю четыре способа её решения: \u0026quot;наивный\u0026quot; метод (пробежаться по всем битам), встроенная в Gcc функция \u003ci\u003e__builtin_popcount\u003c/i\u003e, предподсчёт для всех чисел \u0026lt; 0xFFFF и метод за \u003ci\u003elog log X\u003c/i\u003e.\u003cbr /\u003e \u003cbr /\u003eНаписал тестовую программу (с long long\u0027ами): \u003ca href\u003d\"http://pastebin.com/vTUPkK07\"\u003ehttp://pastebin.com/vTUPkK07\u003c/a\u003e\u003cbr /\u003eРезультаты на Core 2 Duo E4500 2.2 GHz (10^7 long long\u0027ов):\u003cbr /\u003e__builtin_popcount: 0.211\u003cbr /\u003ecountPrecalc: 0.129\u003cbr /\u003ecountLoglog: 0.269\u003cbr /\u003ecountSimple: 1.240\u003cbr /\u003eСамым быстрым оказался способ с предподсчётом - он делает наивный метод в 10 раз, а метод за loglog и встроенную функцию - в два.\u003cbr /\u003eЧто любопытно, если попытаться сократить количество операций в предподсчёте (не до 2^16, а до 2^22 - чтобы было 3 сложения вместо четырёх), скорость резко падает до 0.6 - т.е. уже её делают в два раза встроенная функция и loglog.\u003cbr /\u003e\u003cb\u003e\u003cbr /\u003eUPD\u003c/b\u003e: при замене \u003ci\u003eint cnt[]\u003c/i\u003e на \u003ci\u003echar cnt[]\u003c/i\u003e и компиляциис \u003ci\u003e-O2\u003c/i\u003e скорость \u003ci\u003ecountPrecalc\u003c/i\u003e возврастает в два раза. При компиляции с \u003ci\u003e-O3\u003c/i\u003e - еще в два - до \u003cspan\u003e0.048.\u003c/span\u003e\u003c/div\u003e","tags":["popcount","скорость"]}}