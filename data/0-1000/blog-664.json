{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1284323565,"rating":0,"authorHandle":"Borisp","modificationTimeSeconds":1284323565,"id":664,"title":"Solution of D contest 27","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003eI am applying the exact same solution as proposed in the \u003ca href\u003d\"http://codeforces.ru/blog/entry/653\"\u003etutorial\u003c/a\u003e, though using bfs instead of dfs.\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003e#define _CRT_SECURE_NO_DEPRECATE\u003cbr /\u003e#include\u0026lt;iostream\u0026gt;\u003cbr /\u003e#include\u0026lt;vector\u0026gt;\u003cbr /\u003e#include\u0026lt;set\u0026gt;\u003cbr /\u003e#include\u0026lt;map\u0026gt;\u003cbr /\u003e#include\u0026lt;stack\u0026gt;\u003cbr /\u003e#include\u0026lt;queue\u0026gt;\u003cbr /\u003e#include\u0026lt;string\u0026gt;\u003cbr /\u003e#include\u0026lt;sstream\u0026gt;\u003cbr /\u003e#include\u0026lt;deque\u0026gt;\u003cbr /\u003e#include\u0026lt;math.h\u0026gt;\u003cbr /\u003e#include\u0026lt;cstring\u0026gt;\u003cbr /\u003e#include \u0026lt;bitset\u0026gt;\u003cbr /\u003e#include\u0026lt;algorithm\u0026gt;\u003cbr /\u003e#include\u0026lt;stdio.h\u0026gt;\u003cbr /\u003e#include\u0026lt;stdlib.h\u0026gt;\u003cbr /\u003e\u003cbr /\u003e#define all(v) v.begin(),v.end()\u003cbr /\u003e#define mpair make_pair\u003cbr /\u003e\u003cbr /\u003eusing namespace std;\u003cbr /\u003etypedef long double ld;\u003cbr /\u003econst ld epsilon \u003d 1e-9;\u003cbr /\u003etypedef long long ll;\u003cbr /\u003evector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; roads;\u003cbr /\u003ebool intersect(int i, int j)\u003cbr /\u003e{\u003cbr /\u003e        int a \u003d (roads[i].first - roads[j].first) * (roads[i].second - roads[j].first);\u003cbr /\u003e        int b \u003d (roads[i].first - roads[j].second) * (roads[i].second - roads[j].second);\u003cbr /\u003e        int c \u003d (roads[j].first - roads[i].first) * (roads[j].second - roads[i].first);\u003cbr /\u003e        int d \u003d (roads[j].first - roads[i].second) * (roads[j].second - roads[i].second);\u003cbr /\u003e        if(a \u003d\u003d 0 || b \u003d\u003d 0 || c \u003d\u003d 0 || d \u003d\u003d 0)\u003cbr /\u003e                return false;\u003cbr /\u003e        if((a \u0026lt; 0) ^ (b \u0026lt; 0))\u003cbr /\u003e                return true;\u003cbr /\u003e        if((c \u0026lt; 0) ^ (d \u0026lt; 0))\u003cbr /\u003e                return true;\u003cbr /\u003e}\u003cbr /\u003eint main()\u003cbr /\u003e{\u003cbr /\u003e        //freopen(\u0026quot;bobi.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\u003cbr /\u003e        int n, m;\u003cbr /\u003e        cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\u003cbr /\u003e        vector\u0026lt;int\u0026gt; vis(m, -1);\u003cbr /\u003e        roads.resize(m);\u003cbr /\u003e        for(int i \u003d 0; i \u0026lt; m; i++)\u003cbr /\u003e                cin \u0026gt;\u0026gt; roads[i].first \u0026gt;\u0026gt; roads[i].second;\u003cbr /\u003e\u003cbr /\u003e        queue\u0026lt;int\u0026gt; toProcess;\u003cbr /\u003e        int cur;\u003cbr /\u003e        for(int i \u003d 0; i \u0026lt; m; i++)\u003cbr /\u003e        {\u003cbr /\u003e                if(vis[i] \u003d\u003d -1)\u003cbr /\u003e                {\u003cbr /\u003e\u003cbr /\u003e                        toProcess.push(i);\u003cbr /\u003e                        vis[i] \u003d 0;\u003cbr /\u003e                        while(!toProcess.empty())\u003cbr /\u003e                        {\u003cbr /\u003e                                cur\u003d toProcess.front();\u003cbr /\u003e                                toProcess.pop();\u003cbr /\u003e                                for(int j \u003d 0; j \u0026lt; m; j++)\u003cbr /\u003e                                {\u003cbr /\u003e                                        if(j \u003d\u003d cur)\u003cbr /\u003e                                                continue;\u003cbr /\u003e                                        if(intersect(cur, j))\u003cbr /\u003e                                        {\u003cbr /\u003e                                                if(vis[j] !\u003d -1)\u003cbr /\u003e                                                {\u003cbr /\u003e                                                        if(vis[j] \u003d\u003d vis[cur])\u003cbr /\u003e                                                        {\u003cbr /\u003e                                                                cout \u0026lt;\u0026lt; \u0026quot;Impossible\u0026quot; \u0026lt;\u0026lt; endl;\u003cbr /\u003e                                                                return 0;\u003cbr /\u003e                                                        }\u003cbr /\u003e                                                }\u003cbr /\u003e                                                else\u003cbr /\u003e                                                {\u003cbr /\u003e                                                        vis[j] \u003d !vis[cur];\u003cbr /\u003e                                                        toProcess.push(j);\u003cbr /\u003e                                                }\u003cbr /\u003e                                        }\u003cbr /\u003e                                }\u003cbr /\u003e                        }\u003cbr /\u003e                }\u003cbr /\u003e        }\u003cbr /\u003e        for(int i \u003d 0; i \u0026lt; m; i++)\u003cbr /\u003e                if(vis[i] \u003d\u003d 0)\u003cbr /\u003e                        cout \u0026lt;\u0026lt; \u0026quot;i\u0026quot;;\u003cbr /\u003e                else\u003cbr /\u003e                        cout \u0026lt;\u0026lt; \u0026quot;o\u0026quot;;\u003cbr /\u003e        cout \u0026lt;\u0026lt; endl;\u003cbr /\u003e        return 0;\u003cbr /\u003e}\u003c/div\u003e","tags":["27","bfs","ring road"]}}