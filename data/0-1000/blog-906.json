{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1291112185,"rating":-1,"authorHandle":"A.K.Goharshady","modificationTimeSeconds":1291112457,"id":906,"title":"How to solve Codeforces 42(Div.2)","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv\u003eThis is a semi-Tutorial for codeforces #42 (Div.2) , I\u0027m not going to explain everything but I\u0027m just telling the ideas.\u003c/div\u003e\u003cdiv\u003eThe problems were extremely nice.\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003eA) This is pretty obvious , you can store the two strings and how many times each of them occurred\u003c/div\u003e\u003cdiv\u003eB) For each of the upper or lower case letters , take care about how many times it appeared in each of the strings. if for a character x , repetitions of x in the second string is more than the first string , we can\u0027t make it , otherwise the answer is YES.\u003c/div\u003e\u003cdiv\u003eC) We all know that the remainder of a number when divided by 3 is equal to the remainder of sum of its digits when divided by three. So we can put all of input numbers in 3 sets based on their remainder by 3. Those with remainder 1 can be matched with those with remainder 2 and those with remainder 0 can be matched with themselves. so the answer is:\u003c/div\u003e\u003cdiv\u003ehalf of number of those divisible by three + minimum of those having a remainder of 1 and those having a remainder of 2\u003c/div\u003e\u003cdiv\u003eD) Actually we\u0027re looking for an Eulerian tour. I found it like this:\u003c/div\u003e\u003cdiv\u003eIf at least one of m and n was even do it like this figure:\u003c/div\u003e\u003cdiv\u003e \u003cdl\u003e  \u003cdl\u003e   \u003cdl\u003e    \u003cdl\u003e     \u003cdl\u003e      \u003cdl\u003e       \u003cdl\u003e        \u003cdl\u003e         \u003cdl\u003e          \u003cdl\u003e           \u003cdl\u003e            \u003cdl\u003e             \u003cdl\u003e              \u003cdl\u003e               \u003cdd\u003e              \u003c/dd\u003e\u003c/dl\u003e             \u003c/dl\u003e            \u003c/dl\u003e           \u003c/dl\u003e          \u003c/dl\u003e         \u003c/dl\u003e        \u003c/dl\u003e       \u003c/dl\u003e      \u003c/dl\u003e     \u003c/dl\u003e    \u003c/dl\u003e   \u003c/dl\u003e  \u003c/dl\u003e \u003c/dl\u003e\u003c/div\u003e\u003cdiv style\u003d\"text-align: center;\"\u003e\u003cimg src\u003d\"/predownloaded/e5/94/e5946f4cd67bf11014ba68319c94b3ce14ca57cc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003eelse do it like this and add a teleport from last square to the first:\u003c/div\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdl\u003e\u003cdl\u003e\u003cdl\u003e\u003cdl\u003e\u003cdl\u003e\u003cdl\u003e\u003cdl\u003e\u003cdl\u003e\u003cdl\u003e\u003cdl\u003e\u003cdl\u003e\u003cdl\u003e\u003cdl\u003e\u003cdl\u003e\u003cdl\u003e\u003cdd\u003e\u003cimg src\u003d\"/predownloaded/d4/d1/d4d1769884b70ac7d96e5c9c7e2d9cb6ccadbf8c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/dd\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003c/dl\u003e\u003c/dl\u003e\u003c/dl\u003e\u003c/dl\u003e\u003c/dl\u003e\u003c/dl\u003e\u003c/dl\u003e\u003c/dl\u003e\u003c/dl\u003e\u003c/dl\u003e\u003c/dl\u003e\u003c/dl\u003e\u003c/dl\u003e\u003c/dl\u003e\u003c/dl\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003eBut there were really nice hacks as I studied them. like these two:\u003c/div\u003e\u003cdiv\u003e1 10\u003c/div\u003e\u003cdiv\u003eand\u003c/div\u003e\u003cdiv\u003e1 2\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003eE) Let\u0027s just take care about 2 cars and see how many times they change their position. This is easy. Then do this for all cars :D\u003c/div\u003e\u003c/div\u003e","tags":["codeforces"]}}