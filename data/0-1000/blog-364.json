{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1273167488,"rating":27,"authorHandle":"KADR","modificationTimeSeconds":1311597250,"id":364,"title":"Codeforces Beta Round #13 editorial","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eLet me introduce an editorial to Codeforces Beta Round #13. If you have any questions or propositions - feel free to post them in the comments.\u003cbr /\u003e\u003c/p\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003e \u003c/div\u003e\u003cdiv\u003e\u003cb\u003eProblem A.\u003c/b\u003e\u003c/div\u003e\u003cdiv\u003eIt is sufficient to iterate over all bases from 2 to A-2 and find the sum of digits in them. Then one should find the greatest common divisor of found sum and A-2 (which is equal to number of bases in which we found the sums). The numerator of the answer is equal to founded sum divided by this GCD and the denominator is equal to A-2 divided by this GCD.\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003eThe complexity is O(A).\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003e\u003cb\u003eProblem B.\u003c/b\u003e\u003c/div\u003e\u003cdiv\u003eThis problem appeared to be quite unpleasant to code, but all what one need to do is to check whether all three statements are true. It is recommended to perform all computations using integer arithmetics and to use scalar and vector product instead of computing cosines of angles or angles itself.\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003e\u003cb\u003eProblem C.\u003c/b\u003e\u003c/div\u003e\u003cdiv\u003eNote, that there exists a non-decreasing sequence, which can be obtained from the given sequence using minimal number of moves and in which all elements are equal to some element from the initial sequence (i.e. which consists only from the numbers from the initial sequence).\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003eSuppose {a\u003csub\u003ei\u003c/sub\u003e} is the initial sequence, {b\u003csub\u003ei\u003c/sub\u003e} is the same sequence, but in which all elements are distinct and they are sorted from smallest to greatest. Let f(i,j) be the minimal number of moves required to obtain the sequence in which the first i elements are non-decreasing and i-th element is at most b\u003csub\u003ej\u003c/sub\u003e. In that case the answer to the problem will be equals to f(n,k), where n is the length of {a\u003csub\u003ei\u003c/sub\u003e} and k is the length of {b\u003csub\u003ei\u003c/sub\u003e}. We will compute f(i,j) using the following recurrences:\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003e\u003cdiv style\u003d\"margin-top: 0.0px;margin-right: 0.0px;margin-bottom: 0.0px;margin-left: 0.0px;padding-top: 0.0px;padding-right: 0.0px;padding-bottom: 0.0px;padding-left: 0.0px;font-family: verdana , arial , sans-serif;font-size: 12.0px;line-height: 20.0px;\"\u003ef(1,1)\u003d|a\u003csub\u003e1\u003c/sub\u003e-b\u003csub\u003e1\u003c/sub\u003e|\u003c/div\u003e\u003cdiv style\u003d\"margin-top: 0.0px;margin-right: 0.0px;margin-bottom: 0.0px;margin-left: 0.0px;padding-top: 0.0px;padding-right: 0.0px;padding-bottom: 0.0px;padding-left: 0.0px;font-family: verdana , arial , sans-serif;font-size: 12.0px;line-height: 20.0px;\"\u003ef(1,j)\u003dmin{|a\u003csub\u003e1\u003c/sub\u003e-b\u003csub\u003ej\u003c/sub\u003e|,f(1,j-1)},  j\u0026gt;1\u003c/div\u003e\u003cdiv style\u003d\"margin-top: 0.0px;margin-right: 0.0px;margin-bottom: 0.0px;margin-left: 0.0px;padding-top: 0.0px;padding-right: 0.0px;padding-bottom: 0.0px;padding-left: 0.0px;font-family: verdana , arial , sans-serif;font-size: 12.0px;line-height: 20.0px;\"\u003ef(i,1)\u003d|a\u003csub\u003ei\u003c/sub\u003e-b\u003csub\u003e1\u003c/sub\u003e|+f(i-1,1),  i\u0026gt;1\u003c/div\u003e\u003cdiv style\u003d\"margin-top: 0.0px;margin-right: 0.0px;margin-bottom: 0.0px;margin-left: 0.0px;padding-top: 0.0px;padding-right: 0.0px;padding-bottom: 0.0px;padding-left: 0.0px;font-family: verdana , arial , sans-serif;font-size: 12.0px;line-height: 20.0px;\"\u003ef(i,j)\u003dmin{f(i,j-1),f(i-1,j)+|a\u003csub\u003ei\u003c/sub\u003e-b\u003csub\u003ej\u003c/sub\u003e|},  i\u0026gt;1, j\u0026gt;1\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003eThe complexity is O(N\u003csup\u003e2\u003c/sup\u003e). To avoid memory limit one should note that to compute f(i,*) you only need to know f(i-1,*) and the part of i-th row which is already computed. \u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003e\u003cb\u003eProblem D.\u003c/b\u003e\u003c/div\u003e\u003cdiv\u003e\u003cb\u003e\u003cbr /\u003e\u003c/b\u003e\u003c/div\u003e\u003cdiv\u003eWe will solve the problem using the following algorithm:\u003c/div\u003e\u003cdiv\u003e\u003col\u003e\u003cli\u003eFix some red point.\u003c/li\u003e\u003cli\u003eFind the number of triangles with vertices in the red points which don\u0027t contain any blue points inside and which have the fixed red point as one of the vertices.\u003c/li\u003e\u003cli\u003eRemove the fixed red point and go back to statement 1, if there remain any red point.\u003c/li\u003e\u003c/ol\u003e\u003cdiv\u003eThe first and third statements are obvious, so the main part of the solution is statement 2.\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003eSuppose the red point A is fixed (in the first statement). Also suppose we have all other points which are still not removed (blue and red together) sorted by angle around the point A. We will iterate over all red points B, which will be the second vertice of triangle. Now, we need to find the number of triangles with vertices in red points which have points A and B as two vertices and which don\u0027t contain any blue point inside.\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003eTo solve this problem we will iterate over all unremoved points C in the increasing order of angle ABC starting from the point after the point B (in the same order). To avoid double counting we will stop when the angle between vectors AB and AC become greater than 180 degrees or when we reach the point which was already considered. Then we will perform such actions:\u003c/div\u003e\u003cdiv\u003e\u003cul\u003e\u003cli\u003eIf C is red then we will check whether there are blue points inside triangle ABC and if not - we will increase the answer by 1. Note, that to perform this check we don\u0027t need to iterate over all blue points. It is sufficient to maintain such point D from the ones which we have already seen for which the angle ABD is the smallest possible. If D doesn\u0027t lies inside the triangle ABC, then there is no blue point which lies inside it.\u003c/li\u003e\u003cli\u003eIf C is blue, then we will compare the angle ABC with ABD and if ABC is smaller, we will replace old D with C.\u003c/li\u003e\u003c/ul\u003e\u003cdiv\u003eNote, that after choosing new B we consider that there is no point D and there will be no blue points inside triangles ABC until we reach the first blue point.\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003eThe complexity is O(N\u003csup\u003e2\u003c/sup\u003e(N+M)). \u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003e\u003cb\u003eProblem E.\u003c/b\u003e\u003c/div\u003e\u003cdiv\u003e\u003cb\u003e\u003cbr /\u003e\u003c/b\u003e\u003c/div\u003e\u003cdiv\u003eLet\u0027s divide all row into blocks of length K\u003dsqrt(N) of consecutive holes. If N is not a complete square, then we will take K\u003dsqrt(N) rounded down. For each hole we will maintain not only it\u0027s power (let\u0027s call it power[i]), but also the number of the first hole which belongs to other block and which can be reached from the current one with sequence of jumps (let\u0027s call it next[i]). Also, for each hole we will maintain the number of jumps required to reach the hole next[i] from the current one (let\u0027s call it count[i]). We will consider that there is a fictious hole, which lies after the hole N and it belongs to it\u0027s own block.\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003eTo answer the query of the first type (when the ball is thrown) we will jump from the hole i to hole next[i] and so on, until we reach the fictious hole. Each time we will add count[i] to the answer. We will jump not more than N/K times.\u003c/div\u003e\u003cdiv\u003eTo maintain the query of the seqond type (when the power of hole i is changed) we will change power[i], next[i] and count[i]. Then for each hole which belongs to the same block as i and has smaller number than i we will update next[i] and power[i] in decreasing order of number of the hole. We will perform not more than K updates.\u003c/div\u003e\u003cdiv\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv\u003eThe complexity is O(Nsqrt(N)).\u003c/div\u003e\u003c/div\u003e","tags":["beta round #13","codeforces","editorial"]}}