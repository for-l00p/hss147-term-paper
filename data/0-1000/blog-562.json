{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1280418691,"rating":20,"authorHandle":"freopen","modificationTimeSeconds":1283281145,"id":562,"title":"Ввод/вывод в C++","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003eМне захотелось наконец разобраться в способах ввода-вывода в C++, какой из них быстрее и удобнее. Поэтому я написал \u003ca href\u003d\"http://pastebin.com/DpmjHF7C\"\u003eпрогу\u003c/a\u003e, которая проверит скорость работы основных способов ввода/вывода в C++.\u003cdiv\u003eИтак, разберем все тесты по порядку:\u003c/div\u003e\u003cdiv\u003e\u003cspan style\u003d\"border-collapse: collapse;color: rgb(170,170,170);font-family: verdana , arial , sans-serif;font-size: 13.0px;\"\u003e \u003c/span\u003e\u003c/div\u003e\u003cblockquote style\u003d\"margin: 0 0 0 40.0px;border: none;padding: 0.0px;\"\u003e\u003c/blockquote\u003e\u003ch3\u003eВывод программы\u003cbr /\u003e\u003c/h3\u003e\u003cblockquote style\u003d\"margin: 0 0 0 40.0px;border: none;padding: 0.0px;\"\u003e\u003cdiv\u003eTest: (printf, 10000000 ints) 2.50c\u003c/div\u003e\u003cdiv\u003eTest: (cout, 10000000 ints) 3.02c\u003c/div\u003e\u003cdiv\u003eTest: (write, 10000000 ints, 104827485 chars) 2.88c + 0.25c\u003c/div\u003e\u003cdiv\u003eTest: (scanf, 10000000 ints) 2.61c\u003c/div\u003e\u003cdiv\u003eTest: (fwrite, 10000000 ints, 104827485 chars) 2.88c + 0.26c\u003c/div\u003e\u003cdiv\u003eTest: (cin, 10000000 ints) 8.32c\u003c/div\u003e\u003cdiv\u003eTest: (printf, 100000000 chars) 1.87c\u003c/div\u003e\u003cdiv\u003eTest: (scanf, 100000000 chars) 8.44c\u003c/div\u003e\u003cdiv\u003eTest: (cout, 100000000 chars) 6.98c\u003c/div\u003e\u003cdiv\u003eTest: (cin, 100000000 chars) 12.51c\u003c/div\u003e\u003cdiv\u003eTest: (putchar, 100000000 chars) 2.26c\u003c/div\u003e\u003cdiv\u003eTest: (getchar, 100000000 chars) 1.99c\u003c/div\u003e\u003cdiv\u003eTest: (read, 100000000 chars) 0.08c + 0.57c\u003c/div\u003e\u003cdiv\u003eTest: (fread, 100000000 chars) 0.08c + 0.59c\u003c/div\u003e\u003c/blockquote\u003e\u003ch3\u003eРазбор тестов\u003c/h3\u003e\u003cdiv\u003e\u003cdiv\u003e\u003col\u003e\u003cli\u003e\u003cfont color\u003d\"#AAAAAA\" face\u003d\"verdana, arial, sans-serif\" size\u003d\"3\"\u003e\u003cspan style\u003d\"color: rgb(0,0,0);font-family: \u0026quot;Times New Roman\u0026quot;;\"\u003eprintf вывел 10\u003csup\u003e7 \u003c/sup\u003eцелых чисел. Относительно быстро и удобно. Вполне можно использовать.\u003c/span\u003e\u003cbr /\u003e\u003c/font\u003e\u003c/li\u003e\u003cli\u003eТоже самое сделал cout. Немного медленнее, но это когда как. Иногда cout работает довольно медленно.\u003c/li\u003e\u003cli\u003ewrite, как функция ostream. Работает быстро. Очень быстро. Похоже, что в основе лежит fwrite. Первое время - преобразование чисел в строку. Второе - вывод. Примечательно, что вывод куда быстрее.\u003c/li\u003e\u003cli\u003escanf. Работает ровно также как и printf. Сносно и удобно в использовании.\u003c/li\u003e\u003cli\u003efwrite. Функция из C. Работает идентично write и сравнимо с ней по сложности использования. Ну может чуть чуть сложнее.\u003c/li\u003e\u003cli\u003eВот и первый fail. cin считывает числа медленно. Раза в 4 медленнее, чем все остальное. Если вам в программе требуется считать миллион чисел, готовьтесь потратить на это 0.8 секунд cin-а. А возможно и больше.\u003c/li\u003e\u003cli\u003eПереходим к символам. printf выводит символы чуть быстрее, чем числа. Видимо, из-за отсутствия необходимости преобразовывать число.\u003c/li\u003e\u003cli\u003eА вот это стало неожиданностью. scanf на редкость медленно читает символы. Файлик был размером около 100Мб, но все равно мог бы и побыстрее.\u003c/li\u003e\u003cli\u003ecout выводит символы медленно. В 3 раза медленнее, чем printf.\u003c/li\u003e\u003cli\u003ecin считывает символы совсем медленно. У меня уходило 1.2 секунды на каждые 10Мб. Есть и еще один сюрприз. Он выкидывает whitespace. Даже когда считывает один символ. Про это надо не забывать. Лечится так: cin \u0026gt;\u0026gt; noskipws;\u003c/li\u003e\u003cli\u003eputchar. Предназначен для вывода одного символа. И это у него выходит прекрасно. \u003c/li\u003e\u003cli\u003egetchar. Предназначен для ввода одного символа. И также он это делает очень быстро.\u003c/li\u003e\u003cli\u003eНаконец, блочный ввод-вывод. Опять указано два параметра. Первый - время считывания. Второй - проверка на правильность считывания. Второй нужен только для сравнения. Данные предсказуемо совпадают.\u003c/li\u003e\u003cli\u003eСм. выше\u003c/li\u003e\u003c/ol\u003e\u003ch3\u003eВывод\u003c/h3\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003col\u003e\u003cli\u003eДля чисел лучше использовать cin(если время не очень критично), или printf(если критично).\u003c/li\u003e\u003cli\u003eДля символов лучше использовать getchar и putchar.\u003c/li\u003e\u003cli\u003eЧто-то мне не верится в возможность считать 100Мб данных в оперативку за 0.08 секунд. Есть версия, что файл был кеширован в оперативке. Кто знает, как это проверить и как исправить - пишите в комменты.\u003c/li\u003e\u003cli\u003eНадо доделать тесты для строк и дробного типа. Но это уже попозже.\u003c/li\u003e\u003c/ol\u003e\u003ch3\u003eТем, кто хочет проверить это на своем компьютере\u003c/h3\u003e\u003c/div\u003e\u003cdiv\u003eПожалуйста. Вот программа: \u003ca href\u003d\"http://pastebin.com/DpmjHF7C\"\u003ehttp://pastebin.com/DpmjHF7C\u003c/a\u003e. Учтите, что она заменит файл temp.txt на свой, а также ей надо 100Мб свободного места и 200Мб оперативки. И пришлите мне вывод программы в комменты или в личку. Под влиянием этих данных, я возможно, изменю разбор тестов. Большое спасибо всем, кто запустит прогу у себя и пришлет мне результаты, а также тем, кто укажет мне на неточности в программе или предложит другие тесты.\u003c/div\u003e\u003c/div\u003e","tags":["c++","ввод-вывод","тестирование"]}}