{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1272437467,"rating":22,"authorHandle":"Ripatti","modificationTimeSeconds":1282570781,"id":337,"title":"A little bit of classics: dynamic programming over subsets and paths in graphs","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ci\u003eAuthor thanks \u003c/i\u003e\u003ca class\u003d\"rated-user\" href\u003d\"../../../profile/adamax\" title\u003d\"Капитан adamax\"\u003eadamax\u003c/a\u003e\u003ci\u003e \u003cspan\u003e\u003cspan style\u003d\"\" title\u003d\"\"\u003efor  translation this article into English.\u003c/span\u003e\u003c/span\u003e\u003c/i\u003e\u003cbr /\u003e\u003cbr /\u003e\u003cb\u003eIntroduction\u003c/b\u003e\u003cbr /\u003eAfter \u003ca href\u003d\"http://codeforces.ru/blog/entry/331\"\u003eCodeforces Beta Round #11\u003c/a\u003e several participants expressed a wish to read something about problems similar to \u003ca href\u003d\"http://codeforces.ru/contest/11/problem/D\"\u003eproblem D\u003c/a\u003e of that round. The author of this article, for the purpose of helping them, tried searching for such information, but to his surprise couldn\u0027t find anything on the Internet. It is not known whether the search was not thorough or there\u0027s really nothing out there, but (just in case) the author decided to write his own article on this topic.\u003cbr /\u003e\u003cbr /\u003eIn some sense this article may be regarded as a tutorial for the \u003ca href\u003d\"http://codeforces.ru/contest/11/problem/D\"\u003eproblem D\u003c/a\u003e from Beta Round #11.\u003cbr /\u003e\u003cbr /\u003e \u003cbr /\u003e\u003cbr /\u003eIn this article quite well-known algorithms are considered: the search for optimal Hamiltonian walks and cycles, finding their number, check for existence and something more. The so-called \u0026quot;dynamic programming over subsets\u0026quot; is used. This method requires exponential time and memory and therefore can be used only if the graph is very small - typically 20 vertices or less.\u003cbr /\u003e\u003cbr /\u003e\u003cb\u003eDP over subsets\u003c/b\u003e\u003cbr /\u003eConsider a set of elements numbered from 0 to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - 1\u003c/span\u003e. Each subset of this set can be encoded by a sequence of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e bits (we will call this sequence \u0026quot;a mask\u0026quot;). The \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th element belongs to the subset if and only if the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th bit of the mask equals 1. For instance, the mask \u003cspan class\u003d\"tex-span\"\u003e00010011\u003c/span\u003e means that the subset of the set \u003cspan class\u003d\"tex-span\"\u003e[0... 7]\u003c/span\u003e consists of elements 0, 1 and 4. There are totally \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e masks, and so \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e subsets. Each mask is in fact an integer number written in binary notation.\u003cbr /\u003e\u003cbr /\u003eThe method is to assign a value to each mask (and, therefore, to each subset) and compute the values for new masks using already computed values. As a rule, to find the value for a subset \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e we remove an element in every possible way and use values for obtained subsets \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u0027\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eA\u003c/i\u003e\u0027\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ... , \u003ci\u003eA\u003c/i\u003e\u0027\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to compute the value for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e. This means that the values for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u0027\u003c/span\u003e must have been computed already, so we need to establish an ordering in which masks will be considered. It\u0027s easy to see that the natural ordering will do: go over masks in increasing order of corresponding numbers.\u003cbr /\u003e\u003cbr /\u003eWe will use the following notation:\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebit\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003emask\u003c/i\u003e)\u003c/span\u003e - the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th bit of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecount\u003c/i\u003e(\u003ci\u003emask\u003c/i\u003e)\u003c/span\u003e - the number of non-zero bits in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efirst\u003c/i\u003e(\u003ci\u003emask\u003c/i\u003e)\u003c/span\u003e - the number of the lowest non-zero bit in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e?\u003ci\u003eb\u003c/i\u003e: \u003ci\u003ec\u003c/i\u003e)\u003c/span\u003e - returns \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e holds, or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e otherwise.\u003cbr /\u003eThe elements of our set will be vertices of the graph. For the sake of simplicity we\u0027ll assume that the graph is undirected. Modification of the algorithms for directed graphs is left as an exercise for the reader.\u003cbr /\u003e\u003cbr /\u003e\u003cb\u003e1. Search for the shortest Hamiltonian walk\u003c/b\u003e\u003cbr /\u003eLet the graph \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e \u003d (\u003ci\u003eV\u003c/i\u003e, \u003ci\u003eE\u003c/i\u003e)\u003c/span\u003e have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e vertices, and each edge \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9b/6d/9b6de38d1b0c16b487db5585a3812af8e991860e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e have a weight \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e. We want to find a Hamiltonian walk for which the sum of weights of its edges is minimal.\u003cbr /\u003e\u003cbr /\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003emask\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e be the length of the shortest Hamiltonian walk in the subgraph generated by vertices in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e, that ends in the vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e.\u003cbr /\u003e\u003cbr /\u003eThe DP can be calculated by the following formulas:\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003emask\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e] \u003d 0\u003c/span\u003e, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecount\u003c/i\u003e(\u003ci\u003emask\u003c/i\u003e) \u003d 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebit\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003emask\u003c/i\u003e) \u003d 1\u003c/span\u003e;\u003cbr /\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/34/26/3426930acf69966a0cb4a7bd1597f0bb1277cfdf.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecount\u003c/i\u003e(\u003ci\u003emask\u003c/i\u003e) \u0026gt; 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebit\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003emask\u003c/i\u003e) \u003d 1\u003c/span\u003e;\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003emask\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e] \u003d ∞\u003c/span\u003e in other cases.\u003cbr /\u003e\u003cbr /\u003eNow the desired minimal length is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/be/18/be18208d8321f93b3ff1e7c11018f9e3df9b3c67.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003emin\u003c/i\u003e\u003c/sub\u003e \u003d ∞\u003c/span\u003e, then there is no Hamiltonian walk in the graph. Otherwise it\u0027s easy to recover the walk itself. Let the minimal walk end in the vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Then the vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e ≠ \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, for which \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9e/28/9e2806b497b102b0fb77dbc7188cbb33944e0eb3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, is the previous vertex in the path. Now remove \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e from the set and find the vertex previous to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e in the same way. Continuing this process until only one vertex is left, we\u0027ll find the whole Hamiltonian walk.\u003cbr /\u003e\u003cbr /\u003eThis solution requires \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e of memory and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e of time.\u003cbr /\u003e\u003cbr /\u003e\u003cb\u003e2. Finding the number of Hamiltonian walks\u003c/b\u003e\u003cbr /\u003eLet the graph \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e \u003d (\u003ci\u003eV\u003c/i\u003e, \u003ci\u003eE\u003c/i\u003e)\u003c/span\u003e be unweighted. We\u0027ll modify the previous algorithm. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003emask\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e be the number of Hamiltonian walks on the subset \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e, which end in the vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. The DP is rewritten in the following way:\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003emask\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e] \u003d 1\u003c/span\u003e, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecount\u003c/i\u003e(\u003ci\u003emask\u003c/i\u003e) \u003d 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebit\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003emask\u003c/i\u003e) \u003d 1\u003c/span\u003e;\u003cbr /\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/11/1c/111ceb457d3800af6e186bfc56803eb573020b8e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecount\u003c/i\u003e(\u003ci\u003emask\u003c/i\u003e) \u0026gt; 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebit\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003emask\u003c/i\u003e) \u003d 1\u003c/span\u003e;\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003emask\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e] \u003d 0\u003c/span\u003e in other cases.\u003cbr /\u003e\u003cbr /\u003eThe answer is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/38/23/3823ae756b1c49b12adee8fc39fbd1f92d39214f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003cbr /\u003e\u003cbr /\u003eThis solution requires \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e of memory and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e of time.\u003cbr /\u003e\u003cbr /\u003e\u003cb\u003e3. Finding the number of simple paths\u003c/b\u003e\u003cbr /\u003eCalculate the DP from the previous paragraph. The answer is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8a/98/8a98229c0efdce4b3c8d09891c5f6cec3cd7c343.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. The coefficient \u003cspan class\u003d\"tex-span\"\u003e1 / 2\u003c/span\u003e is required because each simple path is considered twice - in both directions. Also note that only paths of positive length are taken into account. You can add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e zero-length paths, of course.\u003cbr /\u003e\u003cbr /\u003eThis solution requires \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e of memory and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e of time.\u003cbr /\u003e\u003cbr /\u003e\u003cb\u003e4. Check for existence of Hamiltonian walk\u003c/b\u003e\u003cbr /\u003eWe can use solution 2 replacing the sum with bitwise OR. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003emask\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e will contain a boolean value - whether there exists a Hamiltonian walk over the subset \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e which ends in the vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. DP is the following:\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003emask\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e] \u003d 1\u003c/span\u003e, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecount\u003c/i\u003e(\u003ci\u003emask\u003c/i\u003e) \u003d 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebit\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003emask\u003c/i\u003e) \u003d 1\u003c/span\u003e;\u003cbr /\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a1/ad/a1ad02ed3bbc7c7a47a69989f1801f563ef02ffb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecount\u003c/i\u003e(\u003ci\u003emask\u003c/i\u003e) \u0026gt; 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebit\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003emask\u003c/i\u003e) \u003d 1\u003c/span\u003e;\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003emask\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e] \u003d 0\u003c/span\u003e in other cases.\u003cbr /\u003e\u003cbr /\u003eThis solution, like solution 2, requires \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e of memory and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e of time. It can be improved in the following way.\u003cbr /\u003e\u003cbr /\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u0027[\u003ci\u003emask\u003c/i\u003e]\u003c/span\u003e be the mask of the subset consisting of those vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e for which there exists a Hamiltonian walk over the subset \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e ending in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. In other words, we \u0027compress\u0027 the previous DP: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u0027[\u003ci\u003emask\u003c/i\u003e]\u003c/span\u003e equals \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/09/3d/093d34b7e9c55bf55cc670535f3eefab75eb497c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. For the graph \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e write out \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e masks \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, which give the subset of vertices incident to the vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. That is, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/fa/bb/fabb6cb31765a407d9bfa403a752e334a936c67f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003cbr /\u003e\u003cbr /\u003eDP will be rewritten in the following way:\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u0027[\u003ci\u003emask\u003c/i\u003e] \u003d 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecount\u003c/i\u003e(\u003ci\u003emask\u003c/i\u003e) \u003d 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebit\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003emask\u003c/i\u003e) \u003d 1\u003c/span\u003e;\u003cbr /\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8a/71/8a71895860a57cfc1e3eed2c8e547a1bb90f8044.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecount\u003c/i\u003e(\u003ci\u003emask\u003c/i\u003e) \u0026gt; 1\u003c/span\u003e;\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u0027[\u003ci\u003emask\u003c/i\u003e] \u003d 0\u003c/span\u003e in other cases.\u003cbr /\u003e\u003cbr /\u003ePay special attention to the expression \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/fb/b0/fbb0e28538d013709b2dc40cd33c26f6dae5f71e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. The first part of the expression is the subset of vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, for which there exists a Hamiltonian walk over the subset \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e minus vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, ending in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. The second part of the expression is the set of vertices incident to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. If these subsets have non-empty intersection (their bitwise AND is non-zero), then it\u0027s easy to see that there exists a Hamiltonian walk in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e ending in the vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e.\u003cbr /\u003e\u003cbr /\u003eThe final test is to compare \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e - 1]\u003c/span\u003e to 0.\u003cbr /\u003e\u003cbr /\u003eThis solution uses \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e of memory and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e of time.\u003cbr /\u003e\u003cbr /\u003e\u003cb\u003e5. Finding the shortest Hamiltonian cycle\u003c/b\u003e\u003cbr /\u003eSince we don\u0027t care at which vertex the cycle starts, assume that it starts at 0. Now use solution 1 for the subset of vertices, changing the formulas in the following way:\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[1][0] \u003d 0\u003c/span\u003e;\u003cbr /\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/34/26/3426930acf69966a0cb4a7bd1597f0bb1277cfdf.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026gt; 0\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebit\u003c/i\u003e(0, \u003ci\u003emask\u003c/i\u003e) \u003d 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebit\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003emask\u003c/i\u003e) \u003d 1\u003c/span\u003e;\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003emask\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e] \u003d ∞\u003c/span\u003e in other cases.\u003cbr /\u003e\u003cbr /\u003eSo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003emask\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e contains the length of the shortest Hamiltonian walk over the subset \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e, starting at 0 and ending at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e.\u003cbr /\u003e\u003cbr /\u003eThe required minimum is calculated by the formula \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/20/e8/20e8be2659ed206676daedffa99d654cbf8750b3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. If it equals \u003cspan class\u003d\"tex-span\"\u003e∞\u003c/span\u003e, there is no Hamiltonian cycle. Otherwise the Hamiltonian cycle can be restored by a method similar to solution 1.\u003cbr /\u003e\u003cbr /\u003e\u003cb\u003e6. Finding the number of Hamiltonian cycles\u003c/b\u003e\u003cbr /\u003eUsing ideas from solutions 5 and 2 one can derive a DP calculating the number of Hamiltonian cycles requiring \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e of time and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e of memory.\u003cbr /\u003e\u003cbr /\u003e\u003cb\u003e7. Finding the number of simple cycles\u003c/b\u003e\u003cbr /\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003emask\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e be the number of Hamiltonian walks over the subset \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e, starting at the vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efirst\u003c/i\u003e(\u003ci\u003emask\u003c/i\u003e)\u003c/span\u003e and ending at the vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. DP looks like this:\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003emask\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e] \u003d 1\u003c/span\u003e, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecount\u003c/i\u003e(\u003ci\u003emask\u003c/i\u003e) \u003d 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebit\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003emask\u003c/i\u003e) \u003d 1\u003c/span\u003e;\u003cbr /\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4b/ee/4bee02e9b2170bcec7148796498abe601e921f24.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecount\u003c/i\u003e(\u003ci\u003emask\u003c/i\u003e) \u0026gt; 1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebit\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003emask\u003c/i\u003e) \u003d 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e ≠ \u003ci\u003efirst\u003c/i\u003e(\u003ci\u003emask\u003c/i\u003e)\u003c/span\u003e;\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003emask\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e] \u003d 0\u003c/span\u003e otherwise.\u003cbr /\u003e\u003cbr /\u003eThe answer is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ff/80/ff80900b6cdcb90111af74aaa725fadb41cbc504.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003cbr /\u003e\u003cbr /\u003eThis solution requres \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e of time and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e of memory.\u003cbr /\u003e\u003cbr /\u003e\u003cb\u003e8. Checking for existence of Hamiltonian cycle\u003c/b\u003e\u003cbr /\u003eWe can modify solution 5 and, using the trick from solution 4, obtain an algorithm requiring \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e of time and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e of memory.\u003cbr /\u003e\u003cbr /\u003e\u003cb\u003eExercises\u003c/b\u003e\u003cbr /\u003e\u003ca href\u003d\"http://codeforces.ru/contest/11/problem/D\"\u003eCFBR11D\u003c/a\u003e\u003cbr /\u003e\u003ca href\u003d\"http://www.codechef.com/problems/TOOLS\"\u003eCCTOOLS\u003c/a\u003e\u003cbr /\u003e\u003cbr /\u003e\u003cb\u003eP.S.\u003c/b\u003e This article may be extended and fixed in future. The author would be grateful for supplementing the Exercises section and for pointing out any mistakes and inaccuracies.\u003c/div\u003e","tags":["algorithms","dynamic programming","graphs"]}}