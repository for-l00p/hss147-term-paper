{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1288468840,"rating":21,"authorHandle":"NALP","modificationTimeSeconds":1288471644,"id":807,"title":"Школьная индивидуальная олимпиада #1 - Codeforces Beta Round #38. (Разбор задачи G)","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eЗадача G. \u0026quot;Очередь\u0026quot;\u003c/h1\u003eДанная задача имеет несколько возможных решений, но я расскажу 2 возможных подхода:\u003cbr /\u003e\u003cbr /\u003e\u003ch2\u003e1. Декартово дерево (дуча, treap или дерамида)\u003c/h2\u003eБудем считать, что читатели знакомы с этой структурой (если это не так, то советую почитать \u003ca href\u003d\"http://e-maxx.ru/algo/treap\"\u003eтут\u003c/a\u003e). Самое простой по логике подход использует неявное декартово дерево, и этот алгоритм действует так: будем добавлять людей по очереди, в порядке их прихода. В вершине дерева, кроме служебной информации, будем поддерживать число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emaxValue\u003c/i\u003e\u003c/span\u003e, равное максимальному значению из чисел \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e в этом дереве.\u003cbr /\u003e\u003cbr /\u003eБинарным поиском переберем возможную позицию нового человека, пусть он имеет номер \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e\u003c/span\u003e от \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (для удобства нумерацию введем с конца очереди). Человек достигнет этой позиции тогда и только тогда, когда среди чисел \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003epos\u003c/i\u003e\u003c/span\u003e не существует ни одного, большего числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Это можно проверить, отщепив от декартова дерева поддерево размера \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e\u003c/span\u003e, и проверив у него число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emaxValue\u003c/i\u003e\u003c/span\u003e. Таким образом мы найдем значение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e\u003c/span\u003e, и в эту позицию вставим нового человека. Построив полную очередь, нужно вывести ответ. Но это очень простая операция, не будем ее обсуждать. Асимптотика такого решения \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/56/2d/562d29f0dd61c7582488862e0aa67b1bf11a851f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Замечу, что это решения является неоптимальным, и вполне возможно, что оно не всегда пройдет по времени, поэтому модифицируем его:\u003cbr /\u003e\u003cbr /\u003eизбавимся от бинарного поиска. Для этого можно сразу отщепить от дерева поддерево размера \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e с начала дерева, и найти в нем такую максимальную позицию \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e\u003c/span\u003e, что все числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003epos\u003c/i\u003e\u003c/span\u003e) меньше \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Это делается с помощью одного обхода вниз по дереву, где на каждой вершине мы смотрим, надо ли закончить спуск, или надо выбрать одного из сыновей и продолжить. В процессе такого пути накапливаем количество вершин, оставляемых слева от текущей. Потом вставляем нового человека в найденную позицию, и восстанавливаем дерево обратно. Подумайте сами, как это реализовать, это не очень сложно. Асимптотика нового решения уже составляет \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/23/f1/23f1dcee7a38c3eea3b31d5e9803c84b2b3d5b97.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003cbr /\u003e\u003cbr /\u003e\u003ch2\u003e2. Использование метода \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/5c/4e5c9f371024ad4e1f5b0f2dfeb967ffe7cb5f4e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e-декомпозиции.\u003c/h2\u003eПусть \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/22/79/22795e5046ed3d5848e1042db699cd984de8f27c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Тогда мы заведем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e двусвязных списков, которые и будут представлять очередь, только разбитую на части. Так же, как и в предыдущем решении, будем добавлять по одному человеку в очередь в порядке их прихода.\u003cbr /\u003e\u003cbr /\u003eБудем хранить для каждого списка также число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emaxValue\u003c/i\u003e\u003c/span\u003e, равное максимальному значению из чисел \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e в этом списке. Тогда добавление происходит так: будем искать подходящее место для нового человека, для этого пропустим все списки, суммарной длиной, меньшей \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, причем во всех этих списках числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emaxValue\u003c/i\u003e\u003c/span\u003e должны быть меньше, чем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Если мы возьмем первый такой список, где это условие не выполняется, или \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e стало меньше, чем длина пропущенных список плюс длина текущего, то мы по такому списку пробежимся \u0026quot;в лоб\u0026quot;, то есть по каждому элементу от начала до конца, проверим выполнение условий, и добавим нового человека на найденное место.\u003cbr /\u003e\u003cbr /\u003eДавайте оценим, сколько времени требует текущее решение. В худшем случае, оно будем всех людей добавлять в один и тот же список, и при добавлении нового \u0026quot;в лоб\u0026quot; пробегаться от его начала до конца, таким образом в неудачном случае, время работы составит \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e, что нам не очень годится.\u003cbr /\u003e\u003cbr /\u003eТогда применим следующую хитрость: в момент, когда какой-либо список станет больше, чем \u003cspan class\u003d\"tex-span\"\u003e2 * \u003ci\u003es\u003c/i\u003e\u003c/span\u003e элементов, то сделаем перераспределение людей в очереди. Из списков, которые содержат более \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e элементов, будем проталкивать их в следующую очередь. Таким образом мы нормируем списки, и они станут достаточно короткие - всего не более \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e элементов в каждом.\u003cbr /\u003e\u003cbr /\u003eОценим время работы в новом случае. Теперь добавление нового человека требует \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e времени. Нормализация требует \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e времени, но выполняется она не чаще, чем раз в \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/5c/4e5c9f371024ad4e1f5b0f2dfeb967ffe7cb5f4e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e операций добавления, что в сумме даст \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3b/0b/3b0bdf23003450b9c6db3c961c80e4c6bdd8ce7d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e операций.\u003cbr /\u003e\u003cbr /\u003eЗначит, наше решение работает за \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3b/0b/3b0bdf23003450b9c6db3c961c80e4c6bdd8ce7d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/div\u003e","tags":["round","wcs","разбор"]}}