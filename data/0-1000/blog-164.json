{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1268408261,"rating":1,"authorHandle":"Jokser","modificationTimeSeconds":1268408261,"id":164,"title":"Разбор задач Codeforces Beta Round #4","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eЗадача A\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗдесь все просто. Если число нечетное или равно 2, то ответ \u0026quot;NO\u0026quot;, иначе ответ \u0026quot;YES\u0026quot;.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача B\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВ этой задаче есть более простые пути решения, но я решил написать ДП. Обозначим массивом bool dp[d][sumTime] возможность того, что в день d можно набрать ровно sumTime времени. Если true - то можно, если false - то нельзя. Изначально dp[0][0]\u003dtrue, остальные - false.\u003c/p\u003e\u003cp\u003eПолучаем следующее реккурентное соотношение dp[i][j]\u003ddp[i-1][j-k], где i - текущий день, j - текущее суммарное время и k - время, которое Петя хочет потратить в i день. \u003c/p\u003e\u003cp\u003eПопутно запоминаем расписание формулой from[i][j]\u003dk. Далее, восстановить расписание не составляет труда.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача C\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗдесь можно использовать map\u0026lt;string,int\u0026gt; в С++. Считываем имя, смотрим какое число соответствует данному имени. Если 0 - выводим OK, и прибавляем единичку в map. Иначе выводим имя+текущее число в mapе и снова прибавляем единичку в map.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача D\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eСначала отсортируем все конверты, включая открытку по возрастанию по ширине. Далее применяем алгоритм, как если бы мы искали самую длинную возрастающуюю подпоследовательность. Обозначаем dp[i] - длину наибольшой цепочки конвертов, оканчивающейся на конверт с номером i. Тогда получаем следующее реккурентное соотношение. \u003c/p\u003e\u003cp\u003edp[i]\u003dmax(dp[i],d[j]+1), где j\u003d0..i-1 и a[i].длина\u0026gt;a[j].длина и a[i].ширина\u0026gt;a[j].ширина. \u003c/p\u003e\u003cp\u003eНачальное условие dp[номер открытки]\u003d0. Все остальным можно сделать -1.\u003c/p\u003e\u003cp\u003eЗапоминаем максимальное число открыток, а также порядок их следования.\u003c/p\u003e\u003cp\u003eДалее отсортируем все конверты, включая открытку по возрастанию, но теперь уже по длине! И проделываем все те же действия, что написаны выше. Cравниваем результаты и выводим наибольший.\u003c/p\u003e\u003c/div\u003e","tags":["codeforces beta round #4","задача","разбор"]}}