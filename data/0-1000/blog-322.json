{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1271569624,"rating":-15,"authorHandle":"removed1","modificationTimeSeconds":1271937406,"id":322,"title":"Умножаем матрицы (не читайте, если вы любитель Java)","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eПравильный тест должен гарантировать, что обрабатываются одни и те же данные, поэтому я убрал библиотечные генераторы случайных чисел и заменил их явной генерацией. Правильный тест должен проверять корректность результата, поэтому результат умножения теперь используется.\u003c/p\u003e\u003cp\u003eКаждый код прогонялся три раза в topcoder practice room 461 easy. Результаты и код можно посмотреть здесь: http://advgreat.narod.ru/matrices.rar\u003c/p\u003e\u003cp\u003eЕсли кто-то думает, что я что-то делаю не так -- код в студию.\u003c/p\u003e\u003cp\u003eМои извинения любителям Java. В прошлый раз я забыл указать ключевое слово final, теперь добавил. \u003c/p\u003e\u003cp\u003eДля C# я попробовал замерить вариант, когда значение size не задается литералом, а берется из входных данных -- в таком случае у компилятора не будет шансов догадаться, что будет это такое при работе программы. Правда, влияние на скорость это оказывает только для С/С++.\u003c/p\u003e\u003cp\u003eДля C# и Java вывод такой:\u003c/p\u003e\u003cp\u003eесли нужен двухмерный массив или его аналог, то индексация в \u003c/p\u003e\u003cp\u003eint[,] будет работать медленнее всего\u003c/p\u003e\u003cp\u003eint[][] будет работать немного быстрее\u003c/p\u003e\u003cp\u003eint[] с индексацией вида arr[y*cols + x] будет работать еще быстрее\u003c/p\u003e\u003cp\u003eДля C++, как и ожидалось, индексация в массиве массивов (int **) оказалась медленее, чем в двухмерном массиве (int [][]), никакого преимущества переход с адресации int[][] на развернутое int[] не дает.\u003c/p\u003e\u003cp\u003eТакже хочу рассказать тем, кто не знает, что GCC поддерживает VLA. То есть там работает такой код:\u003c/p\u003e\u003cp\u003eint foo(int n) { int arr[n][n]; // все, массив готов и в него можно писать\u003c/p\u003e\u003cp\u003ep.s. Почему я писал этот пост\u003c/p\u003e\u003cp\u003eменя удивила фраза Федора в \u003ca href\u003d\"//codeforces.com/blog/entry/254#comment-3033\"\u003ehttp://codeforces.com/blog/entry/254#comment-3033\u003c/a\u003e про двухмерные массивы в C#\u003c/p\u003e\u003cp\u003eв результате прогона его кода выяснилось, что он прав, а я ошибался\u003c/p\u003e\u003cp\u003eя заинтересовался другими способами использования массива, а потом немного решил погонять и другие языки, заодно проверив фразу Петра о том, что Java медленнее C#\u003c/p\u003e\u003cp\u003eтеперь решил сделать измерение корректным и выложить исходники \u003c/p\u003e\u003cp\u003ep.p.s.любители Java ухитрилось заминусовать даже мой коммент со ссылкой на бенчмарк, где Java быстрее C/C++. Очевидно, что Java коррелирует с биполярностью мышления и скудостью ума. Для вас еще есть замечательный пост о гибкой Java: http://codeforces.com/blog/entry/312\u003c/p\u003e\u003c/div\u003e","tags":["benchmark","nonflawed","tags"]}}