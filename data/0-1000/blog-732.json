{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1286480366,"rating":12,"authorHandle":"---Grigor---","modificationTimeSeconds":1286480558,"id":732,"title":"Codeforces Beta Round #33. Problem C Analysis.","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cspan style\u003d\"border-collapse: collapse;font-family: verdana , arial , sans-serif;font-size: 14.0px;\"\u003eThis problem can be solved in linear time, using the following idea:\u003c/span\u003e\u003cspan style\u003d\"border-collapse: collapse;font-family: verdana , arial , sans-serif;font-size: 14.0px;\"\u003e\u003cbr /\u003e\u003c/span\u003e\u003cspan style\u003d\"border-collapse: collapse;font-family: verdana , arial , sans-serif;font-size: 14.0px;\"\u003e1. \u003cspan style\u003d\"border-collapse: separate;font-family: arial , sans-serif;font-size: 16.0px;\"\u003e\u003cspan title\u003d\"\"\u003eIf desired prefix and suffix intersect, then their common part is remaining with the initial sign and\u003cbr /\u003e\u003c/span\u003e\u003cspan title\u003d\"\"\u003etherefore, this case is equivalent to the case when we take the same suffix and prefix, but without their common part\u003c/span\u003e\u003c/span\u003e:\u003c/span\u003e\u003cspan style\u003d\"border-collapse: collapse;font-family: verdana , arial , sans-serif;font-size: 14.0px;\"\u003e\u003cbr /\u003e\u003c/span\u003e\u003cspan style\u003d\"border-collapse: collapse;font-family: verdana , arial , sans-serif;font-size: 14.0px;\"\u003e(s1 [s2 )s3 ] is equal to (s1)s2[s3] (s1,s2,s3 - some subsequences).\u003c/span\u003e\u003cspan style\u003d\"border-collapse: collapse;font-family: verdana , arial , sans-serif;font-size: 14.0px;\"\u003e\u003cbr /\u003e\u003c/span\u003e\u003cspan style\u003d\"border-collapse: collapse;font-family: verdana , arial , sans-serif;font-size: 14.0px;\"\u003e2. Let the sum of elements A1 .. An be equal to S. Then when inverting signs we get -A1, -A2 .. -An, and the sum is thereafter changed to -S, i.e. sum of elements on the segment will just change its\u0027 sign when inverting the whole segment\u0027s signs.\u003c/span\u003e\u003cspan style\u003d\"border-collapse: collapse;font-family: verdana , arial , sans-serif;font-size: 14.0px;\"\u003e\u003cbr /\u003e\u003c/span\u003e\u003cspan style\u003d\"border-collapse: collapse;font-family: verdana , arial , sans-serif;font-size: 14.0px;\"\u003e3. One can consider the initial problem as follows: we have to choose a consecutive subsequence (the part of the initial sequence, remaining between suffix and prefix), and invert all the numbers remaining out of it. Considering the sum of the whole sequence be S, and the sum of the target subsequence as S1 , the total sum will be equal to -(S-S1) + S1 \u003d 2*S1 - S  -  this is the value, we want to get. S is a constant, therefore to maximize this value, we just have to maximize S1, i.e. find a consecutive subsequence of the initial sequence that has the biggest sum, and this can be done in linear as follows:\u003c/span\u003e\u003cspan style\u003d\"border-collapse: collapse;font-family: verdana , arial , sans-serif;font-size: 14.0px;\"\u003e\u003cbr /\u003e\u003c/span\u003e\u003cspan style\u003d\"border-collapse: collapse;font-family: verdana , arial , sans-serif;font-size: 14.0px;\"\u003emx \u003d 0;\u003c/span\u003e\u003cspan style\u003d\"border-collapse: collapse;font-family: verdana , arial , sans-serif;font-size: 14.0px;\"\u003e\u003cbr /\u003e\u003c/span\u003e\u003cdiv style\u003d\"margin-top: 0.0px;margin-right: 0.0px;margin-bottom: 0.0px;margin-left: 0.0px;padding-top: 0.0px;padding-right: 0.0px;padding-bottom: 0.0px;padding-left: 0.0px;border-collapse: collapse;font-family: verdana , arial , sans-serif;font-size: 14.0px;\"\u003efor(i\u003d0;i\u0026lt;n;++i)\u003c/div\u003e\u003cdiv style\u003d\"margin-top: 0.0px;margin-right: 0.0px;margin-bottom: 0.0px;margin-left: 0.0px;padding-top: 0.0px;padding-right: 0.0px;padding-bottom: 0.0px;padding-left: 0.0px;border-collapse: collapse;font-family: verdana , arial , sans-serif;font-size: 14.0px;\"\u003e\u003cspan style\u003d\"white-space: pre;\"\u003e \u003c/span\u003e{\u003c/div\u003e\u003cdiv style\u003d\"margin-top: 0.0px;margin-right: 0.0px;margin-bottom: 0.0px;margin-left: 0.0px;padding-top: 0.0px;padding-right: 0.0px;padding-bottom: 0.0px;padding-left: 0.0px;border-collapse: collapse;font-family: verdana , arial , sans-serif;font-size: 14.0px;\"\u003e\u003cspan style\u003d\"white-space: pre;\"\u003e  \u003c/span\u003esum +\u003d a[i];\u003c/div\u003e\u003cdiv style\u003d\"margin-top: 0.0px;margin-right: 0.0px;margin-bottom: 0.0px;margin-left: 0.0px;padding-top: 0.0px;padding-right: 0.0px;padding-bottom: 0.0px;padding-left: 0.0px;border-collapse: collapse;font-family: verdana , arial , sans-serif;font-size: 14.0px;\"\u003e\u003cspan style\u003d\"white-space: pre;\"\u003e  \u003c/span\u003eif(sum \u0026lt; 0)\u003c/div\u003e\u003cdiv style\u003d\"margin-top: 0.0px;margin-right: 0.0px;margin-bottom: 0.0px;margin-left: 0.0px;padding-top: 0.0px;padding-right: 0.0px;padding-bottom: 0.0px;padding-left: 0.0px;border-collapse: collapse;font-family: verdana , arial , sans-serif;font-size: 14.0px;\"\u003e\u003cspan style\u003d\"white-space: pre;\"\u003e   \u003c/span\u003esum \u003d 0;\u003c/div\u003e\u003cdiv style\u003d\"margin-top: 0.0px;margin-right: 0.0px;margin-bottom: 0.0px;margin-left: 0.0px;padding-top: 0.0px;padding-right: 0.0px;padding-bottom: 0.0px;padding-left: 0.0px;border-collapse: collapse;font-family: verdana , arial , sans-serif;font-size: 14.0px;\"\u003e\u003cspan style\u003d\"white-space: pre;\"\u003e  \u003c/span\u003emx \u003d max(mx, sum);\u003c/div\u003e\u003cdiv style\u003d\"margin-top: 0.0px;margin-right: 0.0px;margin-bottom: 0.0px;margin-left: 0.0px;padding-top: 0.0px;padding-right: 0.0px;padding-bottom: 0.0px;padding-left: 0.0px;border-collapse: collapse;font-family: verdana , arial , sans-serif;font-size: 14.0px;\"\u003e\u003cspan style\u003d\"white-space: pre;\"\u003e \u003c/span\u003e}\u003c/div\u003e\u003c/div\u003e","tags":["analysis","problem c","round #33"]}}