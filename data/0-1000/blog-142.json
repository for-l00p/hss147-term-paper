{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1267979449,"rating":2,"authorHandle":"Alex_KPR","modificationTimeSeconds":1267986230,"id":142,"title":"CF beta 3: разбор и эмоции","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp align\u003d\"justify\"\u003e\u003cimg src\u003d\"/predownloaded/0f/22/0f221c0b4c2a10d2bd8afcac9996301c6f730e08.jpg\" style\u003d\"float: right;margin: 1.0em;max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp align\u003d\"justify\"\u003eЗадача D. Скобочная последовательность\u003c/p\u003e\u003cp align\u003d\"justify\"\u003eНесомненно, это самая интересная задача контеста. Не пойму, как можно сдать её за 16 минут, как Petr, даже зная решение. Не пойму, как можно сдать её раньше, чем задачу B, как Nerevar (см. достижения справа).\u003c/p\u003e\u003cp align\u003d\"justify\"\u003eДля её решения рассуждать нужно было, например, следующим образом: давайте вместо знаков вопроса сразу поставим дешевейшую из двух скобок. Если цена открывающей равна A, а закрывающей B, то цена изменения её на противоположную будет |A-B|. Цена изменения бывших \u0026quot;не знаков вопроса\u0026quot; пусть будет равна бесконечности (например, 10\u003csup\u003e15\u003c/sup\u003e). Получили какую-то фигню из открывающих и закрывающих скобок.\u003c/p\u003e\u003cp align\u003d\"justify\"\u003eЯ и дальше буду использовать термин \u0026quot;фигня\u0026quot;, потому что такую же терминологию использовал при рассуждениях во время контеста. В нашей фигне есть X открывающих скобок и Y закрывающих. В правильной скобочной последовательности X\u003dY. Предположим, что у нас X\u0026gt;Y, тогда возьмём (X-Y)/2 наиболее дешёвых по цене изменения открывающих скобок и заменим их на закрывающие. При Y\u0026gt;X действия аналогичные. \u003c/p\u003e\u003cp align\u003d\"justify\"\u003e \u003c/p\u003e\u003cp align\u003d\"justify\"\u003eИтак, теперь в нашей фигне X\u003dY, а это уже почти правильная скобочная последовательность! \u003d) Как проверяется скобочная последовательность на правильность, если в ней X\u003dY? Конечно, подсчётом баланса: проходим по строке, если символ \u0026quot;(\u0026quot; то увеличим баланс на 1, иначе уменьшим на 1. В том месте, где баланс стал равен -1 (это позиция i), получилась нестыковка. Как её обойти? Оказывается, достаточно просто: найдём самую дешёвую (для замены) открывающую скобку в подстроке [0..i] и самую дешёвую закрывающую скобку в подстроке [i+1..n-1]. Поменяем их на противоположные и этим самым увеличим баланс на 2. И так будем делать каждый раз. Теперь у нас баланс везде неотрицательный... Всё? Ещё нет.\u003c/p\u003e\u003cp align\u003d\"justify\"\u003eВ правильной скобочной последовательности баланс в самом конце равен 0, а у нас может быть какое-нибудь чётное число. Бороться будем так: отразим нашу последовательность зеркально (если было \u0026quot;((()((\u0026quot;, то будет \u0026quot;))()))\u0026quot;) и повторим ту же процедуру восстановления баланса, что и раньше. Теперь баланс равен 0, X\u003dY. Значит, получили правильную скобочную последовательность. А так как мы использовали каждый раз самую дешёвую замену, то ответ будет минимальным. Осталось не забыть отразить зеркально обратно перед выводом. \u003d)\u003c/p\u003e\u003cp align\u003d\"justify\"\u003eИ ещё: если где-то самая дешёвая замена равна бесконечности (10\u003csup\u003e15\u003c/sup\u003e), то ответа не существует. Для того, чтобы быстро находить самую дешёвую открывающую или закрывающую скобку, можно воспользоваться std::set.\u003c/p\u003e\u003cp align\u003d\"justify\"\u003e\u003cbr /\u003e\u003cbr /\u003eЗадача A. Кратчайший путь короля\u003c/p\u003e\u003cp align\u003d\"justify\"\u003eБудем рассуждать просто. Пусть стартовая точка (X0, Y0), финальная точка (X, Y). Очевидно, что если для попадания в финальную точку нужно двигаться по вертикали и горизонтали, то мы вместо двух ходов сделаем один - по диагонали. Утверждение 1: ответ, который нужно вывести - это максимум из |X0-X| и |Y0-Y|. Почему? Очень просто: каждым ходом короля мы можем уменьшать разницу между текущей точкой и финальной как по вертикали, так и по горизонтали одновременно, путешествуя по диагонали. Если, например, |X0-X|\u0026gt;|Y0-Y|, то мы сделаем |Y0-Y| ходов по диагонали, а потом придётся ещё идти горизонтально. А теперь посмотрим внимательно на формат вывода: движение по диагонали выводится как движение по горизонали + движение по вертикали. Значит, основной цикл может выглядеть примерно так:\u003c/p\u003e\u003cfont face\u003d\"Courier New, Courier, mono\"\u003e\u003cp align\u003d\"justify\"\u003ewhile(true)\u003c/p\u003e\u003cp align\u003d\"justify\"\u003e{\u003c/p\u003e\u003cp align\u003d\"justify\"\u003e  if (x\u003d\u003dx0 \u0026amp;\u0026amp; y\u003d\u003dy0) break; // мы нашли ответ\u003c/p\u003e\u003cp align\u003d\"justify\"\u003e  if (x\u0026gt;x0) {x0++; cout\u0026lt;\u0026lt;\u0026quot;R\u0026quot;;} else // если финальная точка находится справа от текущей, то пойдём вправо\u003c/p\u003e\u003cp align\u003d\"justify\"\u003e  if (x\u0026lt;x0) {x0--; cout\u0026lt;\u0026lt;\u0026quot;L\u0026quot;;} // иначе пойдём влево\u003c/p\u003e\u003cp align\u003d\"justify\"\u003e  if (y\u0026gt;y0) {y0++; cout\u0026lt;\u0026lt;\u0026quot;D\u0026quot;;} else // рассуждения аналогичны\u003c/p\u003e\u003cp align\u003d\"justify\"\u003e  if (y\u0026lt;y0) {y0--; cout\u0026lt;\u0026lt;\u0026quot;U\u0026quot;;}\u003c/p\u003e\u003cp align\u003d\"justify\"\u003e  cout\u0026lt;\u0026lt;endl;\u003c/p\u003e\u003cp align\u003d\"justify\"\u003e}\u003c/p\u003e\u003c/font\u003e\u003cp align\u003d\"justify\"\u003e\u003cbr /\u003e\u003cbr /\u003eЗадача B. Грузовик\u003c/p\u003e\u003cp align\u003d\"justify\"\u003eИнтересная задача. Рассуждать можно по-разному, но ключ - жадное решение. Отсортируем по невозрастанию полезности все байдарки. Возмём каждую пару байдарок и сольём её в катамаран. \u003d) Если осталась какая-то байдарка без пары - ничего страшного. Теперь отсортируем все обычные катамараны, катамараны-мутанты и оставшуюся байдарку опять по невозрастанию полезности, но теперь всех вместе и будем забивать полученными плавсредствами грузовик. Осталось рассмотреть 2 случая. Первый: свободного места уже нет, но катамараны ещё есть. Давайте посмотрим, что же мы положили в конце? Если это две байдарки (тут уже неважно, были ли они с кем-то спарены или нет), то попробуем их вытащить и засунуть самый полезный катамаран. Второй случай: есть место под байдарку, но байдарок больше нет, а есть катамараны. Поступим также: вытащим последнюю байдарку (если она была) и попытаемся разместить катамаран. При рассмотрении каждого из двух случаев необходимо, разумеется, брать максимум из одного и другого результата. Тест на 2-ой случай: 3 3 2 10 1 13 1 7.\u003cbr /\u003e\u003c/p\u003e\u003cp align\u003d\"justify\"\u003e\u003cbr /\u003e\u003cbr /\u003eЗадача C. Крестики-нолики\u003c/p\u003e\u003cp align\u003d\"justify\"\u003eДавайте узнаем, как определить, какой игрок только что ходил. Если количество крестиков на 1 больше количества ноликов, то ходил первый, а если их количества равны - то второй. Если нельзя определить, какой игрок ходил, то это illegal-ситуация. Посмотрим на игровое поле. Если оба игрока находятся в состоянии победы, то ответ illegal. Если получилось так, что только что ходил первый игрок, а победил второй, то это значит, что первый игрок сделал ход уже после победы второго игрока, следовательно, ответ illegal. Если ситуация разворачивается с точностью до наоборот, то ответ аналогичный. Если ситуация такова, что игрок, который ходил - победил, то он вполне мог победить своим последним ходом, значит, ответ \u0026quot;the ... player won\u0026quot;. Если количество крестиков \u003d 5, а ноликов \u003d 4 и никто не победил - то ответ draw, потому что поставить больше некуда. :) Если ничего из вышеперечисленного не случилось и ходил первый игрок, то будет ходить второй, иначе первый. Не решение, а набор условий. \u003d)\u003c/p\u003e\u003c/div\u003e","tags":["codeforces","codeforces beta round #3","contest","задача","интересно","разбор","фигня"]}}