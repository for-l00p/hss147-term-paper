{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1286480541,"rating":10,"authorHandle":"Edvard","modificationTimeSeconds":1286483214,"id":733,"title":"Codeforces Beta Round #33. Разбор D","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv\u003e\u003ch2 style\u003d\"text-align: center;\"\u003eAnalysis for problem \u0026quot;D. Knights\u0026quot;.\u003cbr /\u003e\u003c/h2\u003e\u003cdiv\u003eDenote the number of fences surrounding the control point number i through cnt\u003csub\u003ei\u003c/sub\u003e. Also denote cnt\u003csub\u003eij\u003c/sub\u003e - the number of fences surrounding point i and point j. Then the answer to the query (i, j) is cnt\u003csub\u003ei\u003c/sub\u003e + cnt\u003csub\u003ej\u003c/sub\u003e - cnt\u003csub\u003eij\u003c/sub\u003e. Clearly, that we can calculate all the values cnt\u003csub\u003ei\u003c/sub\u003e with time O(n * m). The problem is the fast computation of the values cnt\u003csub\u003eij\u003c/sub\u003e. And then suggests two solutions: a simple and not very much. Simple is as follows: create for every point i a bitset, j-th is equal to 1 if the j-th fence surrounds the point number i. Then, obviously cnt\u003csub\u003eij\u003c/sub\u003e \u003d count(z\u003csub\u003ei\u003c/sub\u003e \u0026amp; z\u003csub\u003ej\u003c/sub\u003e), where count(a) - the number of ones in bitset a. Now another solution. Add another fence with a center at (0, 0) and infinite radius. We construct a graph whose vertices are the fences as follows: we draw an arc from i to j, if the i-th fence is a fence with the minimum radius surrounding the fence number j. Obviously we get a directed tree rooted at the fence of infinite radius. Also, for each control point will find idx\u003csub\u003ei\u003c/sub\u003e - number of the fence with minimum radius  surrounding the i-th control point. Then cnt\u003csub\u003eij\u003c/sub\u003e \u003d dist\u003csub\u003eij\u003c/sub\u003e + dist\u003csub\u003eji\u003c/sub\u003e, where dist\u003csub\u003eij\u003c/sub\u003e - distance from vertex i to the lowest common ancestor of verticex i ans j. With the implementation problems should not arise, because in the first solution could write bitset himself or use the standard bitset from STL (for those who write in C++), while in the second solution we could preprocess all the lca with time O(n\u003csup\u003e2\u003c/sup\u003e).\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["analysis","beta round 33","codeforces","codeforces format","faq","problem d"]}}