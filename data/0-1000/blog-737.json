{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1286554901,"rating":5,"authorHandle":"ir5","modificationTimeSeconds":1286557743,"id":737,"title":"Codeforces Beta Round #33 (personal participation commentaries)","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003eI would like to write participation commentaries of Beta Round #33. I\u0027m sorry my English may be poor.\u003cbr /\u003e\u003cbr /\u003e\u003ch3\u003eA What is for dinner?\u003c/h3\u003eThe problem is quite easy, but the problem statement is a little hard so I got as many as 2WAs. This made me upset a little.\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003e\u003ch3\u003eB String Problem\u003c/h3\u003eThis problem is also easy if we know warshll-floyd algorithm. But I confused the specification. I translated the statement \u0026quot;\u003ci\u003eAccording to the game rules, with each move Valera can change one arbitrary character A\u003csub\u003ei\u003c/sub\u003e in one of the strings into arbitrary character B\u003csub\u003ei\u003c/sub\u003e...\u003c/i\u003e\u0026quot; as \u0026quot;\u003cb\u003eeach string can be moved at most one time\u003c/b\u003e\u0026quot; by mistake, and I spend much time in wrong and heavy coding, then I got 1WA.\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003e\u003ch3\u003eC Wonderful Randomized Sum\u003c/h3\u003eSimple DP Problem. Let dp[n]:\u003d(maximum sum using only \u0026quot;prefix multiplication\u0026quot; operation if an input sequence is a[1],a[2],...,a[n]). Each dp[n] can be calculated by as follow.\u003cbr /\u003e\u003cbr /\u003e\u003cblockquote\u003e    dp[0]\u003d0;\u003cbr /\u003e    ll mm\u003d-1LL\u0026lt;\u0026lt;50;\u003cbr /\u003e    FOREQ(j,1,N) {\u003cbr /\u003e        mm\u003dmax(mm,-2*sum[j]);  //sum[j] is a sum of a[1],...,a[j]\u003cbr /\u003e        dp[j]\u003dsum[j]+mm;\u003cbr /\u003e    }\u003cbr /\u003e\u003c/blockquote\u003e\u003cbr /\u003eAnd let dp2[n]:\u003d(maximum sum using only \u0026quot;suffix multiplication\u0026quot; operation if an input is a[n],a[n+1],...,a[N]). This is also calculated as same as dp[n].\u003cbr /\u003eThen the final answer is max_{n} (dp[n]+dp2[n]).\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003e\u003ch3\u003eD Knights\u003c/h3\u003eInteresting problem about geometry and graph. Query number k is large, so a program must calculate each query as fast as possible. Or, it is also good to calculate all possible M^2 queries in advance.\u003cbr /\u003eA way I tried was the latter tactics. First of all, I constructed a graph with M vertices. In the graph, there would exist an edge between node i and node j, if a fence i contains a fence j strictly. \u0026quot;a fence i contains a fence j strictly\u0026quot; means that there is no fence between the fence i and the fence j.\u003cbr /\u003eConstrucing such a graph in O(M^2) is not so plain, but it can be done as follow: 1. sort all fences by their radius 2. see each fence from smaller one, then check if the fence contains the other fence strictly. Because it can be said that every fence will be contained by at most one the other fence, we need to check only fences that is not contained by any fence.\u003cbr /\u003eIt would help implementation to add an \u0026quot;outer envelope\u0026quot; fence as a sentinel value like R\u003d1e14, P\u003d(0,0) , because: 1. adding it will not change any result 2. by adding it any control point will be contained in exactly one fence strictly.\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003eAfter constructing the graph, we will calculate distance[i][j] for each pair (i,j). This can be done by some depth-first-search approach, starting from top node(outer envelope).\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003eImplementation of above algorithm was laboring and I took much time. I finally got AC with 1 resubmission.\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003eAfter contest I read some solution of other people, and following method looked quite good.\u003cbr /\u003eFor each query, we can also calculate the answer by counting the number of fences that enclose only i or j. (i,j is an index of a control point)\u003cbr /\u003eIf we use this method, the time complexity will be O(10^5*10^3)\u003dO(10^9) and we would got TLE.\u003cbr /\u003eBut if we calculate this not by bool[] one by one, but each bit of unsigned long long, it will be O(10^9/64) ~ O(1,562,500), then the method will be good for the time limit. I think this method is comprehensible and clever.\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003e\u003ch3\u003eE Helper\u003c/h3\u003eI didn\u0027t read the statement yet.\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003e\u003ch3\u003eResult\u003c/h3\u003eoooox +3442pts 62nd place\u003c/div\u003e","tags":["beta round 33","codeforces format"]}}