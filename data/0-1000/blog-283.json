{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1271005004,"rating":7,"authorHandle":"slycelote","modificationTimeSeconds":1271186255,"id":283,"title":"Codeforces Beta Round #9 tutorial","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eA. \u003ca href\u003d\"../../../contest/9/problem/A\"\u003eDie Roll        \u003c/a\u003e\u003c/h3\u003eIf the maximum of Yakko\u0027s and Wakko\u0027s points is a, then Dot will win, if she has not less than a points. So the probability of her win is (6 - (a-1)) / 6. Since there are only 6 values for a, you can simply hardcode the answers.\u003cbr /\u003e \u003cbr /\u003e\u003ch3\u003eB. \u003ca href\u003d\"../../../contest/9/problem/B\"\u003eRunning Student        \u003c/a\u003e\u003c/h3\u003eIt is simple to calculate the time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e that the Student will need, if he gets off the bus at the i-th stop: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e / \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is the time he will drive on the bus, and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b1/1b/b11b3ee2b0ba3b6e1aea8ed33bce796f9ada7d9a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is the time he will need to get from the i-th stop to the University. We need to choose indices with minimal possible \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, and among them - the index with minimal possible \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, that is, with maximal \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, that is (since the coordinates of bus stops are already ordered) with maximal i.\u003cbr /\u003e\u003cbr /\u003eNote that due to precision issues, you should be careful when you compare \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e: the condition \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e \u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e should be written in the form \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e| \u0026lt; ε\u003c/span\u003e for some small \u003cspan class\u003d\"tex-span\"\u003eε\u003c/span\u003e.\u003cbr /\u003e\u003cbr /\u003e\u003ch3\u003eC. \u003ca href\u003d\"../../../contest/9/problem/C\"\u003eHexadecimal\u0027s Numbers        \u003c/a\u003e\u003c/h3\u003eBrute force solution, when you try each number from 1 to n, will not fit into the time limit.\u003cbr /\u003eNote, however, that all good numbers have at most 10 digits, and each of the digits is 0 or 1. That is, there are at most \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e10\u003c/sup\u003e\u003c/span\u003e binary strings to check. Each of these strings is a number from 1 to \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e10\u003c/sup\u003e - 1\u003c/span\u003e in binary representation. So the algorithm is the following: for each number from 1 to \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e10\u003c/sup\u003e - 1\u003c/span\u003e write its binary  representation, read it as if it was decimal representation and compare the result to n.\u003cbr /\u003e\u003cbr /\u003e\u003ch3\u003eD. \u003ca href\u003d\"../../../contest/9/problem/D\"\u003eHow many trees?        \u003c/a\u003e\u003c/h3\u003eDenote by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003enh\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e the number of binary search trees on n nodes with height equal to h. We will derive a recurrent formula for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003enh\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. For the base case note that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e00\u003c/sub\u003e \u003d 1\u003c/span\u003e (empty tree), and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e0\u003c/sub\u003e \u003d \u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 0\u003c/span\u003e if i\u0026gt;0.\u003cbr /\u003e\u003cbr /\u003eNow take any binary search tree on n nodes with height equal to h. Let m be the number written at its root, \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003em\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. The left subtree is a binary search tree on m-1 nodes, and the right subtree is a binary search tree on n-m nodes. The maximal of their heights must be equal to h-1. Consider 2 subcases:\u003cbr /\u003e1. The height of the left subtree is equal to h-1. There are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e - 1, \u003ci\u003eh\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e such trees. The right subtree can have any height from 0 to h-1, so there are \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/67/35/6735ab779d7d0cbcfdd69b94e0ca65b2b7951c40.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e such trees. Since we can choose left and right subtrees independently, we have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7a/ab/7aab010645363dec52a2ab2d17dfde4fd665f3b2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e variants in this case.\u003cbr /\u003e2. The height of the left subtree is less than h-1. There are \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bd/09/bd09a9363dae40847098d16053f71dced0ca89b9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e such trees, and the right subtree must have height exactly h-1, which gives us totally \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/30/83/3083cdd8f3d4bc3728f7dda6a45e5697bf246754.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e variants.\u003cbr /\u003eSo the recurrent formula is the following: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/01/f9/01f993d1faa4b3db8c74d60001c4b5b755f59710.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003cbr /\u003e\u003cbr /\u003eAll the values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003enh\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e can be calculated by dynamic programming. The answer, then, is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/49/7f/497f7ae8f74ccd85055e1a9a12a05f88f6860aef.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003e\u003ch3\u003eE. \u003ca href\u003d\"../../../contest/9/problem/E\"\u003eInteresting graph and Apples        \u003c/a\u003e\u003c/h3\u003eThe funny ring consists of n vertices and n edges. If there is another edge except for these n, then the vertices it connects belong to more than one cycle. So, an interesting graph is just a funny ring. \u003cbr /\u003eA graph is a funny ring if and only if the following conditions hold:\u003cbr /\u003eA1. The degree of each vertex equals 2.\u003cbr /\u003eA2. The graph is connected.\u003cbr /\u003e Now let\u0027s figure out when a graph is not yet a funny ring, but can be transformed into a funny ring by adding edges. There are obvious necessary conditions:\u003cbr /\u003eB1. m \u0026lt; n.\u003cbr /\u003eB2. There are no cycles.\u003cbr /\u003eB3. The degree of each vertex is not more than 2.\u003cbr /\u003e Let\u0027s add edges so that these conditions were preserved, and the sequence of edges was lexicographically minimal. So, we add an edge (i,j) such that:\u003cbr /\u003e1. The degrees of i and j are less than 2. (Otherwise we would break B3).\u003cbr /\u003e2. i and j belong to different connected components. (Otherwise we would break B2).\u003cbr /\u003e3. The pair (i,j) is lexicographically minimal.\u003cbr /\u003e Let\u0027s see what we have when we can\u0027t add edges anymore. Since there are no cycles, each connected component is a tree, and therefore has at least one vertex with degree less than 2. If there are two connected components, then they could be connected by an edge without breaking B1-B3. So the graph is connected, has no cycles, and the degree of each vertex is not more than 2. This means that the obtained graph is just a walk and we can connect its end points to obtain a funny ring.\u003cbr /\u003e \u003cbr /\u003e To summarize, the algorithm is the following:\u003cbr /\u003e 1. Check if A1-A2 hold. If yes, output \u0026quot;YES\u0026quot; and 0.\u003cbr /\u003e 2. Check if B1-B3 hold. If no, output \u0026quot;NO\u0026quot;.\u003cbr /\u003e 3. Output \u0026quot;YES\u0026quot; and n-m. \u003cbr /\u003e 4. Add edges as described. When the edge (i,j) is added, output \u0026quot;i j\u0026quot;.\u003cbr /\u003e 5. Find the only vertices i and j with degree less than 2 (they can be equal if n\u003d1). Output \u0026quot;i j\u0026quot;.\u003c/div\u003e","tags":["cf9","codeforces beta round #9","tutorial"]}}