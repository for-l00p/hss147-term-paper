{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1281564967,"rating":1,"authorHandle":"choice","modificationTimeSeconds":1281580258,"id":594,"title":"Codeforces Beta Round #25 Solution Analysis","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eProblem A - IQ Test\u003c/h3\u003eWe can store two values, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecount\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eodd\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecount\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eeven\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, as the number of odd or even elements in the series. We can also store \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elast\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eodd\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elast\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eeven\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e as the index of the last odd/even item encountered. If only one odd number appears --- output \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elast\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eodd\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e; otherwise only one even number appears, so output \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elast\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eeven\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003e\u003ch3\u003eProblem B - Telephone Numbers\u003cbr /\u003e\u003c/h3\u003eThere are many ways of separating the string into clusters of 2 or 3 characters. One easy way is to output 2 characters at a time, until you have only 2 or 3 characters remaining. Here is a possible C++ solution:\u003cbr /\u003e\u003cbr /\u003e\u0026lt;code\u0026gt;\u003cbr /\u003efor( i\u003d0; i\u0026lt;n; i++ )\u003cbr /\u003e{\u003cbr /\u003e    putchar(buf[i]);\u003cbr /\u003e    if( i%2 \u0026amp;\u0026amp; i\u0026lt;n-(n%2)-2 ) putchar(\u0027-\u0027);\u003cbr /\u003e}\u003cbr /\u003e\u0026lt;/code\u0026gt;\u003cbr /\u003e \u003cbr /\u003e\u003cbr /\u003e \u003ch3\u003eProblem C - Roads in Berland\u003cbr /\u003e \u003c/h3\u003e If you are familiar with the \u003ca href\u003d\"http://en.wikipedia.org/wiki/Floyd-Warshall_algorithm\"\u003eFloyd-Warshall algorithm\u003c/a\u003e, then this solution may be easier to see.\u003cbr /\u003e\u003cbr /\u003eInitially, we are given a matrix \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e is the distance of shortest path between city \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and city \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. Suppose we build a new road between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e with length shorter than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e[\u003ci\u003ea\u003c/i\u003e][\u003ci\u003eb\u003c/i\u003e]\u003c/span\u003e. How do we update the rest of the graph accordingly?\u003cbr /\u003e\u003cbr /\u003eDefine a new matrix \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u0027\u003c/span\u003e, whose entries \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u0027[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e are the minimum path distance between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e while taking into account the new road \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eab\u003c/i\u003e\u003c/span\u003e. There are three possibilities for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e:\u003cbr /\u003e\u003cul\u003e\u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u0027[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e remains unchanged by the new road. In this case \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u0027[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e] \u003d \u003ci\u003eD\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u0027[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e is shorter if we use the new road \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eab\u003c/i\u003e\u003c/span\u003e. This means that the new path \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e must include the road \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. If we connect the vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e together in a path, then our new distance will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ea\u003c/i\u003e] + \u003ci\u003elength\u003c/i\u003e(\u003ci\u003eab\u003c/i\u003e) + \u003ci\u003eD\u003c/i\u003e[\u003ci\u003eb\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e.\u003c/li\u003e\u003cli\u003eLastly, we may have to use the road \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eba\u003c/i\u003e\u003c/span\u003e. (Note that this may \u003ci\u003enot\u003c/i\u003e be the same as road \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eab\u003c/i\u003e\u003c/span\u003e.) In this case, we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u0027[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e] \u003d \u003ci\u003eD\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003eb\u003c/i\u003e] + \u003ci\u003elength\u003c/i\u003e(\u003ci\u003eab\u003c/i\u003e) + \u003ci\u003eD\u003c/i\u003e[\u003ci\u003ea\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e.\u003c/li\u003e\u003c/ul\u003eThus, for each new road that we build, we must update each path \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e within the graph. Then we must sum shortest distances between cities. Updating the matrix and summing the total distance are both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e, so about \u003cspan class\u003d\"tex-span\"\u003e300\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e operations. Lastly, there are at most \u003cspan class\u003d\"tex-span\"\u003e300\u003c/span\u003e roads, so in total there are about \u003cspan class\u003d\"tex-span\"\u003e300\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003c/span\u003e operations.\u003cbr /\u003e\u003cbr /\u003eOne thing to note is that the sum of all shortest distances between cities may be larger than an int; thus, we need to use a long when calculating the sum.\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003e \u003ch3\u003eProblem D - Roads not only in Berland\u003cbr /\u003e \u003c/h3\u003e Before we start this problem, it is helpful to know about the \u003ca href\u003d\"http://en.wikipedia.org/wiki/Disjoint-set_data_structure\"\u003eunion find\u003c/a\u003e data structure. The main idea is this: given some elements \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e, ..., \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e that are partitioned in some way, we want to be able to do the following:\u003cbr /\u003e\u003cul\u003e\u003cli\u003emerge any two sets together quickly\u003c/li\u003e\u003cli\u003efind the parent set of any \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003eThis is a general data structure that sometimes appears in programming competitions. There are a lot of ways to implement it; one good example is written by Bruce Merry (aka BMerry) \u003ca href\u003d\"http://www.google.com/url?sa\u003dt\u0026amp;source\u003dweb\u0026amp;cd\u003d7\u0026amp;ved\u003d0CC8QFjAG\u0026amp;url\u003dhttp%3A%2F%2Folympiad.cs.uct.ac.za%2Fpresentations%2Fcamp1_2006%2Funionfind-handout.pdf\u0026amp;ei\u003dUydjTKqaJIW8lQfZ0IjCDw\u0026amp;usg\u003dAFQjCNGNSiYFJv4MADuMR4EgCkLln5Blmg\"\u003ehere\u003c/a\u003e.\u003cbr /\u003e\u003cbr /\u003eBack to the problem: Every day we are allowed to build exactly 1 road, and close exactly 1 road. Thus, we can break the problem into two parts:\u003cbr /\u003e\u003cul\u003e\u003cli\u003eHow do we connect the parts of the graph that are disconnected?\u003c/li\u003e\u003cli\u003eHow do we remove roads in a way that does not disconnect parts of the graph?\u003c/li\u003e\u003c/ul\u003e Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebuild\u003c/i\u003e\u003c/span\u003e be the list all roads that need to be built, and let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eclose\u003c/i\u003e\u003c/span\u003e be the list of nodes that need to be closed. We can show that in fact, these lists are of the same size. This is because the connected graph with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e nodes is a tree if and only if it has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e edges. Thus, if we remove more roads than than we build, then the graph is disconnected. Also, if we build more roads than we remove, then we have some unnecessary roads (the graph is no longer a tree).\u003cbr /\u003e\u003cbr /\u003eNow consider the format of the input data:\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e\u003cbr /\u003e...\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e\u003cbr /\u003eWe can show that edge \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e is unnecessary if and only if the nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e have already been connected by edges \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e), (\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e), ..., (\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e)\u003c/span\u003e. In other words, if the vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e are in the same connected component \u003ci\u003ebefore\u003c/i\u003e we, add \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e then we do not need to add \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e. We can use union-find to help us solve this problem:\u003cbr /\u003e\u003cbr /\u003e\u0026lt;code\u0026gt;\u003cbr /\u003efor( i from 1 to n-1 )\u003cbr /\u003e{\u003cbr /\u003e    if( find(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e)\u003dfind(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e) ) close.add\u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e;\u003cbr /\u003e    else merge(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e);\u003cbr /\u003e}\u003cbr /\u003e\u0026lt;/code\u0026gt;\u003cbr /\u003e\u003cbr /\u003eIn other words, we treat each connected component as a set. Union find allows us to find the connected component for each node. If the two connected components are the same, then our new edge is unnecessary. If they are different, then we can merge them together (with union find). This allows us to find the edges that we can remove.\u003cbr /\u003e\u003cbr /\u003eIn order to find the edges that we need to add to the graph, we can also use union-find: whenever we find a component that is disconnected from component 1, then we just add an edge between them.\u003cbr /\u003e\u003cbr /\u003e\u0026lt;code\u0026gt;\u003cbr /\u003efor( i from 2 to n )\u003cbr /\u003e    if( find(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e)!\u003dfind(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e) )\u003cbr /\u003e    {\u003cbr /\u003e        then merge\u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e;\u003cbr /\u003e        build.add\u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e;\u003cbr /\u003e    }\u003cbr /\u003e\u0026lt;/code\u0026gt;\u003cbr /\u003e\u003cbr /\u003eWe just need to store the lists of roads that are unnecessary, and the roads that need to be built.\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003e \u003ch3\u003eProblem E - Test\u003cbr /\u003e \u003c/h3\u003e The way I solved this problem is with a \u003ca href\u003d\"http://en.wikipedia.org/wiki/Hash_code\"\u003ehash function\u003c/a\u003e. Hash functions can fail on certain cases, so in fact, my solution is not \u0027correct\u0027. However, it passed all the test cases \u003dP\u003cbr /\u003e\u003cbr /\u003eLet the input strings be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e. We can build the shortest solution by permuting the strings and then trying to \u0027attach\u0027 them to each other. I.e., we need to find the longest overlapping segments at the end of string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and the beginning of string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. The obvious brute force solution won\u0027t run in time. However, we can use a hash function to help us calculate the result in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003elen\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e), \u003ci\u003elen\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e))\u003c/span\u003e. The hash function that I used was the polynomial \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehash\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, ..., \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e) \u003d \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e + \u003ci\u003eax\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. This polynomial is a good hash function in this problem because it has the following useful property:\u003cbr /\u003eGiven \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehash\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, ..., \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e, we can calculate the following values in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time:\u003cbr /\u003e\u003cul\u003e\u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehash\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, ..., \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e) \u003d \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e × \u003ci\u003ehash\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, ..., \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehash\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, ..., \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/sub\u003e) \u003d \u003ci\u003ehash\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, ..., \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e) + \u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ej\u003c/i\u003e + 1 - \u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e × \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003eIn other words, if we know the hash for some subsequence, we can calculate the hash for the subsequence and the previous element, or the subsequence and the next element. Given two strings \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, we can calculate the hash functions starting from the end of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and starting from the beginning of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. If they are equal for length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, then that means that (maybe) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e overlap by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e characters.\u003cbr /\u003e\u003cbr /\u003eThus, we can try every permutation of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e, and try appending the strings to each other. There is one last case: if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is a substring of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e for some \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e ≠ \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, then we can just ignore \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. We can use hash functions to check that one string is contained within another one.\u003c/div\u003e","tags":["beta25","codeforces","solution"]}}