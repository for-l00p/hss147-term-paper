{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1283356963,"rating":6,"authorHandle":"MciprianM","modificationTimeSeconds":1283369899,"id":635,"title":"A median problem - solution","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cu\u003eA median problem - Solution\u003c/u\u003e\u003cbr /\u003e\u003cbr /\u003eFinally, I post the solution to the problem from the Microsoft interview, that I, long ago, promissed to do. Sorry for the delay. I have received on my email solutions from SCQ \u003d) and Vasya V. ( solution6 ), from Harta a solution similar to solution4 and solution7 due to Nyaz Nigmatullin. Thanks all. \u003cbr /\u003e\u003cu\u003e\u003cb\u003eNote: Read solution5 for the O ( lg n ) algorithm.\u003c/b\u003e\u003c/u\u003e\u003cbr /\u003e\u003cbr /\u003e\u003cu\u003eStatement\u003c/u\u003e\u003cbr /\u003e\u003cblockquote\u003eYou are given two sorted sequences of 32-bit integer numbers. Find the median of the sequence obtained by concatening the two sequences.(Update: By sequence I don\u0027t mean the STL one; a simple C array would do - anything with constant random acces).\u003cbr /\u003e\u003c/blockquote\u003e\u003cbr /\u003e\u003cu\u003eSolution1.\u003c/u\u003e\u003cbr /\u003e\u003cblockquote\u003eSimple and obvious: concatenate the two sequences( O ( n ) ) and sort them ( O ( n\u003csup\u003e2\u003c/sup\u003e ), O ( n lg n ) ). Then output the element in the middle.\u003cbr /\u003e\u003c/blockquote\u003e\u003cbr /\u003e\u003cu\u003eSolution2.\u003c/u\u003e\u003cbr /\u003e\u003cblockquote\u003eAlso simple and obvious: Merge ( O( n ) ) the two sequences and output the element in the middle. Merging can be done in-place and can be stable: see \u003ca href\u003d\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi\u003d10.1.1.40.862\"\u003ehere\u003c/a\u003e.\u003cbr /\u003e\u003c/blockquote\u003e\u003cbr /\u003e\u003cu\u003eSolution3.\u003c/u\u003e\u003cbr /\u003e\u003cblockquote\u003eAs we only need the median element, we can adapt the simple clasical merging ( still O ( n ) time, but now O ( 1 ) additional memory ) to our problem. Instead of merging the whole amount of elements, we merge only half ( to get to our median element ) and instead of keeping the whole amount of merged elements in a separate array, we can keep only the last element in this sequence. Some code for this:\u003cbr /\u003e\u003c/blockquote\u003e\u003cblockquote\u003e\u003cblockquote\u003emedian(int a[], int b[], int n, int m)\u003cbr /\u003e    int i, j, k;\u003cbr /\u003e    i \u003d j \u003d 0;\u003cbr /\u003e    while ( i \u0026lt; n \u0026amp;\u0026amp; j \u0026lt; m \u0026amp;\u0026amp; i + j \u0026lt; ( n + m ) / 2 )\u003cbr /\u003e        if ( a [ i ] \u0026lt; b [ j ] )\u003cbr /\u003e            k \u003d a [ i ]\u003cbr /\u003e            i ++\u003cbr /\u003e        else \u003cbr /\u003e            k \u003d b [ j ]\u003cbr /\u003e            j ++\u003cbr /\u003e    if ( i \u0026lt; n \u0026amp;\u0026amp; i + j \u0026lt; ( n + m ) / 2 )\u003cbr /\u003e        i \u003d i + ( n + m ) / 2 - ( i + j )\u003cbr /\u003e        k \u003d a [ i ]\u003cbr /\u003e    if ( j \u0026lt; n \u0026amp;\u0026amp; i + j \u0026lt; ( n + m ) / 2 )\u003cbr /\u003e        j \u003d j + ( n + m ) / 2 - ( i + j )\u003cbr /\u003e        k \u003d a [ j ]\u003cbr /\u003e    return k \u003cbr /\u003e\u003c/blockquote\u003e\u003c/blockquote\u003e\u003cu\u003e\u003cbr /\u003eSolution4.\u003c/u\u003e\u003cbr /\u003e\u003cblockquote\u003eSuppose the 2 sequences are a and b, 0 indexed and have sizes m and n. Also suppose that the median element is in the first sequence. Then we can binary search it. \u003cbr /\u003eGiven an element in the first sequence we can find out, also using binary search, which order of statistics it is.\u003cbr /\u003eSuppose we choose the k-th element in the first sequence( a [ k ] ). Then we know there are k elements in the first sequence that are \u0026lt;\u003d a[k]. We can find, in the second sequence, using binary search, the position kp for which b [ kp ] \u0026lt;\u003d a [ k ] \u0026lt; b [ kp + 1 ] ( if a [ k ] is smaller/greater than all elements in b the we take kp to be -1/n ), that is the position after which a [ k ] would be inserted in sequence b, such that the sequence remains sorted. Then we know there are kp + 1 elements smaller in the sequence b. So our element a [ k ] is larger than\u003cbr /\u003e k + kp + 1 elements in the union of the two sequences a and b.\u003cbr /\u003eNow, given two elements a [ x ] and a [ y ] with x \u0026lt; y, we know that a [ x ] \u0027s order of statistics is smaller than \u003cbr /\u003ea [ y ] \u0027s( if x + kx is the order of statistics of a [ x ] then a [ y ] \u0027s order of statistics is at least y + kx which is greater than x + kx ). \u003cbr /\u003eSo we can binary search in the first sequence the element with order of statistics ( m + n ) / 2. If no such element is found then we search it in the second sequence.\u003cbr /\u003eFinal complexity O ( lg\u003csup\u003e2\u003c/sup\u003e ( n ) ).\u003cbr /\u003e\u003c/blockquote\u003e\u003cbr /\u003e\u003cb\u003e\u003cu\u003eSolution5. \u003c/u\u003e\u003c/b\u003e\u003cbr /\u003e\u003cbr /\u003e\u003cblockquote\u003eWe notice, in solution4 that when we check if an element is the median, we do not need to find its order of statistics - we only need to check it its order of statistics is equal or not with n / 2.\u003cbr /\u003eSuppose that our element a [ k ] is the median \u003d\u0026gt; a [ k ] \u0026gt;\u003d than ( ( m + n ) / 2 ) - 1 elements in the union of the sequnces a and b -- k elements in a and ( ( m + n ) / 2 ) - 1 - k in b.\u003cbr /\u003eSo if b [ ( ( m + n ) / 2 ) - 1 - k ] \u0026lt;\u003d a [ k ] \u0026lt; b [ ( ( m + n ) / 2 ) - 1 - k + 1 ] then our element \u003cbr /\u003ea [ k ] is the median. If the inequality doesn\u0027t hold our element is not the median.\u003cbr /\u003eAs we know we can binary search in the first sequence the element with order of statistics \u003cbr /\u003e( m + n ) / 2 and if not found in the first sequence, we can search it in the second sequence,\u003cbr /\u003ethe final complexity is O ( log ( n ) ).\u003cbr /\u003e\u003c/blockquote\u003e\u003cbr /\u003e\u003cu\u003eSolution6.\u003c/u\u003e\u003cbr /\u003e\u003cbr /\u003e\u003cblockquote\u003eAnother solution would take advantage of the fact that the numbers are 32 bit integers. We can binary search our median in the interval [ - 2\u003csup\u003e31\u003c/sup\u003e, 2\u003csup\u003e31\u003c/sup\u003e - 1 ]. For each number x in there we can find how many numbers are smaller than x in the two sequences by applying the binary search algorithm on each of them. We also need to be careful, because x must be in one of the two sequences. Final complexity O (lg n).\u003cbr /\u003e\u003cu\u003e\u003cb\u003eNote:\u003c/b\u003e\u003c/u\u003e This algorithm has a hidden constant of 32 which on the general case when integers that are restricted to an interval of size S the algorithm has a complexity of O ( lg ( S ) * lg ( n ) ).\u003cbr /\u003e\u003c/blockquote\u003e\u003cbr /\u003e\u003cu\u003eSolution7.\u003cbr /\u003e\u003c/u\u003e\u003cbr /\u003e\u003cblockquote\u003eThe following solution I received via email and although I can see it is some form of binary search, I hadn\u0027t have the time to understand what it does. So here is the source code, as sent, without explanations.\u003cbr /\u003eSome java code for this(due to Niyaz Nigmatullin):\u003cbr /\u003e\u003c/blockquote\u003e\u003cblockquote\u003e\u003cblockquote\u003eint solve2(int[] a, int[] b) {\u003cbr /\u003e        if (a.length \u0026gt; b.length) {\u003cbr /\u003e            int[] t \u003d a;\u003cbr /\u003e            a \u003d b;\u003cbr /\u003e            b \u003d t;\u003cbr /\u003e        }\u003cbr /\u003e        int left1 \u003d 0, right1 \u003d a.length - 1;\u003cbr /\u003e        int left2 \u003d 0, right2 \u003d b.length - 1;\u003cbr /\u003e        int cur1 \u003d 0, cur2 \u003d (a.length + b.length - 1) / 2;\u003cbr /\u003e        while (true) {\u003cbr /\u003e            boolean ok \u003d right1 \u003d\u003d left1 + 1 \u0026amp;\u0026amp; right2 \u003d\u003d left2 + 1;\u003cbr /\u003e            if (a[cur1] \u003d\u003d b[cur2]) {\u003cbr /\u003e                return a[cur1];\u003cbr /\u003e            }\u003cbr /\u003e            if (a[cur1] \u0026lt; b[cur2]) {\u003cbr /\u003e                int d \u003d Math.min((cur2 - left2 + 1) / 2,\u003cbr /\u003e                                 (right1 - cur1 + 1) / 2);\u003cbr /\u003e                if (d \u003d\u003d 0) {\u003cbr /\u003e                    return cur2 \u003d\u003d 0 ? a[cur1] : Math.max(b[cur2 - 1], a[cur1]);\u003cbr /\u003e                }\u003cbr /\u003e                left1 \u003d cur1;\u003cbr /\u003e                right2 \u003d cur2;\u003cbr /\u003e                cur1 +\u003d d;\u003cbr /\u003e                cur2 -\u003d d;\u003cbr /\u003e            } else {\u003cbr /\u003e                int d \u003d Math.min((cur1 - left1 + 1) / 2,\u003cbr /\u003e                                 (right2 - cur2 + 1) / 2);\u003cbr /\u003e                if (d \u003d\u003d 0) {\u003cbr /\u003e                    return cur1 \u003d\u003d 0 ? b[cur2] : Math.max(a[cur1 - 1], b[cur2]);\u003cbr /\u003e                }\u003cbr /\u003e                right1 \u003d cur1;\u003cbr /\u003e                left2 \u003d cur2;\u003cbr /\u003e                cur1 -\u003d d;\u003cbr /\u003e                cur2 +\u003d d;\u003cbr /\u003e            }\u003cbr /\u003e            if (ok \u0026amp;\u0026amp; left1 + 1 \u003d\u003d right1 \u0026amp;\u0026amp; left2 + 1 \u003d\u003d right2) {\u003cbr /\u003e                int[] c \u003d { a[left1], a[right1], b[left2], b[right2] };\u003cbr /\u003e                Arrays.sort(c);\u003cbr /\u003e                return c[1];\u003cbr /\u003e            }\u003cbr /\u003e        }\u003cbr /\u003e    }\u003cbr /\u003e\u003cbr /\u003e\u003c/blockquote\u003eIf you have any questions, requests, comments, corrections to make please feel free to post. Thanks and, again sorry for the delay.\u003cbr /\u003eOh, and if you can explain solution7 please do.\u003cbr /\u003e\u003c/blockquote\u003e\u003c/div\u003e","tags":["interview","median","microsoft","problem","solution","statistics"]}}