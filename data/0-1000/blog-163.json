{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1268403834,"rating":1,"authorHandle":"nushio","modificationTimeSeconds":1268441931,"id":163,"title":"Codeforces Beta Round #4","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003eThis was my first time on Codeforce. I\u0027m amazed to see a contest maintained by a single person (maybe a team?), writing down problems and judges at this pace.  Thank you,                                                           \u003ca href\u003d\"http://www.topcoder.com/tc?module\u003dMemberProfile\u0026amp;cr\u003d308953\"\u003eMike Mirzayanov\u003c/a\u003e, for the contest site!\u003cbr /\u003e\u003cbr /\u003e\u003ch3\u003eWatermelon\u003c/h3\u003eThis is an easy problem. Any even number \u0026gt;\u003d4 is OK. B.t.w. I love watermelons, too!\u003cbr /\u003e\u003cbr /\u003e\u003ch3\u003eBefore an Exam\u003c/h3\u003eThis is easy, too. First, fill the minimum requirement and then fill the excess time in any order you like. I even used very unefficient algorithm O(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esumTime\u003c/i\u003e \u003c/span\u003e) .\u003cbr /\u003e\u003cbr /\u003e\u003ch3\u003eRegistration System\u003c/h3\u003eThis problem made me stop for a while to think of an appropriate data structure. If I implement the problem statement literally it\u0027ll be an O(n^2) algorithm  and it will TLE. e.g. when \u003cspan class\u003d\"tex-span\"\u003eall the 10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e people register with \u0026quot;\u003cspan style\u003d\"font-style: italic;\"\u003esame_string\u003c/span\u003e\u003cb\u003e+\u003c/b\u003e\u003ci\u003edigits\u003c/i\u003e\u0026quot; name, like [\u0026quot;a\u0026quot;, \u0026quot;a3\u0026quot;, \u0026quot;a\u0026quot;, \u0026quot;a4\u0026quot;, \u0026quot;a12\u0026quot;, \u0026quot;a\u0026quot;, ...] I hope my solution, still in queue, is O(n log^2 n) and correct...\u003cbr /\u003e\u003cbr /\u003eP.S. It was Accepted!! (2090ms / 5000ms, that was close!)\u003cbr /\u003e\u003cbr /\u003eMy basical idea is to have an \u003ci\u003eunordered_map\u0026lt;string, set\u0026lt;int\u0026gt; \u0026gt;\u003c/i\u003e \u003ci\u003edb\u003c/i\u003e so when one tries to register a \u003ci\u003ename\u003c/i\u003e, I\u0027ll look\u003ci\u003e db\u003c/i\u003e[\u003ci\u003ename\u003c/i\u003e] for a vacant suffix. Basically I have to lookup by brute force (1,2,3,4, ... ) but if I record the \u003ci\u003elast_results\u003c/i\u003e, as the startpoints of the brute force search next time, the total number of continued brute force search step is O(N).\u003cbr /\u003e\u003cbr /\u003eSome subtleties: username \u0026quot;a123\u0026quot; will conflict with the fourth request for \u0026quot;a12\u0026quot;; \u0026quot;a0\u0026quot; doesn\u0027t conflict with \u0026quot;a\u0026quot;; etc... \u003cbr /\u003e\u003cbr /\u003eSo, I break down a registered username as long as its last character is a digit, and update \u003ci\u003edb\u003c/i\u003e[\u003ci\u003ename\u003c/i\u003e] and  \u003ci\u003elast_results\u003c/i\u003e, properly. It goes like:\u003cbr /\u003e\u003cblockquote\u003edb[\u0026quot;a123\u0026quot;].occupy_raw();\u003cbr /\u003edb[\u0026quot;a12\u0026quot;].occupy(3);\u003cbr /\u003e db[\u0026quot;a1\u0026quot;].occupy(12);\u003cbr /\u003e db[\u0026quot;a\u0026quot;].occupy(123);\u003cbr /\u003e\u003cbr /\u003e \u003c/blockquote\u003e\u003ch3\u003eMysterious Present\u003c/h3\u003eI thought O(n^2) will do for this problem. If you sort all the envelopes by their width, you\u0027ll know that an envelope won\u0027t fit in any of its predecessors. Somehow, I got WA.\u003c/div\u003e","tags":["codeforces beta round #4","postmortem","thread"]}}