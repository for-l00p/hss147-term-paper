{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1291732724,"rating":14,"authorHandle":"yak_ex","modificationTimeSeconds":1291739833,"id":925,"title":"A way to use C++ iostream for large input (gcc only)","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eUpdated:\u003c/strong\u003e Add note for Cygwin environment.\u003cbr /\u003e\u003cstrong\u003eUpdated\u003c/strong\u003e: Add result on FreeBSD\u003cstrong\u003eÂ \u003c/strong\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eIn programming competition such as Codeforces, reading a large number of inputs is somtimes required, for example, 1500*1500 integers in \u003ca href\u003d\"//www.codeforces.com/contest/46/problem/E\"\u003eCodeforces Beta Round #43 Problem E\u003c/a\u003e. I used iostream(cin) in the competition and got TLE. After the competition, I saw some comments that cin caused TLE. After I replaced cin with scanf, I got AC. So, it is said \u0026quot;For large input, use cstdio instead of iostream.\u0026quot; However I believe C++ users want to use iostream. Can\u0027t we avoid the guideline?\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eShort answer:\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eI found one promising way. Unfortunately, it is applicable not to VC but to gcc. Call std::ios_base::sync_with_stdio(false) at the beginning of your code. Here is the graph to show performance comparison among iostream with the call, without the call and cstdio, \u003cem\u003e\u003cstrong\u003ein my local environments\u003c/strong\u003e\u003c/em\u003e. [\u003cstrong\u003eUpdated\u003c/strong\u003e: NOTE that File I/O on Cygwin is generally very slow. Therefore, the effect is overestimated in graph on Cygwin environment.]\u003cstrong\u003e\u003cbr /\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src\u003d\"/predownloaded/c6/6e/c66e86435c5feefd69ce59b3853334a167d9db63\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src\u003d\"/predownloaded/31/11/3111d1ca4f95f1c34a72879482c4534463b4ecac\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eX-axis shows the number of inputs and Y-axis shows seconds to read inputs. The scale of Y-axis is different between graphs.\u003c/p\u003e\u003cp\u003eThe summary of my local environment is as follows:\u003c/p\u003e\u003cul\u003e\u003cli\u003eCygwin\u003c/li\u003e\u003cul\u003e\u003cli\u003eCPU: Core2Duo T7600 2.3Ghz\u003c/li\u003e\u003cli\u003eRAM: 4GB\u003c/li\u003e\u003cli\u003eOS: Windows XP SP3\u003c/li\u003e\u003cli\u003eCompiler: gcc 4.3.4 on Cygwin 1.7.7\u003cbr /\u003e\u003c/li\u003e\u003c/ul\u003e\u003cli\u003eFreeBSD\u003c/li\u003e\u003cul\u003e\u003cli\u003eCPU: PentiumM 1.3GHz\u003c/li\u003e\u003cli\u003eRAM: 1GB\u003c/li\u003e\u003cli\u003eOS: FreeBSD 8.1-STABLE\u003c/li\u003e\u003cli\u003eCompiler: gcc 4.2.1\u003c/li\u003e\u003c/ul\u003e\u003c/ul\u003e\u003cp\u003eTarget source code is \u003ca href\u003d\"http://codepad.org/r4lJllq6\"\u003ehere\u003c/a\u003e (at codepad.org).\u003c/p\u003e\u003cp\u003eThough I don\u0027t know the precise effect in the judge environment, I can get AC with iostream, at least, for \u003ca href\u003d\"//www.codeforces.com/contest/46/problem/E\"\u003eCodeforces Beta Round #43 Problem E\u003c/a\u003e. NOTE that the effect of the call depends on implementation of C++ standard library. For example, there is no significant difference for VC++.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eShort explanation:\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eCalling sync_with_stdio(false) may improve performance. What is the actual effect of the call?\u003cstrong\u003e\u003cbr /\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe standard (ISO/IEC 14882:2003) says:\u003c/p\u003e\u003chr /\u003e\u003cblockquote\u003e\u003cstrong\u003e27.4.2.4 ios_base static members\u003c/strong\u003e\u003cbr /\u003e\u003c/blockquote\u003e\u003cblockquote\u003ebool sync_with_stdio(bool sync \u003d true);\u003c/blockquote\u003e\u003cblockquote\u003e\u003cstrong\u003eReturns:\u003c/strong\u003e true if the standard iostream objects (27.3) are synchronized and otherwise returns false.\u003cbr /\u003e\u003c/blockquote\u003e\u003cblockquote\u003eThe first time it is called, the function returns true.\u003cbr /\u003e\u003c/blockquote\u003e\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003eEffects:\u003c/strong\u003e If any input or output operation has occurred using the standard streams prior to the call, the effect is implementation-defined. Otherwise, called with a false argument, it allows the standard streams to operate independently of the standard C streams.\u003c/p\u003e\u003c/blockquote\u003e\u003chr /\u003e\u003cp\u003eThis means that synchronization with standard C stream is required without the call. In libstdc++ (C++ standard library used by g++), this flag switches iostream object\u0027s underlying buffer between stdio_filebuf and stdio_sync_filebuf. stdio_sync_filebuf has little buffering by itself and delegate almost all operation to cstdio. See also \u003ca href\u003d\"http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch28s02.html\"\u003elibstdc++ manual page\u003c/a\u003e.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eFor programming competition, there seems to be little use of mixture of cstdio and iostream. Thus, I recommend that you include the call in your code template. :p\u003c/p\u003e\u003c/div\u003e","tags":["c++","iostream"]}}