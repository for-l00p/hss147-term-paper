{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1291808774,"rating":16,"authorHandle":"Vasya.V","modificationTimeSeconds":1291814949,"id":931,"title":"Codeforces Beta Round #44: tutorial","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e1) Because of small constraints, just iterate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e from 1 to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and check \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/db/ed/dbed1911f5357013d51f2bfa640e607c3496b448.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003cbr /\u003e  \u003cpre class\u003d\"prettyprint\"\u003efor (int n \u003d 1; n \u0026lt;\u003d Tn; n++)\n{\n    if (n * (n + 1) / 2 \u003d\u003d Tn)\n    {\n        cout \u0026lt;\u0026lt; \u0026quot;YES\\n\u0026quot;;\n        return;\n    }\n}\ncout \u0026lt;\u0026lt; \u0026quot;NO\\n\u0026quot;;\n\u003c/pre\u003e \u003cbr /\u003e 2) Let\u0027s consider a graph, where the letters \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e are the vertexes and if  \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026lt; \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, then the edge \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e -  \u0026gt; \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e exists. After that let\u0027s perform \u003ca href\u003d\"http://en.wikipedia.org/wiki/Topological_sorting\"\u003etopological sort\u003c/a\u003e. If a cycle was found during this operation, put \u0026quot;Impossible\u0026quot; and exit. Otherwise put the answer.\u003cbr /\u003e\u003cbr /\u003eAnother approach is acceptable because of small constaints (by \u003ca href\u003d\"http://codeforces.ru/profile/Connector\"\u003eConnector \u003c/a\u003ein russian comments).\u003cbr /\u003eJust iterate over all of \u003cspan class\u003d\"tex-span\"\u003e3!\u003c/span\u003e permutaioins of the letters and check if they are sorted. If no such permutation, put \u0026quot;Impossible\u0026quot;\u003cbr /\u003e\u003cbr /\u003e 3) Let\u0027s iterate over all of  \u003cspan class\u003d\"tex-span\"\u003e6! \u003d 720\u003c/span\u003e permutations. For every permutation let\u0027s try to put the first 3 words horizontally, the others - vertically:\u003cbr /\u003e\u003col\u003e\u003cli\u003ehor[0], ver[0] - left-up\u003cbr /\u003e\u003c/li\u003e\u003cli\u003ehor[2], ver[2] - right-down\u003cbr /\u003e\u003c/li\u003e\u003cli\u003ehor[1]: (len(ver[0]) - 1, 0)\u003c/li\u003e\u003cli\u003ever[1]: (0, len(hor[0]) - 1)\u003cbr /\u003e\u003c/li\u003e\u003c/ol\u003eNow let\u0027s define N \u003d len(ver[1]), M \u003d len(hor[1]).\u003cbr /\u003eA Conditions for the solution existence\u003cbr /\u003e\u003col\u003e\u003cli\u003elen(hor[0]) + len(hor[2]) \u003d\u003d M + 1 // edges of \u0026quot;eight\u0026quot;\u003cbr /\u003e\u003c/li\u003e\u003cli\u003elen(ver[0]) + len(ver[2]) \u003d\u003d N + 1  // edges of \u0026quot;eight\u0026quot;\u003cbr /\u003e\u003c/li\u003e\u003cli\u003elen(hor[0]) \u0026gt;\u003d 3 \u0026amp;\u0026amp; len(hor[2]) \u0026gt;\u003d 3 \u0026amp;\u0026amp; len(ver[0]) \u0026gt;\u003d 3 \u0026amp;\u0026amp; len(ver[2]) \u0026gt;\u003d 3 // \u0026quot;eight\u0026quot; is nondegenerate\u003c/li\u003e\u003cli\u003eThe letters at start/end of appropriate strings are match\u003c/li\u003e\u003cli\u003eThe letters on the intersection of hor[1], ver[1] are match\u003cbr /\u003e\u003c/li\u003e\u003c/ol\u003eNow we have the right field of the size N x M, and update the answer\u003cbr /\u003eNote In C++ if you use vector\u0026lt;vector\u0026lt;char\u0026gt; \u0026gt; or vector\u0026lt;string\u0026gt; as the field type, then you can simply use operator \u0026quot;\u0026lt;\u0026quot; for updating.\u003cbr /\u003e\u003cbr /\u003e4) Let\u0027s consider not the most efficient, but AC algorithm, with  the complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003emC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003ci\u003elog\u003c/i\u003e(\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e))\u003c/span\u003e.\u003cbr /\u003eLet\u0027s consider the 1 answer of the system: \u0026lt;number, v\u0026gt;. The amount of the variants of the password is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e - not very large number in constaints of the problem, you can simply generate this variants. Declare this set of variants as current. Now, for the every answer let\u0027s generate a set of possible passwords, and let\u0027s declare the intersection of this set and current set as current. After \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e iterations we\u0027ll have some set. Then we\u0027ll erase elements from this set, which were in the answers of the system, and the answer of the problem will be the size of this set.\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003e5) Let\u0027s consider an algorightm with complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e))\u003c/span\u003e.\u003cbr /\u003eExclude from considiration every wall can\u0027t be achieved by canon:  \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026gt; \u003ci\u003ev\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e / \u003ci\u003eg\u003c/i\u003e\u003c/span\u003e\u003cbr /\u003eBecause of \u003cspan class\u003d\"tex-span\"\u003eα \u0026lt; \u003dπ / 4\u003c/span\u003e:\u003cbr /\u003e\u003col\u003e\u003cli\u003eFunction \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/sub\u003e(α)\u003c/span\u003e is monotonous\u003cbr /\u003e\u003c/li\u003e\u003cli\u003eFunction \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e(α, \u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e, when x is fixed, is monotonous\u003c/li\u003e\u003c/ol\u003eSuch observation allows to assign to each wall a section of the attack angle \u003cspan class\u003d\"tex-span\"\u003e[α1, α2]\u003c/span\u003e. If this canon shoots with angle within this section, it hits the wall. These angles can be obtained by solving equation (it will be biquadratic), but because of monotonous we can use binary search.\u003cbr /\u003eSort walls by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Now the initial problem has reduced to the problem: for every shoot it is need to obtain minimal index of the wall, when shoot angle is between attack angles for this wall. This problem can be solved by Segment Tree for Minimum with possibility to update on an interval. At first, fill tree with KInf. Next, for every wall let\u0027s perform update(\u003cspan class\u003d\"tex-span\"\u003eα1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003eα2\u003c/span\u003e, index). Then let\u0027s iterate over requests. If getMin(\u003cspan class\u003d\"tex-span\"\u003eα\u003c/span\u003e) \u003d\u003d KInf, then missle do not hit any wall and hit the land, otherwise it hit the wall with index getMin(\u003cspan class\u003d\"tex-span\"\u003eα\u003c/span\u003e).\u003c/div\u003e","tags":["beta-round-44","tutorial"]}}