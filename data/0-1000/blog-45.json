{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1265182797,"rating":0,"authorHandle":"Jokser","modificationTimeSeconds":1265182797,"id":45,"title":"Помогите с задачей.","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eЗадача из второго тура SNWS-10. Про медиану. Дано N (1\u0026lt;\u003dN\u0026lt;\u003d10^6) чисел. Числа добавляются в изначально пустой набор в заданном порядке. Требуется определять медиану после каждого добавления числа. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eЯ реализовал бинарное дерево поиска по Кормену. Однако получил TL на 11 тесте. Вот код:\u003c/p\u003e\u003cp\u003e \u003c/p\u003e\u003cp\u003estruct binary_elem {\u003cbr /\u003e long key,size,left,right; \u003cbr /\u003e};\u003cbr /\u003e\u003cbr /\u003evector\u0026lt;binary_elem\u0026gt; BT;\u003cbr /\u003e\u003cbr /\u003ebinary_elem BT_init(long key) {\u003cbr /\u003e binary_elem res;\u003cbr /\u003e res.key\u003dkey;\u003cbr /\u003e res.size\u003d1;\u003cbr /\u003e res.left\u003d-1;\u003cbr /\u003e res.right\u003d-1;\u003cbr /\u003e return res;\u003cbr /\u003e}\u003cbr /\u003e\u003cbr /\u003evoid BT_insert (binary_elem z) {\u003cbr /\u003e long y\u003d-1,x\u003d0;\u003cbr /\u003e BT.push_back(z);\u003cbr /\u003e long cur\u003dBT.size()-1;\u003cbr /\u003e if (cur\u003d\u003d0) return;\u003cbr /\u003e while (x!\u003d-1) {\u003cbr /\u003e  y\u003dx;\u003cbr /\u003e  BT[x].size++;\u003cbr /\u003e  if (z.key\u0026lt;BT[x].key) x\u003dBT[x].left; else x\u003dBT[x].right;\u003cbr /\u003e }\u003cbr /\u003e if (y!\u003d-1)\u003cbr /\u003e  if (z.key\u0026lt;BT[y].key) BT[y].left\u003dcur; else BT[y].right\u003dcur;\u003cbr /\u003e}\u003cbr /\u003e\u003cbr /\u003elong BT_select (long x, long i) {\u003cbr /\u003e long r;\u003cbr /\u003e while (true) {\u003cbr /\u003e  if (BT[x].left\u003d\u003d-1) r\u003d1; else r\u003dBT[BT[x].left].size+1;\u003cbr /\u003e  if (i\u003d\u003dr) return BT[x].key;\u003cbr /\u003e  else if (i\u0026lt;r) { x\u003dBT[x].left; } else {x\u003dBT[x].right; i\u003di-r; }\u003cbr /\u003e }\u003cbr /\u003e}\u003cbr /\u003e\u003cbr /\u003eint main(){\u003cbr /\u003e long n,num,i;\u003cbr /\u003e freopen(\u0026quot;median.in\u0026quot;,\u0026quot;rt\u0026quot;,stdin);\u003cbr /\u003e freopen(\u0026quot;median.out\u0026quot;,\u0026quot;wt\u0026quot;,stdout);\u003cbr /\u003e scanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\u003cbr /\u003e for (i\u003d0;i\u0026lt;n;i++) {\u003cbr /\u003e  scanf(\u0026quot;%d\u0026quot;,\u0026amp;num);\u003cbr /\u003e  BT_insert(BT_init(num));\u003cbr /\u003e  long res \u003d BT_select(0,(i+2)/2);\u003cbr /\u003e  printf(\u0026quot;%d \u0026quot;,res);\u003cbr /\u003e }\u003cbr /\u003e}\u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eПодскажите плз, что не так. Или как ее можно решить по-другому. Я посмотрел, некоторые ее решили за 5-7 минут!\u003c/p\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003c/div\u003e","tags":["snark","бинарное дерево","задача"]}}