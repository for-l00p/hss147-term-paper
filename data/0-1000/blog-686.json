{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1285043501,"rating":0,"authorHandle":"onlyone","modificationTimeSeconds":1285043501,"id":686,"title":"My solution @ Round #29, [without Problem E]","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003eProblem A:\u003cbr /\u003eCheck whether exist a pair i and j,they satisfy xi+di \u003d xj \u0026amp;\u0026amp; xj+dj \u003d xi;\u003cbr /\u003e\u003cbr /\u003eProblem B:\u003cbr /\u003ePay attention to Just Right or Red. use Div and Mod can solve it easily;\u003cbr /\u003e\u003cbr /\u003eProblem C:\u003cbr /\u003eAs we know, there are only two path -- forward and reverse, so we can do DFS from the one-degree nodes (only two nodes).\u003cbr /\u003eAs their index may be very larger, so I used map\u0026lt;int,int\u0026gt; to do hash.\u003cbr /\u003e\u003cbr /\u003evoid dfs(int i)\u003cbr /\u003e{\u003cbr /\u003e     int sz \u003d mat[i].size()-1, j;\u003cbr /\u003e     UF(j,0,sz)\u003cbr /\u003e     if (!vis[mat[i][j]])\u003cbr /\u003e     {\u003cbr /\u003e        vis[mat[i][j]] \u003d 1;\u003cbr /\u003e        printf(\u0026quot; %d\u0026quot;,val[mat[i][j]]);\u003cbr /\u003e        dfs(mat[i][j]);\u003cbr /\u003e     }\u003cbr /\u003e}\u003cbr /\u003e\u003cbr /\u003eProblem D: \u003cbr /\u003eFloyd.\u003cbr /\u003eFirst, Floyd pretreat the path from I to J, and save the path. \u003cbr /\u003eThen get the answer.\u003cbr /\u003eThe order is a1,a2...ak, K is the number of the leaves, we can assume a0 \u003d a\u003csub\u003ek+1\u003c/sub\u003e \u003d 1, the root.\u003cbr /\u003ethen, answer push_back the path[ai][a\u003csub\u003ei+1\u003c/sub\u003e].\u003cbr /\u003e\u003cbr /\u003eif the ans.size() \u0026gt; 2*N-1 , cout -1;\u003cbr /\u003eelse cout the answer.\u003cbr /\u003e\u003cbr /\u003e\u003c/div\u003e","tags":["round#29","solution"]}}