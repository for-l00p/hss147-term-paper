{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1270467303,"rating":3,"authorHandle":"at1","modificationTimeSeconds":1317951281,"id":249,"title":"Beta Round #6 - Разбор задач","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eA. Треугольник\u003c/h3\u003eИз трех палочек с длинами \u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e \u0026gt; 0 можно составить треугольник ненулевой площади тогда и только тогда, когда:\u003cbr /\u003e|\u003ci\u003ea\u003c/i\u003e - \u003ci\u003eb\u003c/i\u003e| \u0026lt; \u003ci\u003ec\u003c/i\u003e \u0026lt; \u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e (+)\u003cbr /\u003eПри вырожденном случае в (+) одно из неравенств обращается в равенство. (Для обоснования можно построить окружности радиуса \u003ci\u003ea\u003c/i\u003e и \u003ci\u003eb\u003c/i\u003e с центрами в концах отрезка длины \u003ci\u003ec\u003c/i\u003e, и проверить когда они пересекаются).\u003cbr /\u003e\u003cbr /\u003eТаким образом, можно перебрать все тройки чисел из данных 4-х и проверить (+).\u003cbr /\u003e \u003cbr /\u003e\u003ch3\u003eB. Кабинет президента\u003c/h3\u003eДостаточно перебрать все клетки, соседние с клетками цвета стола президента, помечая их цвета. То есть после процедуры мы будем знать для каждого цвета, является ли он соседним с данным нам. Ответ на задачу - количество помеченных цветов.\u003cbr /\u003e\u003ch3\u003eC. Алиса, Боб и шоколад\u003c/h3\u003eНеобходимо промоделировать описанную в условии игру. Имеем два указателя на начало и конец массива длин шоколадок, каждый раз смещаясь по первому, второму или обоим (в зависимости от длин шоколадок). Сместившись только по одному указателю, нужно уменьшить длину недоеденной шоколадки.\u003cbr /\u003eЕдинственная техническая трудность - правильно обработать последнюю шоколадку, можно ошибиться или зациклиться, если участники перейдут к ней одновременно.\u003cbr /\u003e\u003ch3\u003eE. Экспозиция\u003c/h3\u003eРассмотрим функцию \u003ci\u003ef\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e) \u003d max(\u003ci\u003eh\u003csub\u003ei\u003c/sub\u003e\u003c/i\u003e) - min(\u003ci\u003eh\u003csub\u003ej\u003c/sub\u003e\u003c/i\u003e), \u003ci\u003el \u003c/i\u003e≤\u003ci\u003e i\u003c/i\u003e,\u003ci\u003e j\u003c/i\u003e\u003ci\u003e \u003c/i\u003e≤ \u003ci\u003er\u003c/i\u003e. (\u0026lt;\u003ci\u003eмаксимум на отрезке\u003c/i\u003e\u0026gt; - \u0026lt;\u003ci\u003eминимум на отрезке\u003c/i\u003e\u0026gt;). Эта функция как раз и отражает разницу между самой высокой и самой низкой книгами на взятом отрезке.\u003cbr /\u003eЕсли \u003ci\u003el\u003c/i\u003e возрастает при фиксированом \u003ci\u003er\u003c/i\u003e, то функция убывает, аналогично, по \u003ci\u003er\u003c/i\u003e функция растет. К монотонной по \u003ci\u003er \u003c/i\u003eфункции \u003ci\u003ef\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e\u003csub\u003e0\u003c/sub\u003e, \u003ci\u003er\u003c/i\u003e) можно применить бинарный поиск и найти наибольшее \u003ci\u003er\u003c/i\u003e, для которого \u003ci\u003ef\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e\u003csub\u003e0\u003c/sub\u003e, \u003ci\u003er\u003c/i\u003e) ≤ \u003ci\u003ek\u003c/i\u003e. Подходящая структура данных для поиска минимума (максимума) на отрезке - дерево отрезков.\u003cbr /\u003eДля каждого левого конца можно найти максимально удаленный правый за время O(\u003ci\u003en\u003c/i\u003e*log\u003csup\u003e2\u003c/sup\u003e(\u003ci\u003en\u003c/i\u003e)). (\u003ci\u003en\u003c/i\u003e - левых концов, O(log(\u003ci\u003en\u003c/i\u003e)) вычислений \u003ci\u003ef\u003c/i\u003e с помощью дерева отрезков за O(log(\u003ci\u003en\u003c/i\u003e))). Из этого множества отрезков ответом являются те, длина которых максимальна.\u003cbr /\u003eМожно упростить это решение и по написанию кода и по времени \u0026quot;техникой двух указателей\u0026quot;. \u003ci\u003ep\u003csub\u003el\u003c/sub\u003e\u003c/i\u003e указывает на начало отрезка, \u003ci\u003ep\u003csub\u003er\u003c/sub\u003e\u003c/i\u003e на конец, причем если \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ep\u003csub\u003el\u003c/sub\u003e\u003c/i\u003e, \u003ci\u003ep\u003csub\u003er\u003c/sub\u003e\u003c/i\u003e) \u0026lt; \u003ci\u003ek\u003c/i\u003e, то увеличиваем \u003ci\u003ep\u003csub\u003el\u003c/sub\u003e\u003c/i\u003e, иначе \u003ci\u003ep\u003csub\u003er\u003c/sub\u003e\u003c/i\u003e. Из-за уже указанных свойствах монотонности \u003ci\u003ef \u003c/i\u003eпо \u003ci\u003el\u003c/i\u003e и \u003ci\u003er\u003c/i\u003e, можно утверждать\u003ci\u003e,\u003c/i\u003e что [\u003ci\u003ep\u003csub\u003el\u003c/sub\u003e\u003c/i\u003e, \u003ci\u003ep\u003csub\u003er\u003c/sub\u003e\u003c/i\u003e] заметут все искомые отрезки.\u003cbr /\u003e\u003cbr /\u003eТеперь можно увидеть, что мы используем всего три операции:\u003cbr /\u003e\u0026lt;\u003ci\u003eдобавить элемент \u003c/i\u003e\u003ci\u003ep\u003csub\u003er\u003c/sub\u003e\u003c/i\u003e\u0026gt;\u003cbr /\u003e\u0026lt;\u003ci\u003eудалить \u003c/i\u003e\u003ci\u003eэлемент\u003c/i\u003e\u003ci\u003e p\u003csub\u003el\u003c/sub\u003e\u003c/i\u003e\u0026gt;\u003cbr /\u003e\u0026lt;\u003ci\u003eвзять максимум - минимум на текущем отрезке\u003c/i\u003e\u0026gt;\u003cbr /\u003e\u003cbr /\u003eТо есть можно просто кидать/удалять элементы вида (\u003ci\u003eh\u003csub\u003ei\u003c/sub\u003e\u003c/i\u003e, \u003ci\u003ei\u003c/i\u003e) в \u003cb\u003eset\u003c/b\u003e (структура данных организующая множество, построенная на любом сбалансированном дереве, как правило есть стандартных библиотеках языка). Минимум - левый элемент в дереве, максимум - правый.\u003cbr /\u003e\u003cbr /\u003eСложность алгоритма с сетом O(\u003ci\u003en\u003c/i\u003e*log(\u003ci\u003en\u003c/i\u003e)). (≤ 2\u003ci\u003en\u003c/i\u003e смещений \u003ci\u003ep\u003csub\u003el\u003c/sub\u003e\u003c/i\u003e, \u003ci\u003ep\u003csub\u003er\u003c/sub\u003e\u003c/i\u003e, на каждом шаге обращение к сету за O(log(\u003ci\u003en\u003c/i\u003e))).\u003c/div\u003e","tags":["codeforces beta round #6","разбор"]}}