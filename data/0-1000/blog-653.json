{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1284139379,"rating":16,"authorHandle":"Fefer_Ivan","modificationTimeSeconds":1284147723,"id":653,"title":"Codeforces Beta #27 - Tutorial","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e \u003cstrong\u003eA. \u003ca href\u003d\"http://codeforces.ru/contest/27/problem/A\"\u003eNext Test\u003c/a\u003e\u003c/strong\u003e\u003cbr /\u003e We will create an array of boolean used[1..3001] ans fill it with \u0026quot;false\u0026quot; values. For each of n given number, we will assign corresponding used value to \u0026quot;true\u0026quot;. After that, the index of first element of used with \u0026quot;false\u0026quot; value is the answer to the problem.\u003cbr /\u003e\u003cbr /\u003e  \u003cstrong\u003eB. \u003ca href\u003d\"http://codeforces.ru/contest/27/problem/B\"\u003eTournament\u003c/a\u003e\u003c/strong\u003e\u003cbr /\u003e To solve this problem first of all we should find such numbers A and B that occur in the input data not (n - 1) times, but (n - 2). We can notice, that winner-loser relation in this problem is transitive. This means that if X wins against Y and Y wins against Z, than X wins against Z. So to find out who is harsher A or B, let\u0027s look for such C, that the results of the match A with C and B with C are distinct. If such C exists, than the one, who wins against C should be printed first. If there is no such C, than both results of the match A versus B satisfy problem\u0027s statement. \u003cbr /\u003e\u003cbr /\u003e  \u003cstrong\u003eC. \u003ca href\u003d\"http://codeforces.ru/contest/27/problem/C\"\u003eUnordered Subsequence\u003c/a\u003e\u003c/strong\u003e\u003cbr /\u003e First of all, we should notice, that if answer exists, it consist of 3 elements. Here is linear time solution.\u003cbr /\u003e Let\u0027s path with for-loop through the given array and on each iteration let\u0027s store current minimul and maximun elements positions. When we are looking at some element, it is enough to check, whereas this element makes unordered subsequence along with  min and max elements of the previous part of the array. It is not obvious, but not very difficult to prove. You should try it yourself.\u003cbr /\u003e\u003cbr /\u003e  \u003cstrong\u003eD. \u003ca href\u003d\"http://codeforces.ru/contest/27/problem/D\"\u003eRing Road 2\u003c/a\u003e\u003c/strong\u003e\u003cbr /\u003e Consider all m given roads as segments on numeric axis. Road from town a to town b should correspond to segment [min(a, b), max(a, b)]. For each pair of segments there are three types of positions: both ends of one segment are inside of the other one, both ends of one segment are outside of the other one and only one end of one segment is inside of the other one. In the first two cases positions of corresponding roads(inside circle or outside) are independend. But in the third case this positions must be opposite\u003cbr /\u003e Let\u0027s build the graph. Vertexes will correspond to segments/roads and edge between vertexes i and j will mean that positions of this roads should be opposite. Now we have another problem: for given undirected graph, we must paint all vertexes in 2 colours such that for each edge, corresponding vertexes will have different colours. This problem can be solved using DFS algorithm. First, we will paint all vertexes in -1 colour. Let\u0027s begin for-loop through vertexes. If loop finds -1-vertex, assing colour 0 to the vertex and run DFS from it. DFS from vertex V should look through all neighbor vertex. If neighbor has colour -1, than assing to that neighbor colour, opposite to the colour of V and run DFS from it. If neighbor already has non-negative colour, we should check whereas this colour is opposite, because if it is not, answer is \u0026quot;Impossible\u0026quot;. Such DFS will either build the correct answer or prove that it is impossible.\u003cbr /\u003e\u003cbr /\u003e  \u003cstrong\u003eE. \u003ca href\u003d\"http://codeforces.ru/contest/27/problem/E\"\u003eNumber With The Given Amount Of Divisors\u003c/a\u003e\u003c/strong\u003e\u003cbr /\u003e Consider the number, that is our answer and factorize it. We will get such product \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sup\u003e· \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sup\u003e· ... · \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/sup\u003e\u003c/span\u003e. Product through each i \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + 1\u003c/span\u003e will be the number of divisors. So, if we will take first 10 prime numbers, their product will have 1024 divisors. This means that we need only first 10 primes to build our answer.\u003cbr /\u003e  Let\u0027s do it with dynamic programming: d[i][j] - the minimal number with i divisors that can be built with first j prime numbers. To calculate the answer for state (i, j) let\u0027s look over all powers of j-th prime number in the answer. If j-th prime number has power k in the answer, than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e] \u003d \u003ci\u003ed\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e / (\u003ci\u003ek\u003c/i\u003e + 1)][\u003ci\u003ej\u003c/i\u003e - 1] * \u003ci\u003eprime\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. For each power of j-th prime we must select the power, that gives us minimal d[i][j].\u003cbr /\u003e  You should be extremely careful during the implementation, because all calculations are made on the edge of overflow.\u003cbr /\u003e\u003cbr /\u003e  This is it for now. I hope, you will puzzle out all problems, upsolve them and after next contest will get to the division 1. All questions and remarks you can post in the comments.\u003cbr /\u003e With best regards, Ivan \u003c/p\u003e\u003c/div\u003e","tags":["beta round #27","codeforces","codeforces format"]}}