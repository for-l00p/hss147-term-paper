{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1408769590,"rating":77,"authorHandle":"kien_coi_1997","modificationTimeSeconds":1408770053,"id":13501,"title":"\u003cp\u003eTransform Skip list into a BIT with insert operator\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eBIT does not support insert operator, but Skip list does. I realized that we can transform a Skip list into a BIT.\u003c/p\u003e\u003cp\u003eExample source code for impatient people:\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://paste.ubuntu.com/8119698/\"\u003ehttp://paste.ubuntu.com/8119698/\u003c/a\u003e\u003c/p\u003e\u003cp\u003eMy data-structure contains some operators:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eInsert x v: insert an element valued v into position x:\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eFor instance: {10,20,30} -\u0026gt; insert 40 3 -\u0026gt; {10,20,40,30}\u003c/p\u003e \u003cul\u003e   \u003cli\u003eRange-sum x y: return sum of elements in ranges x..y\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eFor instance: {10,20,30} -\u0026gt; range-sum 2 3 -\u0026gt; 50\u003c/p\u003e\u003cp\u003eAverage complexity of each operator is O(log (max n))\u003c/p\u003e\u003ch1\u003e1. Property\u003c/h1\u003e\u003ch2\u003ea. Parent — child relationship\u003c/h2\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/80/24/80249324b157f09fce35b98ae73d4ec6752bed42.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eA is parent of B if A is the first node on the right of B and A is not shorter than B (A is higher or at least equal B height).\u003c/p\u003e\u003ch2\u003eb. Sum and Count\u003c/h2\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/d8/a1/d8a19aca72ce8ec014049fb7442453f29538e4a0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eIn each node, we maintain a value Sum and Count. \u003c/p\u003e\u003cp\u003eAssume u has children u1, u2, ...\u003c/p\u003e\u003cp\u003eSum[u] \u003d Value[u] + Value[u1] + Value[u2] + ...\u003c/p\u003e\u003cp\u003eCount[u] \u003d 1 + Count[u1] + Count[u2] + ...\u003c/p\u003e\u003ch1\u003e2. Operators\u003c/h1\u003e\u003ch2\u003ea. Accessing an element x-th\u003c/h2\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/00/83/008397290d23b3321d3c67d461a774336277c771.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e \u003cul\u003e   \u003cli\u003eFor each level (from 19 to 0), we move as far as possible but still not over x-th element (We use value Count in each node to ensure that we not go over x-th element). Additionally, we must keep array Last[] contain id of last element not exceed x-th element (to use this for later operators).\u003c/li\u003e \u003c/ul\u003e\u003ch2\u003eb. Insert an element into position x\u003c/h2\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/72/57/7257ec48d74e9cb0a916929c7dc4e8ae9e9e5f76.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e \u003cul\u003e   \u003cli\u003eAccess (x-1)-th element, Last[] let us know edges between (x-1)-th and x-th element.\u003c/li\u003e   \u003cli\u003eDisconnect short edges (edges which height \u0026lt;\u003d new element\u0027s height), maintain Sum and Count of other elements.\u003c/li\u003e   \u003cli\u003eInsert new element, connect some necessary elements in Last[] with the new element, maintain Sum and Count of relevant elements.\u003c/li\u003e   \u003cli\u003eConnect new element with its parent, maintain Sum and Count of relevant elements.\u003c/li\u003e \u003c/ul\u003e\u003ch2\u003ec. Get sum of a range\u003c/h2\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/89/32/89326d3cecd266cebe8472747b90e851091459f1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eRealize (Range-sum x y) \u003d (Range-sum 1 y) — (Range-sum 1 x-1), therefore we only need to process (range-sum 1 x).\u003c/p\u003e \u003cul\u003e   \u003cli\u003eAccess x-th element\u003c/li\u003e   \u003cli\u003eGet sum of all of elements in Last[], if an element twice or more, we only plus once.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eFor example, Last[]\u003d{0,0,0,2,3,3,3} -\u0026gt; Answer \u003d Sum[0] + Sum[2] + Sum[3]\u003c/p\u003e\u003ch1\u003e3. Example source code\u003c/h1\u003e\u003cp\u003e\u003ca href\u003d\"http://paste.ubuntu.com/8119698/\"\u003ehttp://paste.ubuntu.com/8119698/\u003c/a\u003e\u003c/p\u003e \u003cul\u003e   \u003cli\u003eI tested it and it worked correctly.\u003c/li\u003e   \u003cli\u003eIt run fast, complexity of each query is about 2.5 * log (max n)\u003c/li\u003e \u003c/ul\u003e\u003c/div\u003e","tags":["skip-list","fenwick tree","bit"]}}