{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1419565334,"rating":0,"authorHandle":"PrashantM","modificationTimeSeconds":1419565364,"id":15378,"title":"\u003cp\u003eSSN Coding Contest — 5 (Editorial)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eEditorial by Roopesh\u003c/p\u003e\u003cp\u003eA ----- Football (\u003ca href\u003d\"//codeforces.com/problemset/problem/43/A\"\u003ehttp://codeforces.com/problemset/problem/43/A\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eUse separate counters for the 2 teams and count the number of occurences and print the corresponding team as the winner . Map in STL can be used for this question , have a map\u0026lt;string ,int\u0026gt; m .As u get a new string which was not already present in the map (use the inbuilt function map::find() , which returns map::end() if not found) , initialize the value of int to 0 . And as u get the string(s) , increment its int value (m[s]++). (Map finds the key (string in this case) in atmost logN searches . ) \u003c/p\u003e\u003cp\u003eB -----Supercentral point (\u003ca href\u003d\"//codeforces.com/problemset/problem/165/A\"\u003ehttp://codeforces.com/problemset/problem/165/A\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eTake the input of the points , use STL pairs if necessary . And just check for a given point if there exists at least one other neighbour for each position . Use flags or a 2 D array for each of the position (L,R,U,B) and the value of the corresponding position is 1 if there is atleast one of the neighbours of the position for the given point . \u003c/p\u003e\u003cp\u003eC ----- Difference Row (\u003ca href\u003d\"//codeforces.com/problemset/problem/347/A\"\u003ehttp://codeforces.com/problemset/problem/347/A\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eTake input of the values . Sort them . Swap the first element and the last element and print the elements of the sorted array seperated by a space .\u003c/p\u003e\u003cp\u003eHow this works ? \u003c/p\u003e\u003cp\u003eCase 1 : All are positive . We greedily choose the maximum positive score . Which is g \u003d (v[n-1] — v[1] + v[n-2] — v[0]) . And subtract the differences between the other adjacent pairs .\u003c/p\u003e\u003cp\u003eCase 2 : +ve and -ve combo . The maximum positive score u can get is g . Because v[n-1] and v[1] are both of the opposite signs . — ( — ) \u003d + . Similairly for the v[0] and v[n-2] .\u003c/p\u003e\u003cp\u003eD ----- Physics Practicals (\u003ca href\u003d\"//codeforces.com/problemset/problem/253/B\"\u003ehttp://codeforces.com/problemset/problem/253/B\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eMake sure u read the input from the file properly . Usage of freopen() is recommended.\u003c/p\u003e\u003cp\u003eWe are only focusing on the values of her longest and smallest reading . So sort the values of readings and use 2 pointers or the sliding window algorithm . \u003c/p\u003e\u003cp\u003eFor each value in the sorted array find the maximum value of j such that condition a[j] \u0026lt;\u003d 2*a[i] . The number of values in this range is j- i +1 . Find the maximum such value for each position . The final answer is N — (max_value — 1) . Check for the off by one errors . \u003c/p\u003e\u003cp\u003eE ----- Good Sequences (\u003ca href\u003d\"//codeforces.com/problemset/problem/264/B\"\u003ehttp://codeforces.com/problemset/problem/264/B\u003c/a\u003e)\u003c/p\u003e\u003cp\u003ePM always likes to give us a \u0026quot; ___ sequences \u0026quot; problem for E :p Last contest had a hungry sequences problem .\u003c/p\u003e\u003cp\u003eSolved using Dynamic Programming (DP)\u003c/p\u003e\u003cp\u003eThe question asks for the maximum length of good subsequence . v[i] is the i th good integer .\u003c/p\u003e\u003cp\u003e1\u0026gt; Initial ideas — ( O(n^2) wont run for n being 10 ^ 5 in this problem ) The simplest way is having array say dp[i] being the maximum such subsequence ending at i th element . dp[i] \u003d max(dp[k]+1,dp[i]) for each k from i-1 to 0 if(gcd(v[k],v[i] \u0026gt; 1)) using euclidian\u0027s GCD algorithm . Or Use __gcd(a,b) in STL . \u003c/p\u003e\u003cp\u003e2\u0026gt; How to make it into a N^1.5 (N root N) solution . When does a current element extend the maximal sequence consisting of the earlier entries ? If one of its prime factor was also a factor for any of the previous entries . If so , then this would be the next element to the element with the common prime factor . \u003c/p\u003e\u003cp\u003eUse sieve of eratosthenes to build an array where a[i] \u003d 1 iff i is prime . (NloglogN) . Have an array dp , where dp[i] will store the length of the maximum subsequence ending at an element say x , such that x % i \u003d \u003d 0 .Have a variable (say T)for finding the maximal value when current element x extends an already existing good subsequence .  For a given element , find all the factors till the square root of x and check if it is a prime factor . If so , T\u003dmax(T,dp[i]+1) . dp[i] is the length of good subsequence with the last element having i as one of its prime factor . Since x extends the sequence , dp[i]+1 would be the length of the good subsequence currently . \u003c/p\u003e\u003cp\u003eNow that u are done for x , u need to update the value of the dp[factors_of_x] . So in the same way , for each of its prime factor , dp[i]\u003dmax(dp[i],x) since x is the last element in the good subsequence and i is its prime factor and dp[i] \u003d length of current longest good subsequence . \u003c/p\u003e\u003cp\u003eNOTE — Since u are checking only factors till SQRT(x) , u need to do the above procedure for x/i where i is the prime factor . Why ? let x \u003d 15 . sqrt(x) \u003d 4 . U need to check and update for both 3 and 5 (15 \u003d 3 x 5) and 5 can also increase the length of the good subsequence .\u003c/p\u003e\u003c/div\u003e","tags":[]}}