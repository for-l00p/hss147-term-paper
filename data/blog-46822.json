{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1472428837,"rating":4,"authorHandle":"HardW3ll","modificationTimeSeconds":1472429543,"id":46822,"title":"\u003cp\u003eIndividual Contest #1 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem A Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThe problem is a basic dynamic programming problem. Let\u0027s define dp[i][j] as the minimum number of operations to make the array starting from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e non-decreasing if the last element was \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e can equal \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eComplexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3e/d2/3ed22e75be51c52576272f5f57ad4ed5cfeee131.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem B Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eLet\u0027s keep a set of the current solution. If we can afford the next element then add it to the set directly, otherwise, check the largest element in the set, if it\u0027s larger than the next and by removing it we can afford the next element then remove it and add the next element to the set.\u003c/p\u003e\u003cp\u003eComplexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/40/36/40360399e34b1fed92011d625f05b1198d167956.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem D Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eLet\u0027s iterate through all the subarrays of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e is the sum of all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Let\u0027s have a frequency array tells for each element how many times it appears in the current subarray. For getting the correct frequency array for the subarray starting at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e from the subarray starting at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/span\u003e we decrease one from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efreq\u003c/i\u003e[\u003ci\u003earr\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e - 1]]\u003c/span\u003e and add one to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efreq\u003c/i\u003e[\u003ci\u003earr\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + \u003ci\u003eL\u003c/i\u003e - 1]]\u003c/span\u003e. Let\u0027s have a value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebad\u003c/i\u003e\u003c/span\u003e represents the number of bad elements in the current subarray. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efreq\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e is currently equal to the required value and will change to become less than or larger than the required then we increase \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebad\u003c/i\u003e\u003c/span\u003e otherwise if it becomes equal to the required value, we decrease \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebad\u003c/i\u003e\u003c/span\u003e. If after the adjustments \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebad\u003c/i\u003e\u003c/span\u003e is zero then we have an answer.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTricky Case\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eA tricky case is when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e is larger than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3e/d2/3ed22e75be51c52576272f5f57ad4ed5cfeee131.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem E Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eLet\u0027s solve the problem backwards. We have a string of gaps and we want to generate the string such that each operation is adding a substring with no gaps in between. Let\u0027s start with the original string, in each step let\u0027s take the leftmost substring of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e that satisfies the constraints in the problem and then remove it from the string, select another substring and so on. Why this works? The proof is up to you.\u003c/p\u003e\u003cp\u003eWe can implement the previous algorithm in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3e/d2/3ed22e75be51c52576272f5f57ad4ed5cfeee131.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e using two pointers technique and a linked list to represent the string.\u003c/p\u003e\u003cp\u003eComplexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3e/d2/3ed22e75be51c52576272f5f57ad4ed5cfeee131.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem F Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eLet\u0027s fix the largest side in the triangle. It\u0027s known that in a non-degenerate triangle the largest side is less than the summation of the lengths of the other two sides. Now let\u0027s iterate through each pair of boxes, we get the largest side that is less than the fixed side in both the boxes using binary search and check if the sum of them is larger than the fixed side.\u003c/p\u003e\u003cp\u003eComplexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/87/e7871edcf71067af3b775ac11b0fcbac9529ce0a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThe solution can be improved using presort and pointers into \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/96/f0/96f030c595751e4f374c527688fc6ee55ee50f05.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem G Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eLet\u0027s define \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e as the minimum distance from node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e using even number of edges if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d 0\u003c/span\u003e or odd number of edges if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d 1\u003c/span\u003e. It can be filled using standard bfs. Now for a given query \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e, \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e ≥ \u003ci\u003ed\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e][\u003ci\u003ey\u003c/i\u003e][\u003ci\u003ed\u003c/i\u003e%2]\u003c/span\u003e then we can arrive at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e using d[x][y][d%2] edges and spend the remaining distance walking over an edge going forward and then backward to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, so the query is valid otherwise it\u0027s not.\u003c/p\u003e\u003cp\u003eDue to the memory limitation you\u0027ll need to answer the queries offline, for each node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e bfs from it and answer the queries that goes from it.\u003c/p\u003e\u003cp\u003eComplexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4f/22/4f22d1aed3ad784214f28dea2a8963f32e3c3881.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem H Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThe graph is special. It can be represented as multiple trees where in each tree the root is a loop. Now imagine solving the problem on a tree. The only difference will be in handling the root. It can be solved easily using some LCA tweaks.\u003c/p\u003e\u003cp\u003eComplexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e6/df/e6dfaf47c77664db8b53f668ee76e505353ed096.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}