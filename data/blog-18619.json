{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1434466886,"rating":11,"authorHandle":"xuanquang1999","modificationTimeSeconds":1435411737,"id":18619,"title":"\u003cp\u003eCodeforces Round #273 English Editorial (C is available now!)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello everyone. I have noticed the absence of round 273\u0027s editorial, so I decided to write one. This is the first time I write an editorial, so hope everyone like this!\u003c/p\u003e\u003cp\u003eI didn\u0027t know how to solve C and E yet, so it would be appreciated if someone help me with these problems.\u003c/p\u003e\u003cp\u003eAlso, how to use LaTex in codeforces? I want to use this so my editorial would be more clear to read.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUDP:\u003c/strong\u003e Actually, there\u0027s a (well-hidden) tutorial for this round, but it\u0027s written in Russian (with a English version using google translate in comment section). If you can read Russian, \u003ca href\u003d\"//codeforces.com/blog/entry/14307#comment-192751\"\u003eclick here\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUDP2:\u003c/strong\u003e Problem C is now available!\u003c/p\u003e\u003ch1\u003eA — Initial Bet\u003c/h1\u003e\u003cp\u003eSince the coin only pass from this player to other player, the coins sum of all player won’t change in the game. That mean, we’ll have \u003ccode\u003e5*b \u003d c1+c2+c3+c4+c5\u003c/code\u003e. We’ll put \u003ccode\u003esum \u003d c1+c2+c3+c4+c5\u003c/code\u003e. So, if \u003ccode\u003esum is divisible by b\u003c/code\u003e, the answer will be \u003ccode\u003esum/b\u003c/code\u003e. Otherwise, the answer doesn’t exist.\u003c/p\u003e\u003cp\u003eBe careful with the case \u003ccode\u003e0 0 0 0 0\u003c/code\u003e too, since \u003ccode\u003eb \u0026gt; 0\u003c/code\u003e, answer doesn’t exist in this case.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMy solution:\u003c/strong\u003e \u003ca href\u003d\"/contest/478/submission/11607374\" title\u003d\"Submission 11607374 by xuanquang1999\"\u003e11607374\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eComplexity: O(1)\u003c/em\u003e\u003c/p\u003e\u003ch1\u003eB — Random Teams\u003c/h1\u003e\u003cp\u003eIf a team have \u003ccode\u003ea\u003c/code\u003e participants, there will be \u003ccode\u003ea*(a-1)/2\u003c/code\u003e pairs of friends formed.\u003c/p\u003e\u003cp\u003eFor the minimum case, the participants should be unionly – distributed in all the team. More precisely, each team should not have more than one contestant compared to other team. Suppose we’ve already had \u003ccode\u003en div m\u003c/code\u003e contestant in each team, we’ll have \u003ccode\u003en mod m\u003c/code\u003e contestant left, we now should give each contestant left in first \u003ccode\u003en mod m\u003c/code\u003e teams.\u003c/p\u003e\u003cp\u003eFor example, with the test \u003ccode\u003e8 3\u003c/code\u003e, we’ll first give all team 8 div 3 \u003d 2 contestants, the result now is \u003ccode\u003e2 2 2\u003c/code\u003e. We’ll have 8 mod 3 \u003d 2 contestants left, we should each contestant in the first and the second team, so the final result is: \u003ccode\u003e3 3 2\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eThe maximum case is more simple, we should give only give one contestant in first \u003ccode\u003em-1\u003c/code\u003e teams, and give the last team all the contestant left. For example with above test, the result is \u003ccode\u003e1 1 6\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eSince number of the contestant in one team can be 10^9, the maximum numbers of pairs formed can be 10^18, so we should use \u003ccode\u003eint64\u003c/code\u003e (\u003ccode\u003elong long\u003c/code\u003e in c++) to avoid overflow.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMy solution:\u003c/strong\u003e \u003ca href\u003d\"/contest/478/submission/11607784\" title\u003d\"Submission 11607784 by xuanquang1999\"\u003e11607784\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eComplexity: O(1)\u003c/em\u003e\u003c/p\u003e\u003ch1\u003eC — Table Decorations\u003c/h1\u003e\u003cp\u003e\u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/spiderbatman\" title\u003d\"Expert spiderbatman\"\u003espiderbatman\u003c/a\u003e has a great idea for this problem. You can read his comment \u003ca href\u003d\"//codeforces.com/blog/entry/14282?#comment-192710\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThe order of the balloons isn\u0027t important, so instead or \u003ccode\u003er\u003c/code\u003e, \u003ccode\u003eg\u003c/code\u003e, \u003ccode\u003eb\u003c/code\u003e, we\u0027ll call them \u003ccode\u003ea[0]\u003c/code\u003e, \u003ccode\u003ea[1]\u003c/code\u003e, \u003ccode\u003ea[2]\u003c/code\u003e and sort them in ascending order. We\u0027ll now have \u003ccode\u003ea[0] \u0026lt;\u003d a[1] \u0026lt;\u003d a[2]\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eThere\u0027s two case:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003e2*(a[0]+a[1]) \u0026lt;\u003d a[2]\u003c/code\u003e. In this case, we can take \u003ccode\u003ea[0]\u003c/code\u003e sets of \u003ccode\u003e(1, 0, 2)\u003c/code\u003e and \u003ccode\u003ea[1]\u003c/code\u003e sets of \u003ccode\u003e(0, 1, 2)\u003c/code\u003e, so the answer is \u003ccode\u003ea[0]+a[1]\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003e2*(a[0]+a[1]) \u0026gt; a[2]\u003c/code\u003e. In this case, we can continuously take a set of two balloon from \u003ccode\u003ea[2]\u003c/code\u003e and a balloon from \u003ccode\u003emax(a[0], a[1])\u003c/code\u003e until a point that \u003ccode\u003ea[2] \u0026lt;\u003d max(a[0], a[1])\u003c/code\u003e. At this point, \u003ccode\u003emax(a[0], a[1])-a[2] \u0026lt;\u003d 1\u003c/code\u003e, and since \u003ccode\u003emax(a[0], a[1]) - min(a[0], a[1])  \u0026lt;\u003d 1\u003c/code\u003e too, \u003ccode\u003emax(a[0], a[1], a[2]) - min(a[0], a[1], a[2]) \u0026lt;\u003d 1\u003c/code\u003e. All we have to do left is take all possible \u003ccode\u003e(1, 1, 1)\u003c/code\u003e group left. Since we only take the balloons in group of 3, \u003ccode\u003e(a[0]+a[1]+a[2]) mod 3\u003c/code\u003e doesn\u0027t change, so there will be at most \u003ccode\u003e(a[0]+a[1]+a[2]) mod 3\u003c/code\u003e balloons wasted. We go back to the beginning now. The answer is \u003ccode\u003e(a[0]+a[1]+a[2]) div 3\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eMy solution:\u003c/strong\u003e \u003ca href\u003d\"/contest/478/submission/11614150\" title\u003d\"Submission 11614150 by xuanquang1999\"\u003e11614150\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eComplexity: O(1)\u003c/em\u003e\u003c/p\u003e\u003ch1\u003eD — Red-Green Towers\u003c/h1\u003e\u003cp\u003eFor more convenient, we’ll call a function \u003ccode\u003etrinum(x) \u003d (x*(x+1))/ 2\u003c/code\u003e, which is also the number of blocks needed to build a tower with height \u003ccode\u003ex\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eFirst, we’ll find h, the maximum height possible of the tower. We know that \u003ccode\u003eh \u0026lt;\u003d trinum(l+r)\u003c/code\u003e. Since \u003ccode\u003e(l+r) \u0026lt;\u003d 2*10^5\u003c/code\u003e, \u003ccode\u003eh \u0026lt;\u003d 631\u003c/code\u003e, so we can just use a brute-force to find this value.\u003c/p\u003e\u003cp\u003eNow, the main part of this problem, which can be solved by using dynamic programming. We’ll call \u003ccode\u003ef[ih, ir]\u003c/code\u003e the number of towers that have height \u003ccode\u003eih\u003c/code\u003e, can be built from \u003ccode\u003eir\u003c/code\u003e red block and \u003ccode\u003etrinum(ih)-ir\u003c/code\u003e green blocks. \u003c/p\u003e\u003cp\u003eFor each \u003ccode\u003ef[ih, ir]\u003c/code\u003e, there’s two way to reach it:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eAdd \u003ccode\u003eih\u003c/code\u003e red block. This can only be done if \u003ccode\u003eih \u0026lt;\u003d ir \u0026lt;\u003d min(r, trinum(ih))\u003c/code\u003e. In this case, \u003ccode\u003ef[ih, ir] \u003d f[ih, ir] + f[ih-1, ir-ih]\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eAdd \u003ccode\u003eih\u003c/code\u003e green block. This can only be done if \u003ccode\u003emax(0, trinum(ih)-g) \u0026lt;\u003d ir \u0026lt;\u003d min(r, trinum(ih-1))\u003c/code\u003e. In this case, \u003ccode\u003ef[ih, ir] \u003d f[ih, ir] + f[ih-1, ir-ih]\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThe answer to this problem is sum of all \u003ccode\u003ef[h, ir]\u003c/code\u003e with \u003ccode\u003e0 \u0026lt;\u003d ir \u0026lt;\u003d r\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eWe will probably get MLE now...\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMLE solution:\u003c/strong\u003e \u003ca href\u003d\"/contest/478/submission/11600887\" title\u003d\"Submission 11600887 by xuanquang1999\"\u003e11600887\u003c/a\u003e\u003c/p\u003e\u003cp\u003eHow to improve the memory used? We\u0027ll see that all \u003ccode\u003ef[ih]\u003c/code\u003e can only be affected by \u003ccode\u003ef[ih-1]\u003c/code\u003e, so we\u0027ll used two one-dimension arrays to store the result instead of a two-dimension array. The solution should get accepted now.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eAccepted solution:\u003c/strong\u003e \u003ca href\u003d\"/contest/478/submission/11600930\" title\u003d\"Submission 11600930 by xuanquang1999\"\u003e11600930\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eComplexity: O(r*sqrt(l+r))\u003c/em\u003e\u003c/p\u003e\u003ch1\u003eE — Wavy numbers\u003c/h1\u003e\u003cp\u003eUnfinished...\u003c/p\u003e\u003c/div\u003e","tags":[]}}