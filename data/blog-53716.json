{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1502028119,"rating":-4,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1502028119,"id":53716,"title":"\u003cp\u003eNotes on Codeforces Beta Round #66, A, B, C\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/73/problem/A\" title\u003d\"Codeforces Beta Round 66\"\u003e73A - The Elder Trolls IV: Oblivon\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI think there exists a general method to solve any n-dimensional cases. Suppose that we are given n elements, and we denote them as a[0], a[1],.... At first, we calculate k/n (integer division) and k%n. Then, we find out every a[i] such that a[i]-1â‰¤k/n, and denote the number of such elements as NUM. Furthwrmore, we update the following values:\u003c/p\u003e\u003cp\u003ek\u003dk-(a[i]-1), a[i]\u003d1, n\u003dn-NUM\u003c/p\u003e\u003cp\u003eWe repeat the above steps until at least one of the following conditions is satisfied:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003en\u003d0, i.e., no more a[i] can be cut.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003ek\u003d0, i.e., we have no more chances to cut any a[i].\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003ek/n\u003d0, i.e., we only need to deal with the left k%n chances.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eIf k/n\u003d0 but k%n\u0026gt;0, we can just find all the a[i] that satisfies a[i]\u0026gt;1, and update a[i]\u003da[i]-1 and k\u003dk-1. This operation stops if either k\u003d0 or no more such a[i] can be found.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/73/problem/B\" title\u003d\"Codeforces Beta Round 66\"\u003e73B - Need For Brake\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is a very \u0026quot;brain storm\u0026quot; problem. Although only m new scores are given, we can add n-m zeros to obtain a n-length sequence, denoted as S, which is further sorted in a decreasing order. We first try to find the worst rank. \u003c/p\u003e\u003cp\u003eIt is obvious that to obtain the worst rank, the target racer should add the minimum value of S. Then, we sort all the racers in a decreasing order, and denote the current rank of target racer as R. For the racers with better rank than R, we should assign the minimum values of S to them, too. Thus, we use a pointer R2 to denote the rightmost position of S, which is still not assigned to any racer. We scan the racers with rank worse than R, and calculate whether it is possible to achieve a better rank if the score with index R2 is added. If yes, we move on to check next racer and update R2\u003dR2-1. Otherwise, we only decrease R2 by one check again. During this process, we should record the number of racers which have better ranks than R, and this is just answer.\u003c/p\u003e\u003cp\u003eNow, we try to find the best rank. We give the target racer the highest score, and sort all the racers again in a decreasing order. For the racers who have better rank than R, we should assign the maximum scores to them, since they have already got better ranks even without any extra scores. We need to introduce another pointer R1 to denote the leftmost position of S which has not been assigned to any racer. Then, we scan the racers with worse ranks, and check whether it is possible to obtain a better rank than R if giving the score at R2. If yes, we in fact should give the score R1 rather than R2 to him, since \u0026quot;he is surely\u0026quot; to achieve a better rank, while updating R1++. If no, we should decrease R2 by one and check again. For this case, we should introduce a variable RES, which is used to denote the number of skipped R2. In fact, the previous opeartions under \u0026quot;YES\u0026quot; is not correct.... Instead, if yes, we should first check whether RES is larger than zero or not. If RES\u0026gt;0, we add R by one while decreasing RES by one; otherwise we update R1\u003dR1+1, and also add the number of racers who have better ranks by one.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/73/problem/C\" title\u003d\"Codeforces Beta Round 66\"\u003e73C - LionAge II\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is a standard DP problem. It suffices to use dp[n][z][k] to denote the maximum value under the state of \u0026quot;dealing with the n-th character in the given string, changing this letter to \u0027z\u0027, the number of changed letters being no larger than k\u0026quot;. The updating formula is\u003c/p\u003e\u003cp\u003e1) z\u003ds[n], dp[n][z][t]\u003dmax(all z\u0027, dp[n][z\u0027][t]+weight[z\u0027][z])\u003c/p\u003e\u003cp\u003e2) z!\u003ds[n], dp[n][z][t]\u003dmax(all z\u0027, dp[n][z\u0027][t-1]+weight[z\u0027][z])\u003c/p\u003e\u003c/div\u003e","tags":[]}}