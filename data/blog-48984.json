{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1481386214,"rating":0,"authorHandle":"BigBag","modificationTimeSeconds":1481389418,"id":48984,"title":"\u003cp\u003eСуффиксный массив\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eСуффиксным массивом для строки \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e называется лексиграфически отсортированный массив \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e ее суффиксов. Например, для строки \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e \u003d \u003ci\u003eaacba\u003c/i\u003e\u003c/span\u003e, суффиксный массив будет следующим : a, aacba, acba, ba, cba. То есть \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e \u003d [4, 0, 1, 3, 2]\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eПостроение суффиксного массива :\u003c/p\u003e\u003cp\u003eПусть изначально \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e \u003d [0, 1, ..., \u003ci\u003en\u003c/i\u003e - 1]\u003c/span\u003e. Тогда самый простой способ построения суффиксного массива следующий : \u003c/p\u003e \u003cpre\u003e\u003ccode\u003esort(p, p + n, cmp);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eАссимптотика \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1d/62/1d626cb3677ecd02756a73c5aeeea67444eaaba0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e время работы функции cmp.\u003c/p\u003e\u003cp\u003eТеперь опишем различные варианты функции cmp :\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e1)\u003c/strong\u003e Посимвольное сравнивание двух суффиксов :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ebool cmp(int a, int b) {\n    while (a \u0026lt; s.length() \u0026amp;\u0026amp; b \u0026lt; s.length() \u0026amp;\u0026amp; s[a] \u003d\u003d s[b]) {\n        ++a;\n        ++b;\n    }\n    if (a \u0026lt; s.length() \u0026amp;\u0026amp; b \u0026lt; s.length()) {\n        return s[a] \u0026lt; s[b];\n    }\n    return a \u0026gt; b;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗаметим, что в худшем случае, время работы данной функции будет \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7f/c5/7fc5d94dab3319a32c483b7814c0d1a94f87195d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, однако на рандомных тестах данный способ построения суффиксного массива будет самым быстрым.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2)\u003c/strong\u003e Использование хешей. Заметим что для того, чтобы сравнить две строки, достаточно сравнить первый символ, в котором они отличаются. Найти этот символ можно бинарным поиском.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ebool cmp(int a, int b) {\n    int l \u003d -1, r \u003d n - max(a, b);\n    while (r - l \u0026gt; 1) {\n        int mid \u003d (l + r) / 2;\n        if (get_hash(a, a + mid) \u003d\u003d get_hash(b, b + mid)) {\n            l \u003d mid;\n        } else {\n            r \u003d mid;\n        }\n    }\n    if (r \u003d\u003d n - max(a, b)) {\n        return a \u0026gt; b;\n    }\n    return s[a + r] \u0026lt; s[b + r];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПри такой реализации, асимптотика работы функции \u003ccode\u003ecmp\u003c/code\u003e \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3d/69/3d69cddefba4111def8d5f0157077b36e0fab174.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, следовательно время построения суффиксного массива \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/27/b4/27b472475f8c3b9c6063ec806456c5ab944f34be.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, что уже является довольно хорошей оценкой.\u003c/p\u003e\u003cp\u003eОднако, существует алгоритм работающий за \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8a/a8/8aa86cc0989251e7790df7cd85aba1293208cd85.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. С ним вы можете ознакомиться по \u003ca href\u003d\"http://e-maxx.ru/algo/suffix_array\"\u003eссылке\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eОсновное применение : \u003cstrong\u003eнахождение наибольшего общего префикса любых двух подстрок\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eДля этого построим массив \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elcp\u003c/i\u003e\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elcp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e длина наибольшего общего префикса суффиксов \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1]\u003c/span\u003e. Посмотрим, как с помощью этой информации можно находить \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elcp\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e наибольший общий префикс любых двух суффиксов \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. Найдем индексы этих суффиксов в массиве \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e. Т.е. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e1] \u003d \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e2] \u003d \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. Тогда нетрудно заметить, что \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elcp\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e) \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003elcp\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e]), \u003ci\u003ek\u003c/i\u003e \u003d \u003ci\u003ek\u003c/i\u003e1...\u003ci\u003ek\u003c/i\u003e2 - 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eЧтобы построить массив \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elcp\u003c/i\u003e\u003c/span\u003e, можно использовать все тот-же метод с бинарным поиском и хешами. Теперь, если на массиве \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elcp\u003c/i\u003e\u003c/span\u003e, построить SparseTable, мы сможем находить \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elcp\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e за \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/77/93/779302726b0f7eb1ffe589d79155df53ccde749e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eРешим следующую задачу : для заданной строки \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, найти количество ее различных подстрок.\u003c/p\u003e\u003cp\u003eПостроим массив \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elcp\u003c/i\u003e\u003c/span\u003e. Заметим, что любая подстрока \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e это префикс какого-то суффикса. Посмотрим, сколько новых подстрок добавит к ответу \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e-й суффикс. Нетрудно заметить, что это все префиксы, кроме тех, что совпадают с префиксами предыдущего суффикса. Таким образом это количество равно \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ep\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] - \u003ci\u003elcp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e - 1]\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ep\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e это длина текущего суффикса).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадачи на эту тему :\u003c/strong\u003e \u003ca href\u003d\"//codeforces.com/group/JrUBa4QK0n/contest/100133\"\u003eТренировка №5\u003c/a\u003e :\u003c/p\u003e \u003cul\u003e   \u003cli\u003eA\u003c/li\u003e   \u003cli\u003eF\u003c/li\u003e   \u003cli\u003eI\u003c/li\u003e   \u003cli\u003eH\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e\u003ca href\u003d\"https://www.hackerrank.com/contests/world-codesprint-6/challenges/functional-palindromes\"\u003eFunctional Palindroms\u003c/a\u003e, \u003ca href\u003d\"https://www.hackerrank.com/contests/world-codesprint-5/challenges/challenging-palindromes\"\u003eBuild a Palindrom\u003c/a\u003e, \u003ca href\u003d\"//codeforces.com/contest/524/problem/F\"\u003eСкобочная последовательность\u003c/a\u003e, \u003ca href\u003d\"//codeforces.com/contest/452/problem/E\"\u003eТри строки\u003c/a\u003e, \u003ca href\u003d\"//codeforces.com/contest/547/problem/E\"\u003eМайк и друзья\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e","tags":[]}}