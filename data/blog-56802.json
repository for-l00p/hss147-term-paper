{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1514723633,"rating":0,"authorHandle":"toxzi","modificationTimeSeconds":1514723877,"id":56802,"title":"\u003cp\u003eТеоретический материал по графам\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003eТеория\u003c/h4\u003e\u003cp\u003eГраф G — это упорядоченная пара G:\u003d(V,E), где V — множество вершин, а E — множество ребер графа.\u003c/p\u003e\u003cp\u003eГрафы бывают \u003cstrong\u003eориентированные\u003c/strong\u003e и \u003cstrong\u003eнеориентированные\u003c/strong\u003e. В неориентированном графе, если между двумя вершинами существует ребро, то по нему можно ходить \u003cstrong\u003eв обоих направлениях\u003c/strong\u003e, например, если есть ребро из вершины 1 в вершину 2, то мы можем прийти из вершины 1 в 2 и наоборот. В ориентированном графе, наоборот, по ребру можно идти \u003cstrong\u003eтолько в одном направлении\u003c/strong\u003e, например, если есть ребро из вершины 5 в вершину 7, то мы можем пойти из вершины 5 в вершину 7, но из вершины 7 в вершину 5 не можем. \u003c/p\u003e\u003cp\u003eВ неориентированном графе \u003cstrong\u003eкомпонентой связности\u003c/strong\u003e называют некоторое множество вершин графа такое, что для любых двух вершин из этого множества существует путь из одной в другую, и не существует пути из вершины этого множества в вершину не из этого множества. Неориентированный граф называют связным, если у него \u003cstrong\u003eровно одна\u003c/strong\u003e компонента связности, и несвязным если у него \u003cstrong\u003eбольше одной\u003c/strong\u003e компоненты связности.\u003c/p\u003e\u003cp\u003eПуть в графе — это последовательность ребер, такая, что конец одного ребра является началом другого ребра. Например, если в неориентированном графе есть ребра между вершинами 1 и 2, 2 и 3, 3 и 4, то в нем есть следующие пути: 1-2-3-4, 1-2-3, 1-2, 2-3-4, 2-3, 3-4, 4-3-2-1, 4-3-2, 4-3, 3-2-1, 3-2, 2-1.\u003c/p\u003e\u003cp\u003eЦиклом в графе называют такой путь, что если мы начнем его в какой-то вершине, то мы снова попадем в эту вершину. Граф, в котором нет циклов называют \u003cstrong\u003eациклическим\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eГраф называется \u003cstrong\u003eдеревом\u003c/strong\u003e, если он связный и не содержит циклов. Иными словами, граф из n вершин называется деревом, если он связный и в нем \u003cstrong\u003eровно\u003c/strong\u003e n — 1 ребро.\u003c/p\u003e\u003cp\u003eГрафы бывают \u003cstrong\u003eвзвешенные\u003c/strong\u003e и \u003cstrong\u003eневзвешенные\u003c/strong\u003e. В взвешенном графе у ребер есть свой вес (например, стоимость проезда между двумя городами (вершинами)). В невзвешенном графе считают, что вес ребер равен единице.\u003c/p\u003e\u003ch4\u003eПредставление графов\u003c/h4\u003e\u003cp\u003eГрафы можно представлять в виде матрицы смежности \u003cem\u003ea[n][n]\u003c/em\u003e, где n — количество вершин в графе. Тогда если существует ребро между вершинами \u003cem\u003eu\u003c/em\u003e и \u003cem\u003ev\u003c/em\u003e, то \u003cem\u003ea[u][v] \u003d 1\u003c/em\u003e. Если граф взвешенный, то вместо 1, можно записать вес ребра. Матрицы смежности можно использовать, когда количество вершин в графе немного, потому что, чтобы хранить матрицу нужно \u003cem\u003eО(n*n)\u003c/em\u003e памяти.\u003c/p\u003e\u003cp\u003eДругой способ представления графов — это списки смежности. Список смежности для вершины \u003cem\u003eu\u003c/em\u003e содержит вершины, которые достижимы из этой вершины. Так как для каждой вершины мы храним только те вершины, которые из нее достижимы, то в сумме мы используем \u003cem\u003eО(m)\u003c/em\u003e памяти, где m — количество ребер в графе.\u003c/p\u003e\u003ch4\u003eРабота с графами в С++\u003c/h4\u003e\u003cp\u003eГраф, представленный матрицей смежности:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint n; //n - количество вершин в графе\ncin \u0026gt;\u0026gt; n;\nint a[1000][1000]; //матрица смежности графа\nfor(int i \u003d 0; i \u0026lt; n; i++){\n    for(int j \u003d 0; j \u0026lt; n; j++){\n        cin \u0026gt;\u0026gt; a[i][j]; //считываем граф, представленный матрицей смежности\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТакже граф, может задаваться количеством вершин и списком ребер. Граф, представленный списками смежности:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint n, m; //n - количество вершин в графе, m - количество ребер в графе\nvector\u0026lt;int\u0026gt; g[100000]; //граф, представленный списками смежности\ncin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\nfor(int i \u003d 0; i \u0026lt; m; i++){\n    int u, v;\n    cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v;\n    g[u].push_back(v); //добавляем ребро из вершины u в вершину v\n    g[v].push_back(u); //если граф неориентированный, то также добавляем ребро из v в u\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eСайт с задачами на графы: \u003ca href\u003d\"http://informatics.mccme.ru/course/view.php?id\u003d6\"\u003ehttp://informatics.mccme.ru/course/view.php?id\u003d6\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}