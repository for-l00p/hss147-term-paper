{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1500390092,"rating":0,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1500390092,"id":53359,"title":"\u003cp\u003eNotes on Manthan 2011, A, B, D (Longest Decreasing Sub-array)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/67/problem/A\" title\u003d\"Manthan 2011\"\u003e67A - Partial Teacher\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is a very tricky problem... For instance, given RRL, my first solution will output 1 2 3 2, however it is obvious that a better sequence 1 2 3 1 exists. \u003c/p\u003e\u003cp\u003eFor each integer, we have known that it must be at least 1. However, the \u0026quot;L\u0026quot; letters on its right side mean that it should be some larger integer. Thus, we should count the number of \u0026quot;L\u0026quot; on its right side until a \u0026quot;R\u0026quot; is met (note that we should continue if any \u0026quot;\u003d\u0026quot; is met but this is not counted) or arrive at the end, which is denoted as nL. Similarly, we count the number of \u0026quot;R\u0026quot; on its left side until a \u0026quot;L\u0026quot; is met or reach the starting position, which is denoted as nR. The value of this integer is thus max(nL, nR). \u003c/p\u003e\u003cp\u003eFor an intuitive understanding, nL implies that there are exactly nL integers on its right side, which are smaller, and thus it must be at least as large as nL.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/67/problem/B\" title\u003d\"Manthan 2011\"\u003e67B - Restoration of the Permutation\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe can check array b[ ] from left to right, and find the first element that is 0. Suppose that we are trying to restore a[i], and find b[j]\u003d0. It means that the number of integers to the left of \u0026quot;j\u0026quot; which are larger than \u0026quot;j+k\u0026quot; is zero (the indices are counted from 1). Thus, we can set a[i]\u003dj. Next, we should enumerate array b[ ] again, and for each b[j], if a[i] is no less than \u0026quot;j+k\u0026quot;, we should decrease b[j] by 1. The total complexity is O(N^2). \u003c/p\u003e\u003cp\u003eHowever, in fact, I do not know why the above algorithm works... i.e., why it will give the optimal answer...\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/67/problem/D\" title\u003d\"Manthan 2011\"\u003e67D - Optical Experiment\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI think this is a very nicely designed problem!! The solution turns out to be clear, if we replace the indices upside from left to right by 0,1,2,..., i.e., \u0026quot;remap\u0026quot; them to a naturally increasing order, while the indices downside should be \u0026quot;remapped\u0026quot; correspondingly. \u003c/p\u003e\u003cp\u003eAfter the above operations, we in fact have obtained two sequences, one of which is in an naturally increasing order, denoted as a[n] (a[1]\u003d1, a[2]\u003d2,...,a[n]\u003dn), while the other one can be viewed as a permutation sequence of the first one, denoted as p[n]. Suppose that rays with indices i\u0026lt;j\u0026lt;k (these indices are in a[n]) intersect with each other. This means that if b[x]\u003di, b[y]\u003dj, b[z]\u003dk, we must have x\u0026gt;y\u0026gt;z. In other words, we can always find some z\u0026lt;y\u0026lt;x so that \u003c/p\u003e\u003cp\u003eb[z]\u0026gt;b[y]\u0026gt;b[x]\u003c/p\u003e\u003cp\u003eIt can be seen that the original problem in fact has been converted to an equivalent one, which asks to find out the longest decreasing sub-array in array b[n]. One can find a lot of information about this classic and well investigated problem on the Internet. To avoid Time Limited Error, one should adopt the algorithm with complexity O(NlogN).\u003c/p\u003e\u003c/div\u003e","tags":[]}}