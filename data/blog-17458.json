{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1429301681,"rating":123,"authorHandle":"Zlobober","modificationTimeSeconds":1429392718,"id":17458,"title":"\u003cp\u003eРазбор VK Cup Round 2\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/532/problem/A\" title\u003d\"VK Cup 2015 - Round 2\"\u003e532A - Berland Miners\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eWe can add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e miners with height \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e and it won\u0027t affect answer. So we can assume that numbers of miners and caves are the same.\u003c/p\u003e\u003cp\u003eFor every cave let\u0027s define \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e as maximal possible height of miner working in cave \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e if we wouldn\u0027t change any cave. We can calculate it from root to leaves with line \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003efather\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLet\u0027s say we don\u0027t change anything. We will try to assign all workers if it\u0027s possible or to do the best possible assignment otherwise — the one where there are few free (not occupied) caves and they are high (value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is big). I will say later why we want them to be high. Formal definition (you don\u0027t have to read the next paragraph):\u003c/p\u003e\u003cp\u003eFor every assignment let\u0027s sort free caves by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. In the best assignment number of free caves is minimal possible. And for every position in such a list free cave in the best assignment has value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e not lower than in any other assignment. It can be proven that best possible assignment exists (it\u0027s not so obvious though).\u003c/p\u003e\u003cp\u003eHow to find the best possible assignment? Let\u0027s sort caves ascending by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and for every cave let\u0027s assign the tallest free miner who can work here. It will give us the best possibble assignment. Why? Let\u0027s say we\u0027ve just made first bad decision (different than in the best assignment). It doesn\u0027t make sense to leave a cave empty if we can assign here someone. So we put a worker somewhere and we won\u0027t be able to do assignment now (we assumed that we\u0027ve just made bad decision). From definition \u0026quot;we put here tallest possible miner\u0026quot; we know that we couldn\u0027t assign here taller guy. Maybe we want to assign here shorter miner and this \u0026quot;highest possible\u0026quot; goes somewhere else? But we can swap them and everything will be ok. So there remains last option: we don\u0027t want to put anyone here. But we will have to assign our guy to some higher cave so we can leave his destiny cave empty and put him here. To sum up, it\u0027s ok to assign highest possible free worker with iterating over caves sorted by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Almost the same sentences are the proof for other lemma:\u003c/p\u003e\u003cp\u003eIf we want to have few free (not assigned) miners and we want them to be short it\u0027s optimal to iterate somehow over caves and to assign the tallest possible free miner in every cave. It works for every order of iterating over caves. And every order gives us the same set of free miners (but not necessarily the same set of free caves).\u003c/p\u003e\u003cp\u003eWhy did we want free caves to be high? Because to assign everyone we must change height of cave not higher than the lowest free cave. Why? In short: otherwise that lowest free cave will remain free after running our assignment-algo (described above) on new tree. But we managed to find maximal possible height of lowest free cave. Let\u0027s call this value as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLIM\u003c/i\u003e\u003c/span\u003e. And we know minimal set of free miners.\u003c/p\u003e\u003cp\u003eChanging height of cave \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e to something bigger does something only when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e ≤ \u003ci\u003eLIM\u003c/i\u003e\u003c/span\u003e. And then in set of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e some changes happen. There were caves blocked before by cave \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e so they had \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. These caves will have bigger \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e so in set of values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e we have change e.g. from \u003cspan class\u003d\"tex-span\"\u003e{5, 5, 5}\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e{7, 10, 8}\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e was equal to \u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e). Let\u0027s throw out miners from caves with changed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (maybe some of these caves were empty anyway). If we can\u0027t assign free miners (we found them before) to new caves then assigning everything isn\u0027t possible. Otherwise it is — we assign them in these caves with changed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e and there are some threw out miners. But all of them were in caves with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e ≤ \u003ci\u003eLIM\u003c/i\u003e\u003c/span\u003e so they are not higher than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLIM\u003c/i\u003e\u003c/span\u003e. And we know that every free cave has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003efree\u003c/i\u003e\u003c/sub\u003e ≥ \u003ci\u003eLIM\u003c/i\u003e\u003c/span\u003e because \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLIM\u003c/i\u003e\u003c/span\u003e is height of lowest free cave. So we can put them there.\u003c/p\u003e\u003cp\u003eSolution is to find result with binary search and to answer question: can we assign miners to caves with changing one cave by at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e? With our assignment-algo we calculate optimal lowest free cave and set of free miners. Then for every cave we try to increase its height by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e if it had \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e not higher than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLIM\u003c/i\u003e\u003c/span\u003e. It\u0027s also important that checking change of every cave has amortized linear complexity. If increasing height of cave A affects \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e of cave \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e below then later changing height of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e does nothing — B is blocked by A anyway.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/532/problem/B\" title\u003d\"VK Cup 2015 - Round 2\"\u003e532B - Work Group\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eThis problem can be solved by using dynamic programming over subtrees of company hierarchy. Denote as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e][\u003ci\u003ee\u003c/i\u003e]\u003c/span\u003e maximum possible efficiency that can be obtained by taking several people from subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e so that pairity of their number is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e in order condition from statement is fullfilled for all already taken people. Then it is easy to calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e][\u003ci\u003ee\u003c/i\u003e]\u003c/span\u003e from values of children of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e by considering intermediate value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ee\u003c/i\u003e]\u003c/span\u003e — maximum possible efficiency that we can obtain by using first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e subtrees of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e with overall pairity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIt\u0027s important to not to forget that there are two cases: we may take \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e itself or we may decide to not take it. In first case it is important that all subtrees have overall even number of taken people. In the second case there is no such restriction.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/532/problem/C\" title\u003d\"VK Cup 2015 - Round 2\"\u003e532C - Board Game\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eWe will consider three cases:\u003c/p\u003e\u003cp\u003e1) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003emax\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e. In this case Polycarp can be in \u003cspan class\u003d\"tex-span\"\u003e(0, 0)\u003c/span\u003e after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e moves and Vasiliy will always be ,,behind\u0027\u0027. It\u0027s enough for Polycarp to make any move and he is always able to do it. It makes Polycarp closer to \u003cspan class\u003d\"tex-span\"\u003e(0, 0)\u003c/span\u003e and after Vasiliy\u0027s move we again have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003emax\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e condition fulfilled and in some moment Polycarp will reach \u003cspan class\u003d\"tex-span\"\u003e(0, 0)\u003c/span\u003e. It\u0027s impossible that Vasiliy wins because our condition would be unfulfilled.\u003c/p\u003e\u003cp\u003e2) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. In this scenario Polycarp must block Vasiliy somehow. He must make such a move that after any Vasiliy\u0027s response condition will be fulfilled again.\u003c/p\u003e \u003cul\u003e   \u003cli\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e \u0026gt; 0\u003c/span\u003e he goes to \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e - 1, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e \u0026gt; 0\u003c/span\u003e he goes to \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e - 1)\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eOtherwise he makes any move.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eWith this strategy Vasiliy is unable to get out of our new condition.\u003c/p\u003e\u003cp\u003e3) Otherwise we can consider any shortest path to \u003cspan class\u003d\"tex-span\"\u003e(0, 0)\u003c/span\u003e for Vasiliy. Lenght of it is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e. For any cell on this path Polycarp has greater distance than Vasiliy to it so he can\u0027t be there before Vasiliy and he can\u0027t block him. Vasiliy wins. Alternative explanation: after any possible Polycarp move Vasiliy can make a move that none of conditions (1) and (2) aren\u0027t fulfilled.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/532/problem/D\" title\u003d\"VK Cup 2015 - Round 2\"\u003e532D - Landmarks\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eFirst observation: column crashes only if distance between its neighbours is greater than \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e so it doesn\u0027t matter where exactly is this column. The only important thing is how far are left and right neighbour of it.\u003c/p\u003e\u003cp\u003eFor every column \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e let\u0027s calculate does there exist subset of columns on the left that everything is stable between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e and leftmost bearing column. If answer is yes then how close can be left neighbour of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e? Then we will know how far the right neighbour can be. We will use dynamic programming.\u003c/p\u003e\u003cp\u003eSlow approach: For every previous column let\u0027s check if it can be neighbours with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e. The closest column fulfilling this condition is best left neighbour of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFaster approach: Let\u0027s denote \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efar\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e as the biggest possible coordinate where right neighbour of column \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e can be. In our dp we need an extra stack with possible candidates for being left neighbour of new column. In this stack columns are sorted in ascending order by index (and coordinate) and in descending order by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efar\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e. For every new column we must remove from the top of stack columns which have too low \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efar\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e. Then last column on stack is the best left neighbour and we can calculate value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efar\u003c/i\u003e\u003c/span\u003e for current column. It is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e algorithm.\u003c/p\u003e\u003cp\u003eSome columns can\u0027t be connected with leftmost bearing column and for them we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efar\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d 0\u003c/span\u003e. If there exists column with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efar\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e not less than coordinate of rightmost bearing column then we don\u0027t have to add new column and answer is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eOk. Now let\u0027s run the same dp from right to the left. Some columns are connected with leftmost bearing column, some other columns with righmost one. And we will want to place new column somewhere between them. Brute force solution is to check every pair of columns and to say: we want these two columns to be neighbours of added column. With values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efar\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e calculated in dp we check if we can have such a situation and we eventually consider result to be half of a distance between these two columns.\u003c/p\u003e\u003cp\u003eHow to make this last part faster? We must create two stacks with best candidates for neighbours of new column. One stack with columns connected to the leftmost column, one with the ones connected to the rightmost one. On these stacks we can find answer with two pointers technique.\u003c/p\u003e\u003cp\u003eWhole solution is linear in time and memory.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/532/problem/E\" title\u003d\"VK Cup 2015 - Round 2\"\u003e532E - Correcting Mistakes\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSuppose that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e is obtained from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003c/span\u003e by deleteing the earlier symbol than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e. Then it is true that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e \u003d \u003ci\u003eA\u003c/i\u003e + \u003ci\u003ex\u003c/i\u003e + \u003ci\u003eB\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e + \u003ci\u003eC\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u003d \u003ci\u003eA\u003c/i\u003e + \u003ci\u003ex\u003c/i\u003e + \u003ci\u003eB\u003c/i\u003e + \u003ci\u003eC\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e \u003d \u003ci\u003eA\u003c/i\u003e + \u003ci\u003eB\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e + \u003ci\u003eC\u003c/i\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e are deleted symbols and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e are some (possibly, empty) strings.\u003c/p\u003e\u003cp\u003eLet\u0027s calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e as a longest common prefix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e as a longest common suffix. Remove both of them from strings. Now we now that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e are respectively the first letter of string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e and last letter of string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e. Remove them too. The only thing left is to check if remaining parts of strings are equal.\u003c/p\u003e\u003cp\u003ePerform such operation for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e and for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/532/problem/F\" title\u003d\"VK Cup 2015 - Round 2\"\u003e532F - Encoding\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eThere are two possible ideas for solving this task.\u003c/p\u003e\u003cp\u003eFix pair of letters \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. Replace all letters \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e with 1s and all remaining letters with 0s. Do the same for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e with string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e. By using KMP algorithm or Z-function determine all positions where string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e can be attached to string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e so there is a match. If such condition is fullfilled for pair (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e), and for pair (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e) then this position is a possible match position if we use pair (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e) and possibly some other pairs.\u003c/p\u003e\u003cp\u003eNow for each suitable position we need to check if letters can be distributed in pairs according to the information we know. This can be done in O(sigma) where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esigma\u003c/i\u003e \u003d 26\u003c/span\u003e — the size of the alphabet. So, this solution works in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e * \u003ci\u003esigma\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e + \u003ci\u003en\u003c/i\u003e * \u003ci\u003esigma\u003c/i\u003e) \u003d \u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e * \u003ci\u003esigma\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e. It fits in time limit if implementation is efficient enough.\u003c/p\u003e\u003cp\u003eAnother way is to perform such transformation with both strings that allows us to compare them up to letters renaming. Let\u0027s replace each letter with distance from it to the closes letter to the left from it that is the same (or with -inf if there is no such letter). Now for strings to be equal we just need to check that string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e matches the substring of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e in all positions except, possibly, first occurence of each letter in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e. This can be done by modified prefix-function or by hashing.\u003c/p\u003e\u003cp\u003eNow suppose we know that in some position string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e is the same as string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e up to renaming letters. It\u0027s not hard to determine the letter permutation for this renaming (by just checking what matches in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e with first occurence of each letter in string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e). Let\u0027s check that this permutation is a set of transpositions in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003esigma\u003c/i\u003e)\u003c/span\u003e. So, we have a solution in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e * \u003ci\u003esigma\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e","tags":["vk cup round 2 editorial"]}}