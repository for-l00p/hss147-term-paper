{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1480129844,"rating":0,"authorHandle":"Slamur","modificationTimeSeconds":1481111791,"id":48630,"title":"\u003cp\u003eБазовые структуры данных. Python\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eКроме знания о возможностях той или иной структуры хорошо бы знать, как использовать уже имеющуюся в языке её реализацию.\u003c/p\u003e\u003cp\u003eЯ разбил данную серию лекций по языкам программирования, начну я с рассказа структур в языке Python. \u003cbr /\u003e\u003c/p\u003e\u003ch4\u003e1) Массивы и списки.\u003c/h4\u003e\u003cp\u003eХотя в питоне есть отдельный класс массива, но при его рассмотрении я не увидел каких-то кардинальных отличий от питоновского списка — а то и лишние неудобства.\u003c/p\u003e\u003cp\u003eПоэтому далее везде массив и список будут синонимичными понятиями, относящимися к классу \u003cem\u003elist\u003c/em\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eСоздание списка.\u003c/strong\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eСписок можно создать:\u003c/p\u003e \u003col\u003e   \u003cli\u003eявно с помощью квадратных скобок [];\u003c/li\u003e   \u003cli\u003ec помощью функции \u003cem\u003elist\u003c/em\u003e, которая принимает в себя любой перечислимый набор значений;\u003c/li\u003e   \u003cli\u003eс помощью генератора списка — каждый элемент списка задается функцией (спасибо за информацию Андрею Клаузеру).\u003c/li\u003e \u003c/ol\u003e \u003cpre\u003e\u003ccode\u003e\t## Пустой список (следующие две строки одинаковы)\n\ta \u003d [] \n\ta \u003d list()\n\n\t## Список из явно заданных значений\t\n\t## list(1, 2, 3) нельзя - 1, 2, 3 являются тремя числами, а не набором чисел\n\tb \u003d [ 1, 2, 3 ] \n\t\n\t## А вот из строки можно создавать список символов (следующие две строки одинаковы)\n\tc \u003d [\u0027a\u0027, \u0027b\u0027, \u0027a\u0027]\n\tс \u003d list(\u0027aba\u0027)\n\t\n\t## Но такой вариант создания сделает список со строкой, не с ее отдельными символами\n\td \u003d [\u0027aba\u0027]\n\t\n\t## Списки могут содержать значения разных типов (даже другие списки)\n\te \u003d [1, \u0027b\u0027, [\u0027abc\u0027, 2]]\n\t\n\t## Чтобы скопировать список, нужно воспользоваться функцией list\n\t## Простое присваивание \u0027f \u003d e\u0027 копирует ссылку - в итоге вы получите два списка, которые будут меняться одновременно\n\tf \u003d list(e)\n\t\n\t## Синтаксис [value] * length - создает список длины length, каждое значение которого равно value.\n\t## В примере будет создан список [-1, -1, -1, -1, -1].\n\tg \u003d [-1] * 5 \n\t\n\t## P.S. на самом деле это две операции - создать список [value], а затем \u0026quot;умножить\u0026quot; его.\n\t## Но судя по моим проверкам это работает быстрее, чем length раз добавить элемент в список.\n\t\n\t## Генератор списка\n\t## Данный генератор создаст список из квадратов чисел на отрезке [2; 5)\n\th \u003d [x * x for x in range(2, 5)] ## h \u003d [4, 9, 16]\n\u003c/code\u003e\u003c/pre\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eРабота со списком.\u003c/strong\u003e\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003e\tarr \u003d [1, 7, 3, 6, 5]\n\t\n\t## Индексация производится оператором [], индексы начинаются с 0.\n\tx \u003d arr[3] ## x \u003d 6\n\t\n\t## Также поддерживается отрицательная индексация - с конца списка.\n\tarr[-2] \u003d 10 ## arr \u003d [1, 7, 3, 10, 5]\n\t\n\t## Для получения длины списка есть функция len.\t\n\tlen([1, 3, 5]) \u003d\u003d 3\n\t\n\t## Добавление производится командой append.\n\tarr \u003d [1, 7, 3, 6, 5]\n\tarr.append(10) ## arr \u003d [1, 7, 3, 6, 5, 10]\n\t\n\t## Также есть возможность добавить последовательность элементов командой extend.\n\t## Сравните результат операций\n\tarr \u003d [1, 7, 3, 6, 5]\n\tarr.append([0, 2]) ## arr \u003d [1, 7, 3, 6, 5, [0, 2]]\n\t\n\tarr \u003d [1, 7, 3, 6, 5]\n\tarr.extend([0, 2]) ## arr \u003d [1, 7, 3, 6, 5, 0, 2]\n\n\t## Удаление производится командой pop \n\t## (осторожно, работает за количество элементов, правее удаляемого).\n\tarr \u003d [1, 7, 3, 6, 5]\n\tarr.pop(2) ## arr \u003d [1, 7, 6, 5]\n\t\n\tarr \u003d [1, 7, 3, 6, 5]\n\t\n\t## меняет порядок элементов на обратный\n\tarr.reverse() ## arr \u003d [5, 6, 3, 7, 1]\n\t\n\t## сортирует элементы\n\tarr.sort() ## arr \u003d [1, 3, 5, 6, 7]\n\t\n\t## список можно разделить, присвоив каждому значению имя\n\tarr \u003d [1, 7, 3]\n\ta, b, c \u003d arr ## a \u003d 1, b \u003d 7, c \u003d 3\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e2) Cтек, очередь и двунаправленная очередь.\u003c/h4\u003e\u003cp\u003eВ python есть класс \u003cem\u003edeque\u003c/em\u003e, который можно использовать как все три структуры.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\t## для использования деки надо ее заимпортить из модуля collections\n\tfrom collections import deque\n\n\t## создание\n\td \u003d deque() ## пустая дека\n\td \u003d deque(\u0027abc\u0027) ## можно передать последовательность\n\n\t## добавлять/удалять с конца можно аналогично методам списка\n\td.append(\u0027d\u0027) ## [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027]\n\td.extend(\u0027ef\u0027) ## [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027, \u0027f\u0027]\n\td.pop() ## [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027]\n\t\n\t## также дека умеет быстро добавлять и удалять с начала (у списка с этим плохо)\n\td.appendleft(\u0027d\u0027) ## [\u0027d\u0027, \u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027]\n\td.extendleft(\u0027ef\u0027) ## [\u0027f\u0027, \u0027e\u0027, \u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027]\n\td.popleft() ## [\u0027e\u0027, \u0027d\u0027, \u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027]\n\n\t## длина получается также функцией len\n\tm \u003d len(d) ## m \u003d 7\n\t\n\t## reverse также есть у деки\n\td.reverse()\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e3) Очередь с приоритетами.\u003c/h4\u003e\u003cp\u003eВ python нет отдельного класса для priority queue, но есть методы для работы со списком как с кучей [\u003cem\u003eheap\u003c/em\u003e] (как вы помните, она лежит в основе стандартной очереди с приоритетами).\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\t## для использования функций heap надо их заимпортить из модуля heapq\n\tfrom heapq import *\n\t\n\t## куча создается из списка со значениями\n\tpq \u003d [3, 1, 2]\n\theapify(pq) ## сам heapify не возвращает список, он только меняет его\n\n\t## добавить элемент в очередь\n\theappush(pq, 2) ## теперь там две 2\n\n\t## достать минимум из очереди\n\tmin_value \u003d heappop(pq) ## min_value \u003d 1\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e4) Множество\u003c/h4\u003e\u003cp\u003eВ python нет сортированного множества, только на основе хеш-таблицы.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eСоздание множества.\u003c/strong\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eМножество можно создать:\u003c/p\u003e \u003col\u003e   \u003cli\u003eявно с помощью фигурных скобок {};\u003c/li\u003e   \u003cli\u003ec помощью функции \u003cem\u003eset\u003c/em\u003e, которая принимает в себя любой перечислимый набор значений.\u003c/li\u003e \u003c/ol\u003e \u003cpre\u003e\u003ccode\u003e\t## Пустое множество\n\t## a \u003d {} - некорректно (создаст словарь)\n\ta \u003d set()\n\n\t## Множество из явно заданных значений\t\n\t## set(1, 2, 3) нельзя - 1, 2, 3 являются тремя числами, а не набором чисел\n\tb \u003d { 1, 2, 3 }\n\t\n\t## А вот из строки можно создавать множество символов (следующие две строки одинаковы)\n\t## В итоге будет создано множество {\u0027a\u0027, \u0027c\u0027, \u0027b\u0027, \u0027d\u0027}\n\t## Обратите внимание на порядок - он не сохраняется.\n\tc \u003d { \u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027a\u0027, \u0027d\u0027}\n\tс \u003d set(\u0027abcad\u0027)\n\t\n\t## Но такой вариант создания сделает множество со строкой, не с ее отдельными символами\n\td \u003d  { \u0027abcad\u0027 }\n\t\n\t## Чтобы скопировать множество, нужно воспользоваться функцией set\n\t## Простое присваивание \u0027e \u003d d\u0027 копирует ссылку - в итоге вы получите два множества, которые будут меняться одновременно\n\te \u003d set(d)\n\u003c/code\u003e\u003c/pre\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eРабота со множеством.\u003c/strong\u003e\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003e\t## Для получения размера множества есть функция len.\t\n\tlen([1, 3, 5]) \u003d\u003d 3\n\t\n\t## Проверка на принадлежность элемента множеству выполняется оператором in\n\ts \u003d { 1, 7, 3, 6, 5 }\n\tif 3 in s:\n\t\tprint(\u0027Yes\u0027)\n\t\n\t## Добавление производится командой add.\n\ts \u003d { 1, 7, 3, 6, 5 }\n\ts.add(10) ## s \u003d {1, 7, 3, 6, 5, 10}\n\ts.add(3) ## s \u003d {1, 7, 3, 6, 5, 10} - каждый элемент один раз представлен\n\t\n\t## Удаление элемента из множества (если он там есть)\n\ts \u003d { 1, 7, 3, 6, 5 }\n\ts.discard(3) ## s \u003d {1, 7, 6, 5}\n\ts.discard(8) ## s \u003d {1, 7, 6, 5}\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e5) Словарь.\u003c/h4\u003e\u003cp\u003eКак и относительно множества, в python есть только словарь на основе хеш-таблицы.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eСоздание словаря.\u003c/strong\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eМножество можно создать:\u003c/p\u003e \u003col\u003e   \u003cli\u003eявно с помощью фигурных скобок {};\u003c/li\u003e   \u003cli\u003ec помощью функции \u003cem\u003edict\u003c/em\u003e, которая принимает в себя любой перечислимый набор значений.\u003c/li\u003e \u003c/ol\u003e \u003cpre\u003e\u003ccode\u003e\t## Пустой словарь\n\ta \u003d {}\n\ta \u003d dict()\n\n\t## Словарь из явно заданных соответствий\t\n\tb \u003d {\u0027abc\u0027: 1, \u0027def\u0027: 2}\n\tb \u003d dict(abc \u003d 1, def \u003d 2)\n\t\n\t## Словарь из пар, где первый элемент будет ключом, второй - значением\n\tb \u003d dict([(\u0027abc\u0027, 1), (\u0027def\u0027, 2)])\n\t\n\t## Чтобы скопировать словарь, нужно воспользоваться функцией dict\n\t## Простое присваивание \u0027c \u003d b\u0027 копирует ссылку - в итоге вы получите два словаря, которые будут меняться одновременно\n\tc \u003d dict(b)\n\u003c/code\u003e\u003c/pre\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eРабота со словарем.\u003c/strong\u003e\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003e\t## Для получения размера множества есть функция len.\t\n\td \u003d {\u0027abc\u0027: 1, \u0027def\u0027: 2}\n\tlen(d) \u003d\u003d 2\n\t\n\t## Обращение к значению по ключу делается квадратными скобками []\n\td[\u0027try\u0027] \u003d 6 ## d \u003d {\u0027abc\u0027: 1, \u0027def\u0027: 2, \u0027try\u0027: 6}\n\tx \u003d d[\u0027abc\u0027] ## x \u003d 1\n\t\n\t## Попытка получить значение по ключу, которого нет, закончится ошибкой\n\t## В таком случае лучше использовать метод get\n\t## y \u003d d[\u0027qwer\u0027] - error\n\ty \u003d d.get(\u0027qwer\u0027) ## y \u003d None\n\ty \u003d d.get(\u0027qwer\u0027, 0) ## y \u003d 0 - второй параметр - значение, которое возвращается вместо None\n\t\n\t## Удаление элемента\n\tz \u003d d.pop(\u0027try\u0027) ## z \u003d 6, d \u003d {\u0027abc\u0027: 1, \u0027def\u0027: 2}\n\t\n\t## Если ключа нет, то pop выбросит ошибку без второго параметра\n\t## z \u003d d.pop(\u0027qwer\u0027) - error\n\tz \u003d d.pop(\u0027qwer\u0027, 0) ## z \u003d 0, d \u003d {\u0027abc\u0027: 1, \u0027def\u0027: 2}\n\t\n\t## Доступны 3 вида итерации: по парам \u0026quot;ключ-значение\u0026quot;, по ключам, по значениям\n\td[\u0027qwer\u0027] \u003d 1\n\t\n\t## выведет \u0027abc2\u0027, \u0027def4\u0027, \u0027qwer2\u0027\n\tfor key, value in d.items():\n\t\tx \u003d value * 2\n\t\tprint(key + str(x))\n\t\n\t## выведет \u0027abcabc\u0027, \u0027defdef\u0027, \u0027qwerqwer\u0027\n\tfor k in d.keys():\n\t\tprint(k + k)\n\t\t\n\t## выведет 3, 6, 3\n\tfor v in d.values():\n\t\tprint(3 * v)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["самара","структуры данных","python 3"]}}