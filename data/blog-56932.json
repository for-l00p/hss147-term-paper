{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1515218968,"rating":66,"authorHandle":"remidinishanth","modificationTimeSeconds":1516683011,"id":56932,"title":"\u003cp\u003eScanf and non-standard input format [Tutorial for beginners]\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003eReading Integers until End of file:\u003c/h4\u003e \u003cpre\u003e\u003ccode\u003eint a[110];\nfor(i \u003d 0; scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i])!\u003dEOF; i++);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBecause scanf will return the total number of input successfully scanned.\u003c/p\u003e\u003ch4\u003eReading date\u003c/h4\u003e \u003cpre\u003e\u003ccode\u003eint day, month, year;\nscanf(\u0026quot;%d/%d/%d\u0026quot;, \u0026amp;month, \u0026amp;day, \u0026amp;year);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHelps when input is of format\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e01/29/64\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003eRead Binary string\u003c/h4\u003e \u003cpre\u003e\u003ccode\u003echar str[20];\nscanf(\u0026quot;%[01]s\u0026quot;, str);\nprintf(\u0026quot;%s\\n\u0026quot;, str);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e%[01]s\u003c/strong\u003e – Read only if you see 0’s and 1’s. Shorthand for matching characters in the seq [01] can also be extended for decimals using \u003cstrong\u003e%[0-9]s\u003c/strong\u003e. Similarly, \u003cstrong\u003e%[abc]s\u003c/strong\u003e – Read only if you see a, b, c. [...] read till these characters are found. \u003cstrong\u003e[^...]\u003c/strong\u003e read until these characters are not found.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003echar s[110];\nscanf(“%[^\\n]s”, s);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHere,we have \u003cstrong\u003e[^\\n]\u003c/strong\u003e. The not operator \u003cstrong\u003e(^)\u003c/strong\u003e is used on the character \u003cstrong\u003e\\n\u003c/strong\u003e, causes \u003cstrong\u003escanf\u003c/strong\u003e to read everything but the character \u003cstrong\u003e\\n\u003c/strong\u003e – which is automatically added when you press return after entering input.\u003c/p\u003e\u003ch4\u003eRead but donot store. (use * assignment suppression character)\u003c/h4\u003e \u003cpre\u003e\u003ccode\u003escanf(\u0026quot;%d %*s %d\u0026quot;, \u0026amp;a, \u0026amp;b);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe above segment can be used to read date format and do not store the month if the format is \u003cstrong\u003edd month yyyy (06 Jan 2018)\u003c/strong\u003e.Read the desired input, but do not store.\u003c/p\u003e\u003ch4\u003eTo read char\u003c/h4\u003e \u003cpre\u003e\u003ccode\u003echar c;\nscanf(\u0026quot;%*[ \\t\\n]%c\u0026quot;,\u0026amp;c);\n\u003c/code\u003e\u003c/pre\u003e \u003cpre\u003e\u003ccode\u003escanf(“%2d”, \u0026amp;x);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn this example we have, a number located between the \u003cstrong\u003e%\u003c/strong\u003e and \u003cstrong\u003ed\u003c/strong\u003e which in this case is 2. The number determines the number of integers our variable input (of integer type) will read. So if the input was “3222”, our variable would only read “32”.\u003c/p\u003e\u003ch4\u003eEnd of File\u003c/h4\u003e \u003cpre\u003e\u003ccode\u003ewhile (scanf() !\u003d EOF){\n   //do something\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003eExample from CP1\u003c/h4\u003e\u003cp\u003eTake this problem with a non-standard input format: the first line of input is an integer N. This is followed by N lines, each starting with the character ‘0’, followed by a dot ‘.’, then followed by an unknown number of digits (up to 100 digits), and finally terminated with three dots ‘...’.\u003c/p\u003e\u003ch4\u003eInput:-\u003c/h4\u003e \u003cpre\u003e\u003ccode\u003e 3\n 0.1227...\n 0.517611738...\n 0.7341231223444344389923899277...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOne possible solution is as follows.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\nusing namespace std;\n\nint N;         // using global variables in contests can be a good strategy\nchar x[110];  // make it a habit to set array size a bit larger than needed\n\nint main() {\n  scanf(\u0026quot;%d\\n\u0026quot;, \u0026amp;N);\n  while (N--) {                  // we simply loop from N, N-1, N-2, ..., 0\n    scanf(\u0026quot;0.%[0-9]...\\n\u0026quot;, \u0026amp;x);   // `\u0026amp;\u0027 is optional when x is a char array\n                         // note: if you are surprised with the trick above,\n                      // please check scanf details in www.cppreference.com\n    printf(\u0026quot;the digits are 0.%s\\n\u0026quot;, x);\n} } // return 0;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ePlease feel free to add more in comments. Thank you for reading. \u003cstrong\u003eLearn and let learn\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003e[UPD]\u003c/p\u003e\u003ch4\u003eScanf with search sets\u003c/h4\u003e\u003cp\u003eWe used hyphen in format string: dd-mm-yyyy\u003c/p\u003e\u003cp\u003eIf we want more than one option: hyphen or slash: - or / then use search set %[-/]\u003c/p\u003e\u003cp\u003eStore the search string in a character variable\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;stdio.h\u0026gt;\nvoid main()\n{\n    int date, month, year;\n    char separator[2];\n    printf(\u0026quot;Input the date:\u0026quot;);\n    scanf(\u0026quot;%d%[-/]%d%[-/]%d\u0026quot;, \u0026amp;date, separator, \u0026amp;month, separator,\u0026amp;year);\n    printf(\u0026quot;Date: %d\\n\u0026quot;, date);\n    printf(\u0026quot;Month: %d\\n\u0026quot;, month);\n    printf(\u0026quot;Year: %d\\n\u0026quot;, year);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eExamples\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eInput the date:31-12-2013\nDate: 31\nMonth: 12\nYear: 2013\n*** another input ***\nInput the date:14/1/2014\nDate: 14\nMonth: 1\nYear: 2014\n*** another input ***\nInput the date:26/2-2014\nDate: 26\nMonth: 2\nYear: 2014\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe more simplified version using the above-mentioned assignment suppression operator.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003escanf(\u0026quot;%d%*[-/]%d%*[-/]%d\u0026quot;, \u0026amp;date, \u0026amp;month, \u0026amp;year);\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003eMore Info:\u003c/h4\u003e\u003cp\u003eThat the terminal is line-buffered means that it submits input to the program when a newline character is encountered. It is usually more efficient to submit blocks of data instead of one character at a time. It also offers the user a chance to edit the line before pressing enter.\u003c/p\u003e\u003cp\u003eThanks\u003c/p\u003e\u003ch4\u003eUPD 2\u003c/h4\u003e\u003ch4\u003estringstream\u003c/h4\u003e\u003cp\u003eYou are given a String Rectangle consists of four integers separated by single spaces, with no additional spaces in the string. The first two integers are the window coordinates of the top left pixel in the given rectangle, and the last two integers are the window coordinates of its bottom right pixel.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e     string rectangle;\n     cin\u0026gt;\u0026gt;rectangle;\n     istringstream ss(rectangle); \n     int x1,y1,x2,y2; \n     ss \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y2 \u0026gt;\u0026gt; x2;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThank you\u003c/p\u003e\u003c/div\u003e","tags":["i/o","scanf"]}}