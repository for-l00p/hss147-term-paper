{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1517649094,"rating":105,"authorHandle":"KokiYmgch","modificationTimeSeconds":1517649185,"id":57512,"title":"\u003cp\u003eHirschberg\u0027s Algorithm\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI wrote an article about Hirschberg\u0027s Algorithm\u003c/p\u003e\u003cp\u003eThis article was originally written in Japanese here \u003ca href\u003d\"http://www.learning-algorithms.com/entry/2018/01/22/024722\"\u003ehttp://www.learning-algorithms.com/entry/2018/01/22/024722\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirstly, look at the problem below.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://csacademy.com/contest/archive/task/classic-task/\"\u003ehttps://csacademy.com/contest/archive/task/classic-task/\u003c/a\u003e\u003c/p\u003e\u003cp\u003eSummary: You are given a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eH\u003c/i\u003e×\u003ci\u003eW\u003c/i\u003e\u003c/span\u003e grid which has a number in each cell. You want to go to the lower right cell from the upper left cell, and the score is the sum of the nunbers of the cells you pass through. Minimize the score, and show an example of the paths which satisfy the score. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eH\u003c/i\u003e ≤ 10000, \u003ci\u003eW\u003c/i\u003e ≤ 10000\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIf you just need to calculate the minimum score, you can solve this problem by a simple DP with the time complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eHW\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e) \u003d \u003ci\u003egrid\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e) + \u003ci\u003emin\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e - 1, \u003ci\u003ey\u003c/i\u003e), \u003ci\u003edp\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e - 1))\u003c/span\u003e\u003c/p\u003e\u003cp\u003eLet me show the grids on which the numbers and the DP values are written.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/8d/1e/8d1eb77fef767470a9ac72ecd52a8dc8390c3ae2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eIn this example, you found out that the minimum score is \u003cspan class\u003d\"tex-span\"\u003e29\u003c/span\u003e. Now, let\u0027s restore the path which gets the score. On DP grid that I showed above, you can restore DP from the last cell. When you are on a cell in the optimal path, the previous cell must be the cell which has the smaller DP value. For each cell, therefore, just write \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, if the nuber in the upper cell is smaller than that in the left cell, and \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, vice versa. In this way, you can get the grid like the left of the image, and the optimal path can be restored.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/b5/21/b5214410082cbd7f055a8a8816c36a9d8f8fd254.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eWhat I wrote above is simply implemented. It\u0027s a piece of cake!\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; dp(h, vector\u0026lt;long long\u0026gt; (w, INFL));\ndp[0][0] \u003d grid[0][0];\nfor (int i \u003d 0; i \u0026lt; h; i ++) {\n        for (int j \u003d 0; j \u0026lt; w; j ++) {\n                if (i - 1 \u0026gt;\u003d 0) dp[i][j] \u003d min(dp[i][j], (long long) grid[i][j] + dp[i - 1][j]);\n                if (j - 1 \u0026gt;\u003d 0) dp[i][j] \u003d min(dp[i][j], (long long) grid[i][j] + dp[i][j - 1]);\n        }\n}\nvector\u0026lt;bitset\u0026lt;10010\u0026gt;\u0026gt; restore(10010);\nfor (int i \u003d 0; i \u0026lt; h; i ++) {\n        for (int j \u003d 0; j \u0026lt; w; j ++) {\n                if (i \u003d\u003d 0) {\n                        restore[i][j] \u003d false;\n                } else if (j \u003d\u003d 0) {\n                        restore[i][j] \u003d true;\n                } else {\n                        restore[i][j] \u003d dp[i - 1][j] \u0026lt; dp[i][j - 1];\n                }\n        }\n}\nint y \u003d h - 1, x \u003d w - 1;\nstring ans \u003d \u0026quot;\u0026quot;;\nwhile (true) {\n        if (x \u003d\u003d 0 \u0026amp;\u0026amp; y \u003d\u003d 0) break;\n        if (restore[y][x]) {\n                ans +\u003d \u0026quot;D\u0026quot;;\n                y --;\n        } else {\n                ans +\u003d \u0026quot;R\u0026quot;;\n                x --;\n        }\n}\nreverse(ans.begin(), ans.end());\ncout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis problem seemed quite easy for many coders, but if you look at the problem statement again, you\u0027ll notice that the memory limit is unusual (it\u0027s emphasized though!). This memory limit implies that you can\u0027t even use memory space \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eHW\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIf you just want to know the minimum score, you can do the same DP by reusing the \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e DP arrays, but how do you restore the path?\u003c/p\u003e\u003cp\u003eOne possible solution is to restore the path from right side by reusing the \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e restoring arrays. However, since you can\u0027t save the DP values, every time you restore one step of the path, you need to do the DP from the left side again, which unfortunately requires the time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eHW\u003c/i\u003e * \u003ci\u003emin\u003c/i\u003e(\u003ci\u003eH\u003c/i\u003e, \u003ci\u003eW\u003c/i\u003e))\u003c/span\u003e. Not fast enough!\u003c/p\u003e\u003cp\u003eThis problem can be solved by Hirschberg\u0027s Algorithm! This algorithm makes it possible to restore this DP within space \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003emin\u003c/i\u003e(\u003ci\u003eH\u003c/i\u003e, \u003ci\u003eW\u003c/i\u003e))\u003c/span\u003e, and time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eHW\u003c/i\u003e)\u003c/span\u003e, respectively.\u003c/p\u003e\u003cp\u003eThis algorithm is based on Divide and Conquer Algorithm. Dividing the grids, Finding the path on each grid, and merging them.\u003c/p\u003e\u003cp\u003eLet\u0027s see this algorithm, using the same example above. First of all, divide the grid into two (almost) same size grids. According to the rule of the movement, \u003cstrong\u003ethere must be only one position, where you pass from the left grid to the right grid.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eIn order to find the position, you just do the \u003cstrong\u003eDP from the upper left to the lower right\u003c/strong\u003e on the left grid, while you do the \u003cstrong\u003eDP from the lower right to the upper left\u003c/strong\u003e on the right grid.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/f5/08/f508c308a605b70c88fc481200de8ae483b3f855.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eConsequently, at each position on the line of the division, the score was calculated from the upper left and from the lower right, thus, the position where these sums are the minimum, must be used. In this example, these sums are \u003cspan class\u003d\"tex-span\"\u003e35, 33, 29, 36\u003c/span\u003e from the top, which implies that the 3rd position from the top should be used.\u003c/p\u003e\u003cp\u003eThen, just repeat this process until all the movement is restored. The second time, you need to consider only the following part.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/ed/ff/edffdddab09b36e440c76a5360ee55ff3b455bfe.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThis means that you need to traverse only half part than you previously traversed. In the third time, you only need to check the \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/19/d4/19d400124326c44995a849507b45353fa030abad.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e part of the entire grid.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/f9/e9/f9e9fe4f9aec9a1574415da8d03d84b826f4324a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThe space complexity is obviously \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003emin\u003c/i\u003e(\u003ci\u003eH\u003c/i\u003e, \u003ci\u003eW\u003c/i\u003e))\u003c/span\u003e, while the time complexity is\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6f/d7/6fd7171700ef881c7efe9c85218e582e6736281a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eI hope you enjoyed this algorithm!\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;functional\u0026gt;\n#include \u0026lt;string\u0026gt;\nusing namespace std;\n\ntemplate\u0026lt;class T\u0026gt;\nvoid amin(T \u0026amp;a, T b) { if (a \u0026gt; b) a \u003d b; }\n\nint main() {\n        int h, w;\n        scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;h, \u0026amp;w);\n        vector\u0026lt;int\u0026gt; u(h), v(w);\n        for (int i \u003d 0; i \u0026lt; h; i ++) scanf(\u0026quot;%d\u0026quot;, \u0026amp;u[i]);\n        for (int i \u003d 0; i \u0026lt; w; i ++) scanf(\u0026quot;%d\u0026quot;, \u0026amp;v[i]);\n        function\u0026lt;long long (int, int)\u0026gt; get_val \u003d [\u0026amp;](int i, int j) {\n                return (long long) (u[i] + j + 1) ^ (long long) (v[j] + i + 1);\n        };\n        //Hirschberg\n        vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pos;\n        function\u0026lt;void (int, int, int, int)\u0026gt; Hirschberg \u003d [\u0026amp;](int li, int lj, int ri, int rj) {\n                int mid \u003d (lj + rj) / 2;\n                int height \u003d ri - li + 1;\n                if (rj - lj \u0026lt; 1) return;\n                if (height \u003d\u003d 1) {\n                        pos.emplace_back(mid, li);\n                        Hirschberg(li, lj, li, mid);\n                        Hirschberg(li, mid + 1, li, rj);\n                        return;\n                }\n                //left\n                int w_left \u003d mid - lj + 1;\n                vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; dp(2, vector\u0026lt;long long\u0026gt; (height));\n                dp[0][0] \u003d get_val(li, lj);\n                for (int i \u003d 1; i \u0026lt; height; i ++) {\n                        dp[0][i] \u003d dp[0][i - 1] + get_val(li + i, lj);\n                }\n                bool f \u003d 1;\n                for (int j \u003d 1; j \u0026lt; w_left; j ++) {\n                        for (int i \u003d 0; i \u0026lt; height; i ++) {\n                                dp[f][i] \u003d 1LL \u0026lt;\u0026lt; 60;\n                        }\n                        for (int i \u003d 0; i \u0026lt; height; i ++) {\n                                int val \u003d get_val(li + i, lj + j);\n                                amin(dp[f][i], dp[!f][i] + val);\n                                if (i - 1 \u0026gt;\u003d 0) amin(dp[f][i], dp[f][i - 1] + val);\n                        }\n                        f \u003d !f;\n                }\n                f \u003d !f;\n                vector\u0026lt;long long\u0026gt; m1(height);\n                for (int i \u003d 0; i \u0026lt; height; i ++) {\n                        m1[i] \u003d dp[f][i];\n                }\n                //right\n                int w_right \u003d rj - mid;\n                dp[0][0] \u003d get_val(ri, rj);\n                for (int i \u003d 1; i \u0026lt; height; i ++) {\n                        dp[0][i] \u003d dp[0][i - 1] + get_val(ri - i, rj);\n                }\n                f \u003d 1;\n                for (int j \u003d 1; j \u0026lt; w_right; j ++) {\n                        for (int i \u003d 0; i \u0026lt; height; i ++) {\n                                dp[f][i] \u003d 1LL \u0026lt;\u0026lt; 60;\n                        }\n                        for (int i \u003d 0; i \u0026lt; height; i ++) {\n                                long long val \u003d get_val(ri - i, rj - j);\n                                amin(dp[f][i], dp[!f][i] + val);\n                                if (i - 1 \u0026gt;\u003d 0) amin(dp[f][i], dp[f][i - 1] + val);\n                        }\n                        f \u003d !f;\n                }\n                f \u003d !f;\n                vector\u0026lt;long long\u0026gt; m2(height);\n                for (int i \u003d 0; i \u0026lt; height; i ++) {\n                        m2[height - i - 1] \u003d dp[f][i];\n                }\n                //\n                long long mi \u003d 1LL \u0026lt;\u0026lt; 60;\n                int res \u003d -1;\n                for (int i \u003d 0; i \u0026lt; height; i ++) {\n                        long long sum \u003d m1[i] + m2[i];\n                        if (sum \u0026lt; mi) {\n                                mi \u003d sum;\n                                res \u003d i;\n                        }\n                }\n                res +\u003d li;\n                pos.emplace_back(mid, res);\n                Hirschberg(li, lj, res, mid);\n                Hirschberg(res, mid + 1, ri, rj);\n        };\n        Hirschberg(0, 0, h - 1, w - 1);\n        //\n        sort(pos.begin(), pos.end());\n        int y \u003d 0, x \u003d 0;\n        string ans \u003d \u0026quot;\u0026quot;;\n        while (true) {\n                if (x \u003d\u003d w - 1) {\n                        while (y !\u003d h - 1) {\n                                ans +\u003d \u0026quot;D\u0026quot;;\n                                y ++;\n                        }\n                        break;\n                }\n                if (pos[x].second \u003d\u003d y) {\n                        x ++;\n                        ans +\u003d \u0026quot;R\u0026quot;;\n                } else {\n                        y ++;\n                        ans +\u003d \u0026quot;D\u0026quot;;\n                }\n        }\n        cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n        return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}