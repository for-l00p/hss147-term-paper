{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1412641644,"rating":1,"authorHandle":"Enchom","modificationTimeSeconds":1416256953,"id":14146,"title":"\u003cp\u003ePolly Training #1 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003e\u003cstrong\u003eA. Ангажименти\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eТова бе една то лесните задачи в темата. Решението на задачата се базира на известно greedy. Сортираме интервалите в нарастващ ред на крайщата им и започваме да взимаме отляво надясно първия интервал, който можем. Алгоритъмът е правилен понеже различните ангажименти са с еднакъв приоритет, тоест е най-изгодно да взимаме ангажиментите, които свършват най-рано, понеже така си оставяме повече свободно време завбъдеще.\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003eB. Роботи\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eТова бе най-трудната задача в темата. Задачата е от IOI 2013 и е решена от едва 47 човека, като аз \u003cstrong\u003eне\u003c/strong\u003e бях измежду тях.\u003c/p\u003e\u003cp\u003eПървото, което трябва да забележим е, че искат най-малко \u003cstrong\u003eвреме\u003c/strong\u003e. Това трябва да ни наведе на мисълта за двуично търсене по отговора. Нека използваме такъв подход. От тук нататъка ще опишем как да проверим дали за дадено фиксирано време \u003cstrong\u003eX\u003c/strong\u003e можем да разчистим всички играчки. Това значи, че всеки робот има възможност да вземе до X играчки.\u003c/p\u003e\u003cp\u003eДа разгледаме задачата само за единия тип роботчета. Нека имаме само слаби роботчета и игнорираме големината на роботите. Следното greedy решение е очевидно оптимално:\u003c/p\u003e\u003cp\u003eДа сортираме роботите по сила в нарастващ ред, и да сортираме играчките по тежест в нарастващ ред. При такава подредба ако някой робот може да вдига играчка на позиция K, той ще може да вдигне и тази на позиция K-1. Следователно ще записваме че i-тият робот може да вдига играчките в интервала \u003cstrong\u003e[1; Mi]\u003c/strong\u003e. Понеже роботите също са сортирани, то M[i]\u0026lt;\u003dM[i+1]. Знаейки това нека започнем от най-слабият робот. Той може да вдига играчки от интервала [1; M1]. Всички останали роботи също могат да вдигнат всяка от тези играчки, от което следва, че няма значение кои X от тях ще вдигне той. Използвайки това твърдение можем да вървим по сортираните роботи и да избираме по X произволни играчки, които да вдигне текущият робот. Това би било оптимално.\u003c/p\u003e\u003cp\u003eНека се върнем към задачата с два типа роботи. Да започнем разглеждайки само единият, слабият тип и прилагайки горното решение. Тук обаче не избираме произволни X играчки. Текущият робот не може да помогне на тези от своя вид, понеже те са по-силни от него, затова е оптимално той да вземе X-те \u003cstrong\u003eнай-големи\u003c/strong\u003e играчки, помагайки на вторият тип роботчета. Единствената промяна в решението е, че поддържаме кои играчки може да вдигне текущият робот в приоритетна опашка сортирана по големината им.\u003c/p\u003e\u003cp\u003eСлед като сме изпълнили това решение, то пускаме решението за един тип роботчета на малките роботи и останалите невзети играчки.\u003c/p\u003e\u003cp\u003eТова greedy води до оптимално разпределяне. Комбинирайки го с двуичното търсене получаваме обща сложност \u003cstrong\u003eO( N log N log MaxVal )\u003c/strong\u003e, където N е общият брой играчки и роботи.\u003c/p\u003e\u003cp\u003eЗа въпроси по решението ми пишете.\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003eC. Монети\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eТова бе най-лесната задача. Нейната цел бе някой незапознат с решението и да се опита да приложи greedy алгоритъм, който не би сработил. Решението се базира на просто динамично оптимиране.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eF[i] - най-малкият брой монети, с които можем да направим сума i.\nF[i] \u003d MIN( F[ i-C[1] ] , F[ i-C[2] ] ... ) + 1\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e\u003cstrong\u003eD. Кутии\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eРешението на задачата се базира отново на greedy решение. Кутиите се сортират в нарастващ ред по \u003cstrong\u003e(Si+Wi)\u003c/strong\u003e. След това в този ред се построява кула. Ако тя е стабилна се извежда YES, в противен случай не съществува стабилна кула.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eДоказателство на алгоритъма\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eДа забележим, че ако има няколко кутии, които могат да издържат всички останали върху себе си, то относителният ред, в който ги слагаме е без значение. Следва, че всяка кутия, която може да издържи всички други е подходяща за първа кутия.\u003c/p\u003e\u003cp\u003eНека кутия \u003cstrong\u003ek\u003c/strong\u003e е най-отдолу. За да издържа всички други то:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eSk \u0026gt;\u003d (W1+W2+W3+...+Wn) - Wk\nSk + Wk \u0026gt;\u003d (W1+W2+W3+...+Wn)\nПонеже дясната страна е константа за фиксиран вход, то тогава да изберем кутията максимизираща Sk+Wk е оптимално.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПо индукция следва, че да строим кулата по този начин е оптимално за задачата.\u003c/p\u003e\u003c/div\u003e","tags":[]}}