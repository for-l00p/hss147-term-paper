{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1497474288,"rating":0,"authorHandle":"SAeed","modificationTimeSeconds":1497474288,"id":52612,"title":"\u003cp\u003eSPU Contest #6\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e \u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214108/problem/Blue\"\u003eBlue — Vasya and String\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003e2 Pointers\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eFirst, let\u0027s define 2 variables:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003ea\u003c/code\u003e denoting the number of characters \u0026quot;a\u0026quot; in the current range.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003eb\u003c/code\u003e denoting the number of characters \u0026quot;b\u0026quot; in the current range.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eEach time we move the variable \u003ccode\u003eend\u003c/code\u003e one step forward, we increase either \u003ccode\u003ea\u003c/code\u003e or \u003ccode\u003eb\u003c/code\u003e, according to the character \u003ccode\u003es[end]\u003c/code\u003e. Now we have to find how much do we need to move the variable \u003ccode\u003estart\u003c/code\u003e forward?\u003c/p\u003e\u003cp\u003eIf the current range has \u003ccode\u003ea\u003c/code\u003e number of characters \u0026quot;a\u0026quot;, and \u003ccode\u003eb\u003c/code\u003e number of characters \u003ccode\u003eb\u003c/code\u003e, and we want to make all these characters of the same type, we either make all of them \u0026quot;a\u0026quot; (we do that by changing all the \u0026quot;b\u0026quot; characters into \u0026quot;a\u0026quot;), or we make all of them \u0026quot;b\u0026quot; (we do that by changing all the \u0026quot;a\u0026quot; characters into \u0026quot;b\u0026quot;. But which choice is better? Obviously, if \u003ccode\u003ea\u003c/code\u003e is smaller than \u003ccode\u003eb\u003c/code\u003e we will change all \u0026quot;a\u0026quot; into \u0026quot;b\u0026quot;, or if \u003ccode\u003eb\u003c/code\u003e is smaller than \u003ccode\u003ea\u003c/code\u003e we change all \u0026quot;b\u0026quot; into \u0026quot;a\u0026quot;.\u003c/p\u003e\u003cp\u003eNow back to the 2 pointers algorithm, how much do we need to move \u003ccode\u003estart\u003c/code\u003e forward? We will keep moving \u003ccode\u003estart\u003c/code\u003e forward until \u003ccode\u003emin(a, b)\u003c/code\u003e is smaller than or equal to \u003ccode\u003ek\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits\\stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long         ll;\n\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tint n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k;\n\tstring s; cin \u0026gt;\u0026gt; s;\n\tint start \u003d 0, ans \u003d 0, a \u003d 0, b \u003d 0;\n\tfor (int end \u003d 0; end \u0026lt; n; end++){\n\t\tif (s[end] \u003d\u003d \u0027a\u0027) a++;\n\t\telse b++;\n\t\twhile (min(a, b) \u0026gt; k){\n\t\t\tif (s[start] \u003d\u003d \u0027a\u0027) a--;\n\t\t\telse b--;\n\t\t\tstart++;\n\t\t}\n\t\tans \u003d max(ans, end - start + 1);\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214108/problem/Green\"\u003eGreen — Oath of the Night\u0027s Watch\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eBrute Force\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSort the given elements. Now the smaller element is in the cell \u003ccode\u003e0\u003c/code\u003e, and the greatest element is in the cell \u003ccode\u003en - 1\u003c/code\u003e. Iterate over all the elements. Each element is accepted if it is greater than the smaller element, and smaller than the greatest element.\u003c/p\u003e\u003cp\u003eThe main cause for WA was that the elements may not be distinct. For example:\u003c/p\u003e\u003cp\u003eInput: 2 2 2 2 2\u003c/p\u003e\u003cp\u003eCorrect output: 0\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits\\stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long         ll;\n\n\nint a[100100];\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tint n; cin \u0026gt;\u0026gt; n;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i];\n\tsort(a, a + n);\n\tint ans \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\tif (a[0] \u0026lt; a[i] \u0026amp;\u0026amp; a[n - 1] \u0026gt; a[i]) ans++;\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214108/problem/Purple\"\u003ePurple — Gotta Catch Em\u0027 All!\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAdHoc\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSince the order of the characters in string is not important, we just need to count the number of these characters \u003ccode\u003eB, u, l, b, a, s, r\u003c/code\u003e. Now the answer is the minimum between:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eNumber of \u003ccode\u003eB\u003c/code\u003e characters.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eNumber of \u003ccode\u003eu\u003c/code\u003e characters/ 2 (because there is 2 u\u0027s in Bulbasaur, so if we have 2 u\u0027s we can use them to form only one word, not two).\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eNumber of \u003ccode\u003el\u003c/code\u003e characters.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eNumber of \u003ccode\u003eb\u003c/code\u003e characters.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eNumber of \u003ccode\u003ea\u003c/code\u003e characters / 2 (for the same reason as mentioned above).\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eNumber of \u003ccode\u003es\u003c/code\u003e characters.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eNumber of \u003ccode\u003er\u003c/code\u003e characters.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits\\stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long         ll;\n\n\nint cnt[300];\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tstring s; cin \u0026gt;\u0026gt; s;\n\tfor (int i \u003d 0; i \u0026lt; (int)s.size(); i++) cnt[s[i]]++;\n\tint ans \u003d 1e9;\n\tans \u003d min(ans, cnt[\u0027B\u0027]);\n\tans \u003d min(ans, cnt[\u0027u\u0027] / 2);\n\tans \u003d min(ans, cnt[\u0027l\u0027]);\n\tans \u003d min(ans, cnt[\u0027b\u0027]);\n\tans \u003d min(ans, cnt[\u0027a\u0027] / 2);\n\tans \u003d min(ans, cnt[\u0027s\u0027]);\n\tans \u003d min(ans, cnt[\u0027r\u0027]);\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214108/problem/Red\"\u003eRed — Cards\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eDP\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSince the order of the colors in string in not important, we just need to calculate the number of red colors \u003ccode\u003er\u003c/code\u003e, the number of green colors \u003ccode\u003eg\u003c/code\u003e, and the number of blue colors \u003ccode\u003eb\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eNote that each of these variables will be at most 200, so we can make the following DP array: \u003cstrong\u003eDP[b][g][r]\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eEach time we should try the following moves:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eIf we have 2 or more blue colors replace them with a single blue color \u003ccode\u003eDP[b - 1][g][r]\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf we have 2 or more green colors replace them with a single green color \u003ccode\u003eDP[b][g - 1][r]\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf we have 2 or more red colors replace them with a single red color \u003ccode\u003eDP[b][g][r - 1]\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf we have at least 1 blue color and 1 green color replace them with a single red color \u003ccode\u003eDP[b - 1][g - 1][r + 1]\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf we have at least 1 blue color and 1 red color replace them with a single green color \u003ccode\u003eDP[b - 1][g + 1][r - 1]\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf we have at least 1 green color and 1 red color replace them with a single blue color \u003ccode\u003eDP[b + 1][g + 1][r - 1]\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThe only problem left, is what value should we store inside our \u003ccode\u003ememo\u003c/code\u003e array? Note that what we need to answer is the following questions:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eCan we end up with a single blue color?\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eCan we end up with a single green color?\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eCan we end up with a single red color?\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eHow can we store the answer to these questions inside our \u003ccode\u003ememo\u003c/code\u003e array? We can use a mask !!\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eIf the first bit in the mask is on \u003ccode\u003eif(mask \u0026amp; (1 \u0026lt;\u0026lt; 1))\u003c/code\u003e then we can end up with a single blue color.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf the second bit in the mask is on \u003ccode\u003eif(mask \u0026amp; (1 \u0026lt;\u0026lt; 2))\u003c/code\u003e then we can end up with a single green color.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf the third bit in the mask is on \u003ccode\u003eif(mask \u0026amp; (1 \u0026lt;\u0026lt; 3))\u003c/code\u003e then we can end up with a single red color.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eI know this technique is new to you, but try reading the code carefully and ask me if there is something that you can\u0027t understand.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eAnother Solution\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eWrite a recursive code that would try all the possible formations \u003ccode\u003eF(b, g, r)\u003c/code\u003e. Each time try all the moves described in the first solution. The only problem with this code is its huge complexity. If we created an array \u003ccode\u003evis[b][g][r]\u003c/code\u003e in order not to visit the same state more than once, our complexity would be n^3, which is acceptable.\u003c/p\u003e\u003cp\u003eI wrote a code for the first solution. Try writing a code for the second solution by your self.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n ^ 3)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits\\stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long         ll;\n\nint memo[201][201][201];\nint dp(int b, int g, int r){\n\tif (b \u003d\u003d 1 \u0026amp;\u0026amp; g \u003d\u003d 0 \u0026amp;\u0026amp; r \u003d\u003d 0) return (1 \u0026lt;\u0026lt; 1);\n\telse if (b \u003d\u003d 0 \u0026amp;\u0026amp; g \u003d\u003d 1 \u0026amp;\u0026amp; r \u003d\u003d 0) return (1 \u0026lt;\u0026lt; 2);\n\telse if (b \u003d\u003d 0 \u0026amp;\u0026amp; g \u003d\u003d 0 \u0026amp;\u0026amp; r \u003d\u003d 1) return (1 \u0026lt;\u0026lt; 3);\n\n\tint \u0026amp;ret \u003d memo[b][g][r];\n\tif (ret !\u003d -1) return ret;\n\n\tret \u003d 0;\n\tif (b \u0026gt;\u003d 2) ret |\u003d dp(b - 1, g, r);\n\tif (g \u0026gt;\u003d 2) ret |\u003d dp(b, g - 1, r);\n\tif (r \u0026gt;\u003d 2) ret |\u003d dp(b, g, r - 1);\n\tif (b \u0026gt; 0 \u0026amp;\u0026amp; g \u0026gt; 0) ret |\u003d dp(b - 1, g - 1, r + 1);\n\tif (b \u0026gt; 0 \u0026amp;\u0026amp; r \u0026gt; 0) ret |\u003d dp(b - 1, g + 1, r - 1);\n\tif (g \u0026gt; 0 \u0026amp;\u0026amp; r \u0026gt; 0) ret |\u003d dp(b + 1, g - 1, r - 1);\n\treturn ret;\n}\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tint n; cin \u0026gt;\u0026gt; n;\n\tstring s; cin \u0026gt;\u0026gt; s;\n\tint b \u003d 0, g \u003d 0, r \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\tif (s[i] \u003d\u003d \u0027B\u0027) b++;\n\t\telse if (s[i] \u003d\u003d \u0027G\u0027) g++;\n\t\telse r++;\n\t}\n\tmemset(memo, -1, sizeof memo);\n\tint ans \u003d dp(b, g, r);\n\tif (ans \u0026amp; (1 \u0026lt;\u0026lt; 1)) cout \u0026lt;\u0026lt; \u0027B\u0027;\n\tif (ans \u0026amp; (1 \u0026lt;\u0026lt; 2)) cout \u0026lt;\u0026lt; \u0027G\u0027;\n\tif (ans \u0026amp; (1 \u0026lt;\u0026lt; 3)) cout \u0026lt;\u0026lt; \u0027R\u0027;\n\tcout \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214108/problem/Yellow\"\u003eYellow — PolandBall and Game\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eGame\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s assume that you are playing the game against your friend, and now is your turn, what word would you say? Of course you will choose a word that both you and your friend have (a common word) and say it (because this way you will decrease the number of words your friend can say be 1, because you said one of his words). If there is no more common words left, you will say any word from your words.\u003c/p\u003e\u003cp\u003eWe can simply simulate this process.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n log(n))\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits\\stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long         ll;\n\nset\u0026lt;string\u0026gt; words;\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tint n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tint commonWords \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\tstring s; cin \u0026gt;\u0026gt; s;\n\t\twords.insert(s);\n\t}\n\tfor (int i \u003d 0; i \u0026lt; m; i++){\n\t\tstring s; cin \u0026gt;\u0026gt; s;\n\t\tif (words.count(s)) commonWords++;\n\t}\n\tint turn \u003d 0; // 0 means it\u0027s your turn, 1 means it\u0027s your friends turn\n\twhile (1){\n\t\tif (turn \u003d\u003d 0 \u0026amp;\u0026amp; n \u003d\u003d 0){ // if it\u0027s your turn, and you don\u0027t have words left, you lose\n\t\t\tcout \u0026lt;\u0026lt; \u0026quot;NO\u0026quot; \u0026lt;\u0026lt; endl;\n\t\t\tbreak;\n\t\t}\n\t\telse if (turn \u003d\u003d 1 \u0026amp;\u0026amp; m \u003d\u003d 0){ // if it\u0027s your friend\u0027s turn, and he doesn\u0027t have words left, you win\n\t\t\tcout \u0026lt;\u0026lt; \u0026quot;YES\u0026quot; \u0026lt;\u0026lt; endl;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (turn \u003d\u003d 0){ // if it\u0027s your turn, say a common word if you can, or if you can\u0027t the say any word\n\t\t\tif (commonWords \u0026gt; 0) commonWords--, n--, m--;\n\t\t\telse n--;\n\t\t}\n\t\telse{ // if it\u0027s your friend\u0027s turn he will also play by this strategy because it\u0027s optimal for him too\n\t\t\tif (commonWords \u0026gt; 0) commonWords--, n--, m--;\n\t\t\telse m--;\n\t\t}\n\t\tturn \u003d 1 - turn;\n\t}\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}