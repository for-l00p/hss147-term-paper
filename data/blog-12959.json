{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1404660581,"rating":53,"authorHandle":"xyz111","modificationTimeSeconds":1404689719,"id":12959,"title":"\u003cp\u003eCodeforces Round #254 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/contest/445/problem/A\"\u003eDIV2A-DZY Loves Chessboard\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eJust output the chessboard like this:\u003c/p\u003e\u003cp\u003eWBWBWBWB...\u003c/p\u003e\u003cp\u003eBWBWBWBW...\u003c/p\u003e\u003cp\u003eWBWBWBWB...\u003c/p\u003e\u003cp\u003e...\u003c/p\u003e\u003cp\u003eDon\u0027t forget to left \u0027-\u0027 as it is. The time complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003echeck the C++ code \u003ca href\u003d\"http://ideone.com/LQ465Z\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/contest/445/problem/B\"\u003eDIV2B-DZY Loves Chemistry\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eIt\u0027s easy to find that answer is equal to \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ev\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is the number of connected components.\u003c/p\u003e\u003cp\u003echeck the C++ code \u003ca href\u003d\"http://ideone.com/3U63Nu\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/contest/444/problem/A\"\u003eDIV1A-DZY Loves Physics\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eIf there is a connected induced subgraph containing more than \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e nodes with the maximum density. The density of every connected induced subgraph of it that contains only one edge can be represented as \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/31/50/31507be805b6a75b073c9d55408c0562c26c5dba.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e are the values of the two nodes linked by the edge. The density of the bigger connected induced subgraph is at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/40/be/40be978c509ea145a94ec50aba7c5233e1263c6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eIf \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d6/91/d691ca0ea9a0495df522d6e2aebbb3b3ae111883.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, and for every edge, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/44/4d/444dd6ff8e53fd10b36520101371a6037606f740.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Then we\u0027ll have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e + \u003ci\u003ev\u003c/i\u003e \u0026lt; \u003ci\u003eBc\u003c/i\u003e\u003c/span\u003e, and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a2/31/a23116585e7d5e38829dfd0940282de6bddd87d4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bf/cc/bfcc6f31fd477db183657463102fd1416f6c898a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, it leads to contradiction.\u003c/p\u003e\u003cp\u003eSo just check every single node, and every \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e nodes linked by an edge.\u003c/p\u003e\u003cp\u003eThe time complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003echeck the C++ code \u003ca href\u003d\"http://ideone.com/IuFRiu\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/contest/444/problem/B\"\u003eDIV1B-DZY Loves FFT\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eFirstly, you should notice that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e are given randomly.\u003c/p\u003e\u003cp\u003eThen there\u0027re many ways to solve this problem, I just introduce one of them.\u003c/p\u003e\u003cp\u003eThis algorithm can get \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e one by one. Firstly, choose an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e. Then check if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e equals to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e - 1, \u003ci\u003en\u003c/i\u003e - 2... \u003ci\u003en\u003c/i\u003e - \u003ci\u003es\u003c/i\u003e + 1\u003c/span\u003e. If none of is the answer, just calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e by brute force.\u003c/p\u003e\u003cp\u003eThe excepted time complexity to calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e is around\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/be/01/be015a4a5718e651d634c8886fe4d99870eb3a1d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003ewhere \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/13/f2/13f212d97722579eccb0e7d2cbcbc430f4c74722.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eJust choose an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to make the formula as small as possible. The worst excepted number of operations is around tens of million.\u003c/p\u003e\u003cp\u003echeck the C++ code \u003ca href\u003d\"http://ideone.com/vZrnSF\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/contest/444/problem/C\"\u003eDIV1C-DZY Loves Colors\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe only thing you need to notice is that if there are many continuous units with the same uppermost color, just merge them in one big unit. Every time painting continuous units, such big units will only increase by at most \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e. Then you can use STL set to solve it. But anyway, a segment tree is useful enough, check the C++ solution \u003ca href\u003d\"http://ideone.com/oJsR0W\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThe time complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/contest/444/problem/D\"\u003eDIV1D-DZY Loves Strings\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eWe can solve a subproblem in which all the query strings are characters only first. The problem becomes calculating the shortest substring containing two given characters.\u003c/p\u003e\u003cp\u003eIf character \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003c/span\u003e appears more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e times in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e, use brute force with time complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003eS\u003c/i\u003e|)\u003c/span\u003e to calculate all the queries containing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003c/span\u003e. Obviously, there are at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003eS\u003c/i\u003e| / \u003ci\u003eT\u003c/i\u003e)\u003c/span\u003e such \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eOtherwise, we consider two sorted sequences, just merge them with time complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eT\u003c/i\u003e)\u003c/span\u003e(Both of the two characters appear at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e times). Being merging, you can get the answer.\u003c/p\u003e\u003cp\u003eSo the complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eTQ\u003c/i\u003e + |\u003ci\u003eS\u003c/i\u003e|\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e / \u003ci\u003eT\u003c/i\u003e)\u003c/span\u003e. We can choose \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4a/88/4a883d70e65065942a8879969a03c77778d8a7ae.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, then the complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/99/95/99958e0401a703119ad2f6beb6b97bbb209246f4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eAnd short substring is almost the same with characters.\u003c/p\u003e\u003cp\u003eCheck the C++ code \u003ca href\u003d\"http://ideone.com/HB544x\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/contest/444/problem/E\"\u003eDIV1E-DZY Loves Planting\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eFirstly, use binary search. We need to determine whether the answer can be bigger than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. Then, every pair \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e must contain at least one edge which length is bigger than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. It\u0027s a problem like bipartite graph matching, and we can use maxflow algorithm to solve it.\u003c/p\u003e\u003cp\u003eWe create \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e nodes for every node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e of the original tree. We call one of the nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, and the other \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. And we need a source \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e and a terminal \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e. Link \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to every \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e with upper bound \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, and link \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e with upper bound \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Then if the path between node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e contains an edge with value larger than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e, link \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e with upper bound \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. This means they can match. Every time we build such graph, we must check \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e pairs of nodes, so number of edges of the network is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe can make it better. Consider the process of \\texttt{Divide and Conquer} of a tree, This algorithm can either based on node or edge. And The one based on edge is simpler in this problem. Now, there are two subtrees \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e on two sides, we record the maximum edge from every node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to the current edge we split, we call it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eMAXL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSuppose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (it is almost the same in contrast). We create two new nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e in the network to represent the two subtrees. Add edges \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eG\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e, ∞)\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e) and edges \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eG\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, ∞)\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e). If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eMAXL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u0026gt; \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e, we add an edge \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eG\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e, ∞)\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e is in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eMAXL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u0026gt; \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e, we add an edge \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eG\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e, ∞)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThen use maxflow algorithm. The number of nodes in the network is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e and the number of edges in the network is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e9/82/e9824f6612c4b83669d669fe6fd4d9e558305dfd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. So the total complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/45/43/4543de22ba8b5ff4d55fde0ecd26766a3e991a22.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e with really small constant.\u003c/p\u003e\u003cp\u003eCheck the C++ code \u003ca href\u003d\"http://ideone.com/MhtOXG\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThis is what I supposed DIV1-E will be. And thank \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/subscriber\" title\u003d\"Grandmaster subscriber\"\u003esubscriber\u003c/a\u003e for coming up with a really good algorithm with time complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003eα(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e \u003ca href\u003d\"/contest/444/submission/7025382\" title\u003d\"Submission 7025382 by subscriber\"\u003e7025382\u003c/a\u003e. And maybe others have the same idea. This is my mistake, and I feel sorry for not noticing that, I\u0027m too naive, and not good at solving problems. Please forgive me.\u003c/p\u003e\u003c/div\u003e","tags":[]}}