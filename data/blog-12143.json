{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1399129069,"rating":48,"authorHandle":"adamant","modificationTimeSeconds":1399281617,"id":12143,"title":"\u003cp\u003eManacher\u0027s algorithm and code readability\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi everyone again! Recently, solving the problem \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1937\"\u003e1937\u003c/a\u003e from Timus (by the way, I recommend it to you too! It is a great opportunity to improve yourself in string algorithms), I was faced with the necessity of finding all subpalindromes in the string. Experienced programmers already know that one of the best algorithms for this is Manacher\u0027s algo that allows you to get all subpalindromes in compressed form without any additional structures. The only problem — the algorithm is kinda hard to implement. That is, its idea is simple and straightforward, but the implementation usually are heaps of code to the widespread consideration of where to write +1, and where -1. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eFor those who do not know or do not remember, I will describe briefly the Manacher\u0027s algorithm. Conciseness in memory is achieved through the fact that we do not store the indices of palindromes, and for each item in the string we store the half of the length of the largest palindrome, for which item is central. If we are talking about palindromes of even length, we consider the central element to the right of exact center. \u003c/p\u003e\u003cp\u003eFurther, we keep the left and the right ends of the rightmost palindrome and, just as it done in the Z-function, we firstly try to initialize the value of the array at this point, using information that is already computed, and then we continue with naive algorithm. To be precise, we can initialize the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e from the point that is symmetric to it in the rightmost palindrome, i.e. from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e + (\u003ci\u003er\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e)]\u003c/span\u003e. If we talk about palindromes of even length (you already hate them just like me, right?), Then we are interested in the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e + (\u003ci\u003er\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e) + 1]\u003c/span\u003e. And yes, it is necessary not to forget that after initialization we should not have to go beyond the known part of the string, i.e. it is necessary to initialize with something that is not more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e ( or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e for palindromes of even length).\u003c/p\u003e\u003cp\u003eThat\u0027s how \u003ca href\u003d\"http://e-maxx.ru/algo/palindromes_count\"\u003ee-maxx\u003c/a\u003e offers to use Manacher\u0027s algo:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003evector\u0026lt;int\u0026gt; d1 (n);\nint l\u003d0, r\u003d-1;\nfor (int i\u003d0; i\u0026lt;n; ++i) {\n\tint k \u003d (i\u0026gt;r ? 0 : min (d1[l+r-i], r-i)) + 1;\n\twhile (i+k \u0026lt; n \u0026amp;\u0026amp; i-k \u0026gt;\u003d 0 \u0026amp;\u0026amp; s[i+k] \u003d\u003d s[i-k])  ++k;\n\td1[i] \u003d k--;\n\tif (i+k \u0026gt; r)\n\t\tl \u003d i-k,  r \u003d i+k;\n}\nvector\u0026lt;int\u0026gt; d2 (n);\nl\u003d0, r\u003d-1;\nfor (int i\u003d0; i\u0026lt;n; ++i) {\n\tint k \u003d (i\u0026gt;r ? 0 : min (d2[l+r-i+1], r-i+1)) + 1;\n\twhile (i+k-1 \u0026lt; n \u0026amp;\u0026amp; i-k \u0026gt;\u003d 0 \u0026amp;\u0026amp; s[i+k-1] \u003d\u003d s[i-k])  ++k;\n\td2[i] \u003d --k;\n\tif (i+k-1 \u0026gt; r)\n\t\tl \u003d i-k,  r \u003d i+k-1;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTwo almost similar pieces of code for palindromes of even and odd length. And, if my memory serves me, and it\u0027s still not fixed, they also contain an error (can you find it?)\u003c/p\u003e\u003cp\u003eA little thought and writing out some cases on a piece of paper, I was able to squeeze two separate pieces into one. At the same time, I tried to keep the maximum similarity with the Z-function algorithm.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; p(2,vector\u0026lt;int\u0026gt;(n,0));\n    for(int z\u003d0,l\u003d0,r\u003d0;z\u0026lt;2;z++,l\u003d0,r\u003d0)\n        for(int i\u003d0;i\u0026lt;n;i++)\n        {\n            if(i\u0026lt;r) p[z][i]\u003dmin(r-i+!z,p[z][l+r-i+!z]);\n            while(i-p[z][i]-1\u0026gt;\u003d0 \u0026amp;\u0026amp; i+p[z][i]+1-!z\u0026lt;n \u0026amp;\u0026amp; s[i-p[z][i]-1]\u003d\u003ds[i+p[z][i]+1-!z]) p[z][i]++;\n            if(i+p[z][i]-!z\u0026gt;r) l\u003di-p[z][i],r\u003di+p[z][i]-!z;\n        }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHowever, long enough string with while spoils the whole picture. I propose to fight with it like this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; p(2,vector\u0026lt;int\u0026gt;(n,0));\n    for(int z\u003d0,l\u003d0,r\u003d0;z\u0026lt;2;z++,l\u003d0,r\u003d0)\n        for(int i\u003d0;i\u0026lt;n;i++)\n        {\n            if(i\u0026lt;r) p[z][i]\u003dmin(r-i+!z,p[z][l+r-i+!z]);\n            int L\u003di-p[z][i], R\u003di+p[z][i]-!z;\n            while(L-1\u0026gt;\u003d0 \u0026amp;\u0026amp; R+1\u0026lt;n \u0026amp;\u0026amp; s[L-1]\u003d\u003ds[R+1]) p[z][i]++,L--,R++;\n            if(R\u0026gt;r) l\u003dL,r\u003dR;\n        }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs it seems to me, this is the most readable version of the code. And what do you think about this? How to implement Manacher\u0027s algo least painful? And in general, how do you solve the problem of finding all subpalindromes in the string? Share your ideas in the comments below :)\u003c/p\u003e\u003cp\u003eP.S. It looks like my English is especially poor in this entry. My apologies about it :(\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD:\u003c/strong\u003e \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/MikhailRubinchik\" title\u003d\"Master MikhailRubinchik\"\u003eMikhailRubinchik\u003c/a\u003e said in the comments on how to support arrays from Manacher\u0027s algorithm in online. \u003ca href\u003d\"http://ideone.com/AbA9Zu\"\u003eHere\u003c/a\u003e I put an example of the algorithm itself, with some modifications, which will be discussed below.\u003c/p\u003e\u003cp\u003eThe basic idea of ​​the algorithm: at any time we keep the center of the longest palindrome relating to the right end of the line. When we add character to the end, we have two options for what happens next:\u003c/p\u003e \u003col\u003e   \u003cli\u003eMain palindrome expands. Then we simply increase its radius value and return.\u003c/li\u003e   \u003cli\u003eMain palindrome not expands. This means that we will need to traverse an array forward to find new primary palindrome. Thus, each time a new cell initializing with number in the cell that is symmetrical to the center of the previous main palindrome. Once it turned out that we can extend the current palindrome, which means that it is leftmost of the related to the end of the string and then it will become the new main palindrome.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eNow about the changes in the code. First, were deleted the two empty characters that were inserted into the string at the begin. As it turned out, they are not necessary, however, but their addition to their complexity algorithm.\u003c/p\u003e\u003cp\u003eSecond, was added \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eget\u003c/i\u003e()\u003c/span\u003e. Mikhail mentioned in his comment about some problems with online. The problem was that, in any moment, we know only the final values ​​in the elements, which are earlier than the center of the main palindrome. However, you will notice that the values ​​after it, we can get in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e if we will refer to symmetric from the center of the main palindrome element.\u003c/p\u003e\u003c/div\u003e","tags":["string algorithms","subpalindromes","manacher algo"]}}