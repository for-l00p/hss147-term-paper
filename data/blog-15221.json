{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1418824615,"rating":63,"authorHandle":"zscoder","modificationTimeSeconds":1418824615,"id":15221,"title":"\u003cp\u003eThis guy got a bit too......hardcore?!\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/409/submission/6235741\" title\u003d\"Посылка 6235741 от OpalDshawn\"\u003e6235741\u003c/a\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e/** Micro Mezzo Macro Flation -- Overheated Economy ., Last Update: Feb. 12th 2013 **/ //{\n\n/** Header .. **/ //{\n#define LOCAL\n#include \u0026lt;functional\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;sstream\u0026gt;\n#include \u0026lt;iomanip\u0026gt;\n#include \u0026lt;numeric\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;bitset\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n#include \u0026lt;list\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;map\u0026gt;\n\nusing namespace std;\n\n#define REP(i, n) for (int i\u003d0;i\u0026lt;int(n);++i)\n#define FOR(i, a, b) for (int i\u003dint(a);i\u0026lt;int(b);++i)\n#define DWN(i, b, a) for (int i\u003dint(b-1);i\u0026gt;\u003dint(a);--i)\n#define REP_1(i, n) for (int i\u003d1;i\u0026lt;\u003dint(n);++i)\n#define FOR_1(i, a, b) for (int i\u003dint(a);i\u0026lt;\u003dint(b);++i)\n#define DWN_1(i, b, a) for (int i\u003dint(b);i\u0026gt;\u003dint(a);--i)\n#define REP_C(i, n) for (int n____\u003dint(n),i\u003d0;i\u0026lt;n____;++i)\n#define FOR_C(i, a, b) for (int b____\u003dint(b),i\u003da;i\u0026lt;b____;++i)\n#define DWN_C(i, b, a) for (int a____\u003dint(a),i\u003db-1;i\u0026gt;\u003da____;--i)\n#define REP_N(i, n) for (i\u003d0;i\u0026lt;int(n);++i)\n#define FOR_N(i, a, b) for (i\u003dint(a);i\u0026lt;int(b);++i)\n#define DWN_N(i, b, a) for (i\u003dint(b-1);i\u0026gt;\u003dint(a);--i)\n#define REP_1_C(i, n) for (int n____\u003dint(n),i\u003d1;i\u0026lt;\u003dn____;++i)\n#define FOR_1_C(i, a, b) for (int b____\u003dint(b),i\u003da;i\u0026lt;\u003db____;++i)\n#define DWN_1_C(i, b, a) for (int a____\u003dint(a),i\u003db;i\u0026gt;\u003da____;--i)\n#define REP_1_N(i, n) for (i\u003d1;i\u0026lt;\u003dint(n);++i)\n#define FOR_1_N(i, a, b) for (i\u003dint(a);i\u0026lt;\u003dint(b);++i)\n#define DWN_1_N(i, b, a) for (i\u003dint(b);i\u0026gt;\u003dint(a);--i)\n#define REP_C_N(i, n) for (int n____\u003d(i\u003d0,int(n));i\u0026lt;n____;++i)\n#define FOR_C_N(i, a, b) for (int b____\u003d(i\u003d0,int(b);i\u0026lt;b____;++i)\n#define DWN_C_N(i, b, a) for (int a____\u003d(i\u003db-1,int(a));i\u0026gt;\u003da____;--i)\n#define REP_1_C_N(i, n) for (int n____\u003d(i\u003d1,int(n));i\u0026lt;\u003dn____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____\u003d(i\u003d1,int(b);i\u0026lt;\u003db____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____\u003d(i\u003db,int(a));i\u0026gt;\u003da____;--i)\n\n#define ECH(it, A) for (__typeof(A.begin()) it\u003dA.begin(); it !\u003d A.end(); ++it)\n#define REP_S(i, str) for (char*i\u003dstr;*i;++i)\n#define REP_L(i, hd, nxt) for (int i\u003dhd;i;i\u003dnxt[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define DO(n) for ( int ____n ## __line__ \u003d n; ____n ## __line__ -- ; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define BSC(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) !\u003d T.end())\n#define SZ(A) int(A.size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair\u0026lt;T, T\u0026gt;\n#define fi first\n#define se second\n\n#define Rush for(int ____T\u003dRD(); ____T--;)\n\n#define Display(A, n, m) {                      \\\n\tREP(i, n){\t\t                            \\\n        REP(j, m) cout \u0026lt;\u0026lt; A[i][j] \u0026lt;\u0026lt; \u0026quot; \u0026quot;;       \\\n        cout \u0026lt;\u0026lt; endl;\t\t\t\t            \\\n\t}\t\t\t\t\t\t                    \\\n}\n\n#define Display_1(A, n, m) {\t\t\t\t    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m) cout \u0026lt;\u0026lt; A[i][j] \u0026lt;\u0026lt; \u0026quot; \u0026quot;;     \\\n\t\tcout \u0026lt;\u0026lt; endl;\t\t            \t\t\\\n\t}\t\t\t\t\t\t                    \\\n}\n\n#pragma comment(linker, \u0026quot;/STACK:36777216\u0026quot;)\n//#pragma GCC optimize (\u0026quot;O2\u0026quot;)\n#define Ruby system(\u0026quot;ruby main.rb\u0026quot;)\n#define Haskell system(\u0026quot;runghc main.hs\u0026quot;)\n#define Python system(\u0026quot;python main.py\u0026quot;)\n#define Pascal system(\u0026quot;fpc main.pas\u0026quot;)\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned UINT;\ntypedef unsigned long long ULL;\n\ntypedef vector\u0026lt;int\u0026gt; VI;\ntypedef vector\u0026lt;char\u0026gt; VC;\ntypedef vector\u0026lt;string\u0026gt; VS;\ntypedef vector\u0026lt;LL\u0026gt; VL;\ntypedef vector\u0026lt;DB\u0026gt; VF;\ntypedef set\u0026lt;int\u0026gt; SI;\ntypedef set\u0026lt;string\u0026gt; SS;\ntypedef map\u0026lt;int, int\u0026gt; MII;\ntypedef map\u0026lt;string, int\u0026gt; MSI;\ntypedef pair\u0026lt;int, int\u0026gt; PII;\ntypedef pair\u0026lt;LL, LL\u0026gt; PLL;\ntypedef vector\u0026lt;PII\u0026gt; VII;\ntypedef vector\u0026lt;VI\u0026gt; VVI;\ntypedef vector\u0026lt;VII\u0026gt; VVII;\n\ntemplate\u0026lt;class T\u0026gt; inline T\u0026amp; RD(T \u0026amp;);\ntemplate\u0026lt;class T\u0026gt; inline void OT(const T \u0026amp;);\ninline LL RD(){LL x; return RD(x);}\ninline DB\u0026amp; RF(DB \u0026amp;);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char\u0026amp; RC(char \u0026amp;c);\ninline char RC();\ninline char\u0026amp; RC(char \u0026amp;c){scanf(\u0026quot; %c\u0026quot;, \u0026amp;c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char\u0026amp; RC(char \u0026amp;c){c \u003d getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate\u0026lt;class T\u0026gt; inline T\u0026amp; RDD(T \u0026amp;x){\n    char c; for (c \u003d getchar(); c \u0026lt; \u0027-\u0027; c \u003d getchar());\n    if (c \u003d\u003d \u0027-\u0027){x \u003d \u00270\u0027 - getchar(); for (c \u003d getchar(); \u00270\u0027 \u0026lt;\u003d c \u0026amp;\u0026amp; c \u0026lt;\u003d \u00279\u0027; c \u003d getchar()) x \u003d x * 10 + \u00270\u0027 - c;}\n    else {x \u003d c - \u00270\u0027; for (c \u003d getchar(); \u00270\u0027 \u0026lt;\u003d c \u0026amp;\u0026amp; c \u0026lt;\u003d \u00279\u0027; c \u003d getchar()) x \u003d x * 10 + c - \u00270\u0027;}\n    return x;\n}\n\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate\u0026lt;class T0, class T1\u0026gt; inline T0\u0026amp; RD(T0 \u0026amp;x0, T1 \u0026amp;x1){RD(x0), RD(x1); return x0;}\ntemplate\u0026lt;class T0, class T1, class T2\u0026gt; inline T0\u0026amp; RD(T0 \u0026amp;x0, T1 \u0026amp;x1, T2 \u0026amp;x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate\u0026lt;class T0, class T1, class T2, class T3\u0026gt; inline T0\u0026amp; RD(T0 \u0026amp;x0, T1 \u0026amp;x1, T2 \u0026amp;x2, T3 \u0026amp;x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate\u0026lt;class T0, class T1, class T2, class T3, class T4\u0026gt; inline T0\u0026amp; RD(T0 \u0026amp;x0, T1 \u0026amp;x1, T2 \u0026amp;x2, T3 \u0026amp;x3, T4 \u0026amp;x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate\u0026lt;class T0, class T1, class T2, class T3, class T4, class T5\u0026gt; inline T0\u0026amp; RD(T0 \u0026amp;x0, T1 \u0026amp;x1, T2 \u0026amp;x2, T3 \u0026amp;x3, T4 \u0026amp;x4, T5 \u0026amp;x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate\u0026lt;class T0, class T1, class T2, class T3, class T4, class T5, class T6\u0026gt; inline T0\u0026amp; RD(T0 \u0026amp;x0, T1 \u0026amp;x1, T2 \u0026amp;x2, T3 \u0026amp;x3, T4 \u0026amp;x4, T5 \u0026amp;x5, T6 \u0026amp;x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate\u0026lt;class T0, class T1\u0026gt; inline void OT(const T0 \u0026amp;x0, const T1 \u0026amp;x1){OT(x0), OT(x1);}\ntemplate\u0026lt;class T0, class T1, class T2\u0026gt; inline void OT(const T0 \u0026amp;x0, const T1 \u0026amp;x1, const T2 \u0026amp;x2){OT(x0), OT(x1), OT(x2);}\ntemplate\u0026lt;class T0, class T1, class T2, class T3\u0026gt; inline void OT(const T0 \u0026amp;x0, const T1 \u0026amp;x1, const T2 \u0026amp;x2, const T3 \u0026amp;x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate\u0026lt;class T0, class T1, class T2, class T3, class T4\u0026gt; inline void OT(const T0 \u0026amp;x0, const T1 \u0026amp;x1, const T2 \u0026amp;x2, const T3 \u0026amp;x3, const T4 \u0026amp;x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate\u0026lt;class T0, class T1, class T2, class T3, class T4, class T5\u0026gt; inline void OT(const T0 \u0026amp;x0, const T1 \u0026amp;x1, const T2 \u0026amp;x2, const T3 \u0026amp;x3, const T4 \u0026amp;x4, const T5 \u0026amp;x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate\u0026lt;class T0, class T1, class T2, class T3, class T4, class T5, class T6\u0026gt; inline void OT(const T0 \u0026amp;x0, const T1 \u0026amp;x1, const T2 \u0026amp;x2, const T3 \u0026amp;x3, const T4 \u0026amp;x4, const T5 \u0026amp;x5, const T6 \u0026amp;x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char\u0026amp; RC(char \u0026amp;a, char \u0026amp;b){RC(a), RC(b); return a;}\ninline char\u0026amp; RC(char \u0026amp;a, char \u0026amp;b, char \u0026amp;c){RC(a), RC(b), RC(c); return a;}\ninline char\u0026amp; RC(char \u0026amp;a, char \u0026amp;b, char \u0026amp;c, char \u0026amp;d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char\u0026amp; RC(char \u0026amp;a, char \u0026amp;b, char \u0026amp;c, char \u0026amp;d, char \u0026amp;e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char\u0026amp; RC(char \u0026amp;a, char \u0026amp;b, char \u0026amp;c, char \u0026amp;d, char \u0026amp;e, char \u0026amp;f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char\u0026amp; RC(char \u0026amp;a, char \u0026amp;b, char \u0026amp;c, char \u0026amp;d, char \u0026amp;e, char \u0026amp;f, char \u0026amp;g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB\u0026amp; RF(DB \u0026amp;a, DB \u0026amp;b){RF(a), RF(b); return a;}\ninline DB\u0026amp; RF(DB \u0026amp;a, DB \u0026amp;b, DB \u0026amp;c){RF(a), RF(b), RF(c); return a;}\ninline DB\u0026amp; RF(DB \u0026amp;a, DB \u0026amp;b, DB \u0026amp;c, DB \u0026amp;d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB\u0026amp; RF(DB \u0026amp;a, DB \u0026amp;b, DB \u0026amp;c, DB \u0026amp;d, DB \u0026amp;e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB\u0026amp; RF(DB \u0026amp;a, DB \u0026amp;b, DB \u0026amp;c, DB \u0026amp;d, DB \u0026amp;e, DB \u0026amp;f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB\u0026amp; RF(DB \u0026amp;a, DB \u0026amp;b, DB \u0026amp;c, DB \u0026amp;d, DB \u0026amp;e, DB \u0026amp;f, DB \u0026amp;g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate\u0026lt;class T0,class T1\u0026gt;inline void RDD(const T0\u0026amp;a, const T1\u0026amp;b){RDD(a),RDD(b);}\ntemplate\u0026lt;class T0,class T1,class T2\u0026gt;inline void RDD(const T0\u0026amp;a, const T1\u0026amp;b, const T2\u0026amp;c){RDD(a),RDD(b),RDD(c);}\n\ntemplate\u0026lt;class T\u0026gt; inline void RST(T \u0026amp;A){memset(A, 0, sizeof(A));}\ntemplate\u0026lt;class T\u0026gt; inline void FLC(T \u0026amp;A, int x){memset(A, x, sizeof(A));}\ntemplate\u0026lt;class T\u0026gt; inline void CLR(T \u0026amp;A){A.clear();}\n\ntemplate\u0026lt;class T0, class T1\u0026gt; inline void RST(T0 \u0026amp;A0, T1 \u0026amp;A1){RST(A0), RST(A1);}\ntemplate\u0026lt;class T0, class T1, class T2\u0026gt; inline void RST(T0 \u0026amp;A0, T1 \u0026amp;A1, T2 \u0026amp;A2){RST(A0), RST(A1), RST(A2);}\ntemplate\u0026lt;class T0, class T1, class T2, class T3\u0026gt; inline void RST(T0 \u0026amp;A0, T1 \u0026amp;A1, T2 \u0026amp;A2, T3 \u0026amp;A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate\u0026lt;class T0, class T1, class T2, class T3, class T4\u0026gt; inline void RST(T0 \u0026amp;A0, T1 \u0026amp;A1, T2 \u0026amp;A2, T3 \u0026amp;A3, T4 \u0026amp;A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate\u0026lt;class T0, class T1, class T2, class T3, class T4, class T5\u0026gt; inline void RST(T0 \u0026amp;A0, T1 \u0026amp;A1, T2 \u0026amp;A2, T3 \u0026amp;A3, T4 \u0026amp;A4, T5 \u0026amp;A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate\u0026lt;class T0, class T1, class T2, class T3, class T4, class T5, class T6\u0026gt; inline void RST(T0 \u0026amp;A0, T1 \u0026amp;A1, T2 \u0026amp;A2, T3 \u0026amp;A3, T4 \u0026amp;A4, T5 \u0026amp;A5, T6 \u0026amp;A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate\u0026lt;class T0, class T1\u0026gt; inline void FLC(T0 \u0026amp;A0, T1 \u0026amp;A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate\u0026lt;class T0, class T1, class T2\u0026gt; inline void FLC(T0 \u0026amp;A0, T1 \u0026amp;A1, T2 \u0026amp;A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate\u0026lt;class T0, class T1, class T2, class T3\u0026gt; inline void FLC(T0 \u0026amp;A0, T1 \u0026amp;A1, T2 \u0026amp;A2, T3 \u0026amp;A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate\u0026lt;class T0, class T1, class T2, class T3, class T4\u0026gt; inline void FLC(T0 \u0026amp;A0, T1 \u0026amp;A1, T2 \u0026amp;A2, T3 \u0026amp;A3, T4 \u0026amp;A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate\u0026lt;class T0, class T1, class T2, class T3, class T4, class T5\u0026gt; inline void FLC(T0 \u0026amp;A0, T1 \u0026amp;A1, T2 \u0026amp;A2, T3 \u0026amp;A3, T4 \u0026amp;A4, T5 \u0026amp;A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate\u0026lt;class T0, class T1, class T2, class T3, class T4, class T5, class T6\u0026gt; inline void FLC(T0 \u0026amp;A0, T1 \u0026amp;A1, T2 \u0026amp;A2, T3 \u0026amp;A3, T4 \u0026amp;A4, T5 \u0026amp;A5, T6 \u0026amp;A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate\u0026lt;class T\u0026gt; inline void CLR(priority_queue\u0026lt;T, vector\u0026lt;T\u0026gt;, less\u0026lt;T\u0026gt; \u0026gt; \u0026amp;Q){while (!Q.empty()) Q.pop();}\ntemplate\u0026lt;class T\u0026gt; inline void CLR(priority_queue\u0026lt;T, vector\u0026lt;T\u0026gt;, greater\u0026lt;T\u0026gt; \u0026gt; \u0026amp;Q){while (!Q.empty()) Q.pop();}\ntemplate\u0026lt;class T0, class T1\u0026gt; inline void CLR(T0 \u0026amp;A0, T1 \u0026amp;A1){CLR(A0), CLR(A1);}\ntemplate\u0026lt;class T0, class T1, class T2\u0026gt; inline void CLR(T0 \u0026amp;A0, T1 \u0026amp;A1, T2 \u0026amp;A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate\u0026lt;class T0, class T1, class T2, class T3\u0026gt; inline void CLR(T0 \u0026amp;A0, T1 \u0026amp;A1, T2 \u0026amp;A2, T3 \u0026amp;A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate\u0026lt;class T0, class T1, class T2, class T3, class T4\u0026gt; inline void CLR(T0 \u0026amp;A0, T1 \u0026amp;A1, T2 \u0026amp;A2, T3 \u0026amp;A3, T4 \u0026amp;A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate\u0026lt;class T0, class T1, class T2, class T3, class T4, class T5\u0026gt; inline void CLR(T0 \u0026amp;A0, T1 \u0026amp;A1, T2 \u0026amp;A2, T3 \u0026amp;A3, T4 \u0026amp;A4, T5 \u0026amp;A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate\u0026lt;class T0, class T1, class T2, class T3, class T4, class T5, class T6\u0026gt; inline void CLR(T0 \u0026amp;A0, T1 \u0026amp;A1, T2 \u0026amp;A2, T3 \u0026amp;A3, T4 \u0026amp;A4, T5 \u0026amp;A5, T6 \u0026amp;A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate\u0026lt;class T\u0026gt; inline void CLR(T \u0026amp;A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate\u0026lt;class T\u0026gt; inline T\u0026amp; SRT(T \u0026amp;A){sort(ALL(A)); return A;}\ntemplate\u0026lt;class T, class C\u0026gt; inline T\u0026amp; SRT(T \u0026amp;A, C B){sort(ALL(A), B); return A;}\ntemplate\u0026lt;class T\u0026gt; inline T\u0026amp; UNQ(T \u0026amp;A){A.resize(unique(ALL(SRT(A)))-A.begin());return A;}\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int dx4[] \u003d {-1, 0, 1, 0};\nconst int dy4[] \u003d {0, 1, 0, -1};\n\nconst int dx8[] \u003d {-1, 0, 1, 0 , -1 , -1 , 1 , 1};\nconst int dy8[] \u003d {0, 1, 0, -1 , -1 , 1 , -1 , 1};\n\nconst int dxhorse[] \u003d {-2 , -2 , -1 , -1 , 1 , 1 , 2 , 2};\nconst int dyhorse[] \u003d {1 ,  -1 , 2  , -2 , 2 ,-2 , 1 ,-1};\n\nconst int MOD \u003d 1000000007;\n//int MOD \u003d 99990001;\nconst int INF \u003d 0x3f3f3f3f;\nconst LL INFF \u003d 1LL \u0026lt;\u0026lt; 60;\nconst DB EPS \u003d 1e-9;\nconst DB OO \u003d 1e15;\nconst DB PI \u003d acos(-1.0); //M_PI;\n\n//}\n\n/** Add On .. **/ //{\n// \u0026lt;\u0026lt;\u003d \u00270. Nichi Joo ., //{\ntemplate\u0026lt;class T\u0026gt; inline void checkMin(T \u0026amp;a,const T b){if (b\u0026lt;a) a\u003db;}\ntemplate\u0026lt;class T\u0026gt; inline void checkMax(T \u0026amp;a,const T b){if (a\u0026lt;b) a\u003db;}\ntemplate\u0026lt;class T\u0026gt; inline void checkMin(T \u0026amp;a, T \u0026amp;b, const T x){checkMin(a, x), checkMin(b, x);}\ntemplate\u0026lt;class T\u0026gt; inline void checkMax(T \u0026amp;a, T \u0026amp;b, const T x){checkMax(a, x), checkMax(b, x);}\ntemplate \u0026lt;class T, class C\u0026gt; inline void checkMin(T\u0026amp; a, const T b, C c){if (c(b,a)) a \u003d b;}\ntemplate \u0026lt;class T, class C\u0026gt; inline void checkMax(T\u0026amp; a, const T b, C c){if (c(a,b)) a \u003d b;}\ntemplate\u0026lt;class T\u0026gt; inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate\u0026lt;class T\u0026gt; inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate\u0026lt;class T\u0026gt; inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate\u0026lt;class T\u0026gt; inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate\u0026lt;class T\u0026gt; inline T sqr(T a){return a*a;}\ntemplate\u0026lt;class T\u0026gt; inline T cub(T a){return a*a*a;}\ninline int ceil(int x, int y){return (x - 1) / y + 1;}\ninline int sgn(DB x){return x \u0026lt; -EPS ? -1 : x \u0026gt; EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n// \u0026lt;\u0026lt;\u003d \u00271. Bitwise Operation ., //{\nnamespace BO{\n\ninline bool _1(int x, int i){return bool(x\u0026amp;1\u0026lt;\u0026lt;i);}\ninline bool _1(LL x, int i){return bool(x\u0026amp;1LL\u0026lt;\u0026lt;i);}\ninline LL _1(int i){return 1LL\u0026lt;\u0026lt;i;}\ninline LL _U(int i){return _1(i) - 1;};\n\ninline int reverse_bits(int x){\n    x \u003d ((x \u0026gt;\u0026gt; 1) \u0026amp; 0x55555555) | ((x \u0026lt;\u0026lt; 1) \u0026amp; 0xaaaaaaaa);\n    x \u003d ((x \u0026gt;\u0026gt; 2) \u0026amp; 0x33333333) | ((x \u0026lt;\u0026lt; 2) \u0026amp; 0xcccccccc);\n    x \u003d ((x \u0026gt;\u0026gt; 4) \u0026amp; 0x0f0f0f0f) | ((x \u0026lt;\u0026lt; 4) \u0026amp; 0xf0f0f0f0);\n    x \u003d ((x \u0026gt;\u0026gt; 8) \u0026amp; 0x00ff00ff) | ((x \u0026lt;\u0026lt; 8) \u0026amp; 0xff00ff00);\n    x \u003d ((x \u0026gt;\u0026gt;16) \u0026amp; 0x0000ffff) | ((x \u0026lt;\u0026lt;16) \u0026amp; 0xffff0000);\n    return x;\n}\n\ninline LL reverse_bits(LL x){\n    x \u003d ((x \u0026gt;\u0026gt; 1) \u0026amp; 0x5555555555555555LL) | ((x \u0026lt;\u0026lt; 1) \u0026amp; 0xaaaaaaaaaaaaaaaaLL);\n    x \u003d ((x \u0026gt;\u0026gt; 2) \u0026amp; 0x3333333333333333LL) | ((x \u0026lt;\u0026lt; 2) \u0026amp; 0xccccccccccccccccLL);\n    x \u003d ((x \u0026gt;\u0026gt; 4) \u0026amp; 0x0f0f0f0f0f0f0f0fLL) | ((x \u0026lt;\u0026lt; 4) \u0026amp; 0xf0f0f0f0f0f0f0f0LL);\n    x \u003d ((x \u0026gt;\u0026gt; 8) \u0026amp; 0x00ff00ff00ff00ffLL) | ((x \u0026lt;\u0026lt; 8) \u0026amp; 0xff00ff00ff00ff00LL);\n    x \u003d ((x \u0026gt;\u0026gt;16) \u0026amp; 0x0000ffff0000ffffLL) | ((x \u0026lt;\u0026lt;16) \u0026amp; 0xffff0000ffff0000LL);\n    x \u003d ((x \u0026gt;\u0026gt;32) \u0026amp; 0x00000000ffffffffLL) | ((x \u0026lt;\u0026lt;32) \u0026amp; 0xffffffff00000000LL);\n    return x;\n}\n\ntemplate\u0026lt;class T\u0026gt; inline bool odd(T x){return x\u0026amp;1;}\ntemplate\u0026lt;class T\u0026gt; inline bool even(T x){return !odd(x);}\ntemplate\u0026lt;class T\u0026gt; inline T low_bit(T x) {return x \u0026amp; -x;}\ntemplate\u0026lt;class T\u0026gt; inline T high_bit(T x) {T p \u003d low_bit(x);while (p !\u003d x) x -\u003d p, p \u003d low_bit(x);return p;}\ntemplate\u0026lt;class T\u0026gt; inline T cover_bit(T x){T p \u003d 1; while (p \u0026lt; x) p \u0026lt;\u0026lt;\u003d 1;return p;}\n\n} using namespace BO;//}\n// \u0026lt;\u0026lt;\u003d \u00272. Number Theory .,//{\nnamespace NT{\ninline LL __lcm(LL a, LL b){return a*b/__gcd(a,b);}\ninline void INC(int \u0026amp;a, int b){a +\u003d b; if (a \u0026gt;\u003d MOD) a -\u003d MOD;}\ninline int sum(int a, int b){a +\u003d b; if (a \u0026gt;\u003d MOD) a -\u003d MOD; return a;}\ninline void DEC(int \u0026amp;a, int b){a -\u003d b; if (a \u0026lt; 0) a +\u003d MOD;}\ninline int dff(int a, int b){a -\u003d b; if (a \u0026lt; 0) a  +\u003d MOD; return a;}\ninline void MUL(int \u0026amp;a, int b){a \u003d (LL)a * b % MOD;}\ninline int pdt(int a, int b){return (LL)a * b % MOD;}\n\ninline int sum(int a, int b, int c){return sum(sum(a, b), c);}\ninline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\ninline int pdt(int a, int b, int c){return pdt(pdt(a, b), c);}\ninline int pdt(int a, int b, int c, int d){return pdt(pdt(pdt(a, b), c), d);}\n\ninline int pow(int a, int b){\n    int c(1); while (b){\n        if (b\u0026amp;1) MUL(c, a);\n        MUL(a, a), b \u0026gt;\u0026gt;\u003d 1;\n    }\n    return c;\n}\n\ninline int pow(int a, LL b){\n    int c(1); while (b){\n        if (b\u0026amp;1) MUL(c, a);\n        MUL(a, a), b \u0026gt;\u0026gt;\u003d 1;\n    }\n    return c;\n}\n\ntemplate\u0026lt;class T\u0026gt; inline T pow(T a, LL b){\n    T c(1); while (b){\n        if (b\u0026amp;1) c *\u003d a;\n        a *\u003d a, b \u0026gt;\u0026gt;\u003d 1;\n    }\n    return c;\n}\n\ninline int _I(int b){\n    int a \u003d MOD, x1 \u003d 0, x2 \u003d 1, q;\n    while (true){\n        q \u003d a / b, a %\u003d b;\n        if (!a) return (x2 + MOD) % MOD;\n        DEC(x1, pdt(q, x2));\n\n        q \u003d b / a, b %\u003d a;\n        if (!b) return (x1 + MOD) % MOD;\n        DEC(x2, pdt(q, x1));\n    }\n}\n\ninline void DIV(int \u0026amp;a, int b){MUL(a, _I(b));}\ninline int qtt(int a, int b){return pdt(a, _I(b));}\n\ninline int phi(int n){\n    int res \u003d n; for (int i\u003d2;sqr(i)\u0026lt;\u003dn;++i) if (!(n%i)){\n        DEC(res, qtt(res, i));\n        do{n /\u003d i;} while(!(n%i));\n    }\n    if (n !\u003d 1)\n        DEC(res, qtt(res, n));\n    return res;\n}\n\n};// using namespace NT;//}\n//}\n\n/** Miscellaneous .. **/ //{\n\n/** Algorithm    .. */ //{\n// \u0026lt;\u0026lt;\u003d \u0027-. Math .,//{\nnamespace Math{\n\ttypedef long long typec;\n\t///Lib functions\n\ttypec GCD(typec a, typec b)\n\t{\n\t\treturn b ? GCD(b, a % b) : a;\n\t}\n\ttypec extendGCD(typec a, typec b, typec\u0026amp; x, typec\u0026amp; y)\n\t{\n\t\tif(!b) return x \u003d 1, y \u003d 0, a;\n\t\ttypec res \u003d extendGCD(b, a % b, x, y), tmp \u003d x;\n\t\tx \u003d y, y \u003d tmp - (a / b) * y;\n\t\treturn res;\n\t}\n\t///for x^k\n\ttypec power(typec x, typec k)\n\t{\n\t\ttypec res \u003d 1;\n\t\twhile(k)\n\t\t{\n\t\t\tif(k\u0026amp;1) res *\u003d x;\n\t\t\tx *\u003d x, k \u0026gt;\u0026gt;\u003d 1;\n\t\t}\n\t\treturn res;\n\t}\n\t///for x^k mod m\n\ttypec powerMod(typec x, typec k, typec m)\n\t{\n\t\ttypec res \u003d 1;\n\t\twhile(x %\u003d m, k)\n\t\t{\n\t\t\tif(k\u0026amp;1) res *\u003d x, res %\u003d m;\n\t\t\tx *\u003d x, k \u0026gt;\u0026gt;\u003d1;\n\t\t}\n\t\treturn res;\n\t}\n\t/***************************************\n\tInverse in mod p^t system\n\t***************************************/\n\ttypec inverse(typec a, typec p, typec t \u003d 1)\n\t{\n\t\ttypec pt \u003d power(p, t);\n\t\ttypec x, y;\n\t    y \u003d extendGCD(a, pt, x, y);\n\t\treturn x \u0026lt; 0 ? x +\u003d pt : x;\n\t}\n\t/***************************************\n\tLinear congruence theorem\n\tx \u003d a (mod p)\n\tx \u003d b (mod q)\n\tfor gcd(p, q) \u003d 1, 0 \u0026lt;\u003d x \u0026lt; pq\n\t***************************************/\n\ttypec linearCongruence(typec a, typec b, typec p, typec q)\n\t{\n\t\ttypec x, y;\n\t\ty \u003d extendGCD(p, q, x, y);\n\t\twhile(b \u0026lt; a) b +\u003d q / y;\n\t\tx *\u003d b - a, x \u003d p * x + a, x %\u003d p * q;\n\t\tif(x \u0026lt; 0) x +\u003d p * q;\n\t\treturn x;\n\t}\n\t/***************************************\n\tprime table\n\tO(n)\n\t***************************************/\n\tconst int PRIMERANGE \u003d 1000000;\n\tint prime[PRIMERANGE + 1];\n\tint mobius[PRIMERANGE + 1];\n\tint getPrime()\n\t{\n\t\tmemset (prime, 0, sizeof (int) * (PRIMERANGE + 1));\n\t\tmemset(mobius , 0 , sizeof(mobius));\n\t\tmobius[1] \u003d 1;\n\t\tfor (int i \u003d 2; i \u0026lt;\u003d PRIMERANGE; i++)\n\t\t{\n\t\t\tif (!prime[i]) prime[++prime[0]] \u003d i , mobius[i] \u003d -1;\n\t\t\tfor (int j \u003d 1; j \u0026lt;\u003d prime[0] \u0026amp;\u0026amp; prime[j] \u0026lt;\u003d PRIMERANGE / i; j++)\n\t\t\t{\n\t\t\t\tprime[prime[j]*i] \u003d 1;\n\t\t\t\tif (i % prime[j] \u003d\u003d 0) break;\n\t\t\t\telse mobius[i * prime[j]] \u003d -mobius[i];\n\t\t\t}\n\t\t}\n\t\treturn prime[0];\n\t}\n\t/***************************************\n\tget factor of n\n\tO(sqrt(n))\n\tfactor[][0] is prime factor\n\tfactor[][1] is factor generated by this prime\n\tfactor[][2] is factor counter\n\n\tneed: Prime Table\n\t***************************************/\n\t///you should init the prime table before\n\tint factor[100][3], facCnt;\n\tint getFactors(int x)\n\t{\n\t\tfacCnt \u003d 0;\n\t\tint tmp \u003d x;\n\t\tfor(int i \u003d 1; prime[i] \u0026lt;\u003d tmp / prime[i]; i++)\n\t\t{\n\t\t\tfactor[facCnt][1] \u003d 1, factor[facCnt][2] \u003d 0;\n\t\t\tif(tmp % prime[i] \u003d\u003d 0)\n\t\t\t\tfactor[facCnt][0] \u003d prime[i];\n\t\t\twhile(tmp % prime[i] \u003d\u003d 0)\n\t\t\t\tfactor[facCnt][2]++, factor[facCnt][1] *\u003d prime[i], tmp /\u003d prime[i];\n\t\t\tif(factor[facCnt][1] \u0026gt; 1) facCnt++;\n\t\t}\n\t\tif(tmp !\u003d 1)\n\t\t\tfactor[facCnt][0] \u003d tmp, factor[facCnt][1] \u003d tmp, factor[facCnt++][2] \u003d 1;\n\t\treturn facCnt;\n\t}\n\ttypec combinationModP(typec n, typec k, typec p)\n\t{\n\t\tif(k \u0026gt; n) return 0;\n\t\tif(n - k \u0026lt; k) k \u003d n - k;\n\t\ttypec a \u003d 1, b \u003d 1, x, y;\n\t\tint pcnt \u003d 0;\n\t\tfor(int i \u003d 1; i \u0026lt;\u003d k; i++)\n\t\t{\n\t\t\tx \u003d n - i + 1, y \u003d i;\n\t\t\twhile(x % p \u003d\u003d 0) x /\u003d p, pcnt++;\n\t\t\twhile(y % p \u003d\u003d 0) y /\u003d p, pcnt--;\n\t\t\tx %\u003d p, y %\u003d p, a *\u003d x, b *\u003d y;\n\t\t\tb %\u003d p, a %\u003d p;\n\t\t}\n\t\tif(pcnt) return 0;\n\t\textendGCD(b, p, x, y);\n\t\tif(x \u0026lt; 0) x +\u003d p;\n\t\ta *\u003d x, a %\u003d p;\n\t\treturn a;\n\t}\n};//using namespace Math;\n//}\n// \u0026lt;\u0026lt;\u003d \u0027-. Geo ,.//{\nnamespace Geo{\n\t#define typec double\n    const typec eps\u003d1e-9;\nint dblcmp(double d)\n{\n    return d \u0026lt; -eps ? -1 : d \u0026gt; eps;\n}\ninline double sqr(double x){return x*x;}\nstruct point\n{\n    double x,y;\n    point(){}\n    point(double _x,double _y):\n    x(_x),y(_y){};\n    void input()\n    {\n        scanf(\u0026quot;%lf%lf\u0026quot;,\u0026amp;x,\u0026amp;y);\n    }\n    void output()\n    {\n        printf(\u0026quot;%.2f %.2f\\n\u0026quot;,x,y);\n    }\n    bool operator\u003d\u003d(point a)const\n    {\n        return dblcmp(a.x-x)\u003d\u003d0\u0026amp;\u0026amp;dblcmp(a.y-y)\u003d\u003d0;\n    }\n    bool operator\u0026lt;(point a)const\n    {\n        return dblcmp(a.x-x)\u003d\u003d0?dblcmp(y-a.y)\u0026lt;0:x\u0026lt;a.x;\n    }\n    double len()\n    {\n        return hypot(x,y);\n    }\n    double len2()\n    {\n        return x*x+y*y;\n    }\n    double distance(point p)\n    {\n        return hypot(x-p.x,y-p.y);\n    }\n    double distance2(point p)\n    {\n        return sqr(x-p.x)+sqr(y-p.y);\n    }\n    point add(point p)\n    {\n        return point(x+p.x,y+p.y);\n    }\n    point operator + (const point \u0026amp; p) const{\n        return point(x+p.x,y+p.y);\n    }\n    point sub(point p)\n    {\n        return point(x-p.x,y-p.y);\n    }\n    point operator - (const point \u0026amp; p) const{\n        return point(x-p.x,y-p.y);\n    }\n    point mul(double b)\n    {\n        return point(x*b,y*b);\n    }\n    point div(double b)\n    {\n        return point(x/b,y/b);\n    }\n    double dot(point p)\n    {\n        return x*p.x+y*p.y;\n    }\n    double operator * (const point \u0026amp; p) const{\n        return x*p.x+y*p.y;\n    }\n    double det(point p)\n    {\n        return x*p.y-y*p.x;\n    }\n    double operator ^ (const point \u0026amp; p) const{\n        return x*p.y-y*p.x;\n    }\n    double rad(point a,point b)\n    {\n    \tpoint p\u003d*this;\n    \treturn fabs(atan2(fabs(a.sub(p).det(b.sub(p))),a.sub(p).dot(b.sub(p))));\n\t}\n    point trunc(double r)\n\t{\n\t\tdouble l\u003dlen();\n\t\tif (!dblcmp(l))return *this;\n\t\tr/\u003dl;\n\t\treturn point(x*r,y*r);\n\t}\n    point rotleft()\n    {\n        return point(-y,x);\n    }\n    point rotright()\n    {\n        return point(y,-x);\n    }\n    point rotate(point p,double angle)//�Ƶ�p��ʱ����תangle�Ƕ�\n    {\n        point v\u003dthis-\u0026gt;sub(p);\n        double c\u003dcos(angle),s\u003dsin(angle);\n        return point(p.x+v.x*c-v.y*s,p.y+v.x*s+v.y*c);\n    }\n#undef typec\n};\n};//using namespace Geo;\n//}\n//}\n\n/** I/O Accelerator Interface .. **/ //{\ntemplate\u0026lt;class T\u0026gt; inline T\u0026amp; RD(T \u0026amp;x){\n    //cin \u0026gt;\u0026gt; x;\n    //scanf(\u0026quot;%d\u0026quot;, \u0026amp;x);\n    char c; for (c \u003d getchar(); c \u0026lt; \u00270\u0027; c \u003d getchar()); x \u003d c - \u00270\u0027; for (c \u003d getchar(); \u00270\u0027 \u0026lt;\u003d c \u0026amp;\u0026amp; c \u0026lt;\u003d \u00279\u0027; c \u003d getchar()) x \u003d x * 10 + c - \u00270\u0027;\n    //char c; c \u003d getchar(); x \u003d c - \u00270\u0027; for (c \u003d getchar(); c \u0026gt;\u003d \u00270\u0027; c \u003d getchar()) x \u003d x * 10 + c - \u00270\u0027;\n    return x;\n}\n\ninline DB\u0026amp; RF(DB \u0026amp;x){\n    //cin \u0026gt;\u0026gt; x;\n    scanf(\u0026quot;%lf\u0026quot;, \u0026amp;x);\n    /*char t; while ((t\u003dgetchar())\u003d\u003d\u0027 \u0027||t\u003d\u003d\u0027\\n\u0027); x \u003d t - \u00270\u0027;\n    while ((t\u003dgetchar())!\u003d\u0027 \u0027\u0026amp;\u0026amp;t!\u003d\u0027\\n\u0027\u0026amp;\u0026amp;t!\u003d\u0027.\u0027)x*\u003d10,x+\u003dt-\u00270\u0027;\n    if (t\u003d\u003d\u0027.\u0027){DB l\u003d1; while ((t\u003dgetchar())!\u003d\u0027 \u0027\u0026amp;\u0026amp;t!\u003d\u0027\\n\u0027)l*\u003d0.1,x +\u003d (t-\u00270\u0027)*l;}*/\n    return x;\n}\n\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\u0026quot;%s\u0026quot;, s);\n    return s;\n}\n\nint Case; template\u0026lt;class T\u0026gt; inline void OT(const T \u0026amp;x){\n    //printf(\u0026quot;Case %d: %d\\n\u0026quot;, ++Case, x);\n    //printf(\u0026quot;%.2lf\\n\u0026quot;, x);\n    //printf(\u0026quot;%d\\n\u0026quot;, x);\n    cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["c++"]}}