{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1513206981,"rating":0,"authorHandle":"platypus179","modificationTimeSeconds":1513364095,"id":56336,"title":"\u003cp\u003eНеделя грусти и дорешивания\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eОбещанный разбор. Напоминаю, что мои решения после того, как я выложил разбор ты можешь найти \u003ca href\u003d\"http://vasalf.net/cosh/\"\u003eздесь\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eГовядина — C: DZY любит модификации\u003c/h3\u003e\u003cp\u003eМысль такая: в общем-то, неважно, из каких строк мы вычитали до какого-то вычитания из столбца, в том смысле, что от этого не зависит результат, прибавленный к ответу. Более того, этот результат не поменяется даже, если переставить местами соседние операции отнятия от строки и от столбца. Отсюда, неважно, в каком порядке мы отнимаем от строк и столбцов (в смысле, порядок отниманий от столбцов важен, но неважно, в каком порядке идут отнимания от строк и столбцов) и можно считать, что сначала мы сделали все операции, например, со строками, а потом все опреации со столбцами.\u003c/p\u003e\u003cp\u003eТеперь рассмотрим отдельно операцию отнимания от столбцов. Я утверждаю, что выгодно всегда отнимать от столбца с наибольшей суммой. Интуитивно более-менее понятно, доказывается как любая жадность: посмотрим на лучший ответ, попробуем заменить в нём операцию \u003cem\u003eпосле последнего взятия более жирного столбца, которого взяли слишком мало раз\u003c/em\u003e на взятие этого самого более жирного столбца, покажем, что стало лучше.\u003c/p\u003e\u003cp\u003eНу и решение: перебрать, сколько раз берём столбцы и сколько раз строки и промоделировать жаность с \u003ccode\u003epriority_queue\u003c/code\u003e. Промоделировать жадность нужно заранее, запомнив ответы для каждого количества строк и столбцов. Тогда это работает за \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/67/e1/67e1f46cf1440d0eed8ea5d2006a40abdccae76a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003ch3\u003eГовядина — E: Дима и контейнеры\u003c/h3\u003e\u003cp\u003eМежду нулями задача решается независимо. Хочется распределить числа по контейнерам так, чтобы достать три максимума. Например, сложить все числа до первого из них не включительно и второй из них в стек, первый из них и все до третьего из них не включительно в очередь, а остальные -- \u003ccode\u003epop_back\u003c/code\u003e в дек. После чего в конце стека и в начале очереди и дека как раз будут лежать три максимума.\u003c/p\u003e\u003ch3\u003eСтатическое программирование — С: Владик и запоминающаяся поездка\u003c/h3\u003e\u003cp\u003eДинамика на префиксах, в пересчёте перебираешь последний отрезок (левую его границу с конца). В процессе тебе нужно поддерживать текущий \u003ccode\u003exor\u003c/code\u003e (для этого полезно иметь булевый массивчик \u0026quot;был такой элемент или не было\u0026quot;) и правда ли, что все числа, которые ты встретил на текущем отрезке, встречаются только на нём. Для последнего надо подсчитать для каждого исла его первое и последнее вхождение и поддерживать минимум и максимум этих значений в процессе перебора левой границы.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003eFive out of five — A: Покраска деревьев\u003c/h3\u003e\u003cp\u003eСтранно, что ты её не решил, я задумывал её как халяву, когда давал.\u003c/p\u003e\u003cp\u003eДинамика на префиксах, три параметра: перфикс, красота префикса и последняя штука на префиксе. Если ты сейчас добавляешь уже известное число, то всё совсем понятно, иначе перебираешь новый цвет.\u003c/p\u003e\u003cp\u003eВообще-то это \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e, но доказательство этой асимптотики я оставлю как упражнение.\u003c/p\u003e\u003cp\u003eЕсли что-то непонятно — спроси, пожалуйста, я правда не придумал, что тут ещё можно написать.\u003c/p\u003e\u003ch3\u003eFive out of five — С: Минимизация\u003c/h3\u003e\u003cp\u003eЧестно признаюсь, решение вроде вообще несложное, но я сам почти всё утро четверга его придумывал :) Примерно поэтому и контест задержался на лишние полдня.\u003c/p\u003e\u003cp\u003eНу у нас есть сколько-то последовательностей из \u003cspan class\u003d\"tex-span\"\u003e⌊ \u003ci\u003en\u003c/i\u003e / \u003ci\u003ek\u003c/i\u003e⌋\u003c/span\u003e чисел и сколько-то из \u003cspan class\u003d\"tex-span\"\u003e⌈ \u003ci\u003en\u003c/i\u003e / \u003ci\u003ek\u003c/i\u003e⌉\u003c/span\u003e. Нам нужно минимизировать сумму разностей максимумов и минимумов в них (всё остальное сократится).\u003c/p\u003e\u003cp\u003eПредлагается сказать, что если отрезки (по значениям) этих последовательностей пересекаются, то всё уже плохо в том плане, что если посвопать какие-нибудь числа в последовательностях, то сумма разностей будет поменьше.\u003c/p\u003e\u003cp\u003eРешение: сортим числа, делаем динамику. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e;\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e -- это лучший ответ для \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e последовательностей длины \u003cspan class\u003d\"tex-span\"\u003e⌊ \u003ci\u003en\u003c/i\u003e / \u003ci\u003ek\u003c/i\u003e⌋\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e последовательностей длины \u003cspan class\u003d\"tex-span\"\u003e⌈ \u003ci\u003en\u003c/i\u003e / \u003ci\u003ek\u003c/i\u003e⌉\u003c/span\u003e, если мы разбивали префикс длины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e·⌊ \u003ci\u003en\u003c/i\u003e / \u003ci\u003ek\u003c/i\u003e⌋ + \u003ci\u003ej\u003c/i\u003e·⌈ \u003ci\u003en\u003c/i\u003e / \u003ci\u003ek\u003c/i\u003e⌉\u003c/span\u003e. Пересчёт: перебираем, был ли последний отрезок длины \u003cspan class\u003d\"tex-span\"\u003e⌊ \u003ci\u003en\u003c/i\u003e / \u003ci\u003ek\u003c/i\u003e⌋\u003c/span\u003e или же \u003cspan class\u003d\"tex-span\"\u003e⌈ \u003ci\u003en\u003c/i\u003e / \u003ci\u003ek\u003c/i\u003e⌉\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eВсё. Это \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003eFive out of five — D: Демиурги играют снова\u003c/h3\u003e\u003cp\u003eДинамика от вершины, идея в том, чтобы промоделировать ходы в зависимости от того, Мазукта мы или Шамбамбукли и минимизируем сейчас или максимизируем. Все четыре случая можно разобрать руками. Если честно, особого желания это делать здесь у меня нет. Если ты не справишься, можешь почитать разбор \u003ca href\u003d\"//codeforces.com/blog/entry/17612\"\u003eздесь\u003c/a\u003e, это задача 538E. Если не справишься с английским, пиши, я переведу.\u003c/p\u003e\u003c/div\u003e","tags":[]}}