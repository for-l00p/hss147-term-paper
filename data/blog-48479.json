{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1479572834,"rating":85,"authorHandle":"codeonwort","modificationTimeSeconds":1479658228,"id":48479,"title":"\u003cp\u003eHaskell Implementations for Round 379 (Div. 2)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThis post doesn\u0027t include a special or creative solution. It\u0027s about how to implement the solutions in the \u003ca href\u003d\"//codeforces.com/blog/entry/48397\"\u003eeditorial\u003c/a\u003e. This kind of post is unnecessary for C++ or Java, but it\u0027s Haskell and there\u0027s no one who completed the round with Haskell ;) I can\u0027t assure if my codes are in pure functional way or very efficient, but at least they were accepted. I hope it will be helpful.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/734/problem/A\" title\u003d\"Codeforces Round 379 (Div. 2)\"\u003e734A - Антон и Даник\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eTake the outcome as a \u003ccode\u003eString\u003c/code\u003e and count the number of \u0027A\u0027 and \u0027D\u0027 in it. It\u0027s very simple problem so I just traversed the string twice (two calls of \u003ccode\u003elength . filter\u003c/code\u003e.) If you want to do it 2x faster, you can use \u003ccode\u003epartition\u003c/code\u003e in \u003ccode\u003eData.List\u003c/code\u003e.\u003c/p\u003e\u003cp\u003ecode: \u003ca href\u003d\"/contest/734/submission/22282938\" title\u003d\"Посылка 22282938 от codeonwort\"\u003e22282938\u003c/a\u003e\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/734/problem/B\" title\u003d\"Codeforces Round 379 (Div. 2)\"\u003e734B - Антон и цифры\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eAnother simple problem. Here is the line that reads the input:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e[k2, k3, k5, k6] \u0026lt;- (map read . words) `fmap` getLine :: IO [Integer]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf input is small like this, it has no problem. When you have to read a large number of integers, there is two considerations — speed and memory. They\u0027ll be examined in later problems.\u003c/p\u003e\u003cp\u003ecode: \u003ca href\u003d\"/contest/734/submission/22282969\" title\u003d\"Посылка 22282969 от codeonwort\"\u003e22282969\u003c/a\u003e\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/734/problem/C\" title\u003d\"Codeforces Round 379 (Div. 2)\"\u003e734C - Антон и зельеварение\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eIn this problem I\u0027ll discuss two things — input and binary search.\u003c/p\u003e\u003cp\u003eFirst, we need to read a huge number of integers, possibly up to \u003cspan class\u003d\"tex-span\"\u003e8 * 10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e numbers. When you try to read a line with \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e integers in this way:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003exs \u0026lt;- (map read . words) `fmap` getLine :: IO [Int64]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt will give you TLE. Believe me, parsing with \u003ccode\u003eString\u003c/code\u003e and \u003ccode\u003eread\u003c/code\u003e is really, really slow. Here is my favorite approach:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport Data.Maybe (fromJust)\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BS8\n\ngetInts \u003d (map (fst . fromJust . BS8.readInt) . BS8.words) `fmap` BS.getLine :: IO [Int]\ngetInt64s \u003d (map (fromIntegral . fst . fromJust . BS8.readInteger) . BS8.words) `fmap` BS.getLine :: IO [Int64]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt performs in reasonable time, but what about space? If you see my submission you will notice that the memory usage is 64 MB. In C++, to hold \u003cspan class\u003d\"tex-span\"\u003e8 * 10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e integers of 64-bit, you only need (100000 * 8 * 8) bytes \u003d 6.1 MB. I\u0027ll discuss it in problem F.\u003c/p\u003e\u003cp\u003eSecond, we need to use binary search. But I couldn\u0027t find a function like \u003ccode\u003estd::upper_bound()\u003c/code\u003e of C++ STL in Haskell\u0027s \u003ccode\u003ebase\u003c/code\u003e package. I implemented it as follow:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eupperBound :: Array Int64 Int64 -\u0026gt; Int64 -\u0026gt; Int64 -\u0026gt; Int64\nupperBound ary n x \u003d go 0 n where\n    go lb ub\n        | lb \u0026gt;\u003d ub \u003d ub\n        | ary ! mid \u0026lt;\u003d x \u003d go (mid+1) ub\n        | ary ! mid \u0026gt; x \u003d go lb mid\n        where mid \u003d (lb + ub) `div` 2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt assumes a few things. \u003ccode\u003eary\u003c/code\u003e has elements in indices from 0 to (n-1). It returns an integer from 0 to n. n means \u003ccode\u003ex\u003c/code\u003e is larger than any elements in \u003ccode\u003eary\u003c/code\u003e. This is not an idiomatic Haskell style. It can be generalized as follows:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eupperBound :: Ix i\n            \u003d\u0026gt; Array i e    -- array to binary search\n            -\u0026gt; (i,i)        -- left bound, right bound of search\n            -\u0026gt; e            -- element to find the upper bound\n            -\u0026gt; i            -- desired upper bound\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut I\u0027ll keep going with the first version, as it works well on this problem...\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    let ub \u003d upperBound ds k s\n    let freePotion \u003d cs ! (ub - 1)\n    let noFirst \u003d if ub \u0026gt; 0 then (max (n - freePotion) 0) * x else n * x\n    let bestUsingFirst \u003d minimum $ map (make as bs cs ds n k s) [0..m-1]\n    print $ min noFirst bestUsingFirst\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is the code that finds the answer. Here comes \u003cem\u003elazy evaluation\u003c/em\u003e. \u003ccode\u003eub\u003c/code\u003e can be 0 but \u003ccode\u003efreePotion\u003c/code\u003e doesn\u0027t mind it. \u003ccode\u003efreePotion\u003c/code\u003e is used to evaluate \u003ccode\u003enoFirst\u003c/code\u003e, only when \u003ccode\u003eub \u0026gt; 0\u003c/code\u003e. Hence \u003ccode\u003efreePotion \u003d cs ! (-1)\u003c/code\u003e never happens.\u003c/p\u003e\u003cp\u003eLast thing, a parade of parameters to \u003ccode\u003emake\u003c/code\u003e. If I defined \u003ccode\u003emake\u003c/code\u003e like \u003ccode\u003elet make i \u003d ...\u003c/code\u003e with other \u003ccode\u003elet\u003c/code\u003es, \u003ccode\u003eas bs cs ds n k s\u003c/code\u003e are not needed:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    let ub \u003d upperBound ds k s\n    let freePotion \u003d cs ! (ub - 1)\n    let noFirst \u003d if ub \u0026gt; 0 then (max (n - freePotion) 0) * x else n * x\n    let make i      -- define make here\n        | bs ! i \u0026gt; s \u003d maxBound :: Int64\n        | otherwise \u003d (max 0 remain) * (as ! i)\n        where\n            remain \u003d n - (if ub \u003d\u003d 0 then 0 else (cs ! (ub - 1)))\n            ub \u003d upperBound ds k (s - bs ! i)\n    let bestUsingFirst \u003d minimum $ map make [0..m-1]\n    print $ min noFirst bestUsingFirst\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt causes parse error, meanwhile in my desktop there\u0027s no problem. I use GHC 8.x and Codeforce\u0027s GHC version is 7.x. That\u0027s the reason I guess.\u003c/p\u003e\u003cp\u003ecode: \u003ca href\u003d\"/contest/734/submission/22285536\" title\u003d\"Посылка 22285536 от codeonwort\"\u003e22285536\u003c/a\u003e\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/734/problem/D\" title\u003d\"Codeforces Round 379 (Div. 2)\"\u003e734D - Антон и шахматы\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eInput is not just a list of integers, but a list of (char, int, int). Again, if you try to parse it with \u003ccode\u003eString\u003c/code\u003e and \u003ccode\u003eread\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003emain \u003d do\n    ...\n    blacks \u0026lt;- replicateM n $ do\n        [post, x, y] \u0026lt;- words `fmap` getLine\n        return (post, read x :: Int, read y :: Int)\n    ...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou will receive TLE. \u003ccode\u003eByteString\u003c/code\u003e will save us again.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport Data.Maybe\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BS8\n\nparseInt \u003d fst . fromJust . BS8.readInt\n\nmain \u003d do\n    ...\n    blacks \u0026lt;- replicateM n $ do\n        [post, x, y] \u0026lt;- BS8.words `fmap` BS.getLine\n        return (BS8.unpack post, parseInt x, parseInt y)\n    ...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRemaining parts are done just as the editorial says. But as you can see a lot of memory is used — 167 MB! My C++ code only used 15 MB. It\u0027s same situation as problem C. The reasons are list and tuple. in case of tuple, we have to \u003cem\u003eunpack\u003c/em\u003e three elements of tuples. My \u003ca href\u003d\"//codeforces.com/blog/entry/47260\"\u003eprevious post\u003c/a\u003e discusses the same problem and as I said I\u0027ll return to this in problem F.\u003c/p\u003e\u003cp\u003ecode: \u003ca href\u003d\"/contest/734/submission/22286544\" title\u003d\"Посылка 22286544 от codeonwort\"\u003e22286544\u003c/a\u003e\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/734/problem/E\" title\u003d\"Codeforces Round 379 (Div. 2)\"\u003e734E - Антон и дерево\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eAlthough the input is a tree, I\u0027ll consider it as an undirected graph. If it were C++, I would wrote as follow:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;int\u0026gt; G[MAX];\n\nfor(int i\u003d0; i\u0026lt;n; i++){\n  int u, v;\n  cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v;\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHow to do the same thing in Haskell? To model the sample tree in the problem there are several choices.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/9c/0b/9c0b8f47a6ff54dfa0453bf1581abf6ac248a3cb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch6\u003eList of List\u003c/h6\u003e \u003cpre\u003e\u003ccode\u003eadj \u003d [[], [2,3], [4,5], [1,8,9], [2], [2,6,7], [5], [5], [3], [3,11], [3], [9]]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ei-th element of \u003ccode\u003eadj\u003c/code\u003e is the list of neighbors of vertex i. It\u0027s definitely useless because we need random access on vertices. random access on list, well, good luck.\u003c/p\u003e\u003ch6\u003eAdjacency matrix using 2D array\u003c/h6\u003e\u003cp\u003en up to 200000. At least 1525 GB of memory is needed :(\u003c/p\u003e\u003ch6\u003eAdjacency list using \u003ccode\u003eData.Map.Strict\u003c/code\u003e\u003c/h6\u003e \u003cpre\u003e\u003ccode\u003eimport qualified Data.Map.Strict as Map\ntype Graph \u003d Map.Map Int [Int]\ntype Edge \u003d (Int,Int)\n\nbuildG :: [Edge] -\u0026gt; Graph\nbuildG es \u003d foldl addEdge Map.empty es\n\naddEdge :: Graph -\u0026gt; Edge -\u0026gt; Graph\naddEdge g (u,v) \u003d Map.insertWith (++) u [v] (Map.insertWith (++) v [u] g)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is a walkable approach, but we can do better regarding that vertices are numbered in compact from 1 to n.\u003c/p\u003e\u003ch6\u003eAdjacency list using \u003ccode\u003eData.Array\u003c/code\u003e\u003c/h6\u003e \u003cpre\u003e\u003ccode\u003eimport Data.Array\nimport Data.Tuple (swap)\n\ntype Graph \u003d Array Int [Int]\n\nbuildG :: [Edge] -\u0026gt; Int -\u0026gt; Graph\nbuildG es n \u003d accumArray (flip (:)) [] (1,n) es\n\nmain \u003d do\n    ...\n    edges \u0026lt;- ...\n    let edges\u0027 \u003d edges ++ (map swap edges)\n    let g \u003d buildG edges\u0027 n\n    ...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eGraph representation is fine. To calculate the diameter of it, we need two vertices in longest distance. It\u0027s simple:\u003c/p\u003e \u003col\u003e   \u003cli\u003eStart DFS or BFS on random vertex (say, 1). Find a vertex with maximum level. Let\u0027s call it \u003ccode\u003eu\u003c/code\u003e.\u003c/li\u003e   \u003cli\u003eStart DFS or BFS on vertex \u003ccode\u003eu\u003c/code\u003e. Find a vertex with maximum level. Let\u0027s call it \u003ccode\u003ev\u003c/code\u003e.\u003c/li\u003e   \u003cli\u003eThe diameter is the level of \u003ccode\u003ev\u003c/code\u003e.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eIt\u0027s a piece of cake to implement above in C++, but it\u0027s not that simple in Haskell.\u003c/p\u003e\u003cp\u003eI seperated the traversal into two steps: generating a list that represents DFS order and creating an array of tuples of (vertex, level). Here is my first try to generate the DFS order list:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epreorder :: Graph -\u0026gt; Int -\u0026gt; [(Int,Int)]\npreorder g start \u003d dfs start start where\n    dfs parent v \u003d (v,parent) : concatMap (dfs v) (filter (/\u003d parent) (g ! v))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn this problem we need to compare a vertex\u0027s color with it\u0027s parent vertex\u0027s color, so I zipped each vertex with it\u0027s parent.\u003c/p\u003e\u003cp\u003eAt first it looked simple, elegant, and efficient... until I got TLE. this version of \u003ccode\u003epreorder\u003c/code\u003e is incredibly slow as \u003ccode\u003en\u003c/code\u003e (number of vertices) goes big. For example,\u003c/p\u003e \u003cpre\u003e\u003ccode\u003en \u003d 200000\ncolors \u003d 1 0 1 0 1 0 1 0 ...\nedges \u003d 1 2\n        2 3\n        3 4\n        ...\n        199999 200000\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFor this simple chain \u003ccode\u003epreorder\u003c/code\u003e took 50 seconds to terminate. I guess \u003ccode\u003econcatMap\u003c/code\u003e part is the bottleneck, but can\u0027t assure. If someone knows the exact reason, please let me know.\u003c/p\u003e\u003cp\u003eUPD: Thinking \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/koosaga\" title\u003d\"Гроссмейстер koosaga\"\u003ekoosaga\u003c/a\u003e\u0027s suggestion I expanded the evaluation of \u003ccode\u003edfs\u003c/code\u003e. In the case above all of adjacency lists contain just one neighbor vertex. So it is expanded like this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e(1,1) : ((2,1) ++ []) : ((3,2) ++ []) : .... : ((n,n-1) ++ []) : []\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt\u0027s time complexity is O(n). But \u003ccode\u003econcatMap\u003c/code\u003e is defined using \u003ccode\u003efoldr\u003c/code\u003e which lazy evaluate expressions. \u003ccode\u003edfs\u003c/code\u003e constructs a very long expression containing up to 200000 calls of \u003ccode\u003efoldr\u003c/code\u003e and then starts to evaluate the expression. I think building this expression takes most of the execution time.\u003c/p\u003e\u003cp\u003eNext try was generating BFS order. In this time I used \u003ccode\u003eData.Sequence\u003c/code\u003e to merge visit orders.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport qualified Data.Sequence as Seq\nimport Data.Foldable (toList)\n\npreorder :: Graph -\u0026gt; Int -\u0026gt; [(Int,Int)]\npreorder g start \u003d toList $ bfs Seq.empty [(start,start)] where\n    bfs nodes [] \u003d nodes\n    bfs nodes queue \u003d bfs (nodes Seq.\u0026gt;\u0026lt; Seq.fromList queue) (concatMap nexts queue)\n    nexts (v,parent) \u003d map (\\u -\u0026gt; (u,v)) $ filter (/\u003d parent) (g ! v)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003eSeq\u003c/code\u003e is deque-like data structure and the time complexity of merging two \u003ccode\u003eSeq\u003c/code\u003e by \u003ccode\u003e(\u0026gt;\u0026lt;)\u003c/code\u003e is \u003ccode\u003eO(log(min(n,m)))\u003c/code\u003e where n and m are lengths of two sequences. This version of \u003ccode\u003epreorder\u003c/code\u003e was reasonably fast which made me conclude that \u003ccode\u003econcatMap\u003c/code\u003e was the problem.\u003c/p\u003e\u003cp\u003eNow we know in which order vertices should be visited. Traverse the graph and calculate each vertex\u0027s level based on the level of the parent of the vertex. (caution: We didn\u0027t compress the graph, that is we didn\u0027t merge adjacent vertices of same color. So if a vertex \u003ccode\u003ev\u003c/code\u003e and it\u0027s parent have same color, \u003ccode\u003ev\u003c/code\u003e has the same level with its parent.)\u003c/p\u003e\u003cp\u003ecode: \u003ca href\u003d\"/contest/734/submission/22324674\" title\u003d\"Посылка 22324674 от codeonwort\"\u003e22324674\u003c/a\u003e\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/734/problem/F\" title\u003d\"Codeforces Round 379 (Div. 2)\"\u003e734F - Антон и школа\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eThe size of arrays \u003ccode\u003eb\u003c/code\u003e and \u003ccode\u003ec\u003c/code\u003e is up to 200000. If We read \u003ccode\u003eb\u003c/code\u003e, \u003ccode\u003ec\u003c/code\u003e and calculate \u003ccode\u003ed\u003c/code\u003e, \u003ccode\u003ea\u003c/code\u003e of the editorial as follow:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003emain \u003d do\n    n \u0026lt;- getInt\n    bs \u0026lt;- getInts                -- defined as problem C\n    cs \u0026lt;- getInts\n    let ds \u003d zipWith (+) bs cs\n    let as \u003d ...                 -- get the original array\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThere will be four \u003ccode\u003e[Int]\u003c/code\u003e, each containing 200000 integers. If a list contains \u003ccode\u003en\u003c/code\u003e integers it consumes \u003ccode\u003e5n\u003c/code\u003e words. In this case 4000000 words \u003d 4000000 * 64 bytes are needed. Well... it\u0027s 244 MB. Moreover we need more arrays than \u003ccode\u003ea\u003c/code\u003e, \u003ccode\u003eb\u003c/code\u003e, \u003ccode\u003ec\u003c/code\u003e, and \u003ccode\u003ed\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eClearly the problem is \u003ccode\u003eList\u003c/code\u003e. Fortunately in this problem we can use unboxed array because all elements of input are required in entire calculation and they are all integers.\u003c/p\u003e\u003cp\u003eAt first, reading input as \u003ccode\u003e[Int]\u003c/code\u003e should be avoided:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport Data.Array.IArray\nimport Data.Array.Unboxed\n\ngetIntArray n \u003d listArray (1,n) `fmap` getInts :: IO (UArray Int Int)\n\nmain \u003d do\n    n \u0026lt;- getInt\n    bs \u0026lt;- getIntArray n\n    cs \u0026lt;- getIntArray n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhat? It construct an unboxed array but still uses \u003ccode\u003egetInts\u003c/code\u003e to build it! But this time that \u003ccode\u003e[Int]\u003c/code\u003e is garbage collected as soon as each integer is filled in the array, so \u003ccode\u003e[Int]\u003c/code\u003e of length 200000 is never made. This is a funny part of Haskell ;)\u003c/p\u003e\u003cp\u003eThere are several lines that contain \u003ccode\u003eelems as\u003c/code\u003e which is passed to \u003ccode\u003emap\u003c/code\u003e and \u003ccode\u003eforM_\u003c/code\u003e as a parameter. My GHC 8.x is fine with traversing array (\u003ccode\u003eas\u003c/code\u003e is \u003ccode\u003eUArray\u003c/code\u003e), but Codeforces\u0027 GHC raise a compile error. I guess array is not an instance of \u003ccode\u003eTraversable\u003c/code\u003e in GHC 7.x. List is surely an instance of \u003ccode\u003eTraversable\u003c/code\u003e, and \u003ccode\u003eelems\u003c/code\u003e returns the list representation of elements of an array.\u003c/p\u003e\u003cp\u003eAs a result total memory usage is 81 MB which is comparable to my C++ code (54 MB.)\u003c/p\u003e\u003cp\u003ecode: \u003ca href\u003d\"/contest/734/submission/22329902\" title\u003d\"Посылка 22329902 от codeonwort\"\u003e22329902\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["haskell"]}}