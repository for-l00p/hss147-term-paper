{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1511206843,"rating":30,"authorHandle":"f2lk6wf90d","modificationTimeSeconds":1511264714,"id":55917,"title":"\u003cp\u003eSolving 894D for arbitrary trees in O(nlog^2n)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThis article is about a solution to a variation of \u003ca href\u003d\"/contest/894/problem/D\" title\u003d\"Codeforces Round 447 (Div. 2)\"\u003e894D - Ralph And His Tour in Binary Country\u003c/a\u003e, with (almost) complete binary trees replaced by arbitrary trees. The solution turned out to be more complicated than I thought, so I decided to post it as a separate blog.\u003cbr /\u003eThe main idea is to fix the LCA, just like the original problem.\u003cbr /\u003eNote: We are calculating the sum of all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eH\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e, such that \u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e1/e2/e1e2504b200b2952a9bc470c09f58191db8af0eb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003ewhere \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is any destination vertex and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is the distance from the root to the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e-th vertex.\u003cbr /\u003e Therefore, we could calculate the answer using the following functions: \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// dist[v] \u003d sorted list of d_x, where x is any node in v\u0027s subtree\n// prefsum[v] \u003d prefix sum array of dist[v]\ntypedef long long i64;\ni64 helper(int v, i64 val) {\n\tif(v \u003d\u003d 0) return 0;\n\tauto x \u003d std::upper_bound(dist[v].begin(), dist[v].end(), val);\n\tif(x \u003d\u003d dist[v].begin()) return 0;\n\ti64 cnt \u003d std::distance(dist[v].begin(), x);\n\treturn cnt * val - prefsum[v][cnt - 1];\n}\ni64 solve(int v, int c, i64 happiness, int start) { // par[root] \u003d 0\n\tif(v \u003d\u003d 0) return 0;\n\ti64 val \u003d happiness - d[start] + 2 * d[v];\n\treturn helper(v, val) - helper(c, val) + solve(par[v], v, happiness, start);\n}\ni64 query(int v, i64 happiness) {\n\treturn solve(v, 0, happiness, v);\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe could use this code to calculate the answer for an arbitrary tree, however queries would take \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/2c/b2/2cb2589007469dce283b39b850b2b46d8df75a79.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time.\u003cbr /\u003eWe can speed this algorithm up by using centroid decomposition. We will create a \u0026quot;centroid tree\u0026quot;, and create a vector for each node that stores the distances from each node to the nodes in its subtree.\u003cbr /\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e be the distance from node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. Then, we need to calculate the sum of all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eH\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e such that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/73/76/73767971e9db5cafe51fcc54a8878f8bf847220d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is an ancestor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e in the centroid tree, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is a node in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e\u0027s subtree, but \u003cem\u003enot\u003c/em\u003e in the subtree containing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003cbr /\u003eNote that we can use the exact same helper function to calculate the answer for a single vertex, however we also need to find a way to subtract the answer for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e\u0027s children. We can reduce subtree queries to range queries on an array using the Euler tour technique.\u003cbr /\u003eWe also need a data structure that supports the following operations:\u003cbr /\u003e1. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecount\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e: count the number of elements in [l, r] such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e.\u003cbr /\u003e2. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e: calculate the sum of elements in [l, r] such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e.\u003cbr /\u003eWe can use a wavelet tree/persistent segment tree/simple segment tree (offline).\u003cbr /\u003eIn the following code, let \u003ccode\u003eidx[v]\u003c/code\u003e be the index of vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in the DFS order, and \u003ccode\u003esz[v]\u003c/code\u003e be the size of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e\u0027s subtree in the centroid tree. Then, the code can be adapted for the centroid tree like this: \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// we build a separate data structure for every vertex\ndata_structure DS[MAXN];\ni64 helper(int v, int l, int r, int val) {\n\tif(l \u0026gt; r) return 0;\n\treturn DS[v].count(l, r, val) * val - DS[v].sum(l, r, val);\n}\ni64 solve(int v, int c, int happiness, int start) {\n\tif(v \u003d\u003d 0) return 0;\n\tint x \u003d idx[c] - idx[v] + 1;\n\tint y \u003d x + sz[c] - 1;\n\ti64 val \u003d happiness - d[v][idx[start] - idx[v] + 1];\n\treturn (c \u003d\u003d 0 ? helper(v, 1, sz[v], val) : helper(v, 1, x - 1, val) + helper(v, y + 1, sz[v], val)) + solve(par[v], v, happiness, start);\n}\ni64 query(int v, i64 happiness) {\n\treturn solve(v, 0, happiness, v);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis solution takes \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/eb/9f/eb9fc3da55d6bb60ce6de7640bf5c6db9619ac3f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time per query. (\u003ccode\u003esolve\u003c/code\u003e is called \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/38/fb/38fb4cb315633ef4d35ba82b8b1e4dafa30fe822.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e times per query, and every \u003ccode\u003ehelper\u003c/code\u003e query takes \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/38/fb/38fb4cb315633ef4d35ba82b8b1e4dafa30fe822.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time.)\u003cbr /\u003e\u003cem\u003eDisclaimer\u003c/em\u003e: This is the first time I have used centroid decomposition. Feel free to point out any flaws in this approach. I will try to post a full solution later. \u003cem\u003eUpdate\u003c/em\u003e: The initial version stated that this was a solution for arbitrary binary trees. It is actually a solution for any tree.\u003c/p\u003e\u003c/div\u003e","tags":[]}}