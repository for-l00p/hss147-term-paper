{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1490077681,"rating":19,"authorHandle":"usernameson","modificationTimeSeconds":1490077927,"id":51121,"title":"\u003cp\u003eBitmasks and Counting Problems\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003eIntroduction\u003c/h4\u003e\u003cp\u003eGenerally bitmasking is used to solve optimisation problems with the following procedure. Store all possible states then pick the best one. Doing this cleverly can sometimes reduce a brute force approach that takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e!)\u003c/span\u003e to something that takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e. However, if you apply the standard bitmasking approach to counting problems you can run into issues.\u003c/p\u003e\u003ch4\u003eA Simple Case\u003c/h4\u003e\u003cp\u003eLet\u0027s consider a simple case where we have three balls, two are red and one is blue and there are two problems. For the first problem we have a function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e that takes balls and spits out a value and we want to optimise \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e. For the second problem we want to count the number of selections of balls we can make where the order of the selection does not matter and the two red balls are indistinguishable. Bitmasking in the usual way works perfectly fine for the first problem. However if we encode each of the balls with its own bit and try to solve the second problem we will get an answer that is too large. Basically our encoding overlooks the fact that red balls are indistinguishable.\u003c/p\u003e\u003ch4\u003eA Solution\u003c/h4\u003e\u003cp\u003eTo solve this problem we can still reserve the first two bits for a red ball. However instead of letting 010 and 001 denote the cases where the one red ball is selected or the other is selected we let 001 denote the case where 1 red ball is selected and 010 where 2 red balls are selected. Of course doing this means 011 will denote the case where three red balls are selected. This means the bitmask 011 will not be valid in our case since so for counting problems we will need to keep track of which bitmasks are valid and check for validity before doing things with them.\u003c/p\u003e\u003ch4\u003eA real problem\u003c/h4\u003e\u003cp\u003eI used the approach outlined to solve colorfulGardenHard from topcoder \u003ca href\u003d\"https://community.topcoder.com/stat?c\u003dproblem_statement\u0026amp;pm\u003d14247\"\u003ehttps://community.topcoder.com/stat?c\u003dproblem_statement\u0026amp;pm\u003d14247\u003c/a\u003e. The basic idea of the question is you have two strings of length at most 15. You want to find how many distinct rearrangements of the the letters there are in the first string such that no two adjacent letters in the first string are the same and no letter in position i of the first string is the same as the letter in position i of the second string. Also because answers can get big we have to return our answer mod 1,000,000,007\u003c/p\u003e\u003ch4\u003eMy approach\u003c/h4\u003e\u003cp\u003eFirst we start storing some basic results about the first string such as which characters appear and how many times they appear. With this information we figure out where to store the counts for each character in a selection in a bitmask. We also create a function called isValid to see check if a given bitmask represents a selection that exceeds the count for a given character. We also make isValid have a parameter n that checks if the number of elements in the selection represented by the bitmask is equal to n. This is useful later for the dynamic programming part.\u003c/p\u003e\u003cp\u003eNow we get to the dynamic programming part. We consider what happens when we have a character sequence of length n that is valid so far that takes a collection of elements represented by a bitmask k and ends in a character represented by j. If we have another character represented by j\u0027 if three conditions hold we can put j\u0027 at the end of j to give a sequence of length n+1 that is valid so far. Two of the conditions are given in the question namely j and j\u0027 cannot be equal and j\u0027 cannot correspond to the character given in n+1th position of the second string. The third condition is the new bitmask we get by appending j\u0027 is this manner must be valid. To get the new bitmask we take the previous bitmask and add 1\u0026lt;\u0026lt;start[j\u0027] to it i.e we are just figuring out where the count for the character j\u0027 is encoded in the bitmask then going there and adding 1 to the count. To test for validity we use our isValid function.\u003c/p\u003e\u003cp\u003eUsing the above reasoning we do our dynamic programming using an array where dp[i][k][j] stores the number of sequences of length i ending in the character represented by j and with a collection of characters represented by the bitmask k. We initially set everything in the array to 0. Then we loop based on the procedure above (in my code I filled row 1 first then started the loop at row 2, however looping immediately should also work).\u003c/p\u003e\u003cp\u003eThe rest is just a matter of summing and taking the modulo diligently to avoid overflow issues when things get large.\u003c/p\u003e\u003cp\u003ecode\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;vector\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n\nconst int MOD\u003d1e9+7;\n\nusing namespace std;\nclass ColorfulGardenHard{\n    vector\u0026lt;int\u0026gt; pos, starts, charCt;\n    \n    //check if k corresponds to a mask with elem elements\n    //and the character count encoded in the mask\n    //does not exceed the total number of characters available\n    bool isValid(int k, int elems){\n        \n        int tot\u003d0;\n        for(int i\u003d0; i\u0026lt;pos.size(); i++){\n            int ct\u003dcharCt[pos[i]];\n            if(i\u003d\u003dpos.size()-1){\n                tot+\u003dk\u0026gt;\u0026gt;starts[i];\n                if(k\u0026gt;\u0026gt;starts[i]\u0026gt;ct)\n                    return false;\n            }\n            else{\n                int s\u003dstarts[i];\n                int e\u003dstarts[i+1];\n                int comp\u003dk\u0026gt;\u0026gt;s;\n                int m\u003d((1\u0026lt;\u0026lt;(e-s))-1);\n                \n                \n                comp\u003dcomp\u0026amp;m;\n                tot+\u003dcomp;\n                if(comp\u0026gt;ct)\n                    return false;\n            }\n           \n       }\n        return tot\u003d\u003delems;\n    }\n                \n                \n                \n        \n        \n    public:\n    int count(string garden, string forbid){\n       \n        //vi stores the counts of every character for a-z \n        //appearing in garden we then store this as charCt\n        //so isValid() can use it\n\n        vector\u0026lt;int\u0026gt; vi(26,0);\n        for(char c:garden){\n            vi[c-\u0027a\u0027]++;\n        }\n        charCt\u003dvi;\n        \n\n        //pos stores the locations of characters\n        //that appear in the string i.e ignore those\n        //with count 0\n        for(int i\u003d0; i\u0026lt;vi.size(); i++){\n            if(vi[i])\n                pos.push_back(i);\n        }\n        \n        int k\u003d0;\n\n        //start stores the for starting points for\n        //each character in the string we assign\n        // in the bitmask representation\n        //this is the key difference between optimisation\n        //problems and counting problems\n        //since we are storing counts of elements \n        //we may need multiple bits to do so\n\n        for(int i:pos){\n            starts.push_back(k);\n            int j\u003d0;                \n            int ct\u003dvi[i];\n            while(ct\u0026gt;\u003d1\u0026lt;\u0026lt;j){\n                k++;\n                j++;\n            }\n        }\n\n        //here is where we use dynamic programming\n        //dp[i][k][j] stores the number of sequences of length i\n        //that make use of the character counts represented by the\n        //bitmask k and end in the character determined by j\n\n        \n        \n        vector\u0026lt;vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;\u0026gt; dp(garden.size()+1,vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;((1\u0026lt;\u0026lt;16),vector\u0026lt;long long\u0026gt;(pos.size(),0)));\n        \n        long long ans\u003d0;\n        for(int j\u003d0; j\u0026lt;pos.size(); j++){\n            if(forbid[0] !\u003d(char)(\u0027a\u0027+pos[j]))\n               dp[1][1\u0026lt;\u0026lt;starts[j]][j]\u003d1;            \n        }\n        for(int i\u003d1; i\u0026lt;garden.size(); i++){\n            for(int j\u003d0; j\u0026lt;pos.size(); j++){\n                for(int k\u003d0; k\u0026lt;1\u0026lt;\u0026lt;16; k++){\n                    if(dp[i][k][j]){\n                        for(int j2\u003d0; j2\u0026lt;pos.size(); j2++){\n                            if(j!\u003dj2 \u0026amp;\u0026amp; forbid[i] !\u003d(char)(\u0027a\u0027+pos[j2]) \u0026amp;\u0026amp; isValid(k+(1\u0026lt;\u0026lt;starts[j2]),i+1))\n                               dp[i+1][k+(1\u0026lt;\u0026lt;starts[j2])][j2]+\u003ddp[i][k][j]%MOD;\n                        }\n                    }\n                }\n            }\n        }\n        \n\n       //getting the answer by summing the number of valid sequences\n       //of length garden.size() that end in j\n       //Although the sum involves k there will only be one value\n       //of k that is non zero namely the value the corresponds\n       //to using all the characters in the string\n        \n        for(int j\u003d0; j\u0026lt;pos.size(); j++){\n            for(int k\u003d0; k\u0026lt;1\u0026lt;\u0026lt;16; k++){\n                ans+\u003ddp[garden.size()][k][j]%MOD;\n                ans%\u003dMOD;\n                                   \n            }\n        }\n        return ans;\n        \n    }\n    \n};\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["dynamic programming","bitmask","combinatorics"]}}