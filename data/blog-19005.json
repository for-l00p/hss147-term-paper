{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1435728941,"rating":0,"authorHandle":"ahmed_fathy_aly","modificationTimeSeconds":1435799040,"id":19005,"title":"\u003cp\u003eDay 10 Analysis\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA \u003ca href\u003d\"/contest/69/problem/A\" title\u003d\"Codeforces Beta Round 63 (Div. 2)\"\u003e69A - Young Physicist\u003c/a\u003e\u003c/p\u003e\u003cp\u003efind sum of the forces on x, sum of the forces on y and sum of the forces on z. The body is in balance if all of them \u003d 0\u003c/p\u003e\u003cp\u003ecode \u003ca href\u003d\"http://pastebin.com/hUn4VdKN\"\u003ehttp://pastebin.com/hUn4VdKN\u003c/a\u003e\u003c/p\u003e\u003cp\u003eB \u003ca href\u003d\"/contest/507/problem/A\" title\u003d\"Codeforces Round 287 (Div. 2)\"\u003e507A - Amr and Music\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe want to take the maximum number of values whose sum \u0026lt;\u003d constant. So we\u0027ll be greedy and take lowest values first. You\u0027ll need to output indices of the chosen items, so you can represent an Item as pair of value, idx or as a class\u003c/p\u003e\u003cp\u003ecode \u003ca href\u003d\"http://pastebin.com/tPw3vPbT\"\u003ehttp://pastebin.com/tPw3vPbT\u003c/a\u003e\u003c/p\u003e\u003cp\u003eC \u003ca href\u003d\"/contest/287/problem/A\" title\u003d\"Codeforces Round 176 (Div. 2)\"\u003e287A - IQ Test\u003c/a\u003e\u003c/p\u003e\u003cp\u003ewe\u0027ll try every 2*2 squares, and find the number of cells painted black. 0 -\u0026gt; we have a 2*2 white square. 1 -\u0026gt; we paint the remaining one white and we have a 2*2 white square. 2 -\u0026gt; we cant convert it to a 2*2 square. 3 -\u0026gt; we paint the remaining one black and we have a 2*2 black square. 4 -\u0026gt; we have a 2*2 black square. that is we check that any square has sum of blck color !\u003d 2\u003c/p\u003e\u003cp\u003ecode \u003ca href\u003d\"http://pastebin.com/40P8rWLE\"\u003ehttp://pastebin.com/40P8rWLE\u003c/a\u003e\u003c/p\u003e\u003cp\u003eD \u003ca href\u003d\"/contest/492/problem/B\" title\u003d\"Codeforces Round 280 (Div. 2)\"\u003e492B - Vanya and Lanterns\u003c/a\u003e\u003c/p\u003e\u003cp\u003eA radius of 0 must be invalid, a radius of infinity must be valid, but what about those inbetween? Say that the answer is 2.5 then 0.5 invalid, 1.0 invalid 1.5 invalid, 2 invalid, 2.5 valid, 3 valid, 3.5 valid, 4.0 valid That means we can binary search for the first valid number, and we\u0027ll need a function that given a radius will tell us whether it is valid or not. This is easy, we\u0027ll sort all the lanterns and for each one we check it reaches the end of the previous one (arr[i-1] + r \u0026gt;\u003d arr[i] — r), and the start of the next one (arr[i] + r \u0026gt;\u003d arr[i+1] — r). and also check the start and end of the street are lit\u003c/p\u003e\u003cp\u003ecode \u003ca href\u003d\"http://pastebin.com/CELrRtZd\"\u003ehttp://pastebin.com/CELrRtZd\u003c/a\u003e\u003c/p\u003e\u003cp\u003eE \u003ca href\u003d\"/contest/270/problem/B\" title\u003d\"Codeforces Round 165 (Div. 2)\"\u003e270B - Multithreading\u003c/a\u003e\u003c/p\u003e\u003cp\u003esay we have 6 threads, then at the beginning the order will be 1 2 3 4 5 6. When some threads get a new message they\u0027ll jump to the beginning, and all of those who never got a new message will remain as they are. for example if we got messages for 5, 3, 1 the new order will be 5 1 2 3 4 6 -\u0026gt; 3 5 1 2 4 6 -\u0026gt; 1 3 5 2 4 6. we\u0027ll notice the elements not changed have the same order 2 4 6, and for sure the element right before 2 is higher than it because it got a new message. So we\u0027ll loop on the number of end to start and if thread[i] \u0026lt; thread[i-1] return i(number of threads before index i).\u003c/p\u003e\u003cp\u003ecode \u003ca href\u003d\"http://pastebin.com/G5BUWWbs\"\u003ehttp://pastebin.com/G5BUWWbs\u003c/a\u003e\u003c/p\u003e\u003cp\u003eF \u003ca href\u003d\"/contest/526/problem/B\" title\u003d\"ZeptoLab Code Rush 2015\"\u003e526B - Om Nom and Dark Park\u003c/a\u003e\u003c/p\u003e\u003cp\u003efirst we find the maximum number of lights in paths to all exits. Now we want every path to have that number of lights. Lets discuss the sample, here the path with the maximum lights is 1-\u0026gt;3-\u0026gt;7 with 8 lights. we\u0027ll make a function called f(node, rem) where node is the index of the destination node, rem is the number of lights we need all paths containing this edge to have number of lights \u003d rem. for example f(2, 8) we have two other paths leading from it, path to 4 which has 3 lights and path to 5 which has 4 lights. any lights added on the edge to 2 increases the number of lights to both of those paths, so we\u0027ll add as much lights as we can on this edge, the maximum lights we can is (rem — lights on this road — max lights in the next two path) then we\u0027ll call f(2*i, newRemaining) and f(2*i+1, newRemaining) where newRemaining is rem — added — lights on this road so the final answer is f(1, maxLights) + f(2, maxLights)\u003c/p\u003e\u003cp\u003ecode \u003ca href\u003d\"http://pastebin.com/Qv8wMExu\"\u003ehttp://pastebin.com/Qv8wMExu\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}