{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1465158133,"rating":37,"authorHandle":"MikhailRubinchik.ru","modificationTimeSeconds":1465233641,"id":45258,"title":"\u003cp\u003e[Analysis] Yandex.Algorithm 2016. Round 1\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello everyone\u003c/p\u003e\u003cp\u003eI created and prepared all problems for the first round of Yandex.Algorithm . Below you will find editorial. I am sorry if something in solutions discriptions is not clear, if you have questions — please ask them in comments.\u003c/p\u003e\u003ch2\u003eProblem A. Cheese\u003c/h2\u003e\u003cp\u003eIf potato takes less time to heat, than cheese to melt, then it is impossible. Otherwise, we either heat the potato a little and then put cheese on it, or heat the cheese to some degree, put it on the potato and continue to heat them together.\u003c/p\u003e\u003ch2\u003eProblem В. Travelling in the Square\u003c/h2\u003e\u003cp\u003eAfter leaving the central square there are four possible directions to go to, on the next step there is a choice from two turns and after that the route is fully determined. Thus, there are only 8 different routes. Each of them can be represented by a single string of length 9. Let’s put these strings in a constant array. While reading the input data let’s ignore all line breaks, so that we have a single string of length 9. Now we just need to find a string in the constant array, that equals to the input string (given that “?” is equal to any symbol).\u003c/p\u003e\u003ch2\u003eProblem С. Opencup\u003c/h2\u003e\u003cp\u003eNote, that if your team is not in top 30, it doesn’t matter which place it took. So let’s think that the only places available are the places from 1 to 31 (the last place means that we should output 1000). For every place from 1 to 30 let’s check whether we can stay in top 10. The worst case scenario is top 10 teams (excluding yours) take top 10 places in the last Grand Prix. Let’s assign a place to each of top 10 teams in such a way, so they would rank higher than you team. That we can do using simple brute-force. The total amount of operations will then be 31 * 10! * 10, which is about a billion. 31 can be replaced with log 31, and that takes us to about 200 million operations, which will probably be enough to get an OK for the solution, if it is implemented efficiently. Otherwise, several straight-forward optimizations will lead to a success. For example, you can check correctness of a permutation while building it. To eliminate a risk of exceeding the Time Limit, you can use a greedy approach when assigning points to top 10 teams.\u003c/p\u003e\u003ch2\u003eProblem D. Cold countries\u003c/h2\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e be the number of pairs (boy + girl) that will eventually sleep next to each other. We are going to solve the problem for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e separately and then sum the answers with coefficients C(p, t). There are 2t! satisfying permutations if we are solving the problem for pairs only. To every such permutation we should now add w — t girls and m — t boys. Between some pairs (or between a pair and a wall) we can put only girls, and between other pairs — only boys. If t is odd, there is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e ways to do it (for both girls and boys), where t \u003d 2x — 1. The number of ways to put boys into permutation then looks like this: m! * C(m + x, x). First multiplier describes the order of boys and the second solves a standard combinatorics problem of putting m objects between t walls. We can then simplify the expression and get (m + x)! / x! (the same for girls). So, for an odd t we have an answer 2 * (t!) * (m + x)! * (w + x)! / x! / x!. We will not compute the answer for an even \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e here, but note, that in this case one should consider two possibilities: when the leftmost person in a first pair a boy and when it is a girl. This solution has O(p * log MOD) complexity, and this is too slow. The second factor appears because of the necessity of performing a division (or finding modular multiplicative inverse). Let’s notice, that we need to find it only for factorials of numbers from 1 to p and 1 / fact[y] \u003d 1/ fact[y — 1] * 1 / y. We can find multiplicative inverse for numbers 1 .. p in O(p log log p) time, using Sieve of Eratosthenes, and then calculate the inverse for composite numbers in O(1), and for primes in log MOD. Also, you could have gotten an OK using only caсhing of already computed values. There is also a linear algorithm for finding multiplicative inverse elements, you can find its’ description in comments to this discussion: \u003ca href\u003d\"http://apps.topcoder.com/forums/?module\u003dThread\u0026amp;threadID\u003d680416\u0026amp;mc\u003d26\u0026amp;view\u003dthreaded\"\u003ehttp://apps.topcoder.com/forums/?module\u003dThread\u0026amp;threadID\u003d680416\u0026amp;mc\u003d26\u0026amp;view\u003dthreaded\u003c/a\u003e\u003c/p\u003e\u003ch2\u003eProblem E. Lillebror and Karlsson\u003c/h2\u003e\u003cp\u003eLet’s represent a chocolate as a binary string of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e which contains \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e ones. We now need to split the string into a minimal amount of substrings, that fit our criteria. The resulting partition will contain \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e strings, of which some consist of ones and zeroes, and some only of zeroes (let’s call them zero-strings). To solve the problem we must minimize the amount of zero-strings. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e be a minimal number of zero-strings in a partition of a prefix of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. We are going to initialize \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d \u003ci\u003ef\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e if \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e + \u003ci\u003ej\u003c/i\u003e) / 2\u003c/span\u003e — integer, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[(\u003ci\u003ei\u003c/i\u003e + \u003ci\u003ej\u003c/i\u003e) / 2] \u003d ‘1’\u003c/span\u003e and there are no other ones between positions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. If there is no such \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, we initialize \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e with infinity. Now we need to update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e], \u003ci\u003ef\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e] + 1])\u003c/span\u003e, using all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e..\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e is a zero-string. Using the fact that all such \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e form a single substring, we can maintain minimum of them and update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e using \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time. We now have a solution with complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003em\u003c/i\u003e)\u003c/span\u003e. Let’s transform it into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e solution. Initialization: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e[0] \u003d 0\u003c/span\u003e; \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d 1\u003c/span\u003e, if there are no ones to the left from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d ‘0’\u003c/span\u003e. Now let’s find initial values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e for all positions between the leftmost (first) ‘1’ and the second one. To do that we’ll need to reverse the array f. If the right end of array “covers” the right “1”, then we just need to delete everything after it. If the right end didn’t reach the right “1”, we need to add some values into array (let’s take a minimal value in the array + 1). After that step we have initial values for all positions between first two ones. Now let’s run through array from left to right and update a value on each position to a (minimum on the prefix with the end in this position) + 1. Similarly, we can calculate f[i] for all positions between second and third “1” and so on. Our array is too long, so we need to compress it. If there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e consecutive values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e we will store corresponding part of array as a pair \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e. Now we can add a bunch of equal values (and in this algorithm we only add equal values) in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time. The amount of deleted values is not greater than the amount of added. Finally, let’s notice, that the difference between maximal and minimal values in the array is 1 or less. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e — position of the minimal element in the array. To the right from it there can’t be a number greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e + 1\u003c/span\u003e. Similarly, on a previous step we could not have had numbers greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e + 1\u003c/span\u003e to the left from it. Thus, our array in compressed form never has more than 3 elements, and we can reverse and run through it in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time. \u003c/p\u003e\u003ch2\u003eProblem F. Dynamic Complexity of String\u003c/h2\u003e\u003cp\u003eFor each border of length g there is a period of length T such that g + T \u003d |S|. Because of that, we can find a minimal period of a string by subtracting from its’ length the length of maximal border. This is derived directly from the definitions of period and border (for more information search the Internet for “border array and period”). Furthermore, if the borders are scanned in decreasing order, the prefix function of each next border will be greater, than the previous one, and that means that minimal period will decrease (or stay the same). After calculating a prefix-function we can in O(1) find complexity for each prefix. To do that take the answer for the maximal border and add 1 if its’ period is different from the period of the next border (in decreasing order). We now know how to find an answer and how to write a checker for the problem. What left is to learn how to find the right string. First, it’s useful to look at known “interesting“ strings, for example “random string”, Zimin strings, Thue–Morse strings, Fibonacci strings, string from identical letters and so on (for more information search the Internet for “combinatorics on words”). In this case we can use Fibonacci strings. Note, that solution to this problem has a practical value. Some string algorithms have complexity O(dynamic complexity of string), and solution described above generates worst-case tests for such algorithms. Dynamic complexity of random strings is O(n), so if your problem can potentially be solved using borders’ analysis, you definitely should add such tests to a testset to increase the perfomance time of those algorithms by log n. \u003c/p\u003e\u003c/div\u003e","tags":[]}}