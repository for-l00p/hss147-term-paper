{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1479055332,"rating":7,"authorHandle":"rahulkhairwar","modificationTimeSeconds":1479055332,"id":48375,"title":"\u003cp\u003eHelp with Codenation contest questions\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThere was a contest by Codenation today (13th Nov, 2016) and there were 3 questions to be solved in 1.5 hours.\u003c/p\u003e\u003cp\u003eQ1) Given a string s, 2 players can remove a single character turn by turn where player 1 starts first. But the condition to remove is that each player can remove a character which is at an index \u0026gt;\u003d the index which was removed previously, and the string gets re indexed after each turn. In the 1st turn player 1 can remove any character. If the final string is lexicographically greater than the original string s, player 1 wins, else player 2 wins. We had to tell who will be the winner.\u003c/p\u003e\u003cp\u003eConstraints :\u003c/p\u003e\u003cp\u003enumber of tests cases \u0026lt;\u003d 10\u003c/p\u003e\u003cp\u003elength of string \u0026lt;\u003d 100\u003c/p\u003e\u003cp\u003eI couldn\u0027t come up with a complete logic during the contest. How can we solve this question?\u003c/p\u003e\u003cp\u003eQ3) We are given n points on a straight line : a0, a1, ...., a(n — 1) (a[i] \u0026gt; 0). Also, there is a starting point, s \u003d 0, and an ending point t (\u0026gt; a[n]). Out of the n + 2 points, we have to choose K + 2 points such that the minimum distance between any 2 consecutive points from the chosen ones is maximum. Also, s and t are always chosen, so essentially we have to choose K out of the n points a[0....n — 1].\u003c/p\u003e\u003cp\u003eFor this, I thought of a dp solution : \u003c/p\u003e\u003cp\u003eFirst I added 0(the starting point) at a0, and shifted the rest by 1 place. Then,\u003c/p\u003e\u003cp\u003eLet dp(i, j, k) \u003d min. dist. b/w any 2 consecutive points by using up to the ith point, with jth point being the previous one, and choosing k points so far.\u003c/p\u003e\u003cp\u003eAnd the base condition will be that to choose exactly 1 point when i \u0026gt;\u003d 1 and j \u0026gt;\u003d 0, dp[i][j][1] \u003d a[1]. I calculated this dp in iterative manner.\u003c/p\u003e\u003cp\u003eThen, I keep track of answer as : \u003c/p\u003e\u003cp\u003eans \u003d INFINITY;\u003c/p\u003e \u003cpre\u003efor (int i \u003d 0; i \u0026lt; n; i++)\n\n    for (int j \u003d 0; j \u0026lt; i; j++)\n\n        ans \u003d min(ans, dp[i][j][K]);\u003c/pre\u003e\u003cp\u003eConstraints :\u003c/p\u003e\u003cp\u003e1 \u0026lt;\u003d n \u0026lt;\u003d 600 1 \u0026lt;\u003d k \u0026lt;\u003d 100 1 \u0026lt;\u003d t \u0026lt;\u003d 11000 1 \u0026lt;\u003d a[i] \u0026lt; t\u003c/p\u003e\u003cp\u003eBut this could clear only 2 out of 3 sample cases. Can someone tell me what\u0027s wrong with this logic? \u003c/p\u003e\u003cp\u003eThank You.\u003c/p\u003e\u003c/div\u003e","tags":["#dp","#strings"]}}