{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1507020487,"rating":5,"authorHandle":"TripleM5da","modificationTimeSeconds":1507228363,"id":54925,"title":"\u003cp\u003eMentor\u0027s Weekly Contest #1 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003ePlease don\u0027t read the Editorial of a Problem, unless you lost all hope in life.\u003c/p\u003e\u003cp\u003eIf you have any questions or Suggestions to improve the contests you are more than welcome to share your opinion with me in the comments.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem A\u003c/strong\u003e : \u003cem\u003eDouble Fence\u003c/em\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTags : Geometry, Convex Hull.\u003c/p\u003e\u003cp\u003eThe problem simply gives you 2 Polygons and asks you if one is inside the other. Now Some of you might be familiar with the name Convex Hull : \u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://en.wikipedia.org/wiki/Convex_hull_algorithms\"\u003ehttps://en.wikipedia.org/wiki/Convex_hull_algorithms\u003c/a\u003e\u003c/p\u003e\u003cp\u003eSo now we can easily deduce that the answer is YES IFF the Convex Hull is equal to one of the two polygons. you can find my implementation for the problem and Convex Hull using Graham Scan here :\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://en.wikipedia.org/wiki/Graham_scan\"\u003ehttps://en.wikipedia.org/wiki/Graham_scan\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ Code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e# include \u0026quot;bits/stdc++.h\u0026quot;\nusing namespace std;\n\n# define F first\n# define S second\n\ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\n\n//Cross Product used for Convex Hull\nll Cross(ii O, ii A, ii B){\n    return (A.F - O.F) * 1ll * (B.S - O.S) - (A.S - O.S) * 1ll * (B.F - O.F);\n}\n//Convex Hull Algorithm\nvector \u0026lt;ii\u0026gt; Convex_Hull(vector\u0026lt;ii\u0026gt; P){\n\n    int n \u003d P.size(), k \u003d 0;\n    if(n \u0026lt; 3)return P;\n    vector\u0026lt;ii\u0026gt;H(n \u0026lt;\u0026lt; 1);\n    sort(P.begin(), P.end());\n    for(int i \u003d 0; i \u0026lt; n; ++i){\n        while(k \u0026gt;\u003d 2 \u0026amp;\u0026amp; Cross(H[k-2], H[k-1], P[i]) \u0026lt; 0)k--;\n        H[k++] \u003d P[i];\n    }\n\n    for(int i \u003d n - 2, t\u003d k + 1; i \u0026gt;\u003d 0; --i){\n        while(k \u0026gt;\u003d t \u0026amp;\u0026amp; Cross(H[k-2], H[k-1], P[i]) \u0026lt; 0)k--;\n        H[k++] \u003d P[i];\n    }\n\n    H.resize(k);\n\n    return H;\n}\n\nint main(){\n\n    int n, m;\n\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\n    //Set1 Saves the first polygon and Set2 Saves the Second Polygon\n    set\u0026lt;ii\u0026gt; st1, st2;\n    //Saves all the points\n    vector\u0026lt;ii\u0026gt; v;\n\n    for(int i \u003d 0; i \u0026lt; n; i++){\n\n        ii x;\n        cin \u0026gt;\u0026gt; x.F \u0026gt;\u0026gt; x.S;\n        st1.insert(x); v.push_back(x);\n\n    }\n    for(int i \u003d 0; i \u0026lt; m; i++){\n\n        ii x;\n        cin \u0026gt;\u0026gt; x.F \u0026gt;\u0026gt; x.S;\n        st2.insert(x); v.push_back(x);\n\n    }\n\n    v \u003d Convex_Hull(v);\n\n    set\u0026lt;ii\u0026gt;cmp;\n\n    for(auto x : v)cmp.insert(x);\n\n    //Check if the Convex Hull is equal to the first or the second Polygon\n    puts((cmp \u003d\u003d st1 || cmp \u003d\u003d st2) ? \u0026quot;YES\u0026quot; : \u0026quot;NO\u0026quot;);\n\n    return 0;\n}\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem B\u003c/strong\u003e : \u003cem\u003eLeading the Scoreboard\u003c/em\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTags : Brute Force\u003c/p\u003e\u003cp\u003eyou are given some submissions in chronological order and you are asked for the number of minutes team 1 will stay in the lead.\u003c/p\u003e\u003cp\u003ethis is a simulation problem when given a submission check if the leader before the submission is team numbered 1 if so add time of submission — time of last submission to your answer.\u003c/p\u003e\u003cp\u003ewhen given a Wrong answer just increment the number of wrong answers for the i — th team on the j — th problem.\u003c/p\u003e\u003cp\u003ewhen given an Accepted first you add to the number of solved problems to the i-th team and increase their penalty by number of their wrong answer * 20 + current time and check if they rise to become the leader then you will change the leader\u003c/p\u003e\u003cp\u003eimplementation using C++ : \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ Code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\nusing namespace std;\n\nmap\u0026lt;string, int\u0026gt; mp;\nchar c[105], d[105], e[105];\nint n, m, p, a[205], b[205], f[205][25];\n\nint main(){\n\n    scanf(\u0026quot;%d %d %d\u0026quot;, \u0026amp;n, \u0026amp;m, \u0026amp;p);\n\n    for(int i \u003d 0; i \u0026lt; n; i++){\n\n        scanf(\u0026quot;%s\u0026quot;, c);\n        mp[(string)c] \u003d i;\n\n    }\n\n    int ans \u003d 0, mx \u003d 0, last \u003d 0, x;\n\n    //List of Submissions in chronological order\n\n    while(m--){\n\n        scanf(\u0026quot;%s%s%d%s\u0026quot;, c, d, \u0026amp;x, e);\n\n        //C-\u0026gt; Name of the team\n        //D-\u0026gt; Problem Name\n        //X-\u0026gt; Time of the Submission\n        //E-\u0026gt; Verdict\n\n        int i \u003d mp[(string)c];\n        int j \u003d d[0] - \u0027A\u0027;\n\n        //ask what is the leader before this submission\n        //if it the first add the difference between last submission and this one\n\n        if(a[0] \u003d\u003d a[mx] \u0026amp;\u0026amp; b[0] \u003d\u003d b[mx])\n            ans +\u003d x - last;\n        last \u003d x;\n        if(e[0] \u003d\u003d \u0027O\u0027){\n\n            //increase the number of solved problems for the i - th team \n            //add the penalty of the j-th problem to the i-th team penalty\n            //the number of wrong answers team i got on problem j * 20 + the current time\n\n            a[i]++, b[i] +\u003d x + f[i][j] * 20;\n\n            //if this team rises up to become the leader change the leader (MX)\n\n            if(a[i] \u0026gt; a[mx] || a[i] \u003d\u003d a[mx] \u0026amp;\u0026amp; b[i] \u0026lt; b[mx])\n                mx \u003d i;\n\n        }\n        else f[i][j]++; // increment wrong answers for team i on problem j\n\n    }\n\n    //Check if a[0] is leader till the end of the time.\n\n    if(a[0] \u003d\u003d a[mx] \u0026amp;\u0026amp; b[0] \u003d\u003d b[mx])\n        ans +\u003d 300 - last;\n\n    printf(\u0026quot;%d\\n\u0026quot;, ans);\n\n\n    return 0;\n}\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem C\u003c/strong\u003e : \u003cem\u003ePersonal programming language\u003c/em\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTags : DFS — Topological sorting.\u003c/p\u003e\u003cp\u003ethinking hard enough this problem can be modeled around a basic topological sorting problem, Where for each line you need to build a list with strings ordered from right to left the rest is just a basic dfs and topological sorting you can take a look at the C++ code to see what i am talking about.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ Code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\nusing namespace std;\n\nconst int N \u003d 1e5 + 5;\nstring ans \u003d \u0026quot;\u0026quot;;\nvector\u0026lt; vector\u0026lt; string \u0026gt; \u0026gt; v;\nmap\u0026lt; string, int \u0026gt; mp;\nstring rev[N];\nstring s;\nbool vis[N];\n\nvoid dfs(int u){\n\n    vis[u] \u003d 1;\n\n    //reverse to call the last then the one before it and so on as described in the problem\n\n    reverse(v[u].begin(), v[u].end());\n\n    for(auto to : v[u])if(!vis[mp[to]])\n        dfs(mp[to]);\n\n    // topological sorting\n\n    ans +\u003d rev[u] + \u0026quot; \u0026quot;;\n}\n\nint main(){\n\n    ios_base::sync_with_stdio(0);cin.tie(0);\n\n    int n; cin \u0026gt;\u0026gt; n;\n\n    int ptr \u003d 0;\n\n    for( ; ptr \u0026lt; n; ptr++){\n\n        cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; s;\n        mp[s] \u003d ptr;\n        vector\u0026lt;string\u0026gt;cur;\n\n        //build and adjacency list with a list for every string\n\n        while(true){\n\n            cin \u0026gt;\u0026gt; s;\n\n            if(s \u003d\u003d \u0026quot;\u003d\u0026quot;){\n                cin \u0026gt;\u0026gt; s;\n                reverse(s.begin(), s.end());\n                rev[ptr] \u003d s;\n                v.push_back(cur);\n                break;\n            }\n            else if(s \u003d\u003d \u0026quot;with\u0026quot;){\n                cin \u0026gt;\u0026gt; s;\n                cur.push_back(s);\n            }\n\n        }\n    }\n\n    cin \u0026gt;\u0026gt; s;\n\n    dfs(mp[s]);\n\n    //extra space\n\n    ans.pop_back();\n\n    //reverse due to taking those at last first\n\n    reverse(ans.begin(), ans.end());\n\n    cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0027\\n\u0027;\n\n    return 0;\n}\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem D\u003c/strong\u003e : \u003cem\u003eArchery\u003c/em\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003etags : ADhoc\u003c/p\u003e\u003cp\u003ethis is a basic simulation problem do as he tells you and count\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ePython Code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003en \u003d input()\npts1, pts2 \u003d 0, 0\nxcnt1, xcnt2 \u003d 0, 0\ncnt101, cnt102 \u003d 0, 0\nfor i in range(n):\n        s  \u003d input()\n        if(s \u003d\u003d \u0027M\u0027):continue\n        if(s \u003d\u003d \u0027X\u0027):\n            pts1 +\u003d 10\n            xcnt1 +\u003d 1\n            cnt101 +\u003d 1\n        elif (s \u003d\u003d \u002710\u0027):\n            pts1 +\u003d 10\n            cnt101 +\u003d 1\n        else:\n            pts1 +\u003d ord(s[0]) - ord(\u00270\u0027)\nfor i in range(n):\n        s  \u003d input()\n        if(s \u003d\u003d \u0027M\u0027):continue\n        if(s \u003d\u003d \u0027X\u0027):\n            pts2 +\u003d 10\n            xcnt2 +\u003d 1\n            cnt102 +\u003d 1\n        elif (s \u003d\u003d \u002710\u0027):\n            pts2 +\u003d 10\n            cnt102 +\u003d 1\n        else:\n            pts2 +\u003d ord(s[0]) - ord(\u00270\u0027)\nif(pts1 \u0026gt; pts2):\n    print(\u0027Yuju\u0027)\nelif(pts2 \u0026gt; pts1):\n    print(\u0027Yerin\u0027)\nelif (cnt101 \u0026gt; cnt102):\n    print(\u0027Yuju\u0027)\nelif (cnt102 \u0026gt; cnt101):\n    print(\u0027Yerin\u0027)\nelif (xcnt1 \u0026gt; xcnt2):\n    print(\u0027Yuju\u0027)\nelif (xcnt1 \u0026lt; xcnt2):\n    print(\u0027Yerin\u0027)\nelse:\n    print(\u0027Shoot-off\u0027)\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem E\u003c/strong\u003e : \u003cem\u003eNew GPU\u003c/em\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTags : Binary Search.\u003c/p\u003e\u003cp\u003eSince Cubic Root (N) and Square Root (N) functions are monotonic functions therefore P(N) is a monotonic function thus we can easily binary search the Smallest N where P(N) \u0026gt;\u003d P.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ePython Code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003eA, B, P \u003d map(int, input().split())\n\nlo, hi \u003d 1, 10 ** 18\n\nwhile lo \u0026lt; hi:\n    md \u003d lo + (hi - lo) // 2\n\n    if P * 1.0 \u0026lt;\u003d 1.0 * (A * (md ** (1/3)) + B * (md ** (1/2))) :\n        hi \u003d md\n    else:\n        lo \u003d md + 1\nprint(lo)\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem F\u003c/strong\u003e : \u003cem\u003eTwo Labyrinths\u003c/em\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTags : BFS.\u003c/p\u003e\u003cp\u003eNow for this problem it\u0027s easy to get the idea that we need to compare the shortest paths on both grids and see if they are equal let\u0027s donate that number as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e, now this is actually the main solution with an extra part you need to check that the shortest path from (1, 1) to (n, m) \u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e by walking on both of the grids at the same time you can check my implementation for this solution here.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ Code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\nusing namespace std;\n\nint dx[] \u003d {-1,1,0,0};\nint dy[] \u003d {0,0,-1,1};\n\npair\u0026lt;int, int\u0026gt; q[505 * 505];\n\nchar grid1[505][505];\nchar grid2[505][505];\nint dist[505][505];\nint n, m;\n\nint bfs(int f){\n\n    memset(dist, 63, sizeof dist);\n    int o \u003d dist[0][0];\n\n    //check if the cell is inside the grid and that the cell is not blocked on either grids and you haven\u0027t visited this cell before\n    auto ok \u003d [\u0026amp;](int x, int y, int f)-\u0026gt;bool{\n        if(x \u0026gt;\u003d n || y \u0026gt;\u003d m || x \u0026lt; 0 || y \u0026lt; 0 || dist[x][y] !\u003d o)return 0;\n        if(f !\u003d 0 \u0026amp;\u0026amp; grid2[x][y] \u003d\u003d \u0027#\u0027)return 0;\n        if(f !\u003d 1 \u0026amp;\u0026amp; grid1[x][y] \u003d\u003d \u0027#\u0027)return 0;\n        return 1;\n    };\n\n    int h \u003d 0, t \u003d 0;\n\n    q[t++] \u003d {0, 0};\n    dist[0][0] \u003d 0;\n\n    //get the shortest path\n\n    while(h \u0026lt; t){\n\n        auto cur \u003d q[h++];\n\n        //once arriving at the bottom right cell return true\n\n        if(cur.first \u003d\u003d n-1 \u0026amp;\u0026amp; cur.second \u003d\u003d m-1)\n            return dist[n-1][m-1];\n\n        int x \u003d cur.first;\n        int y \u003d cur.second;\n\n        for(int i \u003d 0; i \u0026lt; 4; i++){\n\n            int nx \u003d x + dx[i];\n            int ny \u003d y + dy[i];\n\n            if(ok(nx, ny, f)){\n                dist[nx][ny] \u003d dist[x][y] + 1;\n                q[t++] \u003d {nx, ny};\n            }\n\n        }\n\n    }\n\n    // couldn\u0027t get there return a large random number so that they can\u0027t match (low probability)\n    return rand()%5000 + 5000;\n}\n\nint main(){\n\n    scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m);\n    for(int i \u003d 0; i \u0026lt; n; i++)\n        for(int j \u003d 0; j \u0026lt; m; j++)\n            scanf(\u0026quot; %c\u0026quot;, \u0026amp;grid1[i][j]);\n    for(int i \u003d 0; i \u0026lt; n; i++)\n        for(int j \u003d 0; j \u0026lt; m; j++)\n            scanf(\u0026quot; %c\u0026quot;, \u0026amp;grid2[i][j]);\n    //check if the shortest path for first \u003d shortest path on the second grid and they can arrive together in that shortest distance\n    puts((bfs(0) \u003d\u003d bfs(1) \u0026amp;\u0026amp; bfs(1) \u003d\u003d bfs(2))? \u0026quot;YES\u0026quot; : \u0026quot;NO\u0026quot;);\n\n    return 0;\n}\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem G\u003c/strong\u003e : \u003cem\u003eReporting on Mars\u003c/em\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003etags : Dynamic Programming — Observation\u003c/p\u003e\u003cp\u003ewe need for every index modulo k to count the number of integers less than 0 and call them \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, and the number of integers more than 0 and call them \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eneg\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, and then we can solve this using dynamic programming where we will solve this using the flowing facts we can change all segments signs by using numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e only, thus we can deduce the following:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003c/span\u003e[0][i] \u003d min(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003c/span\u003e[0][i-1] + \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eneg\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003c/span\u003e[1][i] + \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e)\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003c/span\u003e[1][i] \u003d min(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003c/span\u003e[0][i-1] + \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003c/span\u003e[1][i] + \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eneg\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e)\u003c/p\u003e\u003cp\u003ewhere 0 represents currently being positive and 1 currently being negative\u003c/p\u003e\u003cp\u003eyou can find more details in the commented code : \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ePython Code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003en, k \u003d map(int, input().split())\na \u003d list(map(int, input().split()))\nsv \u003d [[0 for x in range(k)] for y in range(2)]\ndp \u003d [[0 for x in range(k)] for y in range(2)]\ndp[0][0] \u003d 0\ndp[1][0] \u003d 10 ** 9\nfor i in range(n):\n        if(a[i] \u0026lt; 0):sv[1][i%k] +\u003d 1\n        else:\n            sv[0][i%k] +\u003d 1\n#sv[0][i] number of positives of position (i % k)\n#sv[1][i] number of negatives of position (i % k)\nfor i in range(k):\n    #to resume being positive you have to kill all the negatives inside you on this index\n    #or get a negative and flip it\u0027s sign using all the posiitves\n    dp[0][i+1] \u003d min(dp[0][i] + sv[1][i], dp[1][i] + sv[0][i])\n    #to resume being negative kill all the positives inside a positive thus changing their state to a negative\n    #or change all negatives to positives thus having no effects\n    dp[1][i+1] \u003d min(dp[0][i] + sv[0][i], dp[1][i] + sv[1][i])\nprint(dp[0][k])\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem H\u003c/strong\u003e : \u003cem\u003eNo Name\u003c/em\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003etags : Data Structures the first Solution is using a fast data structure that can split and merge strings in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogn\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003ewhile my implementation used treap \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Eta-mu\" title\u003d\"Candidate Master Eta-mu\"\u003eEta-mu\u003c/a\u003e used Skip List he is more than welcome to explain his approach and provide code.\u003c/p\u003e\u003cp\u003ethe treap solution : \u003c/p\u003e\u003cp\u003egiven a insert operation split the suffix and prefix at index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e then merge the treap pointer of the given string and the prefix the re-merge the prefix and suffix.\u003c/p\u003e\u003cp\u003egiven a print operation split the root from the prefix at index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e - 1\u003c/span\u003e and the suffix at index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e + 1\u003c/span\u003e the print the root and don\u0027t forget to re-merge the root with the suffix and prefix\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ Code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;cstring\u0026gt;\nusing namespace std;\n\nstruct treap{\n    char key;\n    int prior,cnt;\n    treap*l,*r;\n    treap(){}\n    treap(char key,int prior):key(key),prior(prior),l(NULL),r(NULL),cnt(1){}\n};\n\ntypedef treap * ptreap;\n\nint cnt(ptreap t){\n    if(!t)return 0;else return t-\u0026gt;cnt;\n}\n\nvoid upd(ptreap\u0026amp;t){\n    if(!t)return ;\n    t-\u0026gt;cnt\u003dcnt(t-\u0026gt;l)+cnt(t-\u0026gt;r)+1;\n}\n\nvoid split(ptreap t,int key,ptreap\u0026amp;l,ptreap\u0026amp;r,int add\u003d0){\n    if(!t)return void(l\u003dr\u003dNULL);\n    upd(t);\n    int ckey\u003dadd+cnt(t-\u0026gt;l)+1;\n    if(ckey\u0026gt;\u003dkey)split(t-\u0026gt;l,key,l,t-\u0026gt;l,add),r\u003dt;else split(t-\u0026gt;r,key,t-\u0026gt;r,r,add+1+cnt(t-\u0026gt;l)),l\u003dt;\n    upd(t);\n}\n\nvoid merge(ptreap\u0026amp;t,ptreap l,ptreap r){\n    upd(l);\n    upd(r);\n    if(!l)t\u003dr;else\n        if(!r)t\u003dl;else\n            if(l-\u0026gt;prior\u0026gt;r-\u0026gt;prior)merge(l-\u0026gt;r,l-\u0026gt;r,r),t\u003dl;else merge(r-\u0026gt;l,l,r-\u0026gt;l),t\u003dr;\n    upd(t);\n}\n\n\nptreap gettreap(string s){\n    ptreap ret\u003dNULL;\n    int i;\n    for(i\u003d0;i\u0026lt;s.length();i++)merge(ret,ret,new treap(s[i],(rand()\u0026lt;\u0026lt;15)+rand()));\n    return ret;\n}\n\nvoid writetreap(ptreap t){\n    if(!t)return;\n    writetreap(t-\u0026gt;l);\n    cout\u0026lt;\u0026lt;t-\u0026gt;key;\n    writetreap(t-\u0026gt;r);\n}\n\nptreap root, lft, rt, instreap, tmplft, tmprt;\n\nint main(){\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n\n  string s;\n  cin \u0026gt;\u0026gt; s;\n  int idx, l, r;\n\n  root \u003d gettreap(s);\n\n  while(true){\n    cin \u0026gt;\u0026gt; s;\n    if(s \u003d\u003d \u0026quot;END\u0026quot;)break;\n    if(s \u003d\u003d \u0026quot;I\u0026quot;){\n\n      cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; idx;\n      idx++;\n\n      //split the root into a prefix and a suffix\n\n      split(root, idx, lft, rt);\n      instreap \u003d gettreap(s);\n\n      // merge the prefix and the new treap pointer\n      merge(lft, lft, instreap);\n      // merge the suffix and the prefix into the root\n      merge(root, lft, rt);\n\n    }\n    else{\n      cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r;\n\n      l++, r++;\n\n\n      //split the root from it\u0027s prefix\n      split(root, l, lft, rt);\n      // split the root from it\u0027s suffix\n      split(rt, r - l + 2, tmplft, tmprt);\n\n      //write the root   \n      writetreap(tmplft);\n\n      //REMERGE\n\n      merge(rt, tmplft, tmprt);\n      merge(root, lft, rt);\n      cout \u0026lt;\u0026lt; \u0027\\n\u0027;\n    }\n\n  }\n\n}\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003etags: Data Structures and Divide and Conquer.\u003c/p\u003e\u003cp\u003ethis Solution depends on a Certain application using segment tree we need to process the queries off — line last in first out.\u003c/p\u003e\u003cp\u003eif given a insert operation we need to find the first index on the segment tree has i visited indexes on it\u0027s left this can be done using binary search and binary indexed tree however this uses \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogn\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e while Segment tree can do it using Divide and Conquer on a Segment tree you can find it\u0027s details and implementation in the commented C++ Code Below.\u003c/p\u003e\u003cp\u003eif given a print operation we know that all the index he is talking about is still not visited, so all we need to do is find the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e - \u003ci\u003eL\u003c/i\u003e + 1\u003c/span\u003e non-visited indexes can bed done using divide and Conquer too commented in the code.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ Code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\nusing namespace std;\n\n#define F first\n#define S second\n\ntypedef long long ll;\ntypedef pair\u0026lt;int, int\u0026gt; ii;\n\nconst int N \u003d 2e5 + 5;\nint tree[4 * N];\nchar txt[4 * N];\nstring all;\n\nstruct node{\n    int tp, l, r;\n    char c;\n    node(){}\n    node(int tp, int l, int r, char c):tp(tp), l(l), r(r), c(c){}\n};\n\nvoid pull(int node){\n    tree[node] \u003d tree[node \u0026lt;\u0026lt; 1] + tree[node \u0026lt;\u0026lt; 1 | 1];\n}\n\n\nvoid build(int node, int s, int e){\n    if( s \u003d\u003d e ){\n        all.push_back(txt[node]);\n        return;\n    }\n    int md \u003d (s + e) \u0026gt;\u0026gt; 1;\n    build(node \u0026lt;\u0026lt; 1, s, md);\n    build(node \u0026lt;\u0026lt; 1 | 1, md + 1, e);\n\n}\nvoid upd(int node, int s, int e, int k, char c){\n\n    //get the k-th non visited index\n\n    if(s \u003d\u003d e){\n        tree[node] \u003d 1;\n        txt[node] \u003d c;\n      //  cerr \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; txt[node] \u0026lt;\u0026lt; \u0027\\n\u0027;\n        return;\n    }\n\n    int md \u003d (s + e) \u0026gt;\u0026gt; 1;\n\n    //how many non - visited indexes is there on the left child\n    // if they are more than or equal k then the index you are looking for is in the left child range\n\n    if((md - s + 1) - tree[node \u0026lt;\u0026lt; 1] \u0026gt;\u003d k)\n        upd(node \u0026lt;\u0026lt; 1, s, md, k, c);\n    //else you are looking for the K - (non_visited place in the left child) on the right range.\n    else\n        upd(node \u0026lt;\u0026lt; 1 | 1, md + 1, e, k - ((md - s + 1) - tree[node \u0026lt;\u0026lt; 1]), c);\n\n    pull(node);\n\n}\n\nint qry(int node, int s, int e, int k){\n    //same as above\n    if(s \u003d\u003d e){\n        return s;\n    }\n    int md \u003d  (s + e) \u0026gt;\u0026gt; 1;\n    //is it on the left child\n    if((md - s + 1) - tree[node \u0026lt;\u0026lt; 1] \u0026gt;\u003d k)\n        return qry(node \u0026lt;\u0026lt; 1, s, md, k);\n    //if no then it\u0027s on the right\n    return qry(node \u0026lt;\u0026lt; 1 | 1, md + 1, e, k  - ((md - s + 1) - tree[node \u0026lt;\u0026lt; 1]) );\n\n}\n\nint main(){\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    string s;\n    cin \u0026gt;\u0026gt; s;\n    int n \u003d s.size();\n    vector\u0026lt;node\u0026gt;qrys;\n\n    //assign the string as queries\n\n    for(int i \u003d 0; i \u0026lt; s.size(); i++)\n        qrys.push_back(node(0, i, i, s[i]));\n\n    //push_back all the queries at first\n\n    while(cin \u0026gt;\u0026gt; s \u0026amp;\u0026amp; s[0] !\u003d \u0027E\u0027){\n\n        if(s[0] \u003d\u003d \u0027P\u0027){\n            int l, r;\n            cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r;\n            qrys.push_back(node(1, l, r, \u0027#\u0027));\n        }\n        else{\n            int idx;\n            cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; idx;\n            n +\u003d s.size();\n            for(auto c : s)\n                qrys.push_back(node(0, idx, idx, c)), idx++;\n\n        }\n\n    }\n\n    //process them from last to first\n\n    vector\u0026lt; vector \u0026lt; int \u0026gt; \u0026gt; out;\n\n    for(int i \u003d qrys.size() - 1; i \u0026gt;\u003d 0; i--){\n        node go \u003d qrys[i];\n        //when finding a char mark it as visited\n        if(go.tp \u003d\u003d 0){\n            upd(1, 0, n, go.l + 1, go.c);\n       }\n        else{\n            vector\u0026lt;int\u0026gt;a;\n            for(int j \u003d go.l; j \u0026lt;\u003d go.r; j++)\n                a.push_back(qry(1,0,n,j+1));\n            out.push_back(a);\n        }\n\n    }\n\n    build(1,0,n);\n\n    for(int i \u003d out.size()-1; i \u0026gt;\u003d 0; i--, cout \u0026lt;\u0026lt; \u0027\\n\u0027)\n        for(int j \u003d 0; j \u0026lt; out[i].size(); j++)\n            cout \u0026lt;\u0026lt; all[out[i][j]];\n\n\n\n    return 0;\n}\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem I\u003c/strong\u003e : \u003cem\u003e#TheDress\u003c/em\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003etags : Adhoc\u003c/p\u003e\u003cp\u003eanother easy implementation problem you can look at the code it explains everything.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ePython Code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003en \u003d int(input())\n\nhumans, aliens, other \u003d 0,0,0\n\nfor i in range(n):\n    s \u003d str(input())\n\n    if(\u0027black\u0027 in s and \u0027blue\u0027 in s):\n            humans +\u003d 1\n    elif \u0027white\u0027 in s and \u0027gold\u0027 in s:\n            aliens +\u003d 1\n    else:\n        other +\u003d 1\n\nprint (\u0026quot;{0:.5f}\u0026quot;.format(100 * humans / n))\nprint (\u0026quot;{0:.5f}\u0026quot;.format(100 * aliens / n))\nprint (\u0026quot;{0:.5f}\u0026quot;.format(100 * other / n))\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eProblem J\u003c/strong\u003e : \u003cem\u003eAnnoying Mathematics\u003c/em\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003etags : Observation — Inclusion Exclusion Principle — Backtrack — Number theory — Greedy\u003c/p\u003e\u003cp\u003ethere is a little thing to notice at first we need to get the multiplication of number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e with the least number of used numbers then after that we can fill the rest of the numbers with dummies.\u003c/p\u003e\u003cp\u003eAnother thing to observe is that to implement this greedy solution, the Prime factorization of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e has no more than \u003cspan class\u003d\"tex-span\"\u003e10\u003c/span\u003e distinct Primes which is a really small number so small that we can backtrack on it, now another thing to note is that using any number that doesn\u0027t have at least (one \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e is the power of a prime when factorizing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e) is a waste of time.\u003c/p\u003e\u003cp\u003ethus every iteration we will use a backtrack solution we will get the maximum number which is a combination of powers of prime factors of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e and less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e then divide \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e by it, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e gets to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e we have done our job and we check that we didn\u0027t use more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e numbers else if at a time we can\u0027t get a combination of factors and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e is not equal to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e there is no answer now for the dummies part you might think why not generate dummies with a for loop but that isn\u0027t fast enough we have to generate them using Backtrack which is explained in the Code.\u003c/p\u003e\u003cp\u003eafter the Backtrack check that you didn\u0027t use numbers less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e to finish the solution.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ Code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\nusing namespace std;\n\ntypedef long long ll;\n\nvector\u0026lt;ll\u0026gt;gen;\nvector\u0026lt;ll\u0026gt;factors;\n\nll N, R, K;\n\nvoid go(ll x){\n\n    //factorize the K and Save the primes used and the powers of these primes\n\n    for(int i \u003d 2; i *i \u0026lt;\u003d x; i++){\n        ll cur \u003d 1;\n        while(x%i\u003d\u003d0){\n            x /\u003d i;\n            cur *\u003d i;\n        }\n        if(cur!\u003d1){\n            gen.push_back(i);\n            factors.push_back(cur);\n        }\n\n    }\n\n    if(x \u0026gt; 1){\n        factors.push_back(x);\n        gen.push_back(x);\n    }\n\n}\n\nll catch_max(int idx, ll cur){\n    //Backtrack to get the maximum combination of factors\n    if(idx \u003d\u003d factors.size()){\n        return cur \u0026lt;\u003d R ? cur : 1;\n    }\n    return max(catch_max(idx + 1, cur), catch_max(idx + 1, cur / __gcd(cur, factors[idx]) * factors[idx]));\n    assert(false);\n}\nvector\u0026lt;ll\u0026gt;ans;\nll LCM;\nmap\u0026lt;ll, bool\u0026gt;vis;\nvoid bt(int idx, ll cur){\n    //generate dummies through backtrack\n    if(cur \u0026gt; R || LCM % cur !\u003d 0 || ans.size() \u003d\u003d N)return; // this has no potential of being a dummy\n\n    if(idx \u003d\u003d gen.size()){\n        //if it\u0027s not one of the max factors\n        if(!vis[cur])\n            ans.push_back(cur);\n        return;\n    }\n    // you can multiply multiple ones\n    bt(idx, cur * gen[idx]);\n    // or go to next one\n    bt(idx + 1, cur);\n}\nbool chk(ll x){\n    if(vis[x] || LCM / __gcd(LCM, x) * x !\u003d LCM)return 0;\n    return 1;\n}\nvoid kill(){\n    puts(\u0026quot;-1\u0026quot;);\n    exit(0);\n}\nint main(){\n\n    scanf(\u0026quot;%lld%lld%lld\u0026quot;, \u0026amp;N, \u0026amp;R, \u0026amp;K);\n    go(K);\n    LCM \u003d K;\n\n    while(K \u0026gt; 1){\n\n        ll x \u003d catch_max(0,1);\n        if(x \u003d\u003d 1)kill();\n\n        K /\u003d x;\n        vis[x] \u003d 1;\n        ans.push_back(x);\n        for(int i \u003d factors.size() - 1; i \u0026gt;\u003d 0; i--)\n            if(x % factors[i] \u003d\u003d 0)//used this factor won\u0027t need it again\n                    factors.erase(factors.begin()+i);\n\n    }\n\n    if(ans.size() \u0026gt; N)kill();\n    bt(0, 1);\n    if(ans.size() \u0026lt; N)kill();\n\n    sort(ans.begin(), ans.end());\n\n    for(int i \u003d 0; i \u0026lt; N; i++)\n        printf(\u0026quot;%lld%c\u0026quot;, ans[i], (i + 1 \u003d\u003d N? \u0027\\n\u0027 : \u0027 \u0027));\n\n\n\n    return 0;\n}\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}