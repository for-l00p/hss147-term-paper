{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1425737811,"rating":3,"authorHandle":"Fcdkbear","modificationTimeSeconds":1425737811,"id":16826,"title":"\u003cp\u003eРазбор третьей личной тренировки (07.03.2015)\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eВ разборе будет еще несколько challenge-ей, подумайте про них, ответы можете писать в комментариях.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача А\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЧто мы знаем про наше число? То что оно заканчивается на 6, а при умножении его на 3 — получится это же число, циклически сдвинутое вправо на 1\u003c/p\u003e\u003cp\u003eДавайте восстанавливать число, которое обладает этими свойствами. Давайте множить наше число на 3. 6 умножить на 3 дает 18. Значит последнее число результата умножения равно 8, а значит — предпоследнее число искомого числа тоже равно 8. Таким образом мы можем восстановить наименьшее подходящее число — это действительно 2068965517241379310344827586 (мы можем остановить умножение, когда в начале результата умножения мы получим 6 и нам ничего не нужно перенсти в следующий разряд). Когда мы получим это число, результат его умножения на 3 равен 6206896551724137931034482758. Теперь чтобы получить второе по величине искомое число — мы можем продолжить наше умножение на 3. Легко увидеть, что тогда мы получим число 20689655172413793103448275862068965517241379310344827586. То есть k-ое число получается путем записывания начального числа k раз. \u003c/p\u003e\u003cp\u003eЧтобы посчитать остаток его деления на нужное нам число — можно использовать формулу суммы геометрической прогрессии.\u003c/p\u003e\u003cp\u003e\u003cem\u003eChallenge:\u003c/em\u003e Придумайте алгоритм, работающий за сложность \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogK\u003c/i\u003e)\u003c/span\u003e и не использующий факты о геометрической прогрессии.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача B\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eПросто промоделируем то, что сказано в условии. Для хранения результатов игроков удобно использовать map.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача С\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗаведем дерево отрезокв, которое умеет говорить произведение на отрезке. Каждый раз когда поступает запрос на изменение — перестроим его заново (нужно внимательно прочитать условие и увидеть, что запросов такого типа всего лишь 366).\u003c/p\u003e\u003cp\u003e\u003cem\u003eChallenge:\u003c/em\u003e Представим себе похожее решение — только вместо дерева отрезков используется массив частичных произведений. Почему это неправильное решение?\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача D\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eПереберем стартовую вершину и промоделируем всеь процесс. Вобщем-то, все :)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача E\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eДелаем то что просят в условии.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача F\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЧестно говоря, мне не очень понятно как разобрать эту задачу без доски, но я постараюсь.\u003c/p\u003e\u003cp\u003eДавайте сразу определеим отрезок, в котором мы можем делать сдвиги отрезков второго типа.\u003c/p\u003e\u003cp\u003eПредставим себе что координаты маленькие. Тогда для каждого сдвига давайте посчитаем значение ответа, который будет при этом сдвиге. \u003c/p\u003e\u003cp\u003eПереберем все пары \u0026quot;отрезок второго типа — отрезок первого типа\u0026quot;. Что дает нам эта пара? Посчитаем значение сдвига, когда правый конец второго отрезка не пересечется с левым концом первого. С этого момента ответ увеличится на 1 для этого значения сдвига, на 2 — для следующего и т.д и так будет до тех пор, пока левый конец второго отрезка не пересечется с левым концом первого. То есть нам нужно добавить прогрессию на отрезке. Аналогично, можно заметить, что когда правый конец второго отрезкка пересечется с правым концом первого — ответ начнет уменьшаться, причем до тех пор, пока левый конец второго отрезка не пересеечется с правым концом превого. Это тоже добавление какойто прогресси на отрезке. \u003c/p\u003e\u003cp\u003eВ нашем случае координаты большие. Однакое можно увидеть, что интересных точек (точек начала-конца прогрессии) у нас не так уже и много — их \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e. Можно доказать, что ответ имеет смысл искать только в таких точка и соседних с ними (+-1).\u003c/p\u003e\u003cp\u003eКак быстро пересчитывать значения с учетом прогрессий? Можно завести две переменные add и sum. sum показывает текущую набранную сумму. add показвает, сколько нужно доабвить к sum, чтобы корректно перейти к следующей координате. Обновляя эти значения все пересчитывается довольно просто. Детали в коде.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/yK3cPGkh\"\u003eКод\u003c/a\u003e \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача G\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eДавайте заменим начальный массив a на такой:\u003c/p\u003e\u003cp\u003ea[0] — 1; a[1]-a[0]-1; a[2]-a[1]-1....a[n]-a[n-1]-1\u003c/p\u003e\u003cp\u003eЛегко увидеть, что любая операция над начальным массиво равносильна уменьшению на 1 ровно одного элемента нового массива. В игре на этом новом массиве побеждает тот, после хода которого в новом массиве останутся одни 0. Чтобы узнать кто это будет — достаточно посчитать четность общего количества ходов, которые можно сделать.\u003c/p\u003e\u003cp\u003e\u003cem\u003eChallenge:\u003c/em\u003e Решите эту же задачу при условии, что от суффикса можно отнимать любое число (не только 1), не нарушая остальных правил игры.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача H\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗаведем динамику dp[l][r] — сколько минимум букв нам нужно удалить, чтобы подстрока с началом в l и концом в r стала палиндромом. Переходы описываются кодом:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eres\u003d1000000000;\nif (s[l] \u003d\u003d s[r])\n    res \u003d min(res, rec(l + 1, r - 1));\nres \u003d min(res, 1 + rec(l + 1, r));\nres \u003d min(res, 1 + rec(l, r - 1));\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТеперь переберем все подстроки и увидим, правда ли, что значение динамики для них не превышает k.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача I\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eПросто промоделируем то, что сказано в условии. Возможно, кому-то будет полезен код этой задачи:\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/S04TQk9K\"\u003eКод\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["тренировка","разбор"]}}