{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1517843936,"rating":-1,"authorHandle":"LelouchRiBritannia","modificationTimeSeconds":1517910297,"id":57565,"title":"\u003cp\u003e843E AIM Tech Round 4 (Div. 1) tourist\u0027s solution\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eIn \u003ca href\u003d\"/contest/843/problem/E\" title\u003d\"AIM Tech Round 4 (Div. 1)\"\u003e843E - Maximum Flow\u003c/a\u003e it is stated in the tutorial: \u003c/p\u003e\u003cp\u003e\u0026quot;For an each edge from original graph without any flow let\u0027s create a new edge with the same direction and \u003ccode\u003ec \u003d INF\u003c/code\u003e carrying capacity. For every edge with a flow let\u0027s create two edges: the first one with the same direction and \u003ccode\u003ec \u003d 1\u003c/code\u003e capacity and the second edge with reversed direction and \u003ccode\u003ec \u003d INF\u003c/code\u003e.\u0026quot;\u003c/p\u003e\u003cp\u003eWhy do I need the second edge with reversed direction and \u003ccode\u003ec\u003dINF\u003c/code\u003e for the edge with flow? I know it affect the min-cut but I cannot find any specific example. In fact, in one of \u003ca class\u003d\"rated-user user-legendary\" href\u003d\"/profile/tourist\" title\u003d\"Legendary grandmaster tourist\"\u003e\u003cspan class\u003d\"legendary-user-first-letter\"\u003et\u003c/span\u003eourist\u003c/a\u003e submissions \u003ca href\u003d\"/contest/843/submission/29956114\" title\u003d\"Submission 29956114 by tourist\"\u003e29956114\u003c/a\u003e, he didn\u0027t add this edge and still get AC.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e  int n, m, st, fin;\n  scanf(\u0026quot;%d %d %d %d\u0026quot;, \u0026amp;n, \u0026amp;m, \u0026amp;st, \u0026amp;fin);\n  st--; fin--;\n  flow_graph \u0026lt;int\u0026gt; g(n, st, fin);\n  for (int i \u003d 0; i \u0026lt; m; i++) {\n    scanf(\u0026quot;%d %d %d\u0026quot;, from + i, to + i, flag + i);\n    from[i]--; to[i]--;\n    if (flag[i] \u003d\u003d 1) {\n      g.add(from[i], to[i], 1, inf);\n    } else {\n      g.add(from[i], to[i], inf, 0);\n    }\n  }\n  cout \u0026lt;\u0026lt; g.max_flow() \u0026lt;\u0026lt; endl;\n  vector \u0026lt;bool\u0026gt; cut \u003d g.min_cut();\n  flow_graph \u0026lt;int\u0026gt; g2(n + 2, n, n + 1);\n  for (int i \u003d 0; i \u0026lt; m; i++) {\n    if (!flag[i]) {\n      continue;\n    }\n    g2.add(n, to[i], 1, 0);\n    g2.add(from[i], n + 1, 1, 0);\n    g2.add(from[i], to[i], inf - 2, 0);\n  }\n  g2.add(fin, st, inf, 0);\n  g2.max_flow();\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["flow","max-flow min-cut","aimtech round 4"]}}