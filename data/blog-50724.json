{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1488267966,"rating":94,"authorHandle":"niyaznigmatul","modificationTimeSeconds":1488809756,"id":50724,"title":"\u003cp\u003eCodeforces Round #402, Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/779/problem/A\" title\u003d\"Codeforces Round 402 (Div. 2)\"\u003e779A - Pupils Redistribution\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eProblem setter: \u003ca class\u003d\"rated-user user-admin\" href\u003d\"/profile/MikeMirzayanov\" title\u003d\"Headquarters, MikeMirzayanov\"\u003eMikeMirzayanov\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTo solve this problem let\u0027s use array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[]\u003c/span\u003e. We need to iterate through first array with academic performances and for current performance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e let\u0027s increase \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e]\u003c/span\u003e on one. In the same way we need to iterate through the second array and decrease \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e]\u003c/span\u003e on one. \u003c/p\u003e\u003cp\u003eIf after that at least one element of array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[]\u003c/span\u003e is odd the answer is \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e (it means that there are odd number of student with such performance and it is impossible to divide them in two. If all elements are even the answer is the sum of absolute values of array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e\u003c/span\u003e divided by 2. In the end we need to divide the answer on 2 because each change will be counted twice with this way of finding the answer.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/779/problem/B\" title\u003d\"Codeforces Round 402 (Div. 2)\"\u003e779B - Weird Rounding\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eProblem setter: \u003ca class\u003d\"rated-user user-admin\" href\u003d\"/profile/MikeMirzayanov\" title\u003d\"Headquarters, MikeMirzayanov\"\u003eMikeMirzayanov\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTo solve this problem we need to make \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e zeroes in the end of number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Let\u0027s look on the given number as on the string and iterate through it beginning from the end (i.e. from the low order digit). Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e\u003c/span\u003e equals to the number of digits which we reviewed. If the current digit does not equal to zero we need to increase the answer on one. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e\u003c/span\u003e became equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e and we reviewed not all digits we need to print the answer.\u003c/p\u003e\u003cp\u003eIn the other case we need to remove from the string all digits except one, which equals to zero (if there are more than one such digit we left only one of them). Such digit always exists because the problem statement guaranteed that the answer exists.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/779/problem/C\" title\u003d\"Codeforces Round 402 (Div. 2)\"\u003e779C - Dishonest Sellers\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eProblem setters: \u003ca class\u003d\"rated-user user-admin\" href\u003d\"/profile/MikeMirzayanov\" title\u003d\"Headquarters, MikeMirzayanov\"\u003eMikeMirzayanov\u003c/a\u003e and \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/fcspartakm\" title\u003d\"Candidate Master fcspartakm\"\u003efcspartakm\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTo solve this problem we need at first to sort all items in increasing order of values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Then let\u0027s iterate through sorted array. If for the current item \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e we did not buy \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e items now and if after discounts it will cost not more than now, we need to buy it now and pay \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, in the other case we need to buy item \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e after discounts and pay \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/778/problem/A\" title\u003d\"Codeforces Round 402 (Div. 1)\"\u003e778A - String Game\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eProblem setter: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/firezi\" title\u003d\"Expert firezi\"\u003efirezi\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIn this problem we have to find the last moment of time, when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e as a subsequence.\u003c/p\u003e\u003cp\u003eIf at some moment of time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is a subsequence of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e then at any moment before, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is also its subsequence. That\u0027s why the solution is binary search for the number of moves, Nastya makes. For binary search for a moment of time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e we need to check, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is a subsequence of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e. We remove \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ... \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and check if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is a subsequence greedily.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/778/problem/B\" title\u003d\"Codeforces Round 402 (Div. 1)\"\u003e778B - Bitwise Formula\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eProblem setter: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/burakov28\" title\u003d\"Candidate Master burakov28\"\u003eburakov28\u003c/a\u003e\u003c/p\u003e\u003cp\u003eNote that changing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th bit of chosen number doesn\u0027t change any bits of any of the variables other than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th one. Also note that the total number of values is greater, as more variables have 1 at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th position.\u003c/p\u003e\u003cp\u003eLet\u0027s solve for every bit independently: learn, what is the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th bit of chosen number. We can try both values and simulate the given program. Choose one of the values that makes more variables to have 1 at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th position. If both 0 and 1 give equal number of variables to have 1 at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th position, choose 0.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/778/problem/C\" title\u003d\"Codeforces Round 402 (Div. 1)\"\u003e778C - Peterson Polyglot\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eProblem setters: \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/niyaznigmatul\" title\u003d\"International Grandmaster niyaznigmatul\"\u003eniyaznigmatul\u003c/a\u003e and \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/YakutovDmitriy\" title\u003d\"Master YakutovDmitriy\"\u003eYakutovDmitriy\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWhile erasing letters on position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e, trie changes like the following: all the edges from one fixed vertex of depth \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e are merging into one. You can see it on the picture in the sample explanation. After merging of the subtrees we have the only tree — union of subtrees as the result.\u003c/p\u003e\u003cp\u003eConsider the following algorithm. For every vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e iterate over all the subtrees of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e\u0027s children except for the children having largest subtree. There is an interesting fact: this algorithm works in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/08/77/08775a4663313628a1144c3f728523072afef866.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e in total.\u003c/p\u003e\u003cp\u003eDenote as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e the size of the subtree rooted at vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e\u0027s child with the largest subtree, i.e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e\u003c/span\u003e for every \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e — children of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is a child of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e ≠ \u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e then \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6b/49/6b49d13978497b2bee1323aad4ef4d82a63afe35.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Let\u0027s prove that.\u003c/p\u003e \u003col\u003e   \u003cli\u003eLet \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0c/be/0cbe545d1c8dc64b3872e03488ecc4bfcc656c07.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Then \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ca/04/ca04c530b86628c7beb0a670d64f0c86cc423bb6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6b/49/6b49d13978497b2bee1323aad4ef4d82a63afe35.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/li\u003e   \u003cli\u003eOtherwise, if \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/93/40/9340a3426859d983da83a773f2ddae40ef5a04ae.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, then we know that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e \u0026lt; \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Therefore, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/02/7b/027b1fc137b2665b8edc63b02c8fbe4ccc1e165a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eConsider vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e and look at the moments of time when we have iterated over it. Let\u0027s go up through the ancestors of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e. Every time we iterate over \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e the size of the current subtree becomes twice greater. Therefore we could\u0027t iterate over \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e more than \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/10/75/10758feda4d087beb173cfba5ffa524249a2423a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e times in total. It proves that time complexity of this algorithm is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/08/77/08775a4663313628a1144c3f728523072afef866.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eSolution:\u003c/p\u003e \u003col\u003e   \u003cli\u003eIterate over all integers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e up to the depth of the trie\u003c/li\u003e   \u003cli\u003eFor every vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e of depth \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e\u003c/li\u003e   \u003cli\u003eUnite all the subtrees of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e with running over all of them except for the largest one.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eHow to unite subtrees? First method. Find the largest subtree: it has been already built. Try to add another subtree in the following way. Let\u0027s run over smaller subtree\u0027s vertices and add new vertices into respective places of larger subtree. As the result we will have the union of the subtrees of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e\u0027s children. All we need from this union is it\u0027s size. After that we need to roll it back. Let\u0027s remember all the memory cells, which were changed while merging trees, and their old values. After merging we can restore it\u0027s old values in reverse order.\u003c/p\u003e\u003cp\u003eIs it possible to implement merging without rolling back? Second method. Let\u0027s take all the subtrees except for the largest one and build their union using new memory. After that we should have two subtrees: the largest one and the union of the rest. We can find size of their union without any changes. Everything we need is to run over one of these trees examining another tree for the existence of respective vertices. After this we can reuse the memory we have used for building new tree.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/778/problem/D\" title\u003d\"Codeforces Round 402 (Div. 1)\"\u003e778D - Parquet Re-laying\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eProblem setter: \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/pashka\" title\u003d\"Grandmaster pashka\"\u003epashka\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s assume that the width of the rectangle is even (if not, flip the rectangle). Convert both start and final configurations into the configuration where all tiles lie horizontally. After that, since all the moves are reversible, simply reverse the sequence of moves for the final configuration.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/cb/22/cb227bd93b700a5b62c5c9e5a261d4ab82c24080.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eHow to obtain a configuration in which all tiles lie horizontally. Let\u0027s go from top to bottom, left to right, and put all the tiles in the correct position. If the tile lie vertically, then try to turn it into the correct position. If it cannot be rotated, because the neighboring tile is oriented differently, proceed recursively to it. Thus, you get a \u0026quot;ladder\u0026quot;, which can not go further than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e tiles down. At the end of the ladder there will be two tiles, oriented the same way. Making operations from the bottom up, we\u0027ll put the top tile in a horizontal position.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/ad/05/ad0568276ffca5c698e944f500eb44b5c36c2b44.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/778/problem/E\" title\u003d\"Codeforces Round 402 (Div. 1)\"\u003e778E - Selling Numbers\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eProblem setters: \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/niyaznigmatul\" title\u003d\"International Grandmaster niyaznigmatul\"\u003eniyaznigmatul\u003c/a\u003e and \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/VArtem\" title\u003d\"International Grandmaster VArtem\"\u003eVArtem\u003c/a\u003e\u003c/p\u003e\u003cp\u003eBecause the target value for this problem is calculated independently for all digits, we\u0027ll use the dynamic programming approach. Define \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e as the maximum possible cost of digits after we processed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e least significant digits in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e is the set of numbers having the carry in current digit. This information is sufficient to choose the digit in the current position in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and recalculate the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e set and DP value for the next digit.\u003c/p\u003e\u003cp\u003eThe key observation is that there are only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + 1\u003c/span\u003e possible sets instead of \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. Consider last \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e digits of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Sort all the length-\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e suffixes of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e in descending lexicographical order. Because all these suffixes will be increased by the same value, the property of having the carry is monotone. That means that all possible sets \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e are the prefixes of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003em\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e) of this sorted list of suffixes. This fact allows us to reduce the number of DP states to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e·|\u003ci\u003eA\u003c/i\u003e|)\u003c/span\u003e. Sorting all suffixes of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e can be accomplished using the radix sort, appending the digits to the left and recalculating the order.\u003c/p\u003e\u003cp\u003eThe only thing that\u0027s left is to make all DP transitions in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time. To do that, maintain the total cost of all digits and the amount of numbers that have the carry. After adding one more number with carry in current digit, these two values can be easily recalculated. After processing all digits in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e, we have to handle the remaining digits in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (if there are any) and take the best answer. Total running time is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ea/6d/ea6da143a722800be94fb96b1739582130c16983.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003c/div\u003e","tags":["cfr 402","editorial","innopolis"]}}