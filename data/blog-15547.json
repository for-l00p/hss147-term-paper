{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1420195370,"rating":899,"authorHandle":"andreyv","modificationTimeSeconds":1468066427,"id":15547,"title":"\u003cp\u003eCatching silly mistakes with GCC\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eAs you know, the C++ language assumes that the programmer is always correct. Therefore C++ compilers don\u0027t add additional checks to the program, such as checks for null pointer dereference or out-of-bounds array access. This is good, because C++ programs run as fast as possible, and this is bad, because sometimes we may spend a long time debugging some silly mistake. We would want that the compiler can find such mistakes automatically. And many compilers can! In this post I will show various GCC options that do this. Previously \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/zakharvoit\" title\u003d\"Candidate Master zakharvoit\"\u003ezakharvoit\u003c/a\u003e already wrote about this \u003ca href\u003d\"/blog/entry/13875\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eAll options that will follow should be added to the GCC command line. In various IDEs you can do it in IDE or compiler settings. Many of the options can also be used with Clang (for example, in Xcode). For MSVC++, I think, there is nothing better than Debug mode and \u003ccode\u003e/W4\u003c/code\u003e.  \u003c/p\u003e\u003ch2\u003eGCC warnings\u003c/h2\u003e\u003cp\u003eOf course, the first step to debugging is to enable compiler warnings. Even this alone often helps. As a bare minimum I should name \u003ccode\u003e-Wall -Wextra -O2\u003c/code\u003e. The last option is needed because some warnings are only enabled together with optimization. Below I will list some useful options that are not enabled with \u003ccode\u003e-Wall -Wextra\u003c/code\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ccode\u003e-pedantic\u003c/code\u003e — warns about non-standard C++ language extensions. This way you can eliminate stuff that might not be supported by the testing server, and save time needed to rewrite the code. This is best used together with \u003ccode\u003e-std\u003dc++03\u003c/code\u003e or \u003ccode\u003e-std\u003dc++11\u003c/code\u003e. For example, \u003ccode\u003e-pedantic -std\u003dc++03\u003c/code\u003e will warn about\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003eprintf(\u0026quot;%lf\\n\u0026quot;, 1.0);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e— the correct way is\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eprintf(\u0026quot;%f\\n\u0026quot;, 1.0);\n\u003c/code\u003e\u003c/pre\u003e \u003cul\u003e   \u003cli\u003e\u003ccode\u003e-Wshadow\u003c/code\u003e — warns if a declared name shadows the same name in some outer level. For example, this will cause a warning:\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003eint n;\nvoid solve()\n{\n    // Solve the problem\n}\nint main()\n{\n    int n; cin \u0026gt;\u0026gt; n;\n    solve();\n}\n\u003c/code\u003e\u003c/pre\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003e-Wformat\u003d2\u003c/code\u003e — warns if an argument type in \u003ccode\u003eprintf()\u003c/code\u003e/\u003ccode\u003escanf()\u003c/code\u003e does not correspond to the format string. This is partially enabled by \u003ccode\u003e-Wall\u003c/code\u003e, but \u003ccode\u003e-Wformat\u003d2\u003c/code\u003e is more strict.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003e-Wfloat-equal\u003c/code\u003e — warns if two floating point values are compared directly: \u003ccode\u003ea \u003d\u003d b\u003c/code\u003e. Usually the correct way is: \u003ccode\u003efabs(a - b) \u0026lt; eps\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003e-Wconversion\u003c/code\u003e — warns if data can be lost in an implicit conversion.¹ Most often it is accidental assignment of a \u003ccode\u003elong long\u003c/code\u003e value to an \u003ccode\u003eint\u003c/code\u003e variable. I have this warning enabled since I failed a problem by writing \u003ccode\u003epair\u0026lt;int, int\u0026gt;\u003c/code\u003e instead of \u003ccode\u003epair\u0026lt;int, long long\u0026gt;\u003c/code\u003e :)\u003cbr /\u003e\u003cbr /\u003e¹ An explicit cast (for example, \u003ccode\u003e(double)my_long_long_var\u003c/code\u003e) will not trigger this warning.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003e-Wlogical-op\u003c/code\u003e — warns about logical operators in places where GCC expects bitwise operators.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003e-Wshift-overflow\u003d2\u003c/code\u003e — warns about left shift overflows (GCC 6+).\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003e-Wduplicated-cond\u003c/code\u003e — warns about repeated conditions in \u003ccode\u003eif (…) else if (…)\u003c/code\u003e (GCC 6+).\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThere are also \u003ccode\u003e-Wcast-qual\u003c/code\u003e и \u003ccode\u003e-Wcast-align\u003c/code\u003e, but they are less useful (though don\u0027t hurt). You can read more about GCC warnings here: \u003ca href\u003d\"https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html\"\u003ehttps://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html\u003c/a\u003e\u003c/p\u003e\u003ch2\u003eStandard library tools\u003c/h2\u003e\u003cp\u003eBesides the compiler itself, there is also the standard C/C++ library. It also has some options that aid debugging.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ccode\u003e-D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC\u003c/code\u003e — these options turn on \u003ca href\u003d\"https://gcc.gnu.org/onlinedocs/libstdc++/manual/debug_mode.html\"\u003ea special debug mode\u003c/a\u003e in the GNU C++ standard library. In this mode standard containers and algorithms apply various checks. For example, this code\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003eint main()\n{\n    vector\u0026lt;int\u0026gt; v(3);\n    cout \u0026lt;\u0026lt; v[7] \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eprints\u003c/p\u003e\u003cpre\u003e /usr/include/c++/4.9.2/debug/vector:357:error: attempt to subscript \u003cbr /\u003e  container with out-of-bounds index 7, but container only holds 3 \u003cbr /\u003e  elements. \u003c/pre\u003e\u003cp\u003eAnd this code:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint main()\n{\n    int arr[] \u003d { 3, 1, 2 };\n    cout \u0026lt;\u0026lt; binary_search(arr, arr+3, 2) \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eprints\u003c/p\u003e\u003cpre\u003e /usr/include/c++/4.9.2/bits/stl_algo.h:2267:error: elements in iterator\u003cbr /\u003e  range [__first, __last) are not partitioned by the value __val. \u003c/pre\u003e \u003cul\u003e   \u003cli\u003e\u003ccode\u003e-D_FORTIFY_SOURCE\u003d2\u003c/code\u003e (only on Linux/glibc) — this option inserts \u003ca href\u003d\"https://wiki.ubuntu.com/ToolChain/CompilerFlags#A-D_FORTIFY_SOURCE.3D2\"\u003esecurity checks\u003c/a\u003e, such as checks for buffer overflows, into the program. For example, this program:\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003eint main()\n{\n    char s[9];\n    strcpy(s, \u0026quot;too large\u0026quot;);\n    cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ewhen compiled with this option, prints\u003c/p\u003e\u003cpre\u003e *** buffer overflow detected ***: ./a.out terminated \u003c/pre\u003e\u003ch2\u003eGCC tools\u003c/h2\u003e\u003cp\u003eThe GCC compiler also contains tools that help find mistakes in programs.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ccode\u003e-fsanitize\u003daddress\u003c/code\u003e (only in GCC 4.8+ and Clang) — this option inserts memory access checks into the program, such as checks for out-of-bounds accesses. This program:\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003eint arr[3];\n\nint main()\n{\n    for (int i \u003d 0; i \u0026lt;\u003d 3; i++)\n    {\n        arr[i] \u003d i;\n        cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n    }\n    cout \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eprints \u003c/p\u003e\u003cpre\u003e \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003cbr /\u003e \u003d\u003d15496\u003d\u003dERROR: AddressSanitizer: global-buffer-overflow on address 0x00000060152c at pc 0x400ad4 bp 0x7fffbac43e00 sp 0x7fffbac43df0\u003cbr /\u003e WRITE of size 4 at 0x00000060152c thread T0\u003cbr /\u003e . . . \u003c/pre\u003e \u003cul\u003e   \u003cli\u003e\u003ccode\u003e-fsanitize\u003dundefined -fno-sanitize-recover\u003c/code\u003e (only in GCC 4.9+ and Clang) — a similar option that catches \u003ca href\u003d\"http://en.cppreference.com/book/undefined_behavior\"\u003eundefined behavior\u003c/a\u003e, for example, a null pointer dereference. This code:\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003eint main()\n{\n    int *p;\n    cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eprints\u003c/p\u003e\u003cpre\u003e x.cpp:12:14: runtime error: load of null pointer of type \u0027int\u0027 \u003c/pre\u003e\u003cp\u003e\u003ccode\u003e-fsanitize\u003dundefined\u003c/code\u003e can also find divisions by zero, undefined integer shifts, signed integer overflows and leaving a function without a return value.\u003c/p\u003e\u003cp\u003eThese two options are described in \u003ca href\u003d\"https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html\"\u003ehttps://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html\u003c/a\u003e. There is also \u003ca href\u003d\"https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#index-fstack-protector-1070\"\u003ethe \u003ccode\u003e-fstack-protector\u003c/code\u003e option\u003c/a\u003e.\u003c/p\u003e\u003ch2\u003eEverything together\u003c/h2\u003e\u003cp\u003ePutting everything together, we get\u003c/p\u003e\u003cpre\u003e-Wall -Wextra -pedantic -std\u003dc++11 -O2 -Wshadow -Wformat\u003d2 -Wfloat-equal -Wconversion -Wlogical-op -Wshift-overflow\u003d2 -Wduplicated-cond -Wcast-qual -Wcast-align -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC -D_FORTIFY_SOURCE\u003d2 -fsanitize\u003daddress -fsanitize\u003dundefined -fno-sanitize-recover -fstack-protector\u003c/pre\u003e\u003cp\u003eAll this (or selected parts) can be added to GCC command line on the local computer. Therefore, we run a debug-enabled version on our computer, and the usual version on the server. Naturally, the local debug version will be slower — the biggest impact is from the \u003ccode\u003e-fsanitize\u003c/code\u003e options (can cause 2× and more slowdown). But you can easily account for this, and it is a small price to pay. Depending on the compiler version and operating system, \u003cstrong\u003enot every option from this list will work\u003c/strong\u003e — just take such options out.\u003c/p\u003e\u003cp\u003eI hope that this post will help people spend less time debugging and more time solving problems. Good luck :)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD1\u003c/strong\u003e: \u003ca href\u003d\"#comment-205104\"\u003eThere is a problem\u003c/a\u003e with \u003ccode\u003e-D_GLIBCXX_DEBUG\u003c/code\u003e, but a workaround is known. (If \u003ccode\u003estring s; cin \u0026gt;\u0026gt; s;\u003c/code\u003e fails for you, try removing \u003ccode\u003e-fwhole-program\u003c/code\u003e from the command line or adding \u003ccode\u003es.reserve(...);\u003c/code\u003e in the code).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD2\u003c/strong\u003e: Updated options:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eAdded \u003ccode\u003e-fno-sanitize-recover\u003c/code\u003e (GCC 5+)\u003c/li\u003e   \u003cli\u003eRemoved \u003ccode\u003e-lmcheck\u003c/code\u003e (replaced by \u003ccode\u003e-fsanitize\u003daddress\u003c/code\u003e)\u003c/li\u003e   \u003cli\u003eRemoved \u003ccode\u003e-ftrapv\u003c/code\u003e (replaced by \u003ccode\u003e-fsanitize\u003dundefined\u003c/code\u003e)\u003c/li\u003e   \u003cli\u003eRemoved \u003ccode\u003e-fwhole-program\u003c/code\u003e (unstable and is not a debug option)\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eUPD3\u003c/strong\u003e: Added \u003ccode\u003e-Wshift-overflow\u003d2\u003c/code\u003e and \u003ccode\u003e-Wduplicated-cond\u003c/code\u003e (GCC 6+).\u003c/p\u003e\u003c/div\u003e","tags":["c++","gcc","debugging"]}}