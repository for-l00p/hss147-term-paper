{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1401425463,"rating":2,"authorHandle":"Ac-93","modificationTimeSeconds":1401425544,"id":12466,"title":"\u003cp\u003eмодификация алгоритма LCA Тарьяна для леса\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eЗдравствуйте, пусть дана задача нахождения наименьшего общега предка в дереве, допустим в оффлайне, тогда логично писать классический алгоритм Тарьяна. Вопрос как его можно модифицировать для работы на лесе, когда у некоторых вершин может не быть LCA. \u003c/p\u003e\u003cp\u003eЯ вижу 2 варианта: \u003c/p\u003e\u003cp\u003e1) завести дополнительные непересекащиеся множества component[N], положить туда леса, перед выводом LCA проверять что они лежат в одном множестве find(component[a]) \u003d\u003d find(component[b]), при этом трачу дополнительно N памяти, N времени и строчек 15 кода. \u003c/p\u003e\u003cp\u003e2) Сделать фиктивную вершину, провести из нее ребра во все корни деревьев в лесу. Тогда нужно найти корни, чаще всего опять для этого нужно N памяти, при этом легче ошибиться при построении и т.д. В итоге та же память, может быть только строчек будет 10, а не 15. \u003c/p\u003e\u003cp\u003eЕсть ли более красивые варианты как модифицировать LCA, для работы на лесе?\u003c/p\u003e\u003c/div\u003e","tags":["lca","наименьший общий предок"]}}