{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1427298954,"rating":110,"authorHandle":"fcspartakm","modificationTimeSeconds":1427396245,"id":17119,"title":"\u003cp\u003eCodeforces Round #297 (Div.2) Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e\u003ca href\u003d\"http://codeforces.ru/problemset/problem/525/A\"\u003e525A — Vitaliy and Patty\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eTo solve this problem we need to use array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[]\u003c/span\u003e. In this array we will store number of keys of every type, which we already found in rooms, but didn\u0027t use. Answer will store in variable ans. \u003c/p\u003e\u003cp\u003eNow, we iterate on string. If current element of string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is lowercase letter (key), we make \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e]\u003c/span\u003e++. Else if current element of string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e uppercase letter (door) and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003etolower\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)] \u0026gt; 0\u003c/span\u003e, we make \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003etolower\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)]\u003c/span\u003e--, else we make \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003c/span\u003e++. It remains only to print ans. \u003c/p\u003e\u003cp\u003eAsymptotic behavior of this solution — O(\u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003es\u003c/i\u003e|\u003c/span\u003e), where \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003es\u003c/i\u003e|\u003c/span\u003e — length of string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"http://codeforces.ru/problemset/problem/525/B\"\u003e525B — Pasha and String\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAt first we need to understand next fact — it doesn\u0027t matter in wich order make reverses, answer will be the same for all orders. \u003c/p\u003e\u003cp\u003eLet\u0027s numerate elements of string from one. To solve given problem we need to count how many reverses will begin in every position of string. Then we need to count array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e[]\u003c/span\u003e. In \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e we need to store count of reverses of substrings, which begin in positions which not exceeding \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eNow iterate for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e / 2\u003c/span\u003e and if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e is odd swap \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e. After that it remains only to print string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eAsymptotic behavior of this solution — O(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e + \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e), where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e — length of string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e — count of reverses.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"http://codeforces.ru/problemset/problem/525/C\"\u003e525C — Ilya and Sticks\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eThis problem can be solved with help of greedy. At first count array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[]\u003c/span\u003e. In \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e will store how many sticks with length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e we have. \u003c/p\u003e\u003cp\u003eNow iterate for len from maximal length of sticks to minimal. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003elen\u003c/i\u003e]\u003c/span\u003e is odd and we have sticks with length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e - 1\u003c/span\u003e (that is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003elen\u003c/i\u003e - 1] \u0026gt; 0\u003c/span\u003e), make \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003elen\u003c/i\u003e]\u003c/span\u003e-- and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003elen\u003c/i\u003e - 1]\u003c/span\u003e++. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003elen\u003c/i\u003e]\u003c/span\u003e is odd and we have no sticks with length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e - 1\u003c/span\u003e (that is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003elen\u003c/i\u003e - 1] \u003d 0\u003c/span\u003e), make \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003elen\u003c/i\u003e]\u003c/span\u003e--. \u003c/p\u003e\u003cp\u003eIn this way we properly done all sawing which we need and guaranteed that all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003elen\u003c/i\u003e]\u003c/span\u003e is even. After that iterate similary on length of sticks and greedily merge pairs from \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e sticks with the same length in fours. It will be length of sides of sought-for rectangles, left only summarize their squares in answer. In the end can left \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e sticks without pair, we must not consider them in answer. \u003c/p\u003e\u003cp\u003eFor example, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[5] \u003d 6\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[4] \u003d 4\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[2] \u003d 4\u003c/span\u003e, we need to merge this sticks in following way — (\u003cspan class\u003d\"tex-span\"\u003e5, 5, 5, 5\u003c/span\u003e), (\u003cspan class\u003d\"tex-span\"\u003e5, 5, 4, 4\u003c/span\u003e), (\u003cspan class\u003d\"tex-span\"\u003e4, 4, 2, 2\u003c/span\u003e). Two sticks with length \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e are left, we must not count them. \u003c/p\u003e\u003cp\u003eAsymptotic behavior of this solution — O(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + \u003ci\u003emaxlen\u003c/i\u003e - \u003ci\u003eminlen\u003c/i\u003e\u003c/span\u003e), where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e — count of sticks, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emaxlen\u003c/i\u003e\u003c/span\u003e — maximal length of stick, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eminlen\u003c/i\u003e\u003c/span\u003e — minimal length of stick.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"http://codeforces.ru/problemset/problem/525/D\"\u003e525D — Arthur and Walls\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eTo solve this problem we need to observe next fact. If in some square whith size \u003cspan class\u003d\"tex-span\"\u003e2 × 2\u003c/span\u003e in given matrix there is exactly one asterisk, we must change it on dot. That is if in matrix from dots and asterisks is not square \u003cspan class\u003d\"tex-span\"\u003e2 × 2\u003c/span\u003e in which exactly one asterisk and three dots, then all maximum size of the area from dots connected by sides represent rectangles. \u003c/p\u003e\u003cp\u003eNow solve the problem with help of bfs and this fact. Iterate on all asterisks in given matrix and if only this asterisk contains in some \u003cspan class\u003d\"tex-span\"\u003e2 × 2\u003c/span\u003e square, change this asterisk on dot and put this position in queue. Than we need to write standart bfs, in which we will change asterisks on dots in all come out \u003cspan class\u003d\"tex-span\"\u003e2 × 2\u003c/span\u003e squares with exactly one asterisk. \u003c/p\u003e\u003cp\u003eAsymptotic behavior of this solution — O(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e * \u003ci\u003em\u003c/i\u003e\u003c/span\u003e), where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e sizes of given matrix.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"http://codeforces.ru/problemset/problem/525/E\"\u003e525E — Anya and Cubes\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eTo solve this problem we need to use meet-in-the-middle. At first sort given array in increasing order and divide it in two parts. In first part must be first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e / 2\u003c/span\u003e elements, in second part — other. \u003c/p\u003e\u003cp\u003eIterate all submasks of all masks of elements from first part. That is iterate which cubes from first part we take and on which from them we paste exclamation marks. In this way we iterated all possible sums, which we can get with cubes from first part. Let for current submask we get sum sum_lf and use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003elf\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e exclamation marks. To store all such sums we use associative arrays \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e \u0026lt; \u003ci\u003elong\u003c/i\u003e \u003ci\u003elong\u003c/i\u003e \u0026gt; \u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e + \u003cspan class\u003d\"tex-span\"\u003e1]\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e — count of exclamation marks which we have in the beginning. \u003c/p\u003e\u003cp\u003eAfter that similary iterate all submasks of all masks of elements from second part. Let for current submask sum is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003erg\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and number of used exclamation marks is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003erg\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Then from first part we need to get sum (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e - \u003ci\u003esum\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003erg\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e) and we can use only (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - \u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003erg\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e) exclamation marks, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e — sum which we must get by condition of the problem. Then iterate how many exclamation marks we will use in first part (let it be variable cur) and increase answer on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ecur\u003c/i\u003e][\u003ci\u003es\u003c/i\u003e - \u003ci\u003esum\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003erg\u003c/i\u003e\u003c/sub\u003e]\u003c/span\u003e. To accelerate our programm we may increase answer only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ecur\u003c/i\u003e].\u003ci\u003ecount\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e - \u003ci\u003esum\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003erg\u003c/i\u003e\u003c/sub\u003e) \u003d \u003ci\u003etrue\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eFor submasks in iterate we can cut off iteration on current sum for submask (it must be less or equal to given \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e) and on current count of exclamation marks (it must be less or equal to given \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e). Also we should not paste exclamation marks on cubecs with numbers larger than \u003cspan class\u003d\"tex-span\"\u003e18\u003c/span\u003e, because \u003cspan class\u003d\"tex-span\"\u003e19!\u003c/span\u003e more than \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e16\u003c/sup\u003e\u003c/span\u003e — maximal value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eAsymptotic behavior of this solution — O(\u003cspan class\u003d\"tex-span\"\u003e3\u003csup class\u003d\"upper-index\"\u003e((\u003ci\u003en\u003c/i\u003e + 1) / 2)\u003c/sup\u003e * \u003ci\u003elog\u003c/i\u003e(\u003ci\u003emaxcnt\u003c/i\u003e) * \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e), where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e — count of cubes, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emaxcnt\u003c/i\u003e\u003c/span\u003e — maximal size of associative array, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e — count of exclamation marks.\u003c/p\u003e\u003c/div\u003e","tags":["round","297","div2"]}}