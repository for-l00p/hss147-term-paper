{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1399844794,"rating":115,"authorHandle":"fchirica","modificationTimeSeconds":1400060601,"id":12265,"title":"\u003cp\u003eCodeforces Round #245 — Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/430/problem/A\" title\u003d\"Codeforces Round 245 (Div. 2)\"\u003e430A - Точки и отрезки (легкая версия)\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eThe problem asks you to output “-1” if there is no solution. A natural question is now: “when there is no solution”? Try to come up with a test like this! \u003c/p\u003e\u003cp\u003eAfter some analysis, you’ll see anyhow we draw the points and the lines, there will always be a solution. By manually solving small cases, you might already have found the pattern. But for now, let’s assume anyhow we draw points and lines, there will always be a solution. Let’s have a fixed set of points. Then, anyhow we draw a line, there should still be a solution. So, we need to find a coloring of points, such as for every line, |number of red points which belong to it – number of blue points which belong to it| \u0026lt;\u003d 1.\u003c/p\u003e\u003cp\u003eSuppose anytime you color a point with red you assign it +1 value. Also, anytime you color it with blue you assign it -1 value. Then, for a segment, the drawing is good if S \u003d sum of values assigned to points that belong to segment is between -1 and 1 (in other words |S| \u0026lt;\u003d 1). Let’s sort points increasing by abscissa. It’s useful because now, for a segment, there will be a contiguous range of points that belong to that segment. For example, suppose my current segment is [3, 7] and the initial set of points was {4, 1, 5, 2, 8, 7}. Initially, points that belong to the segment would be first, third and sixth. Let’s sort the points by abscissa. It looks like {1, 2, 4, 5, 7, 8}. You can see now there is a contiguous range of points that belongs to [3, 7] segment: more exactly third, fourth and fifth.\u003c/p\u003e\u003cp\u003eWe reduced problem to: given an array, assign it either +1 or -1 values such as, for each subarray (contiguous range), the sum S of subarray’s elements follows the condition |S| \u0026lt;\u003d 1. Before reading on, try to come up with an example by yourself.\u003c/p\u003e\u003cp\u003eMy solution uses the pattern: +1 -1 +1 -1 +1 -1 ... Each subarray of it will have sum of its elements either -1, 0 or 1. How to proof it? When dealing with sums of subarrays, a good idea is to use partial sums. Denote sum[i] \u003d x[1] + x[2] + ... + x[i]. Then, sum of a subarray [x, y] is sum[y] – sum[x – 1]. Partial sums for the pattern looks like: 1 0 1 0 1 0 .... Hence, there are 4 possible cases:\u003c/p\u003e\u003cp\u003e1/ sum[x – 1] \u003d 0 and sum[y] \u003d 0. sum[y] – sum[x – 1] \u003d 0\u003c/p\u003e\u003cp\u003e2/ sum[x – 1] \u003d 1 and sum[y] \u003d 1. sum[y] – sum[x – 1] \u003d 0 \u003c/p\u003e\u003cp\u003e3/ sum[x – 1] \u003d 0 and sum[y] \u003d 1. sum[y] – sum[x – 1] \u003d 1\u003c/p\u003e\u003cp\u003e4/ sum[x – 1] \u003d 1 and sum[y] \u003d 0. sum[y] – sum[x – 1] \u003d -1\u003c/p\u003e\u003cp\u003eHence, each subarray sum is either -1, 0 or 1. So, general algorithm looks like: sort points by abscissa, assign them red, blue, red, blue, ... and then sort them back by original order and print the colors.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/430/problem/B\" title\u003d\"Codeforces Round 245 (Div. 2)\"\u003e430B - Игра с шарами\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eThis is an implementation problem. There is not so much to explain. Perhaps the trick at implementation problems is to divide code into smaller subproblems, easy to code and then put them together. I don’t know if this is the universally truth, but this is how I approach them. Here, there are two main parts: the part when you insert a ball between 2 balls and the part when you see how many balls are destroyed after the move. We can keep an array a[] with initial configuration of balls, then for each insertion create an array b[] with current configuration after the insertion. If my ball is inserted after position pos, b is something like this: b \u003d a[1....pos] + {my_ball} + a[pos+1....n].\u003c/p\u003e\u003cp\u003eFor now we have array b[] and we need to know how many balls will disappear. The problem statement gives us an important clue: no 3 balls will initially have the same color. This means, any time, at most one contiguous range of balls of same color will exist with length at least 3. If it exists, we have to remove it. Then, we have to repeat this process. \u003c/p\u003e\u003cp\u003eSo algorithm is something like bubble sort: while b[] array has changed last step, continue algorithm, otherwise exit it. Now, search an i for which b[i] \u003d b[i + 1] \u003d b[i + 2]. Then, take the maximum j \u0026gt; i for which b[k] \u003d b[i], with i \u0026lt; k \u0026lt;\u003d j. You have to remove from b[] the subarray [i...j] and add j – i + 1 to the destroyed balls. You’ll need to return this sum – 1, because the ball you added wasn’t there at beginning. Pay attention on case when you can’t destroy anything, you need to output 0 instead of -1. There are O(n) positions where you can insert the new ball, for each of them there are maximal O(n) steps when balls are deleted and deleting balls takes maximal O(n) time, so overall complexity is O(n ^ 3). \u003c/p\u003e\u003cp\u003eNote: in my solution, I don’t actually do deletion. If I have to delete a range [i, j] I create a new array c[] \u003d b[1...i – 1] + b[j+1....n] and then copy c[] into b[] array. This guarantees O(n) time for deletion.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/429/problem/A\" title\u003d\"Codeforces Round 245 (Div. 1)\"\u003e429A - Дерево XOR\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eThere is something to learn from “propagating tree” problem, used in round #225. It’s how the special operation works. I’ll copy paste the explanation from there (with some modification, corresponding to the problem):\u003c/p\u003e\u003cp\u003eLet’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on. Now suppose you want to do a special operation to a node x. What nodes from subtree of x will be flipped? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will not be flipped. Sons of sons, located at level L + 2, will be flipped again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be flipped, and nodes located at levels L + 1, L + 3, L + 5 won’t be flipped. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be flipped, and nodes having reminder (L + 1) modulo 2 will not. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, y will be flipped, otherwise it won’t. We’ll use this fact later. For now, let’s think what should be our first operation. Let’s consider some nodes {x1, x2, ..., xk} with property that x1 is son of x2, x2 is son of x3, ... xk-1 is son of xk and parity of levels of these nodes is the same. Suppose by now we fixed {x1, x2, ..., xk-1} (their current value is equal to their goal value), but xk is still not fixed. After some time, we’ll have to fix xk. Now, by doing this, all nodes {x1, x2, ..., xk-1} will get flipped and hence unfixed. We’ve done some useless operations, so our used strategy is not the one that gives minimal number of operations.\u003c/p\u003e\u003cp\u003eWhat we learn from this example? Suppose I want to currently fix a node X. There is no point to fix it now, unless all ancestors Y of X with property level(Y) \u003d level(X) (mod 2) are fixed. But what if an ancestor Y of X is not fixed yet and level(Y) !\u003d level(X) (mod 2)? Can I fix node X now? The answer is yes, as future operations done on Y won’t affect X. But, by same logic, I can firstly fix Y and then fix X, because again operations done on Y won’t affect X. We get a nice property: there is no point to make an operation on a node X unless all ancestors of X are fixed. \u003c/p\u003e\u003cp\u003eHow can we use this property? What should be the first operation? We know that node 1 is the root, hence it always won’t have any ancestor. All other nodes might have sometimes not fixed ancestors, but we know for sure, for beginning, node 1 won’t have any unfixed ancestor (because it won’t have any). So, for beginning we can start with node 1. More, suppose node 1 is unfixed. The only way to fix it is to make an operation on it. Since it’s unfixed and this is the only way to fix it, you’ll be obligated to do this operation. This means, in an optimal sequence of operations, you’ll be obligated to do this operation, too. \u003c/p\u003e\u003cp\u003eSo, if node 1 was unfixed, we did an operation on it. If it was already fixed, we’re done with it. What are next nodes we know for sure that will have all ancestors fixed? Sons of 1, because they have only one ancestor (node 1), which we know it’s fixed. We can only fix them by doing operations of them (doing operations on node 1 / sons of them won’t affect them). Since eventually they have to be fixed and only way to be fixed is to do an operation on them, in an optimal sequence of operations, we’ll have to make operations on them. Let’s move on. What are next nodes that we know for sure all ancestors of them will be fixed? Sons of sons of 1. We can fix them by doing an operation of them, or by doing an operation on 1. But doing an operation on 1 isn’t helpful, because even if it fixes this node, it unfixes 1. Then, you’ll have to do one more operation on 1, which will unfix current node, so we do two useless operations. It turns out, the only way to fix them is to do an operation on them.\u003c/p\u003e\u003cp\u003eGenerally, suppose all ancestors of node x are fixed. We get the current value of node x after the operations done on ancestors of x. If the current value is not the expected one, we’ll have to do an operation on node x (this is the only way to fix the node x). Now, after node x is fixed, we can process sons of it. This strategy guarantees minimal number of operations, because we do an operation only when we’re forced to do it.\u003c/p\u003e\u003cp\u003eThis leads immediately to an O(N ^ 2) algorithm, by every time we need to do an operation to update it to nodes from its subtree. How to get O(N)? Suppose we are at node x and want to know its current value after operations done for its ancestors. Obviously, it is defined by initial value. If we know number of operations done so far by even levels for its ancestors, number of operations done so far by odd levels and current level, we can determine the current value. Suppose these values are (initial_value, odd_times, even_times, level). We observe that 2 operations cancel each other, so we can take this number modulo 2. If level mod 2 \u003d 0, then only even_times will matter, and current_value \u003d (initial_value + even_times) % 2. Otherwise, current_value \u003d (initial_value + odd_times) % 2. \u003c/p\u003e\u003cp\u003eWe can send (even_times, odd_times and level) as DFS parameters, so current_value can be calculated in O(1), and overall complexity is O(N). \u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/429/problem/B\" title\u003d\"Codeforces Round 245 (Div. 1)\"\u003e429B - Тренировка\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eThe particularity of this problem which makes it different by other problem of this kind is that paths need to cross exactly one cell and Iahub can go only right and down, Iahubina can go only right and up. Let\u0027s try to come up with a solution based on these facts. A good start is to analyze configurations possible for meeting cell. Iahub can come either from right or down and Iahubina can come either from right or up. However, if both Iahub and Iahubina come from right, they must have met in other cell as well before (the cell in the left of the meet one). Similarly, if one comes from up and other one from down, their paths will cross either on upper cell, lower cell or right cell.\u003c/p\u003e\u003cp\u003eOnly 2 possible cases are: Iahub comes from right, Iahubina comes from up or Iahub comes from down, Iahubina comes from right. By drawing some skatches on paper, you\u0027ll see next cell visited after meeting one will have the same direction for both of them. More, they will never meet again. So Iahub comes from right, goes to right, Iahubina comes from up, goes to up or Iahub comes from down, goes to down and Iahubina comes from right, goes to right.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/5b/77/5b77db9a231cefd6be58b2146a3fc520624c0692.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eIn the drawing, Iahub\u0027s possible visited cells are blue, Iahubina\u0027s possible visited cells are red and meeting cell is purple. Denote (X, Y) meeting cell. \u003c/p\u003e\u003cp\u003eFor first case, Iahub comes from (1, 1) to (X, Y — 1) by going down or right. Next, he goes from (X, Y + 1) to (N, M) by going down or right. Iahubina goes from (M, 1) to (X + 1, Y) by going up or right and then from (X — 1, Y) to (1, M) by going with same directions. In second case, Iahub goes from (1, 1) to (X — 1, Y) and then from (X + 1, Y) to (N, M) and Iahubina goes from (M, 1) to (X, Y — 1) and then from (X, Y + 1) to (1, M).\u003c/p\u003e\u003cp\u003eWe can precalculate for dynamic programming matrixes and we\u0027re done. \u003c/p\u003e\u003cp\u003edp1[i][j] \u003d maximal cost of a path going from (1, 1) to (i, j) only down and right.\u003c/p\u003e\u003cp\u003edp2[i][j] \u003d maximal cost of a path from (i, j) to (1, m) going only up and right.\u003c/p\u003e\u003cp\u003edp3[i][j] \u003d maximal cost of a path from (m, 1) to (i, j) going only up and right.\u003c/p\u003e\u003cp\u003edp4[i][j] \u003d maximal cost of a path from (i, j) to (n, m) going only down or right.\u003c/p\u003e\u003cp\u003eAnd here is my full implementation of recurrences (C++ only):\u003c/p\u003e \u003cpre\u003efor (int i \u003d 1; i \u0026lt;\u003d n; ++i)\n    for (int j \u003d 1; j \u0026lt;\u003d m; ++j)\n        dp1[i][j] \u003d a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j \u003d m; j \u0026gt;\u003d 1; --j)\n    for (int i \u003d 1; i \u0026lt;\u003d n; ++i)\n        dp2[i][j] \u003d a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i \u003d n; i \u0026gt;\u003d 1; --i)\n    for (int j \u003d 1; j \u0026lt;\u003d m; ++j)\n        dp3[i][j] \u003d a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i \u003d n; i \u0026gt;\u003d 1; --i)\n    for (int j \u003d m; j \u0026gt;\u003d 1; --j)\n        dp4[i][j] \u003d a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);\u003c/pre\u003e\u003cp\u003eAlso, pay attention that meeting points can be cells (i, j) with 1 \u0026lt; i \u0026lt; n and 1 \u0026lt; j \u0026lt; m. (why?)\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/429/problem/C\" title\u003d\"Codeforces Round 245 (Div. 1)\"\u003e429C - Угадай дерево\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eThe constrain n \u0026lt;\u003d 24 immediately suggest us an exponential solution. 24 numbers seems to be not too big, but also not too small. What if we can reduce it by half? We can do this, by analyzing problem’s restriction more carefully.\u003c/p\u003e\u003cp\u003eThe problem states that each internal node has at least two sons. After drawing some trees likes these, one may notice there are a lot of leafs in them. For a tree with this property, number of leafs is at least (n + 1) / 2. We’ll proof this affirmation by mathematical induction. For n \u003d 1, affirmation is true. Now, suppose our tree has n nodes, and the root of it has sons {s1, s2, ..., sk}. Let’s assume subtree of s1 has n1 nodes, subtree of s2 has n2 nodes, ..., subtree of sk has nk nodes. By induction we get that s1 has at least (n1 + 1) / 2 leafs, ..., sk has at least (nk + 1) / 2 leafs. Summing up, we get that our tree has at least (n1 + n2 + ... + nk + k) / 2 leafs. But n1 + n2 + ... + nk \u003d n – 1. So it has at least (n + k – 1) / 2 leafs. But, by hypothesis k \u0026gt;\u003d 2, so our tree has at least (n + 1) / 2 leafs. \u003c/p\u003e\u003cp\u003eFor n \u003d 24, there will be at least 13 leafs, so at most 11 internal nodes. It looks much better now for an exponential solution! Before presenting it, we need one more observation. Suppose we sorted c[] array decreasing. Now, the father of node i can be only one of nodes {1, 2, ..., i – 1}. Nodes {i + 1, i + 2, ..., n} will have at most as much nodes as node i, so they can’t be father of i. By doing this observation we can start algorithm: start with node 1 and assign its sons. Then, move to node 2. If it does not have a father, we won’t have one, so current configuration is good. If he has a father (in this case node 1), then tree is connected so far. So we can assign children of node 2. Generally, if a node i does not have a father when it’s processed, it won’t have in future either. If it has, the tree is connected so far, so we add children of i.\u003c/p\u003e\u003cp\u003eLet’s introduce the following dynamic programming. Let dp[node][mask][leafs] \u003d is it possible to create a tree if all nodes {1, 2, ..., node} have already a father, exactly leafs nodes don’t have one and internal nodes corresponding to 1 in bitmask mask also don’t have one? If you never heart about “bitmask” word, this problem is not good for you to start with. I recommend you problem E from round #191, where I explained more how bitmasks work. Back on the problem. If node has 1 in its bit from the mask, then we know for sure the tree can’t be built. Otherwise, let’s assign sons for node. We take all submasks of mask (number obtained by changing some bits from 1 to 0) and make sum of degrees for corresponding nodes. Denote this number as S. These are the internal nodes. How about the leafs? We need to have available L \u003d c[node] – S – 1 leafs. If L is \u0026lt;\u003d than leafs, we can use them. If L \u0026lt; 0, obviously we can’t build the tree. Will remain obviously leafs – L leafs. The new mask will be mask ^ submask. Also, we need to iterate to node + 1. If dp[node+1][mask ^ submask][leafs – L]. One more condition that needs to be considered: node needs to have at least 2 sons. This means L + cnt \u0026gt; 1 (where cnt are number of internal nodes used). When do we stop the dp? When c[nod] \u003d 1. If mask \u003d 0 and leafs \u003d 0, then we can build the tree. Otherwise, we can’t. \u003c/p\u003e\u003cp\u003eLet’s analyze the complexity. There are O(2 ^ (n / 2)) masks, each of them has O(n) leafs, for each O(n) node. This gives O(2 ^ (n / 2) * n ^ 2) states. Apparently, iterating over all submasks gives O(2 ^ (n / 2)) time for each submask, so overall complexity should be O(4 ^ (n / 2) * n ^ 2). But this complexity is over rated. Taking all submasks for all masks takes O(3 ^ (n / 2)) time, instead of O(4 ^ (n / 2)) time. Why? Consider numbers written in base 3: for a mask and a submask we can assign 3 ternary digits to each bit:\u003c/p\u003e\u003cp\u003e0 if bit does not appear in mask\u003c/p\u003e\u003cp\u003e1 if bit appears in mask but not in submask\u003c/p\u003e\u003cp\u003e2 if bit appears in mask and in submask\u003c/p\u003e\u003cp\u003eObviously, there are O(3 ^ (n / 2)) numbers like this and the two problems are equivalent, so this step takes O(3 ^ (n / 2)) and overall complexity is O(3 ^ (n / 2) * n ^ 2). \u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/429/problem/D\" title\u003d\"Codeforces Round 245 (Div. 1)\"\u003e429D - Хитрая функция\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLet’s define S[i] \u003d a[1] + a[2] + ... + a[i]. Then, f(i, j) \u003d (i – j) ^ 2 + (S[i] – S[j]) ^ 2. Trying to minimize this function seems complicated, so we need to manipulate the formula more. We know from the maths that if f(i, j) is minimized, then also f’(i, j) \u003d sqrt ( (i – j) ^ 2 + (S[i] – S[j]) ^ 2) is also minimized. Does this function look familiar to you? Suppose you get two points in 2D plane: one having coordinates (i, S[i]) and the other one having coordinates (j, S[j]). One can see that f’(i, j) is exactly euclidean distance of those points. So, if f’(i, j) is a distance between two points in plane, when is achieved minimal f’(i, j)? For the closest two points in plane (the points which are located at minimal distance). So, having set of points (i, S[i]), we need to compute closest two points from this plane. There is a classical algorithm that does this in O(n * logn). \u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/429/problem/E\" title\u003d\"Codeforces Round 245 (Div. 1)\"\u003e429E - Точки и отрезки\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eThe problem asks you to check the property for an infinity of points. Obviously, we can’t do that. However, we can observe that some contiguous ranges on OX axis have the same rx and bx values. Like a sweep line algorithm, a possible change may appear only when a new segment begins or when an old one ends. So let’s consider set of points formed by all li reunited with set of points formed by all ri. Sort the values increasing. Suppose the set looks like {x1, x2, ..., xk}. Then ranges [0, x1) [x1, x2) ... [xk-1, xk) [xk, infinity) are the only ones that need to be considered. If we can take an arbitrary point from each range and the property is respected for all points, then the drawing is good. \u003c/p\u003e\u003cp\u003eWe need to color segments. But each segment is a reunion of ranges like the ones from above. When you color a segment, all ranges from it will be colored too. So, after coloring the segments, for each range, |number of times range was colored with blue – number of times range was colored with red| \u0026lt;\u003d 1.\u003c/p\u003e\u003cp\u003eIt’s time to think creative. We can see ranges as vertexes of a graph and segments as edges. For example, if a segment is formed by ranges {Xi, Xi+1, ..., Xj-1, Xj} we add an undirected edge from i to j + 1. We need to color the edges. We divide the graph into connected components and apply same logic for each component. Next, by graph I’ll refer to a connected graph.\u003c/p\u003e\u003cp\u003eLet’s assume that our graph has all degrees even. Then, it admits an eulerian cycle. Suppose {x1, x2, ..., xk} is the list of nodes from the cycle, such as x1-x2 x2-x3 ... xk-x1 are the edges of it, in this order. We apply a rule: if xi \u0026lt; xi+1, we color edge between xi and xi+1 in red. Otherwise, we color it in blue. What happens for a node? Whenever a “red” edge crosses it (for example edge 1-5 crosses node 4) a “blue” edge will always exist to cross it again (for example edge 6-2 crosses node 4). This is because of property of euler cycle: suppose we started from a node x and gone in “left”. We need to return to it, but the only way to do it is an edge which goes to “right”. So, when degrees of graph are all even, for every point on OX axis, difference between rx and bx will be always 0.\u003c/p\u003e\u003cp\u003eLet’s solve the general case now. Some nodes have odd degree. But there will always be an even number of nodes with odd degrees. Why? Suppose the property is respected for some edges added so far and now we add a new one. There are two cases: \u003c/p\u003e\u003cp\u003e1/ the edge connects two nodes with odd degree. in this case, the number of nodes with odd degrees decreases by 2, but its parity does not change.\u003c/p\u003e\u003cp\u003e2/ the edge connects one node with odd degree and one node with even degree. Now, degree of “old” odd one becomes even and degree of “old” even one becomes odd. So number of nodes with odd degrees does not change.\u003c/p\u003e\u003cp\u003eSo suppose the nodes with odd degrees are X1 X2 ... Xk (k is even). Assume X1 \u0026lt; X2 \u0026lt; ... \u0026lt; Xk. If we add one more edge to each of these nodes, an euler cycle would be possible. However, we can’t “add” edges, because edges are segments from the input. But we can imagine them. Of course, this we’ll create an imbalance between red and blue edges, but let’s see how big it is. What if we add a fictive edge between X1 to X2, between X3 to X4, ..., between X(k – 1) to Xk? In this way, all those nodes will have even degree. So for each Xi (i odd) we add a dummy vertex Yi and some dummy edges from Xi to Yi and from Yi to Xi+1. Now let’s see the effect: if the fictive edges existed, the balance would be 0. But they do not exist, so one of rx or bx will decrease. So now |rx – bx| \u0026lt;\u003d 1, good enough for problem’s restrictions.\u003c/p\u003e\u003c/div\u003e","tags":["codeforces","round","245"]}}