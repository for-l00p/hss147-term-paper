{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1475435795,"rating":134,"authorHandle":"ifsmirnov","modificationTimeSeconds":1475435795,"id":47498,"title":"\u003cp\u003eФайлы vs stdin/out\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eПосле начала обсуждения \u003ca href\u003d\"//codeforces.com/blog/entry/47427?locale\u003dru#comment-318486\"\u003eздесь\u003c/a\u003e я решил вынести его в отдельный тред.\u003c/p\u003e\u003cp\u003eЕсть много разных тестирующих систем, и во всех свои политики файлового ввода-вывода. Я встречал много разных: stdin+stdout, a.in/txt, input.txt, $problem.in/txt, где-то даже a.in+stdout. В последнее время, как мне показалось, хорошей практикой считается допускать стандартные потоки, и файловый ввод-вывод. Но предположим, что такого решения нет, и остановимся на первых двух: только файлы или только стандартный ввод-вывод. Что из этого, по-вашему, должна поддерживать тестирующая система?\u003c/p\u003e\u003cp\u003eЯ приведу свои аргументы в пользу stdin/stdout.\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eЧеловек может написать минимальный работающий кусок кода, начав с пустого листа, проверить его работу из консоли и заслать в систему, потратив минимум времени. Есть разные кейсы. Топкодер, где код пишется в арене/на вебсайте; туда же сейчас присоденяются HackerRank, CSAcademy и т.д. Это и мой сегодняшний пример с засыланием предподсчёта, когда основное решение выводит инициализацию массива в отдельный файл, в который я потом в редакторе добавляю условные \u003ccode\u003eint main()\u003c/code\u003e и \u003ccode\u003ecout \u0026lt;\u0026lt; a[n] \u0026lt;\u0026lt; endl\u003c/code\u003e. Это задача А на Codeforces, которую хочется сдать до того, как ты написал шаблон, если шаблона по какой-то причине нет заранее.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eВ файлах есть много разных стилей наименования, в которых легко опечататься. Файлы можно забыть. Да, это проверка на внимательность. Конечно, участник высокого уровня должен уметь и файлы замечать, и приписки в Input Format\u0027е о том, что количество запросов второго типа не превосходит 5, и многое другое подобное. Но сейчас считается хорошим тоном от этого уходить в сторону собственно решения задач. Десять лет назад контест от Андрея Лопатина, где в файлах можно было встретить подколки вида \u0026quot;kitten.in / k1tten.out\u0026quot;, был уместен и свеж. Десять лет назад на финалах просили вывести число ровно с тремя знаками после запятой, ни больше ни меньше, и без ошибок перебить с печатных условий английскую фразу в десяток слов. Сейчас не десять лет назад.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eОтвет на контраргумент \u0026quot;input.txt/output.txt строго удобнее\u0026quot;: не надо за участника решать, как участнику удобнее тестировать локально! Я использую схему \u0026quot;a.in + stdout\u0026quot;, например. Каждая задача в отдельной папке, название файла соответствует названию бинарника с задачей, вывод всегда консольный, потому что файловый бывает нужен крайне редко, а консольный удобнее смотреть. Открытие файла завёрнуто в \u003ccode\u003eifdef\u003c/code\u003e, потому что я его сделал под свои нужды для удобства тестирования, и раз уж я хочу написать непортабельный код, то я сам должен позаботиться о том, чтобы он нигде больше не компилировался. Почему вместо этого я должен заворачивать в \u003ccode\u003eifdef\u003c/code\u003e строки, нужные для взаимодействия с системой?\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eДа начнётся холивар!\u003c/p\u003e\u003c/div\u003e","tags":["holywar"]}}