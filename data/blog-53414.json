{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1500633762,"rating":0,"authorHandle":"BaqablH","modificationTimeSeconds":1500648869,"id":53414,"title":"\u003cp\u003eConcurs Divendres\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003ePosem les solucions dels problemes d\u0027avui. Falta completar i corregir alguna cosa (tant d\u0027aquest concurs com d\u0027algun problema dels altres que hem fet, ho farem durant el dia d\u0027avui). Si teniu algun dubte tant dels problemes com d\u0027algun tema d\u0027olimpiades o que voleu recursos o webs per a aprendre\u0027n més o el que sigui, m\u0027envieu un missatge (ho podeu fer per missatge privat de codeforces o a \u003ca\u003evictormartin96@outlook.com)\u003c/a\u003e. Esperem que hagueu gaudit el concurs.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblema A: LAPAO translator\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eBàsicament una trollejada: Si algú no sap la història, a l\u0027Aragó un govern d\u0027un partit que no nomenaré va decidir que el català que es parlava a la franja d\u0027Aragó no era català sinó LAPAO (Lengua Aragonesa Propia del Aragón Oriental). Força lol aquests del PP. \u003c/p\u003e\u003cp\u003eSimplement, llegiu una línia que no us serveix per a res, i després una altra línia que, a continuació, heu de reescriure.\u003c/p\u003e\u003cp\u003e\u003ccode\u003ePD: la organització demana disculpes per la trollejada\u003c/code\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\nusing namespace std;\n\nint main(){\n\tstring inutil;\n\twhile (getline(cin, inutil)){\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\tcout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblema B: Parells d\u0027una seqüència (2)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eVoleu trobar dos nombres que sumin un nombre senar. És fàcil veure que això només és possible si i només si a la seqüència hi ha almenys un nombre parell i almenys un de senar.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\nusing namespace std;\n\nint main(){\n\tint n;\n\twhile (cin \u0026gt;\u0026gt; n){\n\t\tbool parell \u003d false, senar \u003d false;\n\t\tfor (int i \u003d 0; i \u0026lt; n; ++i){\n\t\t\tint x;\n\t\t\tcin \u0026gt;\u0026gt; x;\n\t\t\tif (x%2 \u003d\u003d 0) parell \u003d true;\n\t\t\telse senar \u003d true;\n\t\t}\n\t\tif (parell and senar) cout \u0026lt;\u0026lt; \u0026quot;si\u0026quot; \u0026lt;\u0026lt; endl;\n\t\telse cout \u0026lt;\u0026lt; \u0026quot;no\u0026quot; \u0026lt;\u0026lt; endl;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblema C: Octàgons Facilets\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003e\u0026quot;Simplement\u0026quot; buscar quants espais i quantes \u0027X\u0027 fan falta en cada part de l\u0027octàgon:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid escriu (char c, int n){\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) cout \u0026lt;\u0026lt; c;\n}\n\nint main(){\n\tint n;\n\twhile (cin\u0026gt;\u0026gt;n) {\n\t\tfor (int i \u003d 0; i \u0026lt;\u003d n - 2; ++i){\n\t\t\tescriu(\u0027 \u0027, n - i - 1);\n\t\t\tescriu(\u0027X\u0027, n + 2*i);\n\t\t\tcout \u0026lt;\u0026lt; endl;\n\t\t}\n\t\tfor (int i \u003d 0; i \u0026lt; n; ++i){\n\t\t\tescriu(\u0027X\u0027, 3*n - 2);\n\t\t\tcout \u0026lt;\u0026lt; endl;\n\t\t}\n\t\tfor (int i \u003d n - 2; i \u0026gt;\u003d 0; --i){\n\t\t\tescriu(\u0027 \u0027, n - i - 1);\n\t\t\tescriu(\u0027X\u0027, n + 2*i);\n\t\t\tcout \u0026lt;\u0026lt; endl;\n\t\t}\n\t\tcout\u0026lt;\u0026lt;endl;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblema D: Factor primer més gran\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eSabem que el primer divisor que trobem en el bucle és primer (Suposem que no ho fos. És a dir: si el primer ddivisor que trobem al bucle és \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e·\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e amb \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e ≥ 2\u003c/span\u003e, abans hauríem passat per \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, que també és divisor. Això és una contradicció. (Benvinguts als raonaments per reducció a l\u0027absurd)). A més, és el factor primer més petit que hi ha, és a dir, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e / \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e té el factor primer més gran de \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Quan només quedi un primer (que serà el més gran \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e), es retornarà aquest.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\nusing namespace std;\n\nint factor_mes_gran(int n){\n\tfor (int i \u003d 2; i*i \u0026lt;\u003d n; ++i) {\n\t\tif (n%i \u003d\u003d 0) return factor_mes_gran(n/i);\n\t}\n\treturn n;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblema E: Magic Squares\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eSimplement comproveu que estan tots els números, i que cada fila, columna, i les dues diagonals principals sumin el mateix. Si recordeu, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/dd/63/dd63ce71c5831392f833dbe5b81c5e788ea3d401.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Per tant els \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e elements del quadrat sumen \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e5/45/e545e9e995870f44be7f82e835c88136fe881414.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Com que cada una de les \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e files suma el mateix, cada fila, columna, i cada una les dues diagonals principals sumarà \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/87/17/87177d9bbe19e3a0b604f5a750c423b3ad7c6e85.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\nusing namespace std;\n\nbool es_magic(const vector \u0026lt;vector \u0026lt;int\u0026gt; \u0026gt;\u0026amp; v, int n){\n\tint r \u003d n*(n*n + 1)/2;\t//Valor que ha de sumar cada fila, columna o diagonal\n\tint sum \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; ++i){\n\t\tsum \u003d 0;\n\t\tfor (int j \u003d 0; j \u0026lt; n; ++j) sum +\u003d v[i][j];\t\t//Sumem els elements de la fila i\n\t\tif (sum !\u003d r) return false;\n\t}\n\tfor (int j \u003d 0; j \u0026lt; n; ++j){\n\t\tsum \u003d 0;\n\t\tfor (int i \u003d 0; i \u0026lt; n; ++i) sum +\u003d v[i][j];\t\t//Sumem els elements de la columna j\n\t\tif (sum !\u003d r) return false;\n\t}\n\tsum \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) sum +\u003d v[i][i];\t\t\t//Sumem els elements de la diagonal principal\n\tif (sum !\u003d r) return false;\n\tsum \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) sum +\u003d v[n - i - 1][i];\t//Sumem els elements de la diagonal secundaria\n\tif (sum !\u003d r) return false;\n\treturn true;\n}\n\nint main(){\n\tint n; \n\twhile(cin \u0026gt;\u0026gt; n){\n\t\tvector \u0026lt;bool\u0026gt; w(n*n, false);\t//Mira quins nombres hem llegit\n\t\tvector \u0026lt;vector \u0026lt;int\u0026gt; \u0026gt; v(n, vector \u0026lt;int\u0026gt; (n));\n\t\tfor (int i \u003d 0; i \u0026lt; n; ++i) for (int j \u003d 0; j \u0026lt; n; ++j){\n\t\t\tint x;\n\t\t\tcin \u0026gt;\u0026gt; x;\n\t\t\tw[x-1] \u003d true;\n\t\t\tv[i][j] \u003d x;\n\t\t}\n\t\tbool estan_tots \u003d true;\n\t\tfor (int i \u003d 0; i \u0026lt; n*n and estan_tots; ++i) if(!w[i]) estan_tots \u003d false;\n\t\tif (estan_tots and es_magic(v, n)) cout \u0026lt;\u0026lt; \u0026quot;yes\u0026quot; \u0026lt;\u0026lt; endl;\n\t\telse cout \u0026lt;\u0026lt; \u0026quot;no\u0026quot; \u0026lt;\u0026lt; endl;\t\n\t}\t\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblema F: Dos trens i dues mosques\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eEl tren de la esquerra és mou relativament al de la dreta a velocitat \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e. Usant que \u003ccode\u003evelocitat \u003d distància recorreguda/temps\u003c/code\u003e,tenim que el temps \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e que triguen en xocar els dos trens és \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c6/2b/c62b67dbbb65fae3b15c59abdf74dca1f967c4e0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. En aquest temps, la primera mosca ha fet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e·\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e metres, mentre que la segona n\u0027ha fet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e·\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\nusing namespace std;\n\n#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint main(){\n    cout.setf(ios::fixed);\n    cout.precision(4);\n    double d, t1, t2, f1, f2;\n    while (cin \u0026gt;\u0026gt; d \u0026gt;\u0026gt; t1 \u0026gt;\u0026gt; t2 \u0026gt;\u0026gt; f1 \u0026gt;\u0026gt; f2){\n\t\tdouble T \u003d d/(t1 + t2);\n\t\tcout \u0026lt;\u0026lt; T*f1 \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; T*f2 \u0026lt;\u0026lt; endl;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblema G: Water deposits\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eCalculeu la mitjana per saber quan litres tindrà cada dipòsit al final. Aneu d\u0027esquerra a dreta. Si sobra aigua, se la passeu al de la dreta. Si en falta, se la \u0026quot;demaneu prestada\u0026quot; al de la dreta. No importa que el dipòsit de la dreta (el dipòsit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e) es quedi amb un nombre de litres negatiu, (només s\u0027està comptant el \u0026quot;deute\u0026quot; d\u0027aigua), ja que abans de passar-se l\u0027aigua del dipòsit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e al dipòsit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, el dipòsit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e haurà rebut la suficient aigua del dipòsit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 2\u003c/span\u003e. Si el dipòsit ja té l\u0027aigua suficient, no cal que sumeu cap cost. Com a cosa així extra us presentem els \u003ccode\u003etypedef\u003c/code\u003e\u0027s, que serveixen per redefinir un tipus de variable.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\ntypedef long long int LL;\ntypedef vector\u0026lt;LL\u0026gt; VLL;\n\nint main(){\n    LL n, p;\n    while (cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p){\n        VLL v(n);\n        for (int i \u003d 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; v[i];\n        LL sum \u003d 0;\n        for (int i \u003d 0; i \u0026lt; n; ++i) sum +\u003d v[i];\n        LL mitjana \u003d sum/n;\n        LL ans \u003d 0;\n        for (int i \u003d 0; i \u0026lt; n - 1; ++i){\n            if (v[i] \u0026lt; mitjana){\n                LL dif \u003d (mitjana - v[i]);\n                v[i+1] -\u003d dif;\n                ans +\u003d (dif + p);\n            }\n            if (v[i] \u0026gt; mitjana){\n                LL dif \u003d v[i] - mitjana;\n                v[i+1] +\u003d dif;\n                ans +\u003d (dif + p);\n            }\n        }\n        cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblema H: Notació polonesa inversa (2)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\nusing namespace std;\n\nint operacio (vector\u0026lt;char\u0026gt;\u0026amp; v) {\n    char c \u003d v[v.size() - 1];\n    v.pop_back();\n    if(c \u0026gt;\u003d \u00270\u0027 and c \u0026lt;\u003d \u00279\u0027) return c - \u00270\u0027;\n    if(c \u003d\u003d \u0027-\u0027) return -operacio(v);\n    if(c \u003d\u003d \u0027+\u0027) return operacio(v) + operacio(v);\n    if(c \u003d\u003d \u0027*\u0027) return operacio(v)*operacio(v);\n}\n\nint main() {\n    int n;\n    cin \u0026gt;\u0026gt; n;\n    for(int i \u003d 0; i \u0026lt; n; ++i) {\n        char c;\n        vector\u0026lt;char\u0026gt; v;\n        while(cin \u0026gt;\u0026gt; c and c !\u003d \u0027F\u0027) v.push_back(c);\n        cout \u0026lt;\u0026lt; operacio(v) \u0026lt;\u0026lt; endl;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblema I: Noves espècies. Versió 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\nusing namespace std;\n\nvoid swap (int\u0026amp; a, int\u0026amp; b){\n\tint aux \u003d a;\n\ta \u003d b;\n\tb \u003d aux;\n}\n\nint main(){\n\tint x00, x01, x10, x11, y00, y01, y10, y11;\n\twhile (cin \u0026gt;\u0026gt; x00 \u0026gt;\u0026gt; x01 \u0026gt;\u0026gt; x10 \u0026gt;\u0026gt; x11 \u0026gt;\u0026gt; y00 \u0026gt;\u0026gt; y01 \u0026gt;\u0026gt; y10 \u0026gt;\u0026gt; y11){\n\t\tint gabies \u003d x11 + y11;\n\t\tif (y01 \u0026gt;\u003d x10){\n\t\t\tswap(x00, y00);\n\t\t\tswap(x01, y10);\n\t\t\tswap(x10, y01);\n\t\t}\n\t\tx10 -\u003d y01;\n\t\tgabies +\u003d y01;\n\t\tif (x10 \u0026gt; 0) gabies +\u003d x10, y00 \u003d 0;\n\t\tif (x01 !\u003d 0) ++gabies, x00 \u003d 0;\n\t\tif (y10 !\u003d 0) ++gabies, y00 \u003d 0;\n\t\tif (x00 !\u003d 0 or y00 \u0026gt; 0) ++gabies;\n\t\tcout \u0026lt;\u0026lt; gabies \u0026lt;\u0026lt; endl;\t\t\n\t}\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblema I: Noves espècies. Versió 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\nusing namespace std;\n\nint main() {\n\tint x00, x01, x10, x11, y00, y01, y10, y11;\n\twhile(cin \u0026gt;\u0026gt; x00 \u0026gt;\u0026gt; x01 \u0026gt;\u0026gt; x10 \u0026gt;\u0026gt; x11 \u0026gt;\u0026gt; y00 \u0026gt;\u0026gt; y01 \u0026gt;\u0026gt; y10 \u0026gt;\u0026gt; y11) {\n\t\tint gabies \u003d x11 + y11;\n\t\tgabies +\u003d max(x10,y01);\n\t\tif(x01 !\u003d 0) ++gabies;\n\t\tif(y10 !\u003d 0) ++gabies;\n\t\tif(x00 !\u003d 0 and x01 \u003d\u003d 0 and (y01 \u003d\u003d 0 or (y01 \u0026lt;\u003d x10))) ++gabies;\n\t\telse if(y00 !\u003d 0 and y10 \u003d\u003d 0 and (x10 \u003d\u003d 0 or (x10 \u0026lt;\u003d y01))) ++gabies;\n\t\tcout \u0026lt;\u0026lt; gabies \u0026lt;\u0026lt; endl;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}