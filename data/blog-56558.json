{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1513954700,"rating":0,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1513954700,"id":56558,"title":"\u003cp\u003eNotes on Codeforces Beta Round #103, A, B, C, D (Knight tour problem), E (branch and bound)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/144/problem/A\" title\u003d\"Codeforces Round 103 (Div. 2)\"\u003e144A - Приезд генерала\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe should find the maximum value with the minimum index and the minimum value with the maximum index, whose indices are denoted as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eid\u003c/i\u003e1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eid\u003c/i\u003e2\u003c/span\u003e (index starts from 0), respectively.\u003c/p\u003e\u003cp\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eid\u003c/i\u003e1 \u003d \u003ci\u003eid\u003c/i\u003e2\u003c/span\u003e, it means that all the values are the same and thus no swap is necessary. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eid\u003c/i\u003e1 \u0026lt; \u003ci\u003eid\u003c/i\u003e2\u003c/span\u003e, it takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eid\u003c/i\u003e1\u003c/span\u003e steps to move the maximum value to the first position while \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1 - \u003ci\u003eid\u003c/i\u003e2\u003c/span\u003e steps to move the minimum value to the last position, which gives totally \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eid\u003c/i\u003e1 + \u003ci\u003en\u003c/i\u003e - 1 - \u003ci\u003eid\u003c/i\u003e2\u003c/span\u003e steps. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eid\u003c/i\u003e1 \u0026gt; \u003ci\u003eid\u003c/i\u003e2\u003c/span\u003e, we need \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eid\u003c/i\u003e1 + \u003ci\u003en\u003c/i\u003e - 1 - \u003ci\u003eid\u003c/i\u003e2 - 1\u003c/span\u003e steps, where the last term \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e comes from that when we move the maximum value to the head, the minimum value in fact has been moved one position to the right. \u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/144/problem/B\" title\u003d\"Codeforces Round 103 (Div. 2)\"\u003e144B - Совещание\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe solution is straightforward. We enumerate each point on the four sides, and check whether it is included by at least one circle or not. Note that the four corner points should be checked only once.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/144/problem/C\" title\u003d\"Codeforces Round 103 (Div. 2)\"\u003e144C - Поиск анаграмм\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet us denote the length of the first and second string as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eslen\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eplen\u003c/i\u003e\u003c/span\u003e (these strings are denoted as s and p). It is obvious that if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eslen\u003c/i\u003e \u0026lt; \u003ci\u003eplen\u003c/i\u003e\u003c/span\u003e, then it is impossible to find any good substrings.\u003c/p\u003e\u003cp\u003eFor \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eslen\u003c/i\u003e ≥ \u003ci\u003eplen\u003c/i\u003e\u003c/span\u003e, we only need consider the substrings of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e with length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eplen\u003c/i\u003e\u003c/span\u003e. It is convenient to imagine that we have a sliding window and move along string s to find good substrings. For any substring of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eplen\u003c/i\u003e\u003c/span\u003e, we use a hash table to store the number of letters that appear there. For simplicity, we use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehs\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e to denote the number of letter \u0027i\u0027 appearing in string s and p, respectively. One can check that if for all letter \u0027i\u0027, we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehs\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] ≤ \u003ci\u003ehp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e, then the current substring is good, since the “missing” letters can be obtained by replacing \u0027?\u0027. Otherwise, it is definitely not a good substring, since the “redundant” letters can not be eliminated.\u003c/p\u003e\u003cp\u003eNote that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e can be calculated once for all while \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehs\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e should be updated whenever we move the sliding window one step forward, which can be implemented with complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e as only one old letter is removed and one new letter is added. Thus, the total complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003emax\u003c/i\u003e(\u003ci\u003eslen\u003c/i\u003e, \u003ci\u003eplen\u003c/i\u003e))\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/144/problem/D\" title\u003d\"Codeforces Round 103 (Div. 2)\"\u003e144D - Ракетные шахты\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe main solution contains two parts.\u003c/p\u003e\u003cp\u003eThe first part is Dij algorithm based on priority queue, since the given graph is sparse. There are a large number of materials (also codes) describing the detailed implementation and thus omitted here.\u003c/p\u003e\u003cp\u003eFor the second part, we should find out all the required points. At first, we check all the nodes and find out all those that have an exact distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e. Then, we enumerate each edge and check whether there exist positions on the edge that also have a distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e. It can be observed that there are at most two positions that have a chance to have a distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e. One is by passing one node while the other one is by passing the other node. Be careful that these two positions may coincide with each other.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/144/problem/E\" title\u003d\"Codeforces Round 103 (Div. 2)\"\u003e144E - Соревнование\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFor a cell \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003er\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e)\u003c/span\u003e that belongs to the secondary diagonal, it can only be reached from cells \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e that satisfy \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e ≤ \u003ci\u003ej\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e, which in fact forms a rectangular. \u003c/p\u003e\u003cp\u003eWe can enumerate the cells in the secondary diagonal from bottom to top and also maintain a set containing the candidate sportmans that can be selected. Initially, we check row \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and only consider the sportmans that belong to row \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. We select the sportman that has the minimum column index and if there are multiple such sportmans, we further select the one the minimum row index. Before we move to row \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e, we should first delete the selected sportman, and then further delete all sportmans belonging to column \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e from the candidate set, while at the same time add the sportmans that belongs to row \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e to the set. Then, we move to row \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e and repeat the above operations again.\u003c/p\u003e\u003cp\u003eGenerally speaking, when we try to find a sportman that should go to cell \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003er\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e)\u003c/span\u003e which belongs to the secondary diognal, we should select one sportman from our candidate set (note that it might be empty), and then delete it and also delete all the sportmans that have a column index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e while adding sportmans that have a row index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e - 1\u003c/span\u003e, and then move to the upper row.\u003c/p\u003e\u003cp\u003eIn fact this is a greedy algorithm and by some induction one can see that this will result in a reasonable answer. Now we prove that the complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003emlog\u003c/i\u003e(\u003ci\u003em\u003c/i\u003e))\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSuppose that the number of sportmans in the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th row is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e while in the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e-th column is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. When we are dealing with cell \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e + 1 - \u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e, we delete \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e + 1 - \u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e sportmans while adding \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e sportmans. Both the deleting and adding operation can be implemented with complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogm\u003c/i\u003e)\u003c/span\u003e. Thus, the total number of deleting operations is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/24/d0/24d0340e0e57a04929f7440ec8a4213d89a3df19.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and the total number of adding operations is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/78/6c/786c96f798fc64ed6d220d35dea9085221aa0b5a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, which gives \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/61/22/61228fdb612997dab5205055c98a20047e19efe9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003c/div\u003e","tags":[]}}