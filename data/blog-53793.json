{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1502466265,"rating":11,"authorHandle":"satylogin","modificationTimeSeconds":1502645659,"id":53793,"title":"\u003cp\u003eContest on Hackerearth by GEEKHAVEN competitive coding wing\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello guys :) \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eCompetitive coding wing of GEEKHAVEN IIIT Allahabad is organising a contest on hackerearth on saturday 12th august. The contest is mainly centred for second year students, although I hope that everyone will be able to enjoy the problem set. The contest is prepared by the members of the wing. \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eIt has Balanced problemset with some interesting problems to simulate the grey cells and great to start the weekend. \u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eThe link of the contest is — \u003ca href\u003d\"https://www.hackerearth.com/challenge/college/codemania-20/\"\u003ehttps://www.hackerearth.com/challenge/college/codemania-20/\u003c/a\u003e \u003c/strong\u003e\u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eThe contest duration is 24 HRS. \u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eI hope for an huge participation. :) \u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e UPD: (EDITORIAL) \u003c/strong\u003e \u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e\u003ch6\u003e1. \u003ca href\u003d\"https://www.hackerearth.com/challenge/college/codemania-20/algorithm/cross-the-stairs/\"\u003ehttps://www.hackerearth.com/challenge/college/codemania-20/algorithm/cross-the-stairs/\u003c/a\u003e\u003c/h6\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eYou can simply brute force for the solution. one by call friend for each level and then compute the answer for that call. Out of all possible solution select the maximum one. \u003cbr /\u003e\u003c/p\u003e\u003ch6\u003e\u003ca href\u003d\"http://paste.ubuntu.com/25305339/\"\u003ehttp://paste.ubuntu.com/25305339/\u003c/a\u003e \u003cbr /\u003e\u003c/h6\u003e\u003ch6\u003e\u003ca href\u003d\"http://paste.ubuntu.com/25305411/\"\u003ehttp://paste.ubuntu.com/25305411/\u003c/a\u003e\u003c/h6\u003e\u003c/div\u003e\u003c/div\u003e\u003ch6\u003e2. \u003ca href\u003d\"https://www.hackerearth.com/challenge/college/codemania-20/algorithm/honey-bees/\"\u003ehttps://www.hackerearth.com/challenge/college/codemania-20/algorithm/honey-bees/\u003c/a\u003e\u003c/h6\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003ethe problem was simple brute force. There were two cases to handle, when the second index is odd, and when second is even for both type of queries. Just make a big enough picture, and it will help you in understanding the solution. \u003cbr /\u003e\u003c/p\u003e\u003ch6\u003e\u003ca href\u003d\"http://paste.ubuntu.com/25305429/\"\u003ehttp://paste.ubuntu.com/25305429/\u003c/a\u003e\u003c/h6\u003e\u003c/div\u003e\u003c/div\u003e\u003ch6\u003e3. \u003ca href\u003d\"https://www.hackerearth.com/problem/algorithm/modern-game/\"\u003ehttps://www.hackerearth.com/problem/algorithm/modern-game/\u003c/a\u003e\u003c/h6\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eWe will solve the problem using binary representation of the number.Since we have to find the number of solutions of the equation a+b+c \u003d N , we have to make sure that ith bit of a , b and c add up to ith bit of N i.e. (ai + bi + ci)%2 \u003d (Ni). A carry might also get generated which will be equal to (ai + bi + ci)/2. For the condition (a \u0026amp; b \u0026amp; c) \u0026gt; 0 to be true we have to make sure that some jth bit have to be set for all three variables(for this purpose we will take a variable flag which is set to 1 when all the 3 numbers have same bit set). Thus after assigning values for MSB , the value of carry and flag should be equal to 0(in case of carry being equal to 1 implies overflow) and 1(in case of value of flag being 0 implies (a\u0026amp;b\u0026amp;c)\u003d0) respectively. Trying all possible combinations for all bit for a,b,c will cost 8^len where ,\u003cbr /\u003elen \u003d number of bits required to denote the number n. But since we are making same same kind of recursive calls many times we can memorize it using 64*2*2 array(Since the number can be of max 64 bits , carry and flag can take value 0,1 ). \u003cbr /\u003e\u003c/p\u003e\u003ch6\u003e\u003ca href\u003d\"http://paste.ubuntu.com/25305466/\"\u003ehttp://paste.ubuntu.com/25305466/\u003c/a\u003e\u003c/h6\u003e\u003c/div\u003e\u003c/div\u003e\u003ch6\u003e4. \u003ca href\u003d\"https://www.hackerearth.com/problem/algorithm/an-excursion-in-mathematics/\"\u003ehttps://www.hackerearth.com/problem/algorithm/an-excursion-in-mathematics/\u003c/a\u003e\u003c/h6\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eAN EXCURSION WITH MATHEMATICS\u003c/p\u003e\u003cp\u003eTime Complexity:-O(T*3000)\u003c/p\u003e\u003cp\u003eIn this question the most important part was finding x,y,z for given a,b,c.\u003c/p\u003e\u003cp\u003ewe are given,\u003cbr /\u003e  x^2 + y^2 + z^2 \u003d a \u003cbr /\u003e  x^4 + y^4 + z^4 \u003d b \u003cbr /\u003e  x^5 + y^5 + z^5 \u003d c \u003cbr /\u003e\u003c/p\u003e\u003cp\u003esuppose, we know the value of x then,\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ey^2 + z^2 \u003d a\u0027 __(1)\ny^4 + z^4 \u003d b\u0027 __(2)\ny^5 + z^5 \u003d c\u0027 __(3)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003enow solving equations (1) and (2) is doable. So now we got the values of y^2 and z^2 (i.e. y and z). Now check if y and z are integers and they satisfy eq(3). We can do above checking for every x. Once you get the values of x,y and z you can find sum using modular exponentiation and properties of Geometric progression.\u003c/p\u003e\u003cp\u003eC++ Code — \u003ca href\u003d\"https://paste.ubuntu.com/25306084/\"\u003ehttps://paste.ubuntu.com/25306084/\u003c/a\u003e \u003cbr /\u003e\u003c/p\u003e\u003ch6\u003e\u003ca href\u003d\"http://paste.ubuntu.com/25305520/\"\u003ehttp://paste.ubuntu.com/25305520/\u003c/a\u003e\u003c/h6\u003e\u003c/div\u003e\u003c/div\u003e\u003ch6\u003e5. \u003ca href\u003d\"https://www.hackerearth.com/problem/algorithm/coin-toss/\"\u003ehttps://www.hackerearth.com/problem/algorithm/coin-toss/\u003c/a\u003e\u003c/h6\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eNote that the ways of tossing and of H and T have a bijection with each other.\u003c/p\u003e\u003cp\u003eLet X(n),Y(n),Z(n) represent the allowable sequences ending with 2,1 and 0 consecutive tails respectively.\u003c/p\u003e\u003cp\u003eWe have:\u003c/p\u003e\u003cp\u003eX(n)\u003dY(n-1)...(i)  Y(n)\u003dZ(n-1)...(ii) The above two results can be shown by considering that we can append a tails to the end of the n-1 length chain to create an n length chain with one more consecutive tail at the end.\u003c/p\u003e\u003cp\u003eNow let F(n) denote the total number of acceptable sequences.\u003c/p\u003e\u003cp\u003eNow, we have:\u003c/p\u003e\u003cp\u003eZ(n)\u003dF(n-1)...(iii) (By appending an heads to the end of any acceptable sequence and removing heads from end of any (acceptable) sequence ending with tails ... bijection can be proved)\u003c/p\u003e\u003cp\u003eAlso (obviously):\u003c/p\u003e\u003cp\u003eF(n)\u003dX(n)+Y(n)+Z(n)\u003c/p\u003e\u003cp\u003eThus, we can show:\u003c/p\u003e\u003cp\u003eF(n)\u003dF(n-1)+F(n-2)+F(n-3) ...by (i), (ii), (iii)\u003c/p\u003e\u003cp\u003eWe can easily compute this in log(n) complexity using Matrix Exponentiation.\u003c/p\u003e\u003cp\u003esolution link : \u003ca href\u003d\"https://paste.ubuntu.com/25305080/\"\u003ehttps://paste.ubuntu.com/25305080/\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTime complexity : O(T*log(n))\u003c/p\u003e\u003cp\u003ejava solution : \u003ca href\u003d\"http://paste.ubuntu.com/25305535/\"\u003ehttp://paste.ubuntu.com/25305535/\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003ch6\u003e6. \u003ca href\u003d\"https://www.hackerearth.com/problem/algorithm/ben-and-the-omnitrix/\"\u003ehttps://www.hackerearth.com/problem/algorithm/ben-and-the-omnitrix/\u003c/a\u003e\u003c/h6\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eprerequisite : Lowest Common ancestor , DFS\u003c/p\u003e\u003cp\u003eFor each 1 ≤ i ≤ n and 0 ≤ j ≤ log(n), store the minimum 20 values in the path from U(vertex) i to its 2^j-th parent in an array. Now everything is needed is: how to merge the array of two paths? You can keep the these 20 values in the array in increasing order and for merging, use standard merge function which will work in . And then delete the extra values (more than 20). Do the same for a query (just like the preprocess part) and you will get the list. \u003c/p\u003e\u003cp\u003esolution link : \u003ca href\u003d\"http://paste.ubuntu.com/25305169/\"\u003ehttp://paste.ubuntu.com/25305169/\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTime complexity: O((n+q)*20*log(n))\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003ch6\u003e7. \u003ca href\u003d\"https://www.hackerearth.com/practice/basic-programming/input-output/basics-of-input-output/practice-problems/algorithm/play-with-numbers-2/\"\u003ehttps://www.hackerearth.com/practice/basic-programming/input-output/basics-of-input-output/practice-problems/algorithm/play-with-numbers-2/\u003c/a\u003e\u003c/h6\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003ePLAY WITH NUMBERS.\u003c/p\u003e\u003cp\u003eTime Complexity:-O(max(N,Q))\u003c/p\u003e\u003cp\u003eIn this question you had to find out the expected value of value of the subarray from l to r.\u003c/p\u003e\u003cp\u003eThe expected value of the subarray is the mean of the subarray i.e. the sum of all the terms in the subarray divide by the number of terms in the subarray. So to solve this we make an array A where A[i] stores the cumulative sum of all elements before index i+1. Then for every query given l and r the answer will be (A[r]-A[l-1])/(r-l+1). To ensure that we get the floor of the expected value we need to do integer divison.\u003c/p\u003e\u003cp\u003eC++ Code — \u003ca href\u003d\"https://paste.ubuntu.com/25305261/\"\u003ehttps://paste.ubuntu.com/25305261/\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003ch6\u003e8. \u003ca href\u003d\"https://www.hackerearth.com/problem/algorithm/alex-and-the-substring/\"\u003ehttps://www.hackerearth.com/problem/algorithm/alex-and-the-substring/\u003c/a\u003e, \u003ca href\u003d\"https://www.hackerearth.com/problem/algorithm/alex-and-the-substring-med/\"\u003ehttps://www.hackerearth.com/problem/algorithm/alex-and-the-substring-med/\u003c/a\u003e\u003c/h6\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eJust make 26 maps for each character. make 2, such map arrays. one stores the frequency of sum that ends in current character and other for sums till previous index (sums means prefix sum); Then just iterate over the values then decrease in both array for current character and then add count of such numbers that end in same prefix sum (as then their difference will be zero)\u003c/p\u003e\u003ch6\u003e\u003ca href\u003d\"http://paste.ubuntu.com/25305989/\"\u003ehttp://paste.ubuntu.com/25305989/\u003c/a\u003e\u003c/h6\u003e\u003c/div\u003e\u003c/div\u003e\u003ch6\u003e9. \u003ca href\u003d\"https://www.hackerearth.com/practice/data-structures/disjoint-data-strutures/basics-of-disjoint-data-structures/practice-problems/algorithm/owl-fight/\"\u003ehttps://www.hackerearth.com/practice/data-structures/disjoint-data-strutures/basics-of-disjoint-data-structures/practice-problems/algorithm/owl-fight/\u003c/a\u003e\u003c/h6\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eA direct implementation of dsu. \u003ca href\u003d\"http://paste.ubuntu.com/25305377/\"\u003ehttp://paste.ubuntu.com/25305377/\u003c/a\u003e \u003ca href\u003d\"http://paste.ubuntu.com/25305621/\"\u003ehttp://paste.ubuntu.com/25305621/\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003ch6\u003e10. \u003ca href\u003d\"https://www.hackerearth.com/practice/basic-programming/implementation/basics-of-implementation/practice-problems/algorithm/clock-1/\"\u003ehttps://www.hackerearth.com/practice/basic-programming/implementation/basics-of-implementation/practice-problems/algorithm/clock-1/\u003c/a\u003e\u003c/h6\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eCLOCK\u003c/p\u003e\u003cp\u003eTime Complexity:-O(R*R)\u003c/p\u003e\u003cp\u003eIn this question you had to find out number of integral points that lie between the minute hand and the hour hand (taking the clockwise angle from the minute to the hour hand) within the clock.\u003c/p\u003e\u003cp\u003eFor this we first needed to find out the angle of the minute and hour hand. -\u0026gt;minute hand angle:-m*6; -\u0026gt;hour hand angle:-h*30+m*(0.5); After this for every integral point in the range (-R,-R) we need to check if it lies within the circle and whether it lies between the minute and hour hand.\u003c/p\u003e\u003cp\u003eC++ Code — \u003ca href\u003d\"https://paste.ubuntu.com/25305475/\"\u003ehttps://paste.ubuntu.com/25305475/\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}