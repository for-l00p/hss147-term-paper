{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1467104291,"rating":5,"authorHandle":"ferc","modificationTimeSeconds":1467104291,"id":45712,"title":"\u003cp\u003estd::set и вопрос про его работу с памятью\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eНа последнем контесте была задача \u003ca href\u003d\"//codeforces.com/problemset/problem/686/D\"\u003eD. Кай и снежинки\u003c/a\u003e. В разборе написано, что вполне подойдет решение в каждой вершине сливать сеты ее потомков.\u003c/p\u003e\u003cp\u003eОчевидно, что худший тест — это просто цепь из 300000 вершин. Тогда получается, что в каждой вершине будет 1, 2, 3,..., 300000 элементов в сете. Всего элементов (арифм. прогрессия) 300000 * 300000 / 2 ~\u003d 45 * 10^9.\u003c/p\u003e\u003cp\u003eЭто катастрофически много. Когда я попытался именно сохранить все эти сеты, то, разумеется, получил ML. Однако, если написать как в разборе, то есть просто запуститься рекурсивно из корня и постепенно получать ответ для него (не сохраняя сами сеты), то получим Accepted.\u003c/p\u003e\u003cp\u003eТак вот по сути же выделяем под те же 45 * 10^9 интов. Единственное, что приходит в голову, то что сет после выполнения функции чистит за собой память, которую потребовал в ходе выполнения этой функции, и в последствии может снова использовать ее же.\u003c/p\u003e\u003cp\u003e1) Подскажите, это правда так?\u003c/p\u003e\u003cp\u003eГрубо говоря, есть цикл for (int i \u003d 0; i \u0026lt; 100000; i++) {  set a;  a.insert(3); }\u003c/p\u003e\u003cp\u003eПравда ли, что потребуется памяти столько, сколько необходимо на одну итерацию? Я просто раньше думал, что выделяется всегда абсолютно новая область памяти. Помогите разобраться, пожалуйста.\u003c/p\u003e\u003c/div\u003e","tags":["выделение памяти","память","работа с памятью","memory"]}}