{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1527448383,"rating":1,"authorHandle":"_maverick","modificationTimeSeconds":1527449678,"id":59711,"title":"\u003cp\u003eOptimisation for a subset problem\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI faced this question among the challenges in another platform. I was unable to optimise my solution for this problem with it\u0027s constraints to pass within the time limit during the contest. The contest has ended and I feel it\u0027s time to learn.\u003c/p\u003e\u003ch4\u003eQuestion :\u003c/h4\u003e\u003cp\u003eYou\u0027re given an array of size N. You need to generate all subsets for the given array. For each subset you need to OR it\u0027s minimum and the maximum element and add it to the result. You need to finally output the result after performing the mentioned operation for all it\u0027s subsets. Since the result can be large, output the result MOD by (10^9)+7.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eConstraints :\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e1\u0026lt;\u003dN\u0026lt;\u003d(2*(10^5))\u003c/p\u003e\u003cp\u003eLet Ai be the values of the array where 1\u0026lt;\u003di\u0026lt;\u003dN\u003c/p\u003e\u003cp\u003e1\u0026lt;\u003dAi\u0026lt;\u003d1000\u003c/p\u003e\u003ch4\u003eMy Approach :\u003c/h4\u003e\u003cp\u003eSince the problem demands to OR the minimum and maximum of each subset, I started by sorting the given array. Since the minimum element would have to appear with all the higher elements it pairs with, and the second minimum element would have to pair with all elements higher than itself and so on, sorting the array seems to be a correct approach towards the goal.\u003c/p\u003e\u003cp\u003eOver the sorted array I run my logic which is displayed in the below code snippet.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003elong MOD \u003d 1000000007l;\nlong result \u003d 0l;\nfor (int i\u003d0;i\u0026lt;N;i++) {\n    for (int j\u003di;j\u0026lt;N;j++) {\n        if (i\u003d\u003dj) {\n            result \u003d (result+array[i])%MOD;\n            continue;\n        }\n        int OR \u003d array[i]|array[j];\n        result \u003d (result+((OR%MOD)*(fastExponentiate(2,j-i-1)%MOD)))%MOD;\n    }\n}\nprint(result)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis looks good as an optimised brute solution running at O((N^2)*log(N)). Still not good enough to pass the time limit of 1 sec. I think the key idea lies somewhere in using the value\u0027s maximum limit of 1000 which is 10 bits for each number of the array. I tried several ideas but they were a catastrophe. I still couldn\u0027t optimise the logic. Can anyone help me if you\u0027ve come across this type of problem ?\u003c/p\u003e\u003c/div\u003e","tags":["subset","fast exponentiation","#bitwiseor"]}}