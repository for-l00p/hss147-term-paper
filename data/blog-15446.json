{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1419805795,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1419805844,"id":15446,"title":"\u003cp\u003eЗадачи с использованием условных операторов и циклов. Часть 3\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eРассмотрим ещё одну задачу.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача 3\u003c/strong\u003e. \u003c/p\u003e\u003cp\u003eДано целое положительное число \u003cem\u003en\u003c/em\u003e, в записи которого содержится не более 100 цифр. Выведите \u003cem\u003eYes\u003c/em\u003e, если оно делится на 11, и \u003cem\u003eNo\u003c/em\u003e в противном случае. \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eРешение\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eОбратите внимание, что длина числа такова, что ни в один целый тип оно не поместится (самый длинный примитивный тип \u003ccode\u003elong\u003c/code\u003e позволяет записать числа, содержащие не более 19 цифр). \u003cbr /\u003e \u003cem\u003eПока мы считаем, что не знаем о существовании типа BigInteger и не умеем им пользоваться.\u003c/em\u003e \u003c/p\u003e\u003cp\u003eПоэтому нам придётся применить признак делимости на 11. Например, подойдёт следующий признак: «число делится на 11, тогда и только тогда, когда абсолютное значение разности между суммой цифр, занимающих нечётные позиции, и суммой цифр, занимающих чётные позиции, делится на 11». \u003cbr /\u003e \u003cem\u003eЭто не единственный признак; подробно о признаках делимости можно прочитать, например, в \u003ca href\u003d\"https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%B7%D0%BD%D0%B0%D0%BA%D0%B8_%D0%B4%D0%B5%D0%BB%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8\"\u003eВикипедии\u003c/a\u003e.\u003c/em\u003e \u003c/p\u003e\u003cp\u003eЗаметим, что при такой формулировке признака делимости несущественно, как именно мы будем нумеровать цифры в числе — с начала, с конца, с нуля, с единицы. Важно то, что мы просуммируем цифры, расположенные через одну, и найдём модуль разности этих сумм. Поскольку цифр в числе не более 100, то модуль разности двух сумм цифр не будет превосходить \u003cspan class\u003d\"tex-span\"\u003e450 ( \u003d 50·9)\u003c/span\u003e. А разделить такое число на 11 уже не составит труда даже вручную. \u003c/p\u003e\u003cp\u003eТехника решения может быть такой: прочитаем число как строку, после чего применим признак делимости. \u003c/p\u003e\u003cp\u003eОднако следует понимать, что, когда мы прочитаем число в строковую переменную, оно будет состоять из символов, соответствующих цифрам, но никак не из «собственно цифр». Java позволит Вам складывать символы, но при этом будет оперировать целочисленными кодами этих символов, которые отличаются от цифровых значений. В частности, соответствующий цифре 0 символ \u00270\u0027 имеет код 48, символ \u00271\u0027 — код 49 и т. д. (по порядку). Поэтому, чтобы получить верный результат, нужно будет предварительно превращать символы в цифры. \u003c/p\u003e\u003cp\u003e\u003cem\u003eКонечно, можно сначала сложить все значения символов, а потом вычесть 48, умноженное на количество символов, но, кажется, что приведённый ниже код более прозрачный.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eНапишем псевдокод для подсчета сумм цифр на чётных и нечётных местах\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eдля (символа №i из строки s) {\n\tесли (i – чётное) {\n\t\tсумма_цифр_на_чётных_местах \u003d сумма_цифр_на_чётных_местах + (код_символа_№i — код_символа_\u00270\u0027)\n\t}\n\tиначе {\n\t\tсумма_цифр_на_нечётных_местах \u003d сумма_цифр_на_нечётных_местах + (код_символа_№i — код_символа_\u00270\u0027)\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЕсли немного порассуждать, этот псевдокод можно упростить. В операторе \u003ccode\u003efor\u003c/code\u003e (\u003ccode\u003eдля\u003c/code\u003e), который мы будем использовать, можно изменять номер символа сразу на 2 единицы. Тогда мы запишем два цикла — в одном будем суммировать цифры на чётных позициях, в другом — на нечётных, а оператор \u003ccode\u003eif\u003c/code\u003e (\u003ccode\u003eесли\u003c/code\u003e) нам уже не понадобится. \u003c/p\u003e\u003cp\u003e\u003cem\u003eОперация сравнения «медленнее», чем операция сложения, поэтому без нее код должен работать быстрее (конечно, это сильно зависит от компилятора и того, как он проводит оптимизацию).\u003c/em\u003e \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eдля (начиная с символа №0, для символа №i из строки s; увеличить i на 2) {\n\tсумма_цифр_на_чётных_местах \u003d сумма_цифр_на_чётных_местах + (код_символа_№i — код_символа_\u00270\u0027)\n}\n\nдля (начиная с символа №1, для символа №i из строки s; увеличить i на 2) {\n\tсумма_цифр_на_нечётных_местах \u003d сумма_цифр_на_нечётных_местах + (код_символа_№i — код_символа_\u00270\u0027)\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЛегко заметить, что циклы отличаются друг от друга лишь выбором номера начального символа (а также именем переменной, в которой хранится сумма). \u003c/p\u003e\u003cp\u003eВ случаях, когда имеются практически идентичные фрагменты кода, обычно есть смысл попробовать описать такой фрагмент кода единожды как метод (и в нужных местах программы вызывать этот метод).\u003c/p\u003e\u003cp\u003eЭтот метод будет принимать единственный параметр — номер символа, с которого следует начать суммирование, и возвращать сумму цифр «через одну» в качестве результата.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eцелое сумма_цифр_через_одну (целое номер_начального_символа) {\n\tсумма \u003d 0\n\tдля (начиная с номер_начального_символа, для символа №i из строки s; увеличить i на 2) {\n\t\tсумма \u003d сумма + (код_символа_№i — код_символа_\u00270\u0027) \n\t}\n\tрезультат ← сумма\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОписанный метод нам потребуется вызвать дважды: с фактическим параметром 0 и с фактическим параметром 1. \u003c/p\u003e\u003cp\u003eТеперь всё готово, чтобы написать программу, решающую задачу. В проекте \u003ccode\u003epractice01\u003c/code\u003e создадим (с помощью диалогового окна) класс \u003ccode\u003eProblem03\u003c/code\u003e и, как обычно, пока оставим его метод \u003ccode\u003emain()\u003c/code\u003e пустым.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\npublic class Problem03 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДалее опишем класс \u003ccode\u003eElevenDivisibility\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\npublic class Problem03 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass ElevenDivisibility {\n\t\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ этом классе опишем поле \u003ccode\u003en\u003c/code\u003e, в котором будет храниться прочитанное с клавиатуры число. Однако это поле будет не целочисленным, а строковым, поскольку число может быть слишком большим. Ещё одно строковое поле понадобится для хранения ответа — это поле \u003ccode\u003eanswer\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eТакже опишем конструктор, в котором с помощью экземпляра класса \u003ccode\u003eScanner\u003c/code\u003e выполняется чтение этого числа. После прочтения числа никакие данные в программу более не поступают, поэтому можно завершить работу с объектом \u003ccode\u003ein\u003c/code\u003e, вызвав его метод \u003ccode\u003eclose()\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\nimport java.util.Scanner;\n\npublic class Problem03 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass ElevenDivisibility {\n\t\n\tElevenDivisibility() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.next();\n\t\tin.close();\n\t}\n\t\n\tString n;\n\tString answer;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОпишем метод \u003ccode\u003esumThroughOne()\u003c/code\u003e, суммирующий цифры через одну. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass ElevenDivisibility {\n\t\n\tElevenDivisibility() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.next();\n\t\tin.close();\n\t}\n\t\n\tint sumThroughOne (int startPos) {\n\t\tint sum \u003d 0;\n\t\tfor (int i \u003d startPos; i \u0026lt; n.length(); i \u003d i + 2) {\n\t\t\tsum \u003d sum + (n.charAt(i) - ZERO);\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tstatic final int ZERO \u003d (int)\u00270\u0027;\n\t\n\tString n;\n\tString answer;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДля кода символа \u00270\u0027 было применено символьное обозначение \u003ccode\u003estatic final int ZERO \u003d (int)\u00270\u0027\u003c/code\u003e\u003c/p\u003e\u003cp\u003eКонечно, было бы вполне достаточно описать такую переменную в самом методе \u003ccode\u003esumThroughOne()\u003c/code\u003e, но мы продемонстрировали, как можно объявить константу — величину, которая будет единой и неизменной для всех экземпляров класса \u003ccode\u003eElevenDivisibilty\u003c/code\u003e. Неизменность обеспечивает модификатор \u003ccode\u003efinal\u003c/code\u003e (попытка присвоить объявленной с \u003ccode\u003efinal\u003c/code\u003e величине какое-либо значение приведет к ошибке компиляции). А модификатор \u003ccode\u003estatic\u003c/code\u003e действует подобно такому же модификатору у метода \u003ccode\u003emain()\u003c/code\u003e (см., например, раздел \u003ca href\u003d\"http://codeforces.ru/group/t4gy0Ot4NY/blog/entry/457\"\u003e«Общая структура программы на Java»\u003c/a\u003e). Применительно к полям \u003ccode\u003estatic\u003c/code\u003e означает, что значение поля не является уникальным для каждого объекта. Для хранения поля выделяется одна область памяти, к которой будут обращаться все экземпляры класса. Заметим, что методы, помеченные как \u003ccode\u003estatic\u003c/code\u003e, могут обращаться к полям, помеченным как \u003ccode\u003estatic\u003c/code\u003e (в отличие от обычных полей). \u003c/p\u003e\u003cp\u003eВ следующем методе — методе \u003ccode\u003esolve()\u003c/code\u003e — как раз и будут подсчитываться суммы цифр. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass ElevenDivisibility {\n\t\n\tElevenDivisibility() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.next();\n\t\tin.close();\n\t}\n\t\n\tint sumThroughOne (int startPos) {\n\t\tint sum \u003d 0;\n\t\tfor (int i \u003d startPos; i \u0026lt; n.length(); i \u003d i + 2) {\n\t\t\tsum \u003d sum + (n.charAt(i) - ZERO);\n\t\t}\t\t\n\t\treturn sum;\n\t}\n\t\n\tvoid solve() {\n\t\tint evenPosSum \u003d sumThroughOne(0);\n\t\tint oddPosSum \u003d sumThroughOne(1);\n\t\tint diff \u003d Math.abs(evenPosSum - oddPosSum);\n\t\tanswer \u003d (diff % 11 \u003d\u003d 0)? \u0026quot;Yes\u0026quot;: \u0026quot;No\u0026quot;;\n\t}\n\t\n\tstatic final int ZERO \u003d (int)\u00270\u0027;\n\t\n\tString n;\n\tString answer;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ первых двух строчках метода \u003ccode\u003esolve()\u003c/code\u003e вызывается метод \u003ccode\u003esumThroughOne()\u003c/code\u003e с параметрами 0 и 1 (для подсчёта сумм цифр на чётных и нечётных местах соответственно); затем вычисляется абсолютное значение разности этих сумм (для чего вызывается стандартная функция \u003ccode\u003eabs()\u003c/code\u003e из класса \u003ccode\u003eMath\u003c/code\u003e). Наконец, тернарный оператор в последней строке присваивает значение переменной \u003ccode\u003eanswer\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eВ нашем случае вместо последней строки метода \u003ccode\u003esolve()\u003c/code\u003e мог быть записан следующий условный оператор:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eif (diff % 11 \u003d\u003d 0) {\n\tanswer \u003d \u0026quot;Yes\u0026quot;;\n}\nelse {\n\tanswer \u003d \u0026quot;No\u0026quot;;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОднако в некоторых случаях условный оператор может быть заменен тернарным оператором. \u003c/p\u003e\u003cp\u003eСинтаксис тернарного оператора таков:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eимя_переменной \u003d (логическое_выражение) ? значение_1 : значение_2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПеременная получает \u003ccode\u003eзначение_1\u003c/code\u003e, если \u003ccode\u003eлогическое_выражение\u003c/code\u003e истинно, и \u003ccode\u003eзначение_2\u003c/code\u003e, если \u003ccode\u003eлогическое_выражение\u003c/code\u003e ложно. \u003c/p\u003e\u003cp\u003eПоэтому, если в каждой ветви условного оператора производится только присваивание значения одной и той же переменной, то условный оператор можно заменить тернарным. \u003c/p\u003e\u003cp\u003eТеперь нам остаётся написать метод \u003ccode\u003eprint()\u003c/code\u003e, распечатывающий полученный результат. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass ElevenDivisibility {\n\t\n\tElevenDivisibility() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.next();\n\t\tin.close();\n\t}\n\t\n\tint sumThroughOne (int startPos) {\n\t\tint sum \u003d 0;\n\t\tfor (int i \u003d startPos; i \u0026lt; n.length(); i \u003d i + 2) {\n\t\t\tsum \u003d sum + (n.charAt(i) - ZERO);\n\t\t}\t\t\n\t\treturn sum;\n\t}\n\t\n\tvoid solve() {\n\t\tint evenPosSum \u003d sumThroughOne(0);\n\t\tint oddPosSum \u003d sumThroughOne(1);\n\t\tint diff \u003d Math.abs(evenPosSum - oddPosSum);\n\t\tanswer \u003d (diff % 11 \u003d\u003d 0)? \u0026quot;Yes\u0026quot;: \u0026quot;No\u0026quot;;\n\t}\n\t\n\tvoid print() {\n\t\tSystem.out.println(answer);\n\t}\n\t\n\tstatic final int ZERO \u003d (int)\u00270\u0027;\n\t\n\tString n;\n\tString answer;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНа последнем шаге напишем тело метода \u003ccode\u003emain()\u003c/code\u003e класса \u003ccode\u003eProblem03\u003c/code\u003e. В итоге получится следующий код:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\nimport java.util.Scanner;\n\npublic class Problem03 {\n\n\tpublic static void main(String[] args) {\n\t\tElevenDivisibility ed \u003d new ElevenDivisibility();\n\t\ted.solve();\n\t\ted.print();\n\t}\n\n}\n\nclass ElevenDivisibility {\n\t\n\tElevenDivisibility() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.next();\n\t\tin.close();\n\t}\n\t\n\tint sumThroughOne (int startPos) {\n\t\tint sum \u003d 0;\n\t\tfor (int i \u003d startPos; i \u0026lt; n.length(); i \u003d i + 2) {\n\t\t\tsum \u003d sum + (n.charAt(i) - ZERO);\n\t\t}\t\t\n\t\treturn sum;\n\t}\n\t\n\tvoid solve() {\n\t\tint evenPosSum \u003d sumThroughOne(0);\n\t\tint oddPosSum \u003d sumThroughOne(1);\n\t\tint diff \u003d Math.abs(evenPosSum - oddPosSum);\n\t\tanswer \u003d (diff % 11 \u003d\u003d 0)? \u0026quot;Yes\u0026quot;: \u0026quot;No\u0026quot;;\n\t}\n\t\n\tvoid print() {\n\t\tSystem.out.println(answer);\n\t}\n\t\n\tstatic final int ZERO \u003d (int)\u00270\u0027;\n\t\n\tString n;\n\tString answer;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗапустите программу на выполнение. Проверьте её работу на числах: \u003cbr /\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/28/47/284795fc7f50b95e12c6faf5b970d41b19ab8182.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e 2112 \u003cbr /\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/28/47/284795fc7f50b95e12c6faf5b970d41b19ab8182.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e 1309 \u003cbr /\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/28/47/284795fc7f50b95e12c6faf5b970d41b19ab8182.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e 919291 \u003cbr /\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/28/47/284795fc7f50b95e12c6faf5b970d41b19ab8182.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e 929192 \u003cbr /\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/28/47/284795fc7f50b95e12c6faf5b970d41b19ab8182.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e 16834193481693991524 \u003cbr /\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/28/47/284795fc7f50b95e12c6faf5b970d41b19ab8182.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e 99987305809080803457297957927598739478513 \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eПредложите свои тесты.\u003c/p\u003e\u003c/div\u003e","tags":["циклы","условные операторы","java"]}}