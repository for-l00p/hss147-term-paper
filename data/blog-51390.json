{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1491156271,"rating":33,"authorHandle":"RussianCodeCup","modificationTimeSeconds":1491156319,"id":51390,"title":"\u003cp\u003eRussian Code Cup Qual 1 — Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eA. Martian Volleyball\u003c/h2\u003e\u003cp\u003eFirst note that in order to end the game as soon as possible only the currently leading team must get points.\u003c/p\u003e\u003cp\u003eConsider the condition that one of the teams wins. It must score at least \u003ci\u003ek\u003c/i\u003e points and have at least 2 points advantage.\u003c/p\u003e\u003cp\u003eSo the answer is \u003ci\u003emax\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e, \u003ci\u003emin\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e) + 2) - \u003ci\u003emax\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e).\u003c/p\u003e\u003ch2\u003eB. Painting the Wall\u003c/h2\u003e \u003cp\u003eFirst note that if the maximal length of the continuous segment is \u003ci\u003eL\u003c/i\u003e, at least \u003ci\u003eL\u003c/i\u003e colors are needed to paint the wall. On the other side \u003ci\u003eL\u003c/i\u003e colors is always enough.\u003c/p\u003e\u003cp\u003eConsider a square \u003ci\u003eL\u003c/i\u003e × \u003ci\u003eL\u003c/i\u003e, fill the first line with integers from 1 to \u003ci\u003eL\u003c/i\u003e, fill the following lines with all its possible circular shifts. Use these squares to cover the given wall rectangle like this (\u003ci\u003eL\u003c/i\u003e \u003d 4):\u003c/p\u003e\u003ccenter\u003e 1 2 3 4 1 2 3 4 1 2\u003cp\u003e2 3 4 1 2 3 4 1 2 3\u003c/p\u003e\u003cp\u003e3 4 1 2 3 4 1 2 3 4\u003c/p\u003e\u003cp\u003e... \u003c/p\u003e\u003c/center\u003e\u003cp\u003eNow each vertical and horizontal segment of length \u003ci\u003eL\u003c/i\u003e or less has all tiles of different colors. All that is left is to bring back the lamps.\u003c/p\u003e\u003ch2\u003eC. Magic Artifact\u003c/h2\u003e \u003cp\u003eLet us denote advantage that Maxim gets if he finds artifact as \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, so \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003eb\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e.\u003c/p\u003e\u003cp\u003eLet Maxim first complete levels in order 1, 2, ..., \u003ci\u003en\u003c/i\u003e. If he finds the artifact at the \u003ci\u003ei\u003c/i\u003e-th level, the time he needs to complete the game is equal to \u003ci\u003eb\u003c/i\u003e\u003csub\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e plus \u003ci\u003ec\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e + ... + \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e. So the expected time of completing the game is:\u003c/p\u003e\u003cp\u003e\u003ci\u003eb\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e + ... + \u003ci\u003eb\u003c/i\u003e\u003csub\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ep\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e·\u003ci\u003ec\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e + \u003ci\u003ep\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e·(\u003ci\u003ec\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e + \u003ci\u003ec\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e) + ... + \u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e·(\u003ci\u003ec\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e + ... + \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e).\u003c/p\u003e\u003cp\u003e\u003ci\u003eb\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e + ... + \u003ci\u003eb\u003c/i\u003e\u003csub\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e doesn\u0027t depend on level order, so let us try to make the rest as small as possible. Expanding the sums, we get sum of all \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e·\u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e for such \u003ci\u003ei\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e that \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003ek\u003c/i\u003e.\u003c/p\u003e\u003cp\u003eLet us now swap levels \u003ci\u003ei\u003c/i\u003e and \u003ci\u003ei\u003c/i\u003e + 1 in our order. For the given \u003ci\u003ei\u003c/i\u003e among \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e·\u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e terms only the one equal to \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e·\u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e changes — it is replaced with \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e·\u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e. If the order was optimal, it must be \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e·\u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e ≤ \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e·\u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, in the other case it was optimal to swap them and get a better answer. Transform this to:\u003c/p\u003e\u003cp\u003e\u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e / \u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e / \u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e.\u003c/p\u003e\u003cp\u003eIn the optimal answer for all \u003ci\u003ei\u003c/i\u003e from 1 to \u003ci\u003en\u003c/i\u003e - 1 this inequality must be satisfied. Therefore it is optimal to sort levels according to the key \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e / \u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e. Note that if \u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 0, you may consider \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e / \u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d ∞.\u003c/p\u003e\u003cp\u003eSorting according to the key \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e / \u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e should be done carefully. If the fractions are compared using floating-point division, the case \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 0 will lead to error because 0 / 0 \u003d \u003ci\u003eNaN\u003c/i\u003e. If the fractions are compared using the comparator \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e·\u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e \u0026lt; \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e·\u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, the case \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 0 will also lead to error because the result of that comparison will always be false. That means that levels with \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 0 should be handled separately. Such levels can be completed at any time because they do not affect the result besides fixed terms \u003ci\u003eb\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e. For example, they can be placed at the end.\u003c/p\u003e\u003cp\u003eAfter sorting the desired expected value can be found using the formula above, use prefix sums for \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e to get it fast.\u003c/p\u003e\u003ch2\u003eD. Memory Manager\u003c/h2\u003e \u003cp\u003eFirst for each query \u003ci\u003eq\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e let us find \u003ci\u003ego\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e — the minimal \u003ci\u003ej\u003c/i\u003e, such that among \u003ci\u003eq\u003c/i\u003e\u003csub\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eq\u003c/i\u003e\u003csub\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/sub\u003e, ..., \u003ci\u003eq\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e there are at most \u003ci\u003ek\u003c/i\u003e different blocks — that would mean that it is possible to place pointers before the \u003ci\u003ej\u003c/i\u003e-th query in such way that queries \u003ci\u003ej\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e + 1, ..., \u003ci\u003ei\u003c/i\u003e are performed immediately. This can be made in \u003ci\u003eO\u003c/i\u003e(\u003ci\u003esum\u003c/i\u003e(|\u003ci\u003eq\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e|)), using, for example, two pointers.\u003c/p\u003e\u003cp\u003eNow let us use dynamic programming, denote as \u003ci\u003edp\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e the minimal time needed to perform the first \u003ci\u003ei\u003c/i\u003e queries. If \u003ci\u003ego\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 0 then \u003ci\u003edp\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 0. If the equation is not satisfied, \u003ci\u003edp\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003emin\u003c/i\u003e\u003csub\u003e\u003ci\u003ej\u003c/i\u003e \u003d \u003ci\u003ego\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e..\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003edp\u003c/i\u003e\u003csub\u003e\u003ci\u003ej\u003c/i\u003e - 1\u003c/sub\u003e + \u003ci\u003es\u003c/i\u003e\u003csub\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e) — we choose the query \u003ci\u003ej\u003c/i\u003e to perform the pointer movement before. Since values \u003ci\u003ego\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e do not descend, this value can be maintained using either std::set of \u003ci\u003edp\u003c/i\u003e\u003csub\u003e\u003ci\u003ej\u003c/i\u003e - 1\u003c/sub\u003e + \u003ci\u003es\u003c/i\u003e\u003csub\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e, or queue with minimum query support.\u003c/p\u003e\u003ch2\u003eE. LISA\u003c/h2\u003e \u003cp\u003eFirst let us consider the problem for given two strings: to solve it calculate the number of occurrences of each letter in the first string, the number of occurrences of each letter in the second string, not including the first letter of the first string and the last letter of the second string, that must be used any way. Now the answer is the product of string lengths, decreased by the sum of values cnt1[letter] * cnt2[letter] for each letter. Let us leave proof as an exercise, such problem was at Northern Subregional Contest of NEERC 2015 \u003ca href\u003d\"http://neerc.ifmo.ru/archive/2015/northern/north-2015-statements.pdf\"\u003e\u003c/a\u003e\u003ca\u003ehttp://neerc.ifmo.ru/archive/2015/northern/north-2015-statements.pdf\u003c/a\u003e, Problem C. Unlimited participants could solve this problem at Three Quaterfinals Cup.\u003c/p\u003e\u003cp\u003eFor \u003ci\u003en\u003c/i\u003e strings similar ideas can be used. Put all strings to a prefix trie, all strings to a suffix trie, the total number of ways to get a string is the product of the number of vertices in these tries. What we need to subtract is similar product of number of occurrences of letters in tries, first/last letters of each word must not be considered.\u003c/p\u003e\u003cp\u003eNow we need to answer segment queries. Let us make sqrt-decomposition, divide all strings to groups based on sum of their lengths. Let us greedily add strings to a group until their sum of lengths is more than sqrt(total sum of lengths). Note that the last string can have a big length.\u003c/p\u003e\u003cp\u003eNow use Mo\u0027s algorithm, sort queries using the block of the left end as a key, move right end only forward between left end block changes. To add/remove a string to a trie one must maintain the number of active vertices in a trie subtree for each vertex, and the number of entries of letters to a trie.\u003c/p\u003e\u003c/div\u003e","tags":[]}}