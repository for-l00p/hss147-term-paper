{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1481383717,"rating":2,"authorHandle":"Lance_HAOH","modificationTimeSeconds":1481416296,"id":48983,"title":"\u003cp\u003eProblem with DP in round #383 problem D (div 2)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI am trying to solve round #383 problem D (div 2):\u003c/p\u003e\u003cp\u003eProblem statement:\u003ca href\u003d\"//codeforces.com/contest/742/problem/D\"\u003ehere\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI can complete every step up till the usage of DP. In my code, I used 2-D DP like what was mentioned in the editorial. Somehow, my code is failing the following test case:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e10 5 100\n6 18 35 6 87 58 4 53 37 71\n465782 57034 547741 748298 315223 370368 679320 349012 9740 622511\n1 2\n10 9\n6 7\n3 6\n7 1\n\u003c/code\u003e\u003c/pre\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eExpected Output: 2050129\nMy Program Output: 1836591\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eMy attempt:\u003cbr /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;unordered_map\u0026gt;\n//#define debug\nusing namespace std;\n\n#define ll long long\n#define v64 vector\u0026lt;ll\u0026gt;\n#define um unordered_map\u0026lt;ll,ll\u0026gt;\n#define mp make_pair\n\nll n,m,w,a,b;\n\ntypedef struct woman {\n\tll w, b;\n} woman;\n\nwoman ww[1005];\nll par[1005], rk[1005],dp[1005][1005];\num cw, cb;\nint val[1005];\n\nll find(ll x) {\n\tll p \u003d x;\n\tif(par[x]!\u003dx) p \u003d find(par[x]);\n\treturn par[x] \u003d p;\n}\n\ninline void un(ll x,ll y) {\n\tll px \u003d find(x), py \u003d find(y);\n\tif(px !\u003d py) {\n\t\tif(rk[px] \u0026gt; rk[py]) {\n\t\t\tpar[py] \u003d px;\n\t\t\trk[px] +\u003d rk[py];\n \t\t} else {\n\t\t\tpar[px] \u003d py;\n\t\t\trk[py] +\u003d rk[px];\n\t\t}\n\t}\n}\n\nll solve(ll cur, ll t) {\n\tif(dp[cur][t]!\u003d-1) return dp[cur][t];\n\tif(cur \u0026lt;\u003d n \u0026amp;\u0026amp; t\u0026gt;0) {\n\t\tif(ww[cur].w\u0026lt;\u003dt) {\n\t\t\tif(val[find(cur)]) {\t\n\t\t\t\tval[find(cur)] \u003d 0;\n\t\t\t\tll a1  \u003d 0;\n\t\t\t\tif(cw[find(cur)]\u0026lt;\u003dt) a1 \u003d cb[find(cur)]+solve(cur+1,t-cw[find(cur)]);\n\t\t\t\tll a2 \u003d ww[cur].b+solve(cur+1,t-ww[cur].w);\n\t\t\t\tval[find(cur)] \u003d 1;\n\t\t\t\tll a3 \u003d solve(cur+1,t);\n\t\t\t\treturn dp[cur][t] \u003d max(a1,max(a2,a3));\n\t\t\t} else {\n\t\t\t\treturn dp[cur][t] \u003d solve(cur+1,t);\n\t\t\t}\n\t\t} else {\n\t\t\treturn dp[cur][t] \u003d solve(cur+1,t);\n\t\t}\n\t}\n\treturn dp[cur][t]\u003d0;\n}\n\nint main(void) {\n\t#ifdef debug\n\t\tfreopen(\u0026quot;in\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n\t#else\n\t\tios_base::sync_with_stdio(false);\n\t\tcin.tie(0);\n\t#endif\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; w;\n\tfill_n(rk,n+1,1);\n\tfill_n(val,n+1,1);\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; ++i) fill_n(dp[i],w+1,-1);\n\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; ++i) {\n\t\tcin \u0026gt;\u0026gt; ww[i].w;\n\t\tpar[i] \u003d i;\n\t}\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; ++i) {\n\t\tcin \u0026gt;\u0026gt; ww[i].b;\n\t}\n\tfor(int i \u003d 1; i \u0026lt;\u003d m; ++i) {\n\t\tcin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\t\tun(a,b);\n\t}\n\tfor(int i \u003d 1 ; i \u0026lt;\u003d n; ++i) {\n                cw[find(i)] +\u003d ww[i].w;\n                cb[find(i)] +\u003d ww[i].b;\n        }\n\tcout \u0026lt;\u0026lt; solve(1,w) \u0026lt;\u0026lt; endl;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf I remove the DP (from the solve function), my program will pass the test case. Hence, it is clear that my DP is wrong. However, I do not know how to write the DP properly. Could someone please advise me on why my code is wrong?\u003c/p\u003e\u003c/div\u003e","tags":["#round #383","#dp","#unionfind","#problem d"]}}