{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1427571682,"rating":45,"authorHandle":"Nickolas","modificationTimeSeconds":1427576254,"id":17177,"title":"\u003cp\u003eVK Cup 2015 Wild Card Round 1: editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eIn this contest we aimed to show that declarative approach to problemsolving can be more convenient than the traditional imperative. However, the first several problems were supposed to aquaint the competitor with the basic language syntax and its libraries. All reference solutions are written by \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/kit1980\" title\u003d\"Specialist kit1980\"\u003ekit1980\u003c/a\u003e.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/530/problem/A\" title\u003d\"VK Cup 2015 - Wild Card Round 1\"\u003e530A - Quadratic equation\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eTo solve a quadratic equation, one has to use a library function \u003ccode\u003esqrt\u003c/code\u003e and an if-then-else construct. Besides, this problem was supposed to show that Picat has foating-point numbers. :-)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003emain \u003d\u0026gt;\n    A \u003d read_real(), B \u003d read_real(), C \u003d read_real(),\n    D \u003d B * B - 4 * A * C,\n    X1 \u003d (-B - sqrt(D)) / (2 * A),\n    X2 \u003d (-B + sqrt(D)) / (2 * A),\n    if D \u003d\u003d 0 then\n        println(X1)\n    else\n        printf(\u0026quot;%w %w%n\u0026quot;, min(X1, X2), max(X1, X2))\n    end.\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/530/problem/B\" title\u003d\"VK Cup 2015 - Wild Card Round 1\"\u003e530B - String inside out\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eA string manipulation problem: library function \u003ccode\u003eslice\u003c/code\u003e allows to get a substring of the given string, \u003ccode\u003ereverse\u003c/code\u003e, well, reverses it, and \u003ccode\u003e++\u003c/code\u003e is concatenation operator. Alternatively, one could use loops and print the answer character-by-character.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003emain \u003d\u0026gt;\n    S \u003d read_line(),\n    N \u003d length(S),\n    X \u003d reverse(slice(S, 1, N // 2)) ++ reverse(slice(S, 1 + N // 2)),\n    println(X).\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/530/problem/C\" title\u003d\"VK Cup 2015 - Wild Card Round 1\"\u003e530C - Diophantine equation\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eThis problem can be solved using complete search (for each X check whether a suitable Y exists). The reference solution uses constraint programming, which effectively implements a search with pruning and allows to get rid of explicit search loop.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport cp.\nmain \u003d\u0026gt;\n    A \u003d read_int(), B \u003d read_int(), C \u003d read_int(),\n    X #\u0026gt; 0, Y #\u0026gt; 0,\n    if A * X + B * Y #\u003d C then\n        Solutions \u003d solve_all([X, Y])\n    else\n        Solutions \u003d []\n    end,\n    println(length(Solutions)),\n    foreach ([I, J] in Solutions)\n        printf(\u0026quot;%d %d%n\u0026quot;, I, J)\n    end.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eExpression \u003ccode\u003eA * X + B * Y #\u003d C\u003c/code\u003e sets variable constraint. At this stage the system can understand that there are no solutions and proceeed to \u003ccode\u003eelse\u003c/code\u003e branch. Otherwise \u003ccode\u003esolve_all\u003c/code\u003e function will return a list of all solutions.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/530/problem/D\" title\u003d\"VK Cup 2015 - Wild Card Round 1\"\u003e530D - Set subtraction\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eThis problem can be solved in a variety of ways, from imperative loops to constraint programming. The reference solution uses library function \u003ccode\u003esubtract\u003c/code\u003e which subtracts one sorted list from another. \u003ccode\u003eA..B\u003c/code\u003e creates a list of integers from A to B. Output is done using list comprehension. This problem is the only one in which our solution uses \u003ccode\u003e:\u003d\u003c/code\u003e â€” an exclusively imperative destructive assignment operator.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport ordset.\nimport util.\nmain \u003d\u0026gt;\n    X \u003d 1..1000,\n    N \u003d read_int(),\n    foreach (_I in 1..N)\n        A \u003d read_int(), B \u003d read_int(),\n        X :\u003d subtract(X, A..B)\n    end,\n    println(join([to_string(V) : V in [length(X) | X]])).\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/530/problem/E\" title\u003d\"VK Cup 2015 - Wild Card Round 1\"\u003e530E - Sum and product\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eThis problem can be solved in at least two ways. The \u0026quot;math\u0026quot; way requires noticing that a set of N-2 \u0026quot;1\u0026quot;s, one \u0026quot;2\u0026quot; and one \u0026quot;N+D\u0026quot; is always a valid solution. Of course, other solutions might exist, for example for N \u003d 4, D \u003d 1 a valid solution is 1, 1, 3, 3.\u003c/p\u003e\u003cp\u003eThe reference solution uses constraint programming, that allows to avoid thinking and just translate the problem statement to Picat.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport cp.\nimport util.\nmain \u003d\u0026gt;\n    N \u003d read_int(), D \u003d read_int(),\n    Vals \u003d new_list(N),\n    Vals :: 1..10000,\n    prod(Vals) #\u003d sum(Vals) + D,\n    solve(Vals),\n    println(join([to_string(V) : V in Vals])).\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/530/problem/F\" title\u003d\"VK Cup 2015 - Wild Card Round 1\"\u003e530F - Jumping frogs\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eThis problem uses breadth-first or depth-first search. In Picat, like in Prolog, depth-first search with backtracking is built-in. Tabling technique is used for memoization and for automated search of maximum: expression \u003ccode\u003etable(+, +, +, max)\u003c/code\u003e means that the first three parameters of the predicate are input, the last one is output, and has to be maximized. \u003ccode\u003e?\u003d\u0026gt;\u003c/code\u003e means non-determinism: call to \u003ccode\u003ejump\u003c/code\u003e itself can return different values for same input parameters, so \u003ccode\u003etable\u003c/code\u003e selects the maximal of them. \u003ccode\u003ebest_frog\u003c/code\u003e uses the same technique to avoid an explicit loop over frogs to search for the best frog.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etable(+, +, +, max)\njump(X, Y, K, Dist) ?\u003d\u0026gt;\n    (\n      NewX \u003d X + K, NewY \u003d Y ;\n      NewX \u003d X - K, NewY \u003d Y ;\n      NewX \u003d X, NewY \u003d Y + K ;\n      NewX \u003d X, NewY \u003d Y - K\n    ),\n    land(NewX, NewY),\n    jump(NewX, NewY, K, Dist).\njump(X, Y, _K, Dist) \u003d\u0026gt;\n    Dist \u003d abs(X) + abs(Y).\n\ntable(-, max)\nbest_frog(K, Dist) ?\u003d\u0026gt;\n    between(1, 10, K),\n    jump(0, 0, K, Dist).\n\nmain \u003d\u0026gt;\n    N \u003d read_int(),\n    Facts \u003d [$land(X, Y) : _I in 1..N, X \u003d read_int(), Y \u003d read_int()],\n    cl_facts(Facts),\n    best_frog(_K, Dist),\n    println(Dist).\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/530/problem/G\" title\u003d\"VK Cup 2015 - Wild Card Round 1\"\u003e530G - Levenshtein distance\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eA classic dynamic programming problem. The reference solution uses tabling to implement recursion with memoization, similar to problem \u003ca href\u003d\"/contest/530/problem/F\" title\u003d\"VK Cup 2015 - Wild Card Round 1\"\u003e530F - Jumping frogs\u003c/a\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etable(+, +, min)\nedit(I, J, Cost) ?\u003d\u0026gt;\n    str(S), goal(G),\n    N \u003d length(S), M \u003d length(G),\n    (\n        I \u0026lt;\u003d N, J \u0026lt;\u003d M,\n        edit(I + 1, J + 1, NextCost),\n        Cost \u003d abs(ord(S[I]) - ord(G[J])) + NextCost\n    ;\n        I \u0026lt;\u003d N,\n        edit(I + 1, J, NextCost),\n        Cost \u003d ord(S[I]) - 0\u0027a + 1 + NextCost\n    ;\n        J \u0026lt;\u003d M,\n        edit(I, J + 1, NextCost),\n        Cost \u003d ord(G[J]) - 0\u0027a + 1 + NextCost\n    ;\n        I \u0026gt; N, J \u0026gt; M,\n        Cost \u003d 0\n    ).\n\nmain \u003d\u0026gt;\n    S \u003d read_line(), G \u003d read_line(),\n    cl_facts([$str(S), $goal(G)]),\n    edit(1, 1, Cost),\n    println(Cost).\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/530/problem/H\" title\u003d\"VK Cup 2015 - Wild Card Round 1\"\u003e530H - Points in triangle\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eThis problem requires a reasonable search of possible triangle vertices with a check whether all points are inside. The points\u0027 coordinates can have values up to 100, so the triangle\u0027s vertices never need to have coordinates over 200.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport cp.\nmain \u003d\u0026gt;\n    N \u003d read_int(),\n    A :: 1..200, B :: 1..200,\n    foreach (_I in 1..N)\n        Xi \u003d read_int(), Yi \u003d read_int(),\n        B * Xi #\u0026lt;\u003d A * (B - Yi)\n    end,\n    solve([$min(A * B)], [A, B]),\n    println(A * B / 2).\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e\u003ca href\u003d\"/contest/530/problem/I\" title\u003d\"VK Cup 2015 - Wild Card Round 1\"\u003e530I - Different variables\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eThis problem is in fact a graph coloring problem. The reference solution uses constraint programming with \u003ccode\u003eall_distinct\u003c/code\u003e constraint. To speed up program execution one had to notice that the first variable is always 1. With this observation one could also use \u003ccode\u003eall_different\u003c/code\u003e constraint (these two constraints differ in internal algorithm implementation), without it \u003ccode\u003eall_different\u003c/code\u003e is too slow.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport cp.\nimport util.\nmain \u003d\u0026gt;\n    N \u003d read_int(), K \u003d read_int(),\n    Vars \u003d new_array(N),\n    Vars :: 1..N, Vars[1] #\u003d 1,\n    foreach(_I in 1..K)\n        [_ | Indexes] \u003d [to_integer(A) : A in split(read_line())],\n        all_distinct([Vars[Idx] : Idx in Indexes])\n    end,\n    List \u003d to_list(Vars), MaxC #\u003d max(List),\n    solve([$min(MaxC)], Vars),\n    println(join([to_string(V) : V in Vars])).\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["vkcup2015","surprise language round","unknown language round"]}}