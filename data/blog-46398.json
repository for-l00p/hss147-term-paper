{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1470155482,"rating":7,"authorHandle":"NibNalin","modificationTimeSeconds":1470170050,"id":46398,"title":"\u003cp\u003eIOI Mini Training Contest 4 Follow up\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI hope you liked the problems. Below I have mentioned sources and brief idea of solutions. The number of hints for a problem also correspond to it\u0027s difficulty level(according to me).\u003c/p\u003e\u003ch2\u003eA. Sums\u003c/h2\u003e\u003cp\u003e\u003ca href\u003d\"http://main.edu.pl/en/archive/oi/10/sum\"\u003ePOI X OI Stage III-day 1\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFor every value \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/40/99/4099a3ceb10f1d6d06ac9226e30c3024ae7a7d8e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e there shall be some \u0026quot;starter\u0026quot; point, basically if some number of form \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e·\u003ci\u003eA\u003c/i\u003e[0] + \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is form-able, then everything beyond this value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e of form \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e·\u003ci\u003eA\u003c/i\u003e[0] + \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ey\u003c/i\u003e ≥ \u003ci\u003eK\u003c/i\u003e)\u003c/span\u003e is also formable. How can you use this fact to quickly compute the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTry to model this as a graph\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\nusing namespace std;\n\nconst int inf \u003d 1707050917;\n\nint main(void)\n{\n\tint n;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\tvector\u0026lt;int\u0026gt; A(n);\n\tfor(int i \u003d 0;i \u0026lt; n;i++) scanf(\u0026quot;%d\u0026quot;, \u0026amp;A[i]);\n\tsort(A.begin(), A.end());\n\tvector\u0026lt;int\u0026gt; D(A[0], inf);\n\tD[0] \u003d 0;\n\tset\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; Q;\n\tQ.insert(make_pair(0, D[0]));\n\n\twhile(!Q.empty())\n\t{\n\t\tpair\u0026lt;int, int\u0026gt; top \u003d *Q.begin();\n\t\tQ.erase(Q.begin());\n\n\t\tfor(int i \u003d 1;i \u0026lt; n;i++)\n\t\t{\n\t\t\tif(D[(top.second+A[i])%A[0]] \u0026gt; D[top.second]+A[i])\n\t\t\t{\n\t\t\t\tif(D[(top.second+A[i])%A[0]] !\u003d inf) Q.erase(make_pair(D[(top.second+A[i])%A[0]], (top.second+A[i])%A[0]));\n\t\t\t\tD[(top.second+A[i])%A[0]] \u003d D[top.second]+A[i];\n\t\t\t\tQ.insert(make_pair(D[(top.second+A[i])%A[0]], (top.second+A[i])%A[0]));\n\t\t\t}\n\t\t}\n\t}\n\n\tint k, v;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;k);\n\twhile(k--)\n\t{\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;v);\n\t\tif(v \u0026gt;\u003d D[v%A[0]]) printf(\u0026quot;TAK\\n\u0026quot;);\n\t\telse printf(\u0026quot;NIE\\n\u0026quot;);\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003eB. Networks\u003c/h2\u003e\u003cp\u003e\u003ca href\u003d\"http://wcipeg.com/problem/noi07p1\"\u003eNOI \u002707 Day 1, Problem 1\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eCompute number of paths b/w all pairs of nodes using Floyd Warshall, or Dijkstra multiple times.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\nusing namespace std;\nconst int N \u003d 105;\nconst int inf \u003d 1e9 + 7;\nint n , m;\nint graph[N][N];\nlong long ways[N][N];\nint a , b , c;\nint main(){\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n    for(int i \u003d 1 ; i \u0026lt;\u003d n ; ++i){\n        for(int j \u003d 1 ; j \u0026lt;\u003d n ; ++j){\n            graph[i][j] \u003d inf;\n            ways[i][j] \u003d 0;\n        }\n        graph[i][i] \u003d 0;\n    }\n    for(int i \u003d 1 ; i \u0026lt;\u003d m ; ++i){\n        cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c;\n        graph[a][b] \u003d c;\n        graph[b][a] \u003d c;\n        ++ways[a][b];\n        ++ways[b][a];\n    }\n    for(int k \u003d 1 ; k \u0026lt;\u003d n ; ++k){\n        for(int i \u003d 1 ; i \u0026lt;\u003d n ; ++i){\n            for(int j \u003d 1 ; j \u0026lt;\u003d n ; ++j){\n                if(i !\u003d k \u0026amp; j !\u003d k \u0026amp;\u0026amp; i !\u003d j){\n                    if(graph[i][k] + graph[k][j] \u0026lt; graph[i][j]){\n                        graph[i][j] \u003d graph[i][k] + graph[k][j];\n                        ways[i][j] \u003d 0;\n                    }\n                    if(graph[i][k] + graph[k][j] \u003d\u003d graph[i][j]){\n                        ways[i][j] +\u003d ways[i][k] * ways[k][j];\n                    }\n                }\n            }\n        }\n    }\n    for(int i \u003d 1 ; i \u0026lt;\u003d n ; ++i){\n        double ans \u003d 0.0;\n        for(int s \u003d 1 ; s \u0026lt;\u003d n ; ++s){\n            for(int t \u003d 1 ; t \u0026lt;\u003d n ; ++t){\n                if(s !\u003d i \u0026amp;\u0026amp; t !\u003d i){\n                    if(graph[s][i] + graph[i][t] \u003d\u003d graph[s][t]){\n                        ans +\u003d 1.0 * ways[s][i] * ways[i][t] / ways[s][t];\n                    }\n                }\n            }\n        }\n        printf(\u0026quot;%.5lf\\n\u0026quot; , ans);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003eC. Points and Lines\u003c/h2\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/gym/100402/problem/E\"\u003e2008-2009 Summer Petrozavodsk Camp, Andrew Stankevich Contest 32 (ASC 32) Problem E\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThe brute force approach storing all sizes of current \u0026quot;components\u0026quot; is slightly obvious. This can be solved using recursion+memoization but obviously won\u0027t get accepted. The trick is to use this program to make observations for the more efficient DP.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThe most major observation is that only the number of odd sized and even sized components matters if you consider representing the within component connections separately(this can be proven with a greedy argument). So, we can reduce our brute force approach to work much faster in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e·2)\u003c/span\u003e but this is not fast enough or memory efficient enough to be able to work.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint 3\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eIf you observe that only the value of within component connections mod 2 matters, your problem is solved. What is the intuition behind this? That is the main reason why you even have even size components and odd size components in the state. Even is basically like a losing position, if you make it odd from even the other player can simply reverse this decision, so you will end up the same state, so you wouldn\u0027t want to go to even from odd state, but rather go from even to odd state(preferably).\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;fstream\u0026gt;\nusing namespace std;\n\nvector\u0026lt;int\u0026gt; par;\nvector\u0026lt;vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt;\u0026gt; memo;\n\ninline int root(int v)\n{\n\treturn ((par[v]\u0026lt;0)?(v):(par[v]\u003droot(par[v])));\n}\n\nvoid dsu(int x, int y)\n{\n\tif((x \u003d root(x)) \u003d\u003d (y \u003d root(y))) return;\n\tif(par[x] \u0026gt; par[y]) swap(x, y);\n\tpar[x] +\u003d par[y];\n\tpar[y] \u003d x;\n}\n\nint DP(int odd, int even, int combi, int player)\n{\n\tif((even \u003d\u003d 1 \u0026amp;\u0026amp; odd \u003d\u003d 0) || (odd \u003d\u003d 1 \u0026amp;\u0026amp; even \u003d\u003d 0)) return !player;\n\tif(memo[odd][even][combi][player] !\u003d -1) return memo[odd][even][combi][player];\n\tif(combi)\n\t{\n\t\tif(DP(odd, even, !combi, !player) \u003d\u003d player)\n\t\t{\n\t\t\tmemo[odd][even][combi][player] \u003d player;\n\t\t\treturn player;\n\t\t}\n\t}\n\tif(odd \u0026gt; 1)\n\t{\n\t\tif(DP(odd-2, even+1, combi, !player) \u003d\u003d player)\n\t\t{\n\t\t\tmemo[odd][even][combi][player] \u003d player;\n\t\t\treturn player;\n\t\t}\n\t}\n\tif(even \u0026gt; 1)\n\t{\n\t\tif(DP(odd, even-1, !combi, !player) \u003d\u003d player)\n\t\t{\n\t\t\tmemo[odd][even][combi][player] \u003d player;\n\t\t\treturn player;\n\t\t}\n\t}\n\tif(odd \u0026gt; 0 \u0026amp;\u0026amp; even \u0026gt; 0)\n\t{\n\t\tif(DP(odd, even-1, !combi, !player) \u003d\u003d player)\n\t\t{\n\t\t\tmemo[odd][even][combi][player] \u003d player;\n\t\t\treturn player;\n\t\t}\n\t}\n\tmemo[odd][even][combi][player] \u003d !player;\n\treturn !player;\n}\n\nint main(void)\n{\n\tifstream fin(\u0026quot;points.in\u0026quot;);\n\tofstream fout(\u0026quot;points.out\u0026quot;);\n\tint n, m, u, v;\n\tfin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tpar.clear(); par.resize(n, -1);\n\tmemo.clear(); memo.resize(2*n+2, vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt;(2*n+2, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(3, vector\u0026lt;int\u0026gt;(2, -1))));\n\n\tfor(int i \u003d 0;i \u0026lt; m;i++)\n\t{\n\t\tfin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v;\n\t\tu--; v--;\n\t\tdsu(u, v);\n\t}\n\n\tint odd \u003d 0, even \u003d 0, combi \u003d -m;\n\tfor(int i \u003d 0;i \u0026lt; n;i++)\n\t{\n\t\tif(par[i] \u0026lt; 0)\n\t\t{\n\t\t\tif((-par[i])%2) odd++;\n\t\t\telse even++;\n\n\t\t\tcombi +\u003d ((-par[i])*(-par[i]-1))/2;\n\t\t}\n\t}\n\tint res \u003d DP(odd, even, combi%2, 0);\n\tif(res) fout \u0026lt;\u0026lt; \u0026quot;Betty\\n\u0026quot;;\n\telse fout \u0026lt;\u0026lt; \u0026quot;Andrew\\n\u0026quot;;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["tutorial","source","ag"]}}