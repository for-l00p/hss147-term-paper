{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1481039342,"rating":293,"authorHandle":"Al.Cash","modificationTimeSeconds":1523113402,"id":48868,"title":"\u003cp\u003eGeometry: Polygon algorithms\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI decided to share my implementations for the basic polygon algorithms. I see almost no problems on this topic and I hope this will change in the future.\u003c/p\u003e\u003cp\u003eFirst, let\u0027s remind the definitions we will use:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003e\u003cstrong\u003ePolygon\u003c/strong\u003e is a plane figure that is bounded by a finite chain of straight line segments closing in a loop to form a closed chain or circuit. These segments are called its edges or sides, and the points where two edges meet are the polygon\u0027s vertices or corners (\u003ca href\u003d\"https://en.wikipedia.org/wiki/Polygon\"\u003ewiki\u003c/a\u003e).\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003ePolygon is \u003cstrong\u003econvex\u003c/strong\u003e if a line segment connecting any two points on its boundary lies inside the polygon. Equivalently, all its interior angles are less than or equal to 180 degrees.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003ePolygon is \u003cstrong\u003estrictly convex\u003c/strong\u003e if in addition no three vertices lie on the same line. Equivalently, all its interior angles are less than 180 degrees.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003ePolygon is \u003cstrong\u003esimple\u003c/strong\u003e if its boundary doesn\u0027t cross itself.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eI will present two algorithms for each problem: one for \u003cstrong\u003earbitrary simple polygon\u003c/strong\u003e, and one for \u003cstrong\u003estrictly convex polygon\u003c/strong\u003e, that has better complexity. The priorities in implementation design were as follows:\u003c/p\u003e \u003cul\u003e   \u003cli\u003ehandle all the corner cases, \u003cstrong\u003eexcept for degenerate polygons\u003c/strong\u003e with zero area;\u003c/li\u003e   \u003cli\u003eperform all computations in integers;\u003c/li\u003e   \u003cli\u003eoptimize performance;\u003c/li\u003e   \u003cli\u003ewrite as concise and clear code as possible.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003ePlease, let me know if you find a way to improve on any of these goals in any algorithm listed. First, some references.\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eThe code in this article will make no sense unless you read \u003ca href\u003d\"//codeforces.com/blog/entry/48122\"\u003emy previous one\u003c/a\u003e. I will use structures and functions defined there.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eI highly recommend reading \u003ca href\u003d\"http://cs.smith.edu/~orourke/books/compgeom.html\"\u003eComputational Geometry in C (2nd Edition)\u003c/a\u003e by \u003ca href\u003d\"http://cs.smith.edu/~orourke/Welcome.html\"\u003eJoseph O\u0027Rourke\u003c/a\u003e (google for pdf version). This is truly fundamental work on this topic! While the code in there is far from perfect, the ideas are described well in my opinion. I will indicate specific pages when I reference this book.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eSome algorithms can be found on \u003ca href\u003d\"http://geomalgorithms.com\"\u003egeomalgorithms.com\u003c/a\u003e, but I dislike the implementations. I took only one from there.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eI define \u003ccode\u003ePolygon\u003c/code\u003e as a \u003ccode\u003evector\u003c/code\u003e of \u003ccode\u003ePoint\u003c/code\u003es. Polygon size is denoted as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e in the complexity formulas. Since polygon is a chain, the next two functions help in jumping from the last vertex to the first and vice versa when necessary. After writing all the algorithms I realized it would be better to implement custom iterators to do that. Maybe one dayâ€¦\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F\u0026gt; using Polygon \u003d vector\u0026lt;Point\u0026lt;F\u0026gt;\u0026gt;;\ninline int prev(int i, int n) { return i \u003d\u003d 0 ? n-1 : i-1; }\ninline int next(int i, int n) { return i \u003d\u003d n-1 ? 0 : i+1; }\ntemplate \u0026lt;class T\u0026gt; inline int sgn(const T\u0026amp; x) { return (T(0) \u0026lt; x) - (x \u0026lt; T(0)); }\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e1. Area: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e\u003c/h3\u003e\u003cp\u003eProbably, everyone knows how to compute polygon area as a sum of triangle or trapezoid areas. If not, you can read [\u003ca href\u003d\"http://geomalgorithms.com/a01-_area.html\"\u003egeomalgorithms\u003c/a\u003e] or [O\u0027Rourke, p.16] for more detailed explanation. However, as it\u0027s shown in \u003ccode\u003earea2D_Polygon\u003c/code\u003e on \u003cem\u003egeomalgorithms\u003c/em\u003e, this computation can be optimized, resulting in the following code:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F\u0026gt;\nF area(const Polygon\u0026lt;F\u0026gt;\u0026amp; poly) {\n  int n \u003d static_cast\u0026lt;int\u0026gt;(poly.size());\n  F area \u003d F(0);\n  for (int i \u003d 0; i \u0026lt; n; ++i)\n    area +\u003d poly[i].x * (poly[next(i, n)].y - poly[prev(i, n)].y);\n  return area;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNote that this function returns \u003cstrong\u003edoubled oriented area\u003c/strong\u003e. Doubled, because for any polygon with integer coordinated the area may be not integer but half-integer. Oriented means that it\u0027s positive if polygon vertices are listed in counter-clockwise (ccw) order and negative otherwise.\u003c/p\u003e\u003ch3\u003e2. Orientation\u003c/h3\u003e\u003cp\u003ePolygon vertices are given in either counter-clockwise or clockwise order. \u003cstrong\u003eAll the algorithms below assume that orientation is counter-clockwise\u003c/strong\u003e. Because of that, we need a way to verify this condition. Common solution is to check the sign of \u003ccode\u003earea\u003c/code\u003e return value. However, it\u0027s not necessary to compute the area.\u003c/p\u003e\u003ch4\u003e2.1 Simple polygon: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e\u003c/h4\u003e\u003cp\u003eAs noted in [O\u0027Rourke, p.12], it\u0027s enough to check orientation at one of extreme polygon vertices, for example lower-left. Complexity remains the same, but operations are faster: comparisons instead of multiplication and summation.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// True if orientation of a simple polygon is counter-clockwise.\ntemplate \u0026lt;class F\u0026gt; \nbool orientation(const Polygon\u0026lt;F\u0026gt;\u0026amp; poly) {\n  int n \u003d static_cast\u0026lt;int\u0026gt;(poly.size());\n  int i \u003d static_cast\u0026lt;int\u0026gt;(min_element(begin(poly), end(poly)) - begin(poly));\n  return ccw(poly[prev(i, n)], poly[next(i, n)], poly[i]) \u0026gt; 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e2.2 Convex polygon: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e\u003c/h4\u003e\u003cp\u003eAll vertices of the convex polygon are extreme, so we can check orientation at an arbitrary vertex.\u003c/p\u003e\u003ch3\u003e3. Convex hull: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e\u003c/h3\u003e\u003cp\u003eWe will be using convex polygons, so first let\u0027s learn to build one from a set of points. There are various algorithms with the same complexity, so I chose the one with the smallest constant: Andrew\u0027s monotone chain algorithm [\u003ca href\u003d\"http://geomalgorithms.com/a10-_hull-1.html\"\u003egeomalgorithms\u003c/a\u003e]. It\u0027s faster, because points are sorted lexicographically, not using more complex angle comparison as in \u003ccode\u003esortByAngle\u003c/code\u003e in my previous article. The implementation was taken from \u003ca href\u003d\"https://github.com/stjepang/snippets/blob/master/convex_hull.cpp\"\u003ehere\u003c/a\u003e. The difference is that I build right and left chains, not upper and lower. Also, I handle the degenerate case when all the points coincide. In such case the original code outputs 2 points instead of one.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F\u0026gt;\nPolygon\u0026lt;F\u0026gt; convexHull(Polygon\u0026lt;F\u0026gt; points) {\n  sort(begin(points), end(points));\n  Polygon\u0026lt;F\u0026gt; hull;\n  hull.reserve(points.size() + 1);\n  for (int phase \u003d 0; phase \u0026lt; 2; ++phase) {\n    auto start \u003d hull.size();\n    for (auto\u0026amp; point : points) {\n      while (hull.size() \u0026gt;\u003d start+2 \u0026amp;\u0026amp;\n             ccw(point, hull.back(), hull[hull.size()-2]) \u0026lt;\u003d 0)\n        hull.pop_back();\n      hull.push_back(point);\n    }\n    hull.pop_back();\n    reverse(begin(points), end(points));\n  }\n  if (hull.size() \u003d\u003d 2 \u0026amp;\u0026amp; hull[0] \u003d\u003d hull[1]) hull.pop_back();\n  return hull;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e4. Inclusion tests\u003c/h3\u003e\u003cp\u003eGiven a point, sometimes we need to check whether it lies inside or outside the given polygon. All the functions below return\u003c/p\u003e \u003cul\u003e   \u003cli\u003e-1 if the point is strictly inside the polygon;\u003c/li\u003e   \u003cli\u003e0 if the point is on the boundary;\u003c/li\u003e   \u003cli\u003e1 if the point is outside the polygon.\u003c/li\u003e \u003c/ul\u003e\u003ch4\u003e4.1 Triangle: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e\u003c/h4\u003e\u003cp\u003eThe easiest example of a polygon is triangle. It\u0027s an important object in computer graphics and deserves special treating :) All the cases are visualized in [O\u0027Rourke, p.235], from where I derived the following conditions:\u003c/p\u003e \u003cul\u003e   \u003cli\u003epoint is inside if all the signs are equal;\u003c/li\u003e   \u003cli\u003epoint is outside if there are two opposite signs;\u003c/li\u003e   \u003cli\u003eotherwise point is on the boundary (two signs are equal and the third one is 0).\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F1, class F2\u0026gt;\nint pointVsTriangle(const Point\u0026lt;F1\u0026gt;\u0026amp; point, const Polygon\u0026lt;F2\u0026gt;\u0026amp; triangle) {\n  assert(triangle.size() \u003d\u003d 3);\n  int signs[3];\n  for (int i \u003d 0; i \u0026lt; 3; ++i)\n    signs[i] \u003d sgn(ccw(point, triangle[next(i, 3)], triangle[i]));\n  if (signs[0] \u003d\u003d signs[1] \u0026amp;\u0026amp; signs[1] \u003d\u003d signs[2]) return -1;\n  for (int i \u003d 0; i \u0026lt; 3; ++i) if (signs[i] * signs[next(i, 3)] \u003d\u003d -1) return 1;\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e4.2 Convex polygon: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e\u003c/h4\u003e\u003cp\u003e\u003cimg src\u003d\"/predownloaded/79/cf/79cf8b9fa8b4dc60db74ae8a2d2b888514e100c0.png\" style\u003d\"float: right;max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThe popular approach here is to triangulate the polygon by drawing diagonals from one vertex to all the others, find the angle where the given point lies using binary search, and then check if it\u0027s inside the triangle or not. However, I got the best time on the problem \u003ca href\u003d\"/contest/166/problem/B\" title\u003d\"Codeforces Round 113 (Div. 2)\"\u003e166B - ÐœÐ½Ð¾Ð³Ð¾ÑƒÐ³Ð¾Ð»ÑŒÐ½Ð¸ÐºÐ¸\u003c/a\u003e using the same approach as in convex hull construction (and I\u0027m not the only one using fast I/O there). Also, I have less special cases to check (even if we don\u0027t need to distinguish the border from the interior).\u003c/p\u003e\u003cp\u003eIf the point is below (or on the same horizontal line but to the right of) the lower-left vertex, it\u0027s definitely outside, similarly for upper-right. Now, let\u0027s connect the lower-left and the upper-right polygon vertices. If the given point lies on this line, it\u0027s either on the polygon boundary (if it coincides with one of the endpoints or this line is a polygon edge) or inside. If the point is to the right (analogously to the left), we need to check if it\u0027s to the left of the right chain built by the convex hull algorithm. The corresponding edge is found using binary search, again comparing points lexicographically.\u003c/p\u003e\u003cp\u003eCurrent implementation assumes that lower-left index has index 0, and we know the index of upper-right vertex (called \u003ccode\u003etop\u003c/code\u003e, it can be found once in linear time). This assumption is perfectly reasonable, because if fits the output of convex hull algorithm. Picture shows points locations that will be compared with each polygon edge. For example, point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e with be compared with edge 2-3, and it\u0027s inside the polygon because it\u0027s to the left of this edge.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F1, class F2\u0026gt;\nint pointVsConvexPolygon(const Point\u0026lt;F1\u0026gt;\u0026amp; point, const Polygon\u0026lt;F2\u0026gt;\u0026amp; poly, int top) {\n  if (point \u0026lt; poly[0] || point \u0026gt; poly[top]) return 1;\n  auto orientation \u003d ccw(point, poly[top], poly[0]);\n  if (orientation \u003d\u003d 0) {\n    if (point \u003d\u003d poly[0] || point \u003d\u003d poly[top]) return 0;\n    return top \u003d\u003d 1 || top + 1 \u003d\u003d poly.size() ? 0 : -1;\n  } else if (orientation \u0026lt; 0) {\n    auto itRight \u003d lower_bound(begin(poly) + 1, begin(poly) + top, point);\n    return sgn(ccw(itRight[0], point, itRight[-1]));\n  } else {\n    auto itLeft \u003d upper_bound(poly.rbegin(), poly.rend() - top-1, point);\n    return sgn(ccw(itLeft \u003d\u003d poly.rbegin() ? poly[0] : itLeft[-1], point, itLeft[0]));\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eExercise\u003c/em\u003e: verify that this code works correctly when horizontal edges are present.\u003c/p\u003e\u003ch4\u003e4.3 Simple polygon: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e\u003c/h4\u003e\u003cp\u003e\u003cimg src\u003d\"/predownloaded/3c/46/3c4663a27750a919ab8c819d45360ae3c703463f.png\" style\u003d\"float: right;max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eWe will use the winding number described for example on [\u003ca href\u003d\"http://geomalgorithms.com/a03-_inclusion.html\"\u003egeomalgorithms\u003c/a\u003e], the same number is the answer for the problem \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1599\"\u003eTimus 1599\u003c/a\u003e. It\u0027s defined as a number of full counter-clockwise turns around the given point we make if we follow the polygon edges. In case of a simple polygon it\u0027s either 1 when the point is inside or 0 if outside.\u003c/p\u003e\u003cp\u003eWinding number can be computed in the following way. We draw an arbitrary ray from the given point and each time the polygon edge crosses it we add either +1 if the crossing was from the right to the left side and -1 otherwise. Such edges are marked with arrows on the picture. For optimization purposes I chose the horizontal ray going in increasing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e direction. The ray itself is included in the upper half-plane. For a horizontal edge, I check whether it contains the given point. If the edge endpoints are on the different sides of the line containing the ray, I check if the edge crosses this line to the right side of the given point.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F1, class F2\u0026gt;\nint pointVsPolygon(const Point\u0026lt;F1\u0026gt;\u0026amp; point, const Polygon\u0026lt;F2\u0026gt;\u0026amp; poly) {\n  int n \u003d static_cast\u0026lt;int\u0026gt;(poly.size()), windingNumber \u003d 0;\n  for (int i \u003d 0; i \u0026lt; n; ++i) {\n    if (point \u003d\u003d poly[i]) return 0;\n    int j \u003d next(i, n);\n    if (poly[i].y \u003d\u003d point.y \u0026amp;\u0026amp; poly[j].y \u003d\u003d point.y) {\n      if (min(poly[i].x, poly[j].x) \u0026lt;\u003d point.x \u0026amp;\u0026amp;\n          point.x \u0026lt;\u003d max(poly[i].x, poly[j].x)) return 0;\n    } else {\n      bool below \u003d poly[i].y \u0026lt; point.y;\n      if (below !\u003d (poly[j].y \u0026lt; point.y)) {\n        auto orientation \u003d ccw(point, poly[j], poly[i]);\n        if (orientation \u003d\u003d 0) return 0;\n        if (below \u003d\u003d (orientation \u0026gt; 0)) windingNumber +\u003d below ? 1 : -1;\n      }\n    }\n  }\n  return windingNumber \u003d\u003d 0 ? 1 : -1;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eExercise\u003c/em\u003e: think of an example when the \u003ccode\u003epoint \u003d\u003d poly[i]\u003c/code\u003e check is necessary.\u003c/p\u003e\u003ch3\u003e5. Extreme points\u003c/h3\u003e\u003cp\u003eI define an extreme vertex with respect to the given direction as following: if we draw a line through this vertex in the given direction, there are no polygon vertices to the right of it. This direction can be fixed for all vertices, or it can be for example direction from a given point to the vertex. In the latter case extreme vertex is the right tangent vertex (for example vertices 1 and 2 for point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e in the picture).\u003c/p\u003e\u003ch4\u003e5.1 Convex polygon: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e\u003c/h4\u003e\u003cp\u003e\u003cimg src\u003d\"/predownloaded/9d/63/9d636d8e31872c167efaba40283d3c582ee54ffe.png\" style\u003d\"float: right;max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThe binary search algorithm was described in [O\u0027Rourke, p.270] and implemented in functions [\u003ca href\u003d\"http://geomalgorithms.com/a14-_extreme_pts.html\"\u003epolyMax_2D\u003c/a\u003e] and [\u003ca href\u003d\"http://geomalgorithms.com/a15-_tangents.html\"\u003etangent_PointPolyC\u003c/a\u003e]. My contribution here is writing one general function instead of three similar ones. I packed all the cases handling into one \u003ccode\u003eif\u003c/code\u003e statement. At least for me, it\u0027s easier to understand and remember. Also, I believe the cases when direction coincides with polygon side (as in the picture) aren\u0027t handled correctly. These cases are (in O\u0027Rourke notation):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eif C points neither up nor down\n\tif A points up\n\t\tthen [a, b] \u0026lt;- [a, c]\n\t\telse [a, b] \u0026lt;- [c, b]\nif A points neither up nor down\n\tif C points up\n\t\tthen [a, b] \u0026lt;- [c, b]\n\t\telse [a, b] \u0026lt;- [a, c]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThere are at most 2 vertices where this can happen (1 and 5 in the picture) and one of them is always extreme (number 1). This implies \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e can\u0027t both point neither up nor down at the same time.\u003c/p\u003e\u003cp\u003eNow I\u0027ll explain my implementation a bit. \u003ccode\u003evertexCmp\u003c/code\u003e returns -1 if vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is to the right of vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e with respect to the given direction. \u003ccode\u003eisExtreme\u003c/code\u003e just follows my definition, but in case when there are two extreme vertices on the same line, it returns \u003ccode\u003etrue\u003c/code\u003e only for the first in counter-clockwise order (\u003ccode\u003etrue\u003c/code\u003e for 1 and 5, \u003ccode\u003efalse\u003c/code\u003e for 2 and 0 in the picture). Once extreme vertex is encountered, it\u0027s immediately returned. For the algorithm to work correctly, the binary search isn\u0027t executed in case vertex 0 is extreme.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F, class Function\u0026gt;\nint extremeVertex(const Polygon\u0026lt;F\u0026gt;\u0026amp; poly, Function direction) {\n  int n \u003d static_cast\u0026lt;int\u0026gt;(poly.size()), left \u003d 0, leftSgn;\n  auto vertexCmp \u003d [\u0026amp;poly, direction](int i, int j) {\n    return sgn(ccw(direction(poly[j]), poly[j] - poly[i])); };\n  auto isExtreme \u003d [n, vertexCmp](int i, int\u0026amp; iSgn) {\n    return (iSgn \u003d vertexCmp(next(i, n), i)) \u0026gt;\u003d 0 \u0026amp;\u0026amp; vertexCmp(i, prev(i, n)) \u0026lt; 0; };\n  for (int right \u003d isExtreme(0, leftSgn) ? 1 : n; left + 1 \u0026lt; right;) {\n    int middle \u003d (left + right) / 2, middleSgn;\n    if (isExtreme(middle, middleSgn)) return middle;\n    if (leftSgn !\u003d middleSgn ? leftSgn \u0026lt; middleSgn\n        : leftSgn \u003d\u003d vertexCmp(left, middle)) right \u003d middle;\n    else left \u003d middle, leftSgn \u003d middleSgn;\n  }\n  return left;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eProbably, you have a question regarding \u003ccode\u003edirection\u003c/code\u003e function. Below is the code showing how this function looks like to find the right and left tangents from the given point. Fixed direction will be demonstrated in Section 6.1.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F1, class F2\u0026gt;\npair\u0026lt;int, int\u0026gt; tangentsConvex(const Point\u0026lt;F1\u0026gt;\u0026amp; point, const Polygon\u0026lt;F2\u0026gt;\u0026amp; poly) {\n  return {\n    extremeVertex(poly, [\u0026amp;point](const Point\u0026lt;F2\u0026gt;\u0026amp; q) { return q - point; }),\n    extremeVertex(poly, [\u0026amp;point](const Point\u0026lt;F2\u0026gt;\u0026amp; q) { return point - q; })};\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e5.2 Simple polygon\u003c/h4\u003e\u003cp\u003eExtreme points always lie on the convex hull. If you\u0027re processing multiple queries for such points, it\u0027s worthwhile to build the convex hull for the given points beforehand and apply the algorithm from Section 5.1. Convex hull can be built using algorithm from Section 3, but there\u0027s \u003ca href\u003d\"http://geomalgorithms.com/a12-_hull-3.html\"\u003emore efficient solution\u003c/a\u003e for simple polygons I have yet to analyze.\u003c/p\u003e\u003ch3\u003e6. Polygon stabbing\u003c/h3\u003e\u003cp\u003eThe problem of finding the intersection of a geometric object with a line is often called the \u0026quot;stabbing\u0026quot; problem.\u003c/p\u003e\u003ch4\u003e6.1 Convex polygon: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e\u003c/h4\u003e\u003cp\u003eOK, here\u0027s the place where I got lazy. I just implemented an idea expressed in [O\u0027Rourke, p.271] and didn\u0027t test it well. The result is either empty or a segment. First, I find two extreme points with respect to the line direction, and then I find intersection segment endpoints on two chains between them using binary search. Care must be taken, because one of these chains passes through 0 vertex. After the correct edge is found, I call the \u003ccode\u003eintersectLines\u003c/code\u003e function from my previous article. I believe \u003ccode\u003eextremeVertex\u003c/code\u003e can be modified to find each intersection point in one binary search, but I\u0027ll leave this idea for the future.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F1, class F2, class F3\u0026gt;\nbool stabConvexPolygon(const Line\u0026lt;F1\u0026gt;\u0026amp; line, const Polygon\u0026lt;F2\u0026gt;\u0026amp; poly, Line\u0026lt;F3\u0026gt;\u0026amp; res) {\n  assert(line);\n  int right \u003d extremeVertex(poly, [\u0026amp;line](const Point\u0026lt;F2\u0026gt;\u0026amp;) { return line.ab; });\n  int left \u003d extremeVertex(poly, [\u0026amp;line](const Point\u0026lt;F2\u0026gt;\u0026amp;) { return -line.ab; });\n  auto vertexCmp \u003d [\u0026amp;line](const Point\u0026lt;F2\u0026gt;\u0026amp; vertex) {\n    return sgn(ccw(line.ab, vertex - line.a)); };\n  int rightSgn \u003d vertexCmp(poly[right]), leftSgn \u003d vertexCmp(poly[left]);\n  if (rightSgn \u0026lt; 0 || leftSgn \u0026gt; 0) return false;\n  auto intersectChain \u003d [\u0026amp;line, \u0026amp;poly, vertexCmp](int first, int last,\n                                                  int firstSgn, Point\u0026lt;F3\u0026gt;\u0026amp; res) {\n    int n \u003d static_cast\u0026lt;int\u0026gt;(poly.size());\n    while (next(first, n) !\u003d last) {\n      int middle \u003d (first + last + (first \u0026lt; last ? 0 : n)) / 2;\n      if (middle \u0026gt;\u003d n) middle -\u003d n;\n      if (vertexCmp(poly[middle]) \u003d\u003d firstSgn) first \u003d middle;\n      else last \u003d middle;\n    }\n    intersectLines\u0026lt;0, 0, 0, 0\u0026gt;(line, makeLine(poly[first], poly[last]), res);\n  };\n  intersectChain(left, right, leftSgn, res.a);\n  intersectChain(right, left, rightSgn, res.ab);\n  res.ab -\u003d res.a;\n  return true;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e6.2 Simple polygon: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e\u003c/h4\u003e\u003cp\u003e\u003cimg src\u003d\"/predownloaded/5d/a6/5da619a0958afd47246c0d4627279ba8ef9a1506.png\" style\u003d\"float: right;max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThe problem of finding the intersection length was given at the first educational round \u003ca href\u003d\"/contest/598/problem/F\" title\u003d\"Educational Codeforces Round 1\"\u003e598F - Ð”Ð»Ð¸Ð½Ð° Ñ€Ð°Ð·Ñ€ÐµÐ·Ð°\u003c/a\u003e. Surprisingly, I didn\u0027t notice a single comment mentioning that it can be solved in linear time (per line). Recall that the line is represented in parametric form \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/19/6d/196d1ee4a05f1122afa4f62c1627deec328b2a3e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, then the intersection is the set of segments for the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e. It\u0027s enough to find the total length of these segments and multiply it by \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eAB\u003c/i\u003e|\u003c/span\u003e. The solution is based on the simple fact: when traversing the polygon in counter-clockwise direction, every time we cross the line from right to left we get an end of some \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e segment, so this value is added to the answer, and from left to right we get a beginning, so it\u0027s subtracted from the answer. We only sort this values if we\u0027re asked to produce all the intersection segments, not just their total length.\u003c/p\u003e\u003cp\u003eThe problem isn\u0027t easy because some vertices and edges may lie on the line, for a total of 6 cases illustrated in the picture. Points we\u0027re interested at are marked blue. The general idea to process these cases is the following. If we\u0027re crossing from right to left, we need the furthest point in the line direction. Suppose we\u0027re processing a vertex that lies on the line, should we include it in the answer? It\u0027s not the furthest only in case one of its adjacent edges lies on the line, and the second vertex is further. This condition is checked using dot product. To determine the direction in which we\u0027re moving, it\u0027s enough to know on which side of the line previous and next vertices lie (variables \u003ccode\u003eprevSgn\u003c/code\u003e and \u003ccode\u003enextSgn\u003c/code\u003e take values 1 on the left, 0 on the line, -1 on the right). For example, if \u003ccode\u003eprevSgn \u003d\u003d 0 \u0026amp;\u0026amp; nextSgn \u003d\u003d 1\u003c/code\u003e, we\u0027re moving from right to left.\u003c/p\u003e\u003cp\u003eI\u0027m not going to go through all the cases, but I\u0027ll explain how the values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e are computed. If an edge crosses the line not at a vertex, the formula from \u003ccode\u003eintersectLines\u003c/code\u003e applies. If vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003c/span\u003e lies on the line, we have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ed/2e/ed2ed83fffbcb5deebad968fd6c2b60c9f64ee9e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, and taking dot product of each side with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/16/2d/162dfaf88e317c85e8f444f3e32e55f0eae9549e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e results in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9d/82/9d821e62defb58865c55ebf5cf55bd6b3e7f78b5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. This is the only place in this article where I needed non-integer computations.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F1, class F2, class F \u003d distF\u0026lt;F1, F2\u0026gt;\u0026gt;\nF stabPolygonLength(const Line\u0026lt;F1\u0026gt;\u0026amp; line, const Polygon\u0026lt;F2\u0026gt;\u0026amp; poly) {\n  assert(line);\n  F tSum \u003d F(0);\n  int n \u003d static_cast\u0026lt;int\u0026gt;(poly.size());\n  auto vertexSgn \u003d [\u0026amp;line, \u0026amp;poly](int i) { return sgn(line.ab ^ (poly[i] - line.a)); };\n  int prevSgn \u003d vertexSgn(n - 1), iSgn \u003d vertexSgn(0), nextSgn;\n  for (int i \u003d 0; i \u0026lt; n; ++i, prevSgn \u003d iSgn, iSgn \u003d nextSgn) {\n    nextSgn \u003d vertexSgn(next(i, n));\n    if (iSgn \u003d\u003d 0) {\n      if (prevSgn \u003d\u003d 0) {\n        if (nextSgn !\u003d 0 \u0026amp;\u0026amp; nextSgn \u003d\u003d sgn((poly[i] - poly[prev(i, n)]) * line.ab))\n          tSum +\u003d nextSgn * static_cast\u0026lt;F\u0026gt;((poly[i] - line.a) * line.ab) / abs(line.ab);\n      } else {\n        if ((nextSgn !\u003d 0 \u0026amp;\u0026amp; nextSgn !\u003d prevSgn) ||\n            (nextSgn \u003d\u003d 0 \u0026amp;\u0026amp; prevSgn \u003d\u003d sgn((poly[next(i, n)] - poly[i]) * line.ab)))\n          tSum -\u003d prevSgn * static_cast\u0026lt;F\u0026gt;((poly[i] - line.a) * line.ab) / abs(line.ab);\n      }\n    } else if (nextSgn \u003d\u003d -iSgn) {\n      auto vect \u003d poly[next(i, n)] - poly[i];\n      tSum +\u003d nextSgn * static_cast\u0026lt;F\u0026gt;((poly[i] - line.a) ^ vect) / (line.ab ^ vect);\n    }\n  }\n  return tSum * norm(line.ab);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e7. Maximum distance (convex polygon): \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e\u003c/h3\u003e\u003cp\u003eAs a final chord, I decided to include my implementation for the maximum distance (squared) between two vertices of the convex polygon. It uses the well known rotating calipers technique. If the input is not a convex polygon, call \u003ccode\u003econvexHull\u003c/code\u003e from Section 3 first.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F\u0026gt;\nF maxDist2(const Polygon\u0026lt;F\u0026gt;\u0026amp; poly) {\n  int n \u003d static_cast\u0026lt;int\u0026gt;(poly.size());\n  F res \u003d F(0);\n  for (int i \u003d 0, j \u003d n \u0026lt; 2 ? 0 : 1; i \u0026lt; j; ++i)\n    for (;; j \u003d next(j, n)) {\n      res \u003d max(res, dist2(poly[i], poly[j]));\n      if (ccw(poly[i+1] - poly[i], poly[next(j, n)] - poly[j]) \u0026gt;\u003d 0) break;\n    }\n  return res;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["geometry","convex-polygon"]}}