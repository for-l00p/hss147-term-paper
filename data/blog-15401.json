{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1419637414,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1419805895,"id":15401,"title":"\u003cp\u003eЗадачи с использованием условных операторов и циклов. Часть 1\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eВ этом разделе мы рассмотрим несколько задач с решениями. Задачи были подобраны с целью проиллюстрировать некоторые типичные приёмы программирования. \u003c/p\u003e\u003cp\u003eРекомендуется тщательно разобрать решения задач, а также записать их и протестировать в IDE Eclipse. Создайте для этих задач проект с именем \u003ccode\u003epractice01\u003c/code\u003e. В дальнейшем мы будем считать, что для каждой задачи из этого раздела Вы добавляете в этот проект новый класс с указанным именем.\u003c/p\u003e\u003cp\u003eТакже настоятельно рекомендуется не перепечатывать «окончательный вариант», а писать решение пошагово — как описывается в данном разделе (состоящем из трёх частей). \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача 1\u003c/strong\u003e. Дано целое положительное число \u003cem\u003en\u003c/em\u003e, не превосходящее \u003cspan class\u003d\"tex-span\"\u003e2·10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e. Найдите самую маленькую цифру в записи этого числа. Не используйте при решении строки. \u003cbr /\u003e \u003cbr /\u003e \u003cstrong\u003eРешение\u003c/strong\u003e. \u003c/p\u003e\u003cp\u003eПеребрать все цифры числа по очереди можно с помощью операций взятия остатка от деления на 10 (\u003ccode\u003e% 10\u003c/code\u003e) и целочисленного деления на 10 (\u003ccode\u003e/ 10\u003c/code\u003e). \u003c/p\u003e\u003cp\u003eВ качестве примера рассмотрим число 5284. Остаток от деления на 10 для него будет равен 4 — последней цифре. Если же это число мы поделим нацело на 10, получим 528. Таким образом, с помощью этих двух операций мы выделили из числа последнюю цифру, а затем отбросили её. \u003c/p\u003e\u003cp\u003eТочно также мы можем поступить теперь с числом 528: остаток от деления на 10 составит 8, а результат деления нацело на 10 будет равен 52. \u003c/p\u003e\u003cp\u003eЕщё одно применение пары этих операций даст нам остаток от деления 2 и число 5. Конечно, нам в этот момент становится понятно, что применять еще две операции для получения числа 5 в качестве последней цифры уже нет необходимости — она осталась одна. Для компьютера же проще сформулировать критерий \u003cem\u003e«цифр не осталось»\u003c/em\u003e. Поэтому применим пару операций \u003cem\u003e«взять остаток от деления на 10»\u003c/em\u003e и \u003cem\u003e«разделить число на 10 нацело»\u003c/em\u003e ещё раз. В качестве результата первой операции получим 5, в качестве результата второй — 0. \u003c/p\u003e\u003cp\u003eИменно этот ноль мы и можем использовать как признак для остановки операций деления: цифр в числе больше не осталось (напомним, оно было целым и положительным). \u003c/p\u003e\u003cp\u003eИтак, мы знаем, как перебрать цифры в числе. Это можно записать в виде псевдокода следующим образом:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eпока (число !\u003d 0) {\n\tцифра \u003d число % 10\n\tчисло \u003d число / 10\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОднако от нас требуется не только перебрать все цифры, но и найти минимальную среди них. Для этого нужно, получив очередную цифру, сравнить её с наименьшей из уже просмотренных (обратите внимание — сравнивать с каждой из уже просмотренных цифр нет необходимости). Если эта очередная цифра окажется меньше минимальной, значит, именно она станет минимальной из просмотренных. Псевдокод будет выглядеть так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eпока (число !\u003d 0) {\n\tцифра \u003d число % 10\n\tесли (цифра \u0026lt; минимальная_цифра) {\n\t\tминимальная_цифра \u003d цифра\n\t}\n\tчисло \u003d число / 10\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОтметим, что утверждение \u003cem\u003e«минимальная_цифра — минимальная цифра среди просмотренных»\u003c/em\u003e является инвариантом цикла. Инвариант цикла — это утверждение, которое является верным до цикла, после цикла, а также по завершении каждой итерации цикла (в ходе итерации инвариант может нарушаться). \u003c/p\u003e\u003cp\u003eЕдинственное, что нам осталось сделать — обеспечить выполнение правильности инварианта до цикла. \u003c/p\u003e\u003cp\u003eПоскольку до начала исполнения цикла просмотренных цифр у нас нет вовсе, то в качестве значения инварианта мы можем принять максимально возможную цифру (или число, её превосходящее). Итоговый псевдокод:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eминимальная_цифра \u003d 9\nпока (число !\u003d 0) {\n\tцифра \u003d число % 10\n\tесли (цифра \u0026lt; минимальная_цифра) {\n\t\tминимальная_цифра \u003d цифра\n\t}\n\tчисло \u003d число / 10\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТеперь запишем решение в виде программы. Создадим в проекте \u003ccode\u003epractice01\u003c/code\u003e новый класс с именем \u003ccode\u003eProblem01\u003c/code\u003e. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\npublic class Problem01 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКак обычно, этот класс станет «запускающим» для того класса, в котором будет реализовано решение задачи. Опишем новый класс с именем \u003ccode\u003eMinDigit\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\npublic class Problem01 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass MinDigit {\n\t\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНам потребуется две переменных: одна для хранения целого числа \u003cem\u003en\u003c/em\u003e, другая — для хранения его минимальной цифры.\u003c/p\u003e\u003cp\u003eОпишем эти переменные в классе \u003ccode\u003eMinDigit\u003c/code\u003e (пока мы ничего не будем делать с классом \u003ccode\u003eProblem01\u003c/code\u003e, поэтому ради краткости будем опускать его код, если в этом не будет необходимости):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass MinDigit {\n\t\n\tint n;\n\tint minimumDigit;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТеперь опишем конструктор класса \u003ccode\u003eMinDigit()\u003c/code\u003e. Его задача — прочитать число \u003cem\u003en\u003c/em\u003e с клавиатуры. Более ничего в нём происходить не будет. Обратите внимание: когда Вы начнёте писать слово \u003cem\u003eScanner\u003c/em\u003e, IDE постарается подсказать Вам, что это именно \u003ccode\u003eScanner\u003c/code\u003e из пакета \u003ccode\u003ejava.util\u003c/code\u003e. Если Вы согласитесь с IDE, то класс \u003ccode\u003eScanner\u003c/code\u003e будет автоматически импортирован в Вашу программу. В противном случае слово \u003cem\u003eScanner\u003c/em\u003e будет подчёркнуто волнистой красной линией (импорт, разумеется, придётся дописать — самостоятельно или же с помощью IDE). \u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\nimport java.util.Scanner;\n\npublic class Problem01 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass MinDigit {\n\t\n\tMinDigit() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tin.close();\n\t}\n\t\n\tint n;\n\tint minimumDigit;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ конструкторе создается объект класса \u003ccode\u003eScanner\u003c/code\u003e (с именем \u003ccode\u003ein\u003c/code\u003e), связанный со стандартным потоком ввода (\u003ccode\u003eSystem.in\u003c/code\u003e), затем с помощью этого объекта прочитывается число \u003ccode\u003en\u003c/code\u003e; после выполнения чтения объект объект \u003ccode\u003ein\u003c/code\u003e закрывается (из него более нельзя осуществлять чтение). \u003c/p\u003e\u003cp\u003eНапишем метод \u003ccode\u003esolve()\u003c/code\u003e, который будет реализовывать обсуждавшийся нами выше псевдокод. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass MinDigit {\n\t\n\tMinDigit() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tin.close();\n\t}\n\t\n\tvoid solve() {\n\t\tminimumDigit \u003d 9;\n\t\twhile (n !\u003d 0){\n\t\t\tint digit \u003d n % 10;\n\t\t\tif (digit \u0026lt; minimumDigit){\n\t\t\t\tminimumDigit \u003d digit;\n\t\t\t}\n\t\t\tn \u003d n / 10;\n\t\t}\n\t}\n\t\n\tint n;\n\tint minimumDigit;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eМетод \u003ccode\u003esolve()\u003c/code\u003e имеет тип \u003ccode\u003evoid\u003c/code\u003e, поскольку он не должен возвращать никакого значения. Результатом его работы будет значение \u003ccode\u003eminimumDigit\u003c/code\u003e, которая объявлена в классе и потому доступна всем методам. \u003cbr /\u003e \u003cem\u003eЗаметим, что переменная \u003ccode\u003edigit\u003c/code\u003e, использованная в методе \u003ccode\u003esolve()\u003c/code\u003e, доступна только внутри цикла \u003ccode\u003ewhile\u003c/code\u003e. Если Вы попытаетесь обратиться к ней вне цикла \u003ccode\u003ewhile\u003c/code\u003e (например, попытаетесь распечатать ее значение), то получите сообщение об ошибке (digit cannot be resolved to a variable).\u003c/em\u003e \u003c/p\u003e\u003cp\u003eСледующий метод — метод \u003ccode\u003eprint()\u003c/code\u003e — будет печатать ответ. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass MinDigit {\n\t\n\tMinDigit() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tin.close();\n\t}\n\t\n\tvoid solve() {\n\t\tminimumDigit \u003d 9;\n\t\twhile (n !\u003d 0){\n\t\t\tint digit \u003d n % 10;\n\t\t\tif (digit \u0026lt; minimumDigit){\n\t\t\t\tminimumDigit \u003d digit;\n\t\t\t}\n\t\t\tn \u003d n / 10;\n\t\t}\n\t}\n\t\n\tvoid print() {\n\t\tSystem.out.println(minimumDigit);\n\t}\n\t\n\tint n;\n\tint minimumDigit;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eС методом \u003ccode\u003eprint()\u003c/code\u003e наш класс \u003ccode\u003eMinDigit\u003c/code\u003e принял окончательный вид. Теперь нам осталось только написать тело метода \u003ccode\u003emain()\u003c/code\u003e класса \u003ccode\u003eProblem01\u003c/code\u003e. Вот как он будет выглядеть:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epublic class Problem01 {\n\n\tpublic static void main(String[] args) {\n\t\tMinDigit md \u003d new MinDigit();\n\t\tmd.solve();\n\t\tmd.print();\n\t}\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗапустите полученную программу и посмотрите, что она выдаёт в качестве ответа для \u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/11/0d/110d368b6bce622d9b0561b17db02a5930202e09.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e 5284 \u003cbr /\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/11/0d/110d368b6bce622d9b0561b17db02a5930202e09.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e 1010101 \u003cbr /\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/11/0d/110d368b6bce622d9b0561b17db02a5930202e09.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e 12345678 \u003cbr /\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/11/0d/110d368b6bce622d9b0561b17db02a5930202e09.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e 0 \u003cbr /\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/11/0d/110d368b6bce622d9b0561b17db02a5930202e09.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e -12 \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eПодумайте, как можно доработать программу, чтобы она корректно работала не только для положительных, а для любых целых чисел. \u003c/p\u003e\u003cp\u003eПродолжение следует...\u003c/p\u003e\u003c/div\u003e","tags":["циклы","условные операторы","java"]}}