{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1420909141,"rating":106,"authorHandle":"kien_coi_1997","modificationTimeSeconds":1420909141,"id":15701,"title":"\u003cp\u003eAn efficient way to map a permutation (length 11 or 12) to an integer without using std::map\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eMapping a permutation to a number has attracted much social concern. In shortest-path problems, in case a node (or state) is a permutation, we should convert states to integers, in order to BFS or Dijkstra on new graph comfortably. Many coders have known using std::map or trie to do this work. However, both have certain disadvantages. My writing will introduce a new way to solve this problem.\u003c/p\u003e\u003cp\u003eIt is hard to write both long and detailed blog. Therefore, you can comment anything which you didn\u0027t understand well. I will reply (or update this blog if it is necessary).\u003c/p\u003e\u003cp\u003eTo understand the role of mapping a permutation to a number, consider \u003ca href\u003d\"http://hsin.hr/coci/archive/2009_2010/contest2_tasks.pdf\"\u003eproblem POSLOZI from COCI\u003c/a\u003e. Our goal is to find the length of the shortest path from a permutation \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e to an other permutation \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e using allowed operations. A valid operation is swapping two elements in the permutation. We are given a list of pair \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ep\u003c/i\u003e, \u003ci\u003eq\u003c/i\u003e)\u003c/span\u003e denote we can swap the element indexed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and the element indexed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e. Any other swapping operations are not allowed. A possible strategy is to BFS simultaneously from both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e. .\u003c/p\u003e\u003ch2\u003e1. Disadvantages of std::map and trie\u003c/h2\u003e\u003cp\u003eIn the first place, what I put in my priority is inefficiency of wide-known methods. Std::map has big time complexity, and trie demands a quite long conding-time. 1, Using std::map is the easiest way to code but it costs big complexity, i.e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogN\u003c/i\u003e * \u003ci\u003eL\u003c/i\u003e)\u003c/span\u003e for each query (where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e is length of the permutation, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e is number of permutations, in other words \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e \u003d \u003ci\u003eL\u003c/i\u003e!\u003c/span\u003e). 2, Trie brings us the speed in queries but it uses quite much memory \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e * \u003ci\u003eL\u003c/i\u003e)\u003c/span\u003e and requests a long time to code. Therefore, both std::map and trie are not perfect solutions. It encourages me to find a better solution.\u003c/p\u003e\u003ch2\u003e2. My new method\u003c/h2\u003e\u003cp\u003eIn the second place, I will talk about my method treating this problem. Assume length of permutations \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e \u003d 11\u003c/span\u003e. We will use a 7-directional array to map first 7 elements to a number, called \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e1\u003c/span\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eint C1[11][11][11][11][11][11][11];\nint MaxC1\u003d0;\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAt this point, the number associate with the first 7 elements of permutation \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e1[\u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e][\u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e][\u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e][\u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e][\u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e4\u003c/sub\u003e][\u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e5\u003c/sub\u003e][\u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e6\u003c/sub\u003e]\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFor the first 7 elements, we have \u003cspan class\u003d\"tex-span\"\u003e11! / 4! \u003d 1663200\u003c/span\u003e states. There are 4 remaining elements.\u003c/p\u003e\u003cp\u003eNow first let\u0027s talk about a \u003cstrong\u003enaive\u003c/strong\u003e solution, we will create array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e2\u003c/span\u003e declared as following:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eint C2[1663200+1][11][11][11][11];\nint MaxC2\u003d0;\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn order to get the number associate with the permutation \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e, we will use following function:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eint index(const vector\u0026lt;int\u0026gt; \u0026amp;P) {\n  int \u0026amp;I1 \u003d C1[P[0]][P[1]][P[2]][P[3]][P[4]][P[5]][P[6]];\n  if (I1\u003d\u003d0) I1\u003d++MaxC1;\n  int \u0026amp;I2 \u003d C2[I1][P[7]][P[8]][P[9]][P[10]];\n  if (I2\u003d\u003d0) I2\u003d++MaxC2;\n  return I2;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe have already created function \u003cem\u003eindex\u003c/em\u003e to map a permutation to a number (although it is not efficient in memory yet). \u003cem\u003eIf you have not understood well, please read again carefully what I wrote before continuing reading.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eYou may realize that size of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e1\u003c/span\u003e is ok but \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e2\u003c/span\u003e is too large. Now we need to make \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e2\u003c/span\u003e smaller. When 7 elements are determined, we can use the relations (6 relations of 6 pairs of 4 elements) between the 4 remaining elements to represent them (remaining elements). Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e7\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e \u003d \u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e8\u003c/sub\u003e, \u003ci\u003ez\u003c/i\u003e \u003d \u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e9\u003c/sub\u003e, \u003ci\u003et\u003c/i\u003e \u003d \u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e10\u003c/sub\u003e\u003c/span\u003e . Instead of using \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e2[\u003ci\u003eI\u003c/i\u003e2][\u003ci\u003ex\u003c/i\u003e][\u003ci\u003ey\u003c/i\u003e][\u003ci\u003ez\u003c/i\u003e][\u003ci\u003et\u003c/i\u003e]\u003c/span\u003e, we will use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e2[\u003ci\u003eI\u003c/i\u003e2][\u003ci\u003ex\u003c/i\u003e \u0026gt; \u003ci\u003ey\u003c/i\u003e][\u003ci\u003ex\u003c/i\u003e \u0026gt; \u003ci\u003ez\u003c/i\u003e][\u003ci\u003ex\u003c/i\u003e \u0026gt; \u003ci\u003et\u003c/i\u003e][\u003ci\u003ey\u003c/i\u003e \u0026gt; \u003ci\u003ez\u003c/i\u003e][\u003ci\u003ey\u003c/i\u003e \u0026gt; \u003ci\u003et\u003c/i\u003e][\u003ci\u003ez\u003c/i\u003e \u0026gt; \u003ci\u003et\u003c/i\u003e]\u003c/span\u003e instead. This makes the size of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e2\u003c/span\u003e become \u003cspan class\u003d\"tex-span\"\u003e1663200 * 64\u003c/span\u003e instead of \u003cspan class\u003d\"tex-span\"\u003e1663200 * 11\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe \u003cstrong\u003efinal\u003c/strong\u003e implementation is here:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eint C1[11][11][11][11][11][11][11]; // 77MB\nint MaxC1\u003d0;\nint C2[1663200+1][2][2][2][2][2][2]; // 425 MB\nint MaxC2\u003d0;\n\nint index(const vector\u0026lt;int\u0026gt; \u0026amp;P) {\n  int \u0026amp;I1 \u003d C1[P[0]][P[1]][P[2]][P[3]][P[4]][P[5]][P[6]];\n  if (I1\u003d\u003d0) I1\u003d++MaxC1;\n  int x\u003dP[7], y\u003dP[8], z\u003dP[9], t\u003dP[10];\n  int \u0026amp;I2 \u003d C2[I1][x\u0026gt;y][x\u0026gt;z][x\u0026gt;t][y\u0026gt;z][y\u0026gt;t][z\u0026gt;t];\n  if (I2\u003d\u003d0) I2\u003d++MaxC2;\n  return I2;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e3. Effectiveness\u003c/h2\u003e\u003cp\u003eIn the third place, what cannot be left out is the effectiveness of my method. \u003c/p\u003e\u003cp\u003e\u003cem\u003eTime complexity\u003c/em\u003e\u003c/p\u003e\u003cp\u003eThe time complexity of function index is O(L) (to access), and the constant is quite small.\u003c/p\u003e\u003cp\u003e\u003cem\u003eMemory complexity\u003c/em\u003e\u003c/p\u003e\u003cp\u003eThe memory is quite big but acceptable. If you cannot accept this memory size, you can use 3 or 4 array (C1, C2, C3, C4, …) to reduce the memory size.\u003c/p\u003e\u003cp\u003e\u003cem\u003eCoding time\u003c/em\u003e\u003c/p\u003e\u003cp\u003ePersonally, function index is short and easy to code in a little time.\u003c/p\u003e\u003cp\u003e\u003cem\u003eEffectiveness in DP\u003c/em\u003e\u003c/p\u003e\u003cp\u003eAssume you are using function dp(u) (which u is a permutation), you can reduce a bool array. To determine if f(u) is calculated, just check if C2[I1][x\u0026gt;y][x\u0026gt;z][x\u0026gt;t][y\u0026gt;z][y\u0026gt;t][z\u0026gt;t] is zero or not.\u003c/p\u003e\u003ch2\u003e4. Magic numbers\u003c/h2\u003e\u003cp\u003eLastly, selected magic numbers is note-worthy. I will talk about reasons why I split 11 elements into 2 groups: first 7 elements and last 4 elements. Because I want to use only two array C1 and C2, I must write 11 into a sum of two number, such ways are: 11\u003d10+1\u003d9+2\u003d8+3\u003d7+4\u003d6+5, and I found that 7+4 is the best selection. 8+3 is impossible because size of C1 is too large: 11^8 ints \u003d 857 MB. 6+5 is not good because size of C2 is too large, 936 MB. Therefore 7+4 is reasonable. More notably, if I use [x][y\u0026gt;z][y\u0026gt;t][z\u0026gt;t] instead of [x\u0026gt;y][x\u0026gt;z][x\u0026gt;t][y\u0026gt;z][y\u0026gt;t][z\u0026gt;t], the size will be 11*2^3 (\u003d88) instead of 2^6 (\u003d64). You should consider those magic numbers carefully to balance the memory used.\u003c/p\u003e\u003cp\u003eTo handle problems with L\u003d12, in a naive view point, we can\u0027t use any data structure (even trie) because 12! ints \u003d 1.9GB (too big). However, not all of states are reached. In problem POSLOZI, there are less than 10^7 reached states. This is my code \u003ca href\u003d\"http://paste.ubuntu.com/9686778/\"\u003ehttp://paste.ubuntu.com/9686778/\u003c/a\u003e. It passed 9/10 tests and runs the last test in 3 seconds. It is what I expected because my strategy is not the perfect solution (someone said the optimal one is to use A* with some heuristics).\u003c/p\u003e\u003ch2\u003eConclusion\u003c/h2\u003e\u003cp\u003eIn summarize, for all the mentioned advantages above, the new method shows us a good efficiency. I highly recommend that you should carefully consider writing to make good decision on problem mapping a permutation to a number.\u003c/p\u003e\u003cp\u003eIt is hard to write both long and detailed blog. Therefore, you can comment anything which you didn\u0027t understand well. I will reply (or update this blog if it is necessary).\u003c/p\u003e\u003c/div\u003e","tags":["permutation"]}}