{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1516677070,"rating":32,"authorHandle":"Malomalomalomalo","modificationTimeSeconds":1516835716,"id":57292,"title":"\u003cp\u003eUnderstanding Fenwick Trees / Binary Indexed Trees\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eIm writing this both to help others and test myself so I will try to explain everything at a basic level. Any feedback is appreciated.\u003c/p\u003e\u003cp\u003eA Fenwick Tree (a.k.a. Binary Indexed Tree, or BIT) is a fairly common data structure. BITs are used to efficiently answer certain types of range queries, on ranges from a root to some distant node. They also allow quick updates on individual data points.\u003c/p\u003e\u003cp\u003eAn example of a range query would be this: \u0026quot;What is the sum of the numbers indexed from [1,x]?\u0026quot;\u003c/p\u003e\u003cp\u003eAn example of an update would be this: \u0026quot;Increase the number indexed by x by v.\u0026quot;\u003c/p\u003e\u003cp\u003eA BIT can perform both of these operations in O(log N) time, and takes O(N) memory.\u003c/p\u003e\u003cp\u003e(least significant bit will be abbreviated to LSB and in this post means the bit with the first one in the binary representation. Length of an interval ending at index x is shown by len(x))\u003c/p\u003e \u003ch2\u003eSo how do BITs work?\u003c/h2\u003e\u003cp\u003eBITs take advantage of the fact that ranges can be broken down into other ranges, and combined quickly. Adding the numbers 1 through 4 to the numbers 5 through 8 is the same as adding the numbers 1 through 8. Basically, if we can precalculate the range query for a certain subset of ranges, we can quickly combine them to answer any [1,x] range query.\u003c/p\u003e\u003cp\u003eThe binary number system helps us here. Every number N can be represented in log N digits in binary. We can use these digits to construct a tree like so:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"img1\" src\u003d\"/predownloaded/d7/d3/d7d3bf975dd3a747ab44ca1945f534aa45f1c435.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThe length of an interval that ends at index I is the same as the LSB of that number in binary. (We exclude zero as its binary representation doesn\u0027t have any ones.) For example, interval ending at 7 (111) has a length of one, 4 (100) has a length of four, six (110) has a length of 2.\u003c/p\u003e\u003cp\u003eThis gives the tree some interesting properties which make log N querying and updating possible.\u003c/p\u003e \u003cul\u003e   \u003cli\u003eEvery index has exactly one interval ending there. This is obvious from the way we constructed the tree.\u003c/li\u003e   \u003cli\u003eEvery range [1,x] is constructable from the intervals given, and every range decomposes into at most log N ranges. (This will be proved below)\u003c/li\u003e   \u003cli\u003eEvery index is included in at most log N intervals. (This will also be proved below)\u003c/li\u003e \u003c/ul\u003e \u003ch6\u003eProof that every range [1,x] is constructable from the intervals given.\u003c/h6\u003e\u003cp\u003eA range query can be defined recursively [1,x] \u003d [1,a-1] + [a,x] where [a,x] is the interval ending at x. x\u0027s which are powers of two are base cases as they contain the range [1,x] precalced. a is never below 1 as it is defined as the least sig bit in x, and x-LSB is either positive or a base case. \u003c/p\u003e \u003ch6\u003eProof that the range [1,x] can be broken down into a log N number of intervals.\u003c/h6\u003e\u003cp\u003elet len(index) \u003d length of the interval ending at index.\u003c/p\u003e\u003cp\u003eWe use the above recursion [1,x] \u003d [1,a-1] + [a,x]. as len(x) \u003d LSB in x, and a-1 \u003d x - len(x), the least significant bit in a-1 is greater than len(x) (unless x is a power of two, in which case it is only one interval). (Subtracting len(x) from x removes this bit.) Since len(a-1) \u0026gt; len(x), len(a-1) \u0026gt;\u003d 2 * len(x). This means that we approach 1 at an exponential rate, so it takes log N intervals to construct [1,x].\u003c/p\u003e\u003cp\u003e(Note that visualizing x as a binary integer, and recognizing that at each step in the recursion the LSB is turned to zero, and that we end when x reaches 0, means that it takes n steps (where n is the number of bits) at most, and these n bits represent 2^n numbers, so we can reach the logarithmic number of intervals this way too.)\u003c/p\u003e \u003ch6\u003eProof that every index is included in at most log N intervals.\u003c/h6\u003e\u003cp\u003eThis is essential to proving that updating takes log N operations.\u003c/p\u003e\u003cp\u003eLooking at the pictures this seems true, lets proceed with a proof by contradiction.\u003c/p\u003e\u003cp\u003eAssume intervals ending at a and b with len(a)\u003dlen(b) intersect, and without loss of generality let b\u0026gt;a. If these intersect, that means b-len(b)\u0026lt;a. Note that - len(b) is just removing the least sig bit. As len(a) \u003d len(b) both a and b are indentical from the least sig bit to their start. This also means that as b \u0026gt; a, the binary number above these digits for b is greater than a. Removing the least sig bit from b doesn\u0027t change b\u0026gt;a as, in binary, the greater number is determined by the leftmost digit, as every digit carries more weight than all the previous digits combined. \u003c/p\u003e\u003cp\u003eBasically: b \u003d [B]10...00 and a\u003d[A]10...00 with [B]\u0026gt;[A]. b-len(b) \u003d [B]00...00 which is still greater than a, so b cannot intersect a.\u003c/p\u003e\u003cp\u003eAs there are a log N number of interval lengths, and no two lengths of the same size intersect, this means that any index is covered by at most log N intervals. Thus, updating an index requires updates to at most log N intervals.\u003c/p\u003e\u003cp\u003eIn the above proofs we have found the method for querying efficently, but we still don\u0027t know how to update the nodes. \u003c/p\u003e \u003ch6\u003eHow to update:\u003c/h6\u003e\u003cp\u003eFirst note that as our ranges are defined by their rightmost endpoint, the range ending at x is the first range that contains x. So we need an algorithm that can quickly find the next largest range that contains x, and repeat until there are no more such ranges. The next range that contains x must be larger than the current one, so we know the next range\u0027s lsb \u0026gt; lsb of x. It turns out that the function next range \u003d x + len(x) works. This is because this function increments the lsb to the next valid one. \u003c/p\u003e\u003cp\u003eSome people might notice a slight problem here, if we have a number like 111000, adding 1000 to that number gets 1000000, skipping a bunch of possible ranges. This is fine as the ranges that are skipped do not cover x. Trying to include the skipped ranges by removing ones just gets numbers that are lower than x, e.g. 110000\u0026lt;111000. Adding numbers to the end before increasing the lsb also doesn\u0027t work, as this moves the range ending further than the lsb increase does, e.g. 1110000 ends at 1100000 which is \u0026gt; 111000. The only way to increment to the next largest valid range is with x+\u003dlen(x).\u003c/p\u003e\u003cp\u003eHere is the procedure for updating a node x: update BIT[x], then add len(x) to x, repeat until x exceeds the size of the tree.\u003c/p\u003e \u003ch2\u003eNow that we know our algorithms in theory, how do we implement them?\u003c/h2\u003e\u003cp\u003eAs every index only has one interval ending in it, it is possible to represent the BIT as an array. BIT[i] \u003d the value of the interval ending at i.\u003c/p\u003e\u003cp\u003eBoth update and query rely on getting len(x), or the lsb of x, easily. Thankfully, the bit operation (x\u0026amp;-x) returns the lsb.\u003c/p\u003e\u003cp\u003eHere\u0027s why: \u003c/p\u003e\u003cp\u003elet a\u003d[A]10...00, then (thanks to 2-complements) -a \u003d [A inverted]01...11 + 1 or [A inverted]10...00. Bitwise ANDing the two gets 000010...000, or the lsb of a.\u003c/p\u003e\u003cp\u003eHere is the actual implementation, using sum as the range query. (Note that we increment x so our tree is rooted at 1, as rooting at 0 causes problems. \u003c/p\u003e\u003cpre\u003e \u003ccode class\u003d\"prettyprint\"\u003e int BIT[MAXN];\u003cp\u003e\u003cspan\u003evoid update(int x,int val) { ++x;  while(x\u0026lt;\u003dN)  {  BIT[x]+\u003dval  x+\u003d(x\u0026amp;-x);  } }\u003c/span\u003e\u003c/p\u003e\u003cp\u003eint query(int x) {  ++x;  int res\u003d0;  while(x\u0026gt;0)  {  res+\u003dBIT[x];  x-\u003d(x\u0026amp;-x);  } return res; } \u003c/p\u003e\u003c/code\u003e \u003c/pre\u003e (I can\u0027t for the life of me figure out why the code isn\u0027t formatting properly... sorry.)\u003cp\u003e(A little interesting fact is that x\u0026amp;\u003d(x-1) functions the same as x-\u003d(x\u0026amp;-x))\u003c/p\u003e\u003cp\u003eThats it! Note that you can query for ranges [a,b] by performing query(b)-query(a-1). The same code can also be adapted to other range queries, but there are some pitfalls to look out for. Updating min and max doesn\u0027t always work, as you need to know the values in the range which you are updating, unlike in sum where all you need to know is the range\u0027s sum. For the same reasons you cannot query arbitary ranges [a,b] with the like you can with sums.\u003c/p\u003e\u003cp\u003eAs a little aside, BITs are like a lightweight form of a segment tree. They take up less space (by a constant factor) and are quicker to code, but they are not as versatile as segment trees.\u003c/p\u003e\u003cp\u003eAgain, this is my first time blog so any feedback is appreciated.\u003c/p\u003e\u003c/div\u003e","tags":["binary indexed tree","bit/fenwick tree","#tutorial"]}}