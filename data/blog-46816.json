{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1472401160,"rating":0,"authorHandle":"1am","modificationTimeSeconds":1472401160,"id":46816,"title":"\u003cp\u003eDay 5 (8/27)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eBinary Search the Answer\u003c/h1\u003e\u003cp\u003eWe first re-discussed Question G from Day 4. You do a binary search on the answer to the problem. To check if a value works for the answer, we first sort the array from greatest to smallest. Then if we are trying x as an answer, we need to know how many people we need to move from all places if the place has more than x people. \u003c/p\u003e\u003cp\u003eThis sum should be less than the k hours we have, since it takes one hour to move someone. You also need to check if there is space to put those extra people in other places in the array, so each time you reach a place that has less than x people, you try to put as much people there up till x.\u003c/p\u003e\u003cp\u003eHere is the code: \u003ca href\u003d\"http://ideone.com/AgyZmp\"\u003ehttp://ideone.com/AgyZmp\u003c/a\u003e\u003c/p\u003e\u003cp\u003eQuestion C from day 4 also deals with the same concept, let mid be the number of matches for the kangaroos we want to make. We need a check function to test whether this mid value is possible or not.\u003c/p\u003e\u003cp\u003eThe check function is simple, we can choose the smallest mid sizes, and start matching them with the largest sizes, if by the end we got mid matches, we return true. otherwise, we return false.\u003c/p\u003e\u003ch1\u003eQueue ,Dequeue, Stack, Priority Queue\u003c/h1\u003e\u003cp\u003eEveryone told me that they already know these topics, but for reference, slides 18 â€” 22 from power point day 1 explain examples and syntax for a refresher. \u003ca href\u003d\"https://drive.google.com/drive/folders/0B54r2jukjz9wZ2JOcDJiWWdfZnc\"\u003ehttps://drive.google.com/drive/folders/0B54r2jukjz9wZ2JOcDJiWWdfZnc\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eLucky Numbers (easy)\u003c/h1\u003e\u003cp\u003eThen we solved problem A from day 5. You use a queue, first you push 4 and 7. Then to get any number after that you push the front of the queue * 10 +4 , and also * 10 +7. We give 4 a value of 1, and 7 a value of -1. If the sum of the values in the number is 0, then that means there are an equal amount of fours and sevens. All that is left to check is if the number is greater than n.\u003c/p\u003e\u003cp\u003eHere is Abdullah\u0027s code :) \u003ca href\u003d\"http://ideone.com/GuAn9V\"\u003ehttp://ideone.com/GuAn9V\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eLower_bound and Upper_Bound\u003c/h1\u003e\u003cp\u003elower bound and upper bound are shortcuts to the binary search method. Before you use them, just like before a binary search, you need to have your array sorted.\u003c/p\u003e\u003cp\u003eA lower bound searches for the first occurrence of an element. If found, returns the index. Otherwise returns the index of the first element higher than it. \u003c/p\u003e\u003cp\u003eAn upper bound searches for the last occurrence of an element, and if found or not... alwayssssssss returns the index of the next element higher than it. \u003c/p\u003e\u003cp\u003eIn both searches, if the number you are searching for is higher than the highest number in the array, it will return the size of the array.\u003c/p\u003e\u003cp\u003eHere is code for reference, try to play around with the elements and see the corresponding output : \u003ca href\u003d\"http://ideone.com/mt7wwJ\"\u003ehttp://ideone.com/mt7wwJ\u003c/a\u003e\u003c/p\u003e\u003ch1\u003e4 Values Whose Sum is 0\u003c/h1\u003e\u003cp\u003e\u003ca href\u003d\"http://www.spoj.com/problems/SUMFOUR/\"\u003ehttp://www.spoj.com/problems/SUMFOUR/\u003c/a\u003e Using a lowerbound and an upper bound, we then solved this problem.\u003c/p\u003e\u003cp\u003eYou get the sum of all pairs of the first two arrays, store it in a vector1. Then the sum of all pairs of the last two arrays, and store it in a vector2. If a pair from vector1 is to be matched with a pair from vector2, then they need to be the negation of the other. If the sum of a pair in vector1 is -3, then i need to find ALL pairs in vector2 that have a value of 3.\u003c/p\u003e\u003cp\u003eYou requested the code for it, but please try it before looking at it: \u003ca href\u003d\"http://ideone.com/uZfOLQ\"\u003ehttp://ideone.com/uZfOLQ\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eAirport\u003c/h1\u003e\u003cp\u003eQuestion C from day 5 can be solved with a maximum and minimum priority queue. A priority queue always removes the maximum element in the array as the front(), even after ever insertion. We use that to get the maximum amount of money we can make by always removing the front() for the next customer. The minimum value can be found the same way but by inserting the negation of each value in the priority queue so that the front() is always the smallest value. \u003c/p\u003e\u003cp\u003eOnce again here is the code: \u003ca href\u003d\"http://ideone.com/JOjdP7\"\u003ehttp://ideone.com/JOjdP7\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI forgot to solve question land lot, so inshallah that will be solved next week. Give problem F from Day 5 a try, if you run into problems it might be due to precision because pow () function, one parameter must be a double value, and the return type is also double. So make sure to add 1e-9 to change for example 2.99999999 to 3 before saving it as an long long.\u003c/p\u003e\u003cp\u003eAlso by today inshallah i will have rounded up some extra problems, give those a try after completing all previous contests.\u003c/p\u003e\u003cp\u003eGood luck to all!\u003c/p\u003e\u003c/div\u003e","tags":[]}}