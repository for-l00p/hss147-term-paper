{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1413755311,"rating":78,"authorHandle":"BYN","modificationTimeSeconds":1414587861,"id":14354,"title":"\u003cp\u003eElimination Round Editorial — Bayan programming Contest 2014-2015\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eA. New Rock Paper Scissors\u003c/h3\u003e\u003cp\u003eThe \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e solution is straight forward, although it can be solved in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e but it was not required. Even the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e seems easier to implement, but some cases might be missed. That\u0027s why the easiest problem of the contest turned out to be a little tricky. You see both kind of solutions in the scoreboard.\u003c/p\u003e\u003ch3\u003eB. Bayan Health Bracelet\u003c/h3\u003e\u003cp\u003eIn this problems you had to find the first condition that is met. If carefully implemented one can get accepted with no hassle.\u003c/p\u003e\u003ch3\u003eC. Grid History\u003c/h3\u003e\u003cp\u003eThe following two statements should hold for a valid grid:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eIf the board is checkered, two cells have the same parity, if and only if they are colored the same.\u003c/li\u003e   \u003cli\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e be the value of a cell, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e be the value of the first cell with greater value than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. The length of the shortest path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e among the cells with value greater than or equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, is not greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003etwo greatest values of the board must differ by one.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eChecking the first statement can be trivially done in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e)\u003c/span\u003e. The second statement needs to be checked for every cell \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e on the grid, leading to an overall \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003ci\u003em\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e time complexity, by running BFS \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enm\u003c/i\u003e\u003c/span\u003e times on the grid.\u003c/p\u003e\u003ch3\u003eD. Towers\u003c/h3\u003e\u003cp\u003eHere is a good \u003ca href\u003d\"//codeforces.com/blog/entry/14343#comment-193313\"\u003eexplanation\u003c/a\u003e by \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/W4yneb0t\" title\u003d\"Grandmaster W4yneb0t\"\u003eW4yneb0t\u003c/a\u003e, that gives a good perception on the solution.\u003c/p\u003e \u003cblockquote\u003e\u003cp\u003eThe visible surface is at least the sum of the highest towers in each column, plus the highest towers in each row, plus the top surfaces.\u003c/p\u003e\u003cp\u003eFor each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, you want to minimize the number of columns and rows that contain a tower taller than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Put the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e highest towers in the smallest (by perimeter) rectangle that can contain them. This rectangle is either a square, or has sides that differ by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, or has one side length equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e. So, this is the lower bound for the area, and since we can actually do that for all k at the same time, it\u0027s also the upper bound.\u003c/p\u003e\u003cp\u003eTo calculate the number of ways, let\u0027s say you have the number of ways to pack the tallest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eab\u003c/i\u003e\u003c/span\u003e towers in an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e × \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e rectangle, with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e ≤ \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, and want to calculate the number of ways to pack the \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e + 1)\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e tallest in an \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e + 1) × \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e rectangle. You can extend the rectangle in either 2 or 4 directions (4 when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d \u003ci\u003eb\u003c/i\u003e \u0026lt; \u003ci\u003emin\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e, 2 otherwise), and arrange \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e towers along the side in \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eb\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e ways.\u003c/p\u003e \u003c/blockquote\u003e\u003ch3\u003eE. Water Barrels\u003c/h3\u003e\u003cp\u003eAt time zero, the water reaches the first barrel. Now assume that we already know the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e barrels that water reached them. Take the lowest pipe going out of these barrels, say it\u0027s located at height \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e. So all of these \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e barrels will be watered to height \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e, unless they are already reached height \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e. So with these information, we can calculate the time that water reaches \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e-th barrel. The whole algorithm runs in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003eAs a exercise, try solving it in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlgn\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003ch3\u003eF. Merge\u003c/h3\u003e\u003cp\u003eLet\u0027s have a bottom-up definition of a \u003cem\u003eblock\u003c/em\u003e. At first, each single black cell is called a block.\u003c/p\u003e\u003cp\u003eA set of blocks are called diagonally-shaped, if each two consecutive blocks touch each other at their corners. It can be easily seen that they will indeed look like a diagonal. Now consider a maximal diagonal-shaped set of blocks on the grid; We call their square-hull a block too; And we call those blocks, children of the new big block. According to this definition, if the answer isn\u0027t -1, the whole grid must be a block.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/a6/ff/a6ffd158bd30e643c5092138127ce6329fe30824\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eHere are some facts about the blocks:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eBlack cells in each block can be merged into a single sub-square on the grid.\u003c/li\u003e   \u003cli\u003eNot every merge-able sub-square is called a block.\u003c/li\u003e   \u003cli\u003eEach block has a unique diagonal direction, which can be used to decompose it to it\u0027s children.\u003c/li\u003e   \u003cli\u003eDiagonal direction of each block is opposite of it\u0027s children\u0027s diagonal direction.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eNow let\u0027s make a tree, using our blocks and the children definition we had. Notice that the whole grid is the root.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/59/07/59070a059147d2960f06a1954b3d634862d2c026\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the minimum sum of cells in block \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, in the optimal merging plan for this block, so the answer to the problem is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the children of vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e. The last merge operation in this block, merges \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, ..., \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e + 1\u003c/sub\u003e... \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, for some \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003eIt can be proven that in optimal solution, one of these parts is merged completely before the other one starts merging. in fact, the bigger part should be merged first. Why?\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eAt this point we have an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e solution. For each block \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, let\u0027s define \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e as the minimum sum of cells in blocks \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, ..., \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, after merging them into one sub-square. So \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e equals to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1, \u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. For each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, we should choose the last move, i.e. choose some \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e, (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003ep\u003c/i\u003e \u0026lt; \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e), and update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e + 1, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. The details of it are just some boring calculations.\u003c/p\u003e\u003cp\u003eTo improve this solution to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e, we just need to see that in the optimal solution, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e will be updated from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e \u003d \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e \u003d \u003ci\u003ej\u003c/i\u003e - 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e..\u003c/p\u003e\u003cp\u003eSpecial thanks goes to \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/havaliza\" title\u003d\"Candidate Master havaliza\"\u003ehavaliza\u003c/a\u003e, \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/mR.ilchi\" title\u003d\"International master mR.ilchi\"\u003emR.ilchi\u003c/a\u003e, \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/haas\" title\u003d\"International master haas\"\u003ehaas\u003c/a\u003e and \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/mruxim\" title\u003d\"International master mruxim\"\u003emruxim\u003c/a\u003e for preparing the problems and the editorials. Hope you enjoyed the problems.\u003c/p\u003e\u003c/div\u003e","tags":["bayan2014","editorial"]}}