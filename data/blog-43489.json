{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1456859219,"rating":0,"authorHandle":"Fcdkbear","modificationTimeSeconds":1456859219,"id":43489,"title":"\u003cp\u003eРазбор VNTU Training 16\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eЗадача A\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eПросто проверим, или выполняются все 4 условия. Для того, чтобы проверить, является ли символ маленькой буквой латинского алфавита, можно использовать такую конструкцию:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eif ((c \u0026gt;\u003d \u0027a\u0027) \u0026amp;\u0026amp; (c \u0026lt;\u003d \u0027z\u0027)) {\n    //do something\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОстальные условия проверяются похожим способом (кроме очевидной проверки длины)\u003c/p\u003e\u003cp\u003eСложность алгоритма — O(n), n — длина строки.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача B\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eБудем моделировать процесс от такта к такту. Будем поддерживать множество уже заблокированных ядер и ячеек памяти. Теперь, когда мы смотрим очередное ядро на очередном такте, делаем следующее:\u003c/p\u003e\u003cp\u003e1) Если ядро уже заблокированно — ничего не делаем, переодим к следующему ядру\u003c/p\u003e\u003cp\u003e2) Если ядро указывает на заблокированную ячейку — говорим что ядро блокируется на текущем шаге и идем дальше\u003c/p\u003e\u003cp\u003e3) Иначе же увеличиваем количество использований ячейки в текущем такте на 1.\u003c/p\u003e\u003cp\u003eПосле этого на этом же такте пройдемся по всем незаблокированным ядрам еще раз. Если они указывают на ячейку, которая на этом такте использовалась несколько раз — говорим, что ядро блокируется на этом такте.\u003c/p\u003e\u003cp\u003eСложность моей реализации — O(m*(n + k))\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача C\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eСначала проверим, может ли выиграть первая команда. Допустим, первый игрок сыграет в защите, а второй в нападении. Проверим, правда ли, что он выигрывает у любой комбинации второй команды. Если это так — первый побеждает. Иначе же предположим, что второй игрок сыграет в защите, и проверим для них, выигрывают ли они у любой комбинации второй команды. Если это так — первая команда победила. Иначе же, проверим, может ли выиграть вторая команда.\u003c/p\u003e\u003cp\u003eДля этого нам нужно убедиться, что какую-бы комбинацию не выбрала первая команда — мы можем выбрать свою комбинацию игроков, которая их победит.\u003c/p\u003e\u003cp\u003eЕсли этого сделать не выйдет — результат нашей игры при оптимальной игре обоих сторон — ничья.\u003c/p\u003e\u003cp\u003eСложность алгоритма — O(1)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача D\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eБудем поддерживать самое маленькое и самое большое число, которые могут быть ответом на задачу (l и r). Тогда каждый запрос может как-то поменять наши границы. Рассмотрим, как именно на примере запроса \u0026gt;\u003d x.\u003c/p\u003e\u003cp\u003eДопустим ответ на этот запрос — Y. Тогда ответ на задачу должен быть как минимум x, что равносильно выполнению операции l \u003d max(l, x). Допустим, ответ на этот запрос — N. Тогда ответ на задачу должен быть строго меньше х, то равносильно операции r \u003d min(r, x — 1).\u003c/p\u003e\u003cp\u003eОстальные операции выполняются аналогично.\u003c/p\u003e\u003cp\u003eВ конце посмотрим, или l\u0026lt;\u003dr. Если это так — выведем любое число из этого промежутка, иначе ответах было противоречие и ответ Impossible.\u003c/p\u003e\u003cp\u003eСложность алгоритма O(n) \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача E\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eДавайте для каждого этапа изготовления каждой картины поддерживать минимальное время, когда он может быть выполнен. Как его узнать? Давайте сначала узнаем минимальное время старта работы над этим этапом этой картины. Во-первых, если этот художник — не первый, кто работает над этой картиной, то время старта работы над этим этапом не меньше, чем время окончания работы прошлым художником этой картины. Во-вторых, если этот этап не первый в изготовлении картины, то время старта работы над этим этапом не меньше чем время окончания работы этим хужожником прошлого этапа картины. Соответственно, из этих величин нам нужно выбрать максимум. Чтобы узнать время окончания работы над этапом — добавим к времени начала работы над ним величину t[i][j].\u003c/p\u003e\u003cp\u003eСложность алгоритма O(n*m)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача F\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eБудем решать задачу отдельно для каждого дня.\u003c/p\u003e\u003cp\u003eУзнаем, сколько денег получит наш работник в очередной день: v \u003d (x[i]*a)/b. Нас интересует следующий вопрос: какое минимальное количество жетонов нужно, чтобы получить столько же денег? Если мы ответим на этот вопрос, посчитать ответ легко — отнимем от x[i] эту величину, результат и будет ответом для этого дня. \u003c/p\u003e\u003cp\u003eИ так, нам нужно найти такое минимальное y, что (y*a)/b \u003d\u003d v (деление целочисленное). В терминах обычного деления это значит, что:\u003c/p\u003e\u003cp\u003e(y*a)/b \u0026gt;\u003d v\u003c/p\u003e\u003cp\u003ey*a \u0026gt;\u003d b*v\u003c/p\u003e\u003cp\u003ey\u0026gt;\u003d(b*v)/a.\u003c/p\u003e\u003cp\u003eА значит, интересующий нас ответ результат деления (b*v)/a, округленный вверх.\u003c/p\u003e\u003cp\u003eСложность нашего алгоритма — O(n)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача G\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eБудем для каждой лампочки поддерживать, была она выключена или нет. Далее для каждой кнопки пройдемся по всем лампочкам, которые она выключает, и если эта лампочка еще не была выключена — выключим ее и скажем, что наша кнопка является для нее ответом. \u003c/p\u003e\u003cp\u003eСложность алгоритма — O(n*m)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача H\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eПосчитаем для кажой кассы, сколько времени займет простоять на ней и среди этих величин выберем минимум.\u003c/p\u003e\u003cp\u003eКак считать ответ для кассы? Он равен 15 * (количество людей в очереди к этой кассе) + 5 * (суммарное количество товаров у всех покупателей на этой кассе).\u003c/p\u003e\u003cp\u003eСложность алгоритма — O(n*max(k))\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача I\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВо-первых, если в гирлянде есть какой-то цвет, которого нет у Васи — ответ -1. Во всехостальных случаях ответ существует.\u003c/p\u003e\u003cp\u003eДавайте посчитаем ответ для каждого цвета и посчитаем.\u003c/p\u003e\u003cp\u003eДопустим, у Васи есть a листов очередного цвета, а нужно покрыть ровно b кусков гирлянды. \u003c/p\u003e\u003cp\u003eПусть a\u0026lt;b. Тогда Вася может порезать все свои куски таким образом, чтобы их стало b, и использовать при этом a единиц площади.\u003c/p\u003e\u003cp\u003eПусть a\u0026gt;\u003db. Тогда Вася может на каждую часть гирлянды положить по одному куску, и использовать при этом b единиц площади.\u003c/p\u003e\u003cp\u003eСложность алгоритма — O(n+m+k), k — максимально возможное количество цветов.\u003c/p\u003e\u003c/div\u003e","tags":["все читают разборы"]}}