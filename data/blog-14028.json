{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1411927983,"rating":137,"authorHandle":"cgy4ever","modificationTimeSeconds":1412063790,"id":14028,"title":"\u003cp\u003eCodeforces Round #270 Editorial \u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/472/problem/A\" title\u003d\"Codeforces Round 270\"\u003e472A - Design Tutorial: Learn from Math\u003c/a\u003e\u003c/p\u003e\u003cp\u003eOne way to solve this is by bruteforce: there are O(n) different ways to decomose n as sum of two number. If we can check if a number is a prime in O(1) then the whole algorithm can run in O(n). You can use Sieve of Eratosthenes to do the pre-calculation.\u003c/p\u003e\u003cp\u003eAnd another way is try to prove this theorem. The prove is simple: if n is odd number, then 9 and (n-9) is an answer (n-9 is an even number at least 4, so a composite number), and if n is even number, then 8 and (n-8) is an answer (n-8 is an even number at least 4, also must be a composite number).\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/472/problem/B\" title\u003d\"Codeforces Round 270\"\u003e472B - Design Tutorial: Learn from Life\u003c/a\u003e \u003c/p\u003e\u003cp\u003eThis task can be solve by greedy: the k people with highest floor goes together, and next k people with highest floor goes together and so on. So the answer is 2 * ((f[n]-1) + (f[n-k]-1) + (f[n-2k]-1) + ...) .\u003c/p\u003e\u003cp\u003eIt is a bit tricky to prove the correctness of greedy, since people can get off the elevator and take it again. We can give a lower bound of the answer by flow analysis: between floor i and floor i+1, there must be no more than (# of f[i] \u0026gt;\u003d i+1) / k times the elevator goes up between these 2 floors, and then there be same number of times goes down. We can find this lower bound matches the answer by above greedy algorithm, so it means the greedy algorithm gives an optimal answer.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/472/problem/C\" title\u003d\"Codeforces Round 270\"\u003e472C - Design Tutorial: Make It Nondeterministic\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis one laso can be solved by greedy, let\u0027s think in this way: let pick one with smallest handle, then we let him/her use min(firstName, secondName) as handle. And go for the next one (2nd mallest handle), now he/she must choose a handle greater than handle of previous person, and if both meet this requirement, he/she can pick a small one.\u003c/p\u003e\u003cp\u003eThis time the correctness of this greedy solution can be proved by exchange argument.\u003c/p\u003e\u003cp\u003eNote that if we change the goal of this problem: ask number of different permutations they can get, then it will be very hard. (I tried it for hours but can\u0027t solve.)\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/472/problem/D\" title\u003d\"Codeforces Round 270\"\u003e472D - Design Tutorial: Inverse the Problem\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s think it in the following way: for the minimal length edge, it must belong the the tree, ..., for the k-th minimal length edge(a, b), if there is already an path between a-b, then it can not be an edge of tree anymore, otherwise it must be edge of tree, why? Because otherwise there must be a path from a to b in the tree, that means a and b can be connected by edges with less length, but a and b is not connected.\u003c/p\u003e\u003cp\u003eSo this Kruskal style analysis gives us this theorem: if there is an answer, then the answer must be the MST of that graph. (You can also guess this theorem and try to prove it.)\u003c/p\u003e\u003cp\u003eYou can solve MST in O(n^2 log n), and then there are many way to check distance between notes on tree: you can just simply do dfs or bfs from each node, it can run in O(n^2). Or if you have pre-coded LCA algorithm, it can run in O(n^2 log n).\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/472/problem/E\" title\u003d\"Codeforces Round 270\"\u003e472E - Design Tutorial: Learn from a Game\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst let\u0027s solve some special cases:\u003c/p\u003e\u003cp\u003eIf the initial board and the target board contains different orbs, then there can\u0027t be a solution.\u003c/p\u003e\u003cp\u003eIf n \u003d 1 (or m \u003d 1), then we can try all O(m^2) (or O(n^2)) possible moves.\u003c/p\u003e\u003cp\u003eAnd for the other cases, there always have solution. We first hold the orb with number target[1][1] in initial board. Then we want to move other orbs to their position.\u003c/p\u003e\u003cp\u003eSo let\u0027s come up with a process to move orb from (a, b) to (c, d): it must be some continue path from (a, b) to (c, d), so we want to build a single move: it will move an orb from (a, b) to an adjacent cell (c, d). How to do that? We can move our touching orb to (c, d) first, and then move to (a, b). But there are some concerns: in this move, the touching orb shouldn\u0027t pass any already-done cells, and it shouldn\u0027t pass (a, b) when we get to (c, d).\u003c/p\u003e\u003cp\u003eThat means we need a good order to move orbs. We can do it in this way: first, as long as there are more than 2 rows, we move the orbs to last row (from left to right or right to left). And then it must be 2xm boards: we do it column by column from right to left. We can find that in this order, there always exist paths for our touching orb to get (c, d).\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/472/problem/F\" title\u003d\"Codeforces Round 270\"\u003e472F - Design Tutorial: Change the Goal\u003c/a\u003e\u003c/p\u003e\u003cp\u003eYou need to know some knowledge about linear algebra and notice the operation of xor on 32 bit integers equals to + operation in a 32 dimension linear space. If you don\u0027t know, you should learn it from the editorial of similar tasks, for example, Topcoder SRM 557 Div1-Hard.\u003c/p\u003e\u003cp\u003eWe need to know some basic properties of our operation:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003ewe can swap two number a and b by: a^\u003db, b^\u003da, a^\u003db.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThis operation is inversible, the inverse is itself.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eBy property 1 we can do the Gaussian elimination of each set of vectors.\u003c/p\u003e\u003cp\u003eBy property 2 we can use this way to build an answer: use some operation to make A[] into a base (linear independent vectors that the span will be A[]), then transfer it into a base of B[], then use the inverse of Gaussian elimination to recover B[].\u003c/p\u003e\u003cp\u003eSo now we have two bases: {a1, a2, ..., ax} and {b1, b2, ..., by}. If there exists some bi such that it can\u0027t be expressed as a linear combination of {a1, a2, ..., ax}, the solution can\u0027t exists. \u003c/p\u003e\u003cp\u003eOtherwise there always exists a solution: first we build b1 and put it in the first position. Suppose b1 \u003d a2 ^ a3 ^ a8, then we swap any of them, say, a2 into position one, and then xor it with a3 and a8, then we get b1. Note that after this operation {a1, a2, ..., ax} will remain a base. And we need to ensure we don\u0027t erase already-done numbers in a.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/472/problem/G\" title\u003d\"Codeforces Round 270\"\u003e472G - Design Tutorial: Increase the Constraints\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s start with a simpler task: we have string A and B (|A|, |B| \u0026lt;\u003d n), we have q queries and each query we ask the Hamming distance between A and a substring of B with length equals to |A|.\u003c/p\u003e\u003cp\u003eHow to solve this? We need to notice compute A with different offset of B is similar to the computation of convolution, so it can be done by FFT.\u003c/p\u003e\u003cp\u003eWe use +1 to replace \u00271\u0027 and we use -1 to replace \u00270\u0027, and then we do the convolution of A and reverse B. We can extract the answer of all possible query of \u0026quot;the Hamming distance between A and a substring of B with length equals to |A|.\u0026quot;!\u003c/p\u003e\u003cp\u003eThen let\u0027s come back to our problem, how to use this way to make a faster solution? We can use a way like sqrt decompose: we divide A into L blocks, for each block, we compute the convolution of this part with B, it will takes O(n*L*logn). And for each query, we can use the pre-calculated results to speedup (if a whole block contains in the query, we can compute it in O(1)). So each query needs no more than O(L) operation.\u003c/p\u003e\u003cp\u003eIf n \u003d q then this solution can run in O((n*logn) ^ 1.5). But in practice it has some issues: for example, we can use bit operation to speedup like __builtin_popcount(). I tried to set constraints to fail solution with only bit optimization, but seems I failed: I apologies to allow this kind of solutions passed. (I used __builtin_popcount() to test such solution, but in fact cnt[x\u0026lt;\u0026lt;16] + cnt[x\u0026gt;\u0026gt;16] is much faster than the builtin fucnion)\u003c/p\u003e\u003cp\u003e(Also, you can use your knowledge about real world computers to solve this task: \u003ca href\u003d\"//codeforces.com/contest/472/submission/8014415\"\u003ehttp://codeforces.com/contest/472/submission/8014415\u003c/a\u003e)\u003c/p\u003e\u003c/div\u003e","tags":[]}}