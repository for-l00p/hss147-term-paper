{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1458540343,"rating":3,"authorHandle":"Tomah4wk","modificationTimeSeconds":1458792319,"id":43913,"title":"\u003cp\u003eSyria IOI Selection 2016 Tutorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eCubes\u003c/h1\u003e\u003cp\u003eWe know that if we want to form a rectangle consisting \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e cubes , then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e must be divisible by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eH\u003c/i\u003e\u003c/span\u003e (The width and the height) .\u003c/p\u003e\u003cp\u003eNow we want to find the smallest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e different rectangles can be formed using \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e cubes.\u003c/p\u003e\u003cp\u003eObviously the number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e that we seek must have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e divisors such that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/64/b3/64b39d9157c0f24ee6c2cc801e7d14458b874781.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eAccording to the problem , we are only interested in values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eWe can count the number of divisors for each number in the interval \u003cspan class\u003d\"tex-span\"\u003e[1, 10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e]\u003c/span\u003e using Sieve Of Eratosthenes , which runs in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSince \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e \u0026lt; 100\u003c/span\u003e We can generate answers for all numbers in the interval \u003cspan class\u003d\"tex-span\"\u003e[1, 99]\u003c/span\u003e and keep them in an array.\u003c/p\u003e\u003cp\u003eWe loop over all numbers and update our answers array.Then we can answer each Testcase in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e .\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eAlternative Solution\u003c/strong\u003e : We can count the number of divisors for each number in the interval \u003cspan class\u003d\"tex-span\"\u003e[1, 10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e]\u003c/span\u003e using trivial division . This solution will lead into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eTLE\u003c/i\u003e\u003c/span\u003e , but you can generate the answers array offline and paste it into the source code. So you can answer each Testcase in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/ZMczkUGE\"\u003eImplementation\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eHasan\u0027s Mystery\u003c/h1\u003e\u003cp\u003eLet\u0027s first solve this problem without having the ability to add an edge. This can be done easily using LCA (Lowest Common Ancestor) of 2 nodes in a tree.\u003c/p\u003e\u003cp\u003eFirst we must root the tree (in an arbitary node) . Let\u0027s assume that node number \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e is the root (This will make the solution easier).\u003c/p\u003e\u003cp\u003eLet\u0027s define \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e]\u003c/span\u003e as the distance to some node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e from our root \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSo the length of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ePath\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e) \u003d \u003ci\u003edist\u003c/i\u003e[\u003ci\u003ea\u003c/i\u003e] + \u003ci\u003edist\u003c/i\u003e[\u003ci\u003eb\u003c/i\u003e] - 2 * \u003ci\u003edist\u003c/i\u003e[\u003ci\u003eLCA\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)]\u003c/span\u003e\u003c/p\u003e\u003cp\u003eSo, the answer for such query (a,b) will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edist\u003c/i\u003e[\u003ci\u003ea\u003c/i\u003e] + \u003ci\u003epath\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow, let\u0027s solve our problem. We can notice that it is never optimal to walk on some original edges before walking on our special edge. We can skip those edges and add this edge.\u003c/p\u003e\u003cp\u003eThe optimal way is to use the new edge to connect main nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eNode\u003c/i\u003e1, \u003ci\u003eNodea\u003c/i\u003e, \u003ci\u003eNodeb\u003c/i\u003e\u003c/span\u003e .\u003c/p\u003e\u003cp\u003eSo, we can try all possibilities and pick the cheapest one.\u003c/p\u003e\u003cp\u003eI will denote moving along the original edges of the tree by \u003cspan class\u003d\"tex-span\"\u003e —  \u0026gt; \u003c/span\u003e and moving along our special edge by \u003cspan class\u003d\"tex-span\"\u003e — \u003c/span\u003e .\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e1 —  \u0026gt; \u003ci\u003ea\u003c/i\u003e —  \u0026gt; \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e1 — \u003ci\u003ea\u003c/i\u003e —  \u0026gt; \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e1 — \u003ci\u003ea\u003c/i\u003e — 1 —  \u0026gt; \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e1 —  \u0026gt; \u003ci\u003ea\u003c/i\u003e — \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/uhktYgU8\"\u003eImplementation\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eRooks\u003c/h1\u003e\u003cp\u003eIt is clear that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e must be less that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e, \u003ci\u003eM\u003c/i\u003e) * 2\u003c/span\u003e , otherwise our answer will be 0.\u003c/p\u003e\u003cp\u003eNow let\u0027s solve this problem recursively row by row , placing 0 or 1 or 2 rooks in each row.\u003c/p\u003e\u003cp\u003eNo column must contain more than 2 rooks , so we can see that we are interested only in columns holding 0 or 1 rooks.\u003c/p\u003e\u003cp\u003eSo we can keep our results in a memoization table :\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eremaining\u003c/i\u003e \u003ci\u003erooks\u003c/i\u003e][\u003ci\u003erow\u003c/i\u003e \u003ci\u003ewe\u003c/i\u003e \u003ci\u003eare\u003c/i\u003e \u003ci\u003ein\u003c/i\u003e][\u003ci\u003enumber\u003c/i\u003e \u003ci\u003eof\u003c/i\u003e \u003ci\u003ecolumns\u003c/i\u003e \u003ci\u003eholding\u003c/i\u003e 0 \u003ci\u003erooks\u003c/i\u003e][\u003ci\u003enumber\u003c/i\u003e \u003ci\u003eof\u003c/i\u003e \u003ci\u003ecolumns\u003c/i\u003e \u003ci\u003eholding\u003c/i\u003e 1 \u003ci\u003erook\u003c/i\u003e]\u003c/span\u003e\u003c/p\u003e\u003cp\u003eIn each row we can pick one of these choices:\u003c/p\u003e\u003cp\u003e1 — place no rook in this row\u003c/p\u003e\u003cp\u003e2 — place 1 rook in this row in a 0-rook column\u003c/p\u003e\u003cp\u003e3 — place 1 rook in this row in a 1-rook column\u003c/p\u003e\u003cp\u003e4 — place 2 rooks in this row in 2 different 0-rook columns\u003c/p\u003e\u003cp\u003e5 — place 2 rooks in this row in 2 different 1-rook columns\u003c/p\u003e\u003cp\u003e6 — place 2 rooks in this row in 2 different columns (the first holding 0 rooks and the second holding 1 rook).\u003c/p\u003e\u003cp\u003eThis solution runs in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/XpwzN85H\"\u003eImplementation\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eFar Planet:\u003c/h1\u003e\u003cp\u003eThis is the most interesting problem in the problem set.\u003c/p\u003e\u003cp\u003eConsidering only operations of type 1 , this is a straight forward dijkstra problem .\u003c/p\u003e\u003cp\u003eIt\u0027s obvious that operations of type 2 (copying edges of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e to node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e and adding an extra cost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e to each of them) is equivalent to adding a directed edge from node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e to node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e with a cost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e (Let\u0027s denote them as special edges) .\u003c/p\u003e\u003cp\u003eIf we added a special edge from node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e to node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e then we cannot continue our path moving along some edge (normal or special) going from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e to some other node which was added after our special edge. So each edge must have a timer.\u003c/p\u003e\u003cp\u003eConsidering small constraints this can be solved using dijkstra and each node represents a pair {some node in the graph , timer} .\u003c/p\u003e\u003cp\u003eBut we can notice something .... we can attach a timer to each node in the Dijkstra Queue and when relaxing some node we use edges with less timer than our node timer and then delete them from the adjacency list (because we aren\u0027t interested in using them with further paths which are more expensive).\u003c/p\u003e\u003cp\u003eAnd we should take care that no node can be reached by a path ending with a special edge .\u003c/p\u003e\u003cp\u003eComplexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eMlogM\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003eThis is a short implementation: \u003ca href\u003d\"http://pastebin.com/UEnfrx4V\"\u003eImplementation\u003c/a\u003e\u003c/p\u003e\u003ch1\u003ePretty Array\u003c/h1\u003e\u003cp\u003eFirst of all let\u0027s calculate the inversion count for each element in our array.\u003c/p\u003e\u003cp\u003eLet\u0027s make some observations :D \u003c/p\u003e\u003cp\u003eFirst , let\u0027s see how could the inversions of some element change (assuming this element is still in its original position).\u003c/p\u003e\u003cp\u003eIn order to keep the element in its original position , the operation must be applied to :\u003c/p\u003e\u003cp\u003eAn element standing behind our element and with value strictly less than its. If we applied so , we can see that the inversion count of our element doesn\u0027t change , because all elements that changed their positions are strictly less than this one. So elements which are ahead of our element and changed their positions , were replaced with other elements that are strictly less than our element\u0027s value (and that makes no difference).\u003c/p\u003e\u003cp\u003eThe operation can be applied also to an arbitrary element ahead of our element. (obviously that won\u0027t make any change also).\u003c/p\u003e\u003cp\u003eSecond Observation , if our element\u0027s position was changed , that means that all elements with values less than or equal to its value are sorted. So that makes the inversion count zero.\u003c/p\u003e\u003cp\u003eSo our problem now is searching for the query that would exclude the inversion count of each element from our answer. This could be done easily by some sweeping and a simple data structure (Segment Tree , Binary Indexed Tree) .\u003c/p\u003e\u003cp\u003eFor each element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e we should search for the minimum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (The query position) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e AND \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/sub\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eAn implementation using BIT : \u003ca href\u003d\"http://pastebin.com/4QsPjVQN\"\u003eImplementation\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}