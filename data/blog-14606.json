{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1415221314,"rating":-27,"authorHandle":"Royalmiki","modificationTimeSeconds":1415260556,"id":14606,"title":"\u003ch1\u003e276 Div.2 Summary (In Chinese) _modified version\u003c/h1\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThis is my 1st time to write an article here(Is it also a blog?). So many things unknown... If there\u0027s anything wrong, please tell me and I\u0027ll try my best to fix and advance...(Maybe there\u0027s also something wrong in my sentences 〒_〒) I am a Chinese student, so I wanna trying to write a Summary of recent #276 Div.2 in Chinese(language C++)\u003c/p\u003e\u003cp\u003e真是状况百出的一次CF啊…… 最终Unrated了有点可惜，不过确实自己打得也很差……(-｡-;) 在这里写一下这一场codeforces的解题报告，部分题目有简单评析，代码还算清晰，主要阅读代码应该不难以理解。 （E题做不出，暂贴出DIV2 Contest时仅有一人的做出E的 \u003ca class\u003d\"rated-user user-gray\" href\u003d\"/profile/joker99\" title\u003d\"Newbie joker99\"\u003ejoker99\u003c/a\u003e 的代码）\u003c/p\u003e\u003cp\u003eA. Factory\u003c/p\u003e\u003cp\u003eYou\u0027ll get input \u0027a\u0027 and \u0027m\u0027. \u0027a\u0027 is always changing into double then get mod of \u0027m\u0027, if \u0027a\u0027 has been changed into zero, the proceeding will be broken down.The question is whether it will be broken down. So we can use an array vis[] to remember if a module has been appeared.We know that if there is a number which has been appeared, Such loops do get started(And never stop).\u003c/p\u003e\u003cp\u003e给两个数字a和m，工厂每次看a是多少就生产a个东西，然后把a变为a%m，如果a为0工序就崩盘了，问是否会崩盘 那就用大小为m的一个vis数组来记录当前余数是否被用过，然后模拟，每次记录当前余数，如果余数变成0了输出Yes，如果余数到达了曾经有过的余数位置，那么就会以此为一个循环永远循环下去，那么我们break，输出No\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e    int a,m;    cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;m;  \n    int vis[100086]\u003d{0};  \n    while(1)  \n    {  \n        if(a\u003d\u003d0){cout\u0026lt;\u0026lt;\u0026quot;Yes\u0026quot;;return 0;}  \n        if(vis[a]\u003d\u003d1){cout\u0026lt;\u0026lt;\u0026quot;No\u0026quot;;return 0;}  \n        vis[a]\u003d1;  \n        a\u003d(a+a)%m;  \n    }  \n    return 0;  \n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eB. Valuable Resources\u003c/p\u003e\u003cp\u003eThere is a city(mention it is a square) which should cover every mine and the area of it should be minimal. We can get x\\y\u0027s min\u0026amp;max while getting input, so we can get two length of the rectangle,use the longer length to get square.\u003c/p\u003e\u003cp\u003e有一个城市需要建造，给你许多矿坑d坐标点，问把这么多矿坑全都包进城市的话，城市所需最小面积是多少（注意，城市为平行于坐标轴的正方形） 这不知道算不算凸包，反正记录最大最小的x和y，然后相减获得最小矩形长宽，取两者较长边平方即可。\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint main()  \n{  \n    int n;  cin\u0026gt;\u0026gt;n;  \n    int up\u003d-inf,down\u003dinf,left\u003dinf,right\u003d-inf;  \n    for(int i\u003d0;i\u0026lt;n;i++)  \n    {  \n        int x,y;    cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;  \n        if(x\u0026lt;left)   left\u003dx;  \n        if(x\u0026gt;right)  right\u003dx;  \n        if(y\u0026lt;down)   down\u003dy;  \n        if(y\u0026gt;up) up\u003dy;  \n    }  \n    int len\u003dmax(up-down,right-left);  \n    cout\u0026lt;\u0026lt;(long long)len*len;  \n    return 0;  \n}  \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eC. Bits\u003c/p\u003e\u003cp\u003eThe bitwise OR operation. From right to left until beyond R.\u003c/p\u003e\u003cp\u003e这题是给一个范围（L是左边界，R是有边界）问你在这个范围内哪个数载二进制下1的数量是最多的（有多个解请输出最小数）。 也就是，要二进制的1尽量多，还要求尽量小，那就从低位开始把0变成1呗 那么我们就从左边界开始，从低位向高位按位或（0变成1，1也还是1）1，直到比R大停止，输出前一个（即比R小的最后一个数）。\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    int cases\u003d0;  \n    scanf(\u0026quot;%d\u0026quot;,\u0026amp;cases);  \n    for(int _case\u003d1;_case\u0026lt;\u003dcases;_case++)  \n    {  \n        ll l,r,t,p\u003d1;   cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r;  \n        for(ll i\u003d0;i\u0026lt;63;i++)  \n        {  \n            ll t\u003dl|p;  \n            if(t\u0026gt;r)break;  \n            l\u003dt,p\u0026lt;\u0026lt;\u003d1;  \n            //cout\u0026lt;\u0026lt;t\u0026lt;\u0026lt;endl;  \n        }  \n        cout\u0026lt;\u0026lt;l\u0026lt;\u0026lt;endl;  \n    }  \n    return 0;  \n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eD. Maximum Value\u003c/p\u003e\u003cp\u003eYou\u0027ll get a list of numbers, and you should find the maximal module of two of them. Mention: you can only compare module_values of a%b(a\u0026gt;b)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#define update(x) ans\u003d(ans\u0026lt;(x)?x:ans);  \n  \nint main()  \n{  \n    scanf(\u0026quot;%d\u0026quot;,\u0026amp;n);  \n    for(int i\u003d0;i\u0026lt;n;++i) scanf(\u0026quot;%d\u0026quot;,\u0026amp;a[i]);  \n    sort(a,a+n);  \n    for(int i\u003d0;i\u0026lt;n-1;++i)  \n    if(i\u003d\u003d0||a[i]!\u003da[i-1])  \n    {  \n        int j\u003da[i]+a[i],p;  \n        while(j \u0026lt;\u003d a[n-1])  \n        {  \n            p \u003d lower_bound(a,a+n,j)-a;  \n            if(p \u0026gt; 0) update(a[p-1] % a[i]);  \n            j+\u003da[i];  \n        }  \n        update(a[n-1] % a[i]);   \n    }  \n    printf(\u0026quot;%d\\n\u0026quot;,ans);  \n    return 0;  \n}  \n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["round #276","div.2","my 1st article"]}}