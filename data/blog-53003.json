{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1498835509,"rating":0,"authorHandle":"SAeed","modificationTimeSeconds":1498835509,"id":53003,"title":"\u003cp\u003eSPU Contest #16\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e \u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214418/problem/Blue\"\u003eBlue — Word\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eImplementation\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eCalculate the number of lower-case letters, and the number of upper-case letters, and convert the string to the corresponding case.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#define _CRT_SECURE_NO_WARNINGS\n#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\n\n\nint main(){\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\t\n\tstring s; cin \u0026gt;\u0026gt; s;\n\tint up \u003d 0, lo \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; s.size(); i++){\n\t\tif (s[i] \u0026gt;\u003d \u0027a\u0027 \u0026amp;\u0026amp; s[i] \u0026lt;\u003d \u0027z\u0027) lo++;\n\t\telse if (s[i] \u0026gt;\u003d \u0027A\u0027 \u0026amp;\u0026amp; s[i] \u0026lt;\u003d \u0027Z\u0027) up++;\n\t}\n\tfor (int i \u003d 0; i \u0026lt; s.size(); i++){\n\t\tif (s[i] \u0026gt;\u003d \u0027a\u0027 \u0026amp;\u0026amp; s[i] \u0026lt;\u003d \u0027z\u0027 \u0026amp;\u0026amp; up \u0026gt; lo) s[i] \u003d (s[i] - \u0027a\u0027) + \u0027A\u0027;\n\t\telse if (s[i] \u0026gt;\u003d \u0027A\u0027 \u0026amp;\u0026amp; s[i] \u0026lt;\u003d \u0027Z\u0027 \u0026amp;\u0026amp; lo \u0026gt;\u003d up) s[i] \u003d (s[i] - \u0027A\u0027) + \u0027a\u0027;\n\t}\n\tcout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214418/problem/Green\"\u003eGreen — Vicious Keyboard\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eBrute Force\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eI don\u0027t know why you all insisted on solving this problem on \u003ccode\u003eO(n)\u003c/code\u003e, while it could easily be solved with a complexity of \u003ccode\u003eO(n^2)\u003c/code\u003e. try flipping every letter, and in each time calculate the answer. Choose the maximum answer.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n^2)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#define _CRT_SECURE_NO_WARNINGS\n#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint calcVK(string s){\n\tint ret \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; s.size() - 1; i++){\n\t\tif (s[i] \u003d\u003d \u0027V\u0027 \u0026amp;\u0026amp; s[i + 1] \u003d\u003d \u0027K\u0027) ret++;\n\t}\n\treturn ret;\n}\n\nint main(){\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\t\n\tstring s;  cin \u0026gt;\u0026gt; s;\n\tint ans \u003d calcVK(s);\n\tfor (int i \u003d 0; i \u0026lt; s.size(); i++){\n\t\tif (s[i] \u003d\u003d \u0027V\u0027){\n\t\t\ts[i] \u003d \u0027K\u0027;\n\t\t\tans \u003d max(ans, calcVK(s));\n\t\t\ts[i] \u003d \u0027V\u0027;\n\t\t}\n\t\telse if (s[i] \u003d\u003d \u0027K\u0027){\n\t\t\ts[i] \u003d \u0027V\u0027;\n\t\t\tans \u003d max(ans, calcVK(s));\n\t\t\ts[i] \u003d \u0027K\u0027;\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214418/problem/Purple\"\u003ePurple — Substring and Subsequence\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eDP\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDP[\u003c/strong\u003e starting index of substring in s \u003cstrong\u003e][\u003c/strong\u003e current index of subsequence in t \u003cstrong\u003e]\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eOur moves are:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eIf \u003ccode\u003es[i] \u003d\u003d t[j]\u003c/code\u003e then we can move both \u003ccode\u003ei\u003c/code\u003e and \u003ccode\u003ej\u003c/code\u003e forward. Also, we can consider that we formed a word ending in this position.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf \u003ccode\u003es[i] !\u003d s[j]\u003c/code\u003e then we can only move \u003ccode\u003ej\u003c/code\u003e forward, because we need a \u003cstrong\u003esubstring\u003c/strong\u003e from s, and the letters of a substring must be continuous, while we need a \u003cstrong\u003esubsequence\u003c/strong\u003e from t, and the letters of a subsequence doesn\u0027t need to be continuous.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eIf we called our DP function \u003ccode\u003edp(0, 0)\u003c/code\u003e this will give us the numbers of words such that the substring start at index \u003ccode\u003e0\u003c/code\u003e. What we need is for the substring to start at any position, so we will call the DP function \u003ccode\u003en\u003c/code\u003e times, each time we will start the substring from a different index \u003ccode\u003edp(i, 0)\u003c/code\u003e. Since we don\u0027t change any variables inside our \u003ccode\u003edp\u003c/code\u003e function, there is no need to \u003ccode\u003ememset(memo, -1, sizeof memo)\u003c/code\u003e each time, just only once at the beginning.\u003c/p\u003e\u003cp\u003eThis way the complexity of our \u003ccode\u003edp\u003c/code\u003e function is \u003ccode\u003eO(n)\u003c/code\u003e, and we call this function \u003ccode\u003eO(n)\u003c/code\u003e times without clearing \u003ccode\u003ememo\u003c/code\u003e array with \u003ccode\u003e-1\u003c/code\u003e, which makes the total complexity \u003ccode\u003e2 x n\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#define _CRT_SECURE_NO_WARNINGS\n#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nstring s, t;\nint memo[5001][5001];\nint MOD \u003d 1e9 + 7;\nint dp(int i, int j){\n\tif (i \u003d\u003d s.size() || j \u003d\u003d t.size()) return 0;\n\n\tint \u0026amp;ret \u003d memo[i][j];\n\tif (ret !\u003d -1) return ret;\n\n\tret \u003d 0;\n\tif (s[i] \u003d\u003d t[j]) ret \u003d 1 + dp(i + 1, j + 1);\n\tret +\u003d dp(i, j + 1);\n\treturn ret %\u003d MOD;\n}\n\nint main(){\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\t\n\tcin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t;\n\tmemset(memo, -1, sizeof memo);\n\tint ans \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; s.size(); i++) ans +\u003d dp(i, 0), ans %\u003d MOD;\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214418/problem/Red\"\u003eRed — The Tag Game\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eDFS + Game Theory\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eIf you check some games then you will notice that the most optimal strategy for Bob is always like this:\u003c/p\u003e\u003cp\u003e1- Climb up for some steps (possibly zero)\u003c/p\u003e\u003cp\u003e2- Go to the lowest vertex from it\u003c/p\u003e\u003cp\u003e3- Stay in this vertex till the end\u003c/p\u003e\u003cp\u003eThus let\u0027s precalc the depth (the distance from the root) of the lowest vertex of each subtree (using dfs), distance from Alice\u0027s starting node and from Bob\u0027s starting node to the vertex (again dfs/bfs).\u003c/p\u003e\u003cp\u003eNow iterate over all vertices and check if Bob can reach this vertex earlier than Alice. If he can then update the answer with the lowest vertex that can be reached from this one.\u003c/p\u003e\u003cp\u003eThe answer is doubled depth of the obtained lowest reachable vertex. That is the time which will take Alice to get there.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#define _CRT_SECURE_NO_WARNINGS\n#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint n, x;\nvector\u0026lt;int\u0026gt; G[200100];\nint maxDepthToBottom[200100];\nint depthFromRoot[200100];\nint parent[200100];\nvoid dfs(int node, int par, int depth){\n\tparent[node] \u003d par;\n\tdepthFromRoot[node] \u003d depth;\n\n\tint maxDepth \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; G[node].size(); i++){\n\t\tint nxt \u003d G[node][i];\n\t\tif (nxt \u003d\u003d par) continue;\n\t\tdfs(nxt, node, depth + 1);\n\t\tmaxDepth \u003d max(maxDepth, maxDepthToBottom[nxt]);\n\t}\n\tmaxDepthToBottom[node] \u003d maxDepth + 1;\n}\n\nint main(){\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\t\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x;\n\tfor (int i \u003d 0; i \u0026lt; n - 1; i++){\n\t\tint a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tdfs(1, -1, 0);\n\tint currentNode \u003d x, ans \u003d 0, moves \u003d 0;\n\twhile (currentNode !\u003d -1){ // move among parents\n\t\tif (depthFromRoot[currentNode] \u0026gt; moves){\n\t\t\tint aliceToMaxDepthToBottom \u003d depthFromRoot[currentNode] + maxDepthToBottom[currentNode] - 1;\n\t\t\tans \u003d max(ans, aliceToMaxDepthToBottom);\n\t\t}\n\t\tcurrentNode \u003d parent[currentNode];\n\t\tmoves++;\n\t}\n\tcout \u0026lt;\u0026lt; ans * 2 \u0026lt;\u0026lt; endl; // * 2 because each move one of them moves\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214418/problem/Yellow\"\u003eYellow — Trees\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAdHoc\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe first thing we notice — beautiful sequence is can be determined with any member. The next thing — at least one tree will remain the same height. Prove: let\u0027s fix height of the first tree, and correct heights of all other ones. Obliviously, they all remain positive.\u003c/p\u003e\u003cp\u003eSolution with work time \u003ccode\u003eO(n^2)\u003c/code\u003e: we run down which tree we will fix, determine required height of the first tree and then relax answer.\u003c/p\u003e\u003cp\u003eThis solution can be optimized to linear solution: if we don\u0027t touch some tree, we know the first element of sequence. Let\u0027s count for each possible element amount of trees, which have required height. It can be done with linear loop and the \u0027increment\u0027 operation on array. After that we just find value of the first element, for which amount of \u0027good\u0027 trees is maximal and output n - x, where x is this amount.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#define _CRT_SECURE_NO_WARNINGS\n#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint best[100100];\nint a[100100];\n\nint main(){\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\t\n\tint n; cin \u0026gt;\u0026gt; n;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i];\n\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t// minimum between distance from the start\n\t\t// and distance from the end\n\t\tint distanceFromEdge \u003d min(i, n - i - 1);\n\t\tint baseElement \u003d a[i] - distanceFromEdge;\n\t\tif(baseElement \u0026gt; 0) best[baseElement]++;\n\t}\n\tint maxi \u003d -1;\n\tfor (int i \u003d 0; i \u0026lt; 100100; i++) maxi \u003d max(maxi, best[i]);\n\tcout \u0026lt;\u0026lt; n - maxi \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}