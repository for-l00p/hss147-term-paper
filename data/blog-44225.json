{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1460021143,"rating":0,"authorHandle":"Fcdkbear","modificationTimeSeconds":1460023343,"id":44225,"title":"\u003cp\u003eРазбор VNTU Training 21\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eЗадача А\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eУвидим, что правило p[p[i]] \u003d\u003d i можно выполнить ровно в двух случаях:\u003c/p\u003e\u003cp\u003e1) Для всех i p[i] \u003d\u003d i (но это запрещено условием)\u003c/p\u003e\u003cp\u003e2) Разбить все числа в перестановке на пары. Пусть мы смотрим на элементы i и j. Тогда сделаем p[i] \u003d j, p[j] \u003d i. \u003c/p\u003e\u003cp\u003eИз этого следует, что для нечетного n ответ построить невозможно (разбить нечетное количество элементов на пары не выйдет). Для четного же n построим перестановку описанным выше способом (в качестве i, j всегда можно брать соседние элементы)\u003c/p\u003e\u003cp\u003eСложность алгоритма — O(N)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача B\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eНас интересуют только целые положительные корни. Давайте оценим максимально возможное значение ответа.\u003c/p\u003e\u003cp\u003ex*x+s(x)*x-n \u003d\u003d 0\u003c/p\u003e\u003cp\u003ex*x-n\u0026lt;\u003d0 (ведь s(x)*x \u0026gt;\u003d 0)\u003c/p\u003e\u003cp\u003ex*x \u0026lt;\u003d n.\u003c/p\u003e\u003cp\u003eТак как n \u0026lt;\u003d \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e\u003c/span\u003e, то x \u0026lt;\u003d \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eМаксимальное значение суммы цифр для таких x — у числа 999999999, и равна она 81.\u003c/p\u003e\u003cp\u003eПереберем это значение суммы от 1 до 81 и решим квадратное уравнение для фиксированного s(x). У него может выйти только 1 полодительный целый корень (а может и не быть ни одного). Если у этого корня сумма цифр равна нашему текущему значению s(x) — обновим ответ.\u003c/p\u003e\u003cp\u003eСложность вышла порядка O(log(N))\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача C\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eНичего сложного — просто считываем данные про каждую задачу, и считаем, сколько людей ее могут решить. Если их хотя бы 2, увеличиваем ответ на 1.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача D\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eИдея решения — так называемый жадный алгоритм. Заметим, что если мы можем победить дракона — нам всегда выгодно побеждать его прямо сейчас (ведь так как все y[i] \u0026gt;\u003d 0, наша сила не уменьшится). Поэтому предлагается следующее решение: отсортируем всех драконов по x[i] и будем пробовать их убивать именно в этом порядке. Легко увидеть, что если мы не можем убить очередного дракона, то и всех других драконов мы убить не сможем, ведь ихнее значение x не меньше.\u003c/p\u003e\u003cp\u003eСложность алгоритма — O(NlogN)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача E\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eДокажем, что число n является T-простым тогда и только тогда, когда оно является квадратом простого числа. Если оно является таким, то очевидно, что у него ровно 3 делителя — 1, sqrt(n), n. Докажем, что у остальных чисел другое количество делителей. Есть несколько случаев:\u003c/p\u003e\u003cp\u003e1) Число n — простое. У него всего два делителя, оно нам не подходит.\u003c/p\u003e\u003cp\u003e2) В факторизацию числа n входит как минимум два простых — p и q. Тогда у n как минимум 4 делителя — 1, p, q, n. Значит такое число нам тоже не подходит.\u003c/p\u003e\u003cp\u003e3) В факторизацию числа n входит только одно простое p, но при этом \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d \u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e, k \u0026gt; 2. Тогда у n как минимум 4 делителя: 1, p, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e, n. Значит такое число нам тоже не подходит.\u003c/p\u003e\u003cp\u003eOK, значит теперь нам нужно быстро проверять, две вещи:\u003c/p\u003e\u003cp\u003e1) Правда ли, что у числа n целочисленный корень. Для этого найдем v \u003d (int)sqrt((double)n). Пройдемся циклом по числам v-1,v,v+1 (но только положительным), и посмотрим, правда ли, что их квадрат равен n. Этот шаг мы делаем за O(1). \u003c/p\u003e\u003cp\u003e2) Правда ли, что этот корень — простое число. Для этого напишем решето Эратосфена для всех чисел до 1000000, и тогда отвечать на этот запрос мы также сможем за O(1).\u003c/p\u003e\u003cp\u003eСложность алгоритма — O(NloglogN + M)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача F\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВо-первых, если существует строчка без 1, ответ, очевидно, -1. В остальных случаях, построение интересующего нас столбика существует.\u003c/p\u003e\u003cp\u003eДавайте посчитаем ответ для каждого столбика, а среди всех таких ответов выберем минимум. \u003c/p\u003e\u003cp\u003eКак считать ответ для столбика? Давайте сначала для каждой строчки найдем индекс самой правой и самой левой единички. Также для каждой ячейки найдем ближайшую справа и слева единичку в той же строчке. Зная эти величины, мы можем пересчитать цену, за которую мы можем поставить единичку в очередную ячейку (применяя циклические сдвиги вправо или влево). Тогда, ответ для столбика равен сумме ответов по всем ячейкам в этом столбике.\u003c/p\u003e\u003cp\u003eКак найти для каждой ячейки найдем ближайшую слева единичку (ближайшая справа ячейка находится аналогично)? Будем итерироваться по строчкам слева направо. Тогда, если в текущей ячейке стоит 1 — скажем, что ближайшая слева единичка — сама эта ячейка, иначе — ближайшая слева единичка для текущей ячейки равна ближайшей слева единичке для соседней слева ячейки. Проще это описать кодом:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003el[i][j] \u003d -1;\nif (s[i][j] \u003d\u003d \u00271\u0027) {\n    l[i][j] \u003d j;\n} else if (j \u0026gt; 0) {\n    l[i][j] \u003d l[i][j - 1];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eСложность нашего алгоритма равна O(n*m).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача G\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eОтвет равен 4 — (количество различных подков). Чтобы легко подсчитать количество различных подков, просто закинем их все в set, размер set и будет этим количеством.\u003c/p\u003e\u003cp\u003eСложность алгоритма — O(1).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача H\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eНесложная задача, которую почему-то никто не решил. Переберем все возможные сдвиги (легко увидеть, что x может принимать значение от -max(n1,n2) до max(n1,n2); аналогично, y может принимать значение от -max(m1,m2) до max(m1,m2)). Для фиксированного сдвига переберем ячейку первой таблицы, и посмотрим, соответствует ли ей какая-то ячейка второй таблицы при текущем сдвиге, и если да — обновим сумму. Среди всех рассмотренных сдвигов выберем тот, у которого сумма минимальна.\u003c/p\u003e\u003cp\u003eСложность алгоритма — O(n1*n2*max(n1,n2)*max(m1,m2))\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача I\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eДавайте для каждого числа в перестановке сохраним его позицию в этой перестановке pos[i] (в 0-индексации). Тогда при обработке очередного запроса, первый поиск выполнит ровно pos[v] + 1 операцию, а второй — n — pos[v] операций, где v — число из запроса.\u003c/p\u003e\u003cp\u003eСложность алгоритма O(n + m)\u003c/p\u003e\u003c/div\u003e","tags":[]}}