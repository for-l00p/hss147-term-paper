{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1484303865,"rating":181,"authorHandle":"Baba","modificationTimeSeconds":1484316126,"id":49743,"title":"\u003cp\u003eCodeCraft-17 and Codeforces Round #391 (Div. 1 + Div. 2, combined) Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e\u003ca href\u003d\"//www.codeforces.com/contest/757/problem/A\"\u003e757A — Gotta Catch Em\u0027 All!\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAuthor:\u003c/strong\u003e \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/tanujkhattar\" title\u003d\"Candidate Master tanujkhattar\"\u003etanujkhattar\u003c/a\u003e\u003cbr /\u003e\u003cstrong\u003eTesters:\u003c/strong\u003e \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/r.arora\" title\u003d\"Specialist r.arora\"\u003er.arora\u003c/a\u003e \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/born2rule\" title\u003d\"Specialist born2rule\"\u003eborn2rule\u003c/a\u003e \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eExpected complexity\u003c/strong\u003e: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d1/49/d149e37848c7f7e231f2f79fcfe74bfa4ddab02a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003cbr /\u003e\u003cstrong\u003eMain idea\u003c/strong\u003e: Maintain counts of required characters. \u003c/p\u003e\u003cp\u003eSince we are allowed to permute the string in any order to find the maximum occurences of the string \u0026quot;Bulbasaur\u0026quot;, we simply keep the count of the letters \u0027B\u0027, \u0027u\u0027, \u0027l\u0027, \u0027b\u0027, \u0027a\u0027, \u0027s\u0027, \u0027r\u0027. Now the string \u0026quot;Bulbasaur\u0026quot; contains 1 \u0027B\u0027, 2\u0027u\u0027, 1 \u0027l\u0027, 2\u0027a\u0027, 1 \u0027s\u0027, 1\u0027r\u0027 and 1 \u0027b\u0027, thus the answer to the problem is Min(count(\u0027B\u0027), count(\u0027b\u0027), count(\u0027s\u0027), count(\u0027r\u0027), count(\u0027l\u0027), count(\u0027a\u0027)/2, count(\u0027u\u0027)/2). You can maintain the counts using an array.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCorner Cases:\u003c/strong\u003e\u003cbr /\u003e1. Neglecting \u0027B\u0027 and while calculating the answer considering count(\u0027b\u0027)/2.\u003cbr /\u003e2. Considering a letter more than once ( \u0027a\u0027 and \u0027u\u0027 ). \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTester\u0027s code:\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint main()\n{\n  map\u0026lt;char, int\u0026gt; m;\n  string s;\n  cin\u0026gt;\u0026gt;s;\n  for(auto x : s)\n    m[x]++;\n\n  int ans \u003d m[\u0027B\u0027];\n  ans \u003d min(ans, m[\u0027u\u0027]/2);\n  ans \u003d min(ans, m[\u0027a\u0027]/2);\n  ans \u003d min(ans, m[\u0027b\u0027]);\n  ans \u003d min(ans, m[\u0027s\u0027]);\n  ans \u003d min(ans, m[\u0027r\u0027]);\n  ans \u003d min(ans, m[\u0027l\u0027]);\n  cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n  return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//www.codeforces.com/contest/757/problem/B\"\u003e757B — Bash\u0027s Big Day \u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAuthor\u003c/strong\u003e: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/architrai\" title\u003d\"Expert architrai\"\u003earchitrai\u003c/a\u003e\u003cbr /\u003e\u003cstrong\u003eTesters\u003c/strong\u003e: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/mprocks\" title\u003d\"Expert mprocks\"\u003emprocks\u003c/a\u003e, \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/deepanshugarg\" title\u003d\"Expert deepanshugarg\"\u003edeepanshugarg\u003c/a\u003e \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eExpected complexity\u003c/strong\u003e: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/58/3b/583ba6f1e208b2c345c9338a0cfc5c814d6ca674.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003cbr /\u003e\u003cstrong\u003eMain idea\u003c/strong\u003e: Square-root factorization and keeping count of prime factors.\u003c/p\u003e\u003cp\u003eThe problem can be simplified to finding a group of Pokemons such that their strengths have a common factor other that \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. We can do this by marking just the prime factors, and the answer will be the maximum count of a prime factor occurring some number of times. The prime numbers of each number can be found out using pre-computed sieve or square-root factorization.\u003c/p\u003e\u003cp\u003eCorner Cases : Since a Pokemon cannot fight with itself (as mentioned in the note), the minimum answer is 1. Thus, even in cases where every subset of the input has gcd equal to 1, the answer will be 1.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTester\u0027s code:\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint N;\nunordered_map\u0026lt;int, int\u0026gt; factors;\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin \u0026gt;\u0026gt; N;\n\n\twhile(N--)\n\t{\n\t\tint strength;\n\t\tcin \u0026gt;\u0026gt; strength;\n\n\t\tint root \u003d sqrt(strength);\n\t\tfor(int i \u003d 2; i \u0026lt;\u003d root; i++)\n\t\t{\n\t\t\tif(strength%i \u003d\u003d 0)\n\t\t\t\tfactors[i]++;\n\n\t\t\twhile(strength%i \u003d\u003d\n\t\t\t\t\t0) strength\n\t\t\t\t/\u003d i;\n\t\t}\n\n\t\tif(strength \u0026gt; 1) factors[strength]++; \n\t}\n\n\tint ans \u003d 1;\n\tfor(auto it \u003d factors.begin(); it !\u003d factors.end(); it++)\n\t{\n\t\tans \u003d max(ans, (*it).second);\n\t}\n\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//www.codeforces.com/contest/757/problem/C\"\u003e757C — Felicity is Coming! \u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAuthor:\u003c/strong\u003e \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/shivamkakkar\" title\u003d\"Candidate Master shivamkakkar\"\u003eshivamkakkar\u003c/a\u003e\u003cbr /\u003e\u003cstrong\u003eTesters:\u003c/strong\u003e \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/codelegend\" title\u003d\"Candidate Master codelegend\"\u003ecodelegend\u003c/a\u003e \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eExpected complexity\u003c/strong\u003e: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/92/33/9233e5a9ea86381add3ad78777a93e32e45fa5b8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003cbr /\u003e\u003cstrong\u003eMain idea\u003c/strong\u003e: Divide pokemon types into equivalence classes based on their counts in each list. \u003c/p\u003e\u003cp\u003eConsider a valid evolution plan \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e, \u003ci\u003eg\u003c/i\u003e]\u003c/span\u003e be the number of times Pokemon \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e appears in gym \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ep\u003c/i\u003e) \u003d \u003ci\u003eq\u003c/i\u003e\u003c/span\u003e then \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d5/a0/d5a050e8eb1ff5e2b604ece6766cd2160a22364f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eNow consider a group of Pokemon \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e such that all of them occur equal number of times in each gym (i.e. for each \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e1/50/e15087771f1ddb4c066be7c38cfd21944d55dba9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e). Any permutation of this group would be a valid bijection.\u003c/p\u003e\u003cp\u003eSay we have groups \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e, ...\u003c/span\u003e, then the answer would be \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e|! |\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e|! |\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e|! ...  \u003ci\u003emod\u003c/i\u003e 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e + 7\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFor implementing groups, we can use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003evector\u003c/i\u003e \u0026lt; \u003ci\u003evector\u003c/i\u003e \u0026lt; \u003ci\u003eint\u003c/i\u003e \u0026gt;  \u0026gt; \u003c/span\u003e and for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th pokemon, add the index of the gym to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th vector.\u003c/p\u003e\u003cp\u003eNow we need to find which of these vectors are equal. If we have the sorted \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003evector\u003c/i\u003e \u0026lt; \u003ci\u003evector\u003c/i\u003e \u0026lt; \u003ci\u003eint\u003c/i\u003e \u0026gt;  \u0026gt; \u003c/span\u003e, we can find equal elements by iterating over it and comparing adjacent elements.\u003c/p\u003e\u003cp\u003eConsider the merge step of merge sort. For a comparison between 2 vectors \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e, we cover at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e.\u003ci\u003esize\u003c/i\u003e(), \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e.\u003ci\u003esize\u003c/i\u003e())\u003c/span\u003e elements. Hence \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d1/49/d149e37848c7f7e231f2f79fcfe74bfa4ddab02a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e work is done at each level. There are \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/84/79/84791eb5da3b82ef8f569848a6c83eb22ed62e39.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e levels.\u003c/p\u003e\u003cp\u003eBonus : Try proving the time complexity for quicksort as well.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eAuthors\u0027s code:\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define PB push_back\n#define ALL(X) X.begin(), X.end()\n\n#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)\n\nconst int N \u003d 1e6;\nconst LL MOD \u003d 1e9 + 7;\nLL fact[N+1];\nint main()\n{\n    fast_io;\n    fact[0] \u003d fact[1] \u003d 1;\n    for(LL i\u003d2;i\u0026lt;\u003dN;i++)\n        fact[i] \u003d (fact[i-1]*i)%MOD;\n    int n,m;\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n    vector\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; x(m);\n    for(int i\u003d0;i\u0026lt;n;i++) {\n        int s;\n        cin \u0026gt;\u0026gt; s;\n        for(int j\u003d0;j\u0026lt;s;j++) {\n            int t;\n            cin \u0026gt;\u0026gt; t;\n            x[t-1].PB(i);\n        }\n    }\n    for(int i\u003d0;i\u0026lt;m;i++)\n        sort(ALL(x[i]));\n    sort(ALL(x));\n    LL ans \u003d 1;\n    LL sm \u003d 1;\n    for(int i\u003d1;i\u0026lt;m;i++) {\n        if(x[i]\u003d\u003dx[i-1])\n            sm++;\n        else\n            ans \u003d (ans*fact[sm])%MOD, sm \u003d 1;\n    }\n    ans \u003d (ans*fact[sm])%MOD;\n    cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n    return 0;\n}\n\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//www.codeforces.com/contest/757/problem/D\"\u003e757D — Felicity\u0027s Big Secret Revealed \u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAuthor:\u003c/strong\u003e \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/saatwik27\" title\u003d\"Expert saatwik27\"\u003esaatwik27\u003c/a\u003e\u003cbr /\u003e\u003cstrong\u003eTesters:\u003c/strong\u003e \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/imamit\" title\u003d\"Candidate Master imamit\"\u003eimamit\u003c/a\u003e,\u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/abhinavaggarwal\" title\u003d\"Expert abhinavaggarwal\"\u003eabhinavaggarwal\u003c/a\u003e,\u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Chipe1\" title\u003d\"Candidate Master Chipe1\"\u003eChipe1\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eExpected complexity\u003c/strong\u003e: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/30/5a/305a532663b8dec78fdc6973e1726c5ff4391df9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003cbr /\u003e\u003cstrong\u003eMain idea\u003c/strong\u003e: DP with Bitmask. \u003c/p\u003e\u003cp\u003eThis problem can be solved using Dynamic Programming with bitmask. \u003c/p\u003e\u003cp\u003eThe important thing to note here is that the set of distinct numbers formed will be a maximum of 20 numbers, i.e. from 1 to 20, else it won\u0027t fit 75 bits(1*(1 bits) + 2*(2 bits) + 4*(3 bits) + 8*(4 bits) + 5*(5 bits) \u003d 74 bits). So, we can use a bitmask to denote a set of numbers that are included in a set of cuts. \u003c/p\u003e\u003cp\u003eLet\u0027s see a Top-Down approach to solve it : \u003c/p\u003e\u003cp\u003eLets define the function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003emask\u003c/i\u003e)\u003c/span\u003e as : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003emask\u003c/i\u003e)\u003c/span\u003e denotes the number of sets of valid cuts that can be obtained from the state \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003emask\u003c/i\u003e\u003c/span\u003e. The state formation is defined below. \u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e be the maximum number among the numbers in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e denotes a set of numbers that have been generated using some number of cuts, all of them before \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Out of these cuts, the last cut has been placed just before \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Now, first we check if the set of cuts obtained from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e is valid or not(in order for a mask to be valid, mask \u003d\u003d \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eX\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e denotes number of set bits in the mask) and increment the answer accordingly if the mask is valid. And then we also have the option of adding another cut. We can add the next cut just before \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e provided the number formed by \u0026quot;\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e...\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e\u0026quot; \u0026lt;\u003d 20. Set the corresponding bit for this number formed to 1 in the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emask\u003c/i\u003e\u003c/span\u003e to obtain \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enewMask\u003c/i\u003e\u003c/span\u003e and recursively find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003enewMask\u003c/i\u003e)\u003c/span\u003e. \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eAuthor\u0027s code:\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e// Saatwik Singh Nagpal\n\n#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\n#define TRACE\n#ifdef TRACE\n#define TR(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate \u0026lt;typename Arg1\u0026gt;\nvoid __f(const char* name, Arg1\u0026amp;\u0026amp; arg1){\n  cerr \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026quot; : \u0026quot; \u0026lt;\u0026lt; arg1 \u0026lt;\u0026lt; std::endl;\n}\ntemplate \u0026lt;typename Arg1, typename... Args\u0026gt;\nvoid __f(const char* names, Arg1\u0026amp;\u0026amp; arg1, Args\u0026amp;\u0026amp;... args){\n  const char* comma \u003d strchr(names + 1, \u0027,\u0027);cerr.write(names, comma - names) \u0026lt;\u0026lt; \u0026quot; : \u0026quot; \u0026lt;\u0026lt; arg1\u0026lt;\u0026lt;\u0026quot; | \u0026quot;;__f(comma+1, args...);\n}\n#else\n#define TR(...)\n#endif\n\ntypedef long long                LL;\ntypedef vector \u0026lt; int \u0026gt;           VI;\ntypedef pair \u0026lt; int,int \u0026gt;         II;\ntypedef vector \u0026lt; II \u0026gt;            VII;\n\n#define MOD                      1000000007\n#define EPS                      1e-12\n#define N                        200100\n#define PB                       push_back\n#define MP                       make_pair\n#define F                        first \n#define S                        second\n#define ALL(v)                   v.begin(),v.end()\n#define SZ(a)                    (int)a.size()\n#define FILL(a,b)                memset(a,b,sizeof(a))\n#define SI(n)                    scanf(\u0026quot;%d\u0026quot;,\u0026amp;n)\n#define SLL(n)                   scanf(\u0026quot;%lld\u0026quot;,\u0026amp;n)\n#define PLLN(n)                  printf(\u0026quot;%lld\\n\u0026quot;,n)\n#define PIN(n)                   printf(\u0026quot;%d\\n\u0026quot;,n)\n#define REP(i,j,n)               for(LL i\u003dj;i\u0026lt;n;i++)\n#define PER(i,j,n)               for(LL i\u003dn-1;i\u0026gt;\u003dj;i--)\n#define endl                     \u0027\\n\u0027\n#define fast_io                  ios_base::sync_with_stdio(false);cin.tie(NULL)\n\n#define FILEIO(name) \\\n  freopen(name\u0026quot;.in\u0026quot;, \u0026quot;r\u0026quot;, stdin); \\\n  freopen(name\u0026quot;.out\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n \ninline int mult(int a , int b) { LL x \u003d a; x *\u003d LL(b); if(x \u0026gt;\u003d MOD) x %\u003d MOD; return x; }\ninline int add(int a , int b) { return a + b \u0026gt;\u003d MOD ? a + b - MOD : a + b; }\ninline int sub(int a , int b) { return a - b \u0026lt; 0 ? MOD - b + a : a - b; }\nLL powmod(LL a,LL b) { if(b\u003d\u003d0)return 1; LL x\u003dpowmod(a,b/2); LL y\u003d(x*x)%MOD; if(b%2) return (a*y)%MOD; return y%MOD; }\n\nint dp[1\u0026lt;\u0026lt;20][77];\nint b[77] , n;\nint go(int mask , int i) {\n  int cnt \u003d __builtin_popcount(mask);\n  if(i \u003d\u003d n) {\n    if(cnt !\u003d 0 \u0026amp;\u0026amp; (1\u0026lt;\u0026lt;cnt)-1 \u003d\u003d mask)\n      return 1;\n    return 0;\n  }\n  if(dp[mask][i] !\u003d -1) return dp[mask][i];\n\n  int ret \u003d 0;\n  if(b[i] \u003d\u003d 0)\n    ret \u003d go(mask , i+1);\n  else {\n    int num \u003d 0;\n    int j \u003d i;\n    while(1) {\n      num *\u003d 2;\n      num +\u003d b[j];\n      if(num \u0026gt; 20) break;\n      //if(!(mask \u0026amp; (1\u0026lt;\u0026lt;(num-1))))\n      ret \u003d add(ret , go(mask | (1\u0026lt;\u0026lt;(num-1)) , j+1));\n      j ++;\n      if(j \u003d\u003d n) break;\n    }\n    if(cnt !\u003d 0 \u0026amp;\u0026amp; mask \u003d\u003d (1\u0026lt;\u0026lt;cnt)-1)\n      ret ++;\n  }\n  return dp[mask][i] \u003d ret;\n}\n\nint main() {\n  FILL(dp,-1);\n  cin \u0026gt;\u0026gt; n;\n  string s; cin \u0026gt;\u0026gt; s;\n  REP(i,0,n)\n    b[i] \u003d s[i] - \u00270\u0027;\n  int ans \u003d 0;\n  REP(i,0,n)\n    ans \u003d add(ans , go(0,i));\n  PIN(ans);\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/757/problem/E\"\u003e757E — Bash Plays with Functions \u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAuthor\u003c/strong\u003e: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/satyam.pandey\" title\u003d\"Expert satyam.pandey\"\u003esatyam.pandey\u003c/a\u003e\u003cbr /\u003e\u003cstrong\u003eTesters\u003c/strong\u003e: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Superty\" title\u003d\"Candidate Master Superty\"\u003eSuperty\u003c/a\u003e,\u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/vmrajas\" title\u003d\"Candidate Master vmrajas\"\u003evmrajas\u003c/a\u003e \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eExpected complexity\u003c/strong\u003e: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/af/87/af87e57015d572d8e288fa1cdec6457c8a8cae0a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003cbr /\u003e\u003cstrong\u003eMain idea\u003c/strong\u003e: Multiplicative Functions. \u003c/p\u003e\u003cp\u003eWe can easily see that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e \u003d \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e(\u003ci\u003enumber\u003c/i\u003e \u003ci\u003eof\u003c/i\u003e \u003ci\u003edistinct\u003c/i\u003e \u003ci\u003eprime\u003c/i\u003e \u003ci\u003efactors\u003c/i\u003e \u003ci\u003eof\u003c/i\u003e \u003ci\u003en\u003c/i\u003e)\u003c/sup\u003e\u003c/span\u003e. We can also see that it is a \u003cstrong\u003emultiplicative function\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eWe can also simplify the definition of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e as: \u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/45/f34563e8fcaa96813b8d11f17809564d17fb68f3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eSince \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e is a multiplicative function, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e is also a multiplicative function. (by property of multiplicative functions)\u003c/p\u003e\u003cp\u003eFor each query, factorize \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow, since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is a multiplicative function, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e can be written as:\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sup\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sup\u003e ... \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/sub\u003e\u003c/sup\u003e\u003c/span\u003e\u003c/center\u003e\u003cp\u003eThen \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e can be computed as:\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003en\u003c/i\u003e) \u003d \u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sup\u003e) * \u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sup\u003e) * ... * \u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/sub\u003e\u003c/sup\u003e)\u003c/span\u003e\u003c/center\u003e\u003cp\u003eNow observe that the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e is independent of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e, as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e(\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e) \u003d 2\u003c/span\u003e. It is dependent only on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. So we calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e for all r and x using a simple \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e * 20\u003c/span\u003e DP as follows:\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d1/66/d166371f14511727d3da04e9a1b5603695f9df18.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eAnd now we can quickly compute \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e for each query as:\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003en\u003c/i\u003e) \u003d \u003ci\u003edp\u003c/i\u003e[\u003ci\u003er\u003c/i\u003e][\u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e] * \u003ci\u003edp\u003c/i\u003e[\u003ci\u003er\u003c/i\u003e][\u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e] * ... * \u003ci\u003edp\u003c/i\u003e[\u003ci\u003er\u003c/i\u003e][\u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/sub\u003e]\u003c/span\u003e\u003c/center\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eAuthor\u0027s code:\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e//Kyokai no Kanata //\n//Written by Satyam Pandey//\n#include\u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\ntypedef pair\u0026lt;int,int\u0026gt; II;\ntypedef vector\u0026lt;II\u0026gt; VII;\ntypedef vector\u0026lt;int\u0026gt; VI;\ntypedef vector\u0026lt; VI \u0026gt; VVI;\ntypedef long long int LL;\n\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define SZ(a) (int)(a.size())\n#define ALL(a) a.begin(),a.end()\n#define SET(a,b) memset(a,b,sizeof(a))\n\n#define si(n) scanf(\u0026quot;%d\u0026quot;,\u0026amp;n)\n#define dout(n) printf(\u0026quot;%d\\n\u0026quot;,n)\n#define sll(n) scanf(\u0026quot;%lld\u0026quot;,\u0026amp;n)\n#define lldout(n) printf(\u0026quot;%lld\\n\u0026quot;,n)\n#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate \u0026lt;typename Arg1\u0026gt;\nvoid __f(const char* name, Arg1\u0026amp;\u0026amp; arg1){\n  cerr\u0026lt;\u0026lt;name\u0026lt;\u0026lt;\u0026quot; : \u0026quot;\u0026lt;\u0026lt;arg1\u0026lt;\u0026lt;endl;\n}\ntemplate \u0026lt;typename Arg1, typename... Args\u0026gt;\nvoid __f(const char* names,Arg1\u0026amp;\u0026amp; arg1,Args\u0026amp;\u0026amp;... args){\n  const char* comma\u003dstrchr(names+1,\u0027,\u0027);\n  cerr.write(names,comma-names)\u0026lt;\u0026lt;\u0026quot; : \u0026quot;\u0026lt;\u0026lt;arg1\u0026lt;\u0026lt;\u0026quot; | \u0026quot;;__f(comma+1,args...);\n}\n#else\n#define trace(...)\n#endif\nfloat  inf\u003dstd::numeric_limits\u0026lt;double\u0026gt;::infinity();\nLL INF\u003dstd::numeric_limits\u0026lt;LL\u0026gt;::max();\n//FILE *fin \u003d freopen(\u0026quot;in\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n//FILE *fout \u003d freopen(\u0026quot;out\u0026quot;,\u0026quot;w\u0026quot;,stdout);\nconst int R\u003dint(1e6)+5,P\u003d25,N\u003dR,mod \u003d int(1e9)+7;\nint  F[R][P],LP[N];\ninline void seive(){\n  LP[1]\u003d1;\n  for(int i\u003d2;i\u0026lt;N;i++){\n    if(!LP[i])\n      for(int j\u003di;j\u0026lt;N;j+\u003di)\n        LP[j]\u003di;      \n  }\n}\ninline void precalc()\n{\n  for(int i\u003d0;i\u0026lt;R;i++) F[i][0] \u003d 1; \n  for(int i\u003d1;i\u0026lt;P;i++) F[0][i] \u003d 2;\n  for(int i\u003d1;i\u0026lt;R;i++) \n   for(int j\u003d1;j\u0026lt;P;j++)\n     F[i][j] \u003d (F[i][j-1] + F[i-1][j])%mod;\n}\ninline LL solve(int r,int n)\n{\n  LL ans\u003d1;\n  while(n!\u003d1)\n  {\n      int cnt\u003d0,p\u003dLP[n];\n      while(n%p\u003d\u003d0) n/\u003dp,cnt++;\n      ans\u003d(ans*F[r][cnt])%mod;\n  }\n  return ans;\n}\nint main()\n{\n  seive();precalc();\n  int q;si(q);\n  int r,n;\n  while(q--)\n  {\n    si(r);si(n);\n    lldout(solve(r,n));\n  }\n  return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//www.codeforces.com/contest/757/problem/F\"\u003e757F — Team Rocket Rises Again \u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAuthor\u003c/strong\u003e: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/tanujkhattar\" title\u003d\"Candidate Master tanujkhattar\"\u003etanujkhattar\u003c/a\u003e\u003cbr /\u003e\u003cstrong\u003eTesters\u003c/strong\u003e: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/shubhamvijay\" title\u003d\"Expert shubhamvijay\"\u003eshubhamvijay\u003c/a\u003e, \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/tanmayc25\" title\u003d\"Expert tanmayc25\"\u003etanmayc25\u003c/a\u003e, \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/vmrajas\" title\u003d\"Candidate Master vmrajas\"\u003evmrajas\u003c/a\u003e \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eExpected complexity\u003c/strong\u003e: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c2/89/c2895313e28a0111f74aad8830eb3723dcf997a8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003cbr /\u003e\u003cstrong\u003eMain idea\u003c/strong\u003e: Building Dominator tree on shortest path DAG. \u003c/p\u003e\u003cp\u003eFirst of all, we run Dijkstra\u0027s shortest path algorithm from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e as the source vertex and construct the shortest path DAG of the given graph. Note that in the shortest path DAG, the length of any path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to any other node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is equal to the length of the shortest path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e in the given graph. \u003c/p\u003e\u003cp\u003eNow, let us analyze what the function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e means. It will be equal to the number of nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e such that every path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e passes through node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e in the shortest path DAG, such that on removing node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e from the DAG, there will be no path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eIn other words, we want to find the number of nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e that are dominated by node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e considering \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e as the sources vertex in the shortest path DAG. This can be calculated by building dominator tree of the shortest path DAG considering \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e as the source vertex.\u003cbr /\u003eA node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is said to dominate a node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e wrt source vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e if all the paths from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e in the graph must pass through node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e.\u003cbr /\u003eYou can read more about dominator tree \u003ca href\u003d\"https://tanujkhattar.wordpress.com/2016/01/11/dominator-tree-of-a-directed-graph/\"\u003ehere\u003c/a\u003e. \u003c/p\u003e\u003cp\u003eOnce the dominator tree is formed, the answer for any node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is equal to the number of nodes in the subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e in the tree formed. \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eAuthor\u0027s code:\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e//Tanuj Khattar\n#include\u0026lt;bits/stdc++.h\u0026gt;\n \nusing namespace std;\n \ntypedef pair\u0026lt;int,int\u0026gt;   II;\ntypedef vector\u0026lt; II \u0026gt;      VII;\ntypedef vector\u0026lt;int\u0026gt;     VI;\ntypedef vector\u0026lt; VI \u0026gt;  VVI;\ntypedef long long int   LL;\n \n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define SZ(a) (int)(a.size())\n#define ALL(a) a.begin(),a.end()\n#define SET(a,b) memset(a,b,sizeof(a))\n \n#define si(n) scanf(\u0026quot;%d\u0026quot;,\u0026amp;n)\n#define dout(n) printf(\u0026quot;%d\\n\u0026quot;,n)\n#define sll(n) scanf(\u0026quot;%lld\u0026quot;,\u0026amp;n)\n#define lldout(n) printf(\u0026quot;%lld\\n\u0026quot;,n)\n#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)\n \n#define TRACE\n \n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate \u0026lt;typename Arg1\u0026gt;\nvoid __f(const char* name, Arg1\u0026amp;\u0026amp; arg1){\n  cerr \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026quot; : \u0026quot; \u0026lt;\u0026lt; arg1 \u0026lt;\u0026lt; std::endl;\n}\ntemplate \u0026lt;typename Arg1, typename... Args\u0026gt;\nvoid __f(const char* names, Arg1\u0026amp;\u0026amp; arg1, Args\u0026amp;\u0026amp;... args){\n  const char* comma \u003d strchr(names + 1, \u0027,\u0027);cerr.write(names, comma - names) \u0026lt;\u0026lt; \u0026quot; : \u0026quot; \u0026lt;\u0026lt; arg1\u0026lt;\u0026lt;\u0026quot; | \u0026quot;;__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n \n//FILE *fin \u003d freopen(\u0026quot;in\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n//FILE *fout \u003d freopen(\u0026quot;out\u0026quot;,\u0026quot;w\u0026quot;,stdout);\nconst int N \u003d int(1e5)+10;\nconst int M \u003d int(2e5)+10;\nconst LL INF \u003d LL(1e16);\nnamespace Dominator{\n  VI g[N],tree[N],rg[N],bucket[N];\n  int sdom[N],par[N],dom[N],dsu[N],label[N];\n  int arr[N],rev[N],T;//1-Based directed graph input\n  int Find(int u,int x\u003d0){\n    if(u\u003d\u003ddsu[u])return x?-1:u;\n    int v \u003d Find(dsu[u],x+1);\n    if(v\u0026lt;0)return u;\n    if(sdom[label[dsu[u]]]\u0026lt;sdom[label[u]])\n      label[u] \u003d label[dsu[u]];\n    dsu[u] \u003d v;\n    return x?v:label[u];\n  }\n  void Union(int u,int v){ //Add an edge u--\u0026gt;v\n    dsu[v]\u003du;   //yup,its correct :)\n  }\n  void dfs0(int u){\n    T++;arr[u]\u003dT;rev[T]\u003du;\n    label[T]\u003dT;sdom[T]\u003dT;dsu[T]\u003dT;\n    for(int i\u003d0;i\u0026lt;SZ(g[u]);i++){\n      int w \u003d g[u][i];\n      if(!arr[w])dfs0(w),par[arr[w]]\u003darr[u];\n      rg[arr[w]].PB(arr[u]);\n    }\n  }\n  void dfs1(int u,int p,int sub[]){\n    sub[u]\u003d1;\n    for(auto w:tree[u])\n      if(w!\u003dp)\n        dfs1(w,u,sub),sub[u]+\u003dsub[w];\n  }\n  void reset(int n){\n    for(int i\u003d1;i\u0026lt;\u003dn;i++){\n      g[i].clear();rg[i].clear();tree[i].clear();arr[i]\u003d0;\n    }\n    T\u003d0;\n  }\n  void addEdge(int u,int v){\n    g[u].PB(v);\n  }\n  //Build Dominator tree(in main)\n  void get(int n,int root,int sub[]){\n    dfs0(root);n\u003dT;\n    for(int i\u003dn;i\u0026gt;\u003d1;i--){\n      for(int j\u003d0;j\u0026lt;SZ(rg[i]);j++)\n        sdom[i] \u003d min(sdom[i],sdom[Find(rg[i][j])]);\n      if(i\u0026gt;1)bucket[sdom[i]].PB(i);\n      for(int j\u003d0;j\u0026lt;SZ(bucket[i]);j++){\n        int w \u003d bucket[i][j],v \u003d Find(w);\n        if(sdom[v]\u003d\u003dsdom[w])dom[w]\u003dsdom[w];\n        else dom[w] \u003d v;\n      }if(i\u0026gt;1)Union(par[i],i);\n    }\n    for(int i\u003d2;i\u0026lt;\u003dn;i++){\n      if(dom[i]!\u003dsdom[i])dom[i]\u003ddom[dom[i]];\n      tree[rev[i]].PB(rev[dom[i]]);\n      tree[rev[dom[i]]].PB(rev[i]);\n    }\n    dfs1(rev[1],rev[1],sub);\n  }//done :) \n}\nint n,m,s,vis[N],sub[N];\nVII g[N];VI P[N];\nLL d[N];\nint dijkstra(int root){\n  for(int i\u003d1;i\u0026lt;\u003dn;i++)d[i]\u003dINF,P[i].clear();\n  Dominator::reset(n);d[root]\u003d0;SET(vis,0);\n  set\u0026lt;pair\u0026lt;LL,int\u0026gt;\u0026gt; S;S.insert({d[root],root});\n  while(!S.empty()){\n    int u \u003d S.begin()-\u0026gt;S;\n    S.erase(S.begin());\n    if(vis[u])continue;\n    vis[u]\u003d1;\n    for(auto w:g[u])\n      if(d[u] + w.S \u0026lt; d[w.F]){\n        d[w.F] \u003d d[u] + w.S;\n        P[w.F].clear();P[w.F].PB(u);\n        S.insert({d[w.F],w.F});\n      }\n      else if(d[u]+w.S\u003d\u003dd[w.F])\n        P[w.F].PB(u);\n  }\n  for(int i\u003d1;i\u0026lt;\u003dn;i++)\n    for(auto j : P[i])\n        Dominator::addEdge(j,i);\n  Dominator::get(n,root,sub);\n  int mx \u003d 0;\n  for(int i\u003d1;i\u0026lt;\u003dn;i++)\n    if(i!\u003droot)\n      mx \u003d max(mx,sub[i]);\n  return mx;\n}\nint main()\n{\n  si(n);si(m);si(s);\n  for(int i\u003d1;i\u0026lt;\u003dm;i++){\n    int u,v,w;\n    si(u);si(v);si(w);\n    g[u].PB({v,w});\n    g[v].PB({u,w});\n  }\n  dout(dijkstra(s));\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eAnother approach for forming dominator tree is by observing that the shortest path directed graph formed is a DAG i.e. acyclic. So suppose we process the nodes of the shortest path dag in topological order and have a dominator tree of all nodes from which we can reach \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e already formed. Now, for the node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, we look at all the parents \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e in the DAG, and compute their LCA in the dominator tree built till now. We can now attach the node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e as a child of the LCA in the tree.\u003cbr /\u003eFor more details on this approach you can look at \u003ca class\u003d\"rated-user user-legendary\" href\u003d\"/profile/moejy0viiiiiv\" title\u003d\"Legendary grandmaster moejy0viiiiiv\"\u003e\u003cspan class\u003d\"legendary-user-first-letter\"\u003em\u003c/span\u003eoejy0viiiiiv\u003c/a\u003e\u0027s solution \u003ca href\u003d\"//codeforces.com/contest/757/submission/23761400\"\u003ehere\u003c/a\u003e. \u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//www.codeforces.com/contest/757/problem/G\"\u003e757G — Can Bash Save the Day? \u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAuthor\u003c/strong\u003e: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/tanujkhattar\" title\u003d\"Candidate Master tanujkhattar\"\u003etanujkhattar\u003c/a\u003e\u003cbr /\u003e\u003cstrong\u003eTesters\u003c/strong\u003e: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Toshad\" title\u003d\"Candidate Master Toshad\"\u003eToshad\u003c/a\u003e, \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/abhinavaggarwal\" title\u003d\"Expert abhinavaggarwal\"\u003eabhinavaggarwal\u003c/a\u003e \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eExpected complexity\u003c/strong\u003e: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/49/6c/496c58e7ce7f836718372f185b90d417d92ed12f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003cbr /\u003e\u003cstrong\u003eMain idea\u003c/strong\u003e: Making the Centroid Tree Persistent. \u003c/p\u003e\u003ch3\u003eSimpler Problem\u003c/h3\u003e\u003cp\u003eFirst let\u0027s try to solve a much simpler problem given as follows. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eQuestion:\u003c/strong\u003e Given a weighted tree, initially all the nodes of the given tree are inactive. We need to support the following operations fast :\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQuery\u003c/i\u003e \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e : Report the sum of distances of all active nodes from node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in the given tree.\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eActivate\u003c/i\u003e \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e : Mark node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e to be an active node. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSolution:\u003c/strong\u003e The above problem can be easily solved by a fairly standard technique called Centroid Decomposition. You can read more about \u003ca href\u003d\"https://tanujkhattar.wordpress.com/2016/01/10/centroid-decomposition-of-a-tree/\"\u003ehere\u003c/a\u003e \u003c/p\u003e\u003ch3\u003eSolution Idea\u003c/h3\u003e \u003cul\u003e   \u003cli\u003eEach query of the form \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eL\u003c/i\u003e \u003ci\u003eR\u003c/i\u003e \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e can be divided into two queries of form \u003cspan class\u003d\"tex-span\"\u003e(1 \u003ci\u003eR\u003c/i\u003e \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e - \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(1 \u003ci\u003eL\u003c/i\u003e - 1 \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e. Hence it is sufficient if we can support the following query:  \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e : Report the answer to query \u003cspan class\u003d\"tex-span\"\u003e(1 \u003ci\u003ei\u003c/i\u003e \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e\u003c/li\u003e   \u003cli\u003eTo answer a single query of the form \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e we can think of it as what is the sum of distance of all active nodes from node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, if we consider the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e nodes to be active.\u003c/li\u003e   \u003cli\u003eHence initially if we can preprocess the tree such that we activate nodes from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and after each update, store a copy of the centroid tree, then for each query \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e we can lookup the centroid tree corresponding to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, which would have the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e nodes activated, and query for node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/15/f7/15f7dc34e7339bd098ebf5555a5631c49acbbda1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time by looking at it’s ancestors.\u003c/li\u003e   \u003cli\u003eTo store a copy of the centroid tree for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, we need to make it persistent.\u003c/li\u003e \u003c/ul\u003e\u003ch3\u003ePersistent Centroid Tree : Key Ideas\u003c/h3\u003e \u003cul\u003e   \u003cli\u003eImportant thing to note is that single update in the centroid tree affects only the ancestors of the node in the tree.\u003c/li\u003e   \u003cli\u003eSince height of the centroid tree is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/15/f7/15f7dc34e7339bd098ebf5555a5631c49acbbda1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, each update affects only \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/15/f7/15f7dc34e7339bd098ebf5555a5631c49acbbda1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e other nodes in the centroid tree.\u003c/li\u003e   \u003cli\u003eThe idea is very similar to that of a persistent segment tree \u003cstrong\u003eBUT\u003c/strong\u003e unlike segtree, here each node of the centroid tree can have arbitrarily many children and hence simply creating a new copy of the affected nodes would not work because linking them to the children of old copy would take \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/48/73/4873ff7187b1cadfaef68a2cdef4b9e76c2fdcce.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for each affected node and this number could be as large as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, hence it could take \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/25/98/2598278d858ca050d0df0a7a0837da31074ef471.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time in total !\u003c/li\u003e \u003c/ul\u003e\u003ch3\u003eBinarizing the Input Tree\u003c/h3\u003e \u003cul\u003e   \u003cli\u003eTo overcome the issue, we convert the given tree \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e into an equivalent binary tree \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u0027\u003c/span\u003e by adding extra dummy nodes such that degree of each node in the transformed tree \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u0027\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e \u0026lt;  \u003d 3\u003c/span\u003e, and the number of dummy nodes added is bounded by \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/25/98/2598278d858ca050d0df0a7a0837da31074ef471.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/li\u003e   \u003cli\u003eThe dummy nodes are added such that the structure of the tree is preserved and weights of the edges added are set to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eTo do this, consider a node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e with degree \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e \u0026gt; 3\u003c/span\u003e and let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e...\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be it\u0027s adjacent nodes. Add a new node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e and change the edges as follows :   \u003cul\u003e     \u003cli\u003eDelete the edges \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e4\u003c/sub\u003e)\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e...\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e and add the edge \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e such that degree of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e reduces to \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e     \u003cli\u003eAdd edges \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ey\u003c/i\u003e - \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ey\u003c/i\u003e - \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e4\u003c/sub\u003e)\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e...\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ey\u003c/i\u003e - \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e such that degree of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e - 1\u003c/span\u003e. Recursively call the procedure on node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003c/ul\u003e\u003c/li\u003e   \u003cli\u003eSince degree of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e - 1\u003c/span\u003e instead of original degree \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, it can be proved that we need to add at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/25/98/2598278d858ca050d0df0a7a0837da31074ef471.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e new nodes before degree of each node in the tree is \u003cspan class\u003d\"tex-span\"\u003e \u0026lt;  \u003d 3\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003ch3\u003eConclusion\u003c/h3\u003e\u003cp\u003eHence we perform centroid decomposition of this transformed tree \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u0027\u003c/span\u003e. The centroid tree formed would have the following properties.\u003c/p\u003e \u003cul\u003e   \u003cli\u003eThe height of the centroid tree is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/15/f7/15f7dc34e7339bd098ebf5555a5631c49acbbda1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/li\u003e   \u003cli\u003eEach node in the centroid tree has \u003cspan class\u003d\"tex-span\"\u003e ≤ 3\u003c/span\u003e children.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eNow we can easily make this tree persistent by path-copying approach.\u003cbr /\u003eTo handle the updates,\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eWay-1 :\u003c/strong\u003e Observe that swapping \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1]\u003c/span\u003e would affect only the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u0027\u003ci\u003eth\u003c/i\u003e\u003c/span\u003e persistent centroid tree, which can be rebuilt from the tree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/span\u003e by a single update query. In this approach, for each update we add \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/15/f7/15f7dc34e7339bd098ebf5555a5631c49acbbda1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e new nodes. See author\u0027s code below for more details.\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003eWay-2 :\u003c/strong\u003e First we go down to the lca of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e + 1]\u003c/span\u003e in the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e\u0027th persistent tree, updating the values as we go. Now, let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the child of lca which is an ancestor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e]\u003c/span\u003e, and let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the child which is an ancestor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e + 1]\u003c/span\u003e. Now, we replace \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e\u0027th persistent tree with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e of \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e + 1)\u003c/span\u003e\u0027th persistent tree. Similarly, we replace \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + 1\u003c/span\u003e\u0027th persistent tree with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e\u0027th persistent tree. So now \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e + 1]\u003c/span\u003e is active in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e\u0027th persistent tree and both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e + 1]\u003c/span\u003e are active in \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e + 1)\u003c/span\u003e\u0027th persistent tree.To deactivate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e]\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e\u0027th persistent tree we replace \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e\u0027th persistent tree with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e of \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e - 1)\u003c/span\u003e\u0027th persistent tree. Hence in this approach we do not need to create new \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/15/f7/15f7dc34e7339bd098ebf5555a5631c49acbbda1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e nodes for each update. See testers\u0027s code below for more details.\u003c/li\u003e \u003c/ul\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eAuthor\u0027s code:\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e//Tanuj Khattar\n#include\u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\ntypedef pair\u0026lt;int,int\u0026gt;   II;\ntypedef vector\u0026lt; II \u0026gt;      VII;\ntypedef vector\u0026lt;int\u0026gt;     VI;\ntypedef vector\u0026lt; VI \u0026gt; \tVVI;\ntypedef long long int \tLL;\n\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define SZ(a) (int)(a.size())\n#define ALL(a) a.begin(),a.end()\n#define SET(a,b) memset(a,b,sizeof(a))\n\n#define si(n) scanf(\u0026quot;%d\u0026quot;,\u0026amp;n)\n#define dout(n) printf(\u0026quot;%d\\n\u0026quot;,n)\n#define sll(n) scanf(\u0026quot;%lld\u0026quot;,\u0026amp;n)\n#define lldout(n) printf(\u0026quot;%lld\\n\u0026quot;,n)\n#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate \u0026lt;typename Arg1\u0026gt;\nvoid __f(const char* name, Arg1\u0026amp;\u0026amp; arg1){\n  cerr \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026quot; : \u0026quot; \u0026lt;\u0026lt; arg1 \u0026lt;\u0026lt; std::endl;\n}\ntemplate \u0026lt;typename Arg1, typename... Args\u0026gt;\nvoid __f(const char* names, Arg1\u0026amp;\u0026amp; arg1, Args\u0026amp;\u0026amp;... args){\n  const char* comma \u003d strchr(names + 1, \u0027,\u0027);cerr.write(names, comma - names) \u0026lt;\u0026lt; \u0026quot; : \u0026quot; \u0026lt;\u0026lt; arg1\u0026lt;\u0026lt;\u0026quot; | \u0026quot;;__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\n//FILE *fin \u003d freopen(\u0026quot;in\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n//FILE *fout \u003d freopen(\u0026quot;out\u0026quot;,\u0026quot;w\u0026quot;,stdout);\nconst int MAXN \u003d int(2e5)+10;\nconst int MAXQ \u003d int(2e5)+10;\nconst int N \u003d 2*MAXN;\nconst int M \u003d 2*N;\nint A[N]; //the permutation given\nint last[N],prv[M],nxt[M],to[M],deg[N],W[M],root[N];\nnamespace tree{\n  int sz,edge,vis[N];\n  void addEdge(int u,int v,int w \u003d 0){\n    prv[edge] \u003d last[u];W[edge] \u003d w;\n    if(last[u]!\u003d-1)nxt[last[u]] \u003d edge;\n    last[u] \u003d edge;\n    to[edge] \u003d v;\n    edge++;\n  }\n  void addEdge1(int u,int v,int e){\n    prv[e] \u003d last[u];nxt[e] \u003d -1;\n    if(last[u]!\u003d-1)nxt[last[u]] \u003d e;\n    last[u] \u003d e;\n    to[e] \u003d v;\n  }\n  void deleteEdge(int u,int e){\n    if(nxt[e]!\u003d-1)prv[nxt[e]] \u003d prv[e];\n    if(prv[e]!\u003d-1)nxt[prv[e]] \u003d nxt[e];\n    if(last[u] \u003d\u003d e) last[u] \u003d prv[e];\n  }\n  void changeEdge(int u,int v,vector\u0026lt;int\u0026gt; edges){\n    //assert(SZ(edges) \u003d\u003d 3);assert(deg[u] \u0026gt; 3);\n    sort(ALL(edges));reverse(ALL(edges));\n    for(auto e : edges)\n      deleteEdge(u,e);\n    last[v] \u003d last[u];\n    last[u] \u003d -1;\n    for(auto e : edges)\n      addEdge1(u,to[e],e);\n  }\n  void pre(){\n    SET(last,-1);SET(nxt,-1);\n    SET(prv,-1);SET(to,-1);\n  }\n  //binarize the give tree.should be called from a leaf node.\n  void binarize(int u,int p,int edge){\n    vis[u]\u003d1;\n    if(deg[u] \u0026gt; 3){\n      addEdge(u,++sz);\n      deg[sz] \u003d deg[u] - 1;\n      set\u0026lt;int\u0026gt; temp;temp.insert(edge^1);\n      int e \u003d last[u];\n      while(SZ(temp) \u0026lt; 3){\n        temp.insert(e);\n        e \u003d prv[e];\n      }\n      changeEdge(u,sz,vector\u0026lt;int\u0026gt;(temp.begin(),temp.end()));\n      deg[u] \u003d 3;\n      addEdge(sz,u);\n    }\n    for(int e \u003d last[u];e \u0026gt;\u003d 0; e \u003d prv[e]){\n      if(!vis[to[e]])\n        binarize(to[e],u,e);\n      else to[e] \u003d p;\n    }\n  }\n}\nnamespace Centroid{\n  const int LOGN \u003d 19;\n  const int MAXC \u003d N + (MAXN + MAXQ)*LOGN;\n  int sub[N],nn,done[M],C[MAXC][3],L[N],R[N],idx[N],len[N],T,cnt[MAXC],lvl,IDX[MAXC];\n  LL sum[MAXC],cntbn[MAXC],dist[LOGN][N];\n  void dfs1(int u,int p){\n    sub[u]\u003d1;nn++;\n    for(int e \u003d last[u];e \u0026gt;\u003d 0; e \u003d prv[e]){\n      int w \u003d to[e];\n      if(w!\u003dp \u0026amp;\u0026amp; !done[e])\n        dfs1(w,u),sub[u]+\u003dsub[w];\n    }\n  }\n  int dfs2(int u,int p){\n    for(int e \u003d last[u];e \u0026gt;\u003d 0; e \u003d prv[e]){\n      if(done[e])continue;int w \u003d to[e];\n      if(w!\u003dp \u0026amp;\u0026amp; sub[w]\u0026gt;nn/2)\n        return dfs2(w,u);\n    }return u;\n  }\n  void dfs(int u,int p){\n    for(int e \u003d last[u];e \u0026gt;\u003d 0; e \u003d prv[e]){\n      if(done[e] || to[e]\u003d\u003dp)continue;\n      dist[lvl][to[e]] \u003d dist[lvl][u] + W[e];\n      dfs(to[e],u);\n    }\n  }\n  int decompose(int root,int p,int l \u003d 0){\n    nn\u003d0;dfs1(root,root);\n    root\u003ddfs2(root,root);\n    lvl \u003d l;dfs(root,root);\n    idx[root] \u003d ++T;\n    int id \u003d idx[root];IDX[T] \u003d T;\n    L[id] \u003d T;\n    for(int e \u003d last[root];e \u0026gt;\u003d 0;e \u003d prv[e]){\n      if(done[e])continue;\n      assert(!done[e^1]);\n      done[e]\u003ddone[e^1]\u003d1;\n      int c \u003d decompose(to[e],root,l+1);\n      assert(len[id] \u0026lt; 3);\n      C[id][len[id]++] \u003d idx[c];\n    }\n    R[id] \u003d T;\n    return root;\n  }\n  int update(int x,int id,int lvl\u003d0){\n    int ID \u003d ++T;\n    cnt[ID] \u003d cnt[id] + 1;\n    sum[ID] \u003d sum[id] + dist[lvl][x];\n    IDX[ID] \u003d IDX[id];\n    for(int i\u003d0;i\u0026lt;len[IDX[id]];i++)\n      if(L[IDX[C[id][i]]] \u0026lt;\u003d idx[x] \u0026amp;\u0026amp; idx[x] \u0026lt;\u003d R[IDX[C[id][i]]]){\n        C[ID][i] \u003d update(x,C[id][i],lvl+1);\n        cntbn[C[ID][i]] \u003d cntbn[C[id][i]] + dist[lvl][x];\n      }\n      else C[ID][i] \u003d C[id][i];\n    return ID;\n  }\n  LL query(int x,int id,int lvl\u003d0){\n    LL ret \u003d sum[id];\n    for(int i\u003d0;i\u0026lt;len[IDX[id]];i++)\n      if(L[IDX[C[id][i]]] \u0026lt;\u003d idx[x] \u0026amp;\u0026amp; idx[x] \u0026lt;\u003d R[IDX[C[id][i]]])\n        ret +\u003d query(x,C[id][i],lvl+1) - cntbn[C[id][i]] + (cnt[id] - cnt[C[id][i]])*dist[lvl][x];\n    return ret;\n  }\n}\nvoid binarize(int n){\n  int root \u003d -1;\n  for(int i\u003d1;i\u0026lt;\u003dn;i++)\n    if(deg[i] \u003d\u003d 1)\n      root \u003d i;\n  tree::binarize(root,root,-1);\n}\nint main()\n{\n  tree::pre();\n  int n,q;\n  si(n);si(q);\n  tree::sz \u003d n;\n  for(int i\u003d1;i\u0026lt;\u003dn;i++)si(A[i]);\n  for(int i\u003d1;i\u0026lt;n;i++){\n    int u,v,w;\n    si(u);si(v);si(w);\n    tree::addEdge(u,v,w);\n    tree::addEdge(v,u,w);\n    deg[u]++;deg[v]++;\n  }\n  //binarize the given tree\n  binarize(n);\n  //build the centroid tree.\n  Centroid::decompose(1,-1);\n  root[0] \u003d 1;\n  //make it persistent and handle the queries.\n  for(int i\u003d1;i\u0026lt;\u003dn;i++)\n    root[i] \u003d Centroid::update(A[i],root[i-1]);\n  const int MOD \u003d (1 \u0026lt;\u0026lt; 30);\n  LL ans \u003d 0;\n  while(q--){\n    int t;si(t);\n    if(t\u003d\u003d1){\n      int l,r,v;\n      si(l);si(r);si(v);\n      l \u003d l ^ ans;\n      r \u003d r ^ ans;\n      v \u003d v ^ ans;\n      ans \u003d Centroid::query(v,root[r])-Centroid::query(v,root[l-1]);\n      lldout(ans);\n      ans \u003d ans % MOD;\n    }\n    else{\n      int x;si(x);x \u003d x ^ ans;\n      root[x] \u003d Centroid::update(A[x+1],root[x-1]);\n      swap(A[x],A[x+1]);\n    }\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTesters\u0027s code:\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e//Toshad Salwekar\n#include\u0026lt;bits/stdc++.h\u0026gt;\n#define f(i,a,n) for(int i\u003da;i\u0026lt;n;i++)\n#define S second\n#define F first\n#define Sc(n) scanf(\u0026quot;%lld\u0026quot;,\u0026amp;n)\n#define scc(a,b,c) scanf(\u0026quot;%lld %lld %lld\u0026quot;,\u0026amp;a,\u0026amp;b,\u0026amp;c)\n#define sp(a) scanf(\u0026quot;%lld %lld\u0026quot;,\u0026amp;a.first,\u0026amp;a.second)\n#define pb push_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define all(a) a.begin(),a.end()\n#define sc(n) scanf(\u0026quot;%d\u0026quot;,\u0026amp;n)\n#define It iterator\n#define SET(a,b) memset(a,b,sizeof(a))\n#define DRT()  int t; cin\u0026gt;\u0026gt;t; while(t--)\n// inbuilt functions\n// __gcd,  __builtin_ffs,     (returns least significant 1-bit, __builtin_ffsll(1)\u003d1)\n// __builtin_clz,             (returns number of leading zeroes in \n// __builtin_popcount,\nusing namespace std;\ntypedef long long LL;\ntypedef pair\u0026lt;int,LL\u0026gt; PII;\ntypedef vector\u0026lt;int\u0026gt; vi;\n#define tr(container, it) for(__typeof(container.begin()) it \u003d container.begin(); it !\u003d container.end(); it++)\n#define trv(s,it) for(auto it:s)\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate \u0026lt;typename Arg1\u0026gt;\nvoid __f(const char* name, Arg1\u0026amp;\u0026amp; arg1){\n\tcerr \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026quot; : \u0026quot; \u0026lt;\u0026lt; arg1 \u0026lt;\u0026lt; std::endl;\n}\ntemplate \u0026lt;typename Arg1, typename... Args\u0026gt;\nvoid __f(const char* names, Arg1\u0026amp;\u0026amp; arg1, Args\u0026amp;\u0026amp;... args){\n\tconst char* comma \u003d strchr(names + 1, \u0027,\u0027);cerr.write(names, comma - names) \u0026lt;\u0026lt; \u0026quot; : \u0026quot; \u0026lt;\u0026lt; arg1\u0026lt;\u0026lt;\u0026quot; | \u0026quot;;__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n#define N 400005\n#define LOGN 20\nconst int MAX \u003d N*LOGN;\nconst int MOD \u003d (1\u0026lt;\u0026lt;30);\nint cn[N],nn,par[N],arr[N],centroid,C,tot,anc[N];\nLL dis[LOGN][N];\nvector\u0026lt;PII\u0026gt; tree[N];\nbool mark[N];\tstack\u0026lt;int\u0026gt; st;\nstruct node\n{\tint id,cn,len; LL sum,psum;\n\tnode* child[4];\n}*pers[N];\nnode BUFF[MAX];\nint buf_len;\nint dfs1(int i,int p)\n{\tint r\u003d1,mx\u003d0,t;\n\tfor(auto it:tree[i])\n\t\tif(it.F!\u003dp \u0026amp;\u0026amp; !mark[it.F])\n\t\t\tr+\u003ddfs1(it.F,i);\n\tcn[i]\u003dr;\n\treturn r;\n}\nint dfs2(int i,int p,int num)\n{\tfor(auto it:tree[i])\n\t\tif(cn[it.F]\u0026gt;num/2 \u0026amp;\u0026amp; !mark[it.F] \u0026amp;\u0026amp; it.F!\u003dp)\n\t\t\treturn dfs2(it.F,i,num);\n\treturn i;\n}\nvoid dfs(int i,int p,LL d)\n{\tfor(auto it:tree[i])\n\t\tif(it.F!\u003dp \u0026amp;\u0026amp; !mark[it.F])\n\t\t\tdfs(it.F,i,d+it.S);\n\tdis[C][i]\u003dd;\n}\nvoid dec(int root, node* p,int c)\n{\tdfs1(root,root);\n\tint cen\u003ddfs2(root,root,cn[root]);\t\t//cen is centroid of current subtree\n\tC\u003dc;\n\tdfs(cen,cen,0LL);\n\tmark[cen]\u003d1;\n\tnode* tmp\u003d BUFF + buf_len++;\n\ttmp-\u0026gt;id\u003dcen;\n\ttmp-\u0026gt;cn\u003d0;   tmp-\u0026gt;len\u003d0;\n\ttmp-\u0026gt;sum\u003d0;\t\t\n\tif(p!\u003dNULL)\n\t{\tp-\u0026gt;child[p-\u0026gt;len++]\u003dtmp;\n\t\tpar[cen]\u003dp-\u0026gt;id;\n\t}\n\telse\n\t{\tpers[0]\u003dtmp;\t\t\t\t//This means cen is the centroid\n\t\tcentroid\u003dcen;\n\t}\n\tfor(auto it:tree[cen])\n\t\tif(!mark[it.F])\n\t\t\tdec(it.F,tmp,c+1);\n}\nnode* persist(node* root, int i,int l)\n{\t\n\tnode* tmp\u003d BUFF + buf_len++;\n\ttmp-\u0026gt;id\u003droot-\u0026gt;id;\n\ttmp-\u0026gt;sum\u003droot-\u0026gt;sum + dis[l][i];\n\tif(l)\n\t\ttmp-\u0026gt;psum\u003droot-\u0026gt;psum + dis[l-1][i];\n\ttmp-\u0026gt;cn\u003droot-\u0026gt;cn + 1;\n\ttmp-\u0026gt;len\u003d0;\n\tf(j,0,root-\u0026gt;len)\n\t\tif(!st.empty() \u0026amp;\u0026amp; (root-\u0026gt;child[j])-\u0026gt;id\u003d\u003dst.top())\n\t\t{\tst.pop();\n\t\t\ttmp-\u0026gt;child[tmp-\u0026gt;len++]\u003dpersist(root-\u0026gt;child[j],i,l+1);\n\t\t}\n\t\telse\n\t\t\ttmp-\u0026gt;child[tmp-\u0026gt;len++]\u003droot-\u0026gt;child[j];\n\treturn tmp;\n}\nLL query(node* root, int i,int l)\n{\tLL ans\u003d0;\n\tans+\u003d(root-\u0026gt;cn)*dis[l][i]+root-\u0026gt;sum;\t\t\t\t\t// Add all nodes in range which are in subtree(in centroid tree) of current node\n\tf(j,0,root-\u0026gt;len)\n\t\tif(!st.empty() \u0026amp;\u0026amp; root-\u0026gt;child[j]-\u0026gt;id\u003d\u003dst.top())\n\t\t{\tst.pop();\n\t\t\tans-\u003d(root-\u0026gt;child[j]-\u0026gt;psum)+(root-\u0026gt;child[j]-\u0026gt;cn)*dis[l][i];\t\t\t//Subtract all nodes which will be considered in the child(i.e., they are\n\t\t\tans+\u003dquery(root-\u0026gt;child[j],i,l+1);\t\t\t\t\t\t\t// in same subtree as the query node).\n\t\t}\n\treturn ans;\n}\nvoid binarise(unordered_map\u0026lt;int,LL\u0026gt; \u0026amp;add,int i,PII p,bool fl)\n{     unordered_map\u0026lt;int,LL\u0026gt; tmp;\n\tmark[i]\u003d1;\n\tif(fl)\t\t\t\t\t\t\t\t\t// fl\u003d1 for those nodes which were not in original tree\n\t{     add.erase(p.F);\n\t\ttree[i].pb(p);\n\t\ttree[i].pb(*(add.begin()));\n\t\tadd.erase(add.begin());\n\t\tif(add.size()\u0026gt;1)\t\t\t\t\t\t\t// Need to create more nodes\n\t\t{     tree[i].pb(mp(tot++,0LL));\n\t\t\tbinarise(add,tot-1,mp(i,0LL),1);\n\t\t}\n\t\telse\t\t\t\t\n\t\t{     tree[i].pb(*(add.begin()));\n\t\t\tbinarise(tmp,tree[i][2].F,mp(i,tree[i][2].S),0);\n\t\t}\n\t\tbinarise(tmp,tree[i][1].F,mp(i,tree[i][1].S),0);\n\t}\n\telse if(tree[i].size()\u0026gt;3)\n\t{     int t\u003d0;bool fl\u003d0;\n\t\tif(tree[i][t].F\u003d\u003dp.F)\n\t\t\tt++;\n\t\tf(j,t,tree[i].size())\n\t\t\tif(mark[tree[i][j].F] \u0026amp;\u0026amp; tree[i].size()\u003d\u003d4)\t\t\t\t// This means that tree[i][j].F is the parent in original tree\n\t\t\t\tfl\u003d1;\n\t\tif(fl)\t\t\t\t\t\t\t\t\t\t\t// Only has \n\t\t{\tf(j,0,tree[i].size())\n\t\t\t\tif(tree[i][j]!\u003dp \u0026amp;\u0026amp; !mark[tree[i][j].F])\n\t\t\t\t\tbinarise(tmp,tree[i][j].F,mp(i,tree[i][j].S),0);\n\t\t\t\telse if(mark[tree[i][j].F])\n\t\t\t\t\ttree[i][j]\u003dp;\n\t\t\treturn;\n\t\t}\n\t\t\tif(mark[tree[i][t].F])\n\t\t\t\tt++;\n\t\t\tbinarise(tmp,tree[i][t].F,mp(i,tree[i][t].S),0);\t\t\t\t//t represents the child which will stay the child of this node.\n\t\t\tf(j,0,tree[i].size())\n\t\t\t\tif(j\u003d\u003dt);\n\t\t\t\telse if(!mark[tree[i][j].F]\t\u0026amp;\u0026amp; tree[i][j].F!\u003dp.F)\n\t\t\t\t\ttmp.insert(tree[i][j]);\n\t\t\t\telse if(mark[tree[i][j].F])\t\t\t\t\t\t\t//Replace original parent with new parent\n\t\t\t\t\ttree[i][j]\u003dp;\n\t\t\tPII tm\u003dtree[i][t];\n\t\t\ttree[i].clear();\n\t\t\tif(i!\u003d1)\t\t\t\t\t\t\t\t\t\t\t// 1 is root. For all others, add parent.\n\t\t\t\ttree[i].pb(p);  \n\t\t\ttree[i].pb(tm);\t\t\t\t \n\t\t\ttree[i].pb(mp(tot++,0LL));\t\t\t\t\t\t\t\t// Add new extra node\n\t\t\tbinarise(tmp,tot-1,mp(i,0LL),1);\n\t}\n\telse\n\t\tf(j,0,tree[i].size())\n\t\t\tif(tree[i][j]!\u003dp \u0026amp;\u0026amp; !mark[tree[i][j].F])\n\t\t\t\tbinarise(tmp,tree[i][j].F,mp(i,tree[i][j].S),0);\n\t\t\telse if(mark[tree[i][j].F])\t\t\t\t\t\t\t//Replace original with new parent\n\t\t\t\ttree[i][j]\u003dp;\n}\n\nint main()\n{\n\tint n,q; LL a,b,c;\n\tcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q;\n\ttot\u003dn+1;\n\tf(i,1,n+1)\n\t\tsc(arr[i]);\n\tf(i,1,n)\n\t{\tscc(a,b,c);\n\t\ttree[a].pb(mp(b,c));\n\t\ttree[b].pb(mp(a,c));\n\t}\n\tunordered_map\u0026lt;int,LL\u0026gt; stmp;\n\tbinarise(stmp,1,mp(0,0LL),0);\n\tSET(mark,0);\n\tdec(1,NULL,0);\n\tf(i,1,n+1)\n\t{\n\t\tint p\u003darr[i];\n\t\twhile(p!\u003dcentroid)\t\t\t\t\t//push all nodes to be added in a stack\n\t\t{\tst.push(p);\t\n\t\t\tp\u003dpar[p];\n\t\t}\n\t\tpers[i]\u003dpersist(pers[i-1],arr[i],0);\n\t}\n\tLL an \u003d 0;\n\tf(i,1,q+1)\n\t{\tSc(a);\n\t\tSc(b);\n\t\tif(a\u003d\u003d1)\n\t\t{\tSc(c); Sc(a);\n\t\t  b \u003d b ^ an; c \u003d c ^ an; a \u003d a ^ an;\n\t\t\tint p\u003da;\n\t\t\tan\u003d0;\n\t\t\twhile(p!\u003dcentroid)\t\t\t\t//push all nodes to be queried in a stack\n\t\t\t{\tst.push(p);\n\t\t\t\tp\u003dpar[p];\n\t\t\t}\n\t\t\tan-\u003dquery(pers[b-1],a,0);\n\t\t\tp\u003da;\n\t\t\twhile(p!\u003dcentroid)\t\t\t\t//push all nodes to be queried in a stack\n\t\t\t{\tst.push(p);\n\t\t\t\tp\u003dpar[p];\n\t\t\t}\n\t\t\tan+\u003dquery(pers[c],a,0);\n\t\t\tprintf(\u0026quot;%lld\\n\u0026quot;,an);\n\t\t\tan %\u003d MOD;\n\t\t}\n\t\telse \n\t\t{   b \u003d b ^ an;\n\t\t    int p\u003darr[b],lca\u003dcentroid,h\u003dcentroid;\n\t\t\twhile(p!\u003dcentroid)\n\t\t\t{     anc[p]\u003di;\t\t\t\t\t\t\t\t//mark all ancestors of arr[b]\n\t\t\t\tp\u003dpar[p];\n\t\t\t}\n\t\t\tp\u003darr[b+1];\n\t\t\twhile(p!\u003dcentroid)\n\t\t\t{     if(anc[p]\u003d\u003di)\n\t\t\t\t{     lca\u003dp; break; }\n\t\t\t\th\u003dp;\t\t\t\t\t\t\t\t\t// h is the highest ancestor of arr[b+1] which is not an ancestor of arr[b]\n\t\t\t\tp\u003dpar[p];\n\t\t\t}\n\t\t\tnode *rt1\u003dpers[b], *rt2\u003dpers[b+1], *rt\u003dpers[b-1];\n\t\t\tint l\u003d0,k\u003d-1;\n\t\t\twhile(rt-\u0026gt;id!\u003dlca)\t\t\t\t\t\t\t//traverse down to lca in all 3 centroid trees.\n\t\t\t{     rt1-\u0026gt;sum -\u003d dis[l][arr[b]] - dis[l][arr[b+1]];\n\t\t\t\tif(l) \n\t\t\t\t\trt1-\u0026gt;psum -\u003d dis[l-1][arr[b]] - dis[l-1][arr[b+1]];\t\t\n\t\t\t\tl++;\n\t\t\t\tf(j,0,rt1-\u0026gt;len)\n\t\t\t\t\tif(anc[rt1-\u0026gt;child[j]-\u0026gt;id]\u003d\u003di)\n\t\t\t\t\t{     rt1\u003drt1-\u0026gt;child[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tf(j,0,rt2-\u0026gt;len)\n\t\t\t\t\tif(anc[rt2-\u0026gt;child[j]-\u0026gt;id]\u003d\u003di)\n\t\t\t\t\t{     rt2\u003drt2-\u0026gt;child[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tf(j,0,rt-\u0026gt;len)\n\t\t\t\t\tif(anc[rt-\u0026gt;child[j]-\u0026gt;id]\u003d\u003di)\n\t\t\t\t\t{     rt\u003drt-\u0026gt;child[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\trt1-\u0026gt;sum-\u003ddis[l][arr[b]]-dis[l][arr[b+1]];\t\t\t//update lca too\n\t\t\tif(l) \n\t\t\t\trt1-\u0026gt;psum-\u003ddis[l-1][arr[b]]-dis[l-1][arr[b+1]];\n\n/*\t This is the swapping part. \n *\t b1child represents the child containing arr[b], \n *\t b2child represents the child containing arr[b+1] and \n *\t bchild represents the child containing arr[b] in persistent centroid tree of first b-1 elements\n *\t The difference between b1child and bchild is that in b1child the ans due to arr[b] is considered, but it is not so in bchild. \n *\t Now we replace b1child with bchild and add b2child in pers[b], so that in pers[b], arr[b+1] is now active and not arr[b].\n *\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n\t\t\tnode *b1child\u003dNULL,*b2child\u003dNULL,*bchild\u003dNULL;\n\t\t\tf(j,0,rt-\u0026gt;len)\t\t\t\t\t\t\t//find bchild It may not exist if arr[b] \u003d lca\n\t\t\t\tif(anc[rt-\u0026gt;child[j]-\u0026gt;id]\u003d\u003di)\n\t\t\t\t\tbchild\u003drt-\u0026gt;child[j];\n\t\t\tf(j,0,rt1-\u0026gt;len)\n\t\t\t\tif(anc[rt1-\u0026gt;child[j]-\u0026gt;id]\u003d\u003di)\t\t\t\t//find b1child. It may not exist if arr[b] \u003d lca\n\t\t\t\t{     b1child\u003drt1-\u0026gt;child[j]; k\u003dj; }\n\t\t\tint vv\u003d0;\n\t\t\tif(b1child!\u003dNULL)\t\t\t\t\t\t\t// vv is used to handle the case where b1child \u003d NULL\n\t\t\t\tvv\u003db1child-\u0026gt;id;\n\t\t\tf(j,0,rt2-\u0026gt;len)\n\t\t\t\tif(rt2-\u0026gt;child[j]-\u0026gt;id\u003d\u003dh)\t\t\t\t//find b2child. It may not exist if arr[b+1] \u003d lca\n\t\t\t\t\tb2child\u003drt2-\u0026gt;child[j];\n\t\t\t\telse if(rt2-\u0026gt;child[j]-\u0026gt;id\u003d\u003dvv)\t\t\t\n\t\t\t\t\trt2-\u0026gt;child[j]\u003db1child;\n\t\t\tif(k\u0026gt;\u003d0)\t\t\t\t\t\t\t\t//Again, check if b1child exists.\n\t\t\t\trt1-\u0026gt;child[k]\u003dbchild;\n\t\t\tf(j,0,rt1-\u0026gt;len)\n\t\t\t\tif(rt1-\u0026gt;child[j]-\u0026gt;id\u003d\u003dh)\n\t\t\t\t\trt1-\u0026gt;child[j]\u003db2child;\n\t\t\tswap(arr[b],arr[b+1]);\n\t\t}\n\n\t}\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eHope you enjoyed the problemset! Any feedback is appreciated! :) \u003c/p\u003e\u003c/div\u003e","tags":["codecraft","round","391","editorial","div1 + div2","felicity"]}}