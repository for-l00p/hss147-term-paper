{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1512081114,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1513288862,"id":56094,"title":"\u003cp\u003eLambda-выражения\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eЛямбда-выражения появились в Java 8, причем не в качестве маленького дополнения, а в качестве инструмента, активно используемого в языке (в том числе в JavaFX — фреймворке, пришедшего на смену Swing). Конечно, следует сказать, что лямбда-выражения стоит рассматривать как существенное упрощение синтаксиса, но не как принципиальное новшество. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eЧасто говорят, что лямбда-выражения позволяют параметризовать поведение (behavior parametrization). Поясним, что имеется в виду.\u003c/p\u003e\u003cp\u003eВы уже неплохо знакомы со стандартными структурами данных и знаете, что эти струкуры параметризуются типами объектов, которые в них содержатся (\u003ccode\u003eTreeSet\u0026lt;Integer\u0026gt;\u003c/code\u003e или \u003ccode\u003eArrayList\u0026lt;Pair\u0026gt;\u003c/code\u003e, где \u003ccode\u003ePair\u003c/code\u003e — класс, содержащий, например, в качестве полей два целых числа). Также вам знакомо понятие компаратора, который позволяет использовать стандартный метод \u003ccode\u003eCollections.sort()\u003c/code\u003e или же передавать класс в качестве параметра в упорядоченную структуру. Технически компаратор может быть либо реализацией интерфейса \u003ccode\u003eComparable\u003c/code\u003e, либо реализацией интерфейса \u003ccode\u003eComparator\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eИнтерфейс \u003ccode\u003eComparator\u003c/code\u003e содержит метод \u003ccode\u003ecompare(T v1, T v2)\u003c/code\u003e, где \u003ccode\u003eT\u003c/code\u003e — тип (класс), который параметризует компаратор, а \u003ccode\u003ev1\u003c/code\u003e и \u003ccode\u003ev2\u003c/code\u003e — значения этого типа. Класс, реализующий этот интерфейс, может быть отделен от класса \u003ccode\u003eT\u003c/code\u003e, а объект этого класса может передаваться отдельно в метод сортировки или конструктор упорядоченной структуры (например, один из конструкторов класса \u003ccode\u003eTreeSet\u003c/code\u003e описан как \u003ccode\u003eTreeSet(Comparator\u0026lt;? super T\u0026gt; comparator)\u003c/code\u003e). Этот подход обеспечивает гибкость — можно создавать разные структуры данных, параметризованные одним и тем же типом \u003ccode\u003eT\u003c/code\u003e и при этом поддерживающие упорядоченность по разным критериям. \u003c/p\u003e\u003cp\u003eОднако \u0026quot;накладные расходы\u0026quot; при таком подходе будут не такими уж и маленькими. Действительно, нужно описать дополнительный класс, реализующий интерфейс \u003ccode\u003eComparator\u003c/code\u003e, создать объект этого класса, а затем передать этот объект в метод. При этом высока вероятность того, что описанный класс и созданный объект понадобятся единожды именно для передачи в этот метод. \u003c/p\u003e\u003cp\u003eВот как, к примеру, это может выглядеть. Пусть у нас есть некие объекты, характеризуемые тремя целочисленными параметрами (можете представлять себе, что это координаты в трёхмерном пространстве, или же придумать другую интерпретацию; мы назовём соответствующий класс довольно абстрактно — \u003ccode\u003eTriplet\u003c/code\u003e). Пусть у нас есть список \u003ccode\u003elst\u003c/code\u003e (\u003ccode\u003eArrayList\u0026lt;Triplet\u0026gt;\u003c/code\u003e), в котором эти объекты хранятся. И в разные моменты нам нужно по-разному упорядочивать этот список. Например, в некоторый момент нам требуется, чтобы список был упорядочен по убыванию величины первого параметра, а в случае одинаковых значений первого параметра — по возрастанию второго; третий же параметр никакой роли играть не должен. А спустя некоторое время возникает необходимость упорядочить этот список по возрастанию второго параметра, при равенстве вторых параметров — по возрастанию третьего параметра, а при равенстве и третьих параметров — по убыванию первого параметра. \u003c/p\u003e\u003cp\u003e\u0026quot;Классический\u0026quot; подход к решению этой задачи состоял в том, чтобы, во-первых, описать два класса, реализующие интерфейс \u003ccode\u003eComparator\u003c/code\u003e (по одному на каждый способ сортировки), затем создать объекты этих классов и передать их в качестве параметров в соответствующие вызовы метода \u003ccode\u003eCollections.sort()\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eПриведём фрагмент кода (предполагаем, что написать класс, содержащий метод \u003ccode\u003emain()\u003c/code\u003e, в котором создается объект демонстрационного класса и вызывается его метод \u003ccode\u003etest()\u003c/code\u003e, не составит труда для читателей ):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass DemoOldStyle {\n\t\n\tstatic class Triplet {\n\n\t    Triplet(int f, int s, int t) {\n\t        first \u003d f;\n\t        second \u003d s;\n\t        third \u003d t;\n\t    }\n\n\t    public String toString() {\n\t        return \u0026quot;[\u0026quot; + first + \u0026quot;, \u0026quot; + second +  \u0026quot;, \u0026quot; + third + \u0026quot;]\u0026quot;;\n\t    }\n\n\t    int first;\n\t    int second;\n\t    int third;\n\t \n\t}\n\n\tclass CmpX implements Comparator\u0026lt;Triplet\u0026gt; {\n\n\t    public int compare(Triplet t1, Triplet t2) {\n\t        if (t1.first \u0026gt; t2.first) return -1;\n\t        if (t1.first \u0026lt; t2.first) return 1;\n\t        return 0;\n\t    }\n\n\t}\n\n\tclass CmpY implements Comparator\u0026lt;Triplet\u0026gt; {\n\n\t    public int compare(Triplet t1, Triplet t2) {\n\t        if (t1.second \u0026lt; t2.second) return -1;\n\t        if (t1.second \u0026gt; t2.second) return 1;\n\t        if (t1.third \u0026lt; t2.third) return -1;\n\t        if (t1.third \u0026gt; t2.third) return 1;\n\t        if (t1.first \u0026gt; t2.first) return -1;\n\t        if (t1.first \u0026lt; t2.first) return 1;\n\t        return 0;\n\t    }\n\n\t}\n\n\t\n\tDemoOldStyle() {\n\t\tlst \u003d new ArrayList\u0026lt;\u0026gt;();\n\t\tlst.add(new Triplet(1, 2, 3));\n\t\tlst.add(new Triplet(3, 2, 1));\n\t\tlst.add(new Triplet(5, 1, 4));\n\t\tlst.add(new Triplet(4, 3, 2));\n\t\tlst.add(new Triplet(7, 4, 1));\n\t\tlst.add(new Triplet(1, 8, 5));\t\n\t\tlst.add(new Triplet(5, 4, 1));\n\t}\n\t\n\n\tvoid printlst() {\n\t\tfor (Triplet t: lst) {\n\t\t\tSystem.out.println(t);\n\t\t}\n\t}\n\t\n\tvoid test() {\n\t\tCmpX cx \u003d new CmpX();\n\t\tCollections.sort(lst, cx);\n\t\tSystem.out.println(\u0026quot;First comparator\u0026quot;);\n\t\tprintlst();\n\t\tCmpY cy \u003d new CmpY();\n\t\tCollections.sort(lst, cy);\n\t\tSystem.out.println(\u0026quot;Second comparator\u0026quot;);\n\t\tprintlst();\n\t}\n\t\n\t\n\tArrayList\u0026lt;Triplet\u0026gt; lst;\n\t\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДействительно, классы \u003ccode\u003eCmpX\u003c/code\u003e и \u003ccode\u003eCmpY\u003c/code\u003e, равно как и объекты этих классов, создаются для единственного обращения к методу сортировки. Вызов этого метода, конечно, можно переписать как \u003ccode\u003eCollections.sort(lst, new CmpX())\u003c/code\u003e, чтобы не создавать объект \u003ccode\u003ecx\u003c/code\u003e (и, аналогично, объект \u003ccode\u003ecy\u003c/code\u003e), но это не очень сильно уменьшает объём кода (и не избавляет нас от \u0026quot;лишних сущностей\u0026quot;). Чтобы эти \u0026quot;лишние сущности\u0026quot; не плодить, в Java можно использовать так называемые анонимные классы. Запись в этом случае также не слишком укорачивается, но компараторы создаются ровно в том месте, где они необходимы (т.е. соблюдается принцип локальности). Метод \u003ccode\u003etest()\u003c/code\u003e можно дополнить следующими строками:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e                System.out.println(\u0026quot;Yet another first comparator\u0026quot;);\n\t\tCollections.sort(lst, new Comparator\u0026lt;Triplet\u0026gt;() {\n\t\t\tpublic int compare(Triplet t1, Triplet t2) {\n\t\t            if (t1.first \u0026gt; t2.first) return -1;\n \t\t            if (t1.first \u0026lt; t2.first) return 1;\n\t\t            return 0;\n\t\t\t}\n\t\t});\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ этом случае нам не потребуется описывать и класс \u003ccode\u003eCmpX\u003c/code\u003e (аналогично для \u003ccode\u003eCmpY\u003c/code\u003e). Однако это всё равно достаточно объёмный код, многое в котором в принципе \u0026quot;очевидно\u0026quot; для компилятора. Например, поскольку \u003ccode\u003elst\u003c/code\u003e хранит объекты класса \u003ccode\u003eTriplet\u003c/code\u003e, логично предположить, что компаратор будет сравнивать именно эти объекты. Далее, в интерфейсе \u003ccode\u003eComparator\u003c/code\u003e заявлен ровно один метод — \u003ccode\u003ecompare()\u003c/code\u003e, и опять же логично предположить, что нам необходимо реализовать именно этот метод. И разработчики Java (а Java написана на Java) в версии 1.8 дали возможность разработчикам на Java записывать такие конструкции более экономно. Приведём также небольшой фрагмент, которым можно дополнить метод \u003ccode\u003etest()\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\t\tSystem.out.println(\u0026quot;Yet another second comparator\u0026quot;);\n\t\tCollections.sort(lst, (t1, t2) -\u0026gt; {\n\t            if (t1.first \u0026gt; t2.first) return -1;\n \t            if (t1.first \u0026lt; t2.first) return 1;\n\t            return 0;\t\t\t\n\t\t});\n\t\tprintlst();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗаметим, что если бы нам было нужно отсортировать список только по одному значению, то запись была бы еще короче: достаточно было бы воспользоваться соответствующим методом класса Integer. Например, вот так можно было бы отсортировать список по невозрастанию значений поля \u003ccode\u003ethird\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\t\tSystem.out.println(\u0026quot;Sort by third parameter\u0026quot;);\n\t\tCollections.sort(lst, (t1, t2) -\u0026gt; -Integer.compare(t1.third, t2.third);\n\t\tprintlst();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВскоре мы обсудим и другие примеры, и другие способы записи лямбда-выражений. Пока же следует сказать, что мы фактически передаем в метод сортировки функцию, определяющую способ сравнения двух элементов. Именно это и является параметризацией поведения: мы вызываем метод \u003ccode\u003esort()\u003c/code\u003e, чтобы отсортировать список, и именно в вызове метода указываем, как именно его следует отсортировать.\u003c/p\u003e\u003cp\u003eТакже сделаем некоторые (промежуточные) наблюдения.\u003c/p\u003e\u003cp\u003eУпрощённый синтаксис, использованный выше, на самом деле ничего не меняет в смысле \u0026quot;однозначности\u0026quot;. Действительно, мы планируем отсортировать список, который уже параметризован классом \u003ccode\u003eTriplet\u003c/code\u003e, поэтому совершенно логично предположить, что нам нужно описать метод сравнения именно объектов этого класса. Таким образом, информация о типе сравниваемых элементов (которая оставалась ещё в анонимном классе), избыточна. \u003c/p\u003e\u003cp\u003eВторой важный момент заключается в том, что интерфейс \u003ccode\u003eComparator\u003c/code\u003e имеет единственный метод (\u003ccode\u003ecompare\u003c/code\u003e). Поэтому указание, что реализуется именно этот метод, также избыточно. Если бы мы имели дело с интерфейсом, в котором было бы описано несколько методов, то обеспечить однозначность было бы проблематично. А в случае одного метода такой проблемы не возникает. Примерно из подобных соображений (наверное) в Java 8 и появилась концепция \u003cem\u003eфункционального интерфейса\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eТак что запись лямбда-выражения в некотором смысле есть сокращение записи анонимного класса без потери однозначности этой записи. \u003c/p\u003e\u003cp\u003eВ общем виде лямбда-выражение может быть записано так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e(параметры лямбда-выражения) -\u0026gt; {оператор(ы)}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eили\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e(параметры лямбда-выражения) -\u0026gt; выражение;\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбратите внимание, что операторы должны быть обязательно заключены в фигурные скобки. Как раз пример с сортировкой по двум параметрам соответствует первому варианту синтаксиса, а пример с сортировкой по одному параметру — второму варианту.\u003c/p\u003e\u003cp\u003eЧто же касается функциональных интерфейсов — это интерфейсы, имеющие ровно один абстрактный метод. Уточнение про абстрактный метод важно, поскольку интерфейсы могут содержать в себе статические методы, имеющие реализацию (а также статические поля; конечно, это нарушает чистоту концепции интерфейсов, но иногда оказывается весьма полезным).\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Когда вы создавали проекты с графическим интерфейсом, вам неоднократно приходилось иметь дело с событиями и их обработчиками (а также лямбда-выражениями, которые воспринимались на уровне небольшого шаманства). Например, требовалось, чтобы при нажатии на кнопку выполнялось некоторое действие. \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e В Swing (до появления лямбда-выражений) нужно было действовать так. В классе кнопки (более, точно, в наиболее общем \u0026quot;оконном\u0026quot; классе, наследником которого является кнопка) существует метод, позволяющий добавить так называемого слушателя события. Слушатель события — это тоже класс, реализующий некоторый интерфейс слушателя (каждому типу событий соответствовал свой интерфейс слушателя; так, был интерфейс слушателя событий клавиатуры, два интерфейса слушателя событий мыши и т.д.). \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Как вы, наверное, помните, интерфейс — это набор заголовков методов без реализации (да, там могут быть статические методы, константы, но сейчас это несущественные детали). Если некоторый класс заявлен как реализующий некоторый интерфейс, это значит, что класс должен реализовать все объявленные в интерфейсе методы. Однако поскольку в интерфейсах присутствовало по нескольку методов, это создавало программистам ряд неудобств. Например, в одном из интерфейсов слушателя мыши содержатся методы нажатия на клавишу мыши, отпускания клавиши мыши, щелчка по клавише мыши (нажатие + отпускание), а также методы, описывающие реакцию на вход курсора в заданную область и выход курсора из заданной области. Чаще всего программисту нужно было отследить одно-два события из набора, что приводило к формальной реализации не нужных в данный момент методов. Создатели Java, предвидя это, предложили заготовленные абстрактные классы, реализующие интерфейсы слушателей, чтобы программист мог просто унаследовать свой класс от такого абстрактного. \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Получалось, что нужно было определить свой класс (либо самостоятельно реализующий необходимый интерфейс слушателя, либо наследник класса, который реализует этот интерфейс), создать объект этого класса и передать его в качестве параметра методу, добавляющему слушателя к графическому компоненту. Конечно, такой подход обеспечивал большую гибкость: компоненты были слабо связаны с событиями и в любой момент можно было изменить их реакцию на то или иное событие или даже \u0026quot;научить\u0026quot; их реагировать на совершенно другой тип событий. Но ценой этой гибкости было большое количество однотипного кода. \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Если единственное, что вам стало понятно из предыдущих трёх абзацев, это то, что связывание события с компонентом было весьма непростым делом, требующим написания достаточно немаленького объёма кода, вы совершенно правы. Изучать сейчас детально описанный выше процесс в наши планы совершенно не входит, достаточно понимать, что разработчики хотели получить инструмент, который сделал бы этот процесс (и результат в виде кода) более простым. Разумеется, разработка приложений с графическим интерфейсом не единственная область, где лямбда-выражения позволяют существенно упростить код, и они находят свое применение в самых разных ситуациях. \u003c/small\u003e\u003c/p\u003e\u003c/div\u003e","tags":["java","lambda"]}}