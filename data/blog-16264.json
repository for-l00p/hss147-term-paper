{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1423385476,"rating":16,"authorHandle":"Ahmed_Salama","modificationTimeSeconds":1423593710,"id":16264,"title":"\u003cp\u003eRound 3 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eQuantization Problem:\u003c/h2\u003e\u003cp\u003eThis is a direct DP problem. The state of the DP should be DP(idx, level), where idx is the number of values we have already quantized (at this step we should quantize the value at index idx) and level is the index of the level set from which we should choose the quantization level for the value at index idx. As stated in the problem, the first value will be quantized from the level set 0. We will always need to loop on the levels in the current level set to try all levels and choose the best one minimizing the quantization deviation. Finally, we need to do answer reconstruction after the DP step, which is straightforward as shown in the code.\u003c/p\u003e\u003ch4\u003eCode: \u003ca href\u003d\"http://ideone.com/80DkZW\"\u003ehttp://ideone.com/80DkZW\u003c/a\u003e\u003c/h4\u003e\u003ch2\u003eLittle Brackets:\u003c/h2\u003e\u003cp\u003eThis problem is a direct DP problem where you keep track of the number of open brackets and the depth so far as well as a boolean of whether you acheived a depth of k already or not. The only thing is to notice that the answer doesn\u0027t fit in a 64 bit integer so you have to use BigInteger. The complexity is O(n*k).\u003c/p\u003e\u003ch4\u003eCode: \u003ca href\u003d\"http://ideone.com/NThbEb\"\u003ehttp://ideone.com/NThbEb\u003c/a\u003e\u003c/h4\u003e\u003ch2\u003ePolice Cities:\u003c/h2\u003e\u003cp\u003eThis problem can be solved in two steps: 1. After reading the problem, one should observe that the first step to be done is transforming the given graph into a SCC DAG. We should do this as it will give us an intuition about satisfying the stated conditions. After getting the SCC DAG, we can see that each SCC can be treated as a separate node now,\u003cbr /\u003ebecause all nodes in the SCC are strongly connected, so satisfying the conditions on one city will make them satisfied on all the cities in the component. 2. Now the problem is reduced to a very simple counting DP problem (with BigInteger), where the state is the index of the component in the SCC DAG you are currently assigning police stations to, and the number of remaining stations to assign. It should be noted that when we assign x stations to a component, we will have comb[sizeOfComponent][x] options for assigning these x stations to any node in the component. This can be done easily by calculating comb array before the DP. There is only one case where you have to assign at least one police station to the the SCC (node), this is when either the number of in-edges to this component or the number of out-edges from this component is zero. The previous constraint can be seen easily from the conditions. \u003c/p\u003e\u003ch4\u003eCode: \u003ca href\u003d\"http://ideone.com/10304Y\"\u003ehttp://ideone.com/10304Y\u003c/a\u003e\u003c/h4\u003e\u003ch2\u003eThe Smart Bomb:\u003c/h2\u003e\u003cp\u003eSince the theree points don\u0027t lie on one straight line, then we can form a triangle with the 3 points as vertices. The best total distance you can get is basically the sum of the 3 sides of the triangle. To achieve that, you basically need to solve three equations in 3 unknowns: x + y \u003d s1 y + z \u003d s2 x + z \u003d s3 Where s1, s2 and s3 are the 3 sides.\u003c/p\u003e\u003ch4\u003eCode: \u003ca href\u003d\"http://ideone.com/eQ3RGT\"\u003ehttp://ideone.com/eQ3RGT\u003c/a\u003e\u003c/h4\u003e\u003ch2\u003eBeer Problem:\u003c/h2\u003e\u003cp\u003eA Min cost maxflow problem. We create a supersink connect each city to this supersink by an edge, a unit of flow on this edge represents the sale of a single beer in this city, thus it\u0027s capacity is equal to infinity as we can always sell infinite amounts of beer in each city, it\u0027s cost is -ve price of beer in this city. Now running mincost maxflow gives us minimum(Transportation costs â€” Sell price), which is the same as maximum(Sell price-transportation costs) (maximum profit)\u003c/p\u003e\u003cp\u003eYou might think that adding such edges create negative weight cycles, however this is wrong since in the initial configuration those edges go only into the supersink (none going out of it), thus there\u0027s no negative weight cycles. Please consult topcoder mcmf tutorial to udnerstand more about the effect of negative weight edges in mcmf network and how a network with negative edges can be converted into one without negative edges (little linear programming knowledge may be useful)\u003c/p\u003e\u003ch4\u003eCode: \u003ca href\u003d\"http://pastebin.com/LvwT1Pg7\"\u003ehttp://pastebin.com/LvwT1Pg7\u003c/a\u003e\u003c/h4\u003e\u003ch2\u003eInteger Numbers:\u003c/h2\u003e\u003cp\u003eWe want to know, which of the \u0026quot;infinite\u0026quot; consecutive sequences (123xxx, 234xxx, 345xxx, 456xxx, ..) are reachable with the least changes possible. So, we can say that each number in the given sequence, contributes to (don\u0027t need a change with) one of the possible consecutive sequences. That being said what we will do is to calculate which of them gets the maximum contributions, and this one will be the one needing the least number of changes.\u003c/p\u003e\u003ch4\u003eCode: \u003ca href\u003d\"http://ideone.com/ZLbSMA\"\u003ehttp://ideone.com/ZLbSMA\u003c/a\u003e\u003c/h4\u003e\u003ch2\u003eExpress Trains:\u003c/h2\u003e\u003cp\u003eWe want to find a pair of disjoint paths that connect A to B and C to D, notice that the given graph is a dag and this has a the key to the solution We implement a dynamic programming solution where the state is the last node in the first path and the last node in the second path (X, Y) Now given that state how do we form disjoint paths ? we can always move form X to a new node Z or move from Y to a new node Z. The key idea to prevent path intersection is to always move from the smaller node so if X \u0026lt; Y we must move from X else we must move from Y, if we did this we prevent any path intersection. WHY ? Assume we did intersect so we were at (X, Y) then (X, K) then (X, Z) and then (K, Z), this indeed contradicts with our assumption that we moved from smaller node! Now using this key idea we can easily create the dynamic programming solution given below\u003c/p\u003e\u003cp\u003eThe rest of solution details is of course left as an exercise ! :D\u003c/p\u003e\u003ch4\u003eCode: \u003ca href\u003d\"http://pastebin.com/X0RAMK67\"\u003ehttp://pastebin.com/X0RAMK67\u003c/a\u003e\u003c/h4\u003e\u003ch2\u003eNonequal Parts:\u003c/h2\u003e\u003cp\u003eGrundy numbers problem, Let the initial number of stones be S for each move we want to try all possible non equal partitions of S and then XOR their grundies together and then find the minimum grundy value that doesn\u0027t exist in those that would be grundy(S)\u003c/p\u003e\u003cp\u003egrundy(S) \u003d maximum element not in set { grundy(a0, a1, a2, .. an), grundy (b0, b1, .. bn) ...} where a0, a1, .. an is a partition of S into non equal parts. now how do we calculate this, we use dynamic programming let dp[i][s] be a set of grundy values we can reach to after making a move given that S\u003ds and the maximum value we can cut while partitioning is i.\u003c/p\u003e\u003cp\u003eif we compute such an array (dp) we can easily tell if the answer is win or lose.\u003c/p\u003e\u003cp\u003eFor the construction of the sets element X exists in dp[i][s] if and only if element X^grundy(i) exists dp[i-1][s-i] or X exists in dp[i-1][s]\u003c/p\u003e\u003cp\u003eConsult the implementation for more details, the set is implemented as a boolean array in the implementation.\u003c/p\u003e\u003ch4\u003eCode: \u003ca href\u003d\"http://pastebin.com/W5Bv75iG\"\u003ehttp://pastebin.com/W5Bv75iG\u003c/a\u003e\u003c/h4\u003e\u003ch2\u003ePrimitive Product:\u003c/h2\u003e\u003cp\u003eThis is a simple factorization problem. We factorize the input number n and then try to place a number of negatives so that it * matches the sign of the input n. This means that if n is negative, we need to have a odd number of negatives and on the other hand if the number is even we will * need an even number of negatives (including 0 negatives). This should be done through simple DFS. The last part is just sorting the results to fit the output format.\u003c/p\u003e\u003ch4\u003eCode: \u003ca href\u003d\"http://pastebin.com/0bvFXRd2\"\u003ehttp://pastebin.com/0bvFXRd2\u003c/a\u003e\u003c/h4\u003e\u003ch2\u003eTrip Expenses:\u003c/h2\u003e\u003cp\u003eTo compute all pair shortest paths, we use Floyd-Warshall algorithm running in O(n^3). After this to compute the number of segments we need between each of pair of cities, we can run a simple BFS from each node and accumulate the number of edges needed in our result. Note that we computed the segments between A-B and B-A twice, so we divide the accumulative value by 2. To compute the average, we divide this by the total number of journeys possible which is (n * (n-1)) / 2.\u003c/p\u003e\u003ch4\u003eCode: \u003ca href\u003d\"http://pastebin.com/W39rxR57\"\u003ehttp://pastebin.com/W39rxR57\u003c/a\u003e\u003c/h4\u003e\u003ch2\u003eHard Test:\u003c/h2\u003e\u003cp\u003eYou have to construct a graph which will produce the most number of relaxations upon using dijktsra algorithm. Starting with node 1, we start adding edges to the whole remaining nodes with costs 0,1,2,...,etc. To allow more relaxations, we add from node 2 (which is reachable by cost 0 right now) edges to the whole remaining nodes with costs 0,1,...,etc so that we enforce them to get relaxed right now, and so on.\u003c/p\u003e\u003ch4\u003eCode: \u003ca href\u003d\"http://pastebin.com/Sf1c1Qec\"\u003ehttp://pastebin.com/Sf1c1Qec\u003c/a\u003e\u003c/h4\u003e\u003ch2\u003eAvoiding Partitions:\u003c/h2\u003e\u003cp\u003eFirst we break the problem to multiple parts.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e+ Given N, calculate the number of ways to partition them (Given the mentioned definition):\u003c/strong\u003e We can do this part with DP[Number of partitions so far(P)][Remaining numbers(Rem)] and for the next number, we either chose to put it in an already created partition (This is done in P ways) and transition to DP[P][Rem â€” 1] or create a new partition and transition to DP[P + 1][Rem â€” 1].\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e+ Avoid having any of the Q listed sets:\u003c/strong\u003e We want to eliminate of all the ways to partition S the ways that have at least one of the Qs as subset of its partition. If we wanted to modify the mentioned DP to avoid the Qs, the state would have grown too much to store enough information needed. So instead, we will go for subtracting the wrong ways that include them (since as we said, calculating those who \u0026quot;exclude\u0026quot; the Qs are hard). for that (and because the number of Qs is very limited, \u0026lt;\u003d 10) we will use the inclusion exclusion principle. \u003c/p\u003e\u003cp\u003eThe final problem to solve here, is when the inclusion exclusion step takes place, the problem is as following: \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e+ Given N and list of Qs to \u0026quot;include\u0026quot;, what is the number of ways to partition them:\u003c/strong\u003e So we will start with some observations, 1) Let\u0027s say we want to include {1,2} and {2,3}. This means, that our partitions should have 1, 2 together, and at the same time, 2, 3 together as well, this means that 1, 2, 3 must exist in the same partition. 2) After merging the intersecting Qs together, now, we can treat each Q as an element originally belonged to the set S and use the first mentioned DP to solve the problem.\u003c/p\u003e\u003ch4\u003eCode: \u003ca href\u003d\"http://ideone.com/xGzBRv\"\u003ehttp://ideone.com/xGzBRv\u003c/a\u003e\u003c/h4\u003e\u003ch2\u003eSpending Budget:\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eWill be added later.\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e","tags":["round3"]}}