{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1416505264,"rating":0,"authorHandle":"PrashantM","modificationTimeSeconds":1416505416,"id":14778,"title":"\u003cp\u003eSSN Coding Contest — 3 (Editorial)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA — Calculating Function (\u003ca href\u003d\"//codeforces.com/problemset/problem/486/A\"\u003ehttp://codeforces.com/problemset/problem/486/A\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eif n is even, print n/2 else n/2 — n\u003c/p\u003e\u003cp\u003eB — Presents (\u003ca href\u003d\"//codeforces.com/problemset/problem/136/A\"\u003ehttp://codeforces.com/problemset/problem/136/A\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eConsider accepting array \u0027a\u0027. Have another array b. for i \u003d 1 to n, b[a[i]] \u003d i; print b\u003c/p\u003e\u003cp\u003eC — Little Pony and Crystal Mine (\u003ca href\u003d\"//codeforces.com/problemset/problem/454/A\"\u003ehttp://codeforces.com/problemset/problem/454/A\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eJust implement the pattern in your way\u003c/p\u003e\u003cp\u003eD — Archer (\u003ca href\u003d\"//codeforces.com/problemset/problem/312/B\"\u003ehttp://codeforces.com/problemset/problem/312/B\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eProbability that SmallR will win :\u003c/p\u003e\u003cp\u003efirst try : a/b\u003c/p\u003e\u003cp\u003esecond try: a/b*(1-c/d)*(1-a/b)\u003c/p\u003e\u003cp\u003ethird try : a/b*(1-c/d)*(1-a/b)*(1-c/d)*(1-a/b)\u003c/p\u003e\u003cp\u003e. . . Infinite series, common difference (1 — c/d)(1 — a/b)\u003c/p\u003e\u003cp\u003eUse G.P Formula.\u003c/p\u003e\u003cp\u003eFinal formula: a*d/(a*d + b*c — a*c)\u003c/p\u003e\u003cp\u003eE — Kuriyama Mirai\u0027s Stones (\u003ca href\u003d\"//codeforces.com/problemset/problem/433/B\"\u003ehttp://codeforces.com/problemset/problem/433/B\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eBasically answering queries of type: sum of elements from l to r from 2 different arrays: sorted an unsorted. First have the sorted array separately.\u003c/p\u003e\u003cp\u003eNow maintain prefix sums for both.\u003c/p\u003e\u003cp\u003eGeneral idea of prefix sums:\u003c/p\u003e\u003cp\u003eFor an array \u0027a\u0027, let \u0027prefix\u0027 be prefix sums of the array.\u003c/p\u003e\u003cp\u003eprefix[i] stores a[0] + a[1] + a[2] .... a[i]\u003c/p\u003e\u003cp\u003eTo calculate prefix array efficiently we use the fact that prefix[i] \u003d prefix[i — 1] + a[i].\u003c/p\u003e\u003cp\u003eNow the sum of elements from l to r is nothing but a[l] + a[l + 1] + .... a[r].\u003c/p\u003e\u003cp\u003eThis is just prefix[r] — prefix[l — 1]. \u003c/p\u003e\u003cp\u003eHence by maintaining prefix sums arrays for both sorted and unsorted, the queries can be answered without any loops, in constant time.\u003c/p\u003e\u003c/div\u003e","tags":[]}}