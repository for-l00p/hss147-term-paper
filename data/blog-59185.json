{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1525097667,"rating":37,"authorHandle":"I_love_myself","modificationTimeSeconds":1526566912,"id":59185,"title":"\u003cp\u003eЗадачи на подсчет количества элементов, меньших K\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eВсем привет, сегодня я расскажу решения часто встречающихся \u003cstrong\u003eзадач на подсчет количества элементов, меньших k\u003c/strong\u003e, и разные способы их решения. Перед прочтением рекомендую ознакомится с предыдущим \u003ca href\u003d\"//codeforces.com/blog/entry/59214\"\u003eпостом\u003c/a\u003e, в котором были разобраны некоторые подзадачи. \u003cbr /\u003e \u003cbr /\u003e \u003cstrong\u003eЗадача 1.\u003c/strong\u003e Подсчитать количество элементов, меньших k на всём массиве с возможностью добавления и удаления элемента. \u003cbr /\u003e \u003cstrong\u003eРешение в онлайн:\u003c/strong\u003e простым способом является написание ДД по ключу, в котором нужно просто подсчитывать размер поддерева. \u003cbr /\u003e \u003cem\u003eСложность:\u003c/em\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e на любой запрос, но средняя константа за счёт ДД. \u003cbr /\u003e\u003cbr /\u003e \u003cstrong\u003eРешение в оффлайн:\u003c/strong\u003e Прочитаем все запросы и запомним все значения и отсортируем их. Построим Фенвика, изначально заполненного нулями. Если появляется запрос на добавление, то добавляем 1 в позицию с этим элементом; удаление — отнимем; количество элементов, меньших k — сумма на префиксе. \u003cbr /\u003e \u003cem\u003eСложность:\u003c/em\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e с очень маленькой константой. В целом, пишется быстрее и короче чем ДД. Аналогично можно решать множество дальнейших задач в оффлайн и уменьшать константу. \u003cbr /\u003e Спасибо \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Kaban-5\" title\u003d\"Международный гроссмейстер Kaban-5\"\u003eKaban-5\u003c/a\u003e за идею.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача 2.\u003c/strong\u003e Подсчитать для каждого элемента массива количество элементов, не больших него самого \u003cstrong\u003eна префиксе в оффлайн\u003c/strong\u003e. \u003cbr /\u003e Давайте отсортируем все элементы по паре \u0026lt;a[i], i\u0026gt;. Пусть у нас есть Дерево Фенвика (или дерево отрезков) на n элементов, изначально заполненное нулями. Теперь будем по отсортированному порядку ставить 1 в текущую позицию и считать сумму на префиксе — это и будет количество элементов, меньших текущего значения. \u003cbr /\u003e \u003cem\u003eСложность:\u003c/em\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e с очень маленькой константой. \u003cbr /\u003e Спасибо \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Holidin\" title\u003d\"Кандидат в мастера Holidin\"\u003eHolidin\u003c/a\u003e за интересную идею.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача 3.\u003c/strong\u003e Усложним предыдущую задачу: будем отвечать на запросы вида количество элементов, меньших K на отрезке [L; R]. \u003cbr /\u003e \u003cstrong\u003eРешение в оффлайн:\u003c/strong\u003e будем действовать аналогично предыдущей задаче. Заведем Дерево Фенвика на n элементов, заполненное нулями. Пусть у нас есть 2 типа событий: 1) написать 1 в некоторую позицию, 2) посчитать кол-во элементов, не больше K на отрезке [L; R]. Тогда отсортируем события по значению(a[i] или k соответственно), а потом по позиции(i или +INF соответственно: если событие второго типа, то важно, чтобы оно выполнилось после событий первого типа). Итак, теперь ответим на все запросы. Пройдемся по отсортированным событиям и если оно первого типа, то поставим 1 в нужную позицию, а если второго, то посчитаем сумму на отрезке [L; R] нашим Фенвиком. \u003cbr /\u003e \u003cem\u003eСложность:\u003c/em\u003e Пусть \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e \u003d \u003ci\u003en\u003c/i\u003e + \u003ci\u003eq\u003c/i\u003e\u003c/span\u003e, тогда асимптотика \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e9/82/e9824f6612c4b83669d669fe6fd4d9e558305dfd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e с опять же очень маленькой константой за счёт Фенвика.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eРешение в онлайн:\u003c/strong\u003e отсортируем массив и построим MergeSortTree по индексам в отсортированном массиве. Пусть нам пришел запрос посчитать количество элементов, меньших K на отрезке [L; R]. Это эквивалентно подсчету количества индексов в отосртированном массиве на префиксе до элемента pos, у которых индексы находятся в [L; R] (pos — индекс первого элемента, большего K в отсортированном массиве). Двоичными спусками найдем эту границу pos, параллельно считая ответ в поддереве — это будет разность lower_bound\u0027ов по r и l в левом поддереве, если мы переходим в правое. Теперь применим технику fractional cascading. \u003cbr /\u003e Получили сложность \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e на запрос.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача 4.\u003c/strong\u003e Нужно уметь выполнять операции 2 типов: \u003cbr /\u003e - Посчитать количество элементов, меньших K на отрезке [L; R] \u003cbr /\u003e - Изменять любой элемент массива \u003cbr /\u003e Построим дерево отрезков, в вершине которого будем хранить ДД по ключу с возможностью подсчета количества элементов, меньших K(ровно так же как в 1 задаче). Тогда отвечать на запросы обоих типов становится очень просто, и это сделает любой человек, который хоть раз писал ДО с суммой на отрезке и обновлением в точке. \u003cbr /\u003e \u003cem\u003eСложность:\u003c/em\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/74/10/7410a69421c6ee91a5842650f56f6dd28c3fad9a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e на запрос с приличной константой.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача 5.\u003c/strong\u003e Давайте ещё больше усложним задачу 3. Теперь есть 3 типа запросов: \u003cbr /\u003e 1. Удалить элемент на позиции pos \u003cbr /\u003e 2. Добавить элемент на позицию pos \u003cbr /\u003e 3. Посчитать количество элементов, меньших X на отрезке [L; R] \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eРешение в онлайн:\u003c/strong\u003e Давайте применим магию корневой декомпозиции. Разобьем массив на блоки по корню и в каждом блоке будем дополнительно хранить ДД по ключу для подсчетка количества элементов, меньших X. \u003cbr /\u003e \u003cem\u003eСложность:\u003c/em\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a7/7e/a77efd95a73cb130a1d22f00a90e2bb7e95e6e2d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e на запрос. \u003cbr /\u003e Я просто оставлю это здесь(здесь тонна оптимизаций, но всё равно при n, q \u0026lt;\u003d 1e+5 не проходит на серверах яндекса):\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eкод\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#pragma GCC target(\u0026quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\u0026quot;)\n#pragma GCC optimize(\u0026quot;O3\u0026quot;)\n#pragma GCC optimize(\u0026quot;unroll-loops\u0026quot;)\n\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n#include \u0026lt;list\u0026gt;\n\nusing namespace std;\n\nconst int MAXMEM \u003d 1e+8;\nint mpos \u003d 0;\nchar mem[MAXMEM];\ninline void *operator new(size_t n)\n{\n\tchar *res \u003d mem + mpos;\n\tmpos +\u003d n;\n\treturn (void *)res;\n}\ninline void operator delete(void *) {}\n\nconst int BLOCK_SIZE \u003d 500;\n\nstruct Node {\n\tint x, y;\n\tint cnt;\n\tint size;\n\n\tNode *l, *r;\n\tNode(int x) : x(x), y(rand()), cnt(1), size(1), l(0), r(0) {}\n};\n\nint sz(Node *v)\n{\n\treturn v \u003d\u003d 0 ? 0 : v-\u0026gt;size;\n}\n\nvoid upd(Node *v)\n{\n\tv-\u0026gt;size \u003d sz(v-\u0026gt;l) + v-\u0026gt;cnt + sz(v-\u0026gt;r);\n}\n\npair\u0026lt;Node *, Node *\u0026gt; split(Node *v, int k)\n{\n\tif (v \u003d\u003d 0)\n\t\treturn { 0 , 0 };\n\n\tif (v-\u0026gt;x \u0026lt; k) {\n\t\tauto t \u003d split(v-\u0026gt;r, k);\n\t\tv-\u0026gt;r \u003d t.first;\n\t\tupd(v);\n\t\treturn { v, t.second };\n\t}\n\telse {\n\t\tauto t \u003d split(v-\u0026gt;l, k);\n\t\tv-\u0026gt;l \u003d t.second;\n\t\tupd(v);\n\t\treturn { t.first, v };\n\t}\n}\n\nNode *merge(Node *a, Node *b)\n{\n\tif (a \u003d\u003d 0)\n\t\treturn b;\n\tif (b \u003d\u003d 0)\n\t\treturn a;\n\n\tif (a-\u0026gt;y \u0026lt; b-\u0026gt;y) {\n\t\ta-\u0026gt;r \u003d merge(a-\u0026gt;r, b);\n\t\tupd(a);\n\t\treturn a;\n\t}\n\telse {\n\t\tb-\u0026gt;l \u003d merge(a, b-\u0026gt;l);\n\t\tupd(b);\n\t\treturn b;\n\t}\n}\n\nNode *insert(Node *v, int x)\n{\n\tauto a \u003d split(v, x);\n\tauto b \u003d split(a.second, x + 1);\n\n\tif (b.first \u003d\u003d 0)\n\t\treturn merge(a.first, merge(new Node(x), b.second));\n\telse {\n\t\tb.first-\u0026gt;cnt++;\n\t\tb.first-\u0026gt;size++;\n\t\treturn merge(a.first, merge(b.first, b.second));\n\t}\n}\n\nNode *erase(Node *v, int x)\n{\n\tauto a \u003d split(v, x);\n\tauto b \u003d split(a.second, x + 1);\n\n\tif (b.first-\u0026gt;cnt \u003d\u003d 1)\n\t\treturn merge(a.first, b.second);\n\telse {\n\t\tb.first-\u0026gt;cnt--;\n\t\tb.first-\u0026gt;size--;\n\t\treturn merge(a.first, merge(b.first, b.second));\n\t}\n}\n\ninline int cnt_low_k(Node *\u0026amp;v, int k)\n{\n\tauto a \u003d split(v, k + 1);\n\tint ans \u003d sz(a.first);\n\tv \u003d merge(a.first, a.second);\n\treturn ans;\n}\n\nstruct Bucket {\n\tNode *v \u003d 0;\n\tlist\u0026lt;int\u0026gt; a;\n};\n\nlist\u0026lt;Bucket\u0026gt; a;\n\ninline void relax(list\u0026lt;Bucket\u0026gt;::iterator block)\n{\n\tif (block-\u0026gt;a.size() \u003d\u003d 2 * BLOCK_SIZE) {\n\t\tauto last_block \u003d a.insert(block, Bucket());\n\t\tauto pos \u003d block-\u0026gt;a.begin();\n\n\t\tfor (int i \u003d 0; i \u0026lt; BLOCK_SIZE; i++) {\n\t\t\tlast_block-\u0026gt;a.insert(last_block-\u0026gt;a.end(), *pos);\n\t\t\tlast_block-\u0026gt;v \u003d insert(last_block-\u0026gt;v, *pos);\n\t\t\tblock-\u0026gt;v \u003d erase(block-\u0026gt;v, *pos);\n\t\t\tpos \u003d block-\u0026gt;a.erase(pos);\n\t\t}\n\t}\n\telse if (block-\u0026gt;a.size() \u003d\u003d 0) {\n\t\tif (a.size() \u0026gt; 1)\n\t\t\ta.erase(block);\n\t}\n}\n\ninline void insert_elem(int pos, int x)\n{\n\tauto block \u003d a.begin();\n\tint k \u003d 0;\n\n\twhile (k + block-\u0026gt;a.size() \u0026lt; pos) {\n\t\tk +\u003d block-\u0026gt;a.size();\n\t\tblock++;\n\t}\n\n\tauto pos_block \u003d block-\u0026gt;a.begin();\n\tfor (int i \u003d k; i \u0026lt; pos; i++)\n\t\tpos_block++;\n\n\tblock-\u0026gt;a.insert(pos_block, x);\n\tblock-\u0026gt;v \u003d insert(block-\u0026gt;v, x);\n\n\trelax(block);\n}\n\ninline void erase_elem(int pos)\n{\n\tauto block \u003d a.begin();\n\tint k \u003d 0;\n\n\twhile (k + block-\u0026gt;a.size() \u0026lt;\u003d pos) {\n\t\tk +\u003d block-\u0026gt;a.size();\n\t\tblock++;\n\t}\n\n\tauto pos_block \u003d block-\u0026gt;a.begin();\n\tfor (int i \u003d k; i \u0026lt; pos; i++)\n\t\tpos_block++;\n\n\tblock-\u0026gt;v \u003d erase(block-\u0026gt;v, *pos_block);\n\tblock-\u0026gt;a.erase(pos_block);\n\n\trelax(block);\n}\n\ninline int get_sum(int ql, int qr, int k)\n{\n\tint l \u003d 0, r \u003d 0;\n\n\tint s \u003d 0;\n\n\tfor (auto block \u003d a.begin(); block !\u003d a.end(); block++) {\n\t\tl \u003d r;\n\t\tr \u003d l + block-\u0026gt;a.size();\n\t\tif (ql \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026lt;\u003d qr + 1) // блок полностью в запросе\n\t\t\ts +\u003d cnt_low_k(block-\u0026gt;v, k);\n\t\telse if (l \u0026lt;\u003d ql \u0026amp;\u0026amp; ql \u0026lt; r || l \u0026lt;\u003d qr \u0026amp;\u0026amp; qr \u0026lt; r) { // в блоке часть запроса\n\t\t\tint i \u003d l;\n\t\t\tfor (auto x : block-\u0026gt;a) {\n\t\t\t\tif (ql \u0026lt;\u003d i \u0026amp;\u0026amp; i \u0026lt;\u003d qr \u0026amp;\u0026amp; x \u0026lt;\u003d k)\n\t\t\t\t\ts++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn s;\n}\n\nint main()\n{\n\t//freopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tsrand(time(0));\n\tint n;\n\tcin \u0026gt;\u0026gt; n;\n\n\ta.insert(a.begin(), Bucket());\n\tauto block \u003d a.begin();\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\tif (block-\u0026gt;a.size() \u003d\u003d BLOCK_SIZE) {\n\t\t\tblock \u003d a.insert(a.end(), Bucket());\n\t\t}\n\n\t\tint x;\n\t\tcin \u0026gt;\u0026gt; x;\n\t\tblock-\u0026gt;a.push_back(x);\n\t\tblock-\u0026gt;v \u003d insert(block-\u0026gt;v, x);\n\t}\n\n\tchar type;\n\twhile (cin \u0026gt;\u0026gt; type \u0026amp;\u0026amp; (type \u003d\u003d \u0027-\u0027 || type \u003d\u003d \u0027+\u0027 || type \u003d\u003d \u0027?\u0027)) {\n\t\tif (type \u003d\u003d \u0027-\u0027) {\n\t\t\tint pos;\n\t\t\tcin \u0026gt;\u0026gt; pos;\n\t\t\terase_elem(pos);\n\t\t}\n\t\telse if (type \u003d\u003d \u0027+\u0027) {\n\t\t\tint pos, x;\n\t\t\tcin \u0026gt;\u0026gt; pos \u0026gt;\u0026gt; x;\n\t\t\tinsert_elem(pos, x);\n\t\t}\n\t\telse {\n\t\t\tint l, r, k;\n\t\t\tcin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k;\n\t\t\tcout \u0026lt;\u0026lt; get_sum(l, r, k) \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t\t}\n\t}\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eСпасибо \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/s.egorov\" title\u003d\"Кандидат в мастера s.egorov\"\u003es.egorov\u003c/a\u003e, который помог оптимально подобрать размер блока и заменить ДД на обычный vector таким образом, что асимптотика стала \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0a/3c/0a3c86500271d1e44defc1977ed1da8be757fa83.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e с небольшой константой. Его решение описанно в комментариях, а код я оставлю тут. Кстати, задачка зашла.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eКод\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;list\u0026gt;\n\nusing namespace std;\n\nconst int BLOCK_SIZE \u003d 7;\nlist\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; a; //blocks\nlist\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; s; //sort_blocks\n\nvoid relax(list\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;::iterator cur_block, list\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;::iterator sort_block)\n{\n\tif (cur_block-\u0026gt;size() \u003d\u003d 2 * BLOCK_SIZE) {\n\t\tauto last_cur \u003d a.insert(cur_block, vector\u0026lt;int\u0026gt; ());\n\t\tauto last_sort \u003d s.insert(sort_block, vector\u0026lt;int\u0026gt; ());\n\n\t\t*last_cur \u003d *cur_block;\n\n\t\tcur_block-\u0026gt;clear();\n\t\tsort_block-\u0026gt;clear();\n\n\t\tfor (int i \u003d BLOCK_SIZE; i \u0026lt; 2 * BLOCK_SIZE; i++)\n\t\t\tcur_block-\u0026gt;push_back((*last_cur)[i]);\n\t\tfor (int i \u003d 0; i \u0026lt; BLOCK_SIZE; i++)\n\t\t\tlast_cur-\u0026gt;pop_back();\n\n\t\t*last_sort \u003d *last_cur;\n\t\tsort(last_sort-\u0026gt;begin(), last_sort-\u0026gt;end());\n\t\t*sort_block \u003d *cur_block;\n\t\tsort(sort_block-\u0026gt;begin(), sort_block-\u0026gt;end());\n\t}\n\telse if (cur_block-\u0026gt;size() \u003d\u003d 0) {\n\t\ta.erase(cur_block);\n\t\ts.erase(sort_block);\n\t}\n}\n\nvoid add(int pos, int x)\n{\n\tauto cur_block \u003d a.begin(), sort_block \u003d s.begin();\n\tint cnt \u003d 0;\n\n\twhile (cnt + cur_block-\u0026gt;size() \u0026lt; pos)\n\t\tcnt +\u003d cur_block-\u0026gt;size(), cur_block++, sort_block++;\n\n\tpos -\u003d cnt;\n\tsort_block-\u0026gt;insert(lower_bound(sort_block-\u0026gt;begin(), sort_block-\u0026gt;end(), x), x);\n\tcur_block-\u0026gt;insert(cur_block-\u0026gt;begin() + pos, x);\n\n\trelax(cur_block, sort_block);\n}\n\nvoid del(int pos)\n{\n\tauto cur_block \u003d a.begin(), sort_block \u003d s.begin();\n\tint cnt \u003d 0;\n\n\twhile (cnt + cur_block-\u0026gt;size() \u0026lt;\u003d pos)\n\t\tcnt +\u003d cur_block-\u0026gt;size(), cur_block++, sort_block++;\n\n\tpos -\u003d cnt;\n\n\tsort_block-\u0026gt;erase(lower_bound(sort_block-\u0026gt;begin(), sort_block-\u0026gt;end(), (*cur_block)[pos]));\n\tcur_block-\u0026gt;erase(cur_block-\u0026gt;begin() + pos);\n\n\trelax(cur_block, sort_block);\n}\n\nint cnt_low_k(int ql, int qr, int k)\n{\n\tint l \u003d 0, r \u003d 0;\n\tint ans \u003d 0;\n\tfor (auto cur_block \u003d a.begin(), sort_block \u003d s.begin(); cur_block !\u003d a.end(); cur_block++, sort_block++) {\n\t\tl \u003d r, r \u003d l + cur_block-\u0026gt;size();\n\n\t\tif (ql \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026lt;\u003d qr + 1)\n\t\t\tans +\u003d upper_bound(sort_block-\u0026gt;begin(), sort_block-\u0026gt;end(), k) - sort_block-\u0026gt;begin();\n\t\telse if (l \u0026lt;\u003d ql \u0026amp;\u0026amp; ql \u0026lt;\u003d r || l \u0026lt;\u003d qr \u0026amp;\u0026amp; qr \u0026lt;\u003d r) {\n\t\t\tfor (int i \u003d l, j \u003d 0; i \u0026lt; r; i++, j++)\n\t\t\t\tif (ql \u0026lt;\u003d i \u0026amp;\u0026amp; i \u0026lt;\u003d qr)\n\t\t\t\t\tans +\u003d (*cur_block)[j] \u0026lt;\u003d k;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\n\tint n;\n\tcin \u0026gt;\u0026gt; n;\n\n\ta.insert(a.begin(), vector\u0026lt;int\u0026gt;());\n\ts.insert(s.begin(), vector\u0026lt;int\u0026gt;());\n\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\tint t;\n\t\tcin \u0026gt;\u0026gt; t;\n\t\tadd(i, t);\n\t}\n\n\tchar type;\n\twhile (cin \u0026gt;\u0026gt; type) {\n\t\tif (type \u003d\u003d \u0027+\u0027) {\n\t\t\tint pos, x;\n\t\t\tcin \u0026gt;\u0026gt; pos \u0026gt;\u0026gt; x;\n\t\t\tadd(pos, x);\n\t\t}\n\t\telse if (type \u003d\u003d \u0027-\u0027) {\n\t\t\tint pos;\n\t\t\tcin \u0026gt;\u0026gt; pos;\n\t\t\tdel(pos);\n\t\t}\n\t\telse {\n\t\t\tint l, r, k;\n\t\t\tcin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k;\n\t\t\tcout \u0026lt;\u0026lt; cnt_low_k(l, r, k) \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t\t}\n\t}\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eРешение в оффлайн:\u003c/strong\u003e \u003cbr /\u003e Получим относительный порядок элементов, с помощью ДД по неявному ключу(из предыдущего \u003ca href\u003d\"//codeforces.com/blog/entry/59214\"\u003eпоста\u003c/a\u003e). А затем воспользуемся задачей 4. \u003cbr /\u003e \u003cem\u003eСложность:\u003c/em\u003e Получение относительного порядка \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e и далее \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/74/10/7410a69421c6ee91a5842650f56f6dd28c3fad9a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e далее для каждого запроса.\u003cbr /\u003e Я таки превозмог себя и написал это, но все еще ТЛ, да еще и памяти стало жрать как конина. Проходит тестов больше чем корневухой. Если вы подскажете мне, как это можно улучшить, буду рад.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eКод\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#pragma GCC target(\u0026quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\u0026quot;)\n#pragma GCC optimize(\u0026quot;O3\u0026quot;)\n#pragma GCC optimize(\u0026quot;unroll-loops\u0026quot;)\n\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n\nusing namespace std;\n\nstruct Node { //ДД по неявному ключу чтобы получить относительный порядок\n\tint x, y;\n\tint is_on, s;\n\tint add;\n\tint del;\n\tvector\u0026lt;int\u0026gt; leftq, rightq;\n\n\tNode *l, *r;\n\n\tNode(int x, int nq) : x(x), y(rand()), is_on(1), s(1), l(0), r(0), add(nq), del(-1) { leftq.reserve(100), rightq.reserve(100); }\n};\n\ninline int sum(Node *v)\n{\n\treturn v \u003d\u003d 0 ? 0 : v-\u0026gt;s;\n}\n\ninline void upd(Node *v)\n{\n\tv-\u0026gt;s \u003d sum(v-\u0026gt;l) + v-\u0026gt;is_on + sum(v-\u0026gt;r);\n}\n\nNode *merge(Node *a, Node *b)\n{\n\tif (a \u003d\u003d 0)\n\t\treturn b;\n\tif (b \u003d\u003d 0)\n\t\treturn a;\n\n\tif (a-\u0026gt;y \u0026lt; b-\u0026gt;y) {\n\t\ta-\u0026gt;r \u003d merge(a-\u0026gt;r, b);\n\t\tupd(a);\n\t\treturn a;\n\t}\n\telse {\n\t\tb-\u0026gt;l \u003d merge(a, b-\u0026gt;l);\n\t\tupd(b);\n\t\treturn b;\n\t}\n}\n\npair\u0026lt;Node *, Node *\u0026gt; split(Node *v, int k)\n{\n\tif (v \u003d\u003d 0)\n\t\treturn { 0, 0 };\n\n\tif (sum(v-\u0026gt;l) + v-\u0026gt;is_on \u0026lt;\u003d k) {\n\t\tauto t \u003d split(v-\u0026gt;r, k - sum(v-\u0026gt;l) - v-\u0026gt;is_on);\n\t\tv-\u0026gt;r \u003d t.first;\n\t\tupd(v);\n\t\treturn { v, t.second };\n\t}\n\telse {\n\t\tauto t \u003d split(v-\u0026gt;l, k);\n\t\tv-\u0026gt;l \u003d t.second;\n\t\tupd(v);\n\t\treturn { t.first, v };\n\t}\n}\n\nvoid set0(Node *v, int nq)\n{\n\tif (v-\u0026gt;is_on) {\n\t\tv-\u0026gt;is_on \u003d 0;\n\t\tv-\u0026gt;del \u003d nq;\n\t\tupd(v);\n\t}\n\telse if (sum(v-\u0026gt;l) \u003d\u003d 1) {\n\t\tset0(v-\u0026gt;l, nq);\n\t\tupd(v);\n\t}\n\telse {\n\t\tset0(v-\u0026gt;r, nq);\n\t\tupd(v);\n\t}\n}\n\ninline Node *insert(Node *v, int pos, int x, int nq)\n{\n\tauto a \u003d split(v, pos);\n\treturn merge(a.first, merge(new Node(x, nq), a.second));\n}\n\ninline Node *erase(Node *v, int pos, int nq)\n{\n\tauto a \u003d split(v, pos);\n\tauto b \u003d split(a.second, 1);\n\tset0(b.first, nq);\n\treturn merge(a.first, merge(b.first, b.second));\n}\n\nNode *find1(Node *v)\n{\n\tif (v-\u0026gt;is_on)\n\t\treturn v;\n\telse if (sum(v-\u0026gt;l) \u003d\u003d 1)\n\t\treturn find1(v-\u0026gt;l);\n\telse\n\t\treturn find1(v-\u0026gt;r);\n}\n\ninline void querry_cnt(Node *\u0026amp;v, int l, int r, int nq)\n{\n\tauto a \u003d split(v, l);\n\tauto b \u003d split(a.second, 1);\n\tNode *t \u003d find1(b.first);\n\tt-\u0026gt;leftq.push_back(nq);\n\tv \u003d merge(a.first, merge(b.first, b.second));\n\n\ta \u003d split(v, r);\n\tb \u003d split(a.second, 1);\n\tt \u003d find1(b.first);\n\tt-\u0026gt;rightq.push_back(nq);\n\tv \u003d merge(a.first, merge(b.first, b.second));\n}\n\nvector\u0026lt;int\u0026gt; ord;\nvector\u0026lt;bool\u0026gt; is_was;\n\nstruct querry {\n\tchar type;\n\tint a, b, c;\n};\n\nvector\u0026lt;querry\u0026gt; q;\n\nvoid make_array(Node *v)\n{\n\tif (v \u003d\u003d 0)\n\t\treturn;\n\tmake_array(v-\u0026gt;l);\n\n\tif (v-\u0026gt;add \u0026gt; -1) {\n\t\tq[v-\u0026gt;add].a \u003d ord.size();\n\t\tis_was.push_back(false);\n\t}\n\telse\n\t\tis_was.push_back(true);\n\n\tfor (int x : v-\u0026gt;leftq)\n\t\tq[x].a \u003d ord.size();\n\tfor (int x : v-\u0026gt;rightq)\n\t\tq[x].b \u003d ord.size();\n\n\tif (v-\u0026gt;del \u0026gt; -1)\n\t\tq[v-\u0026gt;del].a \u003d ord.size();\n\n\tord.push_back(v-\u0026gt;x);\n\t\n\tmake_array(v-\u0026gt;r);\n\n\tdelete v;\n}\n\nstruct Node1 { //ДД для хранения в вершине ДО\n\tint x, y;\n\tint cnt, size;\n\tNode1 *l, *r;\n\n\tNode1(int x): x(x), y(rand()), cnt(1), size(1), l(0), r(0) {}\n};\n\ninline int sz(Node1 *v)\n{\n\treturn v \u003d\u003d 0 ? 0 : v-\u0026gt;size;\n}\n\ninline void upd(Node1 *v)\n{\n\tv-\u0026gt;size \u003d sz(v-\u0026gt;l) + v-\u0026gt;cnt + sz(v-\u0026gt;r);\n}\n\npair\u0026lt;Node1 *, Node1 *\u0026gt; split(Node1 *v, int k)\n{\n\tif (v \u003d\u003d 0)\n\t\treturn { 0, 0 };\n\n\tif (v-\u0026gt;x \u0026lt; k) {\n\t\tauto t \u003d split(v-\u0026gt;r, k);\n\t\tv-\u0026gt;r \u003d t.first;\n\t\tupd(v);\n\t\treturn { v, t.second };\n\t}\n\telse {\n\t\tauto t \u003d split(v-\u0026gt;l, k);\n\t\tv-\u0026gt;l \u003d t.second;\n\t\tupd(v);\n\t\treturn { t.first, v };\n\t}\n}\n\nNode1 *merge(Node1 *a, Node1 *b)\n{\n\tif (a \u003d\u003d 0)\n\t\treturn b;\n\tif (b \u003d\u003d 0)\n\t\treturn a;\n\n\tif (a-\u0026gt;y \u0026lt; b-\u0026gt;y) {\n\t\ta-\u0026gt;r \u003d merge(a-\u0026gt;r, b);\n\t\tupd(a);\n\t\treturn a;\n\t}\n\telse {\n\t\tb-\u0026gt;l \u003d merge(a, b-\u0026gt;l);\n\t\tupd(b);\n\t\treturn b;\n\t}\n}\n\nNode1 *insert(Node1 *v, int x)\n{\n\tauto a \u003d split(v, x);\n\tauto b \u003d split(a.second, x + 1);\n\n\tif (b.first \u003d\u003d 0)\n\t\treturn merge(a.first, merge(new Node1(x), b.second));\n\telse {\n\t\tb.first-\u0026gt;cnt++;\n\t\tupd(b.first);\n\t\treturn merge(a.first, merge(b.first, b.second));\n\t}\n}\n\nNode1 *erase(Node1 *v, int x)\n{\n\tauto a \u003d split(v, x);\n\tauto b \u003d split(a.second, x + 1);\n\n\tif (b.first-\u0026gt;cnt \u003d\u003d 1)\n\t\treturn merge(a.first, b.second);\n\telse {\n\t\tb.first-\u0026gt;cnt--;\n\t\tupd(b.first);\n\t\treturn merge(a.first, merge(b.first, b.second));\n\t}\n}\n\nint cnt_low_k(Node1 *\u0026amp;v, int x)\n{\n\tauto a \u003d split(v, x + 1);\n\tint ans \u003d sz(a.first);\n\tv \u003d merge(a.first, a.second);\n\treturn ans;\n}\n\nvector\u0026lt;Node1 *\u0026gt; t;\nconst int INF \u003d 1e+9 + 2;\n\nvoid build(int v, int l, int r)\n{\n\tt[v] \u003d 0;\n\tfor (int i \u003d l; i \u0026lt; r; i++)\n\t\tif (is_was[i])\n\t\t\tt[v] \u003d insert(t[v], ord[i]);\n\t\telse\n\t\t\tt[v] \u003d insert(t[v], INF);\n\n\tif (r - l \u0026gt; 1) {\n\t\tint m \u003d (l + r) \u0026gt;\u0026gt; 1;\n\t\tbuild(2 * v + 1, l, m);\n\t\tbuild(2 * v + 2, m, r);\n\t}\n}\n\nvoid add(int v, int l, int r, int pos)\n{\n\tt[v] \u003d erase(t[v], INF);\n\tt[v] \u003d insert(t[v], ord[pos]);\n\n\tif (r - l \u0026gt; 1) {\n\t\tint m \u003d (l + r) \u0026gt;\u0026gt; 1;\n\n\t\tif (pos \u0026lt; m)\n\t\t\tadd(2 * v + 1, l, m, pos);\n\t\telse\n\t\t\tadd(2 * v + 2, m, r, pos);\n\t}\n}\n\nvoid del(int v, int l, int r, int pos)\n{\n\tt[v] \u003d erase(t[v], ord[pos]);\n\tt[v] \u003d insert(t[v], INF);\n\n\tif (r - l \u0026gt; 1) {\n\t\tint m \u003d (l + r) \u0026gt;\u0026gt; 1;\n\n\t\tif (pos \u0026lt; m)\n\t\t\tdel(2 * v + 1, l, m, pos);\n\t\telse\n\t\t\tdel(2 * v + 2, m, r, pos);\n\t}\n}\n\nint cnt_low_k(int v, int l, int r, int ql, int qr, int x)\n{\n\tif (qr \u0026lt;\u003d l || r \u0026lt;\u003d ql)\n\t\treturn 0;\n\telse if (ql \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026lt;\u003d qr)\n\t\treturn cnt_low_k(t[v], x);\n\telse {\n\t\tint m \u003d (l + r) \u0026gt;\u0026gt; 1;\n\t\treturn cnt_low_k(2 * v + 1, l, m, ql, qr, x) + cnt_low_k(2 * v + 2, m, r, ql, qr, x);\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tsrand(time(0));\n\n\tint n;\n\tcin \u0026gt;\u0026gt; n;\n\tNode *v \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\tint x;\n\t\tcin \u0026gt;\u0026gt; x;\n\t\tv \u003d insert(v, i, x, -1);\n\t}\n\n\tq.reserve(1e+5 + 1);\n\tchar type;\n\tint i \u003d 0;\n\twhile (cin \u0026gt;\u0026gt; type) {\n\t\tif (type \u003d\u003d \u0027+\u0027) {\n\t\t\tint pos, x;\n\t\t\tcin \u0026gt;\u0026gt; pos \u0026gt;\u0026gt; x;\n\t\t\tv \u003d insert(v, pos, x, i);\n\t\t\tq.push_back({ type, pos, x });\n\t\t}\n\t\telse if (type \u003d\u003d \u0027-\u0027) {\n\t\t\tint pos;\n\t\t\tcin \u0026gt;\u0026gt; pos;\n\t\t\tv \u003d erase(v, pos, i);\n\t\t\tq.push_back({ type, pos });\n\t\t}\n\t\telse {\n\t\t\tint l, r, x;\n\t\t\tcin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x;\n\t\t\tquerry_cnt(v, l, r, i);\n\t\t\tq.push_back({ type, l, r, x });\n\t\t}\n\t\ti++;\n\t}\n\n\tord.reserve(n + i + 1);\n\tis_was.reserve(n + i + 1);\n\n\tmake_array(v);\n\tn \u003d ord.size();\n\n\tt.resize(4 * n);\n\tbuild(0, 0, n);\n\n\tfor (int j \u003d 0; j \u0026lt; i; j++) {\n\t\tif (q[j].type \u003d\u003d \u0027+\u0027)\n\t\t\tadd(0, 0, n, q[j].a);\n\t\telse if (q[j].type \u003d\u003d \u0027-\u0027)\n\t\t\tdel(0, 0, n, q[j].a);\n\t\telse\n\t\t\tcout \u0026lt;\u0026lt; cnt_low_k(0, 0, n, q[j].a, q[j].b + 1, q[j].c) \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t}\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eЗадачи 1 и 2: \u003ca href\u003d\"http://acmp.ru/index.asp?main\u003dtask\u0026amp;id_task\u003d112\"\u003eACMP №112\u003c/a\u003e \u003ca href\u003d\"http://acmp.ru/index.asp?main\u003dtask\u0026amp;id_task\u003d647\"\u003eACMP №647\u003c/a\u003e \u003ca href\u003d\"http://acmp.ru/index.asp?main\u003dtask\u0026amp;id_task\u003d441\"\u003eACMP №441\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЗадача 4: \u003ca href\u003d\"http://www.spoj.com/problems/XXXXXXXX/\"\u003eЗадача на spoj на сумму различных элементов\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЗадача 3 в чистом виде мне ещё не попадалась, а задачу 5 на русскоязычных сайтах я не нашел, она была у меня в ЛОШ.\u003c/p\u003e\u003c/div\u003e","tags":["дерево фенвика","декартово дерево","дерево отрезков","структруры данных"]}}