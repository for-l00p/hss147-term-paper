{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1520532064,"rating":6,"authorHandle":"Tima","modificationTimeSeconds":1520532081,"id":58246,"title":"\u003cp\u003eContest #1\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/group/2jzpDQ0oYB/contest/220950/problem/A\" title\u003d\"Contest 1\"\u003e220950A - Лабиринт\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\n#define ll long long\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define y1 asda\n\nusing namespace std;\nconst int N \u003d int(3e5);\n\nchar s[N];\n\nint main(){\n\n\tint n, m;\n\tscanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m);\n\tm--;\n\tscanf(\u0026quot;%s\u0026quot;, s);\n\tint cnt1 \u003d 0, cnt2 \u003d 0;\n\tfor(int i \u003d 1; i \u0026lt;\u003d m; i++) {\n\t\tif(s[i] \u003d\u003d \u0027R\u0027) {\n\t\t\tcnt1++;\n\t\t}\n\t}\n\tfor(int j \u003d m; j \u0026lt; n - 1; j++) {\n\t\tif(s[j] \u003d\u003d \u0027L\u0027) {\n\t\t\tcnt2++;\n\t\t}\n\t}\n\tprintf(\u0026quot;%d\u0026quot;, min(cnt1, cnt2));\n\t\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/group/2jzpDQ0oYB/contest/220950/problem/B\" title\u003d\"Contest 1\"\u003e220950B - Количество хороших подмножеств\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e//Solution by Tima\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;bitset\u0026gt;\n#define f first\n#define s second\n#define ll long long\n#define ull unsigned long long\n#define mp make_pair\n#define pb push_back\n#define vi vector \u0026lt;int\u0026gt;\n#define ld long double\n#define pii pair\u0026lt;int, int\u0026gt;\n#define y1 sda\nusing namespace std;    \nconst int N \u003d int(3e5), mod \u003d int(1e9)  + 7; \n\nchar s[N];\n\nint n;\n\nll res;\n\nll modpow(ll a,ll b){\n\tll res \u003d 1;\n\twhile(b \u0026gt; 0){\n\t\tif(b \u0026amp; 1) res \u003d res * a % mod;\n\t\ta \u003d a * a % mod;\n\t\tb \u0026gt;\u0026gt;\u003d 1;\n\t}\n\treturn res;\n}\n\nint main () {\n\tscanf(\u0026quot;%s\u0026quot;, s + 1);\n\tn \u003d strlen(s + 1);\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++){\n\t\tres \u003d res * 10 + s[i] - \u00270\u0027;\n\t\tres %\u003d (mod - 1);\n\t}\n\tcout \u0026lt;\u0026lt; 8 * modpow(7, (res + mod - 2) % (mod - 1)) % mod;\n\nreturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/group/2jzpDQ0oYB/contest/220950/problem/C\" title\u003d\"Contest 1\"\u003e220950C - Самый длинный путь\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e//Solution by Tima\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;bitset\u0026gt;\n#define f first\n#define s second\n#define ll long long\n#define ull unsigned long long\n#define mp make_pair\n#define pb push_back\n#define vi vector \u0026lt;int\u0026gt;\n#define ld long double\n#define pii pair\u0026lt;int, int\u0026gt;\n#define y1 sda\nusing namespace std;    \nconst int N \u003d 2010, mod \u003d int(1e9)  + 7;\n\nint t,n, sz, cmp[N], deg[N], id[N];\nvector \u0026lt;int\u0026gt; order, cyc[N], rb;\nbool used[N], a[N][N],ok[N][N];\npair \u0026lt;int,int\u0026gt; p[N];\n\nchar ss[N];\nvoid dfs(int v){\n\tused[v] \u003d 1;\n\tfor(int to \u003d 1; to \u0026lt;\u003d n; to++) if(a[v][to]){\n\t\tif(!used[to]) dfs(to);\n\t}\n\torder.pb(v);                   \n}\n\nvoid dfs1(int v){\n\tused[v] \u003d 1;\n\tcmp[v] \u003d sz;\n\trb.pb(v);\n\tfor(int to \u003d 1; to \u0026lt;\u003d n; to++) if(!a[v][to]){\n\t\tif(!used[to]) dfs1(to);\n\t}\n}\n\nvector \u0026lt;int\u0026gt; path(vector \u0026lt;int\u0026gt; rb){\n\tvector \u0026lt;int\u0026gt; res, cur;\n\tres.pb(rb[0]);\n\tfor(int i \u003d 1; i \u0026lt; rb.size(); i++){\n\t\tcur.clear();\n\t\tif(a[rb[i]][res[0]]){\n\t\t\tcur.pb(rb[i]);\n\t\t\tfor(int j \u003d 0; j \u0026lt; res.size(); j++) cur.pb(res[j]);\n\t\t}\n\t\telse if(a[res.back()][rb[i]]){\n\t\t\tcur \u003d res;\n\t\t\tcur.pb(rb[i]);\n\t\t}\n\t\telse{\n\t\t\tfor(int j \u003d 0; j \u0026lt; res.size(); j++){\n\t\t\t\tif(!a[res[j]][rb[i]]){\n\t\t\t\t\tcur.pb(rb[i]);\n\t\t\t\t\tfor(int k \u003d j; k \u0026lt; res.size(); k++){\n\t\t\t\t\t\tcur.pb(res[k]);\n\t\t\t\t\t}\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur.pb(res[j]);\n\t\t\t}\n\t\t}\n\t\tres \u003d cur;\n\t}\n\treturn res;\n}\n\nvector \u0026lt;int\u0026gt; cycle(vector \u0026lt;int\u0026gt; rb){\n\tvector \u0026lt;int\u0026gt; res;\n\tint k \u003d 0;\n\tfor(int i \u003d 0; i \u0026lt; rb.size(); i++){\n\t\tif(a[rb[i]][rb[0]]){\n\t\t\tk \u003d i;\n\t\t}\n\t}\n\tfor(int i \u003d 0; i \u0026lt;\u003d k; i++){\n\t\tres.pb(rb[i]);\n\t}\n\tint last \u003d k;\n\tvector \u0026lt;int\u0026gt; cur;\n\tfor(int i \u003d k + 1; i \u0026lt; rb.size(); i++){\n\t\tcur.clear();\n\t\tfor(int j \u003d 0; j \u0026lt; res.size(); j++){\n\t\t\tif(a[rb[i]][res[j]]){\n\t\t\t\tfor(int x \u003d 0; x \u0026lt; j; x++){ \n\t\t\t\t\tcur.pb(res[x]);\n\t\t\t\t}\n\t\t\t\tfor(int x \u003d last + 1; x \u0026lt;\u003d i; x++){\n\t\t\t\t\tcur.pb(rb[x]);\n\t\t\t\t}\n\t\t\t\tfor(int x \u003d j; x \u0026lt; res.size(); x++){\n\t\t\t\t\tcur.pb(res[x]);\n\t\t\t\t}\n\t\t\t\tres \u003d cur;\n\t\t\t\tlast \u003d i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main () {\n\tscanf(\u0026quot;%d\\n\u0026quot;,\u0026amp;n);\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++){\n\t\tfor(int j \u003d 1; j \u0026lt;\u003d n; j++){\n\t\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i][j]);\n\t\t}\n\t}\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++){\n\t    assert(a[i] \u003d\u003d 1);\n\t    for(int j \u003d 1; j \u0026lt; i; j++){\n\t        assert((a[i][j] + a[j][i]) \u003d\u003d 2);\n\t    }\n\t}\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++) if(!used[i]){\n\t\tdfs(i);\n\t}\n\tmemset(used, 0, sizeof(used));\n\treverse(order.begin(), order.end());\n\tfor(int v : order){\n\t\tif(!used[v]) {\n\t\t\tsz++;\n\t\t\trb.clear();\n\t\t\tdfs1(v);\n\t\t\trb \u003d path(rb);\n\t\t\tcyc[sz] \u003d cycle(rb);\n\t\t}\n\t}\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++){\n\t    for(int j \u003d 1; j \u0026lt;\u003d n; j++) if(i !\u003d j){\n\t    \tif(a[i][j] \u0026amp;\u0026amp; !ok[cmp[i]][cmp[j]]){\n\t    \t\tok[cmp[i]][cmp[j]] \u003d 1;\n\t    \t\tdeg[cmp[j]]++;\n\t    \t}\n\t    }\n\t}\n\tfor(int i \u003d 1; i \u0026lt;\u003d sz; i++){\n\t\tp[i] \u003d mp(deg[i], i);\n\t}\n\tsort(p + 1, p + sz + 1);\n\tfor(int i \u003d 1; i \u0026lt;\u003d sz; i++){\n\t\tid[p[i].s] \u003d i;\n\t}\n\tvector \u0026lt;int\u0026gt; ga;\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++){\n\t\tint x \u003d cmp[i];\n\t\tga.clear();\n\t\tga.pb(i);\n\t\tif(int(cyc[x].size()) \u0026gt; 1){\n\t\t\tfor(int j \u003d 0 ;j \u0026lt; cyc[x].size(); j++){\n\t\t\t\tif(cyc[x][j] \u003d\u003d i){\n\t\t\t\t\tfor(int k \u003d j + 1; k \u0026lt; cyc[x].size(); k++){\n\t\t\t\t\t\tga.pb(cyc[x][k]);\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k \u003d 0; k \u0026lt; j; k++){\n\t\t\t\t\t\tga.pb(cyc[x][k]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j \u003d id[x] + 1; j \u0026lt;\u003d sz; j++){\n\t\t\tfor(int k \u003d 0; k \u0026lt; cyc[p[j].s].size(); k++){\n\t\t\t\tga.pb(cyc[p[j].s][k]);\n\t\t\t}\n\t\t}\n\t\tprintf(\u0026quot;%d\u0026quot;, int(ga.size()));\n\t\tfor(int j \u003d 0; j \u0026lt; ga.size(); j++){\n\t\t\tprintf(\u0026quot; %d\u0026quot;, ga[j]);\n\t\t}\n\t\tprintf(\u0026quot;\\n\u0026quot;);\n\t}\n\nreturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/group/2jzpDQ0oYB/contest/220950/problem/D\" title\u003d\"Contest 1\"\u003e220950D - XOR-таблица\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#pragma comment(linker, \u0026quot;/stack:20000000\u0026quot;)\n#pragma GCC optimize(\u0026quot;Ofast\u0026quot;)\n#pragma GCC target(\u0026quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\u0026quot;)\n\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;x86intrin.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\nusing namespace __gnu_pbds;\ntemplate \u0026lt;typename T\u0026gt; using ordered_set \u003d tree\u0026lt;T, null_type, std::less\u0026lt;T\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt;;\ntemplate \u0026lt;typename T1, typename T2\u0026gt; using ordered_map \u003d tree\u0026lt;T1, T2, std::less\u0026lt;T1\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt;;\n\nusing namespace std;\n\n\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define abs(a) ((a) \u0026lt; 0 ? -(a) : (a))\n#define sqr(a) ((a) * (a))\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ninline pair\u0026lt;pair\u0026lt;bool, bool\u0026gt;, pair\u0026lt;string, bool\u0026gt; \u0026gt; useinout();\n\n#ifdef SOL\ndouble starttime;\n#endif\n\nvoid initialization() {\n#ifdef SOL\n\tstarttime \u003d 1000. * clock() / CLOCKS_PER_SEC;\n\tif (useinout().fs.fs)\n\t\tfreopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\tif (useinout().fs.sc)\n\t\tfreopen(\u0026quot;output.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n#else\n\tsrand(__rdtsc());\n\tconst string file \u003d useinout().sc.fs;\n\tif (!file.empty()) {\n\t\tfreopen((file + \u0026quot;.in\u0026quot;).c_str(), \u0026quot;r\u0026quot;, stdin);\n\t\tfreopen((file + \u0026quot;.out\u0026quot;).c_str(), \u0026quot;w\u0026quot;, stdout);\n\t} else\n\tif(useinout().sc.sc) {\n\t\tfreopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t\tfreopen(\u0026quot;output.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\t}\n#endif\n}\n\nint solution();\n\nvoid finish(int exitval) {\n\tfflush(stdout);\n#ifdef SOL\n\tfprintf(stderr, \u0026quot;\\n-----------------\\nexit value: %d\\ntime: %.3lf ms\\n-----------------\\n\u0026quot;, exitval, 1000. * clock() / CLOCKS_PER_SEC - starttime);\n#endif\n}\n\nint main() {\n\tinitialization();\n\tfinish(solution());\n\treturn (0);\n}\n\nconst double eps \u003d 1e-9;\nconst int mod \u003d (int) 1e+9 + 7;\nconst double pi \u003d acos(-1.);\nconst int maxn \u003d 100100;\n\nll dp[63][2][2];\n\nll solve(ll n, ll m, ll k) {\n\tdp[62][0][0] \u003d dp[62][0][1] \u003d dp[62][1][0] \u003d 0;\n\tdp[62][1][1] \u003d 1;\n\tll mid \u003d 0;\n\tfor(int i \u003d 62; i \u0026gt; 0; i--) {\n\t\tdp[i - 1][0][0] \u003d dp[i - 1][0][1] \u003d dp[i - 1][1][0] \u003d dp[i - 1][1][1] \u003d 0;\n\t\tlong double addd \u003d 0;\n\t\tll add \u003d 0;\n\t\tfor(int t1 \u003d 0; t1 \u0026lt; 2; t1++) {\n\t\t\tfor(int t2 \u003d 0; t2 \u0026lt; 2; t2++) {\n\t\t\t\tfor(int b \u003d 0; b \u0026lt; 2; b++) {\n\t\t\t\t\tll c1 \u003d (1ll \u0026lt;\u0026lt; (i - 1)), c2 \u003d (1ll \u0026lt;\u0026lt; (i - 1));\n\t\t\t\t\tif(t1) {\n\t\t\t\t\t\tll bit \u003d ((n \u0026gt;\u0026gt; (i - 1)) \u0026amp; 1);\n\t\t\t\t\t\tif(bit \u003d\u003d b) {\n\t\t\t\t\t\t\tc1 \u003d (n \u0026amp; ((1ll \u0026lt;\u0026lt; (i - 1)) - 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(bit \u0026lt; b) {\n\t\t\t\t\t\t\tc1 \u003d 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(t2) {\n\t\t\t\t\t\tll bit \u003d ((m \u0026gt;\u0026gt; (i - 1)) \u0026amp; 1);\n\t\t\t\t\t\tif(bit \u003d\u003d b) {\n\t\t\t\t\t\t\tc2 \u003d (m \u0026amp; ((1ll \u0026lt;\u0026lt; (i - 1)) - 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(bit \u0026lt; b) {\n\t\t\t\t\t\t\tc1 \u003d 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\taddd +\u003d 1. * dp[i][t1][t2] * c1 * c2;\n\t\t\t\t\tadd +\u003d dp[i][t1][t2] * c1 * c2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(addd \u0026lt; k \u0026amp;\u0026amp; add \u0026lt; k) {\n\t\t\tk -\u003d add;\n\t\t\tmid |\u003d (1ll \u0026lt;\u0026lt; (i - 1));\n\t\t}\n\n\t\tfor(int t1 \u003d 0; t1 \u0026lt; 2; t1++) {\n\t\t\tfor(int t2 \u003d 0; t2 \u0026lt; 2; t2++) {\n\t\t\t\tfor(int b1 \u003d 0; b1 \u0026lt; 2; b1++) {\n\t\t\t\t\tfor(int b2 \u003d 0; b2 \u0026lt; 2; b2++) {\n\t\t\t\t\t\tif(((mid \u0026gt;\u0026gt; (i - 1)) \u0026amp; 1) !\u003d b1 ^ b2) continue;\n\t\t\t\t\t\t\tll c1 \u003d 0, c2 \u003d 0;\n\t\t\t\t\t\t\tif(t1) {\n\t\t\t\t\t\t\t\tll bit \u003d ((n \u0026gt;\u0026gt; (i - 1)) \u0026amp; 1);\n\t\t\t\t\t\t\t\tif(bit \u003d\u003d b1) {\n\t\t\t\t\t\t\t\t\tc1 \u003d 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(bit \u0026lt; b1) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(t2) {\n\t\t\t\t\t\t\t\tll bit \u003d ((m \u0026gt;\u0026gt; (i - 1)) \u0026amp; 1);\n\t\t\t\t\t\t\t\tif(bit \u003d\u003d b2) {\n\t\t\t\t\t\t\t\t\tc2 \u003d 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(bit \u0026lt; b2) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdp[i - 1][c1][c2] +\u003d dp[i][t1][t2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn(mid);\n}\n\nint solution() {\n\n\tll n, m, q;\n\n\tscanf(\u0026quot;%lld%lld%lld\u0026quot;, \u0026amp;n, \u0026amp;m, \u0026amp;q);\n\n\tfor(; q--; ) {\n\t\tll k;\n\t\tscanf(\u0026quot;%lld\u0026quot;, \u0026amp;k);\n\t\tprintf(\u0026quot;%lld\\n\u0026quot;, solve(n, m, k));\n\t}\n\n\treturn (0);\n}\n\ninline pair\u0026lt;pair\u0026lt;bool, bool\u0026gt;, pair\u0026lt;string, bool\u0026gt; \u0026gt; useinout() {\n\treturn (mp(mp(1, 0), mp(\u0026quot;\u0026quot;, 0)));\n}\n\n//by Andrey Kim\n\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ekrauch\u0027s code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e/* \n _    _    _______   _    _ \n| |  / /  |  _____| | |  / / \n| | / /   | |       | | / / \n| |/ /    | |_____  | |/ / \n| |\\ \\    |  _____| | |\\ \\ \n| | \\ \\   | |       | | \\ \\ \n| |  \\ \\  | |_____  | |  \\ \\ \n|_|   \\_\\ |_______| |_|   \\_\\ \n  \n*/\n#include \u0026lt;bits/stdc++.h\u0026gt; \n  \nusing namespace std; \n  \ntypedef unsigned long long ull; \ntypedef long long ll; \ntypedef double ld; \ntypedef pair \u0026lt;int, int\u0026gt; PII; \ntypedef pair \u0026lt;ll, ll\u0026gt; PLL; \ntypedef pair \u0026lt; ll, int \u0026gt; PLI; \n  \n  \n#define F first \n#define S second \n#define pb push_back \n#define eb emplace_back \n#define right(x) x \u0026lt;\u0026lt; 1 | 1 \n#define left(x) x \u0026lt;\u0026lt; 1 \n#define forn(x, a, b) for (int x \u003d a; x \u0026lt;\u003d b; ++x) \n#define for1(x, a, b) for (int x \u003d a; x \u0026gt;\u003d b; --x) \n#define mkp make_pair \n#define sz(a) (int)a.size() \n#define all(a) a.begin(), a.end() \n#define y1 kekekek \n  \n#define fname \u0026quot;\u0026quot; \n  \nconst ll ool \u003d 1e18 + 9; \nconst int oo \u003d 1e9 + 9, base \u003d 1e9 + 7; \nconst ld eps \u003d 1e-7; \nconst int N \u003d 2e6 + 6; \n  \nll n, m, d[66][2][2], dn[66][2], dm[66][2]; \nint Q; \n  \nbool bit(ll x, ll i) { \n    return (x \u0026gt;\u0026gt; i) \u0026amp; 1ll; \n} \n  \nint main() { \n    ios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0); \n  \n    #ifdef krauch \n        freopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin); \n    #else \n        //freopen(fname\u0026quot;.in\u0026quot;, \u0026quot;r\u0026quot;, stdin); \n        //freopen(fname\u0026quot;.out\u0026quot;, \u0026quot;w\u0026quot;, stdout); \n    #endif \n  \n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; Q; \n    dn[0][0] \u003d 2; \n    dn[0][1] \u003d (n \u0026amp; 1 ? 1 : 0); \n    forn(i, 1, 60) { \n        dn[i][0] \u003d dn[i - 1][0] * 2; \n        forn(j, 0, bit(n, i)) { \n            if (j \u003d\u003d bit(n, i)) dn[i][1] +\u003d dn[i - 1][1]; \n            else dn[i][1] +\u003d dn[i - 1][0]; \n        } \n    } \n    dm[0][0] \u003d 2; \n    dm[0][1] \u003d (m \u0026amp; 1 ? 1 : 0); \n    forn(i, 1, 60) { \n        dm[i][0] \u003d dm[i - 1][0] * 2; \n        forn(j, 0, bit(m, i)) { \n            if (j \u003d\u003d bit(m, i)) dm[i][1] +\u003d dm[i - 1][1]; \n            else dm[i][1] +\u003d dm[i - 1][0]; \n        } \n    } \n    forn(i, 1, Q) { \n        ll x; \n        cin \u0026gt;\u0026gt; x; \n        ll ans \u003d 0; \n        d[61][1][1] \u003d 1; \n        for1(j, 60, 0) { \n            forn(pn, 0, 1) \n                forn(pm, 0, 1) d[j][pn][pm] \u003d 0; \n            forn(pn, 0, 1) { \n                forn(pm, 0, 1) { \n                    forn(vn, 0, (pn ? bit(n, j) : 1)) { \n                        forn(vm, 0, (pm ? bit(m, j) : 1)) { \n                            if ((vn ^ vm) !\u003d 0) continue; \n                            d[j][pn \u0026amp; (vn \u003d\u003d bit(n, j))][pm \u0026amp; (vm \u003d\u003d bit(m, j))] +\u003d d[j + 1][pn][pm]; \n                        } \n                    } \n                } \n            } \n            ll res \u003d 0; \n            if (j) { \n                forn(pn, 0, 1) { \n                    forn(pm, 0, 1) { \n                        res +\u003d dn[j - 1][pn] * dm[j - 1][pm] * d[j][pn][pm]; \n                    } \n                } \n            } \n            else res \u003d d[j][0][0]; \n            if (x \u0026lt;\u003d res) continue; \n            x -\u003d res; \n            ans +\u003d (1ll \u0026lt;\u0026lt; j); \n            forn(pn, 0, 1) \n                forn(pm, 0, 1) d[j][pn][pm] \u003d 0; \n            forn(pn, 0, 1) { \n                forn(pm, 0, 1) { \n                    forn(vn, 0, (pn ? bit(n, j) : 1)) { \n                        forn(vm, 0, (pm ? bit(m, j) : 1)) { \n                            if ((vn ^ vm) !\u003d 1) continue; \n                            d[j][pn \u0026amp; (vn \u003d\u003d bit(n, j))][pm \u0026amp; (vm \u003d\u003d bit(m, j))] +\u003d d[j + 1][pn][pm]; \n                        } \n                    } \n                } \n            } \n        } \n  \n        cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; \n    } \n  \n    return 0; \n} \n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}