{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1403746352,"rating":-3,"authorHandle":"ivplay","modificationTimeSeconds":1403746352,"id":12843,"title":"\u003cp\u003eMapping Integers !\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cul\u003e   \u003cli\u003eI have some integers 6 , 7 , 9. I want to map them (something like grid compression). Then it should be like :-\u003c/li\u003e   \u003cli\u003e6 — \u0026gt; 1\u003c/li\u003e   \u003cli\u003e7 — \u0026gt; 2\u003c/li\u003e   \u003cli\u003e9 — \u0026gt; 3\u003c/li\u003e   \u003cli\u003e\u003c/li\u003e   \u003cli\u003eI tried STL map for(i\u003d1..3) M[arr[i]]\u003d0; then for_each(it,map) (*it).second\u003d++hashValue;\u003c/li\u003e   \u003cli\u003eUnfortunately I got TLE !\u003c/li\u003e   \u003cli\u003e\u003c/li\u003e   \u003cli\u003eThen I used a temporary array (The order of my original array is needed) , sorted it and used a binary search to map them and stored them in another array.\u003c/li\u003e   \u003cli\u003e\u003c/li\u003e   \u003cli\u003eBut it seems like :-\u003c/li\u003e   \u003cli\u003e2 extra array + O(n) to Copy main array into temporary array + O(nlg(n)) to sorting this temporary array + O(nlg(n)) to binary search is faster than simple mapping I mentioned first !!!\u003c/li\u003e   \u003cli\u003e\u003c/li\u003e   \u003cli\u003eIs it really true or SPOJ\u0027s the great ancient Cluster: Pyramid (Intel Pentium III 733 MHz) machine just fooled me !!! I just can\u0027t believe it because my IO method is another great SPOJ template used for IO operation which I believe is faster than scanf/printf.\u003c/li\u003e \u003c/ul\u003e\u003c/div\u003e","tags":["map","stl","spoj"]}}