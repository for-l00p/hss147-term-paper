{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1403778787,"rating":7,"authorHandle":"Wsl_F","modificationTimeSeconds":1403809251,"id":12847,"title":"\u003cp\u003eНексколько примеров (с решениями) задач на дерево отрезков\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eДанный пост продолжение \u003ca href\u003d\"//codeforces.com/blog/entry/12844\"\u003eэтого\u003c/a\u003e \u003cbr /\u003e Для решения будет использоваться \u003ca href\u003d\"https://github.com/WslF/SomeCode/blob/master/SegmentTree.cpp\"\u003eмой код\u003c/a\u003e класса дерево отрезков единичная модификация. \u003c/p\u003e\u003ch2\u003e1. \u003ca href\u003d\"http://www.e-olimp.com/problems/2941\"\u003eДима и массив\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eМама подарила мальчику Диме массив длины n. Массив этот не простой, а особенный. Дима может выбрать два числа i и d (1 ≤ i ≤ n, -1000 ≤ d ≤ 1000), и элемент с индексом i магически становится равным d. Дима играет со своим массивом, а мама время от времени задает ему вопросы — какова сумма всех чисел в массиве с индексами от f до t? Дима легко справился с этими вопросами, сможете ли Вы?\u003c/p\u003e\u003ch3\u003eТехнические условия\u003c/h3\u003e\u003ch4\u003eВходные данные\u003c/h4\u003e\u003cp\u003eВ первой строке находятся два целых числа n и q (1 ≤ n ≤ 5•105, 1 ≤ q ≤ 105) — количество элементов в массиве и суммарное количество операций и запросов соответственно. В следующей строке дано n чисел a1, a2, ..., an (−1000 ≤ ai ≤ 1000) — начальное состояние массива. В следующих q строках заданы операции и запросы. Первый символ в строке может быть \u003d или ?. Если строка начинается с \u003d, то это операция присваивания. Далее следуют i и d, ограничения на которые описаны в условии. Если строка начинается с ?, то это запрос. Далее следуют числа f и t(1 ≤ f, t ≤ n).\u003c/p\u003e\u003ch4\u003eВыходные данные\u003c/h4\u003e\u003cp\u003eДля каждого запроса выведите сумму чисел в массиве с индексами от f до t, по одному результату в строке.\u003c/p\u003e\u003ch4\u003eРешение.\u003c/h4\u003e\u003cp\u003eЭто одна из классических задач на ДО. В качестве функции используется сумма.\u003c/p\u003e\u003ch4\u003eКод\u003c/h4\u003e \u003cpre\u003e\u003ccode\u003econst int MaxN\u003d 5*100*1000;\nint a[MaxN+5];\n\nint main()\n{\n   ios::sync_with_stdio(0);\n //freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n //freopen(\u0026quot;output.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\n\nint n,q;\ncin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q;\nfor (int i\u003d0; i\u0026lt;n; i++)\n   cin\u0026gt;\u0026gt;a[i];\n\nSegmentTree\u0026lt;int\u0026gt; st(n,a);\nchar c;\nint l,r;\nint i,d;\nfor (int Q\u003d0; Q\u0026lt;q; Q++)\n{\n   cin\u0026gt;\u0026gt;c;\n   if (c\u003d\u003d\u0027?\u0027)\n   {\n       cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r;\n       cout\u0026lt;\u0026lt;st.query(l-1,r-1)\u0026lt;\u0026lt;endl;\n   }\n   else\n   { //c\u003d\u003d \u0027\u003d\u0027\n       cin\u0026gt;\u0026gt;i\u0026gt;\u0026gt;d;\n       st.update(i-1,d);\n   }\n}\nreturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e2. \u003ca href\u003d\"http://www.e-olimp.com/problems/4481\"\u003eВ стране невыученных уроков\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eВитя попал в страну невыученных уроков. Для того, чтобы вернуться домой ему нужно выполнить множество заданий. В этой задаче он должен выиграть у стражей в НОД-игру. Правила этой игры очень простые: есть массив натуральных чисел, после чего игроки выбирают два числа l и r, и им надо посчитать наибольший общий делитель (НОД) всех элементов в массиве с индексами от l до r включительно. Кто быстрее посчитает, тот и выиграл. Чтобы избежать нечестных игр, они иногда заменяют некоторые числа в массиве на другие.  Витя очень хочет домой, помогите ему в этом, для чего напишите программу, которая будет очень быстро считать НОД на заданном промежутке.\u003c/p\u003e\u003ch3\u003eТехнические условия\u003c/h3\u003e\u003ch4\u003eВходные данные\u003c/h4\u003e\u003cp\u003eПервая строка содержит количество элементов n (1 ≤ n ≤ 105) в массиве. Во второй строке находится n чисел – элементы ai (1 ≤ ai ≤ 109) массива. В третьей строке находится количество запросов m (1 ≤ m ≤ 105). Далее в m строках находятся по три числа q, l, r (1 ≤ l ≤ r ≤ n). Если q \u003d 1, требуется посчитать НОД элементов на промежутке [l, r], если q \u003d 2, то надо заменить элемент в позиции l на число r.\u003c/p\u003e\u003ch4\u003eВыходные данные\u003c/h4\u003e\u003cp\u003eДля каждого запроса с номером 1 в отдельной строке выведите ответ на запрос. Подсказка. Тут все просто:)\u003c/p\u003e\u003ch4\u003eРешение.\u003c/h4\u003e\u003cp\u003eПросто напишем функцию наибольшего общего делителя и передадим ее в качестве ассоциативной функции для ДО.\u003c/p\u003e\u003ch4\u003eКод.\u003c/h4\u003e \u003cpre\u003e\u003ccode\u003eint gcd(int a, int b)\n{\n   if (a\u003d\u003d0) return b;\n   return gcd(b%a,a);\n}\n\n\nconst int MaxN\u003d 5*100*1000;\nint a[MaxN+5];\n\nint main()\n{\n  ios::sync_with_stdio(0);\n//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n//freopen(\u0026quot;output.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\n\nint n,q;\n\ncin\u0026gt;\u0026gt;n;\nfor (int i\u003d0; i\u0026lt;n; i++)\n  cin\u0026gt;\u0026gt;a[i];\ncin\u0026gt;\u0026gt;q;\n\nSegmentTree\u0026lt;int\u0026gt; st(n,a,gcd);\nchar c;\nint l,r;\nint i,d;\nfor (int Q\u003d0; Q\u0026lt;q; Q++)\n{\n  cin\u0026gt;\u0026gt;c;\n  if (c\u003d\u003d\u00271\u0027)\n  {\n      cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r;\n      cout\u0026lt;\u0026lt;st.query(l-1,r-1)\u0026lt;\u0026lt;endl;\n  }\n  else\n  { //c\u003d\u003d \u00272\u0027\n      cin\u0026gt;\u0026gt;i\u0026gt;\u0026gt;d;\n      st.update(i-1,d);\n  }\n}\nreturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e3. \u003ca href\u003d\"http://www.e-olimp.com/problems/695\"\u003eRange Variation Query\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eПоследовательность an задается следующей формулой: an \u003d n2 mod 12345 + n3 mod 23456.  Требуется много раз отвечать на запросы следующего вида: • найти разность между максимальным и минимальным значением среди элементов ai, ai+1, ...,aj; • присвоить элементу ai значение j.\u003c/p\u003e\u003ch3\u003eТехнические условия\u003c/h3\u003e\u003ch4\u003eВходные данные\u003c/h4\u003e\u003cp\u003eПервая строка содержит натуральное число k (k ≤ 100 000) — количество запросов. Следующиеk строк содержат запросы, по одному в строке. Запрос номер i описывается двумя целыми числамиxi, yi.  Если xi \u0026gt; 0, то требуется найти разность между максимальным и минимальным значением среди элементов axi...ayi. При этом 1 ≤ xi ≤ yi ≤ 100 000.  Если xi \u0026lt; 0, то требуется присвоить элементу a-xi значение yi. При этом -100 000 ≤ xi ≤ -1 и |yi| ≤ 100 000.\u003c/p\u003e\u003ch4\u003eВыходные данные\u003c/h4\u003e\u003cp\u003eДля каждого запроса первого типа требуется вывести в отдельной строке разность между максимальным и минимальным значением на соответствующем отрезке.\u003c/p\u003e\u003ch4\u003eПодсказка.\u003c/h4\u003e\u003cp\u003eСоздать 2 дерева отрезков.\u003c/p\u003e\u003ch4\u003eРешение.\u003c/h4\u003e\u003cp\u003eВ одном будем хранить максимум на отрезке, в другом – минимум. Нам понадобиться лишь написать функции минимума и максимума и передать в качестве 0 для минимума ОЧЕНЬ большое число, для максимума ОЧЕНЬ маленькое.\u003c/p\u003e\u003ch4\u003eКод.\u003c/h4\u003e \u003cpre\u003e\u003ccode\u003e int Max(int a, int b)\n {\nreturn max(a,b);\n }\n\n int Min(int a, int b)\n {\nreturn min(a,b);\n }\n\nconst int MaxN\u003d 100000;\nconst int inf\u003d 1000*1000*1000;\nint a[MaxN+5];\n\nint main()\n{\n\n ios_base::sync_with_stdio(0);\n cin.tie(0);\n srand(__rdtsc());\n\n for (LL i\u003d0; i\u0026lt;\u003dMaxN; i++)\na[i]\u003d i*i % 12345 + i*i*i % 23456;\n\n\n SegmentTree\u0026lt;int\u0026gt; stMin(MaxN,a+1,Min,inf);\n SegmentTree\u0026lt;int\u0026gt; stMax(MaxN,a+1,Max,-inf);\n\n int x,y,k;\n cin\u0026gt;\u0026gt;k;\n for (int i\u003d0; i\u0026lt;k; i++)\n {\n cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\n if (x\u0026gt;0) cout\u0026lt;\u0026lt;(stMax.query(x-1,y-1)-stMin.query(x-1,y-1))\u0026lt;\u0026lt;endl;\n else\n {\n stMin.update(-x-1,y);\n stMax.update(-x-1,y);\n }\n }\n\n return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e4. \u003ca href\u003d\"http://www.e-olimp.com/problems/2907\"\u003eМожете ли Вы ответить на эти вопросы — 3\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eЗадана последовательность целых чисел a1, a2, ..., an (|ai| ≤ 10000 , 1 ≤ n ≤ 50000). Над ней Вам следует выполнить m (m ≤ 50000) операций: • модифицировать i-ый элемент последовательности • для заданных x и y вывести MAX {ai + ai+1 + ... + aj, x ≤ i ≤ j ≤ y}\u003c/p\u003e\u003ch3\u003eТехнические условия\u003c/h3\u003e\u003ch4\u003eВходные данные\u003c/h4\u003e\u003cp\u003eПервая строка содержит значение n. Следующая строка содержит n целых чисел, задающих последовательность a1, a2, ..., an. Третья строка содержит число m. Следующие m строк содержат запросы вида: • 0 x y: изменить ax на y (|y| ≤ 10000). • 1 x y: вывести MAX {ai + ai+1 + ... + aj, x ≤ i ≤ j ≤ y}\u003c/p\u003e\u003ch4\u003eВыходные данные\u003c/h4\u003e\u003cp\u003eДля каждого запроса вывести ответ как требуется в задаче.\u003c/p\u003e\u003ch4\u003eПодсказка.\u003c/h4\u003e\u003cp\u003eСоздадим структуру из 4 элементов: сумма на отрезке, максимальная сумма на отрезке (ответ на запрос), максимальная сумма начинающаяся с начала отрезка, максимальная сумма заканчивающаяся в конце отрезка.\u003c/p\u003e\u003ch4\u003eРешение.\u003c/h4\u003e\u003cp\u003eСоздадим на этой структуре ДО. Функцию нужно задать следующим образом: сумма на отрезке, очевидно, равна сумме всех чисел; левая сумма – максимум среди [левая сумма левого отрезка], [сумма всех чисел левого отрезка и левая сумма правого отрезка]; правая сумма – максимум среди [правая сумма правого отрезка], [сумма всех чисел правого отрезка и правая сумма левого отрезка]; максимальная сумма – максимум среди [максимальная сумма левого отрезка, максимальная сумма правого отрезка, правая сумма левого отрезка+левая сумма правого отрезка]\u003c/p\u003e\u003ch4\u003eКод.\u003c/h4\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003econst int inf\u003d 16000;\n\nclass Four\n{\npublic:\nint leftSum,rightSum,maxSum,sum;\nFour()\n{\nleftSum\u003d -inf;\nrightSum\u003d -inf;\nmaxSum\u003d -inf;\nsum\u003d 0;\n}\n\nFour(int a, int b, int c, int d)\n{\nleftSum\u003d a;\nrightSum\u003d b;\nmaxSum\u003d c;\nsum\u003d d;\n}\n};\n\n Four maxSum(Four a, Four b)\n {\n Four res;\n res.leftSum\u003d max(a.leftSum,a.sum+b.leftSum);\n res.rightSum\u003d max(b.rightSum,b.sum+a.rightSum);\n res.maxSum\u003d max(a.maxSum,max(b.maxSum,a.rightSum+b.leftSum));\n res.sum\u003d a.sum+b.sum;\n return res;\n }\n\n\nconst int MaxN\u003d 50000;\nFour a[MaxN+5];\n\n\n\nint main()\n{\n\n ios_base::sync_with_stdio(0);\n cin.tie(0);\n srand(__rdtsc());\n\n int n;\n cin\u0026gt;\u0026gt;n;\n {\n int t;\n for (int i\u003d0; i\u0026lt;n; i++)\n {\n cin\u0026gt;\u0026gt;t;\n a[i]\u003d Four(t,t,t,t);\n }\n }\n\n Four zero(-inf,-inf,-inf,0);\n SegmentTree\u0026lt;Four\u0026gt; st(n,a,maxSum,zero);\n\n int x,y,m,q;\n cin\u0026gt;\u0026gt;m;\n Four t;\n for (int i\u003d0; i\u0026lt;m; i++)\n {\n cin\u0026gt;\u0026gt;q\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\n if (q\u003d\u003d1)\n {\nt\u003d st.query(x-1,y-1);\ncout\u0026lt;\u0026lt;t.maxSum\u0026lt;\u0026lt;endl;\n }\n else\n {\n st.update(x-1,Four(y,y,y,y));\n }\n }\n\n return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["дерево отрезков","segment tree","e-olimp"]}}