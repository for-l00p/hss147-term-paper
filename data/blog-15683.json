{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1420829771,"rating":0,"authorHandle":"RemmargorP","modificationTimeSeconds":1420829931,"id":15683,"title":"\u003cp\u003echar — RE | int — OK\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eЗадача:\u003c/p\u003e\u003cp\u003eДана последовательность цифр. Нужно найти сумму всех возможных чисел, которые могут быть \u0026quot;склеены\u0026quot; из этих цифр на отрезке [L;R]\u003c/p\u003e\u003cp\u003eЕсли для хранения этих цифр использовать \u003ccode\u003evector\u0026lt;char\u0026gt; data\u003c/code\u003e, то при вычислении \u003ccode\u003e(1LL * data[i] * p[i])\u003c/code\u003e получается RE. Меняю на \u003ccode\u003evector\u0026lt;int\u0026gt;\u003c/code\u003e — accepted.\u003c/p\u003e\u003cp\u003eСчитывание у меня такое:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (int i \u003d 0; i \u0026lt; n; ++i) {\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;data[i]);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЭто связано с особенностью компилятора или я что-то сделал не так?\u003c/p\u003e\u003c/div\u003e","tags":["c и c++","runtime","пони","все читают теги"]}}