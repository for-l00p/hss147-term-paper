{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1495357540,"rating":60,"authorHandle":"hloya_ygrt","modificationTimeSeconds":1495363760,"id":52099,"title":"\u003cp\u003eCodeforces Round #415 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"810A\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSetter\u0027s code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eint n, k, s \u003d 0;\ncin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k;\nfor (int i \u003d 0; i \u0026lt; n; ++i) {\n    int x;\n    cin \u0026gt;\u0026gt; x;\n    s +\u003d x;\n}\nfor (int ans \u003d 0;; ans++) {\n    int a \u003d 2 * (s + ans * k);\n    int b \u003d (2 * k - 1) * (ans + n);\n\n    if (a \u0026gt;\u003d b) {\n        cout \u0026lt;\u0026lt; ans;\n        return 0;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eFirst accepted \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Zhigan\" title\u003d\"Expert Zhigan\"\u003eZhigan\u003c/a\u003e.\u003c/p\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"810B\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSetter\u0027s code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003efor (int i \u003d 0; i \u0026lt; n; i++) {\n    cin \u0026gt;\u0026gt; k[i] \u0026gt;\u0026gt; l[i];\n    a.push_back(make_pair(min(2 * k[i], l[i]) - min(k[i], l[i]), i));\n}\nsort(a.rbegin(), a.rend());\n\nlong long ans \u003d 0;\nfor (int i \u003d 0; i \u0026lt; f; i++) {\n    int pos \u003d a[i].second;\n    ans +\u003d min(2 * k[pos], l[pos]);\n}\nfor (int i \u003d f; i \u0026lt; n; i++) {\n    int pos \u003d a[i].second;\n    ans +\u003d min(k[pos], l[pos]);\n}\ncout \u0026lt;\u0026lt; ans;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eFirst accepted \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/polygonia\" title\u003d\"Candidate Master polygonia\"\u003epolygonia\u003c/a\u003e.\u003c/p\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"809A\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSetter\u0027s code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003est[0] \u003d 1;\nfor ( int j \u003d 1; j \u0026lt; maxn; j++ )\n    st[j] \u003d ( 2 * st[j - 1] ) % base;\nint n;\nscanf ( \u0026quot;%d\u0026quot;, \u0026amp;n );\nfor ( int j \u003d 0; j \u0026lt; n; j++ )\n    scanf ( \u0026quot;%d\u0026quot;, \u0026amp;a[j] );\nsort( a, a + n );\nint ans \u003d 0;\nfor ( int j \u003d 1; j \u0026lt; n; j++ ) {\n    int len \u003d a[j] - a[j - 1];\n    int cntL \u003d j;\n    int cntR \u003d n - j;\n    int add \u003d ( 1LL * ( st[cntL] - 1 + base ) * ( st[cntR] - 1 + base ) ) % base;\n    ans \u003d ( 1LL * ans + 1LL * len * add ) % base;\n}\nprintf ( \u0026quot;%d\\n\u0026quot;, ans );\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eFirst accepted div2: \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/Lyn\" title\u003d\"Specialist Lyn\"\u003eLyn\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eFirst accepted div1: \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/lewin\" title\u003d\"International Grandmaster lewin\"\u003elewin\u003c/a\u003e.\u003c/p\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"809B\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSetter\u0027s code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eint query(int x,int y){\n    if(x\u003d\u003d-1)return 0;\n    cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;\n    string ret;\n    cin\u0026gt;\u0026gt;ret;\n    return (\u0026quot;TAK\u0026quot;\u003d\u003dret);\n}\n\nint get(int l,int r){\n    if(l\u0026gt;r)return -1;\n\n    while(l\u0026lt;r){\n        int m\u003d(l+r)/2;\n        if(query(m,m+1)){\n            r\u003dm;\n        }else l\u003dm+1;\n    }\n    return l;\n}\n\nint main() {\n    int n,k;\n    cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\n\n    int x\u003dget(1,n);\n    int y\u003dget(1,x-1);\n    if(!query(y,x))y\u003dget(x+1,n);\n    cout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;\n\n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eFirst accepted div2: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/polygonia\" title\u003d\"Candidate Master polygonia\"\u003epolygonia\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eFirst accepted div1: \u003ca class\u003d\"rated-user user-legendary\" href\u003d\"/profile/V--o_o--V\" title\u003d\"Legendary grandmaster V--o_o--V\"\u003e\u003cspan class\u003d\"legendary-user-first-letter\"\u003eV\u003c/span\u003e--o_o--V\u003c/a\u003e.\u003c/p\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"809C\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSetter\u0027s code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cbr /\u003ell dp[32][2][2][2];\nll sum[32][2][2][2];\n\nvoid add(ll \u0026amp;x,ll y){\n    x+\u003dy;\n    if(x\u0026gt;\u003dmod)x-\u003dmod;\n}\n\nvoid sub(ll \u0026amp;x,ll y){\n    x-\u003dy;\n    if(x\u0026lt;0)x+\u003dmod;\n}\n\nll mul(ll x,ll y){\n    return x*y%mod;\n}\n\nll pot[32];\n\nll solve(int x,int y,int z){\n    if(x\u0026lt;0||y\u0026lt;0||z\u0026lt;0)return 0;\n    memset(dp,0,sizeof dp);\n    memset(sum,0,sizeof sum);\n    vi A,B,C;\n    rep(j,0,31){\n        A.pb(x%2);x/\u003d2;\n        B.pb(y%2);y/\u003d2;\n        C.pb(z%2);z/\u003d2;\n    }\n    reverse(all(A));\n    reverse(all(B));\n    reverse(all(C));\n    dp[0][1][1][1]\u003d1;\n    sum[0][1][1][1]\u003d0;\n    rep(i,0,31){\n        rep(a,0,2)rep(b,0,2)rep(c,0,2){\n            rep(x,0,2)rep(y,0,2){\n                int z\u003dx^y;\n                if(a\u003d\u003d1\u0026amp;\u0026amp;A[i]\u003d\u003d0\u0026amp;\u0026amp;x\u003d\u003d1)continue;\n                if(b\u003d\u003d1\u0026amp;\u0026amp;B[i]\u003d\u003d0\u0026amp;\u0026amp;y\u003d\u003d1)continue;\n                if(c\u003d\u003d1\u0026amp;\u0026amp;C[i]\u003d\u003d0\u0026amp;\u0026amp;z\u003d\u003d1)continue;\n                add(dp[i+1][a\u0026amp;(A[i]\u003d\u003dx)][b\u0026amp;(B[i]\u003d\u003dy)][c\u0026amp;(C[i]\u003d\u003dz)],dp[i][a][b][c]);\n                add(sum[i+1][a\u0026amp;(A[i]\u003d\u003dx)][b\u0026amp;(B[i]\u003d\u003dy)][c\u0026amp;(C[i]\u003d\u003dz)],sum[i][a][b][c]);\n                add(sum[i+1][a\u0026amp;(A[i]\u003d\u003dx)][b\u0026amp;(B[i]\u003d\u003dy)][c\u0026amp;(C[i]\u003d\u003dz)],mul(z\u0026lt;\u0026lt;(30-i),dp[i][a][b][c]));\n\n            }\n        }\n    }\n    ll res\u003d0;\n    rep(a,0,2)rep(b,0,2)rep(c,0,2){\n        add(res,sum[31][a][b][c]);\n        add(res,dp[31][a][b][c]);\n    }\n    return res;\n}\n\nint main(){\n    int T;\n    cin\u0026gt;\u0026gt;T;\n    while(T--){\n        int x,y,x2,y2,k;\n        cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;x2\u0026gt;\u0026gt;y2\u0026gt;\u0026gt;k;\n        --x;--y;--x2;--y2;--k;\n        ll res\u003d0;\n        add(res,solve(x2,y2,k));\n        sub(res,solve(x2,y-1,k));\n        sub(res,solve(x-1,y2,k));\n        add(res,solve(x-1,y-1,k));\n        cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;\u0027\\n\u0027;\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eFirst accepted div2: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/xsup\" title\u003d\"Expert xsup\"\u003exsup\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eFirst accepted div1: \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/anta\" title\u003d\"International Grandmaster anta\"\u003eanta\u003c/a\u003e.\u003c/p\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"809D\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSetter\u0027s code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003estruct node {\n    int prior, sz, dp, add;\n    node *l, *r;\n    node ( int x ) {\n        prior \u003d ( rand() \u0026lt;\u0026lt; 15 ) | rand();\n        // sz \u003d 1;\n        dp \u003d x;\n        l \u003d r \u003d NULL;\n        add \u003d 0;\n    }\n};\n \ntypedef node * pnode;\n\nvoid push( pnode T ) {\n    T -\u0026gt; dp +\u003d T -\u0026gt; add;\n    if ( T -\u0026gt; l )\n        T -\u0026gt; l -\u0026gt; add +\u003d T -\u0026gt; add;\n    if ( T -\u0026gt; r )\n        T -\u0026gt; r -\u0026gt; add +\u003d T -\u0026gt; add;\n    T -\u0026gt; add \u003d 0;\n}\n \nvoid merge( pnode \u0026amp;T, pnode L, pnode R ) {\n    if ( !L ) {\n        T \u003d R;\n        return;\n    }\n    if ( !R ) {\n        T \u003d L;\n        return;\n    }\n    if ( L -\u0026gt; prior \u0026gt; R -\u0026gt; prior ) {\n        push( L );\n        merge( L -\u0026gt; r, L -\u0026gt; r, R );\n        T \u003d L;\n        return;\n    }\n    push( R );\n    merge( R -\u0026gt; l, L, R -\u0026gt; l );\n    T \u003d R;\n}\n \nvoid split( pnode T, int value, pnode \u0026amp;L, pnode \u0026amp;R ) {\n    if ( !T ) {\n        L \u003d R \u003d NULL;\n        return;\n    }\n    push( T );\n    if ( T -\u0026gt; dp \u0026gt;\u003d value ) {\n        split( T -\u0026gt; l, value, L, T -\u0026gt; l );\n        R \u003d T;\n        return;\n    }\n    split( T -\u0026gt; r, value, T -\u0026gt; r, R );\n    L \u003d T;\n}\n \nint findBegin( pnode T ) {\n    push( T );\n    if ( !T -\u0026gt; l )\n        return T -\u0026gt; dp;\n    return findBegin( T -\u0026gt; l );\n}\n \nint findMax( pnode T, int n ) {\n    if ( !T )\n        return 0;\n    push( T );\n    return findMax( T -\u0026gt; l, n ) + findMax( T -\u0026gt; r, n ) + ( T -\u0026gt; dp \u0026lt;\u003d inf ? 1 : 0 );\n}\n\npair \u0026lt; int, int \u0026gt; a[maxn];\npnode T \u003d new node( 0 );\npnode L \u003d NULL;\npnode M \u003d NULL;\npnode R \u003d NULL;\npnode rubbish \u003d NULL;\n \nvoid solve() {\n    int n;\n    scanf ( \u0026quot;%d\u0026quot;, \u0026amp;n );\n    for ( int j \u003d 1; j \u0026lt;\u003d n; j++ )\n        scanf ( \u0026quot;%d%d\u0026quot;, \u0026amp;a[j].f, \u0026amp;a[j].s );\n    for ( int j \u003d 1; j \u0026lt;\u003d n; j++ )\n        merge( T, T, new node( inf + j ) );\n    for ( int j \u003d 1; j \u0026lt;\u003d n; j++ ) {\n        split( T, a[j].f, L, R );\n        split( R, a[j].s, M, R );\n        if ( M )\n            M -\u0026gt; add +\u003d 1;\n        int cnt \u003d findBegin( R );\n        split( R, cnt + 1, rubbish, R );\n        merge( T, L, new node( a[j].f ) );\n        merge( T, T, M );\n        merge( T, T, R );\n    }\n    printf ( \u0026quot;%d\\n\u0026quot;, findMax( T, n ) - 1 );\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eFirst accepted: \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/ksun48\" title\u003d\"International Grandmaster ksun48\"\u003eksun48\u003c/a\u003e.\u003c/p\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"809E\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSetter\u0027s code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e#include \u0026lt;functional\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;numeric\u0026gt;\n#include \u0026lt;iomanip\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;math.h\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;map\u0026gt;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate \u0026lt;typename T\u0026gt;\nT nextInt() {\n    T x \u003d 0, p \u003d 1;\n    char ch;\n    do { ch \u003d getchar(); } while(ch \u0026lt;\u003d \u0027 \u0027);\n    if (ch \u003d\u003d \u0027-\u0027) {\n        p \u003d -1;\n        ch \u003d getchar();\n    }\n    while(ch \u0026gt;\u003d \u00270\u0027 \u0026amp;\u0026amp; ch \u0026lt;\u003d \u00279\u0027) {\n        x \u003d x * 10 + (ch - \u00270\u0027);\n        ch \u003d getchar();\n    }\n    return x * p;\n}\nconst int maxN \u003d (int)2e5 + 10;\nconst int maxL \u003d 17;\nconst int INF \u003d (int)1e9;\nconst int mod \u003d (int)1e9 + 7;\nconst ll LLINF \u003d (ll)1e18 + 5;\n\nint mul(int x, int y) {\n    return 1LL * x * y % mod;\n}\n\nvoid add(int \u0026amp;x, int y) {\n    x +\u003d y;\n    if (x \u0026gt;\u003d mod) x -\u003d mod;\n}\n\nvoid sub(int \u0026amp;x, int y) {\n    x -\u003d y;\n    if (x \u0026lt; 0) x +\u003d mod;\n}\n\nint n;\nvector \u0026lt;int\u0026gt; g[maxN];\nvector \u0026lt;int\u0026gt; d[maxN];\nvector \u0026lt;int\u0026gt; coefs[maxN];\nint phi[maxN];\nint inv[maxN];\nint a[maxN];\n\nint tmp[maxN];\n\nvoid productToTmp(int a, int b) {\n    for (size_t it \u003d 0; it \u0026lt; d[a].size(); it++) {\n        for (size_t jt \u003d 0; jt \u0026lt; d[b].size(); jt++) {\n            int x \u003d d[a][it];\n            int cx \u003d coefs[a][it];\n            int y \u003d d[b][jt];\n            int cy \u003d coefs[b][jt];\n            add(tmp[x * y], mul(cx, cy));\n        }\n    }\n}\n\nvoid precalc() {\n    inv[1] \u003d 1;\n    for (int i \u003d 1; i \u0026lt; maxN; ++i) {\n        phi[i] \u003d i;\n        if(i \u0026gt; 1) inv[i] \u003d mul(mod - mod / i, inv[mod % i]);\n    }\n    for (int i \u003d 1; i \u0026lt; maxN; ++i) {\n        for (int j \u003d i; j \u0026lt; maxN; j +\u003d i) {\n            d[j].push_back(i);\n            if (j !\u003d i) phi[j] -\u003d phi[i];\n        }\n    }\n    for (int i \u003d 1; i \u0026lt; maxN; ++i) {\n        coefs[i].resize(d[i].size());\n    }\n    coefs[1][0] \u003d 1;\n    for (int x \u003d 2; x \u0026lt; maxN; x++) {\n        if ((int)d[x].size() \u003d\u003d 2) {\n            coefs[x][0] \u003d 1;\n            coefs[x][1] \u003d inv[x - 1];\n        } else {\n            int lp \u003d d[x][1];\n            int z \u003d x;\n            while (z % lp \u003d\u003d 0) {\n                z /\u003d lp;\n            }\n            for (int y: d[x]) {\n                tmp[y] \u003d 0;\n            }\n            productToTmp(lp, z);\n            for (size_t it \u003d 0; it \u0026lt; d[x].size(); it++) {\n                coefs[x][it] \u003d tmp[d[x][it]];\n            }\n        }\n    }\n}\n\nint nodes[maxN];\nint len \u003d 0;\nint sz[maxN];\nint blocked[maxN];\nint level[maxN];\nint anc[maxN];\n\nvoid calc_sizes(int v, int p \u003d -1) {\n    nodes[len++] \u003d v;\n    sz[v] \u003d 1;\n    anc[v] \u003d p;\n    for (int x: g[v]){\n        if (blocked[x] || x \u003d\u003d p) continue;\n        calc_sizes(x, v);\n        sz[v] +\u003d sz[x];\n    }\n}\n\nint sum_phi[maxN];\n\nint list_len;\nint list[maxN];\nint depth[maxN];\n\nvoid get_list(int v, int par \u003d -1, int dpth \u003d 1) {\n    list[list_len] \u003d v;\n    depth[list_len++] \u003d dpth;\n    for (int x: g[v]) {\n        if (par \u003d\u003d x || blocked[x]) continue;\n        get_list(x, v, dpth + 1);\n    }\n}\n\nint sum[maxN];\n\nint calc(int value) {\n    int cur \u003d 0;\n    for(size_t i \u003d 0; i \u0026lt; d[value].size(); ++i) {\n        int x \u003d d[value][i];\n        add(cur, mul(sum_phi[x], coefs[value][i]));\n    }\n    return mul(cur, phi[value]);\n}\n\nint total \u003d 0;\n\nvoid solve(int root) { //root is a centroid\n    for (int i \u003d 0; i \u0026lt; len; ++i) {\n        int u \u003d nodes[i];\n        int y \u003d a[u];\n        for (int x: d[y]) {\n            add(sum_phi[x], phi[y]);\n        }\n    }\n    for (int child: g[root]) {\n        if (blocked[child]) continue;\n\n        list_len \u003d 0;\n        get_list(child, root);\n        {\n            //excluding everything which can be counted twice\n            for(int i \u003d 0; i \u0026lt; list_len; ++i) {\n                int u \u003d list[i];\n                int y \u003d a[u];\n                for(int x: d[y]) {\n                    sub(sum_phi[x], phi[y]);\n                }\n            }\n        }\n        {\n            for (int i \u003d 0; i \u0026lt; list_len; ++i) {\n                int u \u003d list[i];\n                int d \u003d depth[i];\n                int value \u003d a[u];\n                add(total, mul(d, calc(value)));\n            }\n        }\n        {\n            //including back\n            for(int i \u003d 0; i \u0026lt; list_len; ++i) {\n                int u \u003d list[i];\n                int y \u003d a[u];\n                for(int x: d[y]) {\n                    add(sum_phi[x], phi[y]);\n                }\n            }\n        }\n    }\n\n    //clear\n    for (int i \u003d 0; i \u0026lt; len; ++i) {\n        int u \u003d nodes[i];\n        int y \u003d a[u];\n        for (int x: d[y]) {\n            sum_phi[x] \u003d 0;\n        }\n    }\n}\n\nvoid build(int v, int lev) {\n    len \u003d 0;\n    calc_sizes(v);\n    int centroid \u003d -1;\n    for (int i \u003d 0; i \u0026lt; len; ++i) {\n        int u \u003d nodes[i];\n        int maxChildSize \u003d len - sz[u];\n        for (int x: g[u]) {\n            if (x !\u003d anc[u] \u0026amp;\u0026amp; !blocked[x]) {\n                maxChildSize \u003d max(maxChildSize, sz[x]);\n            }\n        }\n        if (maxChildSize \u0026lt;\u003d len / 2) {\n            centroid \u003d u;\n        }\n    }\n    blocked[centroid] \u003d true;\n    level[centroid] \u003d lev;\n    solve(centroid);\n\n    for (int x: g[centroid]) {\n        if (blocked[x]) continue;\n        build(x, lev + 1);\n    }\n}\n\nint main() {\n\n   // freopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n   // freopen(\u0026quot;output.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n    ios_base::sync_with_stdio(0);\n    precalc();\n    cin \u0026gt;\u0026gt; n;\n    for (int i \u003d 0; i \u0026lt; n; ++i) {\n        cin \u0026gt;\u0026gt; a[i];\n    }\n    for (int i \u003d 1; i \u0026lt; n; ++i) {\n        int x, y;\n        cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n        --x; --y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n\n    build(0, 0);\n\n    total \u003d mul(total, inv[n]);\n    total \u003d mul(total, inv[n - 1]);\n    total \u003d mul(total, 2);\n\n    cout \u0026lt;\u0026lt; total \u0026lt;\u0026lt; endl;\n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eFirst accepted: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/___\" title\u003d\"Candidate Master ___\"\u003e___\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e","tags":[]}}