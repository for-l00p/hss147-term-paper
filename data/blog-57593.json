{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1517942190,"rating":16,"authorHandle":"KokiYmgch","modificationTimeSeconds":1517942190,"id":57593,"title":"\u003cp\u003eThe way to find the centroids of a tree\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThis article is about how to find the centroids of a tree. It can be computed with a trivial tree DP.\u003c/p\u003e\u003cp\u003eThe centroid(s) of a tree is, the vertice(s) whose all subtrees\u0027 size is not more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e(the size of the whole tree).\u003c/p\u003e\u003cp\u003eA tree may have one centroid or may have two centroids. If it has two centroids, they are always connected (otherwise, the tree can\u0027t have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e vertices).\u003c/p\u003e\u003cp\u003eYou can find these vertices by checking the size of each subtree, doing DFS. When the size of a subtree is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, the size of the other part is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003es\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;int\u0026gt; Centroid(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;g) {\n        int n \u003d g.size();\n        vector\u0026lt;int\u0026gt; centroid;\n        vector\u0026lt;int\u0026gt; sz(n);\n        function\u0026lt;void (int, int)\u0026gt; dfs \u003d [\u0026amp;](int u, int prev) {\n                sz[u] \u003d 1;\n                bool is_centroid \u003d true;\n                for (auto v : g[u]) if (v !\u003d prev) {\n                        dfs(v, u);\n                        sz[u] +\u003d sz[v];\n                        if (sz[v] \u0026gt; n / 2) is_centroid \u003d false;\n                }\n                if (n - sz[u] \u0026gt; n / 2) is_centroid \u003d false;\n                if (is_centroid) centroid.push_back(u);\n        };\n        dfs(0, -1);\n        return centroid;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eUsage: By using \u003ccode\u003eg\u003c/code\u003e, the adjacent lists of a tree, get a vector with one or two centroids.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n);\n/*\n    construct a tree\n*/\nauto centroids \u003d Centroid(g);\nif (centroids.size() \u003d\u003d 1) {\n        int c \u003d centroids[0];\n        //\n} else if (centroids.size() \u003d\u003d 2) {\n        int c1 \u003d centroids[0];\n        int c2 \u003d centroids[1];\n        //\n} else {\n        assert(false);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou may sometimes want to find the centroids of any subtree by cutting the original tree. When cutting a tree, you don\u0027t really \u0027cut\u0027 the tree. Instead, just make the vertice die. By ignoring died vertices, you can re-implement the Centroid function like this way.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;int\u0026gt; Centroid(int root, const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;g, const vector\u0026lt;bool\u0026gt; \u0026amp;dead) {\n        static vector\u0026lt;int\u0026gt; sz(g.size());\n        function\u0026lt;void (int, int)\u0026gt; get_sz \u003d [\u0026amp;](int u, int prev) {\n                sz[u] \u003d 1;\n                for (auto v : g[u]) if (v !\u003d prev \u0026amp;\u0026amp; !dead[v]) {\n                        get_sz(v, u);\n                        sz[u] +\u003d sz[v];\n                }\n        };\n        get_sz(root, -1);\n        int n \u003d sz[root];\n        vector\u0026lt;int\u0026gt; centroid;\n        function\u0026lt;void (int, int)\u0026gt; dfs \u003d [\u0026amp;](int u, int prev) {\n                bool is_centroid \u003d true;\n                for (auto v : g[u]) if (v !\u003d prev \u0026amp;\u0026amp; !dead[v]) {\n                        dfs(v, u);\n                        if (sz[v] \u0026gt; n / 2) is_centroid \u003d false;\n                }\n                if (n - sz[u] \u0026gt; n / 2) is_centroid \u003d false;\n                if (is_centroid) centroid.push_back(u);\n        };\n        dfs(root, -1);\n        return centroid;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDon\u0027t forget to reuse \u003ccode\u003esz\u003c/code\u003e, or it\u0027s going to be slow (or if you like, use \u003ccode\u003emap\u003c/code\u003e).\u003c/p\u003e\u003cp\u003eBy the way, when you do Centroid Decomposition, you don\u0027t need to know \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e centroids of the tree. Therefore, if you just want to find \u0027a\u0027 centroid of a dynamic tree, you can implement this in the following way:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint OneCentroid(int root, const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;g, const vector\u0026lt;bool\u0026gt; \u0026amp;dead) {\n        static vector\u0026lt;int\u0026gt; sz(g.size());\n        function\u0026lt;void (int, int)\u0026gt; get_sz \u003d [\u0026amp;](int u, int prev) {\n                sz[u] \u003d 1;\n                for (auto v : g[u]) if (v !\u003d prev \u0026amp;\u0026amp; !dead[v]) {\n                        get_sz(v, u);\n                        sz[u] +\u003d sz[v];\n                }\n        };\n        get_sz(root, -1);\n        int n \u003d sz[root];\n        function\u0026lt;int (int, int)\u0026gt; dfs \u003d [\u0026amp;](int u, int prev) {\n                for (auto v : g[u]) if (v !\u003d prev \u0026amp;\u0026amp; !dead[v]) {\n                        if (sz[v] \u0026gt; n / 2) {\n                                return dfs(v, u);\n                        }\n                }\n                return u;\n        };\n        return dfs(root, -1);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is very fast, because it returns a centroid shortly after it finds a centroid for the first time.\u003c/p\u003e\u003cp\u003eThank you for your reading! I\u0027ll write an article on centroid decomposition later!\u003c/p\u003e\u003c/div\u003e","tags":["#trees","centroid"]}}