{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1498175543,"rating":0,"authorHandle":"SAeed","modificationTimeSeconds":1498175543,"id":52832,"title":"\u003cp\u003eSPU Contest #10\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e \u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214186/problem/Blue\"\u003eBlue — Elephant\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eGreedy\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eObviously we must use as many fives an we can. What\u0027s left can be taken in one move since we have all the numbers from 1 to 4\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(1)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tll n; cin \u0026gt;\u0026gt; n;\n\tcout \u0026lt;\u0026lt; n / 5 + (n % 5 !\u003d 0) \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214186/problem/Green\"\u003eGreen — Dinner with Emma\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAhHoc\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe thing we know for sure that whichever street Emma chooses, Jack is going to choose the smallest number in that street. So, Emma has to look for each street only by its smallest number. Find the smallest number of each street, then choose the street with the biggest number among these small numbers.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n x m)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003e~~~~~\u003c/p\u003e\u003ch1\u003einclude\u0026lt;bits/stdc++.h\u0026gt;\u003c/h1\u003e\u003cp\u003eusing namespace std; typedef long long ll;\u003c/p\u003e\u003cp\u003eint main() {  //freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);  //freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);  ios::sync_with_stdio(0);\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\nint ans \u003d 0;\nfor (int i \u003d 0; i \u0026lt; n; i++){\n    int mini \u003d 1e9;\n    for (int j \u003d 0; j \u0026lt; m; j++){\n       int a; cin \u0026gt;\u0026gt; a;\n       mini \u003d min(mini, a);\n    }\n    ans \u003d max(ans, mini);\n}\ncout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\nreturn 0;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e}~~~~~\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214186/problem/Purple\"\u003ePurple — Link/Cut Tree\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eBrute Force\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe number of powers of \u003ccode\u003eK\u003c/code\u003e that are smaller than 10^18 are actually small (about 60 powers in the worst case). Iterate over all these powers and see which of them falls inside our range. The thing to pay attention to is not to overflow our \u003ccode\u003epower\u003c/code\u003e variable. Since each time we multiply \u003ccode\u003epower\u003c/code\u003e by \u003ccode\u003eK\u003c/code\u003e, we surely know that: \u003ccode\u003epwoer x K / K\u003c/code\u003e is equal to \u003ccode\u003epwoer\u003c/code\u003e it self. Unless an overflow happened, which will give a random number on \u003ccode\u003epower x K\u003c/code\u003e meaning that this number when divided by \u003ccode\u003eK\u003c/code\u003e won\u0027t give power back.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(Log(r))\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nvector\u0026lt;ll\u0026gt; ans;\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tll l, r, k; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k;\n\tll power \u003d 1;\n\twhile (power \u0026lt;\u003d r){\n\t\tif (power \u0026gt;\u003d l) ans.push_back(power);\n\n\t\t// power * k / k in normal cases should be equal to power it self\n\t\t// because we just multiplied the number with k then divided it by k\n\t\t// unless overflow happened\n\t\t// then when we divide it by k the answer won\u0027t be power any more\n\t\t// because power * k got a random number\n\t\tif (power * k / k !\u003d power) break; // overflow will happen if did power *\u003d k\n\t\tpower *\u003d k;\n\t}\n\tif (ans.size() \u003d\u003d 0) cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl;\n\tfor (int i \u003d 0; i \u0026lt; ans.size(); i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214186/problem/Red\"\u003eRed — Bottles\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eDP\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSince at this problem we were asked to calculate two best answers, we will solve it with a DP solution, where our DP function will return a pair of the number of bottles used, and the minimum time to fill these bottles. Now think, what are the options of each bottle? it\u0027s either used to pour the cola into it, or is used to pour the cola from it into some other bottle. We can solve this problem with the following dynamic approach:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003e\u003cstrong\u003eDP[\u003c/strong\u003e current bottle \u003cstrong\u003e][\u003c/strong\u003e space we have to pour the cola to \u003cstrong\u003e]\u003c/strong\u003e\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf we used the bottle to pour the cola to it, our space will increase by whatever free space left on this bottle \u003ccode\u003eb[i] - a[i]\u003c/code\u003e, and this will increase the number of bottles used by one.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf we used the bottle to pour the cola from it, our space will decrease by the amount of cola in it \u003ccode\u003ea[i]\u003c/code\u003e, and this will increase the number of minutes needed by \u003ccode\u003ea[i]\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n x (n x a))\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint n;\nint a[111];\nint b[111];\npair\u0026lt;ll, ll\u0026gt; memo[111][20100];\npair\u0026lt;ll, ll\u0026gt; dp(int i, int space){\n\tif (i \u003d\u003d n){\n\t\tif (space \u0026gt;\u003d 0) return make_pair(0, 0);\n\t\telse return make_pair(1e9, 1e9);\n\t}\n\n\tpair\u0026lt;ll, ll\u0026gt; \u0026amp;ret \u003d memo[i][space + 10050];\n\tif (ret.first !\u003d -1) return ret;\n\n\t// this bottle will not be used, so take the cola in it to pour it in some other bottle\n\tpair\u0026lt;ll, ll\u0026gt; c1 \u003d dp(i + 1, space - a[i]); c1.second +\u003d a[i];\n\t// this bottle will be used, so we have extra space to use\n\tpair\u0026lt;ll, ll\u0026gt; c2 \u003d dp(i + 1, space + (b[i] - a[i])); c2.first++;\n\n\tif (c1.first \u0026lt; c2.first) return ret \u003d c1;\n\telse if (c2.first \u0026lt; c1.first) return ret \u003d c2;\n\telse{ // if bottles count is equal, then check by the time needed\n\t\tif (c1.second \u0026lt; c2.second) return ret \u003d c1;\n\t\telse return ret \u003d c2;\n\t}\n}\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tfor (int i \u003d 0; i \u0026lt; 111; i++) for (int j \u003d 0; j \u0026lt; 20100; j++) memo[i][j] \u003d make_pair(-1, -1);\n\tcin \u0026gt;\u0026gt; n;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i];\n\tfor (int j \u003d 0; j \u0026lt; n; j++) cin \u0026gt;\u0026gt; b[j];\n\tcout \u0026lt;\u0026lt; dp(0, 0).first \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; dp(0, 0).second \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214186/problem/Yellow\"\u003eYellow — The Two Routes\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eBFS\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThey told us that any pair of cities is connected by either a railway road, or a simple road. This means that the starting city and the ending city are connected by either a railway road or a simple road. This means that either the car or train can get to the final city in just one step, while the other one will need a BFS code to determine the minimum amount of time needed to get to the final city using its according roads. \u003c/p\u003e\u003cp\u003eNote that this observation means that the condition saying that the car and train can\u0027t be in same city at the same time other than the last city is meaningless (because either the train or car will take the direct road, leaving the city it self for the other one).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(m)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint n, m;\nvector\u0026lt;int\u0026gt; G[100100];\nint dist[100100];\nset\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; railwayEdges;\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tint directRailway \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; m; i++){\n\t\tint a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\t\trailwayEdges.insert(make_pair(a, b));\n\t\trailwayEdges.insert(make_pair(b, a));\n\t\tif (a \u003d\u003d 1 \u0026amp;\u0026amp; b \u003d\u003d n) directRailway \u003d 1;\n\t\telse if (a \u003d\u003d n \u0026amp;\u0026amp; b \u003d\u003d 1) directRailway \u003d 1;\n\t}\n\tfor (int i \u003d 1; i \u0026lt;\u003d n; i++){\n\t\tfor (int j \u003d 1; j \u0026lt;\u003d n; j++){\n\t\t\tif (i \u003d\u003d j) continue;\n\t\t\tif (directRailway \u0026amp;\u0026amp; railwayEdges.count(make_pair(i, j)) \u003d\u003d 0) G[i].push_back(j), G[j].push_back(i);\n\t\t\tif (!directRailway \u0026amp;\u0026amp; railwayEdges.count(make_pair(i, j)) \u003d\u003d 1) G[i].push_back(j), G[j].push_back(i);\n\t\t}\n\t}\n\tmemset(dist, -1, sizeof dist);\n\tqueue\u0026lt;pair\u0026lt;ll, ll\u0026gt; \u0026gt; q;\n\tq.push(make_pair(1, 0)), dist[1] \u003d 0;\n\twhile (!q.empty()){\n\t\tll node \u003d q.front().first, steps \u003d q.front().second;\n\t\tq.pop();\n\n\t\tfor (int i \u003d 0; i \u0026lt; G[node].size(); i++){\n\t\t\tint nxt \u003d G[node][i];\n\t\t\tif (dist[nxt] !\u003d -1) continue;\n\t\t\tdist[nxt] \u003d steps + 1;\n\t\t\tq.push(make_pair(nxt, steps + 1));\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; dist[n] \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}