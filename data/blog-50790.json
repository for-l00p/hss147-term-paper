{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1488551065,"rating":0,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1488555687,"id":50790,"title":"\u003cp\u003eSolutions to Codeforces Beta Round #26, A, B, C\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA. Almost Prime\u003c/p\u003e\u003cp\u003eThis problem can be viewed as a special case of a more general problem, which asks to find the number of prime divisors for some given positive integer N. In general, N can be written as N\u003d(p1^n1)*(p2^n2)*(p3^n3)*..., which is well known as \u0026quot;Fundamental Theorem of Arithmetic\u0026quot;, where pi is a prime divisor. Thus, we can test from 2 to N-1, and whenever a prime divisor pi is found, we just keep dividing N by pi and update N as N\u003dN/pi, until the updated N is not a multiple of pi. Meanwhile, we count the number of different pi, and if the result is two, it means that N is almost prime. Note that when we enumerate from 2 to N-1, it is guaranteed that only the prime divisor of N will be counted. To prove this, suppose that an integer M which is a divisor of N but not a prime oneis found. Then, M can be written as M\u003d(p1^m1)*(p2^m2)*... As we enumerate the divisors from smaller ones to larger ones, pi must have been found before M is reached, so that M cannot serve as a divisor of N, which is contradictory to our assumption.\u003c/p\u003e\u003cp\u003eB. Suppose that we enumerate the bracket sequence from left to right. A pair of reasonable (or regular) bracket will be found whenever we meet a \u0027)\u0027, under the condition that at least one \u0027(\u0027 has been met before. As this \u0027)\u0027 should be paired with the \u0026quot;nearest\u0026quot; \u0027(\u0027, this \u0027(\u0027 cannot be used to pair with the following \u0027)\u0027. The above process can be simply implemented by keeping a variable \u0027B\u0027 to store the number of currently unpaired \u0027(\u0027, and when a \u0027(\u0027 is met, we add B by one while subtracting it by one if \u0027)\u0027 is met. However, one should be careful that when B\u003d0, no subtraction should be implemented, since this situation implies that no \u0027(\u0027 is available to be paired with the currently met \u0027)\u0027. The problem can be solved by doubling the number of subtraction implemented to B as the final answer.\u003c/p\u003e\u003cp\u003eC. Parquet\u003c/p\u003e\u003cp\u003eAt first, we try to figure out whether it is possible or impossible, and we can consider the following four cases.\u003c/p\u003e\u003cp\u003e1) Both m and n are odd numbers. It is straightforward that the answer is impossible, since every kind of plank will contribute 2 or 4 meters, and thus it is impossible to perfectly cover a floor which has a size of odd number;\u003c/p\u003e\u003cp\u003e2) m is an odd number while n is an even number. Let us focus on one single row, and suppose that we only use planks with 1*2 and 2*2 sizes. Note that it will always contribute 2 meters to the current row whenevere we use a plank with 1*2 or 2*2 size to cover it. Therefore, we have to use at least one plank with 2*1 size if we want to cover the current row perfectly. As a 2*1 size can cover two rows, we need at least n/2 planks with 2*1 size. Therefore, if the number of planks with size 2*1 is less than n/2, the answer will be impossible; otherwise it might be possible (not surely). Furthermore, if it is possible, we can first put n/2 planks with size 2*1 at the last column, without loss of generality. Then, m becomes m-1, which is an even number, and it turns out to be the same as case 4);\u003c/p\u003e\u003cp\u003e3) m is an even number but n is an odd number. As in case 2), we apply similar arguments and will find that if the number of planks with size 1*2 is less than m/2, it is impossible to cover the whole floor perfectly; otherwise, it might be possible. Furthermore, we can put m/2 planks with size 1*2 first, and turn it into case 4) again;\u003c/p\u003e\u003cp\u003e4) Both m and n are even numbers. We can solve the problem in such a manner: \u003c/p\u003e\u003cp\u003estep 1: we put planks with size 2*2 from the upper left corner of the floor first to the right bottom corner; if the number of such planks is sufficient to cover the whole floor, then we are done; otherwise, we go to step 2;\u003c/p\u003e\u003cp\u003estep 2: we combine two planks with size 1*2 to form a virtual plank with size 2*2, and continue as step 1 indicates; if the whole floor is covered, then we are done; otherwise go to step 3;\u003c/p\u003e\u003cp\u003estep 3: we combine two planks with size 2*1 to form a virtual plank with size 2*2, and continue as step 1 indicates; if the whole floor is covered, then we are done; otherwise it means that the answer is impossible.\u003c/p\u003e\u003cp\u003eI think that the above steps will work efficiently and correctly, but I cannot figure out how to prove it... Except for this, I find it not quite easy to provide a pattern explicitly (as the problem asks) which can cover the floow perfectly. I adopt a rather complicated method. I start from the upper left point and implement the above several steps, and whenever I put down a plank, I will check the \u0026quot;indicators\u0026quot; (letters with lower case, suhc as \u0027a\u0027, \u0027b\u0027, etc.) of the adjacent points, and as there will be at most 8 adjacent points, it is always feasible to select a letter that can be used to indicate the current plank. However, this is somehow very complicated....If anyone has any better solutions, it is very nice for you to share your ideas.\u003c/p\u003e\u003c/div\u003e","tags":[]}}