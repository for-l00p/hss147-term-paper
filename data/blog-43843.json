{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1458225851,"rating":0,"authorHandle":"HellKitsune","modificationTimeSeconds":1459247654,"id":43843,"title":"\u003cp\u003eТипы данных, операции, контейнеры C++\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eТипы данных\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЦелочисленные:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eshort — от -2^15 до 2^15 — 1\u003c/li\u003e   \u003cli\u003eint — от -2^31 до 2^31 — 1\u003c/li\u003e   \u003cli\u003elong long — от -2^63 до 2^63 — 1\u003c/li\u003e   \u003cli\u003eunsigned short — от 0 до 2^16 — 1\u003c/li\u003e   \u003cli\u003eunsigned int — от 0 до 2^32 — 1\u003c/li\u003e   \u003cli\u003eunsigned long long — от 0 до 2^64 — 1\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eС плавающей точкой:\u003c/p\u003e \u003cul\u003e   \u003cli\u003edouble\u003c/li\u003e   \u003cli\u003efloat — работает немного быстрее double, но гораздо менее точен, не рекомендуется к использованию на олимпиадах\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eОперации\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e/ и % — деление и взятие остатка от деления. При делении целого на целое, результат так же целый, во всех остальных случаях нет. 3 / 2 \u003d 1, в то время как 3.0 / 2 \u003d 1.5 и 3 / 2.0 \u003d 1.5. Брать остаток от деления можно только для целых чисел.\u003c/p\u003e\u003cp\u003ei +\u003d 2 — добавить 2 к переменной i, то же самое, что i \u003d i + 2 (аналогично i *\u003d 2, i /\u003d 2, i %\u003d 2, i -\u003d 2)\u003c/p\u003e\u003cp\u003e++i, i++ — добавить единицу к i\u003c/p\u003e\u003cp\u003eРазница между префиксным и постфиксным ++ в порядке выполнения операций. Например:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ei \u003d 0;\nif (++i \u003d\u003d 1) {\n    cout \u0026lt;\u0026lt; \u0026quot;YES\u0026quot; \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЭтот код выведет YES, в то время как i++ \u003d\u003d 1 сработало бы не так. Сначала выполнилось бы сравнение, и только затем к i добавилась бы единица.\u003c/p\u003e\u003cp\u003eТо же самое для --i и i--.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eКонтейнеры\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВ C++ есть стандартные контейнеры для хранения данных. Далее некоторые из них с примерами использования.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint main() {\n    vector\u0026lt;int\u0026gt; v; //динамически расширяемый массив\n    v.push_back(3); //дописать в конец вектора число 3\n    v.push_back(5);\n    v.push_back(7);\n    cout \u0026lt;\u0026lt; v[0] \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; v[1] \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; v[2] \u0026lt;\u0026lt; endl; //выведет 3 5 7\n    v.clear(); //очистить вектор\n    v.assign(100000, 11); //расширить вектор до 100000 элементов, каждому из которых присвоить 11\n    cout \u0026lt;\u0026lt; v[99999] \u0026lt;\u0026lt; endl; //выведет 11\n\n    queue\u0026lt;int\u0026gt; q; //очередь\n    //к очереди можно дописывать элементы в конец, и забирать элементы из начала\n    q.push(13);\n    q.push(14);\n    q.push(15);\n    while (!q.empty()) { //пока очередь не пуста\n        int value \u003d q.front(); //взять значение из начала очереди\n        cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0027 \u0027;\n        q.pop(); //удалить первый элемент очереди\n    }\n    cout \u0026lt;\u0026lt; endl;\n    //на выводе будет 13 14 15\n\n    stack\u0026lt;int\u0026gt; st; //стэк\n    //к стэку можно дописывать элементы в конец, и забирать элементы с конца\n    st.push(13);\n    st.push(14);\n    st.push(15);\n    while (!st.empty()) { //пока стэк не пуст\n        int value \u003d st.top(); //достать элемент \u0026quot;сверху\u0026quot; стэка\n        cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0027 \u0027;\n        st.pop(); //удалить верхний элемент стэка\n    }\n    cout \u0026lt;\u0026lt; endl;\n    //на выводе будет 15 14 13\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}