{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1482321914,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1482361781,"id":49213,"title":"\u003cp\u003eLambda \u0026amp; Streams\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eКод и некоторое количество \u0026quot;теории\u0026quot; по лямбда выражениям и потокам данных (stream). \u003cbr /\u003e Код примера с отбором товарищей из списка по возрасту (наименования полей могут немного отличаться от лекции, возможно, присутствуют дополнительные поля, но на суть дела это влияния не оказывает)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\n\npublic class LambdaDemo1 {\n\n    public static void main(String[] args) {\n        PersonListUser plu \u003d new PersonListUser(new PersonList());\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v1 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v1(20);\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v2 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v2(20);\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v3 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v3(20);\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v4 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v4(20);\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v5 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v5(20);\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v6 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v6(20);\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v7 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v7(20);\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v8 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v8(20);\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v9 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v9(20);\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v10 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v10(20);\n        System.out.println(\u0026quot;\u003d\u003d\u003d\u003d\u003d v11 \u003d\u003d\u003d\u003d\u003d\u0026quot;);\n        plu.printToAge_v11(20);\n    }\n\n}\n\nclass PersonList {\n    \n    static class Person {\n        \n        Person(String name, int age, char g){\n            this.name \u003d name;\n            this.age \u003d age;\n            switch (g) {\n            case \u0027m\u0027: case \u0027M\u0027: gender \u003d Gender.MALE; break;\n            case \u0027f\u0027: case \u0027F\u0027: gender \u003d Gender.FEMALE; break;\n            default: gender \u003d Gender.NOTSPECIFIED;\n            }\n            emailAddress \u003d null;\n        }\n\n        Person(String name, int age, char g, String emailAddress){\n            this.name \u003d name;\n            this.age \u003d age;\n            switch (g) {\n            case \u0027m\u0027: case \u0027M\u0027: gender \u003d Gender.MALE; break;\n            case \u0027f\u0027: case \u0027F\u0027: gender \u003d Gender.FEMALE; break;\n            default: gender \u003d Gender.NOTSPECIFIED;\n            }\n            this.emailAddress \u003d emailAddress;\n        }\n\n        public String toString(){\n            return name + \u0026quot;, \u0026quot; + age +  \n                    ((gender !\u003d Gender.NOTSPECIFIED)? ((gender \u003d\u003d Gender.MALE)? \u0026quot;, male\u0026quot;: \u0026quot;, female\u0026quot;): \u0026quot;\u0026quot;) +\n                    ((emailAddress !\u003d null)? \u0026quot;, \u0026quot; +emailAddress: \u0026quot;\u0026quot;);\n        }\n        \n        String shortInfo() {\n            return name + \u0026quot;, \u0026quot; + age;\n        }\n        \n        int getAge(){\n            return age;\n        }\n        \n        String getNameMail(){\n            return name + \u0026quot;: \u0026quot; + emailAddress;\n        }\n        \n        static enum Gender{\n            MALE, FEMALE, NOTSPECIFIED\n        }\n        \n        String name;\n        int age;\n        Gender gender;\n        String emailAddress;\n    }\n    \n    PersonList() {\n        plst \u003d new ArrayList\u0026lt;\u0026gt;();\n        plst.add(new Person(\u0026quot;Alice\u0026quot;, 19, \u0027f\u0027));\n        plst.add(new Person(\u0026quot;Bob\u0026quot;, 20, \u0027m\u0027, \u0026quot;bob123@mail.com\u0026quot;));\n        plst.add(new Person(\u0026quot;Christin\u0026quot;, 21, \u0027f\u0027, \u0026quot;ch15@yz.com\u0026quot;));\n        plst.add(new Person(\u0026quot;Donald\u0026quot;, 18, \u0027z\u0027));\n        plst.add(new Person(\u0026quot;Edvard\u0026quot;, 19, \u0027m\u0027));\n        plst.add(new Person(\u0026quot;Ann\u0026quot;, 20, \u0027z\u0027, \u0026quot;annemail\u0026quot;));\n        plst.add(new Person(\u0026quot;Alan\u0026quot;, 22, \u0027m\u0027, \u0026quot;kh@amazon.com\u0026quot;));\n        plst.add(new Person(\u0026quot;Sarah\u0026quot;, 18, \u0027f\u0027));\n    }\n    \n    void addLast(Person p){\n        plst.add(p);\n    }\n        \n    void printList(PrintStream out) {\n        for (Person p: plst) {\n            out.println(p.toString());\n        }\n    }\n    \n    void printShortList(PrintStream out){\n        for (Person p: plst){\n            out.println(p.shortInfo());\n        }\n    }\n    \n    void printUpToAge(PrintStream out, int age) {\n        for (Person p: plst){\n            if (p.age \u0026lt;\u003d age){\n                out.println(p.name);\n            }\n        }\n    }\n    \n    void printInAgeRange(PrintStream out, int low, int high) {\n        for (Person p: plst){\n            if ((low \u0026lt;\u003d p.age) \u0026amp;\u0026amp; (p.age \u0026lt;\u003d high)){\n                out.println(p.name);\n            }\n        }\n    }\n        \n    void printSelectPerson_v1(PrintStream out, CheckPerson checker){\n        for (Person p: plst) {\n            if (checker.test(p)){\n                out.println(p.name);\n            }\n        }\n    }\n\n    void printSelectPerson_v2(PrintStream out, Predicate\u0026lt;Person\u0026gt; tester){\n        for (Person p: plst){\n            if (tester.test(p)){\n                out.println(p.name);\n            }\n        }\n    }\n    \n    void processSelectPerson_v3(Predicate\u0026lt;Person\u0026gt; tester, Consumer\u0026lt;Person\u0026gt; handler){\n        for (Person p: plst){\n            if (tester.test(p)){\n                handler.accept(p);\n            }\n        }\n    }\n    \n    void processSelectPersonData_v1(Predicate\u0026lt;Person\u0026gt; tester, Function\u0026lt;Person, String\u0026gt; getdata, Consumer\u0026lt;String\u0026gt; handler){\n        for (Person p: plst){\n            if (tester.test(p)){\n                String data \u003d getdata.apply(p);\n                handler.accept(data);\n            }\n        }\n    }\n    \n    void processSelectPersonData_v2(int age){\n        plst.stream()\n            .filter(p -\u0026gt; p.age \u0026lt;\u003d age)\n            .map(Person::getNameMail)\n            .forEach(System.out::println);\n    }\n    \n    List\u0026lt;Person\u0026gt; plst;\n}\n\ninterface CheckPerson {\n    \n    boolean test(PersonList.Person p);\n    \n}\n\n\nclass TestUpToAge implements CheckPerson {\n    \n    TestUpToAge(int uta) {\n        upToAge \u003d uta;\n    }\n    \n    public boolean test(PersonList.Person p){\n        if (p.age \u0026lt;\u003d upToAge) return true;\n        return false;\n    }\n    \n    int upToAge;\n}\n\nclass PersonListUser {\n    \n    PersonListUser(PersonList pl){\n        personList \u003d pl;\n    }\n    \n    void printToAge_v1(int age){\n        personList.printUpToAge(System.out, age);\n    }\n    \n    void printToAge_v2(int age){\n        TestUpToAge tuta \u003d new TestUpToAge(age);\n        personList.printSelectPerson_v1(System.out, tuta);\n    }\n    \n    void printToAge_v3(int age){\n        personList.printSelectPerson_v1(System.out, new TestUpToAge(age));\n    }\n    \n    void printToAge_v4(int age){\n        personList.printSelectPerson_v1(System.out, new CheckPerson() {\n            public boolean test(PersonList.Person p){\n                if(p.age \u0026lt;\u003d age) return true;\n                return false;\n            }\n        });\n    }\n    \n    void printToAge_v5(int age){\n        personList.printSelectPerson_v1(System.out, \n                (PersonList.Person p) -\u0026gt; (p.age \u0026lt;\u003d age));\n    }\n    \n    void printToAge_v6(int age){\n        personList.printSelectPerson_v2(System.out, \n                new Predicate\u0026lt;PersonList.Person\u0026gt;() {\n                    public boolean test(PersonList.Person p){\n                        if (p.age \u0026lt;\u003d age) return true;\n                        return false;\n                    }\n                });\n    }\n    \n    void printToAge_v7(int age){\n        personList.printSelectPerson_v2(System.out, \n                (PersonList.Person p) -\u0026gt; (p.age \u0026lt;\u003d age));\n        \n    }\n    \n    void printToAge_v8(int age){\n        personList.processSelectPerson_v3(\n                (PersonList.Person p) -\u0026gt; (p.age \u0026lt;\u003d age), \n                (PersonList.Person p) -\u0026gt; System.out.println(p.name));\n    }\n    \n    void printToAge_v9(int age){\n        personList.processSelectPersonData_v1(\n                p -\u0026gt; (p.age \u0026lt;\u003d age), \n                p -\u0026gt; p.getNameMail(), \n                email -\u0026gt; System.out.println(email));\n    }\n    \n    void printToAge_v10(int age){\n        personList.processSelectPersonData_v1(\n                p -\u0026gt; (p.age \u0026lt;\u003d age), \n                PersonList.Person::getNameMail, \n                System.out::println);\n    }\n    \n    void printToAge_v11(int age){\n        personList.processSelectPersonData_v2(age);\n    }\n    \n    PersonList personList;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПоследний метод демонстрирует использование потоков (stream). \u003c/p\u003e\u003cp\u003eБолее подробный пример с использованием stream ниже. \u003cbr /\u003e Основной источник материалов к примеру и небольшому описанию лямбда-выражений, функциональных интерфейсов и потоков данных — лекция из курса по Java на stepik.org (\u0026quot;Java. Базовый курс\u0026quot;, \u003ca href\u003d\"https://stepik.org/course/Java-%D0%91%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B9-%D0%BA%D1%83%D1%80%D1%81-187/syllabus?module\u003d6\"\u003e6 часть\u003c/a\u003e).\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e\u003cbr /\u003eimport java.math.BigInteger;\nimport java.util.Comparator;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntUnaryOperator;\nimport java.util.stream.IntStream;\n\npublic class TestStream {\n\n    public static void main(String[] args) {\n        ProbeFI pfi \u003d new ProbeFI();\n        pfi.effi();\n        pfi.stfi();\n        pfi.cmpfi();\n        pfi.opttest();\n        \n        ProbeStream ps \u003d new ProbeStream();\n        ps.demo1();\n        ps.demo2();\n        ps.testFP();\n    }\n\n}\n\nclass ProbeFI {\n    \n    void effi() {\n        int added \u003d 10;\n        IntUnaryOperator adder \u003d x -\u0026gt; x + added;\n        \n        System.out.println(adder.applyAsInt(5));\n        \n        //added++;\n        \n        int [] counter \u003d new int[] {0};\n        IntSupplier seq \u003d () -\u0026gt; counter[0]++;\n        seq.getAsInt();\n        System.out.println(counter[0]);\n        \n    }\n    \n    void stfi() {\n        IntPredicate isOdd \u003d x -\u0026gt; x % 2 !\u003d 0;\n        IntPredicate isEven \u003d isOdd.negate();\n        IntPredicate cmb \u003d isOdd.or(isEven);\n        System.out.println(cmb.test(5));\n    }\n    \n    void cmpfi() {\n        Function\u0026lt;Double, Double\u0026gt; sinx \u003d Math::sin;\n        Function\u0026lt;Double, Double\u0026gt; square \u003d x -\u0026gt; x*x;\n        Function\u0026lt;Double, Double\u0026gt; first \u003d sinx.andThen(square);\n        Function\u0026lt;Double, Double\u0026gt; second \u003d sinx.compose(square);\n        \n        Comparator\u0026lt;Double\u0026gt; absValCmp \u003d Comparator.comparing(Math::abs, Double::compare);\n        double f \u003d first.apply(Math.PI/8);\n        double s \u003d second.apply(Math.PI/8);\n        if (absValCmp.compare(f, s) \u0026lt; 0){\n            System.out.println(f + \u0026quot; \u0026quot; + s);\n        }\n        else {\n            System.out.println(\u0026quot;!\u0026quot; + s + \u0026quot; \u0026quot; + f);\n        }\n    }\n    \n    void opttest() {\n        String str \u003d \u0026quot;text\u0026quot;;\n        Optional\u0026lt;String\u0026gt; optstr \u003d Optional.of(\u0026quot;text\u0026quot;);\n        \n        optstr.ifPresent(System.out::println);\n        \n        optstr \u003d Optional.empty();\n        str \u003d optstr.orElse(\u0026quot;test\u0026quot;);\n        System.out.println(str);\n    }\n    \n}\n\nclass ProbeStream {\n    \n    void demo1() {\n        int sum \u003d IntStream.iterate(1, n -\u0026gt; n+1)\n                           .filter(n -\u0026gt; n % 5 \u003d\u003d 0 \u0026amp;\u0026amp; n % 2 !\u003d 0)\n                           .limit(10)\n                           .map(n -\u0026gt; n*n)\n                           .sum();\n        System.out.println(sum);\n    }\n    \n    \n    void demo2() {\n        IntFunction\u0026lt;Character\u0026gt; ci \u003d c -\u0026gt; Character.toChars(c)[0];\n        System.out.println(ci.apply(48));\n        \n        IntStream ist \u003d IntStream.iterate(1, x -\u0026gt; x + 1);\n        ist\n           .map(x -\u0026gt; x*x*x)\n           .filter(n -\u0026gt; n \u0026gt; 500)\n           .mapToObj(Integer::toString)\n           .flatMapToInt(s -\u0026gt; s.chars())           \n           .distinct()           \n           .mapToObj(ci)\n           .skip(3)           \n           .limit(2) \n           .sorted()\n           .forEach(System.out::println);\n           \n    }\n    \n    \n    BigInteger factBI (int n) {\n            return IntStream.rangeClosed(1, n)\n                            .mapToObj(i -\u0026gt; BigInteger.valueOf(i))\n                            .reduce(BigInteger.ONE, BigInteger::multiply);\n    }\n    \n     boolean isPalindrome(String s) {\n             StringBuilder leftToRight \u003d new StringBuilder();\n             \n             s.chars().filter(Character::isLetterOrDigit)\n                      .map(Character::toLowerCase)\n                      .forEach(leftToRight::appendCodePoint);\n            \n             StringBuilder rightToLeft \u003d new StringBuilder(leftToRight).reverse();\n             \n             return leftToRight.toString().equals(rightToLeft.toString());                 \n     }\n    \n     void testFP(){\n         System.out.println(factBI(8));\n         System.out.println(isPalindrome(\u0026quot;A Roza upala na lapu Azora\u0026quot;));\n     }\n    \n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eФункциональные интерфейсы — интерфейсы, которые содержат единственный абстрактный метод. При этом интерфейсы могут содержать статические методы и поля (в любых количествах, это не влияет на их \u0026quot;функциональность\u0026quot;). \u003cbr /\u003e Функциональные интерфейсы помечаются аннотацией \u003ccode\u003e@FunctionalInterface\u003c/code\u003e. Описаны они в пакете java.util.function. Все функциональные интерфейсы могут быть параметризованы любым объектным типом, а для примитивных типов существуют специализированные функциональные интерфейсы (некоторые из них мы будем упоминать далее).\u003c/p\u003e\u003cp\u003eВсего функциональных интерфейсов более четырех десятков, и их можно поделить на пять групп. Коротко о группах:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eConsumer (потребитель); имеет метод, который что-то принимает, но ничего не возвращает (в случае одного параметра — void accept(T t), в случае двух параметров — BiConsumer\u0026lt;T, U\u0026gt;, метод void accept (T t, U u); для примитивных типов — IntConsumer, LongConsumer, DoubleConsumer)\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eSupplier (поставщик); имеет метод, который ничего не принимает, но возвращает некое значение (метод T get()) (для примитивных типов BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier).\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003ePredicate (предикат); имеет метод, который что-то принимает, а возвращает значение булева типа (в случае одного параметра — boolean test(T t), в случае двух параметров — BiPredicate\u0026lt;T, U\u0026gt; и boolean test(T t, U u) соответственно; для примитивных типов — IntPredicate, LongPredicate, DoublePredicate).\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eFunction\u0026lt;T, R\u0026gt; (функция); имеет метод, принимающий аргумент одного типа (T) и возвращающий значение другого типа (R) (в случае одного параметра — R apply(T t), в случае двух параметров BiFunction\u0026lt;T, U, R\u0026gt; и R apply (T t, U u); для примитивных типов есть разные конструкции — в зависимости от того, является ли примитивным типом тип аргумента или / и тип результата: DoubleFunction (T apply(double d)), LongToIntFunction (int apply(long d)), ToIntFunction (int apply(T t)) и т.д.)\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eOperator (оператор); частный случай функции, когда аргумент и результат одного и того же типа (UnaryOperator, BinaryOperator\u0026lt;T, T\u0026gt;, а также интерфейсы для примитивных типов: IntUnaryOperator, IntBinaryOperator, LongUnaryOperator, LongBinaryOperator, DoubleUnaryOperator, DoubleBinaryOperator)\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eКак и \u0026quot;обычные\u0026quot; интерфейсы, функциональные интерфейсы можно реализовывать как в именованных, так и в анонимных классах. Однако то, что по сути необходимо реализовать единственный метод, позволяет отказаться от достаточно объемного кода классов и воспользоваться лямбда-выражениями. Примеры:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e    IntUnaryOperator square \u003d x -\u0026gt; x * x;\n\n    IntUnaryOperator cube \u003d x -\u0026gt; {return x * x * x;}\n\n    IntConsumerPrint print \u003d x -\u0026gt; System.out.print(x);\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ лямбда-выражениях могут использоваться и внешние по отношению к ним переменные, однако при этом переменная должна быть \u0026quot;эффективной константой\u0026quot;. Поясним это на фрагменте кода:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e  int add \u003d 10;\n  IntUnaryOperator adder \u003d x -\u0026gt; x + add;\n  add \u003d add + 1; // не скомпилируется\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЭто требование связано с поддержкой параллелизма — предполагается, что лямбда-выражения могут вычисляться параллельно, поэтому изменение значения переменной, используемой в них, может привести к нежелательным эффектам. Вообще говоря, такую переменную можно было бы сразу объявлять с модификатором final, предполагающим, что она не поменяет своего значения после инициализации. Однако в языке разрешено не указывать такой модификатор, если переменная де-факто не будет изменять своего значения.\u003c/p\u003e\u003cp\u003eОднако это требование может доставить определенные неудобства в тех случаях, когда лямбда-выражения удобно использовать для изменения переменных. Один из возможных \u0026quot;обходных путей\u0026quot; состоит в том, чтобы объявить массив, содержащий один элемент. Собственно переменная-массив будет эффективной константой (точнее, ссылка на массив), а вот содержимое элементов массива может меняться. \u003cbr /\u003e Пример кода:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e  int [] counter \u003d new int[] {0}; \n  IntSupplier seq \u003d () -\u0026gt; counter[0]++;\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ качестве лямбда-выражений могут также использоваться ссылки на методы (method references). Например:\u003c/p\u003e\u003cp\u003e\u003ccode\u003eConsumer\u0026lt;Object\u0026gt; printer \u003d System.out::println\u003c/code\u003e\u003c/p\u003e\u003cp\u003eПри этом, если метод статический, можно ссылаться на него через имя класса, а если нестатический — то через имя объекта (как в примере). Можно даже составить ссылку на конструктор, однако там имеются некоторые тонкости, о которых можно получить представление из документации и иных материалов (в том числе из уже упоминавшейся части 6 курса по Java на stepik.org)\u003c/p\u003e\u003cp\u003eВыше мы уже говорили, что помимо единственного абстрактного (нестатического) метода, функциональные интерфейсы могут иметь еще статические методы. Например, в группе интерфейсов-предикатов есть методы, реализующие привычные логические операции. Например:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e  IntPredicate isOdd \u003d x -\u0026gt; x % 2 !\u003d 0;\n  IntPredicate isEven \u003d isOdd.negate();\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНаряду с методом \u003ccode\u003enegate()\u003c/code\u003e также определены методы \u003ccode\u003eand()\u003c/code\u003e и \u003ccode\u003eor()\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eДля интерфейсов из группы Consumer\u0027ов определен метод \u003ccode\u003eandThen()\u003c/code\u003e, позволяющий выполнить сначала одно, а затем другое действие. Метод \u003ccode\u003eandThen()\u003c/code\u003e определен также и для интерфейсов-функций, но у этих интерфейсов есть еще метод \u003ccode\u003ecompose()\u003c/code\u003e, который сначала выполняет второе действие, а затем уже — первое. Пример применения описан в коде в методе \u003ccode\u003ecmpfi()\u003c/code\u003e (см. выше). Также рекомендуется обратить внимание на то, как в этом методе описан компаратор. Приведем более \u0026quot;привычную\u0026quot; запись этого компаратора:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e  Comparator\u0026lt;Double\u0026gt; absValComp \u003d \n     (a, b) -\u0026gt; Double.compare(Math.abs(a), Math.abs(b));\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТеперь несколько слов о \u0026quot;маленькой, но важной\u0026quot; вещи — типах Optional. Класс Optional — это своего рода \u0026quot;контейнер\u0026quot; для одного объекта типа T (какой положим). Что важно — объект в контейнере может отсутствовать; в Optional описан метод get(), который первым делом проверяет, не будет ли хранимое значение value \u003d\u003d null и, если там все же null, сгенерирует исключение.\u003c/p\u003e\u003cp\u003eПочему возникла потребность в таком типе? Когда есть некий объектный тип (например, тот же String), то бывает неочевидно (особенно в больших проектах), разрешено ли этому значению быть null (т.е. надо ли null как-то обрабатывать). До класса Optional каких-либо стандартных решений не было, в сторонних библиотеках предлагались решения в виде аннотаций @Nullable и @NonNull, но поскольку это именно сторонние библиотеки, компилятор о них не знал и отследить ничего не мог (т.е. не контролировал, скажем, присвоение null переменной, помеченной как @NonNull).\u003c/p\u003e\u003cp\u003eТипичное использование класса Optional продемонстрировано в методе \u003ccode\u003eopttest()\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eНаконец, поговорим о классе Stream (мы будем предпочитать англоязычное название, поскольку название \u0026quot;поток\u0026quot; уже весьма прочно закрепилось за thread). \u003c/p\u003e\u003cp\u003eКлассы Stream содержатся в пакете java.util.stream, все они — параметризуемые. Кроме собственно класса Stream еще есть классы IntStream, LongStream, DoubleStream, поддерживающие работу с соответствующими примитивными типами. \u003c/p\u003e\u003cp\u003eМожно рассматривать Stream как последовательность элементов, к которой можно применять разные преобразования (ко всей последовательности \u0026quot;одновременно\u0026quot;). \u003c/p\u003e\u003cp\u003eStream — не коллекция, где все элементы доступны по отдельности и можно оперировать каждым из них независимо. Stream предлагает рассматривать данные как \u0026quot;единый поток\u0026quot;, в котором ко всем элементам применяется одна и та же операция (есть детали, о них чуть позже). \u003cbr /\u003e В какой-то мере можно было бы сравнить Stream с итератором по коллекции, но итератор мало что умеет — просто ходить по коллекции и выдавать элементы. А у Stream много методов, он умеет с элементами работать, хотя и довольно специфически (с точки зрения человека, привыкшего к императивному программированию).\u003c/p\u003e\u003cp\u003eДалее, коллекция хранит некое конечное количество элементов, а Stream может быть потенциально бесконечным. \u003c/p\u003e\u003cp\u003eКоллекция позволяет изменять элементы и изменять свой собственный состав (удалять / добавлять элементы). А применение операции к Stream никак на него не влияет \u003c/p\u003e\u003cp\u003eПосмотрим на пример работы со stream из метода \u003ccode\u003edemo1()\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e    int sum \u003d IntStream.iterate(1, n -\u0026gt; n + 1)\n                       .filter(n -\u0026gt; n % 5 \u003d\u003d 0 \u0026amp;\u0026amp; n % 2 !\u003d 0)\n                       .limit(10)\n                       .map(n -\u0026gt; n*n) \n                       .sum();\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНазвания здесь \u0026quot;говорящие\u0026quot;. Сначала получаем собственно Stream — бесконечный ряд натуральных чисел (начало с 1, далее задано правило получения следующего элемента из предыдущего). \u003cbr /\u003e Заметим, что операции в stream\u0027ах — \u0026quot;ленивые\u0026quot;, т.е. пока не ясно, зачем что-то считать, ничего вычисляться не будет. Поэтому наш бесконечный ряд натуральных чисел не более, чем соглашение о намерениях. \u003c/p\u003e\u003cp\u003eДалее каждый метод в цепочке описывает какое-то преобразование над stream\u0027ом. Метод \u003ccode\u003efilter()\u003c/code\u003e, принимающий некий предикат, оставляет в stream\u0027е лишь те элементы, которые удовлетворяют условию. Далее метод \u003ccode\u003elimit()\u003c/code\u003e обрезает нашу \u0026quot;условно бесконечную\u0026quot; последовательность данных, оставляя в ней 10 первых элементов. Затем каждый из элементов потока заменяется его квадратом (метод \u003ccode\u003emap\u003c/code\u003e как раз выполняет это отображение).\u003c/p\u003e\u003cp\u003eНаконец, метод \u003ccode\u003esum()\u003c/code\u003e складывает все имеющиеся элементы потока (и формирует результат вычисления). Фактически именно этот метод дает старт вычислениям, до того никаких действий над элементами потока не производится.\u003c/p\u003e\u003cp\u003eОписание этого примера демонстрирует три этапа работы со stream:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eполучение stream\u0027а (т.е. собственно последовательности данных)\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eноль или более промежуточных операций преобразования (они просто запоминаются, но ничего не делается)\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eединственная терминальная операция, которая и запускает процесс вычислений.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eВажно понимать, что использовать терминальную операцию можно только один раз, после ее вызова stream более \u0026quot;непригоден к использованию\u0026quot;; если потребуется выполнить еще какую-либо терминальную операцию, stream понадобится создать заново.\u003c/p\u003e\u003cp\u003eВообще говоря, может понадобиться закрывать stream, вызвав его метод .close(). Однако если никаких системных ресурсов при работе stream\u0027а не выделялось, то вызов .close() не является обязательным (а если бы мы работали, например, с файлами, то это было бы нужно сделать).\u003c/p\u003e\u003cp\u003eНекоторые дополнения по каждому из этапов. \u003c/p\u003e\u003cp\u003eПо первому этапу. \u003c/p\u003e\u003cp\u003eПолучить stream можно из коллекции (или массива) при помощи метода stream(). Кроме него есть и другие методы, которые возвращают stream в качестве результата своей работы. Например, в классе \u003ccode\u003eBufferedReader\u003c/code\u003e есть метод \u003ccode\u003elines()\u003c/code\u003e, который возвращает поток из строк (более того, есть метод, позволяющий получить список директорий в виде потока); в классе \u003ccode\u003eString\u003c/code\u003e есть метод \u003ccode\u003echars()\u003c/code\u003e, который возвращает поток символов, однако в виде \u003ccode\u003eIntStream\u003c/code\u003e (потока CharStream не существует, как можно с этим \u0026quot;бороться\u0026quot; — показано в методе \u003ccode\u003edemo2()\u003c/code\u003e. \u003cbr /\u003e Также stream можно получить, задав правила формирования его элементов с помощью методов \u003ccode\u003egenerate()\u003c/code\u003e, \u003ccode\u003eiterate()\u003c/code\u003e (как в методе \u003ccode\u003edemo1()\u003c/code\u003e), \u003ccode\u003erange()\u003c/code\u003e, \u003ccode\u003erangeClosed()\u003c/code\u003e, определенных в некоторых классах \u0026quot;семейства\u0026quot; Stream, или просто явным образом перечислив его элементы (\u003ccode\u003eIntStream ist \u003d IntStream.of(2, 4, 6, 8);\u003c/code\u003e). \u003cbr /\u003e Это все еще не полный список способов получения stream. Следует добавить, что потоки можно соединять путем конкатенации. \u003c/p\u003e\u003cp\u003eПо второму этапу. \u003c/p\u003e\u003cp\u003eПосмотрим еще раз на метод \u003ccode\u003edemo2()\u003c/code\u003e, в котором использовано достаточно большое количество промежуточных операций (операций преобразования). \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e        ist\n           .map(x -\u0026gt; x*x*x)\n           .filter(n -\u0026gt; n \u0026gt; 500)\n           .mapToObj(Integer::toString)\n           .flatMapToInt(s -\u0026gt; s.chars())           \n           .distinct()           \n           .mapToObj(ci)\n           .skip(3)           \n           .limit(2) \n           .sorted()\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДадим краткие комментарии по поводу использованных методов (подробнее о них можно прочесть в документации / статьях / книгах).\u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003emap()\u003c/code\u003e заменяет каждый элемент потока так, как задано переданной функцией. В нашем случае происходит замена каждого элемента (а элементы — последовательно перечисленные натуральные числа) на его куб (куб числа, как очевидно, тоже число). Кроме того мы можем видеть метод \u003ccode\u003emapToObj()\u003c/code\u003e — он преобразует числа в их строковое представление, именно поэтому нам понадобился именно \u003ccode\u003emapToObj()\u003c/code\u003e, способный сопоставить элементам IntStream элементы другого (объектного) типа. \u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003eflatMapToInt()\u003c/code\u003e делает следующее: каждая строка — элемент stream (после выполнения \u003ccode\u003emapToObj()\u003c/code\u003e мы имеем дело уже со stream, состоящим из элементов типа String) — преобразуется в IntStream, состоящий из кодов символов, составляющих эту строку; после чего все полученные IntStream \u0026quot;склеиваются\u0026quot; в один. Метод \u003ccode\u003eflatMapToInt()\u003c/code\u003e присоединяет очередной полученный IntStream к концу уже имеющегося. \u003c/p\u003e\u003cp\u003eОбсуждая методы, связанные с отображением, мы не упомянули метод \u003ccode\u003efilter\u003c/code\u003e, однако, как представляется, его назначение вполне прояснилось еще из обсуждения метода \u003ccode\u003edemo1()\u003c/code\u003e: он оставляет в потоке лишь те элементы, которые удовлетворяют условию-предикату.\u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003edistinct()\u003c/code\u003e выбрасывает из потока повторяющиеся элементы.\u003c/p\u003e\u003cp\u003eЕще один вызов метода \u003ccode\u003emapToObj()\u003c/code\u003e позволяет нам получить целые числа вместо цифр в символьном представлении.\u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003eskip()\u003c/code\u003e пропускает указанное количество элементов из начала потока.\u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003elimit()\u003c/code\u003e ограничивает наш поток указанным количеством элементов.\u003c/p\u003e\u003cp\u003eНаконец, метод \u003ccode\u003esorted()\u003c/code\u003e упорядочивает содержимое потока \u0026quot;естественным образом\u0026quot; (для чисел \u0026quot;естественным образом\u0026quot; означает по возрастанию). \u003c/p\u003e\u003cp\u003eЗаметим, что есть еще не использованный здесь, но полезный метод \u003ccode\u003epeek()\u003c/code\u003e. Он принимает объект типа Consumer и показывает, что находится у нас в stream. Если передать в качестве такого объекта \u003ccode\u003eSystem.out::println\u003c/code\u003e, то метод будет выводить на экран \u0026quot;промежуточные результаты\u0026quot;. \u003c/p\u003e\u003cp\u003eПо третьему этапу.\u003c/p\u003e\u003cp\u003eМы уже использовали в примерах терминальные операции \u003ccode\u003esum()\u003c/code\u003e и \u003ccode\u003eforEach()\u003c/code\u003e. Их назначение очевидно: \u003ccode\u003esum()\u003c/code\u003e складывает все элементы потока, а \u003ccode\u003eforEach()\u003c/code\u003e выполняет указанную операцию над всеми элементами потока. \u003c/p\u003e\u003cp\u003eИмеется еще ряд терминальных операций, перечислим некоторые из них. \u003cbr /\u003e - Метод \u003ccode\u003efindFirst()\u003c/code\u003e возвращает первый (в порядке следования) элемент из stream (заметим, что возвращается элемент типа Optional, т.к. stream может быть пустой, и никакого элемента в нем нет. \u003cbr /\u003e - Метод \u003ccode\u003efindAny()\u003c/code\u003e возвращает какой-нибудь элемент из stream (не факт, что первый, но не исключено, что первый) \u003cbr /\u003e\u003cbr /\u003e- Метод \u003ccode\u003eallMatch()\u003c/code\u003e проверяет, что все элементы stream удовлетворяют условию, переданному в качестве предиката (т.е. результатом выполнения метода будет некоторое булево значение) \u003cbr /\u003e - Метод \u003ccode\u003eanyMatch()\u003c/code\u003e проверяет, что хотя бы один элемент удовлетворяет условию \u003cbr /\u003e - Метод \u003ccode\u003enoneMatch()\u003c/code\u003e проверяет, что ни один элемент не удовлетворяет условию  \u003cbr /\u003e - Методы \u003ccode\u003emin()\u003c/code\u003e и \u003ccode\u003emax()\u003c/code\u003e принимают в качестве параметра какой-либо компаратор и возвращают результат типа Optional, где T — тип, параметризующий stream \u003cbr /\u003e - Метод \u003ccode\u003ecount()\u003c/code\u003e возвращает количество элементов в stream \u003cbr /\u003e - Метод \u003ccode\u003ecollect()\u003c/code\u003e позволяет собрать элементы, полученные stream, в какую-то коллекцию, причем тип коллекции определяется параметром, передаваемым в \u003ccode\u003ecollect()\u003c/code\u003e. Например, \u003ccode\u003ecollect(Collectors.toList())\u003c/code\u003e позволит получить List. Заметим, что в классе Collectors есть многие \u0026quot;стандартные\u0026quot; коллекторы, а также метод .collector(), который может \u0026quot;собрать\u0026quot; элементы stream так, как потребуется. - Метод \u003ccode\u003ereduce()\u003c/code\u003e позволяет выполнить так называемую свертку, т.е. применить некоторую бинарную операцию к каждой паре элементов из stream. Применяться эта операция будет до тех пор, пока в stream не останется один элемент, и именно он станет результатом работы этого метода. Можно задать значение, которое будет возвращаться, если stream был пуст (некое \u0026quot;нулевое\u0026quot; значение), например:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e   Stream\u0026lt;BigInteger\u0026gt; bigInts \u003d ... // каким-то образом получили такой stream\n   BigInteger sum \u003d bigInts.reduce(BigInteger.ZERO, BigInteger::add);\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТакже в коде приведены два метода — \u003ccode\u003efactBI()\u003c/code\u003e и \u003ccode\u003eisPalindrome()\u003c/code\u003e — показывающие, как с помощью stream посчитать факториал и проверить, не является ли некоторая строка палиндромом. Примеры заимствованы из лекции А.Владыкина, на которую выше уже была ссылка.\u003c/p\u003e\u003cp\u003eКонечно, в данном обзорном материале мы лишь познакомились с лямбда-выражениями и классами Stream. Мы совершенно не затрагивали аспекты параллельного выполнения stream, особенности формирования ссылок на методы и ряд других вещей. Однако представляется, что данное введение в эту тему позволит при необходимости успешно разобраться в более сложных темах.\u003c/p\u003e\u003c/div\u003e","tags":["java","lambda","streams"]}}