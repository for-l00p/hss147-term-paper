{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1503834733,"rating":226,"authorHandle":"Nisiyama_Suzune","modificationTimeSeconds":1504289008,"id":54090,"title":"\u003cp\u003e[Tutorial] Math note — linear sieve\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThis short article is mainly focused on the linear sieve and its various applications in competitive programming, including a brief introduction on how to pick out primes and a way to calculate multiple values of multiplicative functions.\u003c/p\u003e\u003ch1\u003eSieve of Eratosthenes\u003c/h1\u003e\u003cp\u003eWhile this name may sound scary, \u003ca href\u003d\"https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\"\u003ethe sieve of Eratosthenes\u003c/a\u003e is probably the simplest way to pick out all the primes in a given range from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. As we already know, one of the properties that all primes have is that they do not have any factors except 1 and themselves. Therefore, if we cross out all composites, which have at least one factor, we can obtain all primes. The following code demonstrates a simple implementation of the said algorithm:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estd::vector \u0026lt;int\u0026gt; prime;\nbool is_composite[MAXN];\n\nvoid sieve (int n) {\n\tstd::fill (is_composite, is_composite + n, false);\n\tfor (int i \u003d 2; i \u0026lt; n; ++i) {\n\t\tif (!is_composite[i]) prime.push_back (i);\n\t\tfor (int j \u003d 2; i * j \u0026lt; n; ++j)\n\t\t\tis_composite[i * j] \u003d true;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs we can see, the statement \u003ccode\u003eis_composite[i * j] \u003d true;\u003c/code\u003e crosses out all numbers that do have a factor, as they are all composites. All remaining numbers, therefore, should be prime. We then check for those primes and put them into a container named \u003ccode\u003eprime\u003c/code\u003e.\u003c/p\u003e\u003ch1\u003eLinear sieve\u003c/h1\u003e\u003cp\u003eIt can be analyzed that the method above runs in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e complexity (with the \u003ca href\u003d\"https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant\"\u003eEuler–Mascheroni constant\u003c/a\u003e, i.e. \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/25/03/250332834d86f82258eb5c058e3afb0e2da37c5b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e). Let us take a minute to consider the bottleneck of such sieve. While we do need to cross out each composite once, in practice we run the inner loop for a composite multiple times due to the fact that it has multiple factors. Thus, if we can establish a unique representation for each composite and pick them out only once, our algorithm will be somewhat better. Actually it is possible to do so. Note that every composite \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e must have at least one prime factor, so we can pick the smallest prime factor \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e, and let the rest of the part be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, i.e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e \u003d \u003ci\u003eip\u003c/i\u003e\u003c/span\u003e. Since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is the smallest prime factor, we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e ≥ \u003ci\u003ep\u003c/i\u003e\u003c/span\u003e, and no prime less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e can divide \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Now let us take a look at the code we have a moment ago. When we loop for every \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, all primes not exceeding \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is already recorded in the container \u003ccode\u003eprime\u003c/code\u003e. Therefore, if we only loop for all elements in \u003ccode\u003eprime\u003c/code\u003e in the inner loop, breaking out when the element divides \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, we can pick out each composite exactly once.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estd::vector \u0026lt;int\u0026gt; prime;\nbool is_composite[MAXN];\n\nvoid sieve (int n) {\n\tstd::fill (is_composite, is_composite + n, false);\n\tfor (int i \u003d 2; i \u0026lt; n; ++i) {\n\t\tif (!is_composite[i]) prime.push_back (i);\n\t\tfor (int j \u003d 0; j \u0026lt; prime.size () \u0026amp;\u0026amp; i * prime[j] \u0026lt; n; ++j) {\n\t\t\tis_composite[i * prime[j]] \u003d true;\n\t\t\tif (i % prime[j] \u003d\u003d 0) break;\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs is shown in the code, the statement \u003ccode\u003eif (i % prime[j] \u003d\u003d 0) break;\u003c/code\u003e terminates the loop when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e divides \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. From the analysis above, we can see that the inner loop is executed only once for each composite. Hence, the code above performs in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e complexity, resulting in its name — the \u0027linear\u0027 sieve.\u003c/p\u003e\u003ch1\u003eMultiplicative function\u003c/h1\u003e\u003cp\u003eThere is one specific kind of function that shows importance in the study of number theory — the multiplicative function. By definition, A function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e defined on all positive integers is multiplicative if it satisfies the following condition:\u003c/p\u003e\u003cp\u003eFor every co-prime pair of integers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003epq\u003c/i\u003e) \u003d \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ep\u003c/i\u003e)\u003ci\u003ef\u003c/i\u003e(\u003ci\u003eq\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eApplying the definition, it can be shown that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e) \u003d \u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003ci\u003ef\u003c/i\u003e(1)\u003c/span\u003e. Thus, unless for every integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e) \u003d 0\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(1)\u003c/span\u003e must be \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Moreover, two multiplicative functions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e are identical if and only if for every prime \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and non-negative integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e) \u003d \u003ci\u003eg\u003c/i\u003e(\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e holds true. It can then be implied that for a multiplicative function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e, it will suffice to know about its representation in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe following functions are more or less commonly used multiplicative functions, according to \u003ca href\u003d\"https://en.wikipedia.org/wiki/Multiplicative_function\"\u003eWikipedia\u003c/a\u003e:\u003c/p\u003e \u003col\u003e   \u003cli\u003eThe constant function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eI\u003c/i\u003e(\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e) \u003d 1\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eThe power function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eId\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e) \u003d \u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eak\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e is constant.\u003c/li\u003e   \u003cli\u003eThe unit function \u003cspan class\u003d\"tex-span\"\u003eε(\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e) \u003d [\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e \u003d 1]\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eP\u003c/i\u003e]\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e is true, and \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e otherwise).\u003c/li\u003e   \u003cli\u003eThe divisor function \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9a/8e/9a8e85f82fa3922c4741d54591fa2a538171b513.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, denoting the sum of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e-th powers of all the positive divisors of the number.\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://en.wikipedia.org/wiki/M%C3%B6bius_function\"\u003eThe Möbius function\u003c/a\u003e \u003cspan class\u003d\"tex-span\"\u003eμ(\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e) \u003d [\u003ci\u003ek\u003c/i\u003e \u003d 0] - [\u003ci\u003ek\u003c/i\u003e \u003d 1]\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://en.wikipedia.org/wiki/Euler%27s_totient_function\"\u003eThe Euler\u0027s totient function\u003c/a\u003e \u003cspan class\u003d\"tex-span\"\u003eφ(\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e) \u003d \u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e - \u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eIt is interesting that the linear sieve can also be used to find out all the values of a multiplicative function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e in a given range \u003cspan class\u003d\"tex-span\"\u003e[1, \u003ci\u003en\u003c/i\u003e]\u003c/span\u003e. To do so, we have take a closer look in the code of the linear sieve. As we can see, every integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e will be picked out only once, and we must know one of the following property:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is prime. In this case, we can determine the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e directly.\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003eip\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e does not divide \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. In this case, we know that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ep\u003c/i\u003e)\u003c/span\u003e. Since both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ep\u003c/i\u003e)\u003c/span\u003e are already known before, we can simply multiply them together.\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003eip\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e divides \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. This is a more complicated case where we have to figure out a relationship between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003eip\u003c/i\u003e)\u003c/span\u003e. Fortunately, in most situations, a simple relationship between them exists. For example, in the Euler\u0027s totient function, we can easily infer that \u003cspan class\u003d\"tex-span\"\u003eφ(\u003ci\u003eip\u003c/i\u003e) \u003d \u003ci\u003ep\u003c/i\u003eφ(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eSince we can compute the function value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e satisfying any of the above property, we can simply modify the linear sieve to find out all values of the multiplicative function from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. The following code implements an example on the Euler\u0027s totient function.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estd::vector \u0026lt;int\u0026gt; prime;\nbool is_composite[MAXN];\nint phi[MAXN];\n\nvoid sieve (int n) {\n\tstd::fill (is_composite, is_composite + n, false);\n\tfor (int i \u003d 2; i \u0026lt; n; ++i) {\n\t\tif (!is_composite[i]) {\n\t\t\tprime.push_back (i);\n\t\t\tphi[i] \u003d i - 1;\t\t\t\t\t//i is prime\n\t\t}\n\t\tfor (int j \u003d 0; j \u0026lt; prime.size (); ++j) {\n\t\t\tis_composite[i * prime[j]] \u003d true;\n\t\t\tif (i % prime[j] \u003d\u003d 0) {\n\t\t\t\tphi[i * prime[j]] \u003d phi[i] * prime[j];\t//prime[j] divides i\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tphi[i * prime[j]] \u003d phi[i] * phi[prime[j]];\t//prime[j] does not divide i\n\t\t\t}\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eExtension on the linear sieve\u003c/h2\u003e\u003cp\u003eWell, it might not always be possible to find out a formula when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e divides \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. For instance, I can write some random multiplicative function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e) \u003d \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e which is difficult to infer a formula with. However, there is still a way to apply the linear sieve on such function. We can maintain a counter array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e denoting the power of the smallest prime factor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, and find a formula using the array since \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d9/92/d9920a54f2218009a7165d90d0d5439ad1c38f73.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. The following code gives an example on the function I\u0027ve just written.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estd::vector \u0026lt;int\u0026gt; prime;\nbool is_composite[MAXN];\nint func[MAXN], cnt[MAXN];\n\nvoid sieve (int n) {\n\tstd::fill (is_composite, is_composite + n, false);\n\tfor (int i \u003d 2; i \u0026lt; n; ++i) {\n\t\tif (!is_composite[i]) {\n\t\t\tprime.push_back (i);\n\t\t\tfunc[i] \u003d 1; cnt[i] \u003d 1;\n\t\t}\n\t\tfor (int j \u003d 0; j \u0026lt; prime.size (); ++j) {\n\t\t\tis_composite[i * prime[j]] \u003d true;\n\t\t\tif (i % prime[j] \u003d\u003d 0) {\n\t\t\t\tfunc[i * prime[j]] \u003d func[i] / cnt[i] * (cnt[i] + 1);\n\t\t\t\tcnt[i * prime[j]] \u003d cnt[i] + 1;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfunc[i * prime[j]] \u003d func[i] * func[prime[j]];\n\t\t\t\tcnt[i * prime[j]] \u003d 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch1\u003eExample problems\u003c/h1\u003e\u003ch2\u003eThe Embarrassed Cryptographer\u003c/h2\u003e\u003cp\u003e\u003ca href\u003d\"http://poj.org/problem?id\u003d2635\"\u003eLink\u003c/a\u003e\u003c/p\u003e\u003cp\u003eSolution: Simply applying the linear sieve will be enough.\u003c/p\u003e\u003ch2\u003eFarey Sequence\u003c/h2\u003e\u003cp\u003e\u003ca href\u003d\"http://poj.org/problem?id\u003d2478\"\u003eLink\u003c/a\u003e\u003c/p\u003e\u003cp\u003eSolution: Notice that \u003cspan class\u003d\"tex-span\"\u003eΔ \u003ci\u003eF\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e) \u003d \u003ci\u003eF\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e) - \u003ci\u003eF\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e - 1)\u003c/span\u003e is multiplicative and \u003cspan class\u003d\"tex-span\"\u003eΔ \u003ci\u003eF\u003c/i\u003e(\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e) \u003d \u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e - \u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e. Then the linear sieve will come in handy to solve the problem.\u003c/p\u003e\u003c/div\u003e","tags":["math","sieve","tutorial"]}}