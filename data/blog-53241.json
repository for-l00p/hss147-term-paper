{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1499782902,"rating":-8,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1499782937,"id":53241,"title":"\u003cp\u003eNotes on Codeforces Beta Round #60, , A, B, C (a nice problem to practice binary search based on float type), D\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/65/problem/A\" title\u003d\"Codeforces Beta Round 60\"\u003e65A - Harry Potter and Three Spells\u003c/a\u003e\u003c/p\u003e\u003cp\u003eOne should be very careful of this problem...If a*c*e\u0026lt;b*d*f, it is obvious that we can obtain infinite gold. Besides, if c\u003d0 and d\u0026gt;0, it implies that we can obtain infinite gold as well. Next, if a\u003d0 but all of b, c and d are not 0, we can still obtain infinite gold since we can first obtain infinite lead and thus convert all of them to gold.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/65/problem/B\" title\u003d\"Codeforces Beta Round 60\"\u003e65B - Harry Potter and the History of Magic\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis problem can be solved by adopting a greedy algorithm. We first introduce a variable Y which is initialized with value 1000, i.e., the minimum year that meets the requirements. Then, we enumerate the input integers in the given order. For each integer, we start with the current Y, and increase Y by 1 until it reaches 2011. During this process, we check whether we can convert this integer into Y by changing no more than one digit. If the answer is yes, we can immediately stop the loop and just replace this integer with the current value of Y, and store the current Y for the next loop which deals with the next integer; otherwise it means that there is no solution.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/65/problem/C\" title\u003d\"Codeforces Beta Round 60\"\u003e65C - Harry Potter and the Golden Snitch\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is a nice problem for practicing binary search as far as I consider. We can use binary search to search for the earliest time when they will meet. As the search is based on \u0026quot;float types\u0026quot;, it is better to limit the times of search to terminate the loop rather than adopting a small constant like /epsilon to check whether the answer has converged. \u003c/p\u003e\u003cp\u003eAt first we set t_l\u003d0 and t_r to be some sufficiently large value. Then, for each loop we will check whether they can meet at time t_m\u003d(t_l+t_r)/2 or not. With this t_m, we can first calculate the ranges that the player can reach, which turns out to be a circle. Therefore, the left work is to calculate the position of the ball at time t_m, and check whether it falls inside the circle or not. If it is inside the circle, it means that they can meet at some earlier time, and thus we should set t_r\u003dt_m for the next search; otherwise we should set t_l\u003dt_m. At time t_m, we can first compute the total distance that the ball has moved, and then we can find out the segment at which the ball will appear. With this result, we can further calculate the exact position (x,y,z) of the ball, and thus determine whether the ball is inside the circle or not.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/65/problem/D\" title\u003d\"Codeforces Beta Round 60\"\u003e65D - Harry Potter and the Sorting Hat\u003c/a\u003e\u003c/p\u003e\u003cp\u003eA straightforward solution is to enumerate all the possible final patterns, and thus find out the houses that one can select. This process can be simulated by building a tree, and each node denotes the current pattern while each branch denotes the letter given in the string. However, we might run into a severer situation due to the huge expansion of the tree. To alleviate this problem, we can adopt set\u0026lt; \u0026gt; in C++ STL, since some patterns are the same in the trees. As a simple example, suppose that we first meet ????. It can be seen that no matter what the intermediate states can be, they will finally reach the state (GHRS). As set\u0026lt; \u0026gt; produces an efficient way to delete the duplicate states, the total number of states that we have to visit can be significantly reduced. \u003c/p\u003e\u003c/div\u003e","tags":[]}}