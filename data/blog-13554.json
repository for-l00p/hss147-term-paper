{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1409049551,"rating":47,"authorHandle":"kien_coi_1997","modificationTimeSeconds":1409049551,"id":13554,"title":"\u003cp\u003eSegment tree with insert operator without using tree rotations\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI discovered a brand new approach to implement insert operator on segment tree.\u003c/p\u003e\u003ch2\u003e1. Advantages and disadvantages\u003c/h2\u003e\u003cp\u003eThere are following advantages:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eYou don\u0027t need to know what is tree rotation.\u003c/li\u003e   \u003cli\u003eRun extremely fast in weak tests / random test cases.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThere are following disadvantages:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eComplexity of each query is O(log^2 max(n)) (amortized)\u003c/li\u003e   \u003cli\u003eSource code is not shorter than source using balanced tree.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThis is example code for impatient people: \u003ca href\u003d\"http://paste.ubuntu.com/8148477/\"\u003ehttp://paste.ubuntu.com/8148477/\u003c/a\u003e\u003c/p\u003e\u003cp\u003eBecause of its complexity, I got TLE in this problem: \u003ca href\u003d\"http://www.spoj.com/problems/QMAX3VN/\"\u003ehttp://www.spoj.com/problems/QMAX3VN/\u003c/a\u003e\u003c/p\u003e\u003cp\u003eBefore coding this structure, I thought it will be short, but it is not. However, I want to share with you this structure because I think idea used inside this structure is nice.\u003c/p\u003e\u003ch2\u003e2. Properties\u003c/h2\u003e \u003cul\u003e   \u003cli\u003eSize of segment tree is fixed\u003c/li\u003e   \u003cli\u003eIn each node, we maintain two values Max and Count, if u is not leaf, \u003ccode\u003eMax[u]\u003dmax(Max[u*2], Max[u*2+1)\u003c/code\u003e, \u003ccode\u003eCount[u]\u003dCount[u*2]+Count[u*2+1]\u003c/code\u003e.\u003c/li\u003e   \u003cli\u003eDistance between two adjacent is quite long, for example: \u003ccode\u003e----100-----200-----300----\u003c/code\u003e where a \u003ccode\u003e-\u003c/code\u003e means unused space.\u003c/li\u003e   \u003cli\u003eThe longer distance between two adjacent elements were, the faster queries executed.\u003c/li\u003e \u003c/ul\u003e\u003ch2\u003e3. Insertion\u003c/h2\u003e\u003cp\u003eTo insert an element valued into k-th position (to be more precise operator insert(k, X) means insert X between (k-1)-th element and k-th element), we find a suitable space to put it in. If we can\u0027t find any space, re-arrange a node.\u003c/p\u003e\u003cp\u003eThis following example will make you understand.\u003c/p\u003e\u003cp\u003eFirstly, segment tree is empty:\u003c/p\u003e\u003cp\u003e\u003ccode\u003e-------------\u003c/code\u003e\u003c/p\u003e\u003cp\u003eInsert 1 5: we will insert 100 into middle position:\u003c/p\u003e\u003cp\u003e\u003ccode\u003e------5------\u003c/code\u003e\u003c/p\u003e\u003cp\u003eInsert 1 6: the most suitable position is 3rd position:\u003c/p\u003e\u003cp\u003e\u003ccode\u003e--6---5------\u003c/code\u003e\u003c/p\u003e\u003cp\u003eInsert 2 7: choose middle position between element 5 and element 6:\u003c/p\u003e\u003cp\u003e\u003ccode\u003e--6-7-5------\u003c/code\u003e\u003c/p\u003e\u003cp\u003eInsert 3 8: insert 8 between 7 and 5:\u003c/p\u003e\u003cp\u003e\u003ccode\u003e--6-785------\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eInsert 4 9\u003c/strong\u003e: we cannot insert 9 between 8 and 5 right now, we must rearrange a node. Let\u0027s imagine the tree:\u003c/p\u003e\u003cp\u003e\u003ccode\u003e((--6-)(785))((---)(---))\u003c/code\u003e\u003c/p\u003e\u003cp\u003eIt is impossible to insert 9 between 8 and 5 because node (785) is filled, we will \u003cstrong\u003erearrange\u003c/strong\u003e its parent — node ((--6-)(785)) — as follow:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eWrite its elements into a line: \u003ccode\u003e6, 7, 8, 5\u003c/code\u003e\u003c/li\u003e   \u003cli\u003eInsert 9 between 8 and 5: \u003ccode\u003e6, 7, 8, 9, 5\u003c/code\u003e\u003c/li\u003e   \u003cli\u003ePut elements in suitable places: \u003ccode\u003e-------\u003c/code\u003e -\u0026gt; \u003ccode\u003e-678-95\u003c/code\u003e, if we have more spaces, we will need to rearrange in order to distance between adjacent elements as large as possible, for example: \u003ccode\u003e-----------------------------\u003c/code\u003e -\u0026gt; \u003ccode\u003e----6----7----8----9----5----\u003c/code\u003e.\u003c/li\u003e \u003c/ul\u003e\u003ch2\u003e4. Accessing k-th element\u003c/h2\u003e \u003cul\u003e   \u003cli\u003eUse value Count in each node to access k-th element in O(log n)\u003c/li\u003e \u003c/ul\u003e\u003ch2\u003e5. Get max of range L..R\u003c/h2\u003e \u003cul\u003e   \u003cli\u003eExecute this query as other segment trees.\u003c/li\u003e \u003c/ul\u003e\u003ch2\u003e6. Prove the complexity\u003c/h2\u003e \u003cul\u003e   \u003cli\u003eIn worst cases, each queries run in (log n)^2 amortized.\u003c/li\u003e   \u003cli\u003eAlmost actions work in O(log n), but operator \u0026quot;re-arrange\u0026quot;.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eIn node which have length L, we execute maximal log L operator \u0026quot;re-arrange\u0026quot;, the first time occur when number of empty spaces is L/2, the second time is L/4, ...\u003c/p\u003e\u003cp\u003eComplexity to re-arrange a node length L is O(L).\u003c/p\u003e \u003cul\u003e   \u003cli\u003eThere is 1 node length n: O(n log n) * 1\u003c/li\u003e   \u003cli\u003eThere is 2 nodes length n/2: O((n/2) log n) * 2 \u003d O(n log n)\u003c/li\u003e   \u003cli\u003eThere is 4 nodes length n/4: O((n/4) log n) * 4 \u003d O(n log n)\u003c/li\u003e   \u003cli\u003e...\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eIn conclusion, complexity to execute n operators insert is O(n (log n)^2)\u003c/p\u003e\u003c/div\u003e","tags":["segment tree"]}}