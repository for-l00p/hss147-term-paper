{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1490542982,"rating":181,"authorHandle":"krijgertje","modificationTimeSeconds":1490542982,"id":51227,"title":"\u003cp\u003eRap God (Codeforces Round 406 Div 1 problem D)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eIntroduction\u003c/h2\u003e\u003cp\u003eAt the time I am writing this, it seems that all accepted solutions to \u003ca href\u003d\"/contest/786/problem/D\" title\u003d\"Codeforces Round 406 (Div. 1)\"\u003e786D - Rap God\u003c/a\u003e [this problem] use optimized O(n*q) algorithms, including the only accepted solution during the contest by \u003ca class\u003d\"rated-user user-legendary\" href\u003d\"/profile/moejy0viiiiiv\" title\u003d\"Legendary grandmaster moejy0viiiiiv\"\u003e\u003cspan class\u003d\"legendary-user-first-letter\"\u003em\u003c/span\u003eoejy0viiiiiv\u003c/a\u003e. \u003ca href\u003d\"//codeforces.com/blog/entry/51163\"\u003eThe editorial\u003c/a\u003e gives some hints on an algorithm with complexity O((n+q)*lg^3(n)), but nobody seems to have successfully implemented something like it. So I thought I\u0027d give it a try today and after a lot of hard work, I got it accepted. My code can be found here: \u003ca href\u003d\"/contest/786/submission/25820897\" title\u003d\"Submission 25820897 by krijgertje\"\u003e25820897\u003c/a\u003e. Since I enjoyed solving this problem, and since I used a lot of different interesting techniques, I decided to share my approach to this problem in this blog.\u003c/p\u003e\u003ch2\u003eCentroid decomposition\u003c/h2\u003e\u003cp\u003e\u003cem\u003e(just like in the editorial.)\u003c/em\u003e\u003c/p\u003e\u003cp\u003eWe will decompose the tree using centroid decomposition. When processing a centroid, we will need to count for each query (that is in this subtree) the number of paths that pass through the centroid and are lexographically smaller than the query-path. Because of the way the centroid decomposition works, we will process each query at most a logarithmic number of times. Each time we process a query-centroid-combination, we will first compare the path of the query-startnode to the centroid (all paths that we need to count now start with this path) with the query-path (capped at the length of the first path). We will later see how to do this quickly. If they differ, we know that all or none of the paths from the query-startnode though the centroid are lexographically smaller than the query-path. If they are equal, things are a little more difficult. We now need to find where the remaining part of the query-path falls in the subtree of all paths rooted in the centroid, excluding the subtree of the query-startnode.\u003c/p\u003e\u003ch2\u003eTrie rooted in centroid with binary search\u003c/h2\u003e\u003cp\u003e\u003cem\u003e(to sort paths starting in centroid and find the position of the remaining part of the query-path)\u003c/em\u003e\u003c/p\u003e\u003cp\u003eTo find the position of a path in the subtree of all paths rooted in the centroid, we will first construct a trie from the centroid. Then walking this trie in-order will result in a sorted list of all paths rooted in the centroid. If we store all these paths in an array, we can use binary search to find the position of the remaining part of the query path. For this we again need to compare two paths in the tree. We will see later how to do this quickly.\u003c/p\u003e\u003ch2\u003eBinary Indexed Tree\u003c/h2\u003e\u003cp\u003e\u003cem\u003e(to count only active nodes)\u003c/em\u003e\u003c/p\u003e\u003cp\u003eWe only need to count paths in a different subtree than the subtree of the query-startnode. For this, we will use a binary indexed tree. Initally we start with all paths enabled, just before processing queries in a subtree we disable all paths in the subtree, and after processing queries in the subtree we re-enable all paths in the subtree. Then when we know the position of the remaining part of the query-path in list of all paths in the subtree, we can query the binary indexed tree for a prefix sum to obtain the number of paths that we need to count.\u003c/p\u003e\u003ch2\u003eLadder decomposition\u003c/h2\u003e\u003cp\u003e\u003cem\u003e(to decompose paths in O(lg(n)) strings)\u003c/em\u003e\u003c/p\u003e\u003cp\u003eDuring the algorithm, we frequently needed to compare the strings for two paths in the tree, and we need to be able to calculate this quickly. The editorial suggests using hashing for this, but we will use another technique. We will build a string S of linear size, such that each path can be decomposed into a logaritmic number of substrings of S. Then two paths can be compared as follows: split each path in a logarithmic number of substrings of S, compare the first parts of both lists (with length equal to the shorter of the two parts), if they differ we know the result, otherwise we continue with the remaining parts. We continue this way until we find a part that differs or we reach the end of one of the paths; in both cases we know the answer. Assuming we can compare two substrings of S in constant time, then comparing two paths using this algorithm takes only logarithmic time.\u003c/p\u003e\u003cp\u003eHow should S look like so it has the above property? First build a ladder composition of the tree. The total sum of the sizes of all ladders will be at most 2*n. In S, store for each ladder the upward and the downward strings. Then the length of S will be at most 4*n. And each path in the tree can be decomposed into a logarithmic number of parts of a ladder (upward or downward) which correspond to a substring of S.\u003c/p\u003e\u003ch2\u003eSuffix array and lcp array with sparse table range minimum query\u003c/h2\u003e\u003cp\u003e\u003cem\u003e(to compare strings)\u003c/em\u003e\u003c/p\u003e\u003cp\u003eTo compare two substrings in S quickly, we can create a suffix array for S. The relative position of the startpoints in the suffix array of the two suffixes corresponding to the two substrings will then tell us which of the two suffixes comes first, and the minimum over the range in the corresponding lcp array will tell us if the prefixes of the two suffixes (the substrings) are equal or not. To be able to compare substrings in constant time, we should store their position in the suffix array and build a sparse table for rmq queries in the lcp array.\u003c/p\u003e\u003ch2\u003eSuffix tree\u003c/h2\u003e\u003cp\u003e\u003cem\u003e(to create suffix array and lcp array)\u003c/em\u003e\u003c/p\u003e\u003cp\u003eThere are other ways to do this, and you can even afford to use a somewhat slower algorithm, but I used my suffix tree library implementation to create the suffix array in linear time.\u003c/p\u003e\u003ch2\u003eConclusion\u003c/h2\u003e\u003cp\u003eLike I said, I really enjoyed solving this problem. Sometimes it seemed like there was so much stuff to do, but when it all came together in the end it was a wonderful feeling. I want to thank \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/PrinceOfPersia\" title\u003d\"International master PrinceOfPersia\"\u003ePrinceOfPersia\u003c/a\u003e for creating this problem.\u003c/p\u003e\u003cp\u003eOn a more critical note, I don\u0027t think its realistic to expect someone to implement something like this in a two hour contest. And it is very difficult to set the time limit so that these kind of solutions pass, but O(n*q) solutions don\u0027t. Because of these reasons, I don\u0027t think it was a good problem for a two hour contest.\u003c/p\u003e\u003c/div\u003e","tags":["codeforces","round","406","786d","rap god"]}}