{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1430259434,"rating":-6,"authorHandle":"zholnin","modificationTimeSeconds":1430267140,"id":17619,"title":"\u003cp\u003eSPOJ — GSS5, need help with detecting cause of SIGABRT \u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThis is one of the famous Interval tree problems, I think many of you solved it at some point of you competition career. The problem is this:\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://www.spoj.com/problems/GSS5/\"\u003eCan you answer this Queries V\u003c/a\u003e\u003c/p\u003e\u003cp\u003eBelow is my solution — it is not perfect obviously, but with similar code I already solved GSS1 and GSS3:\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://www.spoj.com/problems/GSS1/\"\u003eCan you answer this Queries I\u003c/a\u003e \u003ca href\u003d\"http://www.spoj.com/problems/GSS3/\"\u003eCan you answer this Queries III\u003c/a\u003e\u003c/p\u003e\u003cp\u003eSo it is partially tested and AC\u0027ed. The problem I encountered — under Miscrosoft Visual Studio Express 2013 it compiles and works fine in debug mode. I tried preparing random test cases for it and none of the runs I did (several thousand random testcases) could replicate the problem.\u003c/p\u003e\u003cp\u003eSPOJ reponse to this code is always the same — SIGABRT or SIGSERV, randomly. I understand that for SIGSERV I should be looking for writing outside of boundaries of array, but solution uses only vectors and it should be detected in debug mode... Maybe I was not able to replicate that single specific testcase which leads to the problem.\u003c/p\u003e\u003cp\u003eCan anybody please provide any clues?\u003c/p\u003e\u003cp\u003eThanks,\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;vector\u0026gt;\n#include \u0026lt;list\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;bitset\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;functional\u0026gt;\n#include \u0026lt;numeric\u0026gt;\n#include \u0026lt;sstream\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;iomanip\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n\nusing namespace std;\n\nstruct entry\n{\n\tentry() : sum(0), best(0), left(0), right(0) {};\n\tentry(int value) : sum(value), best(value), left(value), right(value) {};\n\tentry(int v1, int v2, int v3, int v4) : sum(v1), best(v2), left(v3), right(v4) {};\n\n\tint best;\n\tint sum;\n\tint left;\n\tint right;\n};\n\nvector\u0026lt;vector\u0026lt;entry\u0026gt;\u0026gt; M;\n\n\nentry getValue(int a, int b, int depth, int s \u003d 0)\n{\n\tif (a \u0026gt; b) return entry(0);\n\n\tint left \u003d (1 \u0026lt;\u0026lt; depth) * s;\n\tint right \u003d (1 \u0026lt;\u0026lt; depth) * (s + 1) - 1;\n\n\tif (a \u003d\u003d left \u0026amp;\u0026amp; b \u003d\u003d right) return M[depth][s];\n\n\tint mid \u003d (left + right) / 2;\n\n\tif (a \u0026lt;\u003d mid \u0026amp;\u0026amp; b \u0026lt;\u003d mid) return getValue(a, b, depth - 1, 2 * s);\n\tif (a \u0026gt; mid \u0026amp;\u0026amp; b \u0026gt; mid) return getValue(a, b, depth - 1, 2 * s + 1);\n\n\tentry Left \u003d getValue(a, mid, depth - 1, s * 2);\n\tentry Right \u003d getValue(mid + 1, b, depth - 1, s * 2 +1);\n\n\treturn entry(Left.sum + Right.sum, max(max(Left.best, Right.best), Left.right + Right.left), max(Left.left, Left.sum + Right.left), max(Right.right, Right.sum + Left.right));\n}\n\nint main()\n{\n\tint t;\n\n\tcin \u0026gt;\u0026gt; t;\n\n\twhile (t--)\n\t{\n\n\t\tios_base::sync_with_stdio(0);\n\n\t\tint n;\n\t\tcin \u0026gt;\u0026gt; n;\n\n\t\tM \u003d vector\u0026lt;vector\u0026lt;entry\u0026gt;\u0026gt;();\n\n\t\tM.push_back(vector\u0026lt;entry\u0026gt;(n));\n\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++)\n\t\t{\n\t\t\tint t;\n\t\t\tcin \u0026gt;\u0026gt; t;\n\n\t\t\tM[0][i] \u003d t;\n\t\t}\n\n\t\tint k \u003d n;\n\t\tint depth \u003d 0;\n\n\t\twhile (k \u0026gt; 0)\n\t\t{\n\t\t\tdepth++;\n\t\t\tM.push_back(vector\u0026lt;entry\u0026gt;(k / 2 + 2));\n\n\t\t\tfor (int i \u003d 0; i \u0026lt; M[depth - 1].size(); i +\u003d 2)\n\t\t\t{\n\t\t\t\tif (i + 1 \u003d\u003d M[depth - 1].size())\n\t\t\t\t{\n\t\t\t\t\tM[depth][i / 2].sum \u003d M[depth - 1][i].sum;\n\t\t\t\t\tM[depth][i / 2].best \u003d M[depth - 1][i].best;\n\t\t\t\t\tM[depth][i / 2].left \u003d M[depth - 1][i].left;\n\t\t\t\t\tM[depth][i / 2].right \u003d 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tM[depth][i / 2].sum \u003d M[depth - 1][i].sum + M[depth - 1][i + 1].sum;\n\t\t\t\t\tM[depth][i / 2].left \u003d max(M[depth - 1][i].left, M[depth - 1][i].sum + M[depth - 1][i + 1].left);\n\t\t\t\t\tM[depth][i / 2].right \u003d max(M[depth - 1][i + 1].right, M[depth - 1][i + 1].sum + M[depth - 1][i].right);\n\t\t\t\t\tM[depth][i / 2].best \u003d max(max(M[depth - 1][i].best, M[depth - 1][i + 1].best), M[depth - 1][i].right + M[depth - 1][i + 1].left);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tk \u003d k / 2;\n\t\t}\n\n\t\tint q;\n\t\tcin \u0026gt;\u0026gt; q;\n\n\t\twhile (q--)\n\t\t{\n\t\t\tint x1, x2, y1, y2;\n\t\t\tcin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2;\n\t\t\tx1--, y1--, x2--, y2--;\n\n\t\t\tint ans;\n\t\t\tif (y1 \u0026lt; x2)\n\t\t\t{\n\t\t\t\tentry Middle \u003d getValue(y1 + 1, x2 - 1, depth);\n\t\t\t\tentry Left \u003d getValue(x2, y2, depth);\n\t\t\t\tentry Right \u003d getValue(x1, y1, depth);\n\n\t\t\t\tans \u003d Left.left + Right.right + Middle.sum;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint Middle \u003d getValue(x2, y1, depth).best;\n\n\t\t\t\tint l1 \u003d getValue(x1, x2, depth).right;\n\t\t\t\tint r1 \u003d getValue(x2 + 1, y2, depth).left;\n\t\t\t\tl1 \u003d max(l1, l1 + r1);\n\n\t\t\t\tint r2 \u003d getValue(y1 + 1, y2, depth).left;\n\t\t\t\tint l2 \u003d getValue(x1, y1, depth).right;\n\t\t\t\tl2 \u003d max(l2, l2 + r2);\n\n\t\t\t\tans \u003d max(Middle, max(l1, l2));\n\t\t\t}\n\n\t\t\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n\n\t\t}\n\n\t}\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["gss5","spoj"]}}