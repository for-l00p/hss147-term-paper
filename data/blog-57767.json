{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1518634013,"rating":-6,"authorHandle":"AnasAbbas","modificationTimeSeconds":1518639924,"id":57767,"title":"\u003cp\u003eDP Workaround \u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003ehello codeforces\u003c/p\u003e\u003cp\u003ethis problem \u003ca href\u003d\"/contest/917/problem/A\" title\u003d\"Codeforces Round 459 (Div. 1)\"\u003e917A - Монстр\u003c/a\u003e has only a greedy solution which is well explained in the editorial\u003c/p\u003e\u003cp\u003ehowever i want to introduce a Dynamic programming solution\u003c/p\u003e\u003cp\u003eO(N^4) DP solution : \u003ca href\u003d\"/contest/918/submission/34679276\" title\u003d\"Посылка 34679276 от AnasAbbas\"\u003e34679276\u003c/a\u003e\u003c/p\u003e\u003cp\u003eExplanation :\u003c/p\u003e\u003cp\u003e\u003ccode\u003ethe boolean solve function finds out if a certain substring can be a valid sequence of brackets\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003eif it finds a question mark it treats it like an open bracket then a closed bracket\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003ecomplexity O(n^2)\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003ethe main function calls the solve function for every different substring  which is nearly\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003eN^2  substring\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003eso the overall complexity is O(N^4)\u003c/code\u003e\u003c/p\u003e\u003cp\u003eO(N^3) DP solution : \u003ca href\u003d\"/contest/918/submission/34680960\" title\u003d\"Посылка 34680960 от AnasAbbas\"\u003e34680960\u003c/a\u003e\u003c/p\u003e\u003cp\u003eExplanation :\u003c/p\u003e\u003cp\u003e\u003ccode\u003elike the previous solution the main function calls solve function n^2 times but this time\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003esolve function is O(n^2) n times and the rest of the calls is O(1)\u003c/code\u003e\u003c/p\u003e\u003cp\u003eNearly O(N^2) Accepted DP solution : \u003ca href\u003d\"/contest/917/submission/35227974\" title\u003d\"Посылка 35227974 от AnasAbbas\"\u003e35227974\u003c/a\u003e i know that this solutions seems very weird compared to the previous solutions but actually it\u0027s doing the same thing efficiently Explanation:\u003c/p\u003e\u003cp\u003e\u003ccode\u003enow we know that in the previous solutions solve(pos,nopen) goes to\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003estates solve(pos+1,nopen+1),solve(pos+1,nopen-1)\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003eif string[pos] was a question mark and solve(pos,nopen) goes to solve(pos+1,nopen+1)\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003eif it was an open bracket\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003eand solve(pos+1,nopen-1) if it was a closed bracket\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003enow let\u0027s put all these states in an array\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003eexample :\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003eif the input string was \u0026quot;((?)\u0026quot;\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003ethe array should contain:\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003e[0] meaning solve(0,0)\u003c/code\u003e\u003c/p\u003e\u003cp\u003ethen\u003c/p\u003e\u003cp\u003e\u003ccode\u003e[1] meaning solve(1,1)\u003c/code\u003e\u003c/p\u003e\u003cp\u003ethen\u003c/p\u003e\u003cp\u003e\u003ccode\u003e[2] meaning solve(2,2)\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003e[1,3] meaning solve(3,1) and solve(3,3)\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003e[0,2] meaning solve(4,0) and solve(4,2)\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003enotice that we don\u0027t need to save the first parameter in the array as all states has the same level\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003enow we observe that if there\u0027s an open bracket we have to increase all array elements by 1 and -1\u003c/code\u003e \u003ccode\u003ein case of closing\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003eand in case of question mark all states is increased by 1 and new state is added which is\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003eequal to first state -2\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eprove it for yourself on a sheet of paper\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003enow after every iteration we only have to increment our answer if there\u0027s an element in the array \u003d0\u003c/code\u003e\u003c/p\u003e\u003cp\u003ehope you got it\u003c/p\u003e\u003cp\u003eimportant notes :\u003c/p\u003e\u003cp\u003e-please feel free to comment if you find any mistake in my blog \u003c/p\u003e\u003cp\u003e-i\u0027m not really good at writing blogs so i\u0027m sorry if you find bad styling or poor english\u003c/p\u003e\u003cp\u003e-i hope that this workaround help anyone optimizing similar DP solutions\u003c/p\u003e\u003cp\u003e-it took me around a month to come up with this solution and i really want to know if i\u0027m doing problem solving efficiently \u003c/p\u003e\u003cp\u003ethanks\u003c/p\u003e\u003c/div\u003e","tags":[]}}