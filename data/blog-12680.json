{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1402688053,"rating":117,"authorHandle":"Fefer_Ivan","modificationTimeSeconds":1402785368,"id":12680,"title":"\u003cp\u003eZepto Code Rush 2014 — solutions A-D\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/436/problem/A\" title\u003d\"Zepto Code Rush 2014\"\u003e436A - Feed with Candy\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eTutorial author: \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Fefer_Ivan\" title\u003d\"Master Fefer_Ivan\"\u003eFefer_Ivan\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIn this problem types of eaten candies must alternate. It means that the type of first eaten candy dictated the types of all the following candies. There are only two possible types so we should consider each type as a type of first eaten candy separatelly and then pick the most optimal. So, what if Om Nom wants to eat a candy of type \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e and can jump up to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e? It is obvious that best option is to eat a candy with maximal mass among all the candies he can eat at this time.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/436/problem/B\" title\u003d\"Zepto Code Rush 2014\"\u003e436B - Om Nom and Spiders\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eTutorial author: \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Fefer_Ivan\" title\u003d\"Master Fefer_Ivan\"\u003eFefer_Ivan\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet us number columns with integers from \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e from left to right and rows from \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e from top to bottom. In the cell \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e at the time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e only four spiders can be at this cell:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eSpider, which is moving left and started at \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e + \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eSpider, which is moving right and started at \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e - \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eSpider, which is moving up and started at \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e + \u003ci\u003et\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eSpider, which is moving down and started at \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e - \u003ci\u003et\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eLet iterate through all possible starting positions of Om Nom. Consider that he starts at column \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. At time \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e all spiders are on their initial positions and Om Nom is at \u003cspan class\u003d\"tex-span\"\u003e(0, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e. There is no spiders at row \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, so at time \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e Om Nom can not meet any spiders. When Om Nom is at cell \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e, it means that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e units of time passed after the start. So to calculate the number of spiders, that Om Nom meets it is enought to check only \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e cells stated above.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/436/problem/C\" title\u003d\"Zepto Code Rush 2014\"\u003e436C - Dungeons and Candies\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eTutorial author: \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Fefer_Ivan\" title\u003d\"Master Fefer_Ivan\"\u003eFefer_Ivan\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s consider a weighted undirected graph with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e vertex. Label the vertices with numbers from \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Vertices from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e correspond to levels. For each pair of levels \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e add an edge between vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e with weight equal to the cost of transferring one level as a difference from the other level. For each level \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e add an edge from vertex \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e to vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e with weight equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e·\u003ci\u003em\u003c/i\u003e\u003c/span\u003e, i.e. cost of transmitting the whole level. Each way to transmit levels defined an spanning tree of this graph. So to solve the problem, we must find a minimal spanning tree of this graph.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/436/problem/D\" title\u003d\"Zepto Code Rush 2014\"\u003e436D - Pudding Monsters\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eTutorial author: \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Fefer_Ivan\" title\u003d\"Master Fefer_Ivan\"\u003eFefer_Ivan\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis problem can be solved using dynamic programming. Let\u0027s introduce some designations: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e — number of special cells on the segment \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — maximal number of covered special cells using only first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e monsters, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — maximal number of covered special cells using only first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e monsters and with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th monster not moving.\u003c/p\u003e\u003cp\u003eHow to calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Let\u0027s denote \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th monster position as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e. Let\u0027s iterate through all special cells to the left of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th monster. Let\u0027s denote current special cell position as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e. Let\u0027s consider the situation when this cell is the leftmost special cell in the block of monsters with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th monster in it. So we need \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e - \u003ci\u003el\u003c/i\u003e\u003c/span\u003e additional monsters to get to this cell from monster \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. So the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e can be updated with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - (\u003ci\u003er\u003c/i\u003e - \u003ci\u003el\u003c/i\u003e)\u003c/sub\u003e + \u003ci\u003esum\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow, after we computed new value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, we need to update some values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Let\u0027s denote \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th monster position as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e. Let\u0027s iterate through all special cells to the right of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th monster. Let\u0027s denote current special cell position as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e. Let\u0027s consider the situation when this cell is the rightmost special cell in the block of monsters with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th monster in it. So we need \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e - \u003ci\u003el\u003c/i\u003e\u003c/span\u003e additional monsters to get to this cell from monster \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. So we can update the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + (\u003ci\u003er\u003c/i\u003e - \u003ci\u003el\u003c/i\u003e)\u003c/sub\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003esum\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e + 1, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e. Also, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e should be updated with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSo the solution works in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e·\u003ci\u003em\u003c/i\u003e)\u003c/span\u003e because for each of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e monsters we iterate through all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e special cells and for a fixed monster-cell pair all computing is done in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThere are some details about monsters, that are merged at the initial state, but they are pretty easy to figure out.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/436/problem/E\" title\u003d\"Zepto Code Rush 2014\"\u003e436E - Cardboard Box\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eTutorial author: \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Gerald\" title\u003d\"Master Gerald\"\u003eGerald\u003c/a\u003e, \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Nerevar\" title\u003d\"International master Nerevar\"\u003eNerevar\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIn this task you have to come with the proper greedy algorithms. Several algorithms will fit, let\u0027s describe one of them:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eFrom that point we will consider that the levels are sorted by increasing value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eLet\u0027s look at some optimal solution (a set of completed levels). From levels that we completed for two stars, select the level \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e with the largest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e. It turns out that all levels that stand before \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e (remember, the levels are sorted) should be completed for at least one star. Otherwise, we could complete some of the previous levels instead of the level \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. This won\u0027t increase the cost.\u003c/li\u003e   \u003cli\u003eLet\u0027s fix a prefix of the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e levels and solve the problem with the assumption that each of the selected levels should be completed. Additionally, we will assume that all levels that are completed for two stars are within this prefix (as was shown before, such prefix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e levels always exists for some optimal solution).\u003c/li\u003e   \u003cli\u003eAs we will surely complete this \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e levels, we can imagine that we have initially completed all of the for just one star. So, we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e - \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e more stars to get. We can get these stars either by completing some of the levels that are outside our prefix for one star, or by completing some of the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e levels for two stars instead of one star.\u003c/li\u003e   \u003cli\u003eIt\u0027s clear that we just have to choose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e - \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e cheapest options, which correspond to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e - \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e smallest numbers among the following: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] - \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026gt; \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. Computing the sum of these smallest values can be done with a data structure like Cartesian tree or BIT.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThe described solution has time completixy of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e \u003ci\u003elog\u003c/i\u003e \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/436/problem/F\" title\u003d\"Zepto Code Rush 2014\"\u003e436F - Banners\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eTutorial author: \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Gerald\" title\u003d\"Master Gerald\"\u003eGerald\u003c/a\u003e, \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Nerevar\" title\u003d\"International master Nerevar\"\u003eNerevar\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTask F was the hardest one in the problemset. To better understand the solution, let\u0027s look at the task from the geometrical point of view. Imagine that people are point in the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eOpc\u003c/i\u003e\u003c/span\u003e plane (value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e are points\u0027 coordinates). Then for each line horizontal \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e \u003d \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e we have to find such vertical line \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e \u003d \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e that maximizes some target function. The function is computed as follows: (number of points not below \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e \u003d \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, multiplied by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e·\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e) plus (number of points below \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e \u003d \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and not to the left of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e \u003d \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, multiplied by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eLet\u0027s move scanning line upwards (consider values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e \u003d 0\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e \u003d 1\u003c/span\u003e, etc). For each value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e we will store the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e]\u003c/span\u003e — the value of the target function with the current value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e and this value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e. The problem is: if we have such array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[]\u003c/span\u003e for the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e, how to recompute it for the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e + 1\u003c/span\u003e?\u003c/p\u003e\u003cp\u003eLet\u0027s look at all people that will be affected by the increase of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e: these are the people with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e. With the current \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e they are still using free version, after the increase they won\u0027t. Each of these people makes the following effect to the array: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[1] +  \u003d 1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[2] +  \u003d 2\u003c/span\u003e, ..., \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003eb\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]] +  \u003d \u003ci\u003eb\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e\u003c/p\u003e\u003cp\u003eNow the task can be reduced to the problem related with data structures. There are two types of queries: add the increasing arithmetical progression to the prefix of the array and retrieve the maximum value of the array. One of the way to solve it is to use sqrt-decomposition.\u003c/p\u003e\u003cp\u003eLet\u0027s divide all queries into groups of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esqrt\u003c/i\u003e(\u003ci\u003eq\u003c/i\u003e)\u003c/span\u003e. Let\u0027s denote the queries from the group as a sequence: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e \u003d \u003ci\u003esqrt\u003c/i\u003e(\u003ci\u003eq\u003c/i\u003e))\u003c/span\u003e. For query \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e we should perform assignments \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[1] +  \u003d 1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[2] +  \u003d 2\u003c/span\u003e, ..., \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e] +  \u003d \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Imagine we already preformed all the queries. Each value of new array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[]\u003c/span\u003e can be represented as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d \u003ci\u003eoldD\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] + \u003ci\u003ei\u003c/i\u003e·\u003ci\u003ecoef\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecoef\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e is the number of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u0026gt; \u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eOne can notice that array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecoef\u003c/i\u003e\u003c/span\u003e contains at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esqrt\u003c/i\u003e(\u003ci\u003eq\u003c/i\u003e)\u003c/span\u003e distinct values, additionally this array can be splitted into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003esqrt\u003c/i\u003e(\u003ci\u003eq\u003c/i\u003e))\u003c/span\u003e parts such that all elements from the same part will be the same. This is the key observation. We will divide array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecoef\u003c/i\u003e\u003c/span\u003e into parts. And for each part will maintain lower envelope of the lines \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e \u003d \u003ci\u003ed\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] + \u003ci\u003ei\u003c/i\u003e·\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. So, we will have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003esqrt\u003c/i\u003e(\u003ci\u003eq\u003c/i\u003e))\u003c/span\u003e lower envelopes. Each envelope will help us to get maximum value among the segment of array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e](\u003ci\u003eoldD\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] + \u003ci\u003ei\u003c/i\u003e·\u003ci\u003ecoef\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e])\u003c/span\u003e. As for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e from some segment factor \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecoef\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e is containt we can just pick \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e-coordinate with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003ecoef\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e of corresponding lower envelope.\u003c/p\u003e\u003cp\u003eDescribed solution has time complexity of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eMAXX\u003c/i\u003e·\u003ci\u003esqrt\u003c/i\u003e(\u003ci\u003eMAXX\u003c/i\u003e))\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eMAXX\u003c/i\u003e\u003c/span\u003e is the maximum value among \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e. With best regards, Ivan.\u003c/p\u003e\u003c/div\u003e","tags":["tutorial","zepto code rush 2014","zeptolab"]}}