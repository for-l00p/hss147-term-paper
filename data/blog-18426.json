{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1433840461,"rating":182,"authorHandle":"I_love_Hoang_Yen","modificationTimeSeconds":1456271645,"id":18426,"title":"\u003cp\u003eValidators with testlib.h\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eIf you have written some programming problems, and have prepared test cases, you will probably experience the terrible feeling that some test cases may be invalid (meaning it does not agree with the constraints in problem statement): upper bound can be violated, your graph not satisfied connectivity requirements or is not at tree... It is reasonable to feel that way. Even experienced problem setters make mistakes sometimes (for example, in the prestigious ACM ICPC World final 2007).\u003c/p\u003e\u003cp\u003eIt is strictly recommended to write a special program (called \u003cem\u003evalidator\u003c/em\u003e) to formally check each test to satisfy all requirements from problem statements. Validators are strictly required for problems on Codeforces. \u003ca href\u003d\"https://polygon.codeforces.com\"\u003ePolygon\u003c/a\u003e has built-in support of validators.\u003c/p\u003e\u003cp\u003eIt is really easy to write a validator using testlib.h.\u003c/p\u003e\u003ch2\u003eExample\u003c/h2\u003e\u003cp\u003eFollowing is the validator was written for the problem \u003ca href\u003d\"/gym/100541/problem/A\" title\u003d\"2014 ACM-ICPC Vietnam National Second Round\"\u003e100541A - Stock Market\u003c/a\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026quot;testlib.h\u0026quot;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int testCount \u003d inf.readInt(1, 10, \u0026quot;testCount\u0026quot;);\n    inf.readEoln();\n    \n    for (int i \u003d 0; i \u0026lt; testCount; i++) {\n        int n \u003d inf.readInt(1, 100, \u0026quot;n\u0026quot;);\n        inf.readSpace();\n        inf.readInt(1, 1000000, \u0026quot;w\u0026quot;);\n        inf.readEoln();\n\n        for(int i \u003d 0; i \u0026lt; n; ++i) {\n            inf.readInt(1, 1000, \u0026quot;p_i\u0026quot;);\n            if (i \u0026lt; n-1)\n                inf.readSpace();\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe wonderful thing about this validator is that it is very simple and it is very difficult to write something incorrect.\u003c/p\u003e\u003cp\u003eMore examples can be found at \u003ca href\u003d\"https://github.com/MikeMirzayanov/testlib/tree/master/validators\"\u003ethe Github repo\u003c/a\u003e\u003c/p\u003e\u003ch2\u003eAvailable methods\u003c/h2\u003e\u003cp\u003eThe first line of your code should be \u003ccode\u003eregisterValidation()\u003c/code\u003e which does some magic in the background, so that you can use the necessary methods. Most methods for validators start with prefix \u0026quot;read\u0026quot; and it does the same thing: moves input stream pointer to next suitable place after reading something. It also detect violations (input does not match what you are trying to read), and then throw error.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eNotes\u003c/strong\u003e:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eValidator is strict. It cares about correct placing of spaces. For example, when you\u0027re trying to read an integer and the next character is a space (and then an integer), the validator will throw error.\u003c/li\u003e   \u003cli\u003eSome method has \u0026quot;regex\u0026quot; feature. It is not a full-featured regex as you may have used in many programming languages. It is a very simple version, which supports the following:   \u003cul\u003e     \u003cli\u003e\u003cstrong\u003eSet\u003c/strong\u003e of character, e.g: \u003ccode\u003e[a-z]\u003c/code\u003e is a lowercase latin letter, \u003ccode\u003e[^a-z]\u003c/code\u003e matches anything but a lowercase latin letter.\u003c/li\u003e     \u003cli\u003e\u003cstrong\u003eRange\u003c/strong\u003e, e.g. \u003ccode\u003e[a-z]{1,5}\u003c/code\u003e is a string of length 1 to 5 consists of only lowercase latin letter.\u003c/li\u003e     \u003cli\u003e\u003cstrong\u003eOr\u003c/strong\u003e operator, e.g. \u003ccode\u003emike|john\u003c/code\u003e is either \u003ccode\u003emike\u003c/code\u003e or \u003ccode\u003ejohn\u003c/code\u003e.\u003c/li\u003e     \u003cli\u003e\u003cstrong\u003eOptional\u003c/strong\u003e character, e.g. \u003ccode\u003e-?[1-9][0-9]{0,3}\u003c/code\u003e will match non-zero integers from -9999 to 9999 (note the optional minus sign).\u003c/li\u003e     \u003cli\u003e\u003cstrong\u003eRepetition\u003c/strong\u003e, e.g. \u003ccode\u003e[0-9]*\u003c/code\u003e will match sequences (empty or non-empty) of digits, and \u003ccode\u003e[0-9]+\u003c/code\u003e will match non-empty sequences of digits.\u003c/li\u003e   \u003c/ul\u003e\u003c/li\u003e   \u003cli\u003eAlso regarding regex, very simple greedy algorithm is used. For example, pattern \u003ccode\u003e[0-9]?1\u003c/code\u003e will not match \u003ccode\u003e1\u003c/code\u003e, because of greedy nature of matching.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eFollowing is full list of methods available:\u003c/p\u003e \u003ctable\u003e   \u003cthead\u003e     \u003ctr\u003e       \u003cth\u003eMethod\u003c/th\u003e       \u003cth\u003eWhat it does\u003c/th\u003e     \u003c/tr\u003e   \u003c/thead\u003e   \u003ctbody\u003e     \u003ctr\u003e       \u003ctd\u003evoid registerValidation()\u003c/td\u003e       \u003ctd\u003eThis method must be called at the beginning of your code in order to use validator. \u003cbr /\u003e After calling this method, you can access input stream by variable named \u003ccode\u003einf\u003c/code\u003e. \u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003echar readChar()\u003c/td\u003e       \u003ctd\u003eReturns current character and moves pointer one character forward.\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003echar readChar(char c)\u003c/td\u003e       \u003ctd\u003eSame as \u003ccode\u003ereadChar()\u003c/code\u003e but ensures that the readCharacter is \u0027c\u0027.\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003echar readSpace()\u003c/td\u003e       \u003ctd\u003eSame as \u003ccode\u003ereadChar(\u0027 \u0027)\u003c/code\u003e.\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003evoid unreadChar(char c)\u003c/td\u003e       \u003ctd\u003ePuts back character c to input stream.\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003estring readToken()\u003c/td\u003e       \u003ctd\u003eReads a new token, i.e. a word that doesn\u0027t contain any whitespaces (like space, tab, EOLN and etc).\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003estring readToken(string regex)\u003c/td\u003e       \u003ctd\u003eSame as \u003ccode\u003ereadToken()\u003c/code\u003e but ensures that it matches given regex.\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003estring readWord()\u003c/td\u003e       \u003ctd\u003eSame as \u003ccode\u003ereadToken()\u003c/code\u003e\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003estring readWord(string regex)\u003c/td\u003e       \u003ctd\u003eSame as \u003ccode\u003ereadToken(string regex)\u003c/code\u003e\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003elong long readLong()\u003c/td\u003e       \u003ctd\u003eReads a long (long long in C/C++ and long in Java)\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003elong long readLong(long long L, long long R)\u003c/td\u003e       \u003ctd\u003eSame as \u003ccode\u003ereadLong()\u003c/code\u003e but ensures that the value is in range \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e]\u003c/span\u003e (inclusively)\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003eint readInt(), \u003cbr /\u003e int readInteger()\u003c/td\u003e       \u003ctd\u003eReads an integer (int type in both Java and C/C++)\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003eint readInt(int L, int R), \u003cbr /\u003e int readInteger(L, R)\u003c/td\u003e       \u003ctd\u003eSame as \u003ccode\u003ereadInt()\u003c/code\u003e but ensures that the value is in range \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e]\u003c/span\u003e (inclusively)\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003edouble readReal(), \u003cbr /\u003e double readDouble()\u003c/td\u003e       \u003ctd\u003eReads a double.\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003edouble readReal(double L, double R), \u003cbr /\u003e double readDouble(double L, double R)\u003c/td\u003e       \u003ctd\u003eSame as \u003ccode\u003ereadReal()\u003c/code\u003e, \u003ccode\u003ereadDouble()\u003c/code\u003e but ensures that the value is in range \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e]\u003c/span\u003e.\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003edouble readStrictReal(double L, double R, int minPrecision, int maxPrecision), \u003cbr /\u003e double readStrictDouble(double L, double R, int minPrecision, int maxPrecision)\u003c/td\u003e       \u003ctd\u003eSame as \u003ccode\u003ereadReal(L, R)\u003c/code\u003e, \u003ccode\u003ereadDouble(L, R)\u003c/code\u003e, but additionally ensures that the number of digits after decimal point is between \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eminPrecision\u003c/i\u003e, \u003ci\u003emaxPrecision\u003c/i\u003e]\u003c/span\u003e. Doesn\u0027t allow exponential or any other non-standard form.\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003estring readString(), \u003cbr /\u003e string readLine()\u003c/td\u003e       \u003ctd\u003eReads a line from current position to EOLN. Moves input stream pointer to first character of new line (if exists).\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003estring readString(string regex), \u003cbr /\u003e string readLine(string regex)\u003c/td\u003e       \u003ctd\u003eSame as \u003ccode\u003ereadString()\u003c/code\u003e and \u003ccode\u003ereadLine()\u003c/code\u003e, but ensures that the string matches given regex.\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003evoid readEoln()\u003c/td\u003e       \u003ctd\u003eReads EOLN or fails. Note that this method magically works on both Windows and Linux. On Windows it reads #13#10 and on Linux it reads #10.\u003c/td\u003e     \u003c/tr\u003e     \u003ctr\u003e       \u003ctd\u003evoid readEof()\u003c/td\u003e       \u003ctd\u003eReads EOF or fails.\u003c/td\u003e     \u003c/tr\u003e   \u003c/tbody\u003e \u003c/table\u003e\u003ch4\u003eParameter \u003cem\u003evariableName\u003c/em\u003e\u003c/h4\u003e\u003cp\u003eIt is recommended to insert last string parameter to readInt/readInteger/readLong/readDouble/readWord/readToken/readString/readLine called \u003cem\u003evariableName\u003c/em\u003e to make error message be human-readable. So it is preffered to use \u003ccode\u003einf.readInt(1, 100, n)\u003c/code\u003e instead of \u003ccode\u003einf.readInt(1, 100)\u003c/code\u003e. The first statement will fail with human-readable message like \u003ccode\u003eFAIL Integer parameter [name\u003dn] equals to 0, violates the range [1, 100]\u003c/code\u003e.\u003c/p\u003e\u003ch4\u003eUsing ensure/ensuref\u003c/h4\u003e\u003cp\u003eTo check a requirement (like a graph doesn\u0027t contain loops, i.e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≠ \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e) use \u003ccode\u003eensuref(x_i !\u003d y_i, \u0026quot;Graph can\u0027t contain loops\u0026quot;)\u003c/code\u003e. It is allowed to use C-language format specifiers like \u003ccode\u003eensuref(s.length() % 2 \u003d\u003d 0, \u0026quot;String \u0027s\u0027 should have even length, but s.length()\u003d%d\u0026quot;, int(s.length()))\u003c/code\u003e. Also you can use simple form like \u003ccode\u003eensure(x \u0026gt; y)\u003c/code\u003e, it will print failed condition if it doesn\u0027t hold in form \u003ccode\u003eFAIL Condition failed: \u0026quot;x \u0026gt; y\u0026quot;\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eReference: \u003ca href\u003d\"https://github.com/MikeMirzayanov/testlib/blob/master/testlib.h\"\u003eGithub page of testlib.h\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["testlib","validator","validators","polygon"]}}