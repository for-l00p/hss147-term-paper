{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1425662850,"rating":0,"authorHandle":"Fcdkbear","modificationTimeSeconds":1425671405,"id":16816,"title":"\u003cp\u003eРазбор второй личной тренировки (28.02.2015)\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eЗадача А\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eРешение 1. SQRT-декомпозиция по запросам\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eРазобьем наши запросы на блоки размером порядка \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/61/ea/61ea97a74324784c1feda6bff27bf6c17dfb431b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e числа запросов (я использовал размер-константу 310). Мы можем сразу узнать, к каким стекам в текущем блоке применяется запрос Get. Остальные стеки на текущем этапе нас не волнуют. \u003c/p\u003e\u003cp\u003eНам хотелось бы иметь структуру данных, которая поддерживает состояние этих стеков на момент начала текущего блока запросов. Заметим, что для того, чтобы ответить корректно на запросы текущего блока, можно в каждом стеке держать не более чем \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/89/e1/89e157e56798f485296569de0bcfa74699919ba6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e последних неудаленных значений (ведь в нашем текущем блоке будет не более \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/61/ea/61ea97a74324784c1feda6bff27bf6c17dfb431b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e удалений). Давайте в начале каждого блока преподсчитывать такую структуру. Как это делать? Будем идти по неудаленным add-запросам задом наперед и добавлять в нужные нам стеки очереное число. Как добавлять только в нужные стеки, не ухудшив при этом сложность? Это можно делать при помощи DSU (читаем по \u003ca href\u003d\"http://e-maxx.ru/algo/dsu\"\u003eссылке\u003c/a\u003e раздел \u0026quot;Применение DSU для сжатия \u0026quot;прыжков\u0026quot; по отрезку. Задача о покраске подотрезков в оффлайне\u0026quot;, идея крайне похожа).\u003c/p\u003e\u003cp\u003eИ так, как выглядит наш алгоритм?\u003c/p\u003e\u003cp\u003e1) Раз в \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/61/ea/61ea97a74324784c1feda6bff27bf6c17dfb431b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e шагов перестраиваем структуру данных\u003c/p\u003e\u003cp\u003e2) При обработке запроса add в очередном блоке — не делаем ничего\u003c/p\u003e\u003cp\u003e3) При обрабоке запроса remove — отмечаем где-то, что запрос был отменен\u003c/p\u003e\u003cp\u003e4) При запросе get — добавим в стек построенной в начале блока структуры все add-ы, которые задевали текущий стек. Длаее будем идти по стеку от конца к началу и удалять все удаленные запросы. Первое неудаленное число и будет ответом. \u003c/p\u003e\u003cp\u003eСложность перестройки для каждого блока равна \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e + \u003ci\u003eM\u003c/i\u003e)\u003c/span\u003e, значит суммарно все перестройки выполнятся за \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/56/9b/569b1b7dd87c9a3177f3dce2167dccc4ceac7fd2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Сложность ответа на запрос get равна \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/60/50/60509107dcce0eec980769c409f80bb84ae9accf.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, на остальные — O(1). И того, суммарная сложность — \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/56/9b/569b1b7dd87c9a3177f3dce2167dccc4ceac7fd2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eРешение 2. Дерево отрезков\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eБудем поддерживать дерево отрезков, в каждом листе которго хранится начальный стек, другие вершины будут в какомто смысле отвечать за свой отрезок стеков.\u003c/p\u003e\u003cp\u003eЗапросы обрабатываем так:\u003c/p\u003e\u003cp\u003e1) При обработке запроса add — спускаемся по ДО и кидаем текущее число в нужные стеки в нужных вершинах ДО. Сложность запроса — logN\u003c/p\u003e\u003cp\u003e2) При обрабоке запроса remove — отмечаем где-то, что запрос был отменен\u003c/p\u003e\u003cp\u003e3) При запросе get — спускаемся по ДО до нужного листа. По дороге к листу будем идти по стекам всех пройденных вершин задом наперед и удалять все отмененные add пока не встретим не отменнный add. Нетрудно видеть, что: \u003c/p\u003e\u003cp\u003eа) Ответ на запрос — число, которое соответствует наибольшему не удаленному запросу из всех что мы посмотрели на пути к листу\u003c/p\u003e\u003cp\u003eб) Суммарно удалений будет не больше чем добавлений, а добавлений у нас — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e \u003c/p\u003e\u003cp\u003eИ того получаем решение за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eM\u003c/i\u003e + \u003ci\u003eN\u003c/i\u003e)\u003ci\u003elogN\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача B\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eНесложно увидеть, что если k четное — ответ равен x-y, иначе он равен y-x.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача C\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eОпишем решение, которому требуется порядка 2000 итераций.\u003c/p\u003e\u003cp\u003eБудем пробовать угадать суффикс строки. Делаем это следующим образом. Допустим мы знаем, что в загаданную строку как подстрока входит строка s (изначально пустая). Запросим ответ для строки s+\u00270\u0027. Если он положительный — олично, делаем s\u003ds+\u00270\u0027. Если же нет — делаем запрос для строки s+\u00271\u0027. Если ответ положительный — делаем s\u003ds+\u00271\u0027. Иначе же — суффикс найден. \u003c/p\u003e\u003cp\u003eДалее будем искать префикс. Мы знаем длину найденого суфикса, а значит — мы можем однозначно определить длину оставшегося префикса. Пусть она равна k. Тогда k раз делаем следующее. Делаем запрос про строку \u00270\u0027+s. Если ответ положителен — делаем s\u003d\u00270\u0027+s, иначе делаем s\u003d\u00271\u0027+s.\u003c/p\u003e\u003cp\u003eДавайте теперь оптимизировать решение, а именно поиск суффикса. Мы хотели бы делать запрос про символ \u00270\u0027 в конце, и если ответ отрицателен — считать, что в конец можно приписать \u00271\u0027, иначе \u00270\u0027. Однако, проблема в том, что мы могли дойти до конца строки и не заметить этого. Как же с этим бороться. Давайте каждый раз приписывать не 0 в конец строки , а рандомный символ. Тогда если мы m (m — фиксированное число) раз подряд получали, что такой подстроки нет — в лоб проверим коректность последних m добавлений. Возьмем m\u003d11. Тогда m случайных ошибок таких, что конец строки еще не достигнут, случатся примерно 1 раз на \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e11\u003c/sup\u003e\u003c/span\u003e запросовю То есть вероятность того, что это событие случится в одном тесте более одного раза — крайне мала. А значит в среднем мы будем делать примерно (1000+m+m+1) запросов для восстановления всей строки (на самом деле меньше). \u003c/p\u003e\u003cp\u003eТакое решение получает accepted.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача D\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eНайдем минимальное ребро, и пройдемся по нему нужное количество раз — это и будет ответом.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача E\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eОтсортируем текущий массив. Легко увидеть, что ответ стоит искать только среди k последовательных элементов отсортированного массива — иначе он увеличится.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача F\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eНаблюдение: в каждой вершине правильно построенного дерева может быть записано число от 0 до количества листов его поддерева включительно.\u003c/p\u003e\u003cp\u003eБудем делать динамику dp[v][sum] — минимальная цена, за которую можно в вершинке v число sum.\u003c/p\u003e\u003cp\u003eЕсть три случая:\u003c/p\u003e\u003cp\u003e1) Вершинка v — лист — случай тривиален.\u003c/p\u003e\u003cp\u003e2) У вершинки v — один ребенок — вершина u. Тогда dp[v][sum]\u003ddp[u][sum]+ABS(a[v]-sum).\u003c/p\u003e\u003cp\u003e3) У вершинки v — два ребенка — вершины u1 и u2. Прбежимся по всем возможным значениям динамики вершин u1 и u2 и обновим соответствующее значение вершины v. То есть dp[v][sum1+sum2]\u003dMIN(dp[v][sum1+sum2],dp[u1][sum1]+dp[u2][sum2]+ABS(sum1+sum2-a[v])).\u003c/p\u003e\u003cp\u003eЕсли перебирать sum1 до количества листов в поддереве u1, а sum2 до количества листов в поддереве u2 — получим суммарную сложность \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e (доказательство по \u003ca href\u003d\"http://codeforces.ru/blog/entry/6703\"\u003eссылке\u003c/a\u003e))\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача G\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eПросто проверим то, что просят в условии.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача H\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗаметим, что мы можем поменять переменные на 0 или 1 (в зависимости от четности). Дальше нам нужно посчитать значение полученного выражения по модулю 2 — для этого используем простой разбор строки. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eВНИМАНИЕ\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eКак видите, в этой тренировке я не выкладывал код, потому что мне лень прикреплять ссылки :) Однако, если вы считаете, что прочтение моего кода — полезно для вас — отпишите пожалуйста в комментариях (вопросы оставляйте там же), и я выложу коды к этой тренировки и также буду выкладывать коды в последующих разборах\u003c/p\u003e\u003c/div\u003e","tags":["разбор","тренировка"]}}