{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1507465431,"rating":0,"authorHandle":"Slamur","modificationTimeSeconds":1507465431,"id":55061,"title":"\u003cp\u003eБазовые структуры данных. Стек и очередь\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eЭтот пост продолжает мою серию постов о базовых структурах данных, в нем я расскажу о следующих структурах:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eстек\u003c/strong\u003e;\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003eочередь\u003c/strong\u003e и \u003cstrong\u003eдвунаправленная очередь\u003c/strong\u003e;\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003eочередь с приоритетами\u003c/strong\u003e. \u003cbr /\u003e\u003c/li\u003e \u003c/ul\u003e\u003ch3\u003e2) Стек [stack] и очередь [queue].\u003c/h3\u003e\u003cp\u003eДве простые структуры, которые могут быть сделаны на основе списка. Замечу, что данные структуры не подразумевают возможность индексации \u0026quot;из коробки\u0026quot; (хотя она может быть доступна в зависимости от реализации).\u003c/p\u003e\u003ch4\u003eСтек [stack].\u003c/h4\u003e\u003cp\u003eПредставьте, что вы идете мыть грязную посуду. Вы будете ее мыть в обратном от добавления в кучу порядке — раньше всего вымыта будет та посуда, которая была добавлена позже всего. Это можно считать одним из примеров стека — \u0026quot;Последний пришел, первый вышел\u0026quot; (\u0026quot;LIFO — last in, first out\u0026quot;).\u003c/p\u003e\u003cp\u003eОперации, доступные для стека:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eДобавить элемент на вершину стека [push];\u003c/li\u003e   \u003cli\u003eУдалить элемент с вершины стека [pop];\u003c/li\u003e   \u003cli\u003eПосмотреть, но не удалить элемент на вершине стека [peek].\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eОбе операции делаются за O(1) при использовании любого из видов списка — мы просто храним указатель на текущую вершину стека.\u003c/p\u003e\u003cp\u003eПлюсы:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eБыстрые операции добавления и удаления элемента из конца — O(1).\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eМинусы:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eОтсутствие индексации.\u003c/li\u003e   \u003cli\u003eНевозможность добавлять/удалять не последний элемент.\u003c/li\u003e \u003c/ul\u003e\u003ch4\u003eОчередь [queue] и двунаправленная очередь [deque].\u003c/h4\u003e\u003cp\u003eКогда вы приходите в поликлинику, почту или банк — вы встаете в очередь. Главный принцип очереди — \u0026quot;Первый пришел, первый вышел\u0026quot; (\u0026quot;FIFO — first in, first out\u0026quot;).\u003c/p\u003e\u003cp\u003eОперации, доступные для очереди:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eДобавить элемент в конец [add / enqueue (редко используемое название)];\u003c/li\u003e   \u003cli\u003eУдалить элемент из начала [poll / dequeue (редко используемое название)];\u003c/li\u003e   \u003cli\u003eПосмотреть, но не удалить первый элемент [peek].\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eОбе операции делаются за O(1) при использовании любого из видов списка — мы просто храним два указателя на текущие \u0026quot;голову\u0026quot; и \u0026quot;хвост\u0026quot; очереди. (При использовании ArrayList указатель на голову сдвигается, но элемент не удаляется).\u003c/p\u003e\u003cp\u003eПростейшая модификация очереди — двунаправленная очередь [deque]. У нее определены те же самые операции (также за O(1)), только к обоим концам:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eДобавить элемент в начало/конец;\u003c/li\u003e   \u003cli\u003eУдалить элемент из начала/конец;\u003c/li\u003e   \u003cli\u003eПосмотреть, но не удалить первый/последний элемент.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eПлюсы:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eБыстрые операции добавления и удаления из начала/конца — O(1).\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eМинусы:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eОтсутствие индексации.\u003c/li\u003e   \u003cli\u003eНевозможность добавлять/удалять не последний элемент.\u003c/li\u003e \u003c/ul\u003e\u003ch4\u003eОчередь с приоритетами [priority queue].\u003c/h4\u003e\u003cp\u003eДанную структуру я хотел бы рассмотреть отдельно от обычной очереди. Хотя она удовлетворяет всем требованиям к очереди, но сама идея операций немного отличается:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eДобавить элемент;\u003c/li\u003e   \u003cli\u003eУдалить наименьший/наибольший элемент;\u003c/li\u003e   \u003cli\u003eПосмотреть наименьший/наибольший элемент.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eНаименьший или наибольший элемент будут доставаться — зависит от реализации (одна очередь может либо на минимум, либо на максимум, не одновременно).\u003c/p\u003e\u003cp\u003eОбычно очередь с приоритетами выполняет все операции за O(logN) (кроме peek — за O(1)), так как реализуется на основе структуры \u0026quot;куча\u0026quot; [heap], которая представляет собой древесную структуру, а не линейную, как список.\u003c/p\u003e\u003cp\u003eПлюсы:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eБыстрое добавление элемента — O(logN).\u003c/li\u003e   \u003cli\u003eБыстрое удаление минимума/максимума — O(logN).\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eМинусы:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eОтсутствие индексации.\u003c/li\u003e   \u003cli\u003eНевозможность удалять произвольный элемент (не минимум/максимум).\u003c/li\u003e \u003c/ul\u003e\u003c/div\u003e","tags":["самара","структуры данных","стек","очередь","куча"]}}