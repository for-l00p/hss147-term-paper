{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1426457656,"rating":59,"authorHandle":"ykalchevskiy","modificationTimeSeconds":1426977837,"id":16971,"title":"\u003cp\u003eCPython и PyPy\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eПривет!\u003c/p\u003e\u003cp\u003eБлагодаря команде Codeforces, участникам теперь доступен \u003ca href\u003d\"http://codeforces.ru/blog/entry/16366\"\u003ePyPy\u003c/a\u003e. Он помогает решать задачи, которые CPython (\u0026quot;стандартный\u0026quot; Python) не может (например, \u003ca href\u003d\"/contest/523/problem/D\" title\u003d\"VK Cup 2015 - Qualification Round 2\"\u003e523D - Statistics of Recompressing Videos\u003c/a\u003e). Но хотя PyPy практически полностью совместим с CPython, не всегда можно просто поменять язык в настройках и улучшить посылку. Вернемся к вышеупомянутой задаче. На момент написания данного текста я был единственным участником, сдавшим эту задачу на PyPy. На СPython решение не проходило из-за ограничений по времени. Связано это с особенностями реализации ввода/вывода в PyPy и CPython. Об \u003ca href\u003d\"http://codeforces.ru/blog/entry/16366#comment-212579\"\u003eэтом\u003c/a\u003e уже упомянал \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/hellman1908\" title\u003d\"Expert hellman1908\"\u003ehellman1908\u003c/a\u003e. Дело в том, что чаще всего программы используют \u003ccode\u003eraw_input\u003c/code\u003e/\u003ccode\u003eprint\u003c/code\u003e, которые реализованы не так эффективно в PyPy, как хотелось бы. Следует использовать \u003ccode\u003esys.stdin\u003c/code\u003e/\u003ccode\u003esys.stdout\u003c/code\u003e. У меня есть шаблон с таким содержанием:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003edef read():\n    return stdin.readline().rstrip(\u0027\\n\u0027)\n\ndef read_array(sep\u003dNone, maxsplit\u003d-1):\n    return read().split(sep, maxsplit)\n\ndef read_int():\n    return int(read())\n\ndef read_int_array(sep\u003dNone, maxsplit\u003d-1):\n    return [int(a) for a in read_array(sep, maxsplit)]\n\ndef write(*args, **kwargs):\n    sep \u003d kwargs.get(\u0027sep\u0027, \u0027 \u0027)\n    end \u003d kwargs.get(\u0027end\u0027, \u0027\\n\u0027)\n    stdout.write(sep.join(str(a) for a in args) + end)\n\ndef write_array(array, **kwargs):\n    sep \u003d kwargs.get(\u0027sep\u0027, \u0027 \u0027)\n    end \u003d kwargs.get(\u0027end\u0027, \u0027\\n\u0027)\n    stdout.write(sep.join(str(a) for a in array) + end)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eИзначально эти функции использовали \u003ccode\u003eraw_input\u003c/code\u003e/\u003ccode\u003eprint\u003c/code\u003e :) Плюс этих функций в том, что они работают одинаково быстро и в PyPy, и в CPython. Более того, и во второй версии, и в третьей!\u003c/p\u003e\u003cp\u003eВторой момент состоит в том, что чем меньше отдельных выводов, тем лучше. Это может сыграть значительную роль! Сравните 2 посылки: \u003ca href\u003d\"/contest/523/submission/10293678\" title\u003d\"Submission 10293678 by ykalchevskiy\"\u003e10293678\u003c/a\u003e и \u003ca href\u003d\"/contest/523/submission/10293685\" title\u003d\"Submission 10293685 by ykalchevskiy\"\u003e10293685\u003c/a\u003e. Лучше писать:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etimes \u003d [...]\nsys.stdout.write(\u0027\\n\u0027.join(str(t) for t im times) + \u0027\\n\u0027)\n# or\nwrite_array(times, sep\u003d\u0027\\n\u0027)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eчем:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etimes \u003d [...]\nfor t in times:\n    sys.stdout.write(str(t) + \u0027\\n\u0027)\n    # or\n    write(t)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКонечно, в этом случае используется больше памяти, но памяти обычно хватает, чего не скажешь о времени.\u003c/p\u003e\u003cp\u003eЕще хотелось бы отметить одну вещь, которую также вскользь упомянули в комментариях к анонсу о PyPy. Обычно, на простых задачах CPython оказывается чуть быстрее, а на более долгих — быстрее PyPy.\u003c/p\u003e\u003cp\u003eЭтим постом я хотел напомнить о том, что есть PyPy, который может немного увеличить Ваши шансы. Если Вам известны еще какие-нибудь способы по улучшения производительности (кроме перехода на C++ или Java :)) или что-либо полезное, напишите, пожалуйста, в комментариях. Спасибо!\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD\u003c/strong\u003e: подправил функцию read()\u003c/p\u003e\u003c/div\u003e","tags":["python","python for competitions","pypy"]}}