{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1424460136,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1424468920,"id":16530,"title":"\u003cp\u003eНачинаем новый семестр\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eИ начинаем с изучения массивов. Массив — это индексированный набор однотипных данных. Обратите внимание: во-первых, данные однотипные — т.е. в массиве можно хранить, например, только целые числа или только строки, а вот хранить в одном массиве и строки, и числа (не в строковой форме) уже не получится. Во-вторых, набор индексированный — это означает, что каждый элемент массива имеет свой уникальный номер (индекс). Следовательно, можно поместить в массив одинаковые с точки зрения \u0026quot;содержания\u0026quot; элементы, которые при этом будут иметь разные индексы (это одно из ключевых отличий массива от множества — о котором мы будем говорить позже). \u003cbr /\u003e \u003cbr /\u003e Если, к примеру, мы будем рассматривать целое положительное число как индексированный набор десятичных цифр, то в качестве индекса может быть выбрана степень числа 10, на которую умножается та или иная цифра. \u003c/p\u003e\u003cp\u003eЗаметим, что под словом \u0026quot;индекс\u0026quot; можно понимать и не только какое-то конкретное число, но и совокупность чисел. Элемент в таблице определяется номерами строки и столбца, на пересечении которых он находится. В этом случае нужно говорить о двумерном массиве. Теоретически массив может иметь сколько угодно измерений. Впрочем, в сегодняшней записи мы ограничимся рассмотрением только одномерных массивов. \u003c/p\u003e\u003cp\u003eНумерация элементов в массиве в Java (впрочем, и во многих других языках) начинается с нуля. Таким образом, если в массиве содержится \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e элементов, то последний элемент имеет индекс \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e. Перебирать элементы массива можно с помощью уже знакомых вам циклов \u003ccode\u003ewhile\u003c/code\u003e и \u003ccode\u003efor\u003c/code\u003e. Однако существует ещё одна, специфическая форма цикла \u003ccode\u003efor\u003c/code\u003e, которая, однако, не позволяет изменять элементы массива. \u003c/p\u003e\u003cp\u003e\u003csmall\u003e \u003cem\u003eПочему существует такой \u0026quot;запрет\u0026quot;, будет рассматриваться несколько позже\u003c/em\u003e \u003c/small\u003e\u003c/p\u003e\u003cp\u003eРассмотрим следующую задачу (продолжим нумерацию с прошлого семестра). \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача 4\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eНа курсы по иностранному языку записалось \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e человек. Организаторы провели входное тестирование, результаты которого были оценены в баллах: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (целых числах от 0 до 100). Теперь организаторы решили разделить группу на две подгруппы. В первой подгруппе должны оказаться люди, которые набрали не менее среднего количества баллов за тестирование (среднего по всем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e желающим), во второй — все остальные. \u003c/p\u003e\u003cp\u003eВаша задача — определить численность каждой из подгрупп. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eРешение\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eСначала нам нужно определить средний балл, который является \u0026quot;пороговым\u0026quot; значением для попадания в первую группу. Для этого нужно просто просуммировать все баллы и разделить их на количество человек. Затем нужно будет просмотреть все баллы и определить, сколько из них больше или равны среднему баллу. Тем самым мы посчитаем количество людей в первой группе. Численность второй подгруппы будет равна разности между общим количеством желающих изучать иностранный язык и количеством оказавшихся в первой подгруппе. \u003c/p\u003e\u003cp\u003eСоздадим в проекте \u003ccode\u003epractice01\u003c/code\u003e класс с именем \u003ccode\u003eProblem04\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\npublic class Problem04 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t}\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДалее опишем класс \u003ccode\u003eTwoGroups\u003c/code\u003e, в котором будут объявлены переменная \u003ccode\u003en\u003c/code\u003e и массив целых чисел \u003ccode\u003eb\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003epackage practice01;\n\npublic class Problem04 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t}\n\n}\n\nclass TwoGroups {\n\t\n\tint n;\n\tint[] b;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ конструкторе класса TwoGroup выполним последовательно: \u003cbr /\u003e — чтение с клавиатуры числа \u003ccode\u003en\u003c/code\u003e; \u003cbr /\u003e — выделение памяти для массива \u003ccode\u003eb\u003c/code\u003e из \u003ccode\u003en\u003c/code\u003e элементов; \u003cbr /\u003e — чтение с клавиатуры элементов массива \u003ccode\u003eb\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\nimport java.util.Scanner;\n\npublic class Problem04 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t}\n\n}\n\nclass TwoGroups {\n\n\tTwoGroups() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tb \u003d new int[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t\tb[i] \u003d in.nextInt();\n\t\t}\n\t\tin.close();\n\t}\n\t\n\tint n;\n\tint[] b;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eСледующий шаг — вычисление среднего значения \u003cem\u003e(да, разумеется, мы могли посчитать среднее значение при вводе элементов массива, но мы стараемся без необходимости не смешивать \u0026quot;идейно\u0026quot; различающиеся действия).\u003c/em\u003e Вычисление значения проведём в методе \u003ccode\u003ecalcAverage()\u003c/code\u003e, возвращающем целое значение. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\nimport java.util.Scanner;\n\npublic class Problem04 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t}\n\n}\n\nclass TwoGroups {\n\n\tTwoGroups() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tb \u003d new int[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t\tb[i] \u003d in.nextInt();\n\t\t}\n\t\tin.close();\n\t}\n\t\n\tint calcAverage() {\n\t\tint res \u003d 0;\n\t\tfor (int elem: b){\n\t\t\tres +\u003d elem;\n\t\t}\n\t\t\n\t\tres \u003d res/n - ((res % n \u003d\u003d 0) ? 1: 0);\n\t\treturn res;\n\t}\n\t\n\tint n;\n\tint[] b;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВероятно, код метода \u003ccode\u003ecalcAverage\u003c/code\u003e требует детального рассмотрения. Во-первых, вы можете видеть \u0026quot;специальную форму\u0026quot; цикла \u003ccode\u003efor\u003c/code\u003e, которую можно прочитать как \u003ccode\u003eдля каждого элемента из b\u003c/code\u003e (перебор элементов осуществляется в \u0026quot;естественном\u0026quot; порядке: в случае с массивом от нулевого индекса до последнего). Посредством этого цикла в переменной \u003ccode\u003eres\u003c/code\u003e накапливается сумма элементов массива.\u003c/p\u003e\u003cp\u003eВторой важный момент — вычисление того значения, которое возвратит метод. После выполнения целочисленного деления \u003ccode\u003eres/n\u003c/code\u003e делается \u0026quot;коррекция\u0026quot; полученного результата. Предположим, что результатом \u0026quot;обычного\u0026quot; деления \u003ccode\u003eres\u003c/code\u003e на \u003ccode\u003en\u003c/code\u003e является некоторое число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e с ненулевой дробной частью. В этом случае люди, получившие \u003cspan class\u003d\"tex-span\"\u003e⌊ \u003ci\u003ed\u003c/i\u003e⌋\u003c/span\u003e баллов за тест, попадают во вторую группу (поскольку баллов у них меньше среднего значения). Если же у числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e дробная часть нулевая, то люди, получившие \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e баллов за тест, должны попасть в первую группу. Именно поэтому в случае нулевой дробной части из результата вычитается единица, что и даёт верхнюю границу баллов во второй группе. \u003c/p\u003e\u003cp\u003eТеперь можно ввести переменные \u003ccode\u003efirst\u003c/code\u003e и \u003ccode\u003esecond\u003c/code\u003e, и, проходя по массиву ещё раз, посчитать количество тех, кто окажется в первой и во второй подгруппах. Этот код содержится в методе \u003ccode\u003esolve()\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\nimport java.util.Scanner;\n\npublic class Problem04 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t}\n\n}\n\nclass TwoGroups {\n\n\tTwoGroups() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tb \u003d new int[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t\tb[i] \u003d in.nextInt();\n\t\t}\n\t\tin.close();\n\t}\n\t\n\tint calcAverage() {\n\t\tint res \u003d 0;\n\t\tfor (int elem: b){\n\t\t\tres +\u003d elem;\n\t\t}\n\t\t\n\t\tres \u003d res/n - ((res % n \u003d\u003d 0) ? 1: 0);\n\t\treturn res;\n\t}\n\t\n\tvoid solve() {\n\t\tint ave \u003d calcAverage();\n\t\tfirst \u003d 0;\n\t\tsecond \u003d 0;\n\t\t\t\t\n\t\tfor (int el: b){\n\t\t\tif (el \u0026gt; ave){\n\t\t\t\tfirst++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsecond++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint first;\n\tint second;\n\t\n\tint n;\n\tint[] b;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ методе \u003ccode\u003esolve()\u003c/code\u003e также можно увидеть специальную форму цикла \u003ccode\u003efor\u003c/code\u003e. Вообще говоря, можно было не писать ветвь \u003ccode\u003eelse\u003c/code\u003e в условном операторе, а просто по завершении цикла вычислить \u003ccode\u003esecond\u003c/code\u003e как разность \u003ccode\u003en - first\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eОбратите внимание, что переменные \u003ccode\u003efirst\u003c/code\u003e и \u003ccode\u003esecond\u003c/code\u003e объявлены в классе, а не в методе \u003ccode\u003esolve()\u003c/code\u003e: мы планируем использовать их также в методе печати \u003ccode\u003eprint()\u003c/code\u003e, код которого, вероятно, не нуждается в пояснениях:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\nimport java.util.Scanner;\n\npublic class Problem04 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t}\n\n}\n\nclass TwoGroups {\n\n\tTwoGroups() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tb \u003d new int[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t\tb[i] \u003d in.nextInt();\n\t\t}\n\t\tin.close();\n\t}\n\t\n\tint calcAverage() {\n\t\tint res \u003d 0;\n\t\tfor (int elem: b){\n\t\t\tres +\u003d elem;\n\t\t}\n\t\t\n\t\tres \u003d res/n - ((res % n \u003d\u003d 0) ? 1: 0);\n\t\treturn res;\n\t}\n\t\n\tvoid solve() {\n\t\tint ave \u003d calcAverage();\n\t\tfirst \u003d 0;\n\t\tsecond \u003d 0;\n\t\t\t\t\n\t\tfor (int el: b){\n\t\t\tif (el \u0026gt; ave){\n\t\t\t\tfirst++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsecond++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid print(){\n\t\tSystem.out.println(first + \u0026quot; \u0026quot; + second);\n\t}\n\t\n\tint first;\n\tint second;\n\t\n\tint n;\n\tint[] b;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНаконец, \u0026quot;соберём\u0026quot; все вместе: напишем код функции \u003ccode\u003emain()\u003c/code\u003e класса \u003ccode\u003eProblem04\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\nimport java.util.Scanner;\n\npublic class Problem04 {\n\n\tpublic static void main(String[] args) {\n\t\tTwoGroups tg \u003d new TwoGroups();\n\t\ttg.solve();\n\t\ttg.print();\n\t}\n\n}\n\nclass TwoGroups {\n\n\tTwoGroups() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tb \u003d new int[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t\tb[i] \u003d in.nextInt();\n\t\t}\n\t\tin.close();\n\t}\n\t\n\tint calcAverage() {\n\t\tint res \u003d 0;\n\t\tfor (int elem: b){\n\t\t\tres +\u003d elem;\n\t\t}\n\t\t\n\t\tres \u003d res/n - ((res % n \u003d\u003d 0) ? 1: 0);\n\t\treturn res;\n\t}\n\t\n\tvoid solve() {\n\t\tint ave \u003d calcAverage();\n\t\tfirst \u003d 0;\n\t\tsecond \u003d 0;\n\t\t\t\t\n\t\tfor (int el: b){\n\t\t\tif (el \u0026gt; ave){\n\t\t\t\tfirst++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsecond++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid print(){\n\t\tSystem.out.println(first + \u0026quot; \u0026quot; + second);\n\t}\n\t\n\tint first;\n\tint second;\n\t\n\tint n;\n\tint[] b;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТеперь можно запустить программу на выполнение. Проверьте, как она работает, например, на следующих небольших наборах данных:\u003c/p\u003e\u003cp\u003e5 \u003cbr /\u003e 3 7 4 5 6\u003c/p\u003e\u003cp\u003e6\u003cbr /\u003e 3 7 5 12 5 4\u003c/p\u003e\u003cp\u003e6\u003cbr /\u003e 3 7 5 4 6 5\u003c/p\u003e\u003cp\u003eПредложите свои тесты.\u003c/p\u003e\u003c/div\u003e","tags":["массивы","for each","java"]}}