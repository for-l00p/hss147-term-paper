{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1473539487,"rating":46,"authorHandle":"send_nodes","modificationTimeSeconds":1473700178,"id":47050,"title":"\u003cp\u003eCodeforces Round #370 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi everyone, here are the solutions to the contest problems.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/712/A\"\u003e712A — Memory and Crow\u003c/a\u003e\u003c/p\u003e\u003cp\u003eNote that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] + \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1] \u003d \u003ci\u003eb\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e. Use the initial condition \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e] \u003d \u003ci\u003ea\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e]\u003c/span\u003e and we can figure out the entire array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint arr[100000];\nint ans[100000];\nint main()\n{\n    int n;\n    cin \u0026gt;\u0026gt; n;\n    for(int i\u003d0; i \u0026lt; n; i++){\n        cin \u0026gt;\u0026gt; arr[i];\n\n    }\n\n    for(int i \u003d n-1; i \u0026gt;\u003d0; i--){\n        if(i\u003d\u003dn-1) ans[i] \u003d arr[i];\n        else ans[i] \u003d arr[i] + arr[i+1];\n    }\n    for(int i\u003d0; i \u0026lt; n; i++){\n        cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n    }\n    cout \u0026lt;\u0026lt; endl;\n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/712/B\"\u003e712B — Memory and Trident\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e has odd length, there is no possible string because letters must come in opposite pairs. Now, let\u0027s denote the ending coordinate after following \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e. Since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e has even length, \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003ex\u003c/i\u003e|\u003c/span\u003e has the same parity as \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003ey\u003c/i\u003e|\u003c/span\u003e. Suppose they are both even. Then clearly, we can make \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d 0\u003c/span\u003e in exactly \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/99/77/9977c96b96d133315645e2661e6faebb5e68b34f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e moves, and same for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. If instead they are both odd, then we can change exactly one x-character into a y-character. With the correct choices of these characters, now our string has \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003ex\u003c/i\u003e|\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003ey\u003c/i\u003e|\u003c/span\u003e with even parity, thus reducing to the problem above. Therefore, the answer is \u003cspan class\u003d\"tex-span\"\u003e(|\u003ci\u003ex\u003c/i\u003e| + |\u003ci\u003ey\u003c/i\u003e|) / 2\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003eS\u003c/i\u003e|)\u003c/span\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;string\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\nusing namespace std;\n\n\nint main()\n{\n    string str;\n    cin \u0026gt;\u0026gt; str;\n    if(str.length()%2\u003d\u003d1){\n        cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl;\n        return 0;\n    }\n\n    int x\u003d0,y\u003d0;\n    for(int i\u003d0; i \u0026lt; str.length(); i++){\n        if(str[i]\u003d\u003d\u0027U\u0027)y++;\n        if(str[i]\u003d\u003d\u0027D\u0027)y--;\n        if(str[i]\u003d\u003d\u0027L\u0027)x--;\n        if(str[i]\u003d\u003d\u0027R\u0027)x++;\n    }\n    cout \u0026lt;\u0026lt; (abs(x)+abs(y))/2 \u0026lt;\u0026lt; endl;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/712/C\"\u003e712C — Memory and De-Evolution\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s reverse the process: start with an equilateral triangle with side length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, and lets get to an equilateral triangle with side length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. In each step, we can act greedily while obeying the triangle inequality. This will give us our desired answer.\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint main()\n{\n    int x,y;\n    cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n\n    int besta\u003dy,bestb\u003dy,bestc\u003dy;\n\n    int turns \u003d 0;\n    while(true){\n        //check the current\n        if(besta\u0026gt;\u003dx \u0026amp;\u0026amp; bestb\u0026gt;\u003dx \u0026amp;\u0026amp; bestc\u0026gt;\u003dx){\n            cout \u0026lt;\u0026lt; turns \u0026lt;\u0026lt; endl;\n            break;\n        }\n        turns++;\n        if(turns%3\u003d\u003d1){\n            //update a\n            besta \u003d bestb+bestc-1;\n        }\n        if(turns%3\u003d\u003d2){\n            //update b\n            bestb \u003d besta+bestc-1;\n        }\n        if(turns%3\u003d\u003d0){\n            //update c\n            bestc \u003d besta+bestb-1;\n        }\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/712/D\"\u003e712D — Memory and Scores\u003c/a\u003e\u003c/p\u003e\u003cp\u003eOne approach to this problem is by first implementing naive DP in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003ekt\u003c/i\u003e)\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e. The state for this is \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ediff\u003c/i\u003e, \u003ci\u003eturn\u003c/i\u003e)\u003c/span\u003e, and transitions for \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ediff\u003c/i\u003e, \u003ci\u003eturn\u003c/i\u003e)\u003c/span\u003e is the sum \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ediff\u003c/i\u003e - 2\u003ci\u003ek\u003c/i\u003e, \u003ci\u003eturn\u003c/i\u003e - 1) + 2(\u003ci\u003ediff\u003c/i\u003e - 2\u003ci\u003ek\u003c/i\u003e + 1, \u003ci\u003eturn\u003c/i\u003e - 1) + 3(\u003ci\u003ediff\u003c/i\u003e - 2\u003ci\u003ek\u003c/i\u003e + 2, \u003ci\u003eturn\u003c/i\u003e - 1) + ... + (2\u003ci\u003ek\u003c/i\u003e + 1)(\u003ci\u003ediff\u003c/i\u003e, \u003ci\u003eturn\u003c/i\u003e - 1) + 2\u003ci\u003ek\u003c/i\u003e(\u003ci\u003ediff\u003c/i\u003e + 1, \u003ci\u003eturn\u003c/i\u003e - 1) + ...\u003c/span\u003e  \u003cspan class\u003d\"tex-span\"\u003e + \u003ci\u003ediff\u003c/i\u003e( + 2\u003ci\u003ek\u003c/i\u003e, \u003ci\u003eturn\u003c/i\u003e - 1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow, if we use prefix sums of all differences in (turn-1), along with a sliding window technique across the differences, we can cut a factor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, to achieve desired complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ekt\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eHowever, there is a much nicer solution in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ekt\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ekt\u003c/i\u003e)\u003c/span\u003e using generating functions(thanks to \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/minimario\" title\u003d\"Candidate Master minimario\"\u003eminimario\u003c/a\u003e). We can compute the coefficients of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/15/95/15954d19b8efac75a32523ae8b8a6a71bee5ef2c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, and the coefficient to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e corresponds to the number of ways we can form the difference \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. To compute these coefficients, we can use the binomial theorem.\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ekt\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e#include \u0026lt;bits\\stdc++.h\u0026gt;\nusing namespace std;\n\nint MOD \u003d 1000000007;\nlong long dp[2][1000000];\nint lowest;\n\nint h(int v){\n    return v - lowest;\n}\nint main()\n{\n    int a,b,k,t;\n    cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; k \u0026gt;\u0026gt; t;\n    int lowb \u003d a-b;\n    int highb \u003d a-b;\n\n    lowest \u003d lowb - 2*k*(t);\n    dp[0][h(lowb)] \u003d 1l;\n    //solve for ti \u003d 0\n    int curr \u003d 1;\n    for(int p \u003d lowb-2*k; p\u0026lt;\u003d lowb; p++){\n        dp[1][h(p)] \u003d curr;\n        curr++;\n    }\n    curr--;\n    for(int p \u003d lowb+1; p\u0026lt;\u003d lowb+2*k; p++){\n        curr--;\n        dp[1][h(p)] \u003d curr;\n    }\n    lowb -\u003d2*k;\n    highb+\u003d2*k;\n    for(int ti \u003d 1; ti \u0026lt;\u003d t-1; ti++){\n        int o \u003d ti%2;\n        vector\u0026lt;long long\u0026gt; pref;\n        pref.push_back(dp[o][h(lowb)]);\n        long long su \u003d dp[o][h(lowb)];\n        for(int p \u003d lowb+1; p \u0026lt;\u003d highb; p++){\n            su \u003d (su+dp[o][h(p)])%MOD;\n            pref.push_back(su);\n        }\n        int pe \u003d 2*k;\n        int il \u003d 0;\n        int ir \u003d 0;\n        int l \u003d lowb;\n        int r \u003d lowb;\n        int np \u003d lowb-2*k;\n        long long sum \u003d 0;\n        //get the prefix first\n\n        while(ir\u0026lt;\u003d2*k){\n            //evaluate current\n            sum \u003d (sum + pref[ir])%MOD;\n            dp[!o][h(np)] \u003d sum;\n            //update for the next thing\n            ir++;\n            r++;\n            np++;\n        }\n        pe \u003d 0;\n        ir--;\n        r--;\n        np--;\n        while(pe\u0026lt;2*k){\n            pe++;\n            ir++;\n            r++;\n            np++;\n            //evaluate\n            sum \u003d (sum + pref[ir])%MOD;\n            sum \u003d (sum - 2*pref[pe-1])%MOD;\n            sum \u003d (sum+MOD)%MOD;\n            dp[!o][h(np)] \u003d sum;\n        }\n\n        //slide into those dm\u0027s\n        while(r\u0026lt;highb){\n            //update\n            pe++;\n            r++;\n            l++;\n            ir++;\n            il++;\n            np++;\n\n            long long sum1 \u003d pref[pe-1] - ( (il\u003d\u003d1) ? 0 : pref[(il-1)-1]);\n            long long sum2 \u003d pref[ir] - pref[pe-1];\n            sum \u003d (sum - sum1 + MOD)%MOD;\n            sum \u003d (sum + sum2)%MOD;\n            dp[!o][h(np)] \u003d sum;\n        }\n        //finally, suffix\n        while(l\u0026lt;highb){\n            l++;\n            il++;\n            pe++;\n            np++;\n            //subtract [l-1,pe-1]\n            long long sum1 \u003d pref[min(pe-1,ir)] - ((il\u003d\u003d1) ? 0 : pref[il-1-1]);\n            sum \u003d (sum - sum1 + MOD)%MOD;\n            if(pe\u0026gt;ir){\n\n            }\n            else{\n                long long sum2 \u003d pref[ir]-pref[pe-1];\n                sum \u003d (sum + sum2)%MOD;\n            }\n            dp[!o][h(np)] \u003d sum;\n        }\n\n        lowb-\u003d2*k;\n        highb+\u003d2*k;\n    }\n    long long ans \u003d 0;\n    int o \u003d t%2;\n    for(int p \u003d 1; p \u0026lt;\u003d highb; p++){\n        ans \u003d (ans+dp[o][h(p)])%MOD;\n    }\n    cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eTime Complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ekt\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ekt\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair\u0026lt;int, int\u0026gt; pii;\ntypedef vector\u0026lt;int\u0026gt; vi;\n\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n\n#define FOR(i, a, b) for (int i\u003da; i\u0026lt;b; i++)\n#define F0R(i, a) FOR(i, 0, a)\n\nconst int MAX \u003d 1000005;\nconst int MOD \u003d 1000000007;\n\nint f[MAX];\nint fi[MAX];\n\nint pos(int a) { return ((ll)a%MOD+MOD)%MOD; }\nint add(int a, int b) { return ((ll)a+(ll)b)%MOD; }\nint sub(int a, int b) { return pos(a-b); }\nint mult(int a, int b) { return (ll)pos(a)*b%MOD; }\nint sq(int a) { return (ll)a*a%MOD; }\n\nint expo(int a, int b) {\n    if (b \u003d\u003d 0) { return 1; }\n    if (b%2) { return mult(a, sq(expo(a, b/2))); }\n    else { return sq(expo(a, b/2)); }\n}\nint inv(int a) { return expo(a, MOD-2); }\n\nint c(int n, int k) {\n    return mult(f[n], mult(fi[k], fi[n-k]));\n}\n\nint poly1[MAX];\nint pref2[MAX];\nint main() {\n    f[0] \u003d fi[0] \u003d 1;\n    FOR(i, 1, MAX) { f[i] \u003d mult(f[i-1], i); fi[i] \u003d inv(f[i]); }\n    int a, b, k, t;\n    cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; k \u0026gt;\u0026gt; t;\n    if(b-a \u0026gt; 2*k*t){\n    \tcout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl;\n    \treturn 0;\n    }\n    F0R(i, 2*t+1) { poly1[(2*k+1)*i] \u003d ((i%2\u003d\u003d0)?1:-1)*c(2*t, i); }\n    F0R(i, MAX) { pref2[i] \u003d c(2*t-1+i+1, 2*t); }\n    int lb \u003d 2*k*t+b-a+1;\n    int ub \u003d 4*k*t;\n    int ans \u003d 0;\n    F0R(i, 2*t+1) {\n        int l \u003d lb-(2*k+1)*i;\n        int u \u003d ub-(2*k+1)*i;\n        if (u \u0026lt; 0) { break; }\n        if (l \u0026lt; 0) { ans \u003d add(ans, mult(poly1[(2*k+1)*i], pref2[u])); }\n        else { ans \u003d add(ans, mult(poly1[(2*k+1)*i], sub(pref2[u], pref2[l-1]))); }\n    }\n    cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/712/E\"\u003e712E — Memory and Casinos\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLets think about two segments of casinos \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ej\u003c/i\u003e + 1, \u003ci\u003en\u003c/i\u003e]\u003c/span\u003e. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e([\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e])\u003c/span\u003e denote the probability we dominate on \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e]\u003c/span\u003e, and let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e([\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e])\u003c/span\u003e denote the probability we start on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e and end by moving right of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. Let \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u003d \u003ci\u003eL\u003c/i\u003e([\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e])\u003c/span\u003e, \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u003d \u003ci\u003eL\u003c/i\u003e([\u003ci\u003ej\u003c/i\u003e + 1, \u003ci\u003en\u003c/i\u003e])\u003c/span\u003e,\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u003d \u003ci\u003eR\u003c/i\u003e([\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e])\u003c/span\u003e,\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u003d \u003ci\u003eR\u003c/i\u003e([\u003ci\u003ej\u003c/i\u003e + 1, \u003ci\u003en\u003c/i\u003e])\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eYou can use a geometric series to figure out both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e([\u003ci\u003ei\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e])\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e([\u003ci\u003ei\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e])\u003c/span\u003e using only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e. To derive these series, think about the probability we cross over from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/span\u003e once, twice, three times, and so on. The actual formulas are,\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bf/0b/bf0ba7c1bbd62fab28a4df81d5c951f96af0b8fb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/80/c9/80c9e6a08af6e2557ae6ea855411c75ceb3c54e5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eNow we can build a segment tree on the casinos, and use the above to merge segments.\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e + \u003ci\u003eQlogN\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\n\nint n;\ndouble pr[100000];\npair\u0026lt;double,double\u0026gt; seg[400000];\nbool ze(double d){\n\treturn (abs(d) \u0026lt;\u003d 0.0000000001);\n}\npair\u0026lt;double,double\u0026gt; merge(pair\u0026lt;double,double\u0026gt; a, pair\u0026lt;double,double\u0026gt; b){\n\tif(ze(a.first+1) \u0026amp;\u0026amp; ze(a.second+1)) return b;\n\tif(ze(b.first+1) \u0026amp;\u0026amp; ze(b.second+1)) return a;\n\tdouble l1 \u003d a.first;\n\tdouble r1 \u003d a.second;\n\tdouble l2 \u003d b.first;\n\tdouble r2 \u003d b.second;\n\tif(ze(((l2-1)*r1+1))) return make_pair(0,0);\n\tdouble le \u003d l1*l2/((l2-1)*r1+1);\n\tdouble ri \u003d r2+(r1*l2*(-r2+1))/(-r1*(-l2+1)+1);\n\treturn make_pair(le,ri);\n}\nvoid build(int no, int b, int e){\n\tif(b\u003d\u003de){\n\t\tseg[no] \u003d make_pair(pr[b],pr[b]);\n\t\treturn;\n\t}\n\tint mid \u003d (b+e)/2;\n\tbuild(2*no,b,mid);\n\tbuild(2*no+1,mid+1,e);\n\tseg[no] \u003d merge(seg[2*no],seg[2*no+1]);\n}\nvoid upd(int no, int b, int e, int i, double val){\n\tif(i\u0026lt;b || i\u0026gt;e) return;\n\tif(b\u003d\u003de){\n\t\tseg[no] \u003d make_pair(val,val);\n\t\treturn;\n\t}\n\tint mid \u003d (b+e)/2;\n\tupd(2*no,b,mid,i,val);\n\tupd(2*no+1,mid+1,e,i,val);\n\tseg[no] \u003d merge(seg[2*no],seg[2*no+1]);\n}\npair\u0026lt;double,double\u0026gt; query(int no, int b, int e, int l, int r){\n\tif(b\u0026gt;r || e\u0026lt;l) return make_pair(-1,-1);\n\tif(l\u0026lt;\u003db \u0026amp;\u0026amp; e\u0026lt;\u003dr) return seg[no];\n\tint mid \u003d (b+e)/2;\n\treturn merge(query(2*no,b,mid,l,r),query(2*no+1,mid+1,e,l,r));\n}\nint main(){\n    int q;\n\tscanf(\u0026quot;%d %d\u0026quot;, \u0026amp;n, \u0026amp;q);\n\tfor(int i\u003d0; i \u0026lt; n; i++){\n\t\tint a,b;\n\t\tscanf(\u0026quot;%d %d\u0026quot;, \u0026amp;a, \u0026amp;b);\n\t\tpr[i] \u003d (double)a / (double)b;\n\t}\n\t\n\tbuild(1,0,n-1);\n\tfor(int que \u003d 0; que \u0026lt; q; que++){\n\t\tint ty;\n\t\tint a;\n\t\tint b;\n\t\tscanf(\u0026quot;%d %d %d\u0026quot;, \u0026amp;ty, \u0026amp;a, \u0026amp;b);\n\t\tif(ty\u003d\u003d1){\n\t\t\tint c;\n\t\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;c);\n\t\t\tupd(1,0,n-1,a-1, (double)b / (double)c);\n\t\t}\n\t\telse{\n\t\t    printf(\u0026quot;%.20f\\n\u0026quot;, query(1,0,n-1,a-1,b-1).first);\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}