{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1440228835,"rating":-3,"authorHandle":"rekt_n00b","modificationTimeSeconds":1440230783,"id":19907,"title":"\u003cp\u003ePractice Contest 2 — Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eProblem A : Ultra Noob Problem\u003c/h2\u003e\u003cp\u003eThis problem was very simple and all of you got it. You just had to run two loops and increment counter if A[i] \u0026gt; A[j].\u003c/p\u003e\u003ch4\u003eTime Complexity : O(N^2)\u003c/h4\u003e\u003cp\u003e\u003cbr /\u003e Challenge : Try to solve the same problem in N log N time. \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003ch2\u003eProblem C : Feroz and Number Game\u003c/h2\u003e\u003cp\u003eThe problem statement said that we could divide a number by 3 or subtract 1 at each step.\u003cbr /\u003e It is very obvious that dividing by 3 would get us much closer to the number 1 rather than subtracting by 1. \u003cbr /\u003e The only thing that one needed to take care of was that if the number became 2 during any intermediate step, we needed to subtract 1 from it as our last step. \u003cbr /\u003e The pseudocode was as follows: \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003ewhile( N \u0026gt;\u003d 3) { steps++; N/\u003d3 ; }\u003c/strong\u003e \u003cbr /\u003e \u003cstrong\u003esteps +\u003d ( N — 1 );\u003c/strong\u003e \u003cbr /\u003e \u003cstrong\u003eprint steps\u003c/strong\u003e \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003ch4\u003eTime Complexity \u003d O(log N) // base 3\u003c/h4\u003e\u003cp\u003e\u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e\u003ch2\u003eProblem B : AJKrish\u0027s Fantasy\u003c/h2\u003e\u003cp\u003e\u003cbr /\u003e The problem statement can be summarized as follows : \u003cbr /\u003e \u003cstrong\u003ef(x) \u003d sum of factors of x.\u003c/strong\u003e \u003cbr /\u003e \u003cstrong\u003eAnswer Q queries of the form [L,R] in which we must print sum of f(x) for all x in [L,R]\u003c/strong\u003e \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003ch4\u003eNaive Approach\u003c/h4\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eThe most naive way to approach this problem would be to make a function which returns sum of factors and call it for each x in [L,R] and add the returned value to the total_sum . This approach would be \u003cstrong\u003every slow\u003c/strong\u003e as in the worst case L,R can be 1,1000000 for all Q queries. Hence the time it will take for Q \u003d 10^5 will be 10^5 * ( 1000000 * root 1000000 ) which \u003cstrong\u003ewill run forever\u003c/strong\u003e . \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003ch4\u003eOptimizing Sum of Factors f(x) function to run in sqrt(x) time\u003c/h4\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eLet us first design a function which returns \u003cstrong\u003esum of factors of a number \u0027x\u0027 in sqrt(x) time.\u003c/strong\u003e \u003cbr /\u003e \u003cstrong\u003eObserve that if \u0027i\u0027 is a factor of \u0027x\u0027 then x/i is also a factor of x , because factors always occur in pairs.\u003c/strong\u003e \u003cbr /\u003e Thus the \u003cstrong\u003elargest factor we need to consider in order to find all factors of a number is sqrt(x) .\u003c/strong\u003e \u003cbr /\u003e Assume that the number is 16 \u003cbr /\u003e : We will run a loop from [1,4] : \u003cbr /\u003e \u003cstrong\u003e1 is a factor , therefore 16 is also a factor -\u0026gt; Add 16 and 1 to sum\u003c/strong\u003e \u003cbr /\u003e \u003cstrong\u003e2 is a factor , therefore 8 is also a factor -\u0026gt; Add 2 and 8 to sum\u003c/strong\u003e \u003cbr /\u003e \u003cstrong\u003e4 is a factor --\u0026gt; Add 4 to sum ( Be sure not to overcount for this case )\u003c/strong\u003e \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eHence in sqrt(x) time we can find the sum of factors of a number \u0027x\u0027\u003c/strong\u003e \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003ch4\u003ePrecomputing f(x) and Building Cumulative Sums\u003c/h4\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eYou can see that x lies in the range [1,1000000] which isn\u0027t very big. \u003cbr /\u003e The key idea is that we can find f(x) for each x in [1,1000000] and store it in an array.\u003c/strong\u003e \u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eLet SF[i] denote Sum of Factors of \u0027i\u0027 i.e. f(i) : \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSF[i] \u003d sum_of_factors(i) ; // Where sum of factors function runs in root(i) time.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eHence Precomputing SF[i] for all i in [1,1000000] will take \u003cstrong\u003e(sigma(root i) from i \u003d 1 to 1000000) time \u003cbr /\u003e This will not take more than 2-3 seconds.\u003c/strong\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eAfter we have got SF[] array , we need to build a prefix sum or cumulative sums array\u003c/strong\u003e : \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eLet \u003cstrong\u003eC[i] \u003d sum of SF[] from SF[1] to SF[i].\u003c/strong\u003e \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003ch4\u003eWhy would this help us ?\u003c/h4\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eObserve that if we have the C[] array each query L,R is simply C[R] — C[L-1]\u003c/strong\u003e \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003ch4\u003eHow to build C[] array efficiently?\u003c/h4\u003e\u003cp\u003e\u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eC[i] denotes sum of SF[] from SF[1] to SF[i]. \u003cbr /\u003e Let us say we know C[i] . \u003cstrong\u003eWhat will C[i+1] be ?\u003c/strong\u003e \u003cbr /\u003e \u003cstrong\u003eC[i+1] \u003d sum of SF[] from SF[1] to SF[i+1] \u003d (sum of SF[] from SF[1] to SF[i]) + SF[i+1]\u003c/strong\u003e \u003cbr /\u003e  \u003cstrong\u003e\u003d C[i] + SF[i+1]\u003c/strong\u003e \u003cbr /\u003e \u003cbr /\u003e \u003cstrong\u003eTherefore , C[i] is simply C[i-1] + SF[i]\u003c/strong\u003e \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eNow while inputting L,R we can directly print C[R] — C[L-1]\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eNotice how with some clever precomputation , we are able to answer each query [L,R] in constant time , without running a loop or anything of that sort . Our answer has simply reduced to printing C[R] — C[L-1] !\u003c/strong\u003e \u003cbr /\u003e\u003c/p\u003e\u003ch4\u003eTime Complexity : O( N root N + Q) where N \u003d 10^6 , Q \u003d 10^5\u003c/h4\u003e\u003cp\u003e\u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003ch4\u003eAuthor\u0027s solution in JAVA : \u003ca href\u003d\"http://pastie.org/10367832\"\u003ehttp://pastie.org/10367832\u003c/a\u003e\u003c/h4\u003e\u003cp\u003e\u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eI will also post a N log N solution to this problem soon. Feel free to comment if you all have any queries.\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}