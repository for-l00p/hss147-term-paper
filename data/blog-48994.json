{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1481451607,"rating":89,"authorHandle":"Arpa","modificationTimeSeconds":1481791931,"id":48994,"title":"\u003cp\u003eSome method for solving RMQ\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e(This blog has been restored as \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Errichto\" title\u003d\"Grandmaster Errichto\"\u003eErrichto\u003c/a\u003e and some other users had wanted.)\u003c/p\u003e\u003cp\u003eHi !\u003c/p\u003e\u003cp\u003eHere is some implementation for solving RMQ (Tarjan’s algorithm) (Range Maximum / Minimum Query).\u003c/p\u003e\u003cp\u003eIt’s very simple to implement and it’s time complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003en\u003c/i\u003e + \u003ci\u003eq\u003c/i\u003e)·\u003ci\u003ea\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e()\u003c/span\u003e stands for Akerman inverse function used in DSU.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem :\u003c/strong\u003e Given array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e integers, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e queries, for each query print the maximum value in range \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e]\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSolution:\u003c/strong\u003e We need a array of vectors, called assigned. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eassigned\u003c/i\u003e[\u003ci\u003er\u003c/i\u003e]\u003c/span\u003e contains queries that their \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e. When getting queries, push each query in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eassigned\u003c/i\u003e[\u003ci\u003eR\u003c/i\u003e]\u003c/span\u003e. We need a dsu, first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epar\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. We need a stack, named \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003est\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eFor i from 0 to n, do:\n\tWhile st is not empty and a[st.top] \u0026lt;\u003d a[i]\n\t\tSet i parent of st.top in dsu and pop this element from st.\n\tPush i to st\n\tFor each query assigned to i\n\t\tAnswer of this query is a[root of L of this query in DSU].\n\u003c/code\u003e\u003c/pre\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode here.\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e// God \u0026amp; me\n// \u0026quot;Someone like you\u0026quot;?! Unbelievable ... \n#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\n\nconst int maxn \u003d 1e5 + 17;\nint par[maxn], ans[maxn], n, a[maxn], l[maxn], q;\nvector\u0026lt;int\u0026gt; qu[maxn];\nint root(int v){\n    return par[v] \u003d\u003d -1 ? v : par[v] \u003d root(par[v]);\n}\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0);\n    memset(par, -1, sizeof par);\n    cin \u0026gt;\u0026gt; n;\n    for(int i \u003d 0; i \u0026lt; n; i++)  cin \u0026gt;\u0026gt; a[i];\n    cin \u0026gt;\u0026gt; q;\n    for(int i \u003d 0, r; i \u0026lt; q; i++){\n\tcin \u0026gt;\u0026gt; l[i] \u0026gt;\u0026gt; r, r--, l[i]--;\n\tqu[r].push_back(i);\n    }\n    stack\u0026lt;int\u0026gt; st;\n    for(int i \u003d 0; i \u0026lt; n; i++){\n\twhile(st.size() \u0026amp;\u0026amp; a[st.top()] \u0026lt;\u003d a[i])\n\t    par[st.top()] \u003d i, st.pop();\n\tst.push(i);\n\tfor(auto qi : qu[i])\n\t    ans[qi] \u003d a[root(l[qi])];\n    }\n    for(int i \u003d 0; i \u0026lt; q; i++)\n\tcout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0027 \u0027;\n    cout \u0026lt;\u0026lt; \u0027\\n\u0027;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eNote that in above code I used path-compression technique for dsu only, size-comparing technique can be used too (but it has lower performance).\u003c/p\u003e\u003cp\u003eIt’s obviously true, because each time for any \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e ≤ \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003eroot\u003c/i\u003e(\u003ci\u003ej\u003c/i\u003e)]\u003c/span\u003e is the greatest value in range \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ej\u003c/i\u003e, \u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e.\u003c/p\u003e\u003ch2\u003ePerformance test\u003c/h2\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eThis method (known as Arpas trick)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e// God \u0026amp; me\n// \u0026quot;Someone like you\u0026quot;?! Unbelievable ... \n#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\n\nconst int maxn \u003d 1 \u0026lt;\u0026lt; 22;\nint par[maxn], ans[maxn], n, a[maxn], l[maxn], q, head[maxn], prv[maxn], st[maxn], tail;\nint root(int v){\n    return par[v] \u003d\u003d -1 ? v : par[v] \u003d root(par[v]);\n}\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0);\n    memset(par, -1, sizeof par);\n    memset(head, -1, sizeof head);\n    cin \u0026gt;\u0026gt; n;\n    for(int i \u003d 0; i \u0026lt; n; i++)  cin \u0026gt;\u0026gt; a[i];\n    cin \u0026gt;\u0026gt; q;\n    for(int i \u003d 0, r; i \u0026lt; q; i++){\n\tcin \u0026gt;\u0026gt; l[i] \u0026gt;\u0026gt; r, r--, l[i]--;\n\tprv[i] \u003d head[r], head[r] \u003d i;\n    }\n    for(int i \u003d 0; i \u0026lt; n; i++){\n\twhile(tail-- \u0026amp;\u0026amp; a[ st[tail] ] \u0026lt;\u003d a[i])\n\t    par[ st[tail] ] \u003d i;\n\tst[++tail] \u003d i;\n\tfor(int qi \u003d head[i]; qi \u0026gt;\u003d 0; qi \u003d prv[qi])\n\t    ans[qi] \u003d a[root(l[qi])];\n    }\n    for(int i \u003d 0; i \u0026lt; q; i++)\n\tcout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0027 \u0027;\n    cout \u0026lt;\u0026lt; \u0027\\n\u0027;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eVector + Binary search\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e// God \u0026amp; me\n// \u0026quot;Someone like you\u0026quot;?! Unbelievable ...\n#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int maxn \u003d 1 \u0026lt;\u0026lt; 22;\nint n, q, a[maxn], ans[maxn], head[maxn], prv[maxn], l[maxn];\nvector\u0026lt;int\u0026gt; v, qu[maxn];\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0);\n    memset(head, -1, sizeof head);\n    cin \u0026gt;\u0026gt; n;\n    for(int i \u003d 0; i \u0026lt; n; i++)  cin \u0026gt;\u0026gt; a[i];\n    cin \u0026gt;\u0026gt; q;\n    for(int i \u003d 0, r; i \u0026lt; q; i++){\n\tcin \u0026gt;\u0026gt; l[i] \u0026gt;\u0026gt; r;\n\tprv[i] \u003d head[r], head[r] \u003d i;\n    }\n    for(int i \u003d 0; i \u0026lt; n; i++){\n\twhile(v.size() \u0026amp;\u0026amp; a[v.back()] \u0026lt;\u003d a[i])  v.pop_back();\n\tv.push_back(i);\n\tfor(int qi \u003d head[i]; qi \u0026gt;\u003d 0; qi \u003d prv[qi])\n\t    ans[qi] \u003d a[*lower_bound(v.begin(), v.end(), l[qi])];\n    }\n    for(int i \u003d 0; i \u0026lt; q; i++)\n\tcout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0027 \u0027;\n    cout \u0026lt;\u0026lt; \u0027\\n\u0027;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSparse table\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e// God \u0026amp; me\n// \u0026quot;Someone like you\u0026quot;?! Unbelievable ... \n#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\n\nconst int maxn \u003d 1 \u0026lt;\u0026lt; 22, lg \u003d 22;\nint par[maxn], ans[maxn], n, q, lg2[maxn];\nint spt[lg][maxn];\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0);\n    memset(par, -1, sizeof par);\n    cin \u0026gt;\u0026gt; n;\n    for(int i \u003d 0; i \u0026lt; n; i++)\n\tcin \u0026gt;\u0026gt; spt[0][i];\n    for(int i \u003d 2; i \u0026lt; n; i++)  lg2[i] \u003d lg2[i \u0026gt;\u0026gt; 1] + 1;\n    for(int k \u003d 1; k \u0026lt; lg; k++)\n\tfor(int i \u003d 0; i + (1 \u0026lt;\u0026lt; k) \u0026lt;\u003d n; i++)\n\t    spt[k][i] \u003d max(spt[k - 1][i], spt[k - 1][i + 1 \u0026lt;\u0026lt; (k - 1)]);\n    cin \u0026gt;\u0026gt; q;\n    for(int i \u003d 0, l, r; i \u0026lt; q; i++){\n\tcin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r, r++;\n\tcout \u0026lt;\u0026lt; max(spt[ lg2[r - l] ][l], spt[ lg2[r - l] ][ r - (1 \u0026lt;\u0026lt; lg2[r - l]) ]) \u0026lt;\u0026lt; \u0027 \u0027;\n    }\n    cout \u0026lt;\u0026lt; \u0027\\n\u0027;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eO(n) method\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e// God \u0026amp; me\n// \u0026quot;Someone like you\u0026quot;?! Unbelievable ...\n#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int maxn \u003d 1 \u0026lt;\u0026lt; 22;\ntemplate\u0026lt;typename Val, typename Compare \u003d std::less\u0026lt;Val\u0026gt;, int BlockSize \u003d 10\u0026gt;\nclass DirectRMQ {\npublic:\n\ttypedef int Index;\t//今のところ大きくともintを仮定している(queryとか)\n\ttypedef char InBlockIndex;\n\ttypedef InBlockIndex(*BlockTypeRef)[BlockSize];\n\n\tDirectRMQ(Compare comp_ \u003d Compare()) :\n\t\tblockTypes(0), innerBlockTable(0), sparseTable(0) {\n\t\tcomp \u003d comp_;\n\t\tcalcBallotNumbers();\n\t\tbuildInnerBlockTable();\n\t}\n\t~DirectRMQ() {\n\t\tdelete[] innerBlockTable;\n\t\tdelete[] blockTypes; delete[] sparseTable;\n\t}\n\n\tvoid build(const Val *a, Index n) {\n\t\tblocks \u003d (n + BlockSize - 1) / BlockSize;\n\t\tstHeight \u003d 0; while(1 \u0026lt;\u0026lt; stHeight \u0026lt; blocks) ++ stHeight;\n\t\tdelete[] blockTypes; delete[] sparseTable;\n\n\t\tblockTypes \u003d new BlockTypeRef[blocks];\n\t\tcalcBlockTypes(a, n);\n\t\tbuildInnerBlockTable(a, n);\n\t\tsparseTable \u003d new Index[blocks * stHeight];\n\t\tbuildSparseTable(a);\n\t}\n\n\t//[l,r]の閉区間\n\tIndex query(const Val *a, Index l, Index r) const {\n\t\tIndex x \u003d l / BlockSize, y \u003d r / BlockSize, z \u003d y - x;\n\t\tif(z \u003d\u003d 0) return x * BlockSize + blockTypes[x][l % BlockSize][r % BlockSize];\n\t\tif(z \u003d\u003d 1) return assumeleft_minIndex(a,\n\t\t\tx * BlockSize + blockTypes[x][l % BlockSize][BlockSize - 1],\n\t\t\ty * BlockSize + blockTypes[y][0][r % BlockSize]);\n\t\tz -\u003d 2;\n\t\tIndex k \u003d 0, s;\n\t\ts \u003d ((z \u0026amp; 0xffff0000) !\u003d 0) \u0026lt;\u0026lt; 4; z \u0026gt;\u0026gt;\u003d s; k |\u003d s;\n\t\ts \u003d ((z \u0026amp; 0x0000ff00) !\u003d 0) \u0026lt;\u0026lt; 3; z \u0026gt;\u0026gt;\u003d s; k |\u003d s;\n\t\ts \u003d ((z \u0026amp; 0x000000f0) !\u003d 0) \u0026lt;\u0026lt; 2; z \u0026gt;\u0026gt;\u003d s; k |\u003d s;\n\t\ts \u003d ((z \u0026amp; 0x0000000c) !\u003d 0) \u0026lt;\u0026lt; 1; z \u0026gt;\u0026gt;\u003d s; k |\u003d s;\n\t\ts \u003d ((z \u0026amp; 0x00000002) !\u003d 0) \u0026lt;\u0026lt; 0; z \u0026gt;\u0026gt;\u003d s; k |\u003d s;\n\t\treturn assumeleft_minIndex(a\n\t\t\t, assumeleft_minIndex(a,\n\t\t\t\tx * BlockSize + blockTypes[x][l % BlockSize][BlockSize - 1],\n\t\t\t\tsparseTable[x + 1 + blocks * k])\n\t\t\t, assumeleft_minIndex(a,\n\t\t\t\tsparseTable[y + blocks * k - (1 \u0026lt;\u0026lt; k)],\n\t\t\t\ty * BlockSize + blockTypes[y][0][r % BlockSize])\n\t\t);\n\t}\n\n\tVal queryVal(const Val *a, Index l, Index r) const {\n\t\tIndex x \u003d l / BlockSize, y \u003d r / BlockSize, z \u003d y - x;\n\t\tif(z \u003d\u003d 0) return a[x * BlockSize + blockTypes[x][l % BlockSize][r % BlockSize]];\n\t\tVal edge \u003d minVal(\n\t\t\ta[x * BlockSize + blockTypes[x][l % BlockSize][BlockSize - 1]],\n\t\t\ta[y * BlockSize + blockTypes[y][0][r % BlockSize]]);\n\t\tif(z \u003d\u003d 1) return edge;\n\t\tz -\u003d 2;\n\t\tIndex k \u003d 0, s;\n\t\ts \u003d ((z \u0026amp; 0xffff0000) !\u003d 0) \u0026lt;\u0026lt; 4; z \u0026gt;\u0026gt;\u003d s; k |\u003d s;\n\t\ts \u003d ((z \u0026amp; 0x0000ff00) !\u003d 0) \u0026lt;\u0026lt; 3; z \u0026gt;\u0026gt;\u003d s; k |\u003d s;\n\t\ts \u003d ((z \u0026amp; 0x000000f0) !\u003d 0) \u0026lt;\u0026lt; 2; z \u0026gt;\u0026gt;\u003d s; k |\u003d s;\n\t\ts \u003d ((z \u0026amp; 0x0000000c) !\u003d 0) \u0026lt;\u0026lt; 1; z \u0026gt;\u0026gt;\u003d s; k |\u003d s;\n\t\ts \u003d ((z \u0026amp; 0x00000002) !\u003d 0) \u0026lt;\u0026lt; 0; z \u0026gt;\u0026gt;\u003d s; k |\u003d s;\n\t\treturn minVal(edge, minVal(\n\t\t\ta[sparseTable[x + 1 + blocks * k]],\n\t\t\ta[sparseTable[y + blocks * k - (1 \u0026lt;\u0026lt; k)]]));\n\t}\nprivate:\n\tCompare comp;\n\n\tint ballotNumbers[BlockSize + 1][BlockSize + 1];\n\tInBlockIndex(*innerBlockTable)[BlockSize][BlockSize];\n\n\tIndex blocks;\n\tint stHeight;\n\tBlockTypeRef *blockTypes;\n\tIndex *sparseTable;\n\n\tinline Index minIndex(const Val *a, Index x, Index y) const {\n\t\treturn comp(a[x], a[y]) || (a[x] \u003d\u003d a[y] \u0026amp;\u0026amp; x \u0026lt; y) ? x : y;\n\t}\n\tinline Index assumeleft_minIndex(const Val *a, Index x, Index y) const {\n\t\treturn comp(a[y], a[x]) ? y : x;\n\t}\n\n\tinline Val minVal(Val x, Val y) const {\n\t\treturn comp(y, x) ? y : x;\n\t}\n\n\tvoid buildSparseTable(const Val *a) {\n\t\tIndex *b \u003d sparseTable;\n\t\tif(stHeight) for(Index i \u003d 0; i \u0026lt; blocks; i ++)\n\t\t\tb[i] \u003d i * BlockSize + blockTypes[i][0][BlockSize - 1];\n\t\tfor(Index t \u003d 1; t * 2 \u0026lt; blocks; t *\u003d 2) {\n\t\t\tstd::memcpy(b + blocks, b, blocks * sizeof(Index));\n\t\t\tb +\u003d blocks;\n\t\t\tfor(Index i \u003d 0; i \u0026lt; blocks - t; ++ i)\n\t\t\t\tb[i] \u003d assumeleft_minIndex(a, b[i], b[i + t]);\n\t\t}\n\t}\n\n\tvoid buildInnerBlockTable(const Val *a, Index n) {\n\t\tfor(Index i \u003d 0; i \u0026lt; blocks; i ++) {\n\t\t\tBlockTypeRef table \u003d blockTypes[i];\n\t\t\tif(table[0][0] !\u003d -1) continue;\n\t\t\tconst Val *p \u003d getBlock(a, n, i);\n\t\t\tfor(InBlockIndex left \u003d 0; left \u0026lt; BlockSize; left ++) {\n\t\t\t\tVal minV \u003d p[left];\n\t\t\t\tInBlockIndex minI \u003d left;\n\t\t\t\tfor(InBlockIndex right \u003d left; right \u0026lt; BlockSize; right ++) {\n\t\t\t\t\tif(comp(p[right], minV)) {\n\t\t\t\t\t\tminV \u003d p[right];\n\t\t\t\t\t\tminI \u003d right;\n\t\t\t\t\t}\n\t\t\t\t\ttable[left][right] \u003d minI;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//端っこのブロック用に関数内staticなテンポラリ配列を返す\n\tconst Val *getBlock(const Val *a, Index n, Index i) {\n\t\tIndex offset \u003d i * BlockSize;\n\t\tif(offset + BlockSize \u0026lt;\u003d n)\n\t\t\treturn a + offset;\n\t\telse {\n\t\t\tstatic Val tmp_a[BlockSize];\n\t\t\tstd::copy(a + offset, a + n, tmp_a);\n\t\t\tVal maxVal \u003d Val();\n\t\t\tfor(Index j \u003d i; j \u0026lt; n; j ++)\t//iでなくoffsetでは？(動作には問題ないし計算量もほとんど変わらないけれど…)(バグるのが嫌なので(今まで動いていたので)直すのは後にする)\n\t\t\t\tif(comp(maxVal, a[j])) maxVal \u003d a[j];\n\t\t\tstd::fill(tmp_a + (n - offset), tmp_a + BlockSize, maxVal);\n\t\t\treturn tmp_a;\n\t\t}\n\t}\n\n\tvoid calcBlockTypes(const Val *a, Index n) {\n\t\tVal tmp_rp[BlockSize + 1];\n\t\tfor(Index i \u003d 0; i \u0026lt; blocks; i ++)\n\t\t\tblockTypes[i] \u003d calcBlockType(getBlock(a, n, i), tmp_rp);\n\t}\n\n\tBlockTypeRef calcBlockType(const Val *a, Val *rp) {\n\t\tint q \u003d BlockSize, N \u003d 0;\n\t\tfor(int i \u003d 0; i \u0026lt; BlockSize; i ++) {\n\t\t\twhile(q + i - BlockSize \u0026gt; 0 \u0026amp;\u0026amp; comp(a[i], rp[q + i - BlockSize])) {\n\t\t\t\tN +\u003d ballotNumbers[BlockSize - i - 1][q];\n\t\t\t\tq --;\n\t\t\t}\n\t\t\trp[q + i + 1 - BlockSize] \u003d a[i];\n\t\t}\n\t\treturn innerBlockTable[N];\n\t}\n\n\tvoid calcBallotNumbers() {\n\t\tfor(int p \u003d 0; p \u0026lt;\u003d BlockSize; p ++) {\n\t\t\tfor(int q \u003d 0; q \u0026lt;\u003d BlockSize; q ++) {\n\t\t\t\tif(p \u003d\u003d 0 \u0026amp;\u0026amp; q \u003d\u003d 0)\n\t\t\t\t\tballotNumbers[p][q] \u003d 1;\n\t\t\t\telse if(p \u0026lt;\u003d q)\n\t\t\t\t\tballotNumbers[p][q] \u003d\n\t\t\t\t\t(q ? ballotNumbers[p][q - 1] : 0) +\n\t\t\t\t\t(p ? ballotNumbers[p - 1][q] : 0);\n\t\t\t\telse\n\t\t\t\t\tballotNumbers[p][q] \u003d 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid buildInnerBlockTable() {\n\t\tint numberOfTrees \u003d ballotNumbers[BlockSize][BlockSize];\n\t\tinnerBlockTable \u003d new InBlockIndex[numberOfTrees][BlockSize][BlockSize];\n\t\tfor(int i \u003d 0; i \u0026lt; numberOfTrees; i ++)\n\t\t\tinnerBlockTable[i][0][0] \u003d -1;\n\t}\n};\nint n, q, a[maxn];\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0);\n    cin \u0026gt;\u0026gt; n;\n    for(int i \u003d 0; i \u0026lt; n; i++)\n\tcin \u0026gt;\u0026gt; a[i];\n    DirectRMQ\u0026lt;int\u0026gt; rmq;\n    rmq.build(a, n);\n    cin \u0026gt;\u0026gt; q;\n    for(int i \u003d 0, l, r; i \u0026lt; q; i++){\n\tcin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r;\n\tcout \u0026lt;\u0026lt; rmq.queryVal(a, l, r) \u0026lt;\u0026lt; \u0027 \u0027;\n    }\n    cout \u0026lt;\u0026lt; \u0027\\n\u0027;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003egenerator\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e// God \u0026amp; me\n// \u0026quot;Someone like you\u0026quot;?! Unbelievable ...\n#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\n\nconst int n \u003d 1 \u0026lt;\u0026lt; 22;\nint a[n];\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0);\n    srand(time(0));\n    cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0027\\n\u0027;\n    iota(a, a + n, 0);\n    random_shuffle(a, a + n); // used for generating random test\n    for(int i \u003d 0; i \u0026lt; n; i++)\n\tcout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026quot; \\n\u0026quot;[ i \u003d\u003d n - 1 ];\n    cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0027\\n\u0027;\n    for(int i \u003d 0; i \u0026lt; n; i++){\n\tint l \u003d rand() % n, r \u003d rand() % n;\n\tif(l \u0026gt; r)  swap(l, r);\n\tcout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0027\\n\u0027;\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eHere is the result:\u003c/p\u003e \u003ctable width\u003d\"100%\"\u003e \u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eMethod\\Time(milliseconds)\u003c/td\u003e\u003ctd\u003eStrictly increasing array\u003c/td\u003e\u003ctd\u003eStrictly decreasing array\u003c/td\u003e\u003ctd\u003eRandom\u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd\u003e This method (known as Arpa\u0027s trick) \u003c/td\u003e\u003ctd\u003e2943\u003c/td\u003e\u003ctd\u003e2890\u003c/td\u003e\u003ctd\u003e2946\u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd\u003e Sparse table \u003c/td\u003e\u003ctd\u003e3612\u003c/td\u003e\u003ctd\u003e3595\u003c/td\u003e\u003ctd\u003e3807\u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd\u003e Vector + Binary search \u003c/td\u003e\u003ctd\u003e3101\u003c/td\u003e\u003ctd\u003e6130\u003c/td\u003e\u003ctd\u003e3153\u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd\u003e O(n) method \u003c/td\u003e\u003ctd\u003e3788\u003c/td\u003e\u003ctd\u003e3920\u003c/td\u003e\u003ctd\u003e3610\u003c/td\u003e\u003c/tr\u003e \u003c/tbody\u003e\u003c/table\u003e\u003c/div\u003e","tags":[]}}