{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1507465487,"rating":0,"authorHandle":"Slamur","modificationTimeSeconds":1507465487,"id":55062,"title":"\u003cp\u003eБазовые структуры данных. Словарь и множество\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eДанный пост является завершающим среди постов, описывающих теоретические основы структур.\u003c/p\u003e\u003cp\u003eВ нем я расскажу о двух очень удобных структурах: \u003cstrong\u003eсловарь\u003c/strong\u003e и \u003cstrong\u003eмножество\u003c/strong\u003e. \u003cbr /\u003e\u003c/p\u003e\u003ch3\u003e3) Словарь (ассоциативный массив) [map / dictionary].\u003c/h3\u003e\u003cp\u003eСловарь позволяет объектам какого-либо заданного типа — ключам [key] — поставить в соответствие (map) значение [value]. \u003c/p\u003e\u003cp\u003eМассив в данной ситуации является частным случаем словаря, где в роли ключей выступают числа от 0 до N.\u003c/p\u003e\u003cp\u003eОперации, определенные для словаря:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eЗадать значение для ключа [put / insert];\u003c/li\u003e   \u003cli\u003eПолучить значение для заданного ключа [get].\u003c/li\u003e   \u003cli\u003eУдалить ключ и заданное ему значение [remove / erase].\u003c/li\u003e   \u003cli\u003eПеребрать все пары \u0026lt;ключ, значение\u0026gt;, лежащие в словаре [iterate].\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eВозможность делать все три операции быстро и является визитной карточкой словаря.\u003c/p\u003e\u003cp\u003eОбращу внимание, что все операции выполняются относительно ключей. На значения словаря не накладывается никаких ограничений, но и не реализуются никакие быстрые операции для них.\u003c/p\u003e\u003cp\u003eСуществуют две основные реализации словаря: на основе хеш-таблицы [hash] и на основе сбалансированного дерева поиска.\u003c/p\u003e\u003ch4\u003eХеш-таблицы [hashmap / hashtable].\u003c/h4\u003e\u003cp\u003eХеш [hash] — это функция, определенная для объектов определенного типа S, которая возвращает значение типа T.\u003c/p\u003e\u003cp\u003eЕдинственным обязательным свойством хеш-функции является то, что у одинаковых объектов хеш должен быть одинаковым.\u003c/p\u003e\u003cp\u003eОбратное может невыполняться. Ситуация, когда хеш двух различных объектов совпадает, называется коллизией [collision].\u003c/p\u003e\u003cp\u003eОбычно хеш выдает целое число от 0 до какого-либо заданного числа M (хотя как я отмечал выше, тип результата может быть любым).\u003c/p\u003e\u003cp\u003eХеш-таблица работает следующим образом:\u003c/p\u003e \u003col\u003e   \u003cli\u003eВычисляется хеш от ключа h \u003d hash(key).\u003c/li\u003e   \u003cli\u003eВыбирается корзина [bucket] с индексом h.\u003c/li\u003e   \u003cli\u003eВ корзине ищется пара для заданного ключа (сравнение уже производится не по хешу, а по самому значению ключа).\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eЗаметим, что отсюда истекает главная проблема хеш-таблицы — выбор значения числа M:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eЕсли M слишком маленькое, то случается очень много коллизий и поиск в корзине может быть очень долгим.\u003c/li\u003e   \u003cli\u003eЕсли M слишком большое, то хеш-таблица начинает занимать слишком много памяти.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eПравильный выбор хеш-функци и способа ее вычисления позволяет достичь амортизированной оценки O(1) для операций (вы встречались с понятием амортизированной оценки в разделе про ArrayList).\u003c/p\u003e\u003cp\u003eПлюсы:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eАмортизированная оценка O(1) для вставки/удаления/получения значения по ключу.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eМинусы:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eИтерация по всем парам \u0026lt;ключ, значение\u0026gt; занимает O(M + N), также порядок перебора пар не обязательно совпадает с порядком вставок;\u003c/li\u003e   \u003cli\u003eОценка O(1) является амортизированной, при плохом выборе хеш-функции и алгоритма решения коллизий операция может выполняться и за O(N).\u003c/li\u003e \u003c/ul\u003e\u003ch4\u003eСловари на основе сбалансированных двоичных деревьев поиска (sorted / tree map).\u003c/h4\u003e\u003cp\u003eK-ичным деревом называется структура, состоящая из узлов. У каждого узла есть k сыновей (могут быть не определены), а также ровно один родитель [parent].\u003c/p\u003e\u003cp\u003eВершина с неопределенным родителем называется \u003ci\u003eкорнем\u003c/i\u003e [root] и находится сверху дерева.\u003c/p\u003e\u003cp\u003eСамым часто используемым значением K является 2 — такие деревья называются двоичными, а сыновья в них называются соответственно \u0026quot;левый\u0026quot; и \u0026quot;правый\u0026quot;.\u003c/p\u003e\u003cp\u003eДвоичным деревом поиска называется двоичное дерево, у которого в каждом узле лежит значение, причем задано два условия:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eЛюбое значение в поддереве левого сына узла меньше, чем значение в самом узле.\u003c/li\u003e   \u003cli\u003eЛюбое значение в поддереве правого сына узла больше, чем значение в самом узле.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eВидно, что в таком дереве возможно хранить только типы, для которых определены операции \u0026quot;меньше/больше\u0026quot;.\u003c/p\u003e\u003cp\u003eПоиск значения в таком дереве производится последовательным сравнением со значениями в корнях поддеревьев: \u003c/p\u003e \u003cul\u003e   \u003cli\u003eЕсли значение совпадает со значением в корне — узел найден;\u003c/li\u003e   \u003cli\u003eЕсли значение в корне больше — то перейти в корень левого поддерева;\u003c/li\u003e   \u003cli\u003eЕсли значение в корне меньше — то перейти в корень правого поддерева.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eЗаметим, что в худшем случае операции будут занимать O(h), где h — высота дерева — максимальное расстояние от корня до какой-либо вершины дерева.\u003c/p\u003e\u003cp\u003eМожно показать, что минимальная высота двоичного дерева из N элементов — O(logN). Деревья, которые поддерживают такую высоту вне зависимости от вставляемых/удаляемых значений, называются \u003ci\u003eсбалансированными\u003c/i\u003e.\u003c/p\u003e\u003cp\u003eЗа счет сортированности ключей в такой структуре возможно за O(logN) выполнять также следующие операции:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eПолучить минимальный/максимальный ключ;\u003c/li\u003e   \u003cli\u003eПолучить для заданного ключа ближайший с меньшей / с большей стороны, лежащий в структуре.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eПлюсы:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eДополнительные операции, выполняемые за O(logN);\u003c/li\u003e   \u003cli\u003eИтерация по элементам производится в порядке возрастания элементов.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eМинусы:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eСложность операций O(logN), что хуже амортизированной оценки O(1) для хеш-таблиц (может быть критично).\u003c/li\u003e \u003c/ul\u003e\u003ch3\u003e4) Множество [set].\u003c/h3\u003e\u003cp\u003eПусть вас не смущает английское название данной структуры, совпадающее с названием операции \u0026quot;установить значение\u0026quot;.\u003c/p\u003e\u003cp\u003eМножество — это набор однотипных элементов, где каждый элемент представлен только в одном экземпляре.\u003c/p\u003e\u003cp\u003eОперации, определенные для множества:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eДобавить элемент [add];\u003c/li\u003e   \u003cli\u003eУдалить элемент [remove / erase (редко используемое название)];\u003c/li\u003e   \u003cli\u003eПроверить наличие заданного элемента в множестве [contains];\u003c/li\u003e   \u003cli\u003eПеребрать все элементы множества [iterate].\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eОбращу внимание, что для множества не определено понятие \u0026quot;индекса элемента\u0026quot;, как для массива или списка.\u003c/p\u003e\u003cp\u003eСамый простой способ реализовать множество — реализовать его на основе словаря, где значения множества являются ключами, а значение — фиктивный объект.\u003c/p\u003e\u003cp\u003eДавайте проведем аналогию операций:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eДобавить элемент -\u0026gt; добавить пару \u0026lt;элемент, фиктивное значение\u0026gt; в словарь;\u003c/li\u003e   \u003cli\u003eУдалить элемент -\u0026gt; удалить значение для элемента из словаря;\u003c/li\u003e   \u003cli\u003eПроверить наличие элемента -\u0026gt; проверить, что для данного элемента есть значение в словаре;\u003c/li\u003e   \u003cli\u003eПеребрать элементы -\u0026gt; перебрать пары \u0026lt;ключ, значение\u0026gt; в словаре, но обрабатывать только ключ.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eМножества обычно называются аналогично внутреннему словарю (hashset / treeset), а также имеют аналогичные плюсы и минусы соответствующих операций.\u003c/p\u003e\u003c/div\u003e","tags":["самара","структуры данных","ассоциативный массив","словарь","множество"]}}