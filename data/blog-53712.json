{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1502015813,"rating":0,"authorHandle":"Light","modificationTimeSeconds":1502196521,"id":53712,"title":"\u003cp\u003eWeek 3 Discussion\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello everyone, I hope you\u0027re training well.\u003c/p\u003e\u003cp\u003e(Before you read the solutions please try to solve the problems yourself in the Week 3 Contest I added)\u003c/p\u003e\u003cp\u003eFor yesterday\u0027s training, first problem we discussed was \u0026quot;Lesha and array splitting\u0026quot;. Which wanted us to split the array into multiple sub-arrays (possibly one) such that no sub-array has the sum of elements equal to zero.\u003c/p\u003e\u003cp\u003eWe discussed the solution and here\u0027s the code that we wrote:\u003c/p\u003e\u003cp\u003eComplexity of the solution: O(n)\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\nconst int N \u003d 100000 + 10;\nconst int M \u003d 1000000007;\nconst double PI \u003d atan(1) * 4;\nconst int oo \u003d 1000000000;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef vector\u0026lt;vi\u0026gt; vvi;\ntypedef pair\u0026lt;int, int\u0026gt; ii;\n#define pb push_back \n#define all(c) (c).begin(),(c).end()\n\nint n, v[101];\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t#endif\n\tcin\u0026gt;\u0026gt;n;\n\tbool f\u003dfalse;\n\tint sum\u003d0;\n\tfor(int i\u003d0; i\u0026lt;n; ++i){\n\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;v[i]);\n\t\tif(v[i])\n\t\t\tf\u003dtrue;\n\t\tsum+\u003dv[i];\n\t}\n\tif(f\u003d\u003dfalse){\n\t\tcout\u0026lt;\u0026lt;\u0026quot;NO\\n\u0026quot;;\n\t\treturn 0;\n\t}\n\tcout\u0026lt;\u0026lt;\u0026quot;YES\\n\u0026quot;;\n\tif(sum!\u003d0){\n\t\tcout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl;\n\t\tcout\u0026lt;\u0026lt;\u0026quot;1 \u0026quot;\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl;\n\t\treturn 0;\n\t}\n\tcout\u0026lt;\u0026lt;\u0026quot;2\\n\u0026quot;;\n\tsum\u003d0;\n\tfor(int i\u003d0; i\u0026lt;n; ++i){\n\t\tsum+\u003dv[i];\n\t\tif(sum!\u003d0){\n\t\t\tprintf(\u0026quot;1 %d\\n\u0026quot;, i+1);\n\t\t\tprintf(\u0026quot;%d %d\\n\u0026quot;, i+2, n);\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eAnd then we talked about Pairs, which are a simple data structure in C++ (written as pair\u0026lt;dataType1, dataType2\u0026gt; name;) that \u0026quot;pairs\u0026quot; two elements together in case we need such things. We can access the first element of the pair by the property of the pair — \u0026quot;first\u0026quot;, and the second element by using — \u0026quot;second\u0026quot;. And we can make a pair by using the make_pair(first, second) function.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epair\u0026lt;double, string\u0026gt; p;\np.first\u003d3.89;\np.second\u003d\u0026quot;second here\u0026quot;;\n//OR:\np\u003dmake_pair(3.89, \u0026quot;second here\u0026quot;);\ncout\u0026lt;\u0026lt;p.first\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;p.second\u0026lt;\u0026lt;endl;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can read more and check an example on the pairs here: \u003ca href\u003d\"http://www.cplusplus.com/reference/utility/pair/pair/\"\u003ehttp://www.cplusplus.com/reference/utility/pair/pair/\u003c/a\u003e\u003c/p\u003e\u003cp\u003eNext problem we talked about was \u0026quot;Distances to Zero\u0026quot;, which gave us an array that contains numbers and zeroes, and wanted us to find for each number the distance between it and the closest zero to it. For this problem we found multiple solutions. First one we discussed was using the technique \u0026quot;Two Pointers\u0026quot;, in which we\u0027ve made a vector containing the indices of the zeros in the array, and then -starting with the first zero- we tried to connect each number with the zero we\u0027re standing on, while only moving to the next zero if the distance between the current number and the next zero is less than the distance between the current number and the current zero. This solution works because we will never have to go back to previous zeros since we\u0027re only moving to the right, so going back will obviously give us more distance.\u003c/p\u003e\u003cp\u003eComplexity of the solution: O(n+m) (we could say its at most 2n which is O(n))\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\nconst int N \u003d 100000 + 10;\nconst int M \u003d 1000000007;\nconst double PI \u003d atan(1) * 4;\nconst int oo \u003d 1000000000;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef vector\u0026lt;vi\u0026gt; vvi;\ntypedef pair\u0026lt;int, int\u0026gt; ii;\n#define pb push_back \n#define all(c) (c).begin(),(c).end()\nint n,v[200000], ans[200000];\nvector\u0026lt;int\u0026gt; zero;\nint main(){\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t#endif\n\tcin\u0026gt;\u0026gt;n;\n\tfor(int i\u003d0; i\u0026lt;n; ++i){\n\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;v[i]);\n\t\tif(v[i]\u003d\u003d0)\n\t\t\tzero.push_back(i);\n\t}\n\n\tfor(int i\u003d0,j\u003d0; i\u0026lt;n; ++i){\n\t\tif(j\u0026lt;zero.size()-1 \u0026amp;\u0026amp; abs(i-zero[j+1])\u0026lt;abs(i-zero[j]))\n\t\t\t++j;\n\t\tans[i]\u003dabs(i-zero[j]);\n\t}\n\n\tfor(int i\u003d0; i\u0026lt;n; ++i)\n\t\tprintf(\u0026quot;%d \u0026quot;, ans[i]);\n\t\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eThe second solution we discussed was finding the closest zero to the left of each number (in a single loop), and finding the closest zero to the right of each number (in another loop), and then for each number we take the minimum distance between the number and first zero to the right or the first zero to the left, which would be our answer.\u003c/p\u003e\u003cp\u003eComplexity of the solution: O(n)\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\nconst int N \u003d 100000 + 10;\nconst int M \u003d 1000000007;\nconst double PI \u003d atan(1) * 4;\nconst int oo \u003d 1000000000;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef vector\u0026lt;vi\u0026gt; vvi;\ntypedef pair\u0026lt;int, int\u0026gt; ii;\n#define pb push_back \n#define all(c) (c).begin(),(c).end()\nint n, v[2*N], L[2*N], R[2*N];\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t#endif\n\tcin\u0026gt;\u0026gt;n;\n\tfor(int i\u003d0; i\u0026lt;n; ++i)\n\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;v[i]);\n\tint last \u003d -1e9;\n\tfor(int i\u003d0; i\u0026lt;n; ++i){\n\t\tif(!v[i]) //means if(v[i]\u003d\u003d0)\n\t\t\tlast\u003di;\n\t\tL[i]\u003dlast;\n\t}\n\tlast \u003d 1e9;\n\tfor(int i\u003dn-1; i\u0026gt;\u003d0; --i){\n\t\tif(!v[i])\n\t\t\tlast\u003di;\n\t\tR[i]\u003dlast;\n\t}\n\tfor(int i\u003d0; i\u0026lt;n; ++i){\n\t\tint ans\u003dmin(i-L[i], R[i]-i);\n\t\tprintf(\u0026quot;%d \u0026quot;, ans);\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eThen we discussed a problem that I gave you: Given an integer N and an array of integers of size N (1 \u0026lt;\u003d N \u0026lt;\u003d 1e5) (1 \u0026lt;\u003d v[i] \u0026lt;\u003d 1e9), and an integer Q (1 \u0026lt;\u003d Q \u0026lt;\u003d 1e5), you will be asked Q number of queries (questions) as follows: Given an integer X, find what\u0027s the smallest number found in the array thats greater than or equal to X.\u003c/p\u003e\u003cp\u003eSample input: 5 8 2 7 15 3 3 2 5 9 Sample output: 2 7 15\u003c/p\u003e\u003cp\u003eAnd we\u0027ve found that if we first sort our array, we can answer these type of queries efficiently using Binary Search in O(logn) each.\u003c/p\u003e\u003cp\u003eWhich gives us the complexity: O(nlogn) for sorting the array and O(Qlogn) for answering each query which is about O(nlogn) in total.\u003c/p\u003e\u003cp\u003eI\u0027ll leave writing the code for this problem as an exercise for you.\u003c/p\u003e\u003cp\u003eYou can solve a problem that is similar to that one here: (Highly recommended to try it for yourself) \u003ca href\u003d\"http://www.spoj.com/problems/BSEARCH1/\"\u003ehttp://www.spoj.com/problems/BSEARCH1/\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAnd the last problem we discussed was PIE (\u003ca\u003ehttp://www.spoj.com/problems/PIE/)\u003c/a\u003e, in which after discussing the possible solutions, we found that we can do a Binary Search to find the biggest volume that we can get enough pieces of it from the pies to give to all the friends.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\nconst int N \u003d 100000 + 10;\nconst int M \u003d 1000000007;\nconst double PI \u003d atan(1) * 4;\nconst int oo \u003d 1000000000;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef vector\u0026lt;vi\u0026gt; vvi;\ntypedef pair\u0026lt;int, int\u0026gt; ii;\n#define pb push_back \n#define all(c) (c).begin(),(c).end()\nint n,p;\nvector\u0026lt;double\u0026gt; v;\n \nbool can(double size){\n\tint count\u003d0;\t//an integer to count the number of pieces we can get of size \u0026quot;size\u0026quot;\n\tfor(int i\u003d0; i\u0026lt;v.size(); ++i)\n\t\tcount+\u003dv[i]/size;\t//From each Pie, we can get (VolumeOfPie/Size) number of pieces\n\n\tif(count\u0026gt;\u003dn)\t\t//If total number of pieces is \u0026gt;\u003d number of people then this size works\n\t\treturn true;\n\telse\t\t\t\t//Otherwise, it\u0027s too big\n\t\treturn false;\n}\nint main(){\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t#endif\n\tint T;\n\tcin\u0026gt;\u0026gt;T;\n\tfor(int t\u003d0; t\u0026lt;T; ++t){\n\t\tcin\u0026gt;\u0026gt;p\u0026gt;\u0026gt;n;\n\t\t++n;\n\t\tv.clear();\n\t\tfor(int r,i\u003d0; i\u0026lt;p; ++i){\n\t\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;r);\n\t\t\tv.push_back(PI*r*r);  //Formula to get the volume of a cylinder (height \u003d 1)\n\t\t}\t\t\t      //PI is already defined in my code:\n\t\t\t\t\t      //double PI \u003d acos(-1);\n\n\t\tdouble lo\u003d0, hi\u003d1e9, md, bst\u003d0;\n\t\twhile(hi-lo \u0026gt; 1e-5){\t  //While the difference between high and low is bigger\n\t\t\tmd\u003d(lo+hi)/2;     //than 1/100000 (we only need 3 correct digits)\n\t\t\tif(can(md)){\n\t\t\t\tbst\u003dmd;\n\t\t\t\tlo\u003dmd;\n\t\t\t}else\n\t\t\t\thi\u003dmd;\n\t\t}\n\t\tprintf(\u0026quot;%.4lf\\n\u0026quot;, bst);  //the \u0026quot;.4\u0026quot; between the % and lf specifies the number\n\t}\t\t\t\t //of digits we want to print after the .\n\t\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eThat\u0027s everything we discussed yesterday! Please try to solve all the problems, and if you have any questions message me for I would be happy to help :D\u003c/p\u003e\u003c/div\u003e","tags":[]}}