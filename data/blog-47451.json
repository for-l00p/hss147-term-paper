{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1475269806,"rating":3,"authorHandle":"BigBag","modificationTimeSeconds":1475569768,"id":47451,"title":"\u003cp\u003eОбзор bfs и dfs\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003e1)\u003c/strong\u003e \u003cstrong\u003eBFS\u003c/strong\u003e (breadth-first search)\u003c/p\u003e\u003cp\u003eТ.к. стандартный bfs (на графе, где все ребра имеют одинаковую длину) все знают, то сразу перейдем к его модифицированной версии. \u003c/p\u003e\u003cp\u003eBFS на графе, которые может иметь как ребра длины 1, так и длины 0. Чтобы стандартный bfs работал на таком графе, модернизируем его следующим образом : если в данный момент мы обновляем расстояние до какой-то вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e ребром длины 0, то эту вершину стоит добавить не в конец очереди, а в начало очереди.\u003c/p\u003e\u003cp\u003eСтруктура, позволяющая это делать — \u003ccode\u003edeque\u003c/code\u003e. Например \u003ccode\u003edeque\u0026lt;int\u0026gt; q;\u003c/code\u003e Над этой структурой можно применять следующие операции :\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003ccode\u003eq.push_back(x);\u003c/code\u003e \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e добавить в конец дека число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003e\u003ccode\u003eq.push_front(x);\u003c/code\u003e \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e добавить в начало дека число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003e\u003ccode\u003eq.pop_back();\u003c/code\u003e \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e удалить последний элемент дека.\u003c/li\u003e   \u003cli\u003e\u003ccode\u003eq.pop_front();\u003c/code\u003e \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e удалить первый элемент дека.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003e\u003cstrong\u003e2)\u003c/strong\u003e \u003cstrong\u003eИспользование \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edx\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edy\u003c/i\u003e\u003c/span\u003e\u003c/strong\u003e в задачах на клетчатое поле.\u003c/p\u003e\u003cp\u003eДовольно часто встречаются задачи, в которых граф \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e это клетчатое поле, а ребра существуют между соседними по стороне клетками. В этом случае, для написания dfs/bfs, очень удобно использовать вспомогательные массивы \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edx\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edy\u003c/i\u003e\u003c/span\u003e. Приведу пример своей реализации dfs :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003econst int dx[] \u003d {1, -1, 0, 0};\nconst int dy[] \u003d {0, 0, 1, -1};\n\nbool is_in(int x, int y) {\n    return x \u0026gt;\u003d 0 \u0026amp;\u0026amp; y \u0026gt;\u003d 0 \u0026amp;\u0026amp; x \u0026lt; n \u0026amp;\u0026amp; y \u0026lt; m;\n}\n\nvoid dfs(int x, int y) {\n    used[x][y] \u003d 1;\n    for (int i \u003d 0; i \u0026lt; 4; ++i) {\n        int a \u003d x + dx[i], b \u003d y + dy[i];\n        if (is_in(a, b) \u0026amp;\u0026amp; used[a][b] \u003d\u003d 0) {\n            dfs(a, b);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТакже бывают случаи, когда ребра соединяют клетки, если из одной можно попасть в другую ходом коня/короля. В этом случае, достаточно просто поменять эти константные массивы :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003econst int dx[] \u003d {2, 2, -2, -2, 1, 1, -1, -1};\nconst int dy[] \u003d {1, -1, 1, -1, 2, -2, 2, -2};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e3)\u003c/strong\u003e \u003ca href\u003d\"http://e-maxx.ru/algo/finding_cycle\"\u003eНахождение цикла в графе\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e4)\u003c/strong\u003e \u003ca href\u003d\"http://e-maxx.ru/algo/topological_sort\"\u003eТопологическая сортировка\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e5)\u003c/strong\u003e \u003ca href\u003d\"http://e-maxx.ru/algo/strong_connected_components\"\u003eВыделение компонент сильной связности\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e6)\u003c/strong\u003e \u003cstrong\u003eОбходы деревьев\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e6.1\u003c/strong\u003e. Обход \u003cstrong\u003edfs\u003c/strong\u003e. При обходе мы запоминаем 4 следующие величины : \u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ccode\u003etin[v]\u003c/code\u003e \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e время входа в вершину \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e (то есть когда dfs заходит в вершину \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, мы делаем \u003ccode\u003etin[v] \u003d ++cnt;\u003c/code\u003e).\u003c/li\u003e   \u003cli\u003e\u003ccode\u003etout[v]\u003c/code\u003e \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e время выхода из вершину \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e (то есть при выходе из вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, мы делаем \u003ccode\u003etout[v] \u003d ++cnt;\u003c/code\u003e).\u003c/li\u003e   \u003cli\u003e\u003ccode\u003eorder\u003c/code\u003e \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e порядок обхода дерева (удобнее всего хранить как \u003ccode\u003evector\u0026lt;int\u0026gt; order\u003c/code\u003e).\u003c/li\u003e   \u003cli\u003e\u003ccode\u003enum[v]\u003c/code\u003e \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e номер вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e в списке \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eorder\u003c/i\u003e\u003c/span\u003e (то есть \u003ccode\u003enum[order[i]] \u003d i\u003c/code\u003e).\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eПрименения. \u003ccode\u003etin\u003c/code\u003e и \u003ccode\u003etout\u003c/code\u003e в основном используются для проверки того, что одна вершина является предком другой :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ebool is_ancestor(int v1, int v2) {\n    return tin[v1] \u0026lt;\u003d tin[v2] \u0026amp;\u0026amp; tout[v1] \u0026gt;\u003d tout[v2];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДействительно, если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e1\u003c/span\u003e является предком \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e2\u003c/span\u003e, то должны выполнятся два написанных выше неравенства. Обратите внимание, на нестрогость неравенства. Это нужно для того, чтобы проверка \u003ccode\u003eis_ancestor(v, v)\u003c/code\u003e всегда возвращала \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eОсновное удобство массива \u003ccode\u003eorder\u003c/code\u003e в том, что в этом массиве для любого \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ev\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e), поддерево вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e представляет собой подотрезок этого массива \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003enum\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e; \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(\u003ci\u003enum\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u0027\u003c/sub\u003e)]\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u0027\u003c/span\u003e находится в поддереве \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. Теперь любая задача на запросы в поддеревьях может быть сведена к задаче на запросы на отрезках в массиве, которая в свою очередь может легко решаться какой-нибудь структурой данных.\u003c/p\u003e\u003cp\u003eПример :\u003c/p\u003e\u003cp\u003eДано корневое дерево с \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e вершинами и корнем в вершине 1. В каждой вершине изначально записано какое-то число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Необходимо выполнить \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e запросов. Запросы бывают двух типов :\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ccode\u003e1 v x\u003c/code\u003e \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e необходимо увеличить \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u0027\u003c/sub\u003e\u003c/span\u003e на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, для всех \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u0027\u003c/span\u003e, которые находятся в поддереве вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003e\u003ccode\u003e2 v\u003c/code\u003e \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e необходимо вывести \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/46/c0/46c01a141908a5b750291d70b7e2d3d9471d511b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u0027\u003c/span\u003e находится в поддереве вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eРешение :\u003c/p\u003e\u003cp\u003eЗапишем вершины дерева в порядке обхода dfs. Теперь наша задача свелась к стандартной задаче на структуру данных. То есть нужно уметь увеличивать в числа на заданном отрезке на какое-то число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, и уметь находить сумму всех чисел на отрезке. Это можно делать с помощью стандартного дерева отрезков.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e6.2\u003c/strong\u003e. Обход \u003cstrong\u003ebfs\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eЗдесь нас будет интересовать только порядок обхода \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e \u003ccode\u003eorder\u003c/code\u003e. Главное свойство этого обхода \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e то, что все вершины находящиеся на глубине \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e от вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, тоже представляют собой непрерывный отрезок. То есть, аналогично предыдущему пункту, любая задача на запросы в вершинах на расстоянии \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e от заданной, может быть также сведена к задаче на запросы на отрезках в массиве.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадачи на эти темы\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВ соревнования добавлены 2 тренировки. Решать их лучше не виртуальным контестом, а просто от задачи, к задаче. В первой тренировке нужно решить все задачи, во второй \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e B, C, D. Этот обзор и две тренировки охватывают темы 1.3-1.9.\u003c/p\u003e\u003cp\u003eХитрые задачи :\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ca href\u003d\"//codeforces.com/contest/397/problem/E\"\u003eО меняющемся дереве\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://acmp.ru/index.asp?main\u003dtask\u0026amp;id_task\u003d538\"\u003eРадио\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://acmp.ru/index.asp?main\u003dtask\u0026amp;id_task\u003d509\"\u003eИгра Jammed\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://acmp.ru/index.asp?main\u003dtask\u0026amp;id_task\u003d405\"\u003eТуристическое агенство\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eНадеюсь, вы прочитали первый блог :)\u003c/p\u003e\u003cp\u003eТам я подробно написал о схеме прорешивания. Если есть какие-то вопросы \u003cspan class\u003d\"tex-span\"\u003e  — \u003c/span\u003e спрашивайте, все темы нужно понять так, чтобы не было никаких \u0026quot;белых пятен\u0026quot;.\u003c/p\u003e\u003c/div\u003e","tags":[]}}