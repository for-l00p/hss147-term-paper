{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1508627863,"rating":5,"authorHandle":"amal_taha","modificationTimeSeconds":1508773386,"id":55335,"title":"\u003cp\u003eWeek 9 Discussion \u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi everyone! How was the contest today? For those who attended, thank you, you\u0027ve all done a great job! We were glad to see you participating and working hard to solve the problems. :D\u003c/p\u003e \u003chr /\u003e\u003cp\u003eWe have talked about a new topic related to number theory, it\u0027s about finding all the divisors for a specific number more efficiently.\u003c/p\u003e\u003cp\u003eFor example, number 36 has 9 divisors: 1, 2, 3, 4, 6, 9, 12, 18, 36. If we want to find them all we might go through all the numbers from 1 to 36 and check if the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th number is divisible by 36. This solution takes so long, especially when the input limits are very large. Another solution is to go through all the numbers less than or equal to the square root of 36, this way we can get all the divisors in less time and more efficient way. Observe that we can get the divisors that are bigger than the square root (6) by dividing the number 36 by it\u0027s divisors that are less than the square root (6).\u003c/p\u003e\u003cp\u003e1 -\u0026gt; (36/1 \u003d 36)\u003c/p\u003e\u003cp\u003e2 -\u0026gt; (36/2 \u003d 18)\u003c/p\u003e\u003cp\u003e3 -\u0026gt; (36/3 \u003d 12)\u003c/p\u003e\u003cp\u003e4 -\u0026gt; (36/4 \u003d 9)\u003c/p\u003e\u003cp\u003e6 -\u0026gt; (36/6 \u003d 6), and here we stop.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nvector\u0026lt;int\u0026gt;v ; \n\nint main() {\n //freopen(\u0026quot;input.txt\u0026quot; , \u0026quot;r\u0026quot; , stdin) ;\n    int n ; \n    scanf(\u0026quot;%d\u0026quot; , \u0026amp;n); \n\n    for (int i \u003d1 ; i*i\u0026lt;\u003d n ; ++i) {\n      if(n%i \u003d\u003d 0){\n        v.push_back(i) ; \n          if (n/i !\u003d i)\n          v.push_back(n/i) ; \n      }\n    }\n    sort(v.begin() , v.end()) ; \n    printf(\u0026quot;the divisors for number %d are:\\n\u0026quot; , n) ;\n    for (int i \u003d0 ; i\u0026lt;v.size() ; ++i) {\n      printf(\u0026quot;%d \u0026quot; , v[i]) ; \n    } \n    puts(\u0026quot;\u0026quot;);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eThen, we discussed how we can determine if the number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e is a prime number or not with the same approach. Observe that we start the loop from 2 because 1 is divisible by all numbers.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e.\u003ci\u003eS\u003c/i\u003e.\u003c/span\u003e\u003c/strong\u003e A prime number is a number greater than 1 that has no positive divisors other than 1 and itself. \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint main() {\n //freopen(\u0026quot;input.txt\u0026quot; , \u0026quot;r\u0026quot; , stdin) ;\n    int n ; \n    scanf(\u0026quot;%d\u0026quot; , \u0026amp;n); \n\n    bool isPrime \u003d true ; \n    for (int i \u003d2 ; i*i\u0026lt;\u003d n ; ++i) {\n      if (n%i \u003d\u003d 0){\n        isPrime \u003d false ; \n      }\n    }\n    if (isPrime \u003d\u003d false)puts(\u0026quot;Not a prime\u0026quot;);\n    else puts(\u0026quot;Prime\u0026quot;) ; \n   \n    return 0;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003chr /\u003e\u003cp\u003eNow, let\u0027s talk about the contest problems:\u003c/p\u003e\u003ch4\u003eC. Sam and the Monsters \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eII\u003c/i\u003e\u003c/span\u003e\u003c/h4\u003e\u003cp\u003eIn this problem we have discussed a new method which is called reverse, \u003ccode\u003ereverse(arrName, arrName+arrsize)\u003c/code\u003e, what it functions is reversing the elements within the given range of the array without sorting them, so we use sorting with it if we want the elements sorted reversely. You can go through the elements from the last one to the first one if you don\u0027t want to use it. As you like! :P\u003c/p\u003e\u003cp\u003eThe solution for this problem is simple. We first sort the elements and reverse them, then while \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eJ\u003c/i\u003e\u003c/span\u003e is larger than 0 we jump above the monster without fighting it, otherwise we have to fight it. Don\u0027t forget to add the length of the road.\u003c/p\u003e\u003cp\u003eTry to write the code yourself !\u003c/p\u003e \u003chr /\u003e\u003ch4\u003eE. Perfect Numbers\u003c/h4\u003e\u003cp\u003eIn this problem we used the approach of the square root. We go through the elements from 1 to the square root of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e and if the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th number is divisible by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e we add it to the answer and then add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e / \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to the answer. You can either use the function \u003ccode\u003esqrt(N)\u003c/code\u003e within \u003ccode\u003e#include\u0026lt;cmath\u0026gt;\u003c/code\u003e or better for you square both sides as shown below. \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint main(){\n   // freopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n    int n ; \n    scanf(\u0026quot;%d\u0026quot; , \u0026amp;n) ; \n    int sum \u003d 0 ; \n    for (int i \u003d 1 ; i*i\u0026lt;\u003d n ; ++i ){\n     if (n%i \u003d\u003d 0){\n      sum+\u003di ; \n         if (n/i !\u003d i) // observe that if the the number is a perfect square \n           sum+\u003dn/i;     // you don\u0027t want to add it\u0027s root 2 times . \n     }\n    }\n    sum-\u003dn; \n    if (n \u003d\u003d 1)cout\u0026lt;\u0026lt;\u0026quot;NO\u0026quot;\u0026lt;\u0026lt;endl;\n    else if (sum \u003d\u003d n)cout\u0026lt;\u0026lt;\u0026quot;YES\u0026quot;\u0026lt;\u0026lt;endl;\n    else cout\u0026lt;\u0026lt;\u0026quot;NO\u0026quot;\u0026lt;\u0026lt;endl;\n  }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003chr /\u003e\u003ch4\u003eH. WiFi Password\u003c/h4\u003e\u003cp\u003eIn this problem all you have to do is to observe the pattern of the numbers and the relationship between them. We found that the numbers form a Fibonacci sequence. As you can see, the numbers in the series exceed \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e\u003c/span\u003e starting from a certain number so that you\u0027re not able to store them in any data type anymore, though we need only the last 4 digits, so we use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eMOD\u003c/i\u003e\u003c/span\u003e that equals \u003cspan class\u003d\"tex-span\"\u003e10000\u003c/span\u003e to obtain the last 4 digits. Please try to write the code yourself and solve it recursively.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int N \u003d 100000 + 10;\nint n, fib[N];\nstring ans \u003d \u0026quot;0000\u0026quot;;\nint main(){\n\n  //freopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n  scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n  fib[0] \u003d 1;\n  fib[1] \u003d 2;\n  for (int i \u003d 2; i \u0026lt;\u003d n; i++)\n  {\n    fib[i] \u003d (fib[i - 1] + fib[i - 2]) % 10000;\n  }\n  for (int i \u003d 3; i \u0026gt;\u003d 0; i--)\n  {\n    ans[i] \u003d fib[n] % 10 + \u00270\u0027;\n    fib[n] /\u003d 10;\n  }\n  cout\u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\nreturn 0 ; \n}\n  \n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003chr /\u003e\u003cp\u003eThank you guys!:D This was all for today, if you have any question about the explained topics or even any other topic do not hesitate to write it in the comments or write a blog as the teacher said.\u003c/p\u003e\u003c/div\u003e","tags":[]}}