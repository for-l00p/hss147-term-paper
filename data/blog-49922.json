{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1484992553,"rating":0,"authorHandle":"msfq084","modificationTimeSeconds":1484992553,"id":49922,"title":"\u003cp\u003eGetting TLE in 1080 â€” Binary Simulation\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHow can i make this approach more efficient to get AC. Can anyone help?\u003c/p\u003e\u003cp\u003eProblem link: \u003ca href\u003d\"http://lightoj.com/volume_showproblem.php?problem\u003d1080\"\u003e1080-Binary Simulation\u003c/a\u003e\u003cbr /\u003e Code ideone link: \u003ca href\u003d\"http://ideone.com/gPBp15\"\u003ecode\u003c/a\u003e\u003cbr /\u003e\u003cbr /\u003e Suggestion is appreciated. :)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n#include \u0026lt;stdbool.h\u0026gt;\n#include \u0026lt;math.h\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;set\u0026gt;\n#define pb push_back\n#define ll long long int\n#define ull unsigned long long int\n#define gcd(a,b)    __gcd(a,b)\n#define sz sizeof\n#define INF 1000000000000000000LL\n#define ms memset\n#define MAX\n\nusing namespace std;\n\n\nint a[100010],tree[4*100010],lazy[4*100010];\nvoid build(int node,int s,int d){\n    if(s\u003d\u003dd){\n        //cout\u0026lt;\u0026lt;\u0026quot;node: \u0026quot;\u0026lt;\u0026lt;node\u0026lt;\u0026lt;\u0026quot; val: \u0026quot;\u0026lt;\u0026lt;a[s]\u0026lt;\u0026lt;endl;\n        tree[node] \u003d a[s];\n        return;\n    }\n    int Left \u003d node*2;\n    int Right \u003d node*2 + 1;\n    int mid \u003d (s+d)/2;\n    build(Left,s,mid);\n    build(Right,mid+1,d);\n\n    //update tree\n    tree[node] \u003d tree[Left] + tree[Right];\n}\nvoid update(int node,int s,int d,int i,int j){\n    if(lazy[node]!\u003d0){\n        if(lazy[node]%2\u003d\u003d0){\n            // do nothing\n        }else{\n            tree[node] \u003d (d-s+1) - tree[node];\n        }\n\n        if(s!\u003dd){\n            lazy[node*2] +\u003d lazy[node];\n            lazy[node*2+1] +\u003d lazy[node];\n        }\n        lazy[node]\u003d0;\n    }\n\n    //no overlap\n    if(s\u0026gt;j || d\u0026lt;i) return;\n    //total overlap\n    if(s\u0026gt;\u003di \u0026amp;\u0026amp; d\u0026lt;\u003dj){\n        tree[node] \u003d (d-s+1) - tree[node];\n\n        if(s!\u003dd){\n            lazy[node*2]++;\n            lazy[node*2+1]++;\n        }\n        return ;\n    }\n    //partial overlap\n    int Left \u003d node*2;\n    int Right \u003d node*2 + 1;\n    int mid \u003d (s+d)/2;\n    update(Left,s,mid,i,j);\n    update(Right,mid+1,d,i,j);\n\n    //update tree\n    tree[node] \u003d tree[Left] + tree[Right];\n}\nint query(int node,int s,int d,int i,int j){\n    if(lazy[node]!\u003d0){\n        if(lazy[node]%2\u003d\u003d0){\n            // do nothing\n        }else{\n            tree[node] \u003d (d-s+1) - tree[node];\n        }\n\n        if(s!\u003dd){\n            lazy[node*2] +\u003d lazy[node];\n            lazy[node*2+1] +\u003d lazy[node];\n        }\n        lazy[node]\u003d0;\n    }\n\n    //no overlap\n    if(s\u0026gt;j || d\u0026lt;i){\n        return 0;\n    }\n    //total overlap\n    if(s\u0026gt;\u003di \u0026amp;\u0026amp; d\u0026lt;\u003dj){\n        return tree[node];\n    }\n    //partial overlap\n    int Left \u003d node*2;\n    int Right \u003d node*2 + 1;\n    int mid \u003d (s+d)/2;\n    int p1\u003d0,p2\u003d0;\n    p1 \u003d query(Left,s,mid,i,j);\n    p2 \u003d query(Right,mid+1,d,i,j);\n    return p1+p2;\n}\n\nint main()\n{\n    //freopen(\u0026quot;a.in\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n    //freopen(\u0026quot;out.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\n    //std::ios_base::sync_with_stdio(false);\n    int n,t,i,j,cases\u003d1,q,u,v;\n    scanf(\u0026quot;%d\u0026quot;,\u0026amp;t);\n    getchar();\n    while(t--){\n        ms(a,0,sz(a));\n        ms(tree,0,sz(tree));\n        ms(lazy,0,sz(lazy));\n        char s[100010];\n        scanf(\u0026quot;%s\u0026quot;,\u0026amp;s);\n        for(i\u003d0;i\u0026lt;strlen(s);i++){\n            a[i+1] \u003d s[i]-\u00270\u0027;\n        }\n        n \u003d strlen(s);\n        build(1,1,n);\n        printf(\u0026quot;Case %d:\\n\u0026quot;,cases);cases++;\n        scanf(\u0026quot;%d\u0026quot;,\u0026amp;q);\n        getchar();\n        char ch;\n        while(q--){\n            scanf(\u0026quot;%c\u0026quot;,\u0026amp;ch);\n            if(ch\u003d\u003d\u0027I\u0027){\n                scanf(\u0026quot;%d %d\u0026quot;,\u0026amp;u,\u0026amp;v);\n                update(1,1,n,u,v);\n            }else{\n                scanf(\u0026quot;%d\u0026quot;,\u0026amp;u);\n                int bit \u003d query(1,1,n,u,u);\n                printf(\u0026quot;%d\\n\u0026quot;,bit);\n            }\n            getchar();\n        }\n    }\n\n\n\n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["segment tree","#data structure"]}}