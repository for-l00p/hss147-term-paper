{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1485848549,"rating":-26,"authorHandle":"Xquare","modificationTimeSeconds":1485856589,"id":50134,"title":"\u003cp\u003e393 Div.2 总结\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/760/problem/A\" title\u003d\"Codeforces Round 393 (Div. 2) (8VC Venture Cup 2017 - Final Round Div. 2 Edition)\"\u003e760A - Petr and a calendar\u003c/a\u003e \u003ca href\u003d\"/contest/760/submission/24285727\" title\u003d\"Submission 24285727 by Xquare\"\u003e24285727\u003c/a\u003e\u003c/p\u003e\u003cp\u003e水题,基本等价于一个月多少天. 忘记了 \u003cem\u003e\u003cstrong\u003e七月大,八月大\u003c/strong\u003e\u003c/em\u003e,错了一发.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/760/problem/B\" title\u003d\"Codeforces Round 393 (Div. 2) (8VC Venture Cup 2017 - Final Round Div. 2 Edition)\"\u003e760B - Frodo and pillows\u003c/a\u003e \u003ca href\u003d\"/contest/760/submission/24285741\" title\u003d\"Submission 24285741 by Xquare\"\u003e24285741\u003c/a\u003e\u003c/p\u003e\u003cp\u003e比寻常B题稍难,推公式二分. 规避了溢出问题,但是依然错了两发.\u003c/p\u003e\u003cp\u003e错误\u0026amp;更正:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003e公式推错,没考虑到 at least one pillow 条件对公式的影响. \u003d\u0026gt; 公式分段\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e没考虑到只有一个人的情况,上界开小了. \u003d\u0026gt; 二分区间[1,m+1)\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003e\u003ca href\u003d\"/contest/760/problem/C\" title\u003d\"Codeforces Round 393 (Div. 2) (8VC Venture Cup 2017 - Final Round Div. 2 Edition)\"\u003e760C - Pavel and barbecue\u003c/a\u003e \u003ca href\u003d\"/contest/760/submission/24285747\" title\u003d\"Submission 24285747 by Xquare\"\u003e24285747\u003c/a\u003e\u003c/p\u003e\u003cp\u003e需要稍微分析的图论问题. \u003c/p\u003e\u003cp\u003e分析过程:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003e按照抽代的思想,排列可以看做一个有向环,在不考虑正反的情况下,问题等价于多个环连成一个环.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e考虑正反的时候,不难想到. 有效方案 \u0026lt;\u003d\u0026gt; 存在一个节点v, 能通过若干次转移到达 v\u0027(其反面).\u003c/p\u003e\u003cp\u003e即 \u003cstrong\u003ev -\u0026gt;* v\u0027\u003c/strong\u003e .\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003e同时 v -\u0026gt;* v\u0027 \u0026lt;\u003d\u0026gt; 一圈翻转次数为奇数\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/760/problem/D\" title\u003d\"Codeforces Round 393 (Div. 2) (8VC Venture Cup 2017 - Final Round Div. 2 Edition)\"\u003e760D - Travel Card\u003c/a\u003e \u003ca href\u003d\"/contest/760/submission/24285755\" title\u003d\"Submission 24285755 by Xquare\"\u003e24285755\u003c/a\u003e\u003c/p\u003e\u003cp\u003e水得出奇的D题.\u003c/p\u003e\u003cp\u003eD题只是题意难理解(其实是题意没有完全体现在题面中,部分细节在样例2中才体现),在理解后就是个大水题.\u003c/p\u003e\u003cp\u003e题目中 \u003cstrong\u003eoptimal\u003c/strong\u003e 的定义:\u003c/p\u003e \u003cpre\u003e结合之前的付款时间与数量, 分别考虑三种所需补价, 取最小.\u003c/pre\u003e\u003cp\u003e然后我代码中用了一个尺取的优化,维护指针,把整体复杂度降低到了O(n)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    for(int i \u003d 0; i \u0026lt; n; ++i){\n        for(int k \u003d 0; k \u0026lt; 3; ++k)\n            while (prev[k] \u0026lt; i \u0026amp;\u0026amp; t[prev[k]] + width[k] \u0026lt;\u003d t[i])\n                ++prev[k];\n        ...\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ca href\u003d\"/contest/760/problem/E\" title\u003d\"Codeforces Round 393 (Div. 2) (8VC Venture Cup 2017 - Final Round Div. 2 Edition)\"\u003e760E - Nikita and stack\u003c/a\u003e \u003ca href\u003d\"/contest/760/submission/24285764\" title\u003d\"Submission 24285764 by Xquare\"\u003e24285764\u003c/a\u003e\u003c/p\u003e\u003cp\u003e很有新意的数据结构,想了很久,无果.看tutorial才恍然大悟.\u003c/p\u003e\u003cp\u003eQ:为什么需要逆序 or 为什么是后缀和?\u003c/p\u003e\u003cp\u003eA:(按照我的理解)如果存在一个后缀和 sum[i] \u0026gt; 0,那么可以把栈拆分为两个部分.\u003c/p\u003e \u003cpre\u003e|stack1|stack2(top)\n\n|[0,i) |[i...n) |\u003c/pre\u003e\u003cp\u003e其中stack1是可能为空,而stack2为必定非空的栈. 此时,栈顶的元素必定在stack2中,只需要单独考虑stack2.\u003c/p\u003e\u003cp\u003e即求 \u003cstrong\u003emax({i|sum[i] \u0026gt; 0})\u003c/strong\u003e \u003c/p\u003e\u003cp\u003e特殊地 当 \u003cstrong\u003e{i|sum[i] \u0026gt; 0}\u003c/strong\u003e 为空时, 栈为空.\u003c/p\u003e\u003cp\u003eQ:为什么是线段树?\u003c/p\u003e\u003cp\u003eA:经过上面的分析,不难看出是维护动态最大值.\u003c/p\u003e\u003cp\u003e只需要维护一个这样的线段树:\u003c/p\u003e\u003cp\u003eUpdate: 区间加减\u003c/p\u003e\u003cp\u003eQuery: 区间最大值 \u003d\u0026gt; \u003cstrong\u003emax({i|sum[i] \u0026gt; 0})\u003c/strong\u003e \u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/760/problem/F\" title\u003d\"Codeforces Round 393 (Div. 2) (8VC Venture Cup 2017 - Final Round Div. 2 Edition)\"\u003e760F - Bacterial Melee\u003c/a\u003e \u003ca href\u003d\"/contest/760/submission/24285774\" title\u003d\"Submission 24285774 by Xquare\"\u003e24285774\u003c/a\u003e\u003c/p\u003e\u003cp\u003e组合数学+dp. \u003c/p\u003e\u003cp\u003etutorial中分析的很好,我简单概括一下.\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003e对于一个长为n的串,考虑最终状态为l \u003cstrong\u003e节\u003c/strong\u003e , 则其方案数为 C(n-1,l-1).这里用了隔板法的思想.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e给定串S, 长为l的 合法 子序列个数可以用dp求解.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e合法\u003c/strong\u003e : 子序列中任意相邻两位不相同.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eQ:2.中的dp为什么是 O(n^2)的?感觉上O(n)更合理啊.\u003c/p\u003e\u003cp\u003eA:这么考虑,dp数组同时维护着n个状态. \u003c/p\u003e\u003cp\u003e接受一个输入字符时, n个状态都需要转移. \u003c/p\u003e\u003cp\u003e串S输入n次,所以复杂度为O(n^2)\u003c/p\u003e\u003cp\u003eQ:2.中的dp依然很迷茫.\u003c/p\u003e\u003cp\u003eA:类比其他序列型dp,每接受一个字符的输入,遍历一次dp数组并更新.\u003c/p\u003e\u003cp\u003e那么我们考虑单次遍历更新, 此时长度为l,以c结尾的 \u003cstrong\u003e合法\u003c/strong\u003e 子序列 有两类:\u003c/p\u003e\u003cp\u003ea)在本次输入前已经确定的长度为l序列 保持不变,dp[l][c].\u003c/p\u003e\u003cp\u003eb)在本次输入前已经确定的长度为l-1序列 在末尾附加上c, dp[l-1][\u0027a\u0027] + ... + dp[l-1][\u0027z\u0027] — dp[l-1][c] (减去不合法部分)\u003c/p\u003e\u003cp\u003e然而a)b)中有部分重复统计,所以需要 -dp[l][c].\u003c/p\u003e\u003cp\u003e为了优化b)中求和过程,不妨设 sum[l] \u003d 长度为l的子序列个数(无论以什么字符结尾).\u003c/p\u003e\u003cp\u003eQ:以下两个边界条件是否互相冲突 \u003c/p\u003e\u003cp\u003edp[0][i] \u003d 0 , \u0027a\u0027 \u0026lt;\u003d i \u0026lt;\u003d \u0027z\u0027\u003c/p\u003e\u003cp\u003esum[0] \u003d 1\u003c/p\u003e\u003cp\u003eA:不冲突,因为sum[0]中还包含了以 \u0027\\0\u0027 结尾的空串.\u003c/p\u003e\u003cp\u003eQ:Div.1前面几个大牛的解法直接dp是什么思想?\u003c/p\u003e\u003cp\u003eA:我没看懂...如果你看懂了请务必告诉我,非常感谢.\u003c/p\u003e\u003c/div\u003e","tags":[]}}