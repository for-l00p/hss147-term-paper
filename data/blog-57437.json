{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1517321703,"rating":-10,"authorHandle":"usernameson","modificationTimeSeconds":1517321703,"id":57437,"title":"\u003cp\u003eAn interesting randomised approach to a graph problem\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eIntroduction\u003c/h1\u003e\u003cp\u003eI am going to describe a simple randomised approach to solve this problem \u003ca href\u003d\"/contest/723/problem/E\" title\u003d\"Codeforces Round 375 (Div. 2)\"\u003e723E - One-Way Reform\u003c/a\u003e.\u003c/p\u003e\u003ch1\u003eProblem Overview\u003c/h1\u003e\u003cp\u003eYou have an undirected graph. You want to turn it into a directed graph by choosing a direction for each edge. Also you want to choose directions such that the number of vertices with equal out-degrees and in-degrees is maximised.\u003c/p\u003e\u003ch1\u003eThe Basic Random Approach That Does Not Work\u003c/h1\u003e\u003cp\u003eThe basic random approach is to randomly assign all edges directions (i.e for a given edge make it point in one direction with probability 0.5 and in the other with probability 0.5) and hope if we do this enough times we get an optimal solution. \u003c/p\u003e\u003cp\u003eHowever there a simple obstruction that stops this from working. Assume our original graph is a cycle. Then we can make every edge have the same out-degree and in-degree by creating a directed cycle. We can see the probability of this happening with our basic random approach is roughly \u003cspan class\u003d\"tex-span\"\u003e0.5\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e for a cycle with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e nodes. If the cycle is large it unlikely we will be able to find this solution within a reasonable number of random attempts.\u003c/p\u003e\u003ch1\u003eModifying The Basic Approach To Work\u003c/h1\u003e\u003cp\u003eThere is a simple modification to the basic approach that makes it work. We still randomly assign the edges directions as in the basic approach. \u003c/p\u003e\u003cp\u003eThe modification is after we assign the edge directions we try to improve our solution. For a given directed edge from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e if the out-degree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is greater than its in-degree and the in-degree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is greater than its out degree we swap the direction of the edge to go from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eWe check each edge exactly once, record how good our solution is and repeat the process with a new random assignment. It is clear that this should deal with the case when our graph is just a big cycle. Surprisingly if you repeat this process 1000 times and take the best answer found in all trails it passes all the testcases. Code \u003ca href\u003d\"/contest/723/submission/34649661\" title\u003d\"Submission 34649661 by usernameson\"\u003e34649661\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eConclusion\u003c/h1\u003e\u003cp\u003eThis approach feels like a hill-climbing algorithm. We start at a random position and head to a local optimum. To increase the odds that we find a global optimum we choose a variety of different starting positions. It could be possible that a well constructed graph would cause this approach to fail with a high probability. However, I do not know how to construct such a graph. \u003c/p\u003e\u003c/div\u003e","tags":["#graph","#randomisation","#hill-climbing"]}}