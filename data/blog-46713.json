{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1471855546,"rating":7,"authorHandle":"praran26","modificationTimeSeconds":1471855546,"id":46713,"title":"\u003cp\u003eCodechef August Cook Off 2016 â€” Math Hatter bug\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eProblem Statement: \u003ca href\u003d\"https://www.codechef.com/COOK73/problems/MADHAT\"\u003ehttps://www.codechef.com/COOK73/problems/MADHAT\u003c/a\u003e\u003c/p\u003e\u003cp\u003eMy implementation: \u003ca href\u003d\"http://ideone.com/u9Av7q\"\u003ehttp://ideone.com/u9Av7q\u003c/a\u003e\u003c/p\u003e\u003cp\u003eHere\u0027s what I did:\u003c/p\u003e\u003cp\u003eFirst, I assigned \u003ccode\u003etemp[i]\u003c/code\u003e to the index of kid with just higher IQ than IQ of kid at index \u003ccode\u003ei\u003c/code\u003e (as per the given data). \u003ccode\u003efilltemp\u003c/code\u003e is the recursive function to assign \u003ccode\u003etemp[i]\u003c/code\u003e to each \u003ccode\u003ei\u003c/code\u003e. (\u003ccode\u003etemp[i]\u003c/code\u003e for kid with maximum IQ is n) (Check example below for details)\u003c/p\u003e\u003cp\u003eThen, the answer should be the number of topological orderings in tree with directed edges from \u003ccode\u003etemp[i]\u003c/code\u003e to \u003ccode\u003ei\u003c/code\u003e, starting from kid with with maximum IQ.\u003c/p\u003e\u003cp\u003eTo find the number of topological orderings, I used dfs as each branch of tree is independent.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eI\u0027m getting WA for this implementation, can anyone explain the test case that\u0027ll give WA on this?\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eExample:\u003c/strong\u003e \u003c/p\u003e\u003cp\u003en\u003d4 x\u003d[0,2,1,0]\u003c/p\u003e\u003cp\u003eI know following relations using x.\u003c/p\u003e \u003cul\u003e   \u003cli\u003eIQ[1]\u0026gt;IQ[0] since x[0]\u003d0\u003c/li\u003e   \u003cli\u003eIQ[2]\u0026lt;IQ[1] and IQ[3]\u0026lt;IQ[1] since x[1]\u003d2\u003c/li\u003e   \u003cli\u003eIQ[3]\u0026lt;IQ[2] since x[2]\u003d1\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSo my temp becomes [1,4,1,2] and the edges in tree are 4-\u0026gt;1, 1-\u0026gt;0, 1-\u0026gt;2, 2-\u0026gt;3\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/c4/9b/c49bc811bcd7d6e20e1db0224aabb4caee7979ef.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThe number of topological sorts are 3, which is the right answer for this test case.\u003c/p\u003e\u003cp\u003eWhy number of topological orderings is the answer? Because, suppose I traverse the tree in this order: 1,2,0,3. Now I\u0027ll assign IQ of kids in decreasing order from n to 1 as per the sorting. That is, IQ[1]\u003d4, IQ[2]\u003d3, IQ[0]\u003d2, IQ[3]\u003d1.\u003c/p\u003e\u003cp\u003eOther topological orderings for this example are 1,2,3,0 and 1,0,2,3 which generates two other respective IQ array.\u003c/p\u003e\u003c/div\u003e","tags":["cook-off","debugging","implementations","help"]}}