{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1432746408,"rating":3,"authorHandle":"Safrout","modificationTimeSeconds":1432746408,"id":18157,"title":"\u003cp\u003eLive Archive: Pasti Pas! TLE\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI am trying to solve this problem for a long time \u003ca href\u003d\"https://icpcarchive.ecs.baylor.edu/index.php?option\u003dcom_onlinejudge\u0026amp;Itemid\u003d8\u0026amp;category\u003d588\u0026amp;page\u003dshow_problem\u0026amp;problem\u003d4450\"\u003ehttps://icpcarchive.ecs.baylor.edu/index.php?option\u003dcom_onlinejudge\u0026amp;Itemid\u003d8\u0026amp;category\u003d588\u0026amp;page\u003dshow_problem\u0026amp;problem\u003d4450\u003c/a\u003e\u003c/p\u003e\u003cp\u003eobviously the brute force will TLE, any O(n^2) algorithm will TLE and any use of suffix array will also TLE.\u003c/p\u003e\u003cp\u003eSo what I need actually is to find a way to hash the string from left and right and this requires a hashing function that hashes a string as it hashes his reverse.\u003c/p\u003e\u003cp\u003eIs this possible or there is another way to solve the problem.\u003c/p\u003e\u003c/div\u003e","tags":["string matching","hashing","string suffix structures"]}}