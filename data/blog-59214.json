{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1525283529,"rating":31,"authorHandle":"I_love_myself","modificationTimeSeconds":1526304439,"id":59214,"title":"\u003cp\u003eО двоичных спусках и fractional cascading\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eВсем привет, \u003cs\u003eмне так понравилось как растет мой вклад\u003c/s\u003e я вижу, что вам понравился разбор в предыдущем посте, поэтому я решил периодически рассказывать о разных задачах, во многом, с применением не очень сложных структур данных. \u003cbr /\u003e Сегодня я рассажу вам об оптимизациях дерева отрезков и декартовых деревьях(все вещи аналогичны ДО), позволяющих скинуть лишний логарифм в асимптотике, также разберу одну подзадачу, позволяющую решать кучу задач. \u003cbr /\u003e \u003cstrong\u003eБудут разобраны:\u003c/strong\u003e \u003cbr /\u003e 1. Двоичный спуск \u003cbr /\u003e 2. Fractional cascading \u003cbr /\u003e 3. Задачи с удалением и добавлением элементов \u003cbr /\u003e \u003cbr /\u003e \u003cstrong\u003e1) Двоичный спуск\u003c/strong\u003e \u003cbr /\u003e Пусть вам надо найти элемент, начиная с которого сумма больше K, а вы очень упорный и не любите частичные суммы, зато хлебом вас не корми, дай дерево отрезков написать! А всё это надо сделать за log!! Как быть? На помощь приходят двоичные спуски! \u003cbr /\u003e Пусть вы знаете сумму в левом поддереве, тогда если она больше K0, то переходим в него, иначе — в правое поддерево с K1 \u003d K0 — sum(left).\u003c/p\u003e\u003cp\u003eВ целом, двоичные спуски требуются, если в какой-то задачке вы хотите бинпоиском узнавать что-то через ДО: аналогичной идеей вы каждый раз понимаете в какое поддерево нужно спуститься. \u003cbr /\u003e \u003cem\u003eСложность:\u003c/em\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/58/fb/58fbb7735aa786c1cef50555b829fb04ca6157c0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2) Fractional cascading\u003c/strong\u003e \u003cbr /\u003e К сожалению, на русскоязычных ресурсах об этом ничего нет(UPD: на e-maxx, говорят, есть), хотя это моя сама любимая оптимизация, которая мне ни разу не пригодилась, но делает крутые вещи :) \u003cbr /\u003e Итак, задача: найти k-тый элемент на отрезке [L; R], если бы отрезок был отсортирован — это назывется k-тая статистика на отрезке. (Бонус: придумайте как решать эту задачу персистентным ДО) \u003cbr /\u003e Ну а в задаче такие ограничения, что требуется \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/75/5c/755c0e72a8f6c5be4007a41acbae4bf024107b8c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e на запрос.\u003c/p\u003e\u003cp\u003eДля начала дадим понятие \u003cstrong\u003eMergeSortTree\u003c/strong\u003e — это дерево отрезков, в вершине которого хранится отсортированный массив из 2-х отсортированных массивов его сыновей. Интересно, почему же такое название у этой структуры? \u003cbr /\u003e Итак, придумаем решение за \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9b/7a/9b7a44372d6e07c012bce3e8179492badf3d733f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e на запрос. Давайте отсортируем массив по значениям, и \u003cstrong\u003eпостроим MergeSortTree по индексам\u003c/strong\u003e этого массива. Для примера вот картинка: \u003cbr /\u003e \u003cimg alt\u003d\"картинка\" src\u003d\"https://cdn.pbrd.co/images/HjMSEgg.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eПоймем, сколько элементов из [L; R] в поддереве, за которое отвечает данная вершина в дереве отрезков. На самом деле это очень просто посчитать: давайте возьмем lower_bound по L и R и найдем разность между ними — это и будет наше количество элементов. А теперь двоичными спусками будем находить k-тый элемент с помощью предыдущего утверждения. Заметим, что массив у нас отсортирован, поэтому мы получим именно k-тый элемент.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eРешение за log^2 на запрос\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;vector\u0026gt;\n\nusing namespace std;\n\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; t;\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; a;\n\nvoid build(int v, int l, int r)\n{\n\tif (r - l \u003d\u003d 1)\n\t\tt[v].push_back(a[l].second);\n\telse {\n\t\tint m \u003d (l + r) \u0026gt;\u0026gt; 1;\n\t\tbuild(2 * v + 1, l, m);\n\t\tbuild(2 * v + 2, m, r);\n\t\tt[v].resize(r - l);\n\t\tmerge(t[2 * v + 1].begin(), t[2 * v + 1].end(), t[2 * v + 2].begin(), t[2 * v + 2].end(), t[v].begin());\n\t}\n}\n\nint kth(int v, int l, int r, int ql, int qr, int k)\n{\n\tif (r - l \u003d\u003d 1)\n\t\treturn l;\n\telse {\n\t\tint m \u003d (l + r) \u0026gt;\u0026gt; 1;\n\n\t\tint cntleft \u003d lower_bound(t[2 * v + 1].begin(), t[2 * v + 1].end(), qr) - lower_bound(t[2 * v + 1].begin(), t[2 * v + 1].end(), ql);\n\t\tif (k \u0026lt; cntleft)\n\t\t\treturn kth(2 * v + 1, l, m, ql, qr, k);\n\t\telse\n\t\t\treturn kth(2 * v + 2, m, r, ql, qr, k - cntleft);\n\t}\n}\n\nint main()\n{\n\t//freopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\tint n;\n\tcin \u0026gt;\u0026gt; n;\n\ta.resize(n);\n\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\tcin \u0026gt;\u0026gt; a[i].first;\n\t\ta[i].second \u003d i;\n\t}\n\n\tsort(a.begin(), a.end());\n\n\tt.resize(4 * n);\n\tbuild(0, 0, n);\n\n\tint q;\n\tcin \u0026gt;\u0026gt; q;\n\tfor (int i \u003d 0; i \u0026lt; q; i++) {\n\t\tint l, r, k;\n\t\tcin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k;\n\t\tl--, k--;\n\t\tcout \u0026lt;\u0026lt; a[kth(0, 0, n, l, r, k)].first \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t}\n}\n\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eА теперь то, зачем мы все здесь собрались, расскажу о fractional cascading. Давайте помимо отсортированных массивов в вершине хранить еще два: l и r, такие что l[i] означает количество элементов в левом поддереве, которые не больше a[i], аналогично c r. По сути эти массивы означают upper_bound. Аналогично можно завеcти и lower_bound. \u003cbr /\u003e Картинкой построение upper_bound: \u003cbr /\u003e \u003cimg alt\u003d\"гифочка как строится fraction cascading\" src\u003d\"https://cdn.pbrd.co/images/HjNrcKz.gif\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cbr /\u003e Вернёмся к задаче и поймем, что теперь вместо бинпоиска в сыновьях мы можем просто перейти по этим индексам L и R и найдем опять наш отрезок [L1; R1], в котором лежат только индексы из [L0; R0]. Итого нам придется только двоично спускаться по дереву, поэтому сложность \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e на запрос.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eРешение за log n на запрос\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;vector\u0026gt;\n\nusing namespace std;\n\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; t;\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; lup, rup;\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; llow, rlow;\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; a;\n\nvoid build(int v, int l, int r)\n{\n\tif (r - l \u003d\u003d 1)\n\t\tt[v].push_back(a[l].second);\n\telse {\n\t\tint m \u003d (l + r) \u0026gt;\u0026gt; 1;\n\t\tbuild(2 * v + 1, l, m);\n\t\tbuild(2 * v + 2, m, r);\n\t\t\n\t\tint i \u003d 0, j \u003d 0;\n\t\twhile (i \u0026lt; t[2 * v + 1].size() || j \u0026lt; t[2 * v + 2].size()) {\n\t\t\tllow[v].push_back(i);\n\t\t\trlow[v].push_back(j);\n\n\t\t\tif (i !\u003d t[2 * v + 1].size() \u0026amp;\u0026amp; (j \u003d\u003d t[2 * v + 2].size() || t[2 * v + 1][i] \u0026lt; t[2 * v + 2][j])) {\n\t\t\t\tt[v].push_back(t[2 * v + 1][i]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tt[v].push_back(t[2 * v + 2][j]);\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tlup[v].push_back(i);\n\t\t\trup[v].push_back(j);\n\t\t}\n\t}\n}\n\nint kth(int v, int l, int r, int ql, int qr, int k)\n{\n\tif (r - l \u003d\u003d 1)\n\t\treturn l;\n\telse {\n\t\tint m \u003d (l + r) \u0026gt;\u0026gt; 1;\n\n\t\tint cntleft \u003d lup[v][qr - 1] - llow[v][ql];\n\t\tif (k \u0026lt; cntleft)\n\t\t\treturn kth(2 * v + 1, l, m, llow[v][ql], lup[v][qr - 1], k);\n\t\telse\n\t\t\treturn kth(2 * v + 2, m, r, rlow[v][ql], rup[v][qr - 1], k - cntleft);\n\t}\n}\n\nint main()\n{\n\t//freopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\tint n;\n\tcin \u0026gt;\u0026gt; n;\n\ta.resize(n);\n\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\tcin \u0026gt;\u0026gt; a[i].first;\n\t\ta[i].second \u003d i;\n\t}\n\n\tsort(a.begin(), a.end());\n\n\tt.resize(4 * n);\n\tllow.resize(4 * n);\n\tlup.resize(4 * n);\n\trlow.resize(4 * n);\n\trup.resize(4 * n);\n\tbuild(0, 0, n);\n\n\tint q;\n\tcin \u0026gt;\u0026gt; q;\n\tfor (int i \u003d 0; i \u0026lt; q; i++) {\n\t\tint l, r, k;\n\t\tcin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k;\n\t\tl--, k--;\n\t\tcout \u0026lt;\u0026lt; a[kth(0, 0, n, l, r, k)].first \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t}\n}\n\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eВ целом, fraction cascadinbg используется в задачах на MergeSortTree, в которых требуется каждый раз бинпоиском искать что-то в сыновьях. \u003cbr /\u003e\u003cbr /\u003e 3) Научимся решать \u003cstrong\u003eзадачи на запросы в оффлайн\u003c/strong\u003e, которые вы можете сделать на обычном ДО, но \u003cstrong\u003eс возможностью добавления и удаления элементов\u003c/strong\u003e. Для этого нам надо понять относительный порядок элементов, если бы мы не удаляли элементы. \u003cbr /\u003e Давайте заведем неявное ДД; для каждого элемента будем хранить 0 или 1 — удален этот элемент или нет соответственно, а так же будем сохранять количество неудаленных в поддереве(еще чтобы в конце выполнить запросы, требуется хранить номера запросов, которые добавили и удалили данный элемент). Тогда напишем ещё одну операцию split1, которая будет аналогично split разрезать дерево на 2, но в split1 будет разрезать по количеству еще не удалённых элементов в правом дереве. Теперь с помощью split1 и стандартного merge мы можем добавлять и удалять элементы(вместо удаления нам просто нужно поставить 0 в элемент на позиции pos среди неудаленных). \u003cbr /\u003e Теперь мы получили относительный порядок элементов, можно построить дерево отрезков и выполнять наши операции, а вместо удаленных или еще недобавленных элементов можно записать фиктивные значения. \u003cbr /\u003e \u003cem\u003eСложность построения:\u003c/em\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3d/4b/3d4bf15cee5abfd3f3cad756c76b499c2375254e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eВ целом, эта мини-лекция была подготовительной для дальнейших и является базовой и необходимой в олимпиадном программировании. \u003cbr /\u003e Если что-то не понятно, задавайте вопросы в комментариях, объясню более подробно\u003c/p\u003e\u003c/div\u003e","tags":["структура данных","дерево отрезков","декартово дерево","fractional cascding","двоичный спуск"]}}