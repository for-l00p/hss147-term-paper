{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1457798280,"rating":0,"authorHandle":"randomusername","modificationTimeSeconds":1457826268,"id":43755,"title":"\u003cp\u003eČas 16 — 11.03.2016.\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eSvo gradivo za državno koje nije DP i nisu grafovi\u003c/h2\u003e \u003cul\u003e   \u003cli\u003e\u003ca href\u003d\"https://github.com/Rand0mUsername/algorithms/blob/master/Sorting/Merge%20Sort.cpp\"\u003eMerge Sort\u003c/a\u003e, spajanje korišćenjem dva pointera\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://github.com/Rand0mUsername/algorithms/blob/master/Sorting/Quicksort.cpp\"\u003eQuicksort\u003c/a\u003e, razdvajanje u odnosu na pivot\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://github.com/Rand0mUsername/algorithms/blob/master/Searching/Quickselect.cpp\"\u003eQuickselect\u003c/a\u003e, polovina Quicksorta\u003c/li\u003e   \u003cli\u003eBitna je zamisao \u0026quot;Divide and Conquer\u0026quot; algoritama kao što su Merge Sort ili Quicksort; iako nećete sortirati njima jer postoji sort() ideje su korisne\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://github.com/Rand0mUsername/algorithms/blob/master/Searching/Ternary%20Search.cpp\"\u003eTernary Search\u003c/a\u003e, traženje minimuma konveksnih/konkavnih funkcija, eliminisanje jedne trećine (nije u gradivu ali je kul znati da postoji)\u003c/li\u003e \u003c/ul\u003e\u003ch2\u003eDinamičko programiranje\u003c/h2\u003e\u003ch4\u003eKoraci:\u003c/h4\u003e\u003cp\u003e0 — Prepoznati da se zadatak radi dinamičkim\u003c/p\u003e\u003cp\u003e1 — Stanje (prvih \u003cstrong\u003ei\u003c/strong\u003e, do \u003cstrong\u003ei\u003c/strong\u003e, poslednji da bude \u003cstrong\u003ei\u003c/strong\u003e...)\u003c/p\u003e\u003cp\u003e2 — Rešenje (koje stanje čuva krajnji rezultat)\u003c/p\u003e\u003cp\u003e3 — Rekurentna veza (fiksirati nešto, oduzeti nešto...)\u003c/p\u003e\u003cp\u003e4 — Baza (koja stanja rešavamo manuelno bez korišćenja DP)\u003c/p\u003e\u003ch4\u003ePoznati problemi:\u003c/h4\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003e\u003ca href\u003d\"https://en.wikipedia.org/wiki/Fibonacci_number\"\u003en-ti fibonačijev broj\u003c/a\u003e\u003c/p\u003e   \u003cul\u003e     \u003cli\u003en-ti broj: \u003ccode\u003eDP[n] \u003d DP[n-1] + DP[n-2]\u003c/code\u003e\u003c/li\u003e     \u003cli\u003epristupi: \u0026quot;Bottom Up\u0026quot; (iterativno, češće) i \u0026quot;Top Down sa memoizacijom\u0026quot; (rekurzivno, Tree DP problemi)\u003c/li\u003e   \u003c/ul\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ca href\u003d\"http://www.mathblog.dk/project-euler-81-find-the-minimal-path-sum-from-the-top-left-to-the-bottom-right-by-moving-right-and-down/\"\u003enajbolji put kroz matricu\u003c/a\u003e\u003c/p\u003e   \u003cul\u003e     \u003cli\u003enajbolji put do ( \u003cstrong\u003ei\u003c/strong\u003e, \u003cstrong\u003ej\u003c/strong\u003e ): \u003ccode\u003eDP[i][j] \u003d max(DP[i-1][j], DP[i][j-1]) + a[i][j]\u003c/code\u003e\u003c/li\u003e     \u003cli\u003erekonstrukcija rešenja: dodatni niz u kom čuvamo \u0026quot;odakle smo došli\u0026quot;\u003c/li\u003e   \u003c/ul\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ca href\u003d\"https://en.wikipedia.org/wiki/Knapsack_problem#Unbounded_knapsack_problem\"\u003eunbounded knapsack\u003c/a\u003e\u003c/p\u003e   \u003cul\u003e     \u003cli\u003enajbolje rešenje za kapacitet \u003cstrong\u003ei\u003c/strong\u003e: \u003ccode\u003eDP[i] \u003d max{j: 1-\u0026gt;n}(DP[ i - w[j] ] + v[j])\u003c/code\u003e\u003c/li\u003e     \u003cli\u003especijalni slučaj: \u003ca href\u003d\"http://stackoverflow.com/questions/4247662/the-minimum-number-of-coins-the-sum-of-which-is-s\"\u003emin coin change\u003c/a\u003e\u003c/li\u003e   \u003c/ul\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ca href\u003d\"https://en.wikipedia.org/wiki/Knapsack_problem#0.2F1_knapsack_problem\"\u003e0/1 knapsack\u003c/a\u003e\u003c/p\u003e   \u003cul\u003e     \u003cli\u003eprvih \u003cstrong\u003ei\u003c/strong\u003e objekata, kapacitet \u003cstrong\u003ej\u003c/strong\u003e: \u003ccode\u003eDP[i][j] \u003d max{j: 1-\u0026gt;n}(DP[i-1][j], DP[i-1][j-w[i]] + v[i])\u003c/code\u003e\u003c/li\u003e     \u003cli\u003eekvivalentan problem: \u003ca href\u003d\"https://en.wikipedia.org/wiki/Subset_sum_problem#Pseudo-polynomial_time_dynamic_programming_solution\"\u003esubset sum\u003c/a\u003e\u003c/li\u003e   \u003c/ul\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ca href\u003d\"http://www.algorithmist.com/index.php/Coin_Change\"\u003ecoin change\u003c/a\u003e\u003c/p\u003e   \u003cul\u003e     \u003cli\u003eprvih \u003cstrong\u003ei\u003c/strong\u003e novčića, suma \u003cstrong\u003ej\u003c/strong\u003e: \u003ccode\u003eDP[i][j] \u003d DP[i-1][j] + DP[i][j-w[i]]\u003c/code\u003e\u003c/li\u003e     \u003cli\u003e\u0026quot;na koliko načina\u0026quot; / \u0026quot;da li je moguće\u0026quot; / \u0026quot;min\u0026quot; / \u0026quot;max\u0026quot; ne menjaju mnogo suštinu problema\u003c/li\u003e   \u003c/ul\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ca href\u003d\"https://en.wikipedia.org/wiki/Longest_common_subsequence_problem\"\u003elongest common subsequence\u003c/a\u003e (ne longest common substring!)\u003c/p\u003e   \u003cul\u003e     \u003cli\u003eprefiksi dužine \u003cstrong\u003ei\u003c/strong\u003e i \u003cstrong\u003ej\u003c/strong\u003e: \u003ccode\u003eDP[i][j] \u003d max( (A[i]\u003d\u003dB[i]) * (DP[i-1][j-1] + 1), DP[i-1][j], DP[i][j-1] )\u003c/code\u003e\u003c/li\u003e     \u003cli\u003ememorijska optimizacija: kada koristimo samo prethodni red matrice možemo da radimo sa dva niza umesto sa celom matricom (nekad uz pametan redosled računanja možemo i sve u jednom nizu)\u003c/li\u003e   \u003c/ul\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ca href\u003d\"https://en.wikipedia.org/wiki/Longest_increasing_subsequence\"\u003elongest increasing subsequence\u003c/a\u003e\u003c/p\u003e   \u003cul\u003e     \u003cli\u003eO(n^2), najduži koji se završava na i: \u003ccode\u003eDP[i] \u003d max{j: 1-\u0026gt;i-1}(DP[j] + 1), za one j gde je a[j] \u0026lt;\u003d a[i]\u003c/code\u003e\u003c/li\u003e     \u003cli\u003eO(nlogn), pomoćni niz m, \u003cstrong\u003em[i] je indeks najmanje vrednosti koja je kraj lanca dužine i\u003c/strong\u003e, dokaz da je m[i] \u0026lt;\u003d m[i+1], binarna pretraga po m\u003c/li\u003e   \u003c/ul\u003e\u003c/li\u003e \u003c/ul\u003e\u003ch4\u003eDo sledećeg časa\u003c/h4\u003e \u003cul\u003e   \u003cli\u003e\u003ca href\u003d\"//codeforces.com/group/XjVOh9c76z/contest/206493\"\u003eUcep v1.0\u003c/a\u003e\u003c/li\u003e   \u003cli\u003eNa sledećem času radimo grafove, a nakon toga odabrane zadatke + dp on a tree\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eBejaše: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Reichsmarschall\" title\u003d\"Expert Reichsmarschall\"\u003eReichsmarschall\u003c/a\u003e, \u003ca class\u003d\"rated-user user-green\" href\u003d\"/profile/FreeJ\" title\u003d\"Pupil FreeJ\"\u003eFreeJ\u003c/a\u003e, \u003ca class\u003d\"rated-user user-green\" href\u003d\"/profile/jobelix\" title\u003d\"Pupil jobelix\"\u003ejobelix\u003c/a\u003e, \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/SynoX3\" title\u003d\"Specialist SynoX3\"\u003eSynoX3\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["čas"]}}