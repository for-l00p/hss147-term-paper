{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1483517852,"rating":0,"authorHandle":"1am","modificationTimeSeconds":1483520294,"id":49560,"title":"\u003cp\u003eWeek 3 Practice Hints \u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eA. New Year and Hurry\u003c/h1\u003e\u003cp\u003eHis time in minutes in the beginning is (60 minutes) * (4 hours). We subtract fron that time k to get how much time he has to solve in the contest. Each problem takes 5 *i minutes, i starting from 1 to n. Using a for loop, if (timeleft — 5 * i \u0026gt;\u003d 0), then that means i can solve that problem and i decrease from my time 5 *i;\u003c/p\u003e\u003ch1\u003eB. Santa Claus and a Place in a Class\u003c/h1\u003e\u003cp\u003eThere are n lanes and m desks in each lane. Each desk has a left side and a right side. They will give you k, the index of the desk he is seated at, and you must calculate the position of his desk. The brute force solution is using two for loops and looping n *m*2 until we reach his desk. This solution has 10000 * 10000 *2 operations. This solution is around 10 ^8 operations. If the time limit was one second, this would not pass. But since the time limit is two seconds this solution works fine. It can also be solved with basic division modulos.\u003c/p\u003e\u003ch1\u003eC. Vladik and flights\u003c/h1\u003e\u003cp\u003eThe answer is 0, if airports with numbers a and b belong to one company. Otherwise there are two airports next to eachother,that belong to different companies. We can get to one of them for free, then pay 1 to fly to the one next to it and then fly to airport number b for free. Therefore if they are in the same company the answer is 0, otherwise the answer is always 1. \u003c/p\u003e\u003ch1\u003eD. Grasshopper And the String\u003c/h1\u003e\u003cp\u003eIn this problem you have to find the longest sequence of consonants. The answer is its length + 1.\u003c/p\u003e\u003cp\u003eIterate over each letter of string maintaining cur — current number of consecutive consonants and len — length of longest sequence. If current letter is consonant then increase cur by 1, otherwise update len \u003d max(len, cur) and set cur \u003d 1. Don\u0027t forget to update len value after exiting loop (as string can possibly end with consonant).\u003c/p\u003e\u003ch1\u003eE. Vitaly and Strings\u003c/h1\u003e\u003cp\u003eTo solve this problem we can, for example, find string next, which lexicographically next to string s and check that string next is lexicographically less than string t. If string next is lexicographically smaller than string t, print string next and finish algorithm. If string next is equal to string t print No such string. To find string next, which lexicographically next to string s, at first we need to find maximal ending of string s, consisting from letters \u0027z\u0027, change all letters \u0027z\u0027 in this suffix on letters \u0027a\u0027, and then letter before this suffix increase on one. I.e. if before suffix was letter, for example, \u0027d\u0027, we need to change it on letter \u0027e\u0027.\u003c/p\u003e\u003cp\u003efor example: vklldrxnfgyorgfpfezvhbouyzzzzz vklldrxnfgyorgfpfezvhbouzaaadv\u003c/p\u003e\u003cp\u003eanswer is : vklldrxnfgyorgfpfezvhbouzaaaaa\u003c/p\u003e\u003cp\u003eIf it doesnt end with a \u0027z\u0027, just increase last letter and check if it is less than t.\u003c/p\u003e\u003ch1\u003eF. Buy a Shovel\u003c/h1\u003e\u003cp\u003eIn this problem we have to find the minimal possible value of x such that k·x % 10 \u003d 0 or k·x % 10 \u003d r. It\u0027s easy to see that this x always exists and it is not greater than 10 (because k·10 % 10 \u003d 0). Let\u0027s iterate on x, and if its current value satisfies any of the requirements, we print the answer. 1 \u0026lt;\u003dx \u0026lt;\u003d10\u003c/p\u003e\u003ch1\u003eG. Crazy Computer\u003c/h1\u003e\u003cp\u003eThis is a straightforward implementation problem. Iterate through the times in order, keeping track of when is the last time a word is typed, keeping a counter for the number of words appearing on the screen. Increment the counter by 1 whenever you process a new time. Whenever the difference between the time for two consecutive words is greater than c, reset the counter to 0. After that, increment it by 1.\u003c/p\u003e\u003ch1\u003eH. A Good Contest\u003c/h1\u003e\u003cp\u003eIf for any participant beforei ≥ 2400 and afteri \u0026gt; beforei, then the answer is \u0026quot;YES\u0026quot;, otherwise \u0026quot;NO\u0026quot;\u003c/p\u003e\u003ch1\u003eI. Save Luke\u003c/h1\u003e\u003cp\u003eWidth of free space is decreasing by v1 + v2 per second. It means that it\u0027ll decrease from L to d in t \u003d (l — d) / (v1 + v2) seconds. The moment when width gets a value of d is the last when Luke is alive so t is the answer.\u003c/p\u003e\u003cp\u003eJust make sure for this question you are subtracting integer from integer and dividing by another integerm that makes it integer division when it should be double division.\u003c/p\u003e\u003cp\u003eYou can cast it to double like this: t \u003d (double)(l — d) / (double)(v1 + v2);\u003c/p\u003e\u003ch1\u003eJ. Watching a movie\u003c/h1\u003e\u003cp\u003eIf we can skip x minutes at current moment without skipping any good moment — we do that, otherwise — watch another minute of the film. In the question it states that it is guaranteed that for all integers i from 2 to n the following condition holds: ri - 1 \u0026lt; li. So that means they are already sorted for us.\u003c/p\u003e\u003ch1\u003eK. Valera and X\u003c/h1\u003e\u003cp\u003eThe X goes through the entire paper, we can loop through with two for loops i ( 1 -\u0026gt;n) and j (1 -\u0026gt;n), if our i and our j is equal to 1, then that gives us the character for our X. if our i is equal to 1 and our j is equal to 2, that gives us the character for anything not x. All you need to do is check if you are on a diagnol, then check if that character is the one you already stored for the X. If you are not on diagnol, then check that it is equal to the one you stored for anything not X. Ill leave it up to you to figure out how to tell if you are on diagnol or not, but you can tell from i and j, they follow a specifc pattern.\u003c/p\u003e\u003ch1\u003eL. Perfect Permutation\u003c/h1\u003e\u003cp\u003eConsider permutation p such that pi \u003d i. Actually p is a sequence of numbers from 1 to n. Obviously ppi \u003d i. Now the only trick is to change the permutation to satisfy the second equation: pi ≠ i. Let\u0027s swap every two consequtive elements. More formally, for each k: 2k ≤ n let\u0027s swap p2k - 1 and p2k. It\u0027s easy to see that the obtained permutation satisfies both equations for every n with the only exception: when n is odd, there is no answer and we should print  - 1.\u003c/p\u003e\u003c/div\u003e","tags":[]}}