{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1473240564,"rating":3,"authorHandle":"HardW3ll","modificationTimeSeconds":1473241502,"id":46989,"title":"\u003cp\u003eQualification round #2 editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem A\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eLet\u0027s have for each node a value equals the xor of edges from the root to the node. Now if we want to check if two nodes a, b are good, val[a] ^ val[b] must equal zero. As the paths from the lca to the root will cancel each other. Now the problem is each node is given a value and we want to count how many nodes have the same value after each edge destruction. Instead of destroying edges we\u0027ll build the tree from the last edge to the first and we\u0027ll use a disjoint set. Each time we merge two components we iterate over the smaller component and search in the large one, and then update the values of the large one.\u003c/p\u003e\u003cp\u003eComplexity \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7d/44/7d44642304a6b584b3ccec688422d53bef148624.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/5f5HBA\"\u003eSolution\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem B\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eLet\u0027s count the number of palindromes. We can have a prefix sum of lengths for each character to answer each query in O(1).\u003c/p\u003e\u003cp\u003eComplexity \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/04/8d/048d4095edeb83eb1e98ee32c2bd2061b652e031.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/l8UXj1\"\u003eSolution\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem C\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/85/4b/854b1f732a5ab13b5d4f283829520c8498e54b4b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eWe\u0027ll divide the polygon into 3n triangles. Now to get the area of one triangle, a is a segment from the center of the polygon (which is also center of triangles) and perpendicular on the base. Which make a equals 1/3 * sin(60) * s. Now it\u0027s easy to get the triangle area.\u003c/p\u003e\u003cp\u003eComplexity \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b0/2a/b02acfdab71b1c7c1ad024f32ec04c18f7c6ca84.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/seIyMr\"\u003eSolution\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem D\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eLet\u0027s ignore the zeros from the array and try to get a subarray with sum \u003d x using two pointers, After that we use binary search to get a subarray next to this with a sum equals 2x or 3x, the answer will be the multiplication of number of zeros + 1 between each two consecutive subarrays.\u003c/p\u003e\u003cp\u003eComplexity \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/22/95/229590595d8dba3f35d6fd84a86fce6cc6199346.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/SJgnDw\"\u003eSolution\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem G\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFor each k, Let\u0027s subtract k from each element in the array. Now the problem is to get the maximum length of a subarray with a non-negative sum. Which can be done by binary search.\u003c/p\u003e\u003cp\u003eComplexity \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/43/0d/430d01f849d84590fc91da8da86de0026e9e589a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/CqbdYz\"\u003eSolution\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem I\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eMeet in the middle.\u003c/p\u003e\u003cp\u003eComplexity \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c9/a6/c9a67aeab6bf6959b679b4dae1ace81d82d3d438.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/Tn7vdh\"\u003eSolution\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem J\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eLet\u0027s first construct the graph. It can be done using two pointers. After that the part of the walk of M steps can be done in several ways. One way is that after n steps it\u0027s guaranteed that we\u0027ll be in a node that is in a cycle. So if m \u0026lt;\u003d n let\u0027s walk m using sparse table. otherwise let\u0027s walk n steps, reach a cycle, and then walk (m â€” n) % (size of the cycle).\u003c/p\u003e\u003cp\u003eComplexity \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/22/95/229590595d8dba3f35d6fd84a86fce6cc6199346.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/1UeTbi\"\u003eSolution\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}