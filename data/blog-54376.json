{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1504718968,"rating":2,"authorHandle":"1am","modificationTimeSeconds":1504719251,"id":54376,"title":"\u003cp\u003eDay 2 Review\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eLCA\u003c/h1\u003e\u003cp\u003eToday we learned about lowest common ancestor. The first step to the algorithm is building a sparse table where dp[u][k] represents the 2^k ancestor of u. \u003c/p\u003e\u003cp\u003edp[u][0] is the parent of the node u. To get dp[u][1], its the parent of my parent node. So dp[u][1] \u003d dp[ dp[u][0] ][0]. Using this pattern for all k, dp[u][k] \u003d dp[ dp[u][k-1] ] [k-1]\u003c/p\u003e\u003cp\u003eNow the first step to get the lca of two nodes is raising the one at a lower depth to the same level as the second. You can get the depth array through a simple dfs. Then raise the lower node by the difference between their depths using the sparse table. If the difference is 5 (101), then I must take the 4th ancestor of my 1st parent. \u003c/p\u003e\u003cp\u003eAfter that, I continue raising both nodes by the ith ancestor as long as they are not equal. Once I\u0027m done, the parent of either node will be the LCA.\u003c/p\u003e\u003cp\u003eHere is the code we wrote: \u003ca href\u003d\"https://ideone.com/DUaGeS\"\u003ehttps://ideone.com/DUaGeS\u003c/a\u003e We solved problem Fools and Roads using LCA.\u003c/p\u003e\u003ch1\u003eTrie\u003c/h1\u003e\u003cp\u003eA trie is a very useful way of storing strings in a tree like structure. We wrote this code to figure out how many strings start with a certain prefix. \u003ca href\u003d\"https://ideone.com/cQWU3j\"\u003ehttps://ideone.com/cQWU3j\u003c/a\u003e\u003c/p\u003e\u003cp\u003eYou can use Trie to solve problem Good Substrings from day1.\u003c/p\u003e\u003ch1\u003eSmall to Big Trick\u003c/h1\u003e\u003cp\u003ewe solved \u003ca href\u003d\"//codeforces.com/problemset/problem/600/E\"\u003ethis problem\u003c/a\u003e, the idea was to store a map that contains all the colors in a sub-tree with their frequency for each node and to swap our map with the largest map of one of our children.\u003cbr /\u003ea link to a more detailed editorial is in the previous blog\u003c/p\u003e\u003ch1\u003eMatrix Exponentaion\u003c/h1\u003e\u003cp\u003ewe solved \u003ca href\u003d\"//codeforces.com/problemset/problem/691/E\"\u003ethis problem\u003c/a\u003e, we first created the adjacency matrix by checking for every two elements in the array if their xor has a multiple of 3 one bits.\u003cbr /\u003ethen we raised the matrix to the power (k â€” 1).\u003cbr /\u003e\u003ca href\u003d\"//codeforces.com/contest/691/submission/24277612\"\u003ecode\u003c/a\u003e\u003cbr /\u003e\u003ca href\u003d\"http://www.spoj.com/problems/FIBOSUM/\"\u003epractice problem\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}