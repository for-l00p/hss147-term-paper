{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1425728742,"rating":7,"authorHandle":"Fear_Is_An_Illusion","modificationTimeSeconds":1426573362,"id":16823,"title":"\u003cp\u003eDFS explanation For Beginners.\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello, this is a post for beginners. Recently I came across a blog of someone asking a very basic simple explanation. I will try my best to explain DFS in as a simple a way as possible. \u003cstrong\u003eNote, If you know DFS, don\u0027t read any further.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eDFS (Depth First Search) is an algorithm used to traverse graph or tree. We first select the root node of a tree, or any random node(in case of graph) and explore as far as possible in a branch and then come back to a fixed point. DFS is generally used for connectivity questions. It has a time complexity of \u003ccode\u003eO(N+E)\u003c/code\u003e Where \u003ccode\u003eN\u003c/code\u003e is the total number of nodes and \u003ccode\u003eE\u003c/code\u003e is the total number of edges.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/3d/1e/3d1e19a5f15a7d114b4b2751306ac1f6d985bfa6.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s take this graph. Here A is connected to E,B,D ; B is connected with A,D,C ; C is connected with B ; D is connected with A,B and E is connected with A ; F is not connected.\u003c/p\u003e\u003cp\u003eWe represent this graph using an Adjacency List. Here is the code (in Python)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003egraph\u003d{ \u0027A\u0027:[\u0027E\u0027,\u0027B\u0027,\u0027D\u0027],\n        \u0027B\u0027:[\u0027A\u0027,\u0027D\u0027,\u0027C\u0027],\n        \u0027C\u0027:[\u0027B\u0027],\n        \u0027D\u0027:[\u0027A\u0027,\u0027B\u0027],\n        \u0027E\u0027:[\u0027A\u0027]}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOnce we have the list, we perform DFS. Basically, we pick a node. Then we keep track if we have visited the nodes directly and indirectly connected to it. Since we are traversing downwards, we use a stack and we\u0027ll use it\u0027s last in first out(LIFO) feature. We also keep a list of all the nodes we have visited since we have to visit each node only once. So we will add an node to the stack only if that node has not been visited. On visiting a particular node we remove it from the stack. Finally, we\u0027ll end up visiting all the nodes and then the stack will be empty. That will serve as the terminating condition.\u003c/p\u003e\u003cp\u003eHere are the steps to follow while performing DFS.\u003c/p\u003e \u003cul\u003e   \u003cli\u003eSelect a node. Since we have selected the node, add it to the visited list.\u003c/li\u003e   \u003cli\u003eLook at all the adjacent nodes. Add those nodes which have not been visited to the stack.\u003c/li\u003e   \u003cli\u003eThen pop the top node and Follow the first two steps.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eNow, let us pick any node (say A) and perform DFS. \u003c/p\u003e \u003col\u003e   \u003cli\u003eWe have selected the node A. We now add A to the list of nodes we have visited(which is empty initially). The nodes directly connected to A are E,B,D. So since we havent visited those nodes, we add them to the stack s. Now \u003ccode\u003es\u003d[E,B,D]\u003c/code\u003e and \u003ccode\u003evisited\u003d[A]\u003c/code\u003e\u003c/li\u003e   \u003cli\u003eWe pop s, and we get D. Now D is connected directly with A,B. Since we have visited A, we dont add it. So now \u003ccode\u003es\u003d[E,B]\u003c/code\u003e and \u003ccode\u003evisited\u003d[A,D]\u003c/code\u003e.\u003c/li\u003e   \u003cli\u003eWe pop s, and we get B. Now B is connected directly to A,D,C. Since we have visited A,D we dont add it. However as we have not visited C, we add it to stack s. So now \u003ccode\u003es\u003d[E,C]\u003c/code\u003e and \u003ccode\u003evisited\u003d[A,D,B]\u003c/code\u003e\u003c/li\u003e   \u003cli\u003eWe pop s, we get C. Since we have visited all nodes connected to C, we dont push anything to the stack s. So now \u003ccode\u003es\u003d[E]\u003c/code\u003e and \u003ccode\u003evisited\u003d[A,D,B,C]\u003c/code\u003e\u003c/li\u003e   \u003cli\u003eWe pop s, we get E. Since we have visited all nodes connected to E, we dont push anything to the stack s. So now \u003ccode\u003es\u003d[]\u003c/code\u003e and \u003ccode\u003evisited\u003d[A,D,B,C,E]\u003c/code\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eNow the stack is empty, and the DFS has been completed. The answer lies in the order we visited in the visited list.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSample iterative implementation.\u003c/strong\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003egraph\u003d{ \u0027A\u0027:[\u0027E\u0027,\u0027B\u0027,\u0027D\u0027],\n        \u0027B\u0027:[\u0027A\u0027,\u0027D\u0027,\u0027C\u0027],\n        \u0027C\u0027:[\u0027B\u0027],\n        \u0027D\u0027:[\u0027A\u0027,\u0027B\u0027],\n        \u0027E\u0027:[\u0027A\u0027]}\n\ndef dfs(graph,s):\n    stack\u003d[]\n    visited\u003d[]\n    stack\u003d[s]\n    while stack:\n        node\u003dstack.pop()\n        if node not in visited:\n            visited.append(node)\n            stack\u003dstack+graph[node]\n    return visited\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHope this helps you.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eThanks for your attention\u003c/strong\u003e \u003cstrong\u003e:) :)\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e","tags":["dfs","beginner","algorithms"]}}