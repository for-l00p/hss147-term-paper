{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1459033768,"rating":9,"authorHandle":"fcspartakm","modificationTimeSeconds":1459039058,"id":44016,"title":"\u003cp\u003eРазбор задач Технокубок 2016 — Отборочный Раунд 2\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/649/problem/A\" title\u003d\"Технокубок 2016 - Отборочный Раунд 2\"\u003e649A - Любимые числа Поликарпа\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eДля решения данной задачи нужно воспользоваться фактом, что степени двойки быстро растут, и максимальная степень двойки, на которую может делится число, не превосходящее \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e, равна 29. Поэтому нужно просто проитерироваться по заданным числам, найти максимальную степень двойки, на которую делится текущее число и обновить ответ этой максимальной степенью.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПример решения\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eОсновная часть решения:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint n, x;\n\nint main() {\n\tcin \u0026gt;\u0026gt; n;\t\n\tint ans \u003d -1, cnt \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\tcin \u0026gt;\u0026gt; x;\n\t\tint cur \u003d 1, power \u003d 0;\n\t\twhile (true) {\n\t\t\tcur *\u003d 2;\n\t\t\tif (x % cur) break;\t\t\t\n                        power++;\n\t\t}\n\t\tif (ans \u0026lt; power) {\n\t\t\tans \u003d power;\n\t\t\tcnt \u003d 1;\n\t\t} else if (ans \u003d\u003d power) {\n\t\t\tcnt++;\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/649/problem/B\" title\u003d\"Технокубок 2016 - Отборочный Раунд 2\"\u003e649B - Этажи\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eДля решения данной задачи нужно было аккуратно реализовать то, что написано в условии. Основная сложность заключалась в определении номера подъезда и номера этажа по номеру квартиры. Это можно было сделать следующим образом: если в доме \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e подъездов, в каждом подъезде по \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e этажей, а на каждом этаже по \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e квартир, то квартира с номером \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e находится в подъезде номер \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e - 1) / (\u003ci\u003em\u003c/i\u003e * \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e и на этаже номер \u003cspan class\u003d\"tex-span\"\u003e((\u003ci\u003ea\u003c/i\u003e - 1)%(\u003ci\u003em\u003c/i\u003e * \u003ci\u003ek\u003c/i\u003e)) / \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, причем эти номера 0-индексированы, что удобно для дальнейших вычислений. После определения номеров подъездов и этажей, нужно было рассмотреть два случая — когда номера подъездов Эдварда и Наташи равны (тогда нужно было выбрать, что оптимальнее — доехать на лифте или подняться/спуститься по лестнице), и когда эти номера различны (тут нужно было не забыть, что дом круглый, и выбрать нужное направление).\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПример решения\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eОсновная часть решения:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint n, m, k, a, b;\n\nint main() {\t\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\ta--, b--;\n\tint p1 \u003d a / (m * k), p2 \u003d b / (m * k);\n\tint f1 \u003d (a % (m * k)) / k, f2 \u003d (b % (m * k)) / k;\n\tif (p1 \u003d\u003d p2) {\n\t\tcout \u0026lt;\u0026lt; min(abs(f1 - f2) + 10, abs(f1 - f2) * 5) \u0026lt;\u0026lt; endl;\n\t} else {\n\t    if(p1 \u0026gt; p2) swap(p1, p2);\n\t    cout \u0026lt;\u0026lt; min((p2 - p1) * 15, (p1 + n - p2) * 15) + min(f1 * 5, 10 + f1) + min(f2 * 5, 10 + f2) \u0026lt;\u0026lt; endl;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/649/problem/C\" title\u003d\"Технокубок 2016 - Отборочный Раунд 2\"\u003e649C - Печать условий\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eСначала отсортируем заданные размеры комплектов задач в неубывающем порядке. Затем нужно начать перебирать комплекты задач, начиная с наименьшего. Если мы не можем напечатать текущий комплект, то никакой следующий комплект мы гарантированно не сможем напечатать, поэтому нужно вывести ответ и закончить алгоритм. В противном случае нужно напечатать текущий комплект, увеличить ответ на единицу и перейти к следующему комплекту. Каждый комплект оптимально печатать следующим образом. Пусть \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e — это оставшееся количество двусторонних листов, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e — это оставшееся количество односторонних листов, а \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e — это количество страниц в текущем комплекте задач. Если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d 0\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e \u003d 0\u003c/span\u003e, то напечатать текущий комплект мы точно не сможем. Если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e нечетно и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e \u0026gt; 0\u003c/span\u003e, напечатаем одну страницу на одностороннем листе и уменьшим \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e на единицу, иначе если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e нечетно и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026gt; 0\u003c/span\u003e, напечатаем одну страницу на двустороннем листе (который больше использовать не будем) и уменьшим \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e на единицу. Теперь \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e это всегда четное число. Поэтому выгодно сначала по максимуму использовать для печати двусторонние листы, а если их не хватает — односторонние. Если и односторонних листов не хватает, то текущий комплект распечатать мы не сможем.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПример решения\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eОсновная часть решения:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint n, x, y;\nint a[N];\n\nbool can(int a)\n{\n\tif (a % 2) {\n\t\tif (y \u0026gt; 0) a--, y--;\n\t\telse if (x \u0026gt; 0)\ta--, x--;\n\t\telse return false;\n\t}\t\t\n\tif (x * 2 \u0026gt;\u003d a)\t{\n\t\tx -\u003d a / 2;\n\t\treturn true;\n\t}\n\ta -\u003d 2 * x, x \u003d 0;\n\tif (y \u0026gt;\u003d a) {\n\t\ty -\u003d a;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i];\n\tsort(a, a + n);\n\tint ans \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; i++)\t\n\t\tif(can(a[i])) ans++;\n\t\telse break;\t\t\t\t\t\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/649/problem/D\" title\u003d\"Технокубок 2016 - Отборочный Раунд 2\"\u003e649D - Дефрагментация памяти\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eДля решения данной задачи нужно сформировать массив, который будет равен памяти компьютера после дефрагментации. Для этого, например, можно запомнить про каждый процесс (в порядке слева направо) количество ячеек, которые он занимает. Верно следующее утверждение — пока дефрагментация не закончена, всегда будет две такие ячейки с номерами \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e1\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e2\u003c/span\u003e в памяти компьютера, что ячейка \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e1\u003c/span\u003e пуста, а ячейка \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e2\u003c/span\u003e занята процессом, который по окончании дефрагментации должен находится в ячейке номер \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e1\u003c/span\u003e. Таким образом, ответ на задачу, это количество таких ячеек в памяти, которые должны быть заняты каким-то процессом после окончания дефрагментации, причем до начала дефрагментации эти ячейки либо пусты, либо в них записаны другие процессы (отличные от тех, которые должны быть записаны после дефрагментации).\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПример решения\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eОсновная часть решения:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint n;\nint a[N], need[N];\nint szneed;\n\nint main() {\n\tcin \u0026gt;\u0026gt; n;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\tcin \u0026gt;\u0026gt; a[i];\n\t\tif (a[i] !\u003d 0) need[szneed++] \u003d a[i];\t\t\t\n\t}\n        int ans \u003d 0; \n        for (int i \u003d 0; i \u0026lt; n; i++) {\n        \tif (need[i] !\u003d 0 \u0026amp;\u0026amp; need[i] !\u003d a[i]) ans++;\n        }\t\n        cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/649/problem/E\" title\u003d\"Технокубок 2016 - Отборочный Раунд 2\"\u003e649E - Автобус\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eИзначально отсортируем всех путешественников по их начальным позициям в неубывающем порядке, а при равенстве позиций — отсортируем по дистанциям, которые путешественникам нужно преодолеть, также в неубывающем порядке. Затем необходимо бинарным поиском подобрать минимальное количество мест в автобусе, которых будет достаточно для перевозки \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e путешественников. \u003c/p\u003e\u003cp\u003eЦелевая функция бинарного поиска должна работать следующим образом. Пусть \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e\u003c/span\u003e — количество мест в автобусе. Тогда найдем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e\u003c/span\u003e — максимальное количество путешественников, которых мы сможем подвезти на таком автобусе. Это можно сделать с помощью \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eset\u003c/i\u003e\u003c/span\u003e-a, в котором мы будем хранить позиции выходов путешественников, которые зашли в автобус, и их индексы. \u003c/p\u003e\u003cp\u003eПереберем всех путешественников слева направо (в том порядке, в котором они были отсортированы). Пока в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eset\u003c/i\u003e\u003c/span\u003e-е есть путешественники, которые выйдут из автобуса не позднее момента, когда зайдет текущий путешественник, удалим позиции их выходов из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eset\u003c/i\u003e\u003c/span\u003e и добавим их индексы в отдельный вектор \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003c/span\u003e. В противном случае, если самая дальняя позиция выхода путешественника в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eset\u003c/i\u003e\u003c/span\u003e-е больше, чем потенциальная позиция выхода текущего путешественника, заменим в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eset\u003c/i\u003e\u003c/span\u003e-е самого дальневыходящего путешественника на текущего. \u003c/p\u003e\u003cp\u003eПосле того, как мы переберем всех путешественников, добавим индексы всех оставшихся в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eset\u003c/i\u003e\u003c/span\u003e-е путешественников в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003c/span\u003e. Если размер вектора \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003c/span\u003e меньше \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, сдвинем в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e\u003c/span\u003e левую границу бинарного поиска, иначе сдвинем в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e\u003c/span\u003e правую границу бинарного поиска. После бинарного поиска, запустим еще раз целевую функцию от ответа и выведем индексы путешественников из вектора \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПример решения\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eОсновная часть решения:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint n, a;\nvector\u0026lt;pair\u0026lt;pair\u0026lt;int, int\u0026gt;, int \u0026gt; \u0026gt; v;\nset\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; s;\nvector\u0026lt;int\u0026gt; ans;\n\nint ok (int x) {\n\ts.clear();\n\tans.clear();\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\tint l \u003d v[i].first.first, r \u003d v[i].first.second;\n\t\twhile (!s.empty() \u0026amp;\u0026amp; s.begin()-\u0026gt;first \u0026lt;\u003d l) {\n\t\t\tans.push_back(s.begin()-\u0026gt;second);\n\t\t\ts.erase(s.begin());\n\t\t}\n\t\tif ((int)s.size() + 1 \u0026lt;\u003d x)\ts.insert(mp(r, v[i].second));\n\t\telse {\n\t\t\ts.insert(make_pair(r, v[i].second));\n\t\t\tset\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; :: iterator it \u003d s.end();--it;\n\t\t\ts.erase(it);\n\t\t}\n\t}\n\twhile (!s.empty()) {\n\t\tans.push_back(s.begin()-\u0026gt;second);\n\t\ts.erase(s.begin());\n\t}\n\treturn (int)ans.size();\n}\n\nint main() {\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; a;\n\tv.resize(n);\n\tfor (int i \u003d 0; i \u0026lt; n; i++)\n\t\tcin \u0026gt;\u0026gt; v[i].first.first \u0026gt;\u0026gt; v[i].first.second, v[i].first.second +\u003d v[i].first.first, v[i].second \u003d i;\n\tsort(v.begin(), v.end());\n\tint l \u003d 0, r \u003d a;\n\twhile (r - l \u0026gt; 1) {\n\t\tint mid \u003d (l + r) / 2;\n\t\tif(ok(mid) \u0026gt;\u003d a)\n\t\t\tr \u003d mid;\n\t\telse\n\t\t\tl \u003d mid;\n\t}\n\tok(r);\n\tcout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl;\t\n\tfor (int i \u003d 0; i \u0026lt; a; i++)\n\t\tcout \u0026lt;\u0026lt; ans[i] + 1 \u0026lt;\u0026lt; \u0027 \u0027;\t\n\tcout \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["технокубок","отборочный","разбор","editorial"]}}