{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1510689213,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1518642715,"id":55775,"title":"\u003cp\u003eУсловный оператор. Несколько простых задач (Обновлено!)\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eСледующая подборка задач с Timus — на использование условного оператора. Некоторое количество теории, в том числе пример решения задачи (если вдруг понадобится) — чуть ниже списка задач. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eТекст ниже можно разделить на следующие части: список задач, описание синтаксиса условного оператора (\u003ccode\u003eif\u003c/code\u003e), пример решения задачи.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eСписок задач\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗадача 1785 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1785\"\u003eТрудности локализации\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЗадача 1877 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1877\"\u003eВелосипедные коды\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЗадача 1820 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1820\"\u003eУральские бифштексы\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЗадача 1639 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1639\"\u003eШоколад 2\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЗадача 1924 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1924\"\u003eЧетыре чертёнка\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЗадача 2012 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d2012\"\u003eПро Гришу Н.\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЗадача 2066 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d2066\"\u003eПростое выражение\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЗадача 1327 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1327\"\u003eПредохранители\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЗадача 1493 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1493\"\u003eВ одном шаге от счастья\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЗадача 1194 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1194\"\u003eРукопожатия\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЗадача 1638 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1638\"\u003eКнижный червь\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eСинтаксис оператора \u003ccode\u003eif\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВ \u0026quot;классической форме\u0026quot; условный оператор выглядит так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eif (\u0026lt;условие\u0026gt;) {\n    \u0026lt;операторы 1\u0026gt;\n}\nelse {\n    \u0026lt;операторы 2\u0026gt;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗдесь \u003ccode\u003e\u0026lt;условие\u0026gt;\u003c/code\u003e — некоторое выражение логического (\u003ccode\u003eboolean\u003c/code\u003e) типа, \u003ccode\u003e\u0026lt;операторы 1\u0026gt;\u003c/code\u003e — операторы, которые должны быть выполнены, если условие имеет значение \u003ccode\u003etrue\u003c/code\u003e, \u003ccode\u003e\u0026lt;операторы 2\u0026gt;\u003c/code\u003e — операторы, которые должны быть выполнены, если условие имеет значение \u003ccode\u003efalse\u003c/code\u003e. Условие \u003cem\u003eобязательно\u003c/em\u003e должно быть заключено в круглые скобки. \u003c/p\u003e\u003cp\u003eВетвь \u003ccode\u003eelse\u003c/code\u003e является необязательной, поэтому её можно не писать, если никаких действий (\u003ccode\u003e\u0026lt;операторы 2\u0026gt;\u003c/code\u003e) не требуется:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eif (\u0026lt;условие\u0026gt;) {\n    \u0026lt;операторы 1\u0026gt;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЕсли в группе операторов \u003ccode\u003e\u0026lt;операторы 1\u0026gt;\u003c/code\u003e или \u003ccode\u003e\u0026lt;операторы 2\u0026gt;\u003c/code\u003e только один оператор, то фигурные скобки вокруг этой группы можно не писать (в примере ниже обе группы состоят из одного оператора):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eif (\u0026lt;условие\u0026gt;)\n    \u0026lt;оператор 1\u0026gt;;\nelse\n    \u0026lt;оператор 2\u0026gt;;\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНапомним, что в Java после каждого оператора необходимо ставить точку с запятой \u003ccode\u003e;\u003c/code\u003e (можете считать, что это признак окончания оператора). \u003c/p\u003e\u003cp\u003eПоскольку условный оператор является одним \u0026quot;большим\u0026quot; оператором, то нередко опускать скобки можно при использовании вложенного условного оператора. Сравните:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eif (\u0026lt;условие 1\u0026gt;) {\n    \u0026lt;операторы 1.1\u0026gt;\n}\nelse {\n    if (\u0026lt;условие 2\u0026gt;) {\n        \u0026lt;операторы 2.1\u0026gt;\n    }\n    else {\n        \u0026lt;операторы 2.2\u0026gt;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eи\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eif (\u0026lt;условие 1\u0026gt;) {\n    \u0026lt;операторы 1.1\u0026gt;\n}\nelse if (\u0026lt;условие 2\u0026gt;) {\n    \u0026lt;операторы 2.1\u0026gt;\n}\nelse {\n    \u0026lt;операторы 2.2\u0026gt;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВторая запись используется чаще, нужно просто помнить, что компилятор всегда считает \u003ccode\u003eelse\u003c/code\u003e принадлежащим ближайшему \u003ccode\u003eif\u003c/code\u003e (первому выше этого \u003ccode\u003eelse\u003c/code\u003e). \u003c/p\u003e\u003cp\u003eЕсли оператор \u003ccode\u003eif\u003c/code\u003e нужно вложить в ветвь \u003ccode\u003eif\u003c/code\u003e, то преобразовать конструкцию в \u0026quot;менее вложенную\u0026quot; будет сложнее.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eif (\u0026lt;условие 1\u0026gt;) {\n    if (\u0026lt;условие 2\u0026gt;) {\n        \u0026lt;операторы 2.1\u0026gt;\n    }\n    else {\n        \u0026lt;операторы 2.2\u0026gt;\n    }\n}\nelse {\n    \u0026lt;операторы 1.2\u0026gt;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПонадобится объединить условия \u003ccode\u003e\u0026lt;условие 1\u0026gt;\u003c/code\u003e и \u003ccode\u003e\u0026lt;условие 2\u0026gt;\u003c/code\u003e в одно, а далее придётся проверить соблюдение условия 1 \u0026quot;отдельно\u0026quot; от условия 2, чтобы, в зависимости от результата проверки, выполнить операторы 2.2 или 2.1:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eif (\u0026lt;условие 1\u0026gt; \u0026amp;\u0026amp; \u0026lt;условие 2\u0026gt;) {\n    \u0026lt;операторы 2.1\u0026gt;\n}\nelse if (\u0026lt;условие 1\u0026gt;) {\n        \u0026lt;операторы 2.2\u0026gt;    \n}\nelse {\n    \u0026lt;операторы 1.2\u0026gt;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДействительно, \u003ccode\u003e\u0026lt;операторы 2.1\u0026gt;\u003c/code\u003e должны выполняться в том случае, если и \u003ccode\u003e\u0026lt;условие 1\u0026gt;\u003c/code\u003e, и \u003ccode\u003e\u0026lt;условие 2\u0026gt;\u003c/code\u003e принимают значение \u003ccode\u003etrue\u003c/code\u003e (за это и отвечает первый \u003ccode\u003eif\u003c/code\u003e). Далее, \u003ccode\u003e\u0026lt;операторы 2.2\u0026gt;\u003c/code\u003e должны выполняться, если \u003ccode\u003e\u0026lt;условие 1\u0026gt;\u003c/code\u003e принимает значение \u003ccode\u003etrue\u003c/code\u003e, а \u003ccode\u003e\u0026lt;условие 2\u0026gt;\u003c/code\u003e, напротив, принимает значение \u003ccode\u003efalse\u003c/code\u003e. Понятно, что в первую ветвь \u003ccode\u003eelse\u003c/code\u003e можно попасть при условии, что логическое выражение \u003ccode\u003e(\u0026lt;условие 1\u0026gt; \u0026amp;\u0026amp; \u0026lt;условие 2\u0026gt;)\u003c/code\u003e принимает значение \u003ccode\u003efalse\u003c/code\u003e. Но \u0026quot;причиной\u0026quot; этого значения может быть как \u003ccode\u003e\u0026lt;условие 2\u0026gt;\u003c/code\u003e, так и \u003ccode\u003e\u0026lt;условие 1\u0026gt;\u003c/code\u003e, именно это и проверяется с помощью второго \u003ccode\u003eif\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eКонечно, не нужно стремиться любой ценой преобразовать вложенную структуру в \u0026quot;плоскую\u0026quot; (хотя плоскую зачастую легче читать). Но если решено преобразовывать, необходимо проследить, чтобы все операторы выполнялись именно и только при соблюдении тех условий, при соблюдении которых они выполнялись в исходной структуре.\u003c/p\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eСинтаксис оператора \u003ccode\u003eswitch\u003c/code\u003e\u003c/strong\u003e \u003c/p\u003e\u003cp\u003eОператор выбора также является условным оператором. В отличие от оператора \u003ccode\u003eif\u003c/code\u003e, предоставляющего две альтернативы, \u003ccode\u003eswitch\u003c/code\u003e позволяет рассмотреть несколько вариантов. Вообще говоря, эти операторы могут успешно заменять друг друга, хотя у каждого есть предпочтительная \u0026quot;сфера применения\u0026quot;.\u003c/p\u003e\u003cp\u003eОператор выбора выглядит следующим образом:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eswitch (\u0026lt;переключатель\u0026gt;) {\n    case \u0026lt;вариант 1\u0026gt;: \u0026lt;операторы 1\u0026gt;\n    case \u0026lt;вариант 2\u0026gt;: \u0026lt;операторы 2\u0026gt;\n    ...\n    case \u0026lt;вариант N\u0026gt;: \u0026lt;операторы N\u0026gt;\n    default: \u0026lt;операторы\u0026gt;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ качестве \u003cstrong\u003eпереключателя\u003c/strong\u003e могут быть использованы переменные примитивных типов \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003eshort\u003c/code\u003e, \u003ccode\u003ebyte\u003c/code\u003e, \u003ccode\u003echar\u003c/code\u003e, соответствующих им типов-оболочек \u003ccode\u003eInteger\u003c/code\u003e, \u003ccode\u003eShort\u003c/code\u003e, \u003ccode\u003eByte\u003c/code\u003e, \u003ccode\u003eCharacter\u003c/code\u003e, типов-перечислений \u003ccode\u003eenum\u003c/code\u003e, а также типа \u003ccode\u003eString\u003c/code\u003e. Типы-оболочки и типы-перечисления будут рассматриваться позже, хотя, надо полагать, их \u0026quot;концепция\u0026quot; может быть интуитивно понятна уже сейчас. Если не вдаваться в подробности, типы-оболочки используются там, где в силу особенностей синтаксиса не могут быть использованы примитивные типы; типы-перечисления позволяют задать набор именованных констант.\u003c/p\u003e\u003cp\u003eЗначения \u003ccode\u003eвариант 1\u003c/code\u003e, \u003ccode\u003eвариант 2\u003c/code\u003e, ..., \u003ccode\u003eвариант N\u003c/code\u003e должны быть того же (или совместимого) типа, что и переключатель. Важно: варианты должны быть попарно несовпадающими значениями.\u003c/p\u003e\u003cp\u003eВетвь \u003ccode\u003edefault\u003c/code\u003e может отсутствовать; если же она есть, то выполняется в случае, если ни один вариант не соответствует переключателю. \u003c/p\u003e\u003cp\u003eКоличество операторов в блоках может быть любым: поскольку имеются \u0026quot;естественные границы\u0026quot;, позволяющие отделить один блок от другого. Заметим, что \u0026quot;любым\u0026quot; означает в том числе и нулевым: если имеется несколько вариантов, для которых выполняются одни и те же операторы, то это будет записано, например, так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e    case \u0026lt;вариант 3\u0026gt;: \n    case \u0026lt;вариант 4\u0026gt;: \n    case \u0026lt;вариант 5\u0026gt;:  \u0026lt;операторы 5\u0026gt;\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВыполняется оператор \u003ccode\u003eswitch\u003c/code\u003e следующим образом. Вычисляется значение переключателя, после чего последовательно просматриваются все варианты. Если значение переключателя совпадает с некоторым вариантом, будут выполнены \u003cstrong\u003eвсе\u003c/strong\u003e операторы, записанные после него (разумеется, если среди этих операторов не будет оператора, прерывающего исполнение \u003ccode\u003eswitch\u003c/code\u003e — о нём чуть ниже).\u003c/p\u003e\u003cp\u003eТ.е., если, например, значение переключателя совпало со значением \u003ccode\u003eвариант 1\u003c/code\u003e, то будут выполнены и \u003ccode\u003e\u0026lt;операторы 1\u0026gt;\u003c/code\u003e, и \u003ccode\u003e\u0026lt;операторы 2\u0026gt;\u003c/code\u003e, и все остальные операторы, вплоть до блоков \u003ccode\u003e\u0026lt;операторы N\u0026gt;\u003c/code\u003e и \u003ccode\u003e\u0026lt;операторы\u0026gt;\u003c/code\u003e в ветви \u003ccode\u003edefault\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eДовольно часто требуется выполнить только операторы для конкретного варианта, после чего прервать выполнение оператора \u003ccode\u003eswitch\u003c/code\u003e. Чтобы обеспечить такое поведение, каждый блок операторов завершают оператором \u003ccode\u003ebreak\u003c/code\u003e. Однако бывают ситуации, когда в некоторых вариантах оператор \u003ccode\u003ebreak\u003c/code\u003e полезно не использовать. Приведём пример такого кода.\u003c/p\u003e\u003cp\u003eПусть на вход подаётся число от 1 до 10, и нам нужно вывести \u0026quot;римскую запись\u0026quot; для этого числа. Записывать ответ мы будем в строку.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eint arabic;\n// ввод числа от 1 до 10\n\nString rome \u003d \u0026quot;\u0026quot;;\n\nswitch (arabic) {\n    case 3: rome +\u003d \u0026quot;I\u0026quot;;\n    case 2: rome +\u003d \u0026quot;I\u0026quot;;\n    case 1: rome +\u003d \u0026quot;I\u0026quot;; break;\n    case 4: rome \u003d \u0026quot;IV\u0026quot;;\n    case 8: rome \u003d \u0026quot;I\u0026quot; + rome;\n    case 7: rome \u003d \u0026quot;I\u0026quot; + rome;\n    case 6: rome \u003d \u0026quot;I\u0026quot; + rome;\n    case 5: rome \u003d \u0026quot;V\u0026quot; + rome; break;\n    case 9: rome +\u003d \u0026quot;I\u0026quot;;\n    case 10: rome +\u003d \u0026quot;X\u0026quot;; break;\n    default: rome \u003d \u0026quot;undefined transformation\u0026quot;;\n}\n\nSystem.out.println(rome);\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eРассмотрим несколько случаев работы этого оператора.\u003c/p\u003e\u003cp\u003eПусть на вход подано число 7. Последовательно будут выполнены такие присваивания:\u003c/p\u003e\u003cp\u003e\u003ccode\u003erome \u003d \u0026quot;I\u0026quot; + rome;\u003c/code\u003e — в case 7 \u0026quot;I\u0026quot; + \u0026quot;\u0026quot; даст \u0026quot;I\u0026quot;\u003c/p\u003e\u003cp\u003e\u003ccode\u003erome \u003d \u0026quot;I\u0026quot; + rome;\u003c/code\u003e — в case 6 \u0026quot;I\u0026quot; + \u0026quot;I\u0026quot; даст \u0026quot;II\u0026quot;\u003c/p\u003e\u003cp\u003e\u003ccode\u003erome \u003d \u0026quot;V\u0026quot; + rome;\u003c/code\u003e — в case 5 \u0026quot;V\u0026quot; + \u0026quot;II\u0026quot; даст \u0026quot;VII\u0026quot;\u003c/p\u003e\u003cp\u003eПусть на вход подано число 9. Тогда сначала строка rome получит значение \u0026quot;I\u0026quot; (при срабатывании \u003ccode\u003ecase 9\u003c/code\u003e), после чего будут исполнены операторы, записанные в \u003ccode\u003ecase 10\u003c/code\u003e- т.е. строка rome получит значение \u0026quot;IX\u0026quot;, а затем оператор \u003ccode\u003ebreak\u003c/code\u003e прекратит исполнение оператора \u003ccode\u003eswitch\u003c/code\u003e. Обратите внимание, что если в \u003ccode\u003ecase 10\u003c/code\u003e оператор \u003ccode\u003ebreak\u003c/code\u003e будет отсутствовать, то это приведёт к исполнению оператора из ветви \u003ccode\u003edefault\u003c/code\u003e, и вместо верного ответа \u0026quot;IX\u0026quot; будет получено сообщение о неопределенном преобразовании (undefined transformation).\u003c/p\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eПример решения задачи\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВсе задачи, которые рассматриваются в этом разделе, предполагают, что сначала вы выводите формулу с помощью ручки или карандаша на бумаге, а затем используете ее при записи решения. Мы рассмотрим, вероятно, чуть более сложную задачу, чем большинство в комплекте, предложенном выше.\u003c/p\u003e\u003cp\u003e\u003cem\u003eЗадача \u0026quot;Автобус или трамвай?\u0026quot;\u003c/em\u003e\u003c/p\u003e\u003cp\u003eВ этой задаче для удобства будем отсчитывать время в минутах от начала суток.\u003c/p\u003e\u003cp\u003eКеша может поехать в университет как на автобусе, так и на трамвае. Каких-либо предпочтений у Кеши нет: он садится в первый подошедший транспорт. \u003cbr /\u003e Автобусы и трамваи ходят регулярно. Первый автобус приезжает на остановку в момент времени \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, а затем каждые \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e минут на остановку приезжает очередной автобус. Первый трамвай приезжает на остановку в момент времени \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e, а затем каждые \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e минут на остановку приезжает очередной трамвай. \u003cbr /\u003e Сегодня Кеша пришёл на остановку в момент времени \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e. Определите, поедет ли Кеша на автобусе или на трамвае. \u003cbr /\u003e Считайте, что если автобус и трамвай приедут одновременно, Кеша поедет на автобусе. Считайте также, что если Кеша приходит на остановку одновременно с автобусом и / или трамваем, он успеет сесть в подошедший транспорт. \u003cbr /\u003e Если Кеша поедет на автобусе, выведите \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eBUS\u003c/i\u003e\u003c/span\u003e, если же на трамвае — выведите \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eTRAM\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003e\u003cem\u003eВходные данные\u003c/em\u003e\u003c/p\u003e\u003cp\u003eВ первой строке содержатся два целых числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(0 ≤ \u003ci\u003ea\u003c/i\u003e ≤ 1000,  1 ≤ \u003ci\u003eb\u003c/i\u003e ≤ 100)\u003c/span\u003e — момент времени, в который к остановке приезжает первый автобус, и интервал движения автобусов.\u003c/p\u003e\u003cp\u003eВо второй строке содержатся два целых числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(0 ≤ \u003ci\u003ec\u003c/i\u003e ≤ 1000,  1 ≤ \u003ci\u003ed\u003c/i\u003e ≤ 100)\u003c/span\u003e — момент времени, в который к остановке приезжает первый трамвай, и интервал движения трамваев.\u003c/p\u003e\u003cp\u003eВ третьей строке содержится целое число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(0 ≤ \u003ci\u003eh\u003c/i\u003e ≤ 1200)\u003c/span\u003e — момент времени, в который Кеша пришёл на остановку.\u003c/p\u003e\u003cp\u003e\u003cem\u003eВыходные данные\u003c/em\u003e\u003c/p\u003e\u003cp\u003eВыведите в первой строке слово \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eBUS\u003c/i\u003e\u003c/span\u003e, если Кеша поедет на автобусе, и слово \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eTRAM\u003c/i\u003e\u003c/span\u003e, если Кеша поедет на трамвае.\u003c/p\u003e\u003cp\u003e\u003cem\u003eРешение\u003c/em\u003e\u003c/p\u003e\u003cp\u003eСначала обсудим \u0026quot;математическую\u0026quot; часть решения. \u003cbr /\u003e Задача может быть переформулирована так: начиная с момента времени \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e, будем вести наблюдения за транспортом. Нужно установить, автобус или трамвай придёт первым. \u003c/p\u003e\u003cp\u003eМы знаем, что автобус приезжает к остановке в моменты времени \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + 2·\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, ... \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e·\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, ...\u003c/p\u003e\u003cp\u003eНайдём такое целое \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, чтобы \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e·\u003ci\u003eb\u003c/i\u003e \u0026lt; \u003ci\u003eh\u003c/i\u003e\u003c/span\u003e, но \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + (\u003ci\u003ek\u003c/i\u003e + 1)·\u003ci\u003eb\u003c/i\u003e ≥ \u003ci\u003eh\u003c/i\u003e\u003c/span\u003e. Тогда момент времени \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + (\u003ci\u003ek\u003c/i\u003e + 1)·\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e и будет моментом времени, в который к остановке приедет первый с начала наблюдений автобус. \u003c/p\u003e\u003cp\u003eС точки зрения математики вроде бы всё просто: нужно вычислить \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d (\u003ci\u003eh\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e) / \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e и при необходимости округлить его вверх. Действительно, пусть \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d 400\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e \u003d 20\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e \u003d 517\u003c/span\u003e. Тогда \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d (517 - 400) / 20 \u003d 5 + 17 / 20\u003c/span\u003e. Округление вверх даёт нам \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d 6\u003c/span\u003e и время \u003cspan class\u003d\"tex-span\"\u003e520 \u003d 400 + 6·20\u003c/span\u003e — т.е. ближайший автобус, на котором сможет поехать Кеша, приедет к остановке в момент времени 520 (предыдущий автобус приедет в момент времени 500, очевидно, что Кеша на него не успевает). \u003c/p\u003e\u003cp\u003eНо давайте рассмотрим такие данные: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d 400\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e \u003d 20\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e \u003d 300\u003c/span\u003e. Мы получаем для \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e значение \u003cspan class\u003d\"tex-span\"\u003e - 5\u003c/span\u003e, которое нас не устроит. Вполне понятно, что Кеша в этом случае будет вынужден ждать первый автобус (конечно, если раньше него не придёт трамвай), и \u0026quot;фактическое\u0026quot; значение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e будет равно 0. Значит, пользоваться этой формулой мы можем только при условии, что \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e ≥ \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eЕщё один важный момент состоит в том, что с точки зрения компьютера целые и вещественные числа — очень разные сущности. И целочисленной единице может соответствовать как вещественное \u003cspan class\u003d\"tex-span\"\u003e0.999999999999\u003c/span\u003e, так и \u003cspan class\u003d\"tex-span\"\u003e1.00000000001\u003c/span\u003e. Заметим, что второе при округлении вверх даст ответ 2, а это тоже не совсем то, чего мы ожидаем. \u003c/p\u003e\u003cp\u003eВ Java (впрочем, как и в большинстве языков, использующих вещественную арифметику) при возможности следует отдавать предпочтение операциям над целыми числами (а не операциям над вещественными числами). Поэтому при вычислении \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e мы также будем вычислять и остаток от деления \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eh\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e)%\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. Если остаток отличен от нуля, то к \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e нужно прибавить 1 (это и будет округление вверх). \u003c/p\u003e\u003cp\u003eАналогичным образом можно провести вычисления для трамвая (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e будет заменено на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e, а \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e — на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e). Когда будут вычислены искомые моменты времени, останется их просто сравнить. \u003c/p\u003e\u003cp\u003e\u003cbr /\u003e А теперь перейдём к \u0026quot;программистской\u0026quot; части решения.\u003c/p\u003e\u003cp\u003eБудем считать, что вы уже уверенно пишете простые задачи, в которых условный оператор не нужен, и что вы умеете создавать классы и методы. Мы уже не будем останавливаться на этом так же подробно, как в предыдущих записях в блоге. \u003c/p\u003e\u003cp\u003eСоздайте новый проект с именем \u003ccode\u003ebustram\u003c/code\u003e; в нём — класс (это будет \u0026quot;запускающий класс\u0026quot;, согласно терминам предыдущих записей) \u003ccode\u003eBusOrTram\u003c/code\u003e. Не забудьте удалить название пакета в строке \u003ccode\u003ePackage\u003c/code\u003e диалогового окна и поставить в этом же диалоговом окне галочку на \u003ccode\u003epublic static void main(String[] args)\u003c/code\u003e. У вас должно получиться следующее:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epublic class BusOrTram {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТеперь создадим класс, содержащий логику. Назовём его \u003ccode\u003eKChoice\u003c/code\u003e \u003cem\u003e(англ. choice — выбор, K — от имени Кеши)\u003c/em\u003e. Входные данные — пять целых чисел, поэтому объявим пять целочисленных переменных с названиями, соответствующими обозначениям во входных данных. Также напишем конструктор класса, в котором будет создаваться объект класса \u003ccode\u003eScanner\u003c/code\u003e, читающий данные со стандартного входа \u003ccode\u003eSystem.in\u003c/code\u003e, и выполним чтение входных данных. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport java.util.Scanner;\n\npublic class BusOrTram {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass KChoice {\n\t\n\tKChoice() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\ta \u003d in.nextInt();\n\t\tb \u003d in.nextInt();\n\t\tc \u003d in.nextInt();\n\t\td \u003d in.nextInt();\n\t\th \u003d in.nextInt();\n\t\tin.close();\n\t}\n\t\n\tint a;\n\tint b;\n\tint c;\n\tint d;\n\tint h;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ качестве ответа нам нужно вывести строку, поэтому к объявлению пяти целочисленных переменных следует добавить объявление строковой переменной. Никакого имени в условии задачи для этой переменной не предлагается, поэтому назовём её \u003ccode\u003eans\u003c/code\u003e \u003cem\u003e(сокращённое от англ. answer — ответ).\u003c/em\u003e \u003c/p\u003e\u003cp\u003eТеперь займёмся методом \u003ccode\u003esolve()\u003c/code\u003e. Он будет частью класса \u003ccode\u003eKChoice\u003c/code\u003e, и именно в нём будут выполнены необходимые выкладки. Как уже понятно, для них нам потребуются дополнительные переменные. Однако, поскольку эти переменные нужны будут только в рамках метода \u003ccode\u003esolve()\u003c/code\u003e, именно там мы их и объявим. \u003c/p\u003e\u003cp\u003eСначала напишем вычисление момента времени, в который придёт первый (с момента прихода Кеши на остановку) автобус.\u003c/p\u003e\u003cp\u003e\u003cem\u003eСовет. Не спешите перепечатывать этот метод. Мы покажем, как прийти к более короткой записи. Хотя... Возможно, будет полезно воспроизвести все описанные ниже шаги.\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tvoid solve() {\n\t\tint x;\n\t\tif (h \u0026lt; a) {\n\t\t\tx \u003d 0;\n\t\t}\n\t\telse {\n\t\t\tx \u003d (h - a) / b;\n\t\t\tint r \u003d (h - a) % b;\n\t\t\tif (r \u0026gt; 0) {\n\t\t\t\tx \u003d x + 1;\n\t\t\t}\n\t\t}\n\t\tint tb \u003d a + x * b;\t\t\n\t\t\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗдесь, по сравнению с \u0026quot;математической\u0026quot; частью решения, появились две новые переменные: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etb\u003c/i\u003e\u003c/span\u003e. Как можно видеть, в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e мы сохраняем остаток от деления, позволяющий узнать, как мы должны округлить вверх величину \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, а в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etb\u003c/i\u003e\u003c/span\u003e мы, используя полученное значение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, записываем момент времени, в который Кеша сможет сесть в автобус. \u003c/p\u003e\u003cp\u003eПриведённую выше запись можно сделать немного короче. Поскольку переменная \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e используется только для сравнения, мы можем записать выражение непосредственно в скобках во вложенном операторе \u003ccode\u003eif\u003c/code\u003e. Также мы можем сразу присвоить величине \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e значение \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e и менять его только при выполнении условия \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e ≥ \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. Сделав такие преобразования, получим:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tvoid solve() {\n\t\tint x \u003d 0;\n\t\tif (h \u0026gt;\u003d a) {\n\t\t\tx \u003d (h - a) / b;\n\t\t\tif ((h - a) % b \u0026gt; 0) {\n\t\t\t\tx \u003d x + 1;\n\t\t\t}\n\t\t}\n\t\tint tb \u003d a + x * b;\t\t\n\t\t\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТеперь нужно провести аналогичные вычисления для трамвая. Как кажется, проще всего скопировать уже имеющиеся строчки и слегка поправить их, заменяя \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e. Переменная \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e может быть использована повторно (так как нет необходимости сохранять её значение), но можно заменить её на какую-то другую переменную, например, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. Метод \u003ccode\u003esolve()\u003c/code\u003e примет следующий вид:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tvoid solve() {\n\t\tint x \u003d 0;\n\t\tif (h \u0026gt;\u003d a) {\n\t\t\tx \u003d (h - a) / b;\n\t\t\tif ((h - a) % b \u0026gt; 0) {\n\t\t\t\tx \u003d x + 1;\n\t\t\t}\n\t\t}\n\t\tint tb \u003d a + x * b;\t\t\n\t\t\n\t\tint y \u003d 0;\n\t\tif (h \u0026gt;\u003d c) {\n\t\t\ty \u003d (h - c) / d;\n\t\t\tif ((h - c) % d \u0026gt; 0) {\n\t\t\t\ty \u003d y + 1;\n\t\t\t}\n\t\t}\n\t\tint tt \u003d c + y * d;\t\n\t\t\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКонечно, метод \u0026quot;скопировать — вставить\u0026quot; может быть хорош в некоторых случаях. Но давайте посчитаем, сколько раз нам пришлось менять имена переменных? Было сделано 4 замены \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, 4 замены \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e, 3 замены \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e и одна замена \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etb\u003c/i\u003e\u003c/span\u003e на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ett\u003c/i\u003e\u003c/span\u003e. Целых 12 изменений в таком небольшом фрагменте кода... \u003c/p\u003e\u003cp\u003eСамое неприятное заключается в том, что если Вы забудете сделать хотя бы одну из этих замен, результат будет совсем другим. Найти такую ошибку может быть очень непросто. Наиболее правильный подход — в случае повторяющихся вычислений вынести их в отдельную функцию. Конечно, это потребует выполнения ещё одной операции \u0026quot;копировать — вставить\u0026quot;, но мы введём осмысленные обозначения, и это поможет нам не запутаться. \u003c/p\u003e\u003cp\u003eЕсли вдруг мы допустили ошибку в вычислении времени, то исправить её будет нужно в одном месте — в функции \u003ccode\u003ecalcTime()\u003c/code\u003e. В методе же \u003ccode\u003esolve()\u003c/code\u003e теперь осталось лишь две строки — два вызова функции \u003ccode\u003ecalcTime()\u003c/code\u003e с разными параметрами.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tint calcTime(int start, int interval) {\n\t\tint x \u003d 0;\n\t\tif (h \u0026gt;\u003d start) {\n\t\t\tx \u003d (h - start) / interval;\n\t\t\tif ((h - start) % interval \u0026gt; 0) {\n\t\t\t\tx \u003d x + 1;\n\t\t\t}\n\t\t}\n\t\tint tres \u003d start + x * interval;\n\t\treturn tres;\n\t}\n\t\n\t\n\tvoid solve() {\n\t\tint tb \u003d calcTime(a, b);\t\t\n\t\tint tt \u003d calcTime(c, d);\t\n\t\t\n\t}\n\t\t\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗавершающий штрих — это сравнение величин \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etb\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ett\u003c/i\u003e\u003c/span\u003e, присваивание переменной \u003ccode\u003eans\u003c/code\u003e соответствующего значения и вывод его на печать. Разумеется, нужно будет дописать несколько строк и в метод \u003ccode\u003emain()\u003c/code\u003e запускающего класса.\u003c/p\u003e\u003cp\u003eПри присваивании переменной \u003ccode\u003eans\u003c/code\u003e значения используем такой же подход, какой был применён выше: присвоим сначала одно из допустимых значений, а затем выполним сравнение и, если потребуется, изменим значение переменной. \u003c/p\u003e\u003cp\u003eВ итоге получим следующую программу:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport java.util.Scanner;\n\npublic class BusOrTram {\n\n\tpublic static void main(String[] args) {\n\t\tKChoice kc \u003d new KChoice();\n\t\tkc.solve();\n\t\tkc.print();\n\t}\n\n}\n\nclass KChoice {\n\t\n\tKChoice() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\ta \u003d in.nextInt();\n\t\tb \u003d in.nextInt();\n\t\tc \u003d in.nextInt();\n\t\td \u003d in.nextInt();\n\t\th \u003d in.nextInt();\n\t\tin.close();\n\t}\n\t\n\tint calcTime(int start, int interval) {\n\t\tint x \u003d 0;\n\t\tif (h \u0026gt;\u003d start) {\n\t\t\tx \u003d (h - start) / interval;\n\t\t\tif ((h - start) % interval \u0026gt; 0) {\n\t\t\t\tx \u003d x + 1;\n\t\t\t}\n\t\t}\n\t\tint tres \u003d start + x * interval;\n\t\treturn tres;\n\t}\n\t\n\tvoid solve() {\n\t\tint tb \u003d calcTime(a, b);\t\t\n\t\tint tt \u003d calcTime(c, d);\t\n\t\tans \u003d \u0026quot;BUS\u0026quot;;\n\t\tif (tt \u0026lt; tb) {\n\t\t\tans \u003d \u0026quot;TRAM\u0026quot;;\n\t\t}\n\t}\n\t\n\tvoid print() {\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tint a;\n\tint b;\n\tint c;\n\tint d;\n\tint h;\n\tString ans;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eСохраните файл и попробуйте запустить программу на следующих входных данных:\u003c/p\u003e\u003cp\u003eВходные данные:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e400 25\n380 27\n520\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОтвет:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eBUS\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКомментарий. \u003cbr /\u003e Действительно, можно посчитать, что трамвай придёт в момент времени 515, а потом — в момент времени 542. Автобус же подъедет к остановке в момент времени 525, так что Кеша, придя в момент времени 520, конечно, поедет на автобусе.\u003c/p\u003e\u003cp\u003eВходные данные:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e400 25\n380 27\n530\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОтвет:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eTRAM\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКомментарий. \u003cbr /\u003e От предыдущего примера этот отличается лишь временем прихода на остановку Кеши. Теперь он не успевает на автобус, приходящий в момент времени 525, а следующий автобус подъедет только в момент времени 550. Так что Кеша уедет на трамвае, который придёт в момент времени 542. \u003c/p\u003e\u003cp\u003eВходные данные:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e400 25\n380 27\n250\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОтвет:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eTRAM\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКомментарий. \u003cbr /\u003e Этот пример иллюстрирует ситуацию, когда Кеша пришёл на остановку и раньше первого автобуса, и раньше первого трамвая. Поскольку первый трамвай приедет раньше первого автобуса, то Кеша уедет на нём.\u003c/p\u003e\u003cp\u003eВходные данные:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e400 25\n380 27\n385\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОтвет:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eBUS\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКомментарий. \u003cbr /\u003e Этот пример показывает, что Кеше выгоднее дождаться первого автобуса. Первый трамвай он пропустил, а следующий придет лишь через 7 минут после первого автобуса.\u003c/p\u003e\u003cp\u003eВходные данные:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e400 25\n380 20\n600\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОтвет:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eBUS\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКомментарий. \u003cbr /\u003e Этот пример показывает ситуацию, когда и автобус, и трамвай подъезжают к остановке одновременно. Согласно условию задачи Кеша должен выбрать автобус. Именно так и поступает программа.\u003c/p\u003e\u003cp\u003eВходные данные:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e400 25\n380 27\n542\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОтвет:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eTRAM\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКомментарий. \u003cbr /\u003e Этот пример показывает, что если Кеша приходит одновременно с трамваем, он успевает уехать на этом трамвае (можно придумать аналогичный пример с автобусом).\u003c/p\u003e\u003cp\u003eПридумайте свои примеры входных данных и удостоверьтесь, что ваша программа выводит правильный ответ.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eВажно!\u003c/strong\u003e Придумывая свои примеры, также продумывайте, какую ситуацию они иллюстрируют. Конечно, проверка на произвольных входных данных тоже нужна, но необходимо рассмотреть и \u0026quot;крайние\u0026quot; случаи, как это было сделано выше. Действительно, мы проверили, что програма выводит корректный результат не только в \u0026quot;общем\u0026quot; случае (первые два примера входных данных), но и в ситуациях, когда Кеша должен дождаться первого автобуса / трамвая, когда Кеша приходит на остановку одновременно с каким-либо видом транспорта, когда и автобус, и трамвай приезжают одновременно. \u003c/p\u003e\u003cp\u003eМы ограничивались проверкой для одного из видов транспорта потому, что вычисления для обоих видов транспорта выполняются одной и той же функцией. В случае же применения метода \u0026quot;копировать — вставить\u0026quot; с последующей заменой переменных настоятельно рекомендуется тестировать оба случая независимо.\u003c/p\u003e\u003c/div\u003e","tags":["java","if","switch"]}}