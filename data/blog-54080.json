{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1503780065,"rating":183,"authorHandle":"P_Nyagolov","modificationTimeSeconds":1503817431,"id":54080,"title":"\u003cp\u003e[Tutorial] Nearest Neighbor Search: Locality-Sensitive Hashing, K-Dimensional Tree, Vantage-Point Tree\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello everyone,\u003c/p\u003e\u003cp\u003eSo I recently prepared a lecture for a Bulgarian camp on the topic since I find it quite wide and interesting. I have never seen an article discussing different approaches for the problem so today I am going to share my knowledge. Don\u0027t forget to give me your feedback, please!\u003c/p\u003e\u003cp\u003eLet\u0027s start with first defining the problem we are going to solve. We are given a set of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e-dimensional points. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e queries follow, each containing a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e-dimensional point. We should answer each query with the distance (we will use Euclidean distance) to the point from the set which is closest to the queried one. This will be our main focus but we are still going to consider inserting/deleting points from the set when possible. It\u0027s important to say that for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e \u0026gt; 1\u003c/span\u003e we will consider only average-case complexity and we will assume that the points are distributed uniformly. Unfortunately, even the average-case complexity is exponential in the number of dimensions.\u003c/p\u003e\u003ch5\u003eOne-Dimensional NNS\u003c/h5\u003e\u003cp\u003eWithout doubt, the problem is really simple when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e \u003d 1\u003c/span\u003e. In the picture below, the dark blue point is the queried one and all other points belong to the set.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/99/8a/998a95addb8d2a74c58ac7aef26871be86c47288.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eIt is easy to see that for any point, the one which is closest to it is either the closest to the left or the closest to the right. This leads to a pretty simple solution: First we sort the initial set of points and for each query we use binary search to find its position in the sorted array which automatically gives us its predecessor and successor points.\u003c/p\u003e\u003cp\u003eNow what about insertion/deletion of points?\u003c/p\u003e\u003cp\u003eWell, we can pretty much use the same idea. We need to keep the points sorted and quickly find the position of each queried point. At this moment, it should be obvious that any binary search tree will do the job and std::set is a good example.\u003c/p\u003e\u003ch5\u003eLocality-Sensitive Hashing for Two-Dimensional NNS\u003c/h5\u003e\u003cp\u003eWhen we usually use hashing, we try to avoid collisions no matter what, right? Well, not here. We would like to find a function which maps relatively close points to the same or close numbers and not-so-close points to different/not-so-close numbers. You can try to come up with some good functions on your own. They don\u0027t need to be perfect, the one I am going to present is not guaranteed to work but as you will see, after repeating it a few times we can have some pretty decent chances of getting it right or at least very close. \u003cstrong\u003eDO NOT\u003c/strong\u003e continue reading if you are planning to spend some time thinking.\u003c/p\u003e\u003cp\u003eSo, let\u0027s draw a few random lines (excuse me for being so bad at faking randomness):\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/86/17/861754e959f1266a8420d986afc981bea9447ea1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eFor each line, consider the two half-planes it creates. Let\u0027s write a zero next to each point from one of the half-planes and a one next to each point from the other. Something like this:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/40/ea/40ea4175b414993760a0bbd6fb6c5862889391aa.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eNow this binary code will be the hash for each point. When we are given a query point, we are going to find its hash according to the lines and only check the points having the same hash. Of course, we will need to get too lucky in order to answer many queries correctly with just one set of lines. So let\u0027s just generate as many sets as we can afford and check all points which have the same hash according to at least one set of lines. Let\u0027s say that we generate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e sets with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e lines each. Don\u0027t forget that we are talking about uniformly distributed points/lines and since there are \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e possible hashes for a set of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e lines, the expected number of points in a bucket is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8a/4b/8a4b1fdacd46787357686a07f94c1b989a3dd973.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. So the complexity will be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/83/33/8333f596ae12d1b7f3f5ae8e5fd9bedd1d18ef06.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e per query. \u003c/p\u003e\u003cp\u003eInserting and deleting points is pretty much trivial since this algorithm is dynamic in its essence — the lines are generated before any points are read and then we hash them one by one and insert them in the proper buckets. \u003c/p\u003e\u003cp\u003eAlthough it is an elegant approach, it doesn\u0027t guarantee to give us a correct answer so let\u0027s move on to this structure called k-d tree.\u003c/p\u003e\u003ch5\u003eK-Dimensional Tree for Small Values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e\u003c/h5\u003e\u003cp\u003eSo this structure can solve the problem for small number of dimensions (say up to \u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e) in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e per query on average. We will see why it works only for small number of dimensions and that it is not exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e but something more special after a few moments. I am going to explain it for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e \u003d 2\u003c/span\u003e since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e being \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e really makes no difference.\u003c/p\u003e\u003cp\u003eLet\u0027s start with the root of the tree which will be responsible for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e points. Let\u0027s sort the points by their \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e coordinate. We will draw a line which we will call a splitting line somewhere between the points in the middle in order to split them evenly. The \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e coordinate this line passes through we will call a splitting value for the current node (the root in the beginning):\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/12/4f/124f26f22740e4c3bc5a86a930ea818bb1636aa8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eNow all points from the first to the middle position go to the left subtree and the others — to the right subtree. For the subtrees we will repeat the same process but this time we will sort the points by their \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e and the splitting line will go through some \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/62/9f/629fecc8ccd8540cd44c65d6590fad959502048f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eWe will keep building the tree, alternating the axes we are splitting by until we reach a subarray with only one point which results in the so called leaf nodes. That is, each leaf node contains a point and each non-leaf node contains the splitting value and the axis it is splitted by:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/62/e6/62e605e9a8f857292db8d8c0856d78bffa90b885.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eI will first explain how the NNS works and then discuss the complexity. It is actually a pretty simple recursion, you won\u0027t believe how simple! We start at the root with our answer (closest distance) set to infinity. If we reach a leaf node at any moment, we will just compare the current answer and the distance between the queried point and the point stored the current leaf. Now, I am assuming that we are in a non-leaf node. On each step, we check whether the queried point falls into the left or right subtree (assuming it was there). We don\u0027t need to be exact, if it lays on the splitting line, it doesn\u0027t matter if we consider this left or right subtree. \u003c/p\u003e\u003cp\u003eWe will first recursively traverse the subtree our point falls into. \u0026quot;But we need to traverse the other one afterwards\u0026quot;, you may say. And so will we but only if we need to. And by \u0026quot;we need to\u0026quot; I mean \u0026quot;there is a chance of encountering a closer point in the other subtree\u0026quot;. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAns\u003c/i\u003e\u003c/span\u003e be the closest distance encountered so far, after traversing one of the subtrees and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e be the distance from the queried point to the splitting line. It\u0027s easy to see that all possible candidates for better answer must be in the circle with center the queried point and radius \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAns\u003c/i\u003e\u003c/span\u003e. So we will traverse the other subtree if and only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAns\u003c/i\u003e\u003c/span\u003e\u0026gt;\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e, that is there are some points in the other subtree which are in the circle with center the queried point and radius \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAns\u003c/i\u003e\u003c/span\u003e. And this is it — as simple as it is. Notice that the distance between the queried point and the splitting line is just the absolute difference between the splitting value and the corresponding coordinate of the queried point.\u003c/p\u003e\u003cp\u003eLet\u0027s see why this is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e (not exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e, as I said, but we will get back to that soon). I don\u0027t think this qualifies as a formal proof but just to give you an idea. Take a look at the last picture and you will see how every leaf (point) is bounded by some rectangle. So we get some \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e rectangles in total. We can assume that our plane is bounded by some very big square. For our uniform distribution, we can expect each of those bounding rectangles to have similar sizes or to be more precise similar sides. That is, we can expect our big square (the plane) to be divided into \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/81/f381a867c035d8ab67dd362b509e4d7f78b7a087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e by \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/81/f381a867c035d8ab67dd362b509e4d7f78b7a087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e small squares or something really close to such configuration.\u003c/p\u003e\u003cp\u003eConsider some query. What the recursion will first do is find one of these small squares our queried point falls into and set the distance between the queried point and the point in that leaf as the current answer (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e so far). Say that it is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAns\u003c/i\u003e\u003c/span\u003e. Of course, traversing only this small square is not enough, and we will need to consider some more (those within radius \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAns\u003c/i\u003e\u003c/span\u003e). However, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/81/f381a867c035d8ab67dd362b509e4d7f78b7a087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e by \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/81/f381a867c035d8ab67dd362b509e4d7f78b7a087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e gives us a tight bound on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAns\u003c/i\u003e\u003c/span\u003e — \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/50/f5/50f569c1460b0cfb4ec5311b369b5e122b4a409e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Which means that we will only need to consider the squares surrounding this current cell (which happen to be 8), if the distribution is perfectly uniform. So the average complexity turns out to be around \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(8 * \u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e. \u003c/p\u003e\u003cp\u003e\u0026quot;But we don\u0027t consider constant factors when talking about complexity\u0026quot;, may come to your mind. This is true. As you remember I said that the complexity is not really \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e and is exponential in the number of dimensions. Do you see where this is going? This \u003cspan class\u003d\"tex-span\"\u003e8\u003c/span\u003e, the number of surrounding squares for a unit square, is actually \u003cspan class\u003d\"tex-span\"\u003e3\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sup\u003e - 1\u003c/span\u003e. And here you go, the average-case complexity for a k-d tree query is actually \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(3\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sup\u003e * \u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eInserting a point is actually pretty straighforward — we find the leaf which would contain this point if it was in the set (but actually contains another one). Then we just find a splitting line between the two points — the one in the current leaf and the one being inserted and treat this as an internal (non-leaf) node.\u003c/p\u003e\u003cp\u003eDeleting a point will be just finding the leaf that contains it and detaching it from the tree.\u003c/p\u003e\u003ch5\u003eVantage-Point Tree\u003c/h5\u003e\u003cp\u003eThis is a data structure which is a representative of another class of trees — ball trees. It is really similar to the k-d tree in the way it works and has similar complexity but it uses circles instead of lines to form the left and right subtree.\u003c/p\u003e\u003cp\u003eI won\u0027t be posting pictures but only explain the idea quickly since it has only minor differences with the k-d tree. The root again contains information about all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e points. On each step we randomly choose the so-called vantage-point for the node among all points this node is responsible for. Then we sort all points by their distance to the vantage-point. We choose a radius (the so-called threshold), which is the distance between the vantage-point and the middle point after sorting. Then we build the left subtree over the first half (those inside the circle) and the right subtree over the second half. It\u0027s not a problem if some of the points from the right subtree lie on the circle. Then we recursively build the left and right subtree.\u003c/p\u003e\u003cp\u003eWhen we query some point, we again start at the root with our answer set to infinity. Every time we visit a node, we compare the answer and the distance between the queried point and the vantage-point for the current node. Then we check if it falls inside the circle or not. Depending on that, we first traverse the left or the right subtree, respectively. \u003c/p\u003e\u003cp\u003eAfter that, we will visit the other subtree only if there is a possibility of finding a better answer. Say that the threshold for the current node is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e, the current answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAns\u003c/i\u003e\u003c/span\u003e and the distance between the queried point and the vantage-point is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e. If we first visited the left subtree, then we will go to the right one if and only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e + \u003ci\u003eAns\u003c/i\u003e \u0026gt; \u003ci\u003eT\u003c/i\u003e\u003c/span\u003e. If we first visited the right subtree, then we will go to the left one if and only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e - \u003ci\u003eAns\u003c/i\u003e \u0026lt; \u003ci\u003eT\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFor reference, consider this problem: \u003ca href\u003d\"http://www.spoj.com/problems/FAILURE/\"\u003ehttp://www.spoj.com/problems/FAILURE/\u003c/a\u003e\u003cbr /\u003eMy k-d tree solution: \u003ca href\u003d\"https://ideone.com/yDBOyc\"\u003ehttps://ideone.com/yDBOyc\u003c/a\u003e\u003cbr /\u003eMy VP tree solution: \u003ca href\u003d\"https://ideone.com/o1wTNS\"\u003ehttps://ideone.com/o1wTNS\u003c/a\u003e\u003cbr /\u003eIt is also worth mentioning that the linked problem is a special case of the nearest neighbor search — it only asks about points from the set which has a pretty neat \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e divide and conquer solution but I am too tired to explain it right now.\u003c/p\u003e\u003c/div\u003e","tags":["k-nearest neighbors","hashing","lsh","points","vp tree","k-d tree"]}}