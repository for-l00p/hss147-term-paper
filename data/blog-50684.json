{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1488114449,"rating":54,"authorHandle":"dreamplay","modificationTimeSeconds":1488123747,"id":50684,"title":"\u003cp\u003eWeekly Training Farm 25 — Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eEditorial will be completed soon!!\u003c/p\u003e\u003ch2\u003eProblem A\u003c/h2\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin \u0026gt;\u0026gt; n;\n\tbool flag;\n\tif(n \u003d\u003d 1)\n\t{\n\t\tint a, b;\n\t\tcin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\t\tif(a \u003d\u003d b)\n\t\t\tflag \u003d 1;\n\t\telse\n\t\t\tflag \u003d 0;\n\t}\n\telse if(n \u003d\u003d 2)\n\t{\n\t\tint a, b, c, d;\n\t\tcin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\t\tcin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d;\n\t\tif(a \u0026gt; b) swap(a, b);\n\t\tif(c \u0026gt; d) swap(c, d);\n\t\tif(b \u003d\u003d d \u0026amp;\u0026amp; a + c \u003d\u003d b)\n\t\t\tflag \u003d 1;\n\t\telse\n\t\t\tflag \u003d 0;\n\t}\n\telse if(n \u003d\u003d 3)\n\t{\n\t\tint a, b, c, d, e, f;\n\t\tcin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\t\tcin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d;\n\t\tcin \u0026gt;\u0026gt; e \u0026gt;\u0026gt; f;\n\t\tif(a \u0026gt; b) swap(a, b);\n\t\tif(c \u0026gt; d) swap(c, d);\n\t\tif(e \u0026gt; f) swap(e, f);\n\t\tif(b \u0026gt; f) {\n\t\t\tswap(a, e);\n\t\t\tswap(b, f);\n\t\t}\n\t\tif(d \u0026gt; f) {\n\t\t\tswap(c, e);\n\t\t\tswap(d, f);\n\t\t}\n\t\tflag \u003d 0;\n\t\tif(b \u003d\u003d d \u0026amp;\u0026amp; b \u003d\u003d f \u0026amp;\u0026amp; b \u003d\u003d a + c + e)\n\t\t\tflag \u003d 1;\n\n\t\tif(a \u003d\u003d c \u0026amp;\u0026amp; b + d \u003d\u003d f \u0026amp;\u0026amp; a + e \u003d\u003d f)\n\t\t\tflag \u003d 1;\n\t\tif(b \u003d\u003d d \u0026amp;\u0026amp; a + c \u003d\u003d f \u0026amp;\u0026amp; b + e \u003d\u003d f)\n\t\t\tflag \u003d 1;\n\t\tif(a \u003d\u003d d \u0026amp;\u0026amp; a + e \u003d\u003d f \u0026amp;\u0026amp; b + c \u003d\u003d f)\n\t\t\tflag \u003d 1;\n\t\tif(b \u003d\u003d c \u0026amp;\u0026amp; b + e \u003d\u003d f \u0026amp;\u0026amp; a + d \u003d\u003d f)\n\t\t\tflag \u003d 1;\n\t}\n\tif(flag)\n\t\tcout \u0026lt;\u0026lt; \u0026quot;yes\\n\u0026quot;;\n\telse\n\t\tcout \u0026lt;\u0026lt; \u0026quot;no\\n\u0026quot;;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eThis is an adhoc problem. We just need to consider all the possible cases of joining. Note that we can join 2 rectangles only along their common side lengths, if any. \u003c/p\u003e\u003cp\u003eFor n \u003d 1, it is trivial, check if it is a square.\u003c/p\u003e\u003cp\u003eFor n \u003d 2, only possible way is to join the 2 rectangles.\u003c/p\u003e\u003cp\u003eFor n \u003d 3, we have two cases. Either join them all linearly, all 3 in a row kind of fashion. Another way is to join the 2 rectangles to form a greater rectangle and then join third one, perpendicularly.\u003c/p\u003e\u003cp\u003eFor all of the above cases, if it is possible to form a square, the side length of square is the largest length / breadth from rectangles.\u003c/p\u003e\u003ch2\u003eProblem B\u003c/h2\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int mod \u003d 1e9 + 7;\nint main() {\n\tint l, r;\n\tcin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r;\n\tif(l !\u003d -r || r % 2)\n\t\tcout \u0026lt;\u0026lt; \u0026quot;0\u0026quot;;\n\telse {\n\t\tlong long ans \u003d 1;\n\t\tfor(int i \u003d 1; i \u0026lt; r; i +\u003d 2)\n\t\t\tans \u003d ans * 2 * i % mod;\n\t\tcout \u0026lt;\u0026lt; ans;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eFirst of all, g(0) \u003d 0. \u003c/p\u003e\u003cp\u003eSince g(g(x)) \u003d -x then using this condition, g(g(g(0))) \u003d -g(0) if we expand 2 outer g\u0027s and g(g(g(0))) \u003d g(0) if we expand 2 inner g\u0027s. Thus, if g(0) \u003d -g(0) then g(0) \u003d 0.\u003c/p\u003e\u003cp\u003eNow, let g(a) \u003d b then g(b) \u003d g(g(a)) \u003d -a, similarly g(-a) \u003d g(g(b)) \u003d -b and g(-b) \u003d g(g(-a)) \u003d a. Thus we get {a, b, -a, -b}, that is we need to divide the given integers into such groups.\u003c/p\u003e\u003cp\u003eTherefore, if r !\u003d -l, then answer is zero, as we need both positive and negative of a number. \u003c/p\u003e\u003cp\u003eAlso, if r is odd, then answer is zero, as we need to divide into groups with exactly 2 positive and their negative integers. By using combinatorics, we can get the answer as follows: ** yet to write further**\u003c/p\u003e\u003ch2\u003eProblem C\u003c/h2\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\t#include \u0026lt;bits/stdc++.h\u0026gt;\n\tusing namespace std;\n\n\tconst int MAXN \u003d 300000;\n\tconst int MO \u003d 1e9;\n\ttypedef long long ll;\n\tll n;\n\tpair\u0026lt;ll, ll\u0026gt; p[MAXN + 10];\n\n\tbool cmp (pair\u0026lt;ll, ll\u0026gt; a, pair\u0026lt;ll, ll\u0026gt; b) {\n\t\treturn a.first * b.second \u0026lt; a.second * b.first;\n\t}\n    \n\tint main() {\n        \n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\t\tassert(n \u0026gt;\u003d 1 \u0026amp;\u0026amp; n \u0026lt;\u003d 300000);\n\t\tfor(int i \u003d 0; i \u0026lt; n; i++) {\n\t\t\tint a, b, c; \n\t\t\tscanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;a, \u0026amp;b, \u0026amp;c);\n\t\t\tassert(a \u0026gt;\u003d -MO \u0026amp;\u0026amp; a \u0026lt;\u003d MO);\n\t\t\tassert(b \u0026gt;\u003d -MO \u0026amp;\u0026amp; b \u0026lt;\u003d MO);\n\t\t\tassert(c \u0026gt;\u003d -MO \u0026amp;\u0026amp; c \u0026lt;\u003d MO);\n\t\t\tp[i] \u003d make_pair(a, b);\n\t\t}\n\n\t\tsort(p, p + n, cmp);\n\n\t\tll l \u003d 0, r \u003d 0;\n\t\tll ans \u003d 0;\n\n\t\tfor(int i \u003d 0; i \u0026lt; n; ++i) {\n\t\t\twhile(cmp(p[l], p[i]))\n\t\t\t\t++l;  \t\t\t\t\t\t\t\t\t\n\t\t\twhile(r \u0026lt; n \u0026amp;\u0026amp; !cmp(p[i], p[r])) \n\t\t\t\t++r;\n\t\t\tans +\u003d l * (n - r);\n\t\t}\n\n\t\tprintf(\u0026quot;%lld\\n\u0026quot;, ans);\n\n\t\treturn 0;\n\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eTo find all triangles, we need to find number of ways to select 3 lines such that no 2 of them have same slope.\u003c/p\u003e\u003cp\u003eWe can do this counting, by sorting all the lines by their slope. Now let the slope of 3 lines that we select be m1, m2 and m3, such that m1 \u0026lt; m2 \u0026lt; m3.\u003c/p\u003e\u003cp\u003eSo we iterate on the 2nd line, that has slope m2 and for each such line, add the possible ways for selecting m1(\u0026lt;m2) and m3(\u0026gt;m2) ways.\u003c/p\u003e\u003ch2\u003eProblem D\u003c/h2\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\n#define pb push_back\n\ntypedef long long ll ;\n\nconst int mod \u003d 1e9 + 7 ;\nll powmod(ll a,ll b) {ll res\u003d1;if(a\u0026gt;\u003dmod)a%\u003dmod;for(;b;b\u0026gt;\u0026gt;\u003d1){if(b\u0026amp;1)res\u003dres*a;if(res\u0026gt;\u003dmod)res%\u003dmod;a\u003da*a;if(a\u0026gt;\u003dmod)a%\u003dmod;}return res;}\n\nconst int maxn \u003d 100010;\nconst int inf \u003d INT_MAX;\n\nbool p[1000000 + 5];\nvector\u0026lt;ll\u0026gt; prime;\n\nll f(ll a, ll b, ll n)\n{\n\tll ret \u003d 1;\n\twhile(1) {\n\t\tret \u003d ret * n;\n\t\tif( (a - 1) / ret * ret + ret \u0026gt; b)\n\t\t\tbreak;\n\t}\n\tret \u003d ret / n;\n\treturn ret;\n}\nint main() {\n\tll n, k;\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k;\n\tfor(int i \u003d 2; i \u0026lt;\u003d 1000; i++) {\n\t\tif(p[i])\n\t\t\tcontinue;\n\t\tfor(int j \u003d i * i; j \u0026lt;\u003d 1000000; j +\u003d i)\n\t\t\tp[j] \u003d 1;\n\t}\n\tfor(int i \u003d 2; i \u0026lt;\u003d 1000000; i++)\n\t\tif(p[i] \u003d\u003d 0)\n\t\t\tprime.pb(i);\n\tll ans \u003d powmod(n + 1, mod - 2);\n\tfor(int i \u003d 0; i \u0026lt; prime.size(); i++) {\n\t\tans \u003d ans * f(n + 1 - k, n + 1, prime[i]);\n\t\tif(ans \u0026gt;\u003d mod)\n\t\t\tans %\u003d mod;\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eSince C(n, i + 1) \u003d C(n, i) * (n — i) / (i + 1). \u003cbr /\u003e We can iterate on i from 1 to k, and keep some table to store the prime factorisation of each C(n, i).\u003c/p\u003e\u003cp\u003eThen we can know the maximum power of each prime that occured and thus their product will give us the required LCM.\u003cbr /\u003e Another solution for this problem can be to use a mathematical identity \u003cbr /\u003e  Let X be the required answer, X \u003d lcm { C(n, 0), C(n, 1), ...C(n, k)} % mod \u003cbr /\u003e then (n + 1) * X \u003d lcm(n+1, n, n — 1, ..., n + 1 — k), \u003cbr /\u003e for proof of above identity \u003ca href\u003d\"http://math.stackexchange.com/questions/1442/is-there-a-direct-proof-of-this-lcm-identity\"\u003esee this\u003c/a\u003e\u003cbr /\u003e So now all we need is to find the lcm of (n + 1 — k, n + 1 — k + 1, ...n-1, n, n + 1) \u003cbr /\u003e We can do this by iterating over all the primes and then iterating on powers from 1 till the smallest power that is not divisible is found in this range.\u003c/p\u003e\u003ch2\u003eProblem E\u003c/h2\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I \u003d 0; I \u0026lt; (N); ++I)\n#define REPP(I, A, B) for (int I \u003d (A); I \u0026lt; (B); ++I)\n#define RI(X) scanf(\u0026quot;%d\u0026quot;, \u0026amp;(X))\n#define RII(X, Y) scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;(X), \u0026amp;(Y))\n#define RIII(X, Y, Z) scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;(X), \u0026amp;(Y), \u0026amp;(Z))\n#define DRI(X) int (X); scanf(\u0026quot;%d\u0026quot;, \u0026amp;X)\n#define DRII(X, Y) int X, Y; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;X, \u0026amp;Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;X, \u0026amp;Y, \u0026amp;Z)\n#define RS(X) scanf(\u0026quot;%s\u0026quot;, (X))\n#define CASET int ___T, case_n \u003d 1; scanf(\u0026quot;%d \u0026quot;, \u0026amp;___T); while (___T-- \u0026gt; 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair\u0026lt;int,int\u0026gt;\n#define VI vector\u0026lt;int\u0026gt;\n#define VPII vector\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt;\n#define PLL pair\u0026lt;long long,long long\u0026gt;\n#define VPLL vector\u0026lt;pair\u0026lt;long long,long long\u0026gt; \u0026gt;\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD \u003d 1e9+7;\nconst int SIZE \u003d 2e5+10;\nstruct Union_Find{\n    int d[SIZE],num[SIZE];\n    void init(int n){\n        REP(i,n)d[i]\u003di,num[i]\u003d1;\n    }\n    int find(int x){\n        return (x!\u003dd[x])?(d[x]\u003dfind(d[x])):x;\n    }\n    bool uu(int x,int y){\n        x\u003dfind(x);\n        y\u003dfind(y);\n        if(x\u003d\u003dy)return 0;\n        if(num[x]\u0026gt;num[y])swap(x,y);\n        num[y]+\u003dnum[x];\n        d[x]\u003dy;\n        return 1;\n    }\n}U;\nint n,m;\nstruct EDGE{\n    int u,v,a,b;\n    EDGE(int _u\u003d0,int _v\u003d0,int _a\u003d0,int _b\u003d0):u(_u),v(_v),a(_a),b(_b){}\n    bool operator\u0026lt;(const EDGE\u0026amp; e2){return a\u0026lt;e2.a;}\n}e[SIZE];\nstruct data{\n    int x,y;\n    LL v;\n    data(int _x\u003d0,int _y\u003d0,LL _v\u003d0):x(_x),y(_y),v(_v){}\n    bool operator\u0026lt;(const data\u0026amp; b)const{\n        return v\u0026lt;b.v;\n    }\n}e2[SIZE];\nLL mst(LL x){\n    REP(i,m){\n        e2[i]\u003ddata(e[i].u,e[i].v,e[i].a*x+e[i].b);\n    }\n    sort(e2,e2+m);\n    int r\u003dn-1;\n    U.init(n);\n    LL res\u003d0;\n    REP(i,m){\n        if(U.uu(e2[i].x,e2[i].y)){\n            r--;\n            res+\u003de2[i].v;\n            if(!r)break;\n        }\n    }\n    return res;\n}\nint main(){\n    RII(n,m);\n    REP(i,m){\n        RII(e[i].u,e[i].v);\n        e[i].u--;e[i].v--;\n        RII(e[i].a,e[i].b);\n    }\n    int ll\u003d-100000000,rr\u003d100000000;\n    LL ma;\n    while(ll\u0026lt;rr){\n        int mm1\u003dll+(rr-ll)/2;\n        int mm2\u003dmm1+1;\n        LL v1\u003dmst(mm1);\n        LL v2\u003dmst(mm2);\n        ma\u003dmax(v1,v2);\n        if(v1\u0026lt;v2)ll\u003dmm2;\n        else rr\u003dmm1;\n    }\n    int med\u003dll;\n    DRI(Q);\n    while(Q--){\n        DRII(t1,t2);\n        if(t1\u0026lt;\u003dmed\u0026amp;\u0026amp;med\u0026lt;\u003dt2)printf(\u0026quot;%I64d\\n\u0026quot;,ma);\n        else if(med\u0026lt;\u003dt1)printf(\u0026quot;%I64d\\n\u0026quot;,mst(t1));\n        else printf(\u0026quot;%I64d\\n\u0026quot;,mst(t2));\n    }\n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eA suboptimal solution first.\u003c/p\u003e\u003cp\u003eLet us first look at the algorithm for finding Minimum Spanning tree. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eWe may observe that if the ordering of edges, when sorted by weights, does not change, then the minimum spanning tree remains to be unchanged i.e. the edges in MST remain to be same, even if we increase/decrease the edge weights.\u003c/p\u003e\u003cp\u003eSo, if we considered all the pairs of edges, found the time when their edge weights become equal, then one of the edge weight becomes larger than the other one, forever, as they are linear functions of time. \u003c/p\u003e\u003cp\u003eOf course, in some cases, if they are identical, then always same.\u003c/p\u003e\u003cp\u003eNow, sort these O(m^2) times of intersections, we can say that minimum spanning tree between any of the two adjacent times, remains unchanged.\u003cbr /\u003e Thus we can find the MSTs for each of these times and answer the queries.\u003cbr /\u003e This will certainly TLE, O(m^3 log n).\u003cbr /\u003e The optimal solution uses binary search and attains following complexity.\u003cbr /\u003e  precalculation:(O(log 10^8 * m log(m))) \u003cbr /\u003e each query:O(m log(m))\u003cbr /\u003e ** optimal solution updated ** \u003cbr /\u003e The sum of edge cost of every possible spaning tree is a linear function for t. So the MST function is a concave function. For solving this problem, we precalculate the highest position of the MST function by ternary search in range [-\u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e8\u003c/sup\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e8\u003c/sup\u003e\u003c/span\u003e]. The time complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(10\u003csup class\u003d\"upper-index\"\u003e8\u003c/sup\u003e) × \u003ci\u003em\u003c/i\u003e × \u003ci\u003elog\u003c/i\u003e(\u003ci\u003em\u003c/i\u003e))\u003c/span\u003e. After finishing this step, we get the maximum MST value V_{max} where t is in range [$-10^8$, \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e8\u003c/sup\u003e\u003c/span\u003e] and let such \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLet the MST value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is mst(x).\u003c/p\u003e\u003cp\u003eFor each query, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e1\u003c/sub\u003e ≤ \u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e2\u003c/sub\u003e\u003c/span\u003e, the answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e2\u003c/sub\u003e ≤ \u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, the answer if mst(T_{i2}). Otherwise, the answer is mst(T_{i1}).\u003c/p\u003e\u003c/div\u003e","tags":["weekly training farm","#editorial","discussion"]}}