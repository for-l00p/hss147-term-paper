{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1484764538,"rating":0,"authorHandle":"maximumSHOT","modificationTimeSeconds":1484764538,"id":49853,"title":"\u003cp\u003eРазбор задач. День 3.\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eВ третий день было проведено зеркало реального тура 2013-2014 Всероссийской олимпиады школьников по информатике, регионального этапа, 1 тура.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://neerc.ifmo.ru/school/archive/2013-2014/ru-olymp-regional-2014-solutions.pdf\"\u003eСсылка на официальный разбор!!!\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003ePOBEDA-2014\u003c/code\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eАвторское решение\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;math.h\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n\n#define ALL(x) (x).begin(), (x).end()\n#define mp make_pair\n#define vec vector\n\ntypedef long long LL;\ntypedef unsigned long long ull;\ntypedef long double LD;\n\nconst LL inf \u003d 1000000000;\nconst LL inf64 \u003d inf * inf;\nconst double pi \u003d acos(-1.0);\n\nLL Abs(LL x) {return (x \u0026gt;\u003d 0?x : -x);}\n\nusing namespace std;\n\nbool solve()\n{\n    ifstream fin(\u0026quot;pobeda.in\u0026quot;);\n    ofstream fout(\u0026quot;pobeda.out\u0026quot;);\n\n    LL a1, a2, a3, a4, c, p;\n\n    fin \u0026gt;\u0026gt; a1 \u0026gt;\u0026gt; a2 \u0026gt;\u0026gt; a3 \u0026gt;\u0026gt; a4;\n    \n    c \u003d min(a1, a2) + min(a3, a4);\n\n    LL l \u003d 0, r \u003d inf * 3, mid;\n\n    while(r - l \u0026gt; 1)\n    {\n        mid \u003d (l + r) \u0026gt;\u0026gt; 1;\n        if(mid * mid \u0026gt; c) r \u003d mid - 1;\n        else l \u003d mid;\n    }\n\n    if(r * r \u0026lt;\u003d c) p \u003d r;\n    else p \u003d l;\n\n    fout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0027\\n\u0027;\n\n    return true;\n}\n    \nint main()\n{\n    //while(solve());   \n    solve();\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003eСписок школ\u003c/code\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eАвторское решение\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;math.h\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n\n#define ALL(x) (x).begin(), (x).end()\n#define mp make_pair\n#define vec vector\n\ntypedef long long LL;\ntypedef unsigned long long ull;\ntypedef long double LD;\n\nconst LL inf \u003d 1000000000;\nconst LL inf64 \u003d inf * inf;\nconst double pi \u003d acos(-1.0);\n\nLL Abs(LL x) {return (x \u0026gt;\u003d 0?x : -x);}\n\nusing namespace std;\n\nbool solve()\n{\n    ifstream fin(\u0026quot;schools.in\u0026quot;);\n    ofstream fout(\u0026quot;schools.out\u0026quot;);\n\n    int n;\n    fin \u0026gt;\u0026gt; n;\n    string a, b \u003d \u0026quot;\u0026quot;;\n    map\u0026lt;string, int\u0026gt; C;\n    vec\u0026lt;string\u0026gt; ans;\n\n    getline(fin, a);\n    for(int i(0);i \u0026lt; n;i++)\n    {\n        getline(fin, a);\n        b \u003d \u0026quot;\u0026quot;;\n\n        for(int j(0);j \u0026lt; (int)a.size();j++) if(a[j] \u0026gt;\u003d \u00270\u0027 \u0026amp;\u0026amp; a[j] \u0026lt;\u003d \u00279\u0027) b +\u003d a[j];\n        C[b]++;\n    }\n\n    for(map\u0026lt;string, int\u0026gt;::iterator i \u003d C.begin();i !\u003d C.end();i++)\n    {\n        if(i-\u0026gt;second \u0026gt; 5) continue;\n        ans.push_back(i-\u0026gt;first);\n    }\n\n    fout \u0026lt;\u0026lt; (int)ans.size() \u0026lt;\u0026lt; \u0027\\n\u0027;\n\n    for(int i(0);i \u0026lt; (int)ans.size();i++) fout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0027\\n\u0027;\n\n    return true;\n}\n    \nint main()\n{\n    //while(solve());   \n    solve();\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003eМежрегиональная олимпиада\u003c/code\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eАвторское решение\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;math.h\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;list\u0026gt;\n\n//#include \u0026lt;conio.h\u0026gt;\n\n#define ALL(x) (x).begin(), (x).end()\n#define mp make_pair\n#define vec vector\n#define deb(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026quot; \u003d \u0026quot; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0027\\n\u0027;\n\ntypedef unsigned long long ull;\ntypedef long double LD;\ntypedef long long LL;\n\nconst LL inf \u003d 1000000000ll;\nconst LL inf64 \u003d inf * inf;\nconst LL base \u003d inf + 7;\nconst double pi \u003d acos(-1.0);\n\nusing namespace std;\n\ntemplate\u0026lt;typename T, typename P\u0026gt;\nconst ostream \u0026amp; operator \u0026lt;\u0026lt; (ostream \u0026amp; os, const pair\u0026lt;T, P\u0026gt; \u0026amp; a) {\n\tos.precision(10);\n\tos \u0026lt;\u0026lt; fixed;\n\tos \u0026lt;\u0026lt; a.first;\n\tos \u0026lt;\u0026lt; \u0027 \u0027;\n\tos \u0026lt;\u0026lt; a.second;\n\tos \u0026lt;\u0026lt; \u0027\\n\u0027;\n\treturn os;\n}\n\nstruct problem {\n\tLL s, t, c;\n\tint id;\n\n\tproblem() {\n\t\ts \u003d t \u003d c \u003d id \u003d 0;\n\t}\n\n\tproblem(LL S, LL T, LL C, int ID) {\n\t\ts \u003d S, t \u003d T, c \u003d C, id \u003d ID;\n\t}\n\n\tvoid read(int iD) {\n\t\tscanf(\u0026quot;%I64d %I64d %I64d\u0026quot;, \u0026amp;s, \u0026amp;t, \u0026amp;c);\n\t\tid \u003d iD;\n\t}\n\n\tbool operator \u0026lt; (const problem \u0026amp; b) {\n\t\treturn (s + t \u0026lt; b.s + b.t);\n\t}\n};\n\nbool solve()\n{\t\n\tfreopen(\u0026quot;olympiad.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\tfreopen(\u0026quot;olympiad.out\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n\tint n;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\n\tvec\u0026lt; problem \u0026gt; a(n + 1);\n\tfor(int i(1);i \u0026lt;\u003d n;i++) a[i].read(i);\n\tsort(a.begin() + 1, a.end());\n\n\tvec\u0026lt; LL \u0026gt; dp(n + 1);\n\tvec\u0026lt; int \u0026gt; from(n + 1, -1);\n\tvec\u0026lt; pair\u0026lt;LL, int\u0026gt; \u0026gt; maxDp(n + 1, mp(-inf64, -1));\n\n\tdp[1] \u003d a[1].c;\n\tmaxDp[1] \u003d mp(dp[1], 1);\n\n\tfor(int i(2);i \u0026lt;\u003d n;i++) {\n\t\tint l, r;\n\t\tl \u003d a[i].s, r \u003d a[i].s + a[i].t;\n\t\tLL cost \u003d a[i].c;\n\n\t\tint bl, br, bm, bp;\n\t\tbl \u003d 1, br \u003d i - 1;\n\n\t\twhile(br - bl \u0026gt; 1) {\n\t\t\tbm \u003d (bl + br) \u0026gt;\u0026gt; 1;\n\t\t\tif(a[bm].s + a[bm].t \u0026lt;\u003d l) bl \u003d bm;\n\t\t\telse br \u003d bm - 1;\n\t\t}\n\n\t\tif(a[br].s + a[br].t \u0026lt;\u003d l) bp \u003d br;\n\t\telse if(a[bl].s + a[bl].t \u0026lt;\u003d l) bp \u003d bl;\n\t\telse bp \u003d -1;\n\n\t\tif(bp \u003d\u003d -1) {\n\t\t\tdp[i] \u003d cost;\n\t\t\tfrom[i] \u003d -1;\n\t\t}else {\n\t\t\tdp[i] \u003d cost + maxDp[bp].first;\n\t\t\tfrom[i] \u003d maxDp[bp].second;\n\t\t}\n\n\t\tmaxDp[i] \u003d max(maxDp[i - 1], mp(dp[i], i));\n\t}\n\n\tLL maxValue \u003d maxDp[n].first;\n\tint id \u003d maxDp[n].second;\n\n\tvec\u0026lt; int \u0026gt; way;\n\n\twhile(id !\u003d -1) {\n\t\tway.push_back(id);\n\t\tid \u003d from[id];\n\t}\n\n\treverse(ALL(way));\n\t\n\tint sz \u003d (int)way.size();\n\n\tprintf(\u0026quot;%I64d\\n%d\\n\u0026quot;, maxValue, sz);\n\n\tfor(int i(0);i \u0026lt; sz;i++) printf(\u0026quot;%d \u0026quot;, a[way[i]].id);\n\tputs(\u0026quot;\u0026quot;);\n\n\treturn true;\n}   \n\nint main() \n{\n\t//while(solve());\n\tsolve();\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003eДом Мэра\u003c/code\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eАвторское решение\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\n#define vec vector\n#define ALL(x) (x).begin(), (x).end()\n\ntypedef long long ll;\ntypedef pair\u0026lt; int, int \u0026gt; pii;\ntypedef pair\u0026lt; ll, ll \u0026gt; pll;\ntypedef long double ld;\n\nint const inf \u003d 1000 * 1000 * 1000;\nll const inf64 \u003d 1ll * inf * inf;\n\nstruct pt {\n    int x, y;\n    pt() : x(0), y(0) { }\n    pt(int x, int y) : x(x), y(y) { }\n    void read() {\n        scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;x, \u0026amp;y);\n    }\n};\n\ninline void update_rectangle(pair\u0026lt; pt, pt \u0026gt; \u0026amp; r) {\n    if(r.first.x \u0026gt; r.second.x) swap(r.first.x, r.second.x);\n    if(r.first.y \u0026gt; r.second.y) swap(r.first.y, r.second.y);\n}\n\nint const N \u003d 100005;\nint const K \u003d 15;\n\nint n, k;\npair\u0026lt; pt, pt \u0026gt; rec[N];\n\nint get_up(pt point) {\n    int res \u003d inf;\n    for(int i \u003d 1;i \u0026lt;\u003d n;i++) {\n        if(rec[i].first.x \u0026lt; point.x \u0026amp;\u0026amp; point.x \u0026lt; rec[i].second.x \u0026amp;\u0026amp;\n                rec[i].first.y \u0026gt;\u003d point.y) {\n            res \u003d min(res, rec[i].first.y);\n        }\n    }\n    return res;\n}\n\nint get_down(pt point) {\n    int res \u003d -inf;\n    for(int i \u003d 1;i \u0026lt;\u003d n;i++) {\n        if(rec[i].first.x \u0026lt; point.x \u0026amp;\u0026amp; point.x \u0026lt; rec[i].second.x \u0026amp;\u0026amp;\n                rec[i].second.y \u0026lt;\u003d point.y) {\n            res \u003d max(res, rec[i].second.y);\n        }\n    }\n    return res;\n}\n\nint get_left(pt point) {\n    int res \u003d -inf;\n    for(int i \u003d 1;i \u0026lt;\u003d n;i++) {\n        if(rec[i].first.y \u0026lt; point.y \u0026amp;\u0026amp; point.y \u0026lt; rec[i].second.y \u0026amp;\u0026amp;\n                rec[i].second.x \u0026lt;\u003d point.x) {\n            res \u003d max(res, rec[i].second.x);\n        }\n    }\n    return res;\n}\n\nint get_right(pt point) {\n    int res \u003d inf;\n    for(int i \u003d 1;i \u0026lt;\u003d n;i++) {\n        if(rec[i].first.y \u0026lt; point.y \u0026amp;\u0026amp; point.y \u0026lt; rec[i].second.y \u0026amp;\u0026amp;\n                rec[i].first.x \u0026gt;\u003d point.x) {\n            res \u003d min(res, rec[i].first.x);\n        }\n    }\n    return res;\n}\n\nvoid check_y0(pt house) {\n    int lx \u003d min(0, house.x);\n    int rx \u003d max(0, house.x);\n    int ok \u003d 0;\n    for(int i \u003d 1;i \u0026lt;\u003d n;i++) {\n        if(rec[i].first.y \u0026lt; 0 \u0026amp;\u0026amp; rec[i].second.y \u0026gt; 0 \u0026amp;\u0026amp;\n                rec[i].first.x \u0026gt;\u003d lx \u0026amp;\u0026amp; rec[i].second.x \u0026lt;\u003d rx) {\n            ok \u003d 1;\n            break;\n        }\n    }\n    if(!ok) {\n        printf(\u0026quot;YES\\n1\\n0 0 %d\\n\u0026quot;, (house.x \u0026gt; 0 ? 1 : -1));\n        return;\n    }\n    int Y \u003d min( get_up(pt(0, 0)), get_up(house) );\n    vec\u0026lt; pii \u0026gt; seg;\n    for(int i \u003d 1;i \u0026lt;\u003d n;i++) {\n        if(rec[i].first.x \u0026gt;\u003d lx \u0026amp;\u0026amp; rec[i].second.x \u0026lt;\u003d rx) {\n            int ly \u003d max(0, rec[i].first.y + 1);\n            int ry \u003d min(Y, rec[i].second.y - 1);\n            if(ly \u0026lt;\u003d ry) {\n                seg.push_back( make_pair(ly, ry) );\n            }\n        }\n    }\n    sort(ALL(seg));\n    int can_y \u003d -1;\n    for(int i \u003d 0;i + 1 \u0026lt; (int)seg.size();i++) {\n        if(seg[i].second + 1 \u0026lt; seg[i + 1].first) {\n            can_y \u003d seg[i].second + 1;\n            break;\n        }\n    }\n    if(can_y \u003d\u003d -1 \u0026amp;\u0026amp; seg.back().second + 1 \u0026lt;\u003d Y) {\n        can_y \u003d seg.back().second + 1;\n    }\n    if(can_y \u003d\u003d -1) {\n        printf(\u0026quot;NO\\n\u0026quot;);\n        return;\n    }\n    printf(\u0026quot;YES\\n2\\n\u0026quot;);\n    printf(\u0026quot;0 %d %d\\n\u0026quot;, can_y, (house.x \u0026gt; 0 ? 1 : -1));\n    printf(\u0026quot;%d %d %d\\n\u0026quot;, house.x, can_y, (house.x \u0026gt; 0 ? 1 : -1));\n}\n\nvoid check_x0(pt house) {\n    if(house.y \u0026lt; 0) {\n        printf(\u0026quot;NO\\n\u0026quot;);\n        return;\n    }\n    for(int i \u003d 1;i \u0026lt;\u003d n;i++) {\n        if( rec[i].first.x \u0026lt; 0 \u0026amp;\u0026amp; rec[i].second.x \u0026gt; 0 \u0026amp;\u0026amp;\n            rec[i].first.y \u0026gt;\u003d 0 \u0026amp;\u0026amp; rec[i].second.y \u0026lt;\u003d house.y\n        ) {\n            printf(\u0026quot;NO\\n\u0026quot;);\n            return;\n        }\n    }\n    printf(\u0026quot;YES\\n0\\n\u0026quot;);\n}\n\nvoid check(pt house) {\n    if(house.y \u003d\u003d 0) {\n        check_y0(house);\n        return;\n    }\n    if(house.x \u003d\u003d 0) {\n        check_x0(house);\n        return;\n    }\n    if(house.y \u0026gt; 0) {\n        int max_y \u003d get_up(pt(0, 0));\n        int min_y \u003d get_down(house);\n\n        if(max_y \u0026lt; min_y) {\n            printf(\u0026quot;NO\\n\u0026quot;);\n            return;\n        }\n\n        {\n            int Ly \u003d max(0, min_y);\n            int Ry \u003d min(max_y, house.y);\n            int Lx \u003d min(0, house.x);\n            int Rx \u003d max(0, house.x);\n            vec\u0026lt; pii \u0026gt; seg;\n            for(int i \u003d 1;i \u0026lt;\u003d n;i++) {\n                if(rec[i].first.x \u0026gt;\u003d Lx \u0026amp;\u0026amp; rec[i].second.x \u0026lt;\u003d Rx) {\n                    int ly, ry;\n                    ly \u003d max(Ly, rec[i].first.y + 1);\n                    ry \u003d min(Ry, rec[i].second.y - 1);\n                    if(ly \u0026lt;\u003d ry) {\n                        seg.push_back( make_pair(ly, ry) );\n                    }\n                }\n            }\n            sort(ALL(seg));\n            int can_y \u003d -1;\n            if(seg.empty() || seg.front().first \u0026gt; Ly) can_y \u003d Ly;\n            else {\n                for(int i \u003d 0;i + 1 \u0026lt; (int)seg.size();i++) {\n                    if(seg[i].second + 1 \u0026lt; seg[i + 1].first) {\n                        can_y \u003d seg[i].second + 1;\n                        break;\n                    }\n                }\n                if(can_y \u003d\u003d -1 \u0026amp;\u0026amp; seg.back().second + 1 \u0026lt;\u003d Ry) {\n                    can_y \u003d seg.back().second + 1;\n                }\n            }\n            if(can_y !\u003d -1) {\n                printf(\u0026quot;YES\\n2\\n\u0026quot;);\n                printf(\u0026quot;0 %d %d\\n\u0026quot;, can_y, house.x \u0026gt; 0 ? 1 : -1);\n                printf(\u0026quot;%d %d %d\\n\u0026quot;, house.x, can_y, house.x \u0026gt; 0 ? -1 : 1);\n                return;\n            }\n        }\n\n        max_y \u003d min(max_y, get_up(house));\n\n        if(max_y \u0026lt; house.y) {\n            printf(\u0026quot;NO\\n\u0026quot;);\n            return;\n        }\n\n        {\n            int Ly \u003d house.y;\n            int Ry \u003d max_y;\n            int Lx \u003d min(0, house.x);\n            int Rx \u003d max(0, house.x);\n            vec\u0026lt; pii \u0026gt; seg;\n            for(int i \u003d 1;i \u0026lt;\u003d n;i++) {\n                if(rec[i].first.x \u0026gt;\u003d Lx \u0026amp;\u0026amp; rec[i].second.x \u0026lt;\u003d Rx) {\n                    int ly, ry;\n                    ly \u003d max(Ly, rec[i].first.y + 1);\n                    ry \u003d min(Ry, rec[i].second.y - 1);\n                    if(ly \u0026lt;\u003d ry) {\n                        seg.push_back( make_pair(ly, ry) );\n                    }\n                }\n            }\n            sort(ALL(seg));\n\n            int can_y \u003d -1;\n            if(seg.empty() || seg.front().first \u0026gt; Ly) can_y \u003d Ly;\n            else {\n                for(int i \u003d 0;i + 1 \u0026lt; (int)seg.size();i++) {\n                    if(seg[i].second + 1 \u0026lt; seg[i + 1].first) {\n                        can_y \u003d seg[i].second + 1;\n                        break;\n                    }\n                }\n                if(can_y \u003d\u003d -1 \u0026amp;\u0026amp; seg.back().second + 1 \u0026lt;\u003d Ry) {\n                    can_y \u003d seg.back().second + 1;\n                }\n            }\n\n            if(can_y !\u003d -1) {\n                printf(\u0026quot;YES\\n2\\n\u0026quot;);\n                printf(\u0026quot;0 %d %d\\n\u0026quot;, can_y, house.x \u0026gt; 0 ? 1 : -1);\n                printf(\u0026quot;%d %d %d\\n\u0026quot;, house.x, can_y, house.x \u0026gt; 0 ? 1 : -1);\n                return;\n            }\n        }\n        printf(\u0026quot;NO\\n\u0026quot;);\n    }else {\n        int Y \u003d min(get_up(pt(0, 0)), get_up(house));\n        if(Y \u0026lt; 0) {\n            printf(\u0026quot;NO\\n\u0026quot;);\n            return;\n        }\n\n        {\n            int Ly \u003d 0;\n            int Ry \u003d Y;\n            int Lx \u003d min(0, house.x);\n            int Rx \u003d max(0, house.x);\n            vec\u0026lt; pii \u0026gt; seg;\n            for(int i \u003d 1;i \u0026lt;\u003d n;i++) {\n                if(rec[i].first.x \u0026gt;\u003d Lx \u0026amp;\u0026amp; rec[i].second.x \u0026lt;\u003d Rx) {\n                    int ly, ry;\n                    ly \u003d max(Ly, rec[i].first.y + 1);\n                    ry \u003d min(Ry, rec[i].second.y - 1);\n                    if(ly \u0026lt;\u003d ry) {\n                        seg.push_back( make_pair(ly, ry) );\n                    }\n                }\n            }\n            sort(ALL(seg));\n            int can_y \u003d -1;\n            if(seg.empty() || seg.front().first \u0026gt; Ly) can_y \u003d Ly;\n            else {\n                for(int i \u003d 0;i + 1 \u0026lt; (int)seg.size();i++) {\n                    if(seg[i].second + 1 \u0026lt; seg[i + 1].first) {\n                        can_y \u003d seg[i].second + 1;\n                        break;\n                    }\n                }\n                if(can_y \u003d\u003d -1 \u0026amp;\u0026amp; seg.back().second + 1 \u0026lt;\u003d Ry) {\n                    can_y \u003d seg.back().second + 1;\n                }\n            }\n            if(can_y !\u003d -1) {\n                printf(\u0026quot;YES\\n2\\n\u0026quot;);\n                printf(\u0026quot;0 %d %d\\n\u0026quot;, can_y, house.x \u0026gt; 0 ? 1 : -1);\n                printf(\u0026quot;%d %d %d\\n\u0026quot;, house.x, can_y, house.x \u0026gt; 0 ? 1 : -1);\n                return;\n            }\n        }\n        printf(\u0026quot;NO\\n\u0026quot;);\n    }\n}\n\nint main() {\n\n    freopen(\u0026quot;majorhouse.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n    freopen(\u0026quot;majorhouse.out\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n    scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;n, \u0026amp;k);\n\n    for(int i \u003d 1;i \u0026lt;\u003d n;i++) {\n        rec[i].first.read();\n        rec[i].second.read();\n        update_rectangle(rec[i]);\n    }\n\n    for(int i \u003d 0;i \u0026lt; k;i++) {\n        pt house;\n        house.read();\n        check(house);\n    }\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}