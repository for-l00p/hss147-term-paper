{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1520661072,"rating":0,"authorHandle":"xzm2001","modificationTimeSeconds":1520661323,"id":58274,"title":"\u003cp\u003eTest Round #2 题解\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e所有题目与题解均来自于互联网\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eA-数论\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003e打表发现，答案就是 n*m mod p。\u003c/p\u003e\u003cp\u003e其实，原式的物理意义，就是从坐标原点（0,0），用每一种合法的斜率，穿过坐标[1~n,1~m]的方阵中的整点的个数，总数即n*m。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eB-摘Galo\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003e题目对取 Galo 的要求，即不能同时取一对祖先和子孙。我们可以在 DFS 序上 DP。对于选择取 Galo[i]的决策，即选择了 DFS 序上i 号节点的子树所对应的区间。只要选择的区间不相交、不重复，则是一个合法的取法。这样，题目就成了一个区间覆盖 DP 问题，复杂度 O(n*k)。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC-石头剪刀布\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003e暴力列出两人200次出拳结果然后进行比较即可。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eD-吃草\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003e题目可以看作是，把所有的区间分成很多个集合，对于一个集合中的每一个区间，要有一个公共点。第一问要求划分的集合数最少，第二问要求使选择的点的总代价最小。\u003c/p\u003e\u003cp\u003e对于第一问，只需要将区间按 L[i]排序，按顺序扫过每个区间，贪心地把区间放到集合中（能加入就加入，不能加入就新建），即为最优方案。\u003c/p\u003e\u003cp\u003e对于第二问，如果我们确定好了选择的 ans1 个整点，则一个区间 i，应该被划分到距离区间中点（(L[i]+R[i])/2）最近的一个所选点所对应的集合中。这样，我们只要以“到哪里为止，选择了多少个点”为状态，运用决策单调思想，采用线段树或者单调队列进行转移即可。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}