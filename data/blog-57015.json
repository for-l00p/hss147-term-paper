{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1515522578,"rating":5,"authorHandle":"mouse_wireless","modificationTimeSeconds":1515522578,"id":57015,"title":"\u003cp\u003eRegular Expression problem -- better solution?\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI\u0027ve recently come across the following problem in a real life scenario:\u003c/p\u003e\u003cp\u003eYou are given a regular expression with two special characters: \u003ccode\u003e*\u003c/code\u003e matches any sequence of characters (including the empty sequence) and \u003ccode\u003e?\u003c/code\u003e matches any one character.\u003c/p\u003e\u003cp\u003eFor example, \u003ccode\u003ea?b\u003c/code\u003e matches \u003ccode\u003eacb\u003c/code\u003e, but it does not match \u003ccode\u003eabc\u003c/code\u003e, \u003ccode\u003eaccb\u003c/code\u003e or \u003ccode\u003eab\u003c/code\u003e. \u003ccode\u003ea*?b\u003c/code\u003e however does match \u003ccode\u003eaccb\u003c/code\u003e. \u003ccode\u003eabc*f?h\u003c/code\u003e matches \u003ccode\u003eabcdefgh\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eYou have to write a program that checks if a pattern and a string match.\u003c/p\u003e\u003cp\u003eObviously, we can write an \u003ccode\u003eO(n^2)\u003c/code\u003e algorithm which looks like this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ebool matches(const char *pat, const char *s) {\n  if (*pat \u003d\u003d 0)\n    return (*s \u003d\u003d 0);\n  if ((*pat \u003d\u003d \u0027?\u0027 || *pat \u003d\u003d *s) \u0026amp;\u0026amp; (*s !\u003d 0))\n    return matches(pat + 1, s + 1);\n  if (*pat \u003d\u003d \u0027*\u0027)\n    return ((*s !\u003d 0) \u0026amp;\u0026amp; matches(pat, s + 1)) || matches(pat + 1, s);\n  return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFor the scenario I have encountered, \u003ccode\u003eO(n^2)\u003c/code\u003e is more than enough, however I\u0027ve been wondering for a while if a linear time algorithm (or anyway something better than quadratic) exists. I\u0027ve been giving it some thought and can\u0027t seem to come up with anything. It looks like so it seems like some linear algorithm should exist, right?\u003c/p\u003e\u003c/div\u003e","tags":["string","regex","regexp","algorithm complexity"]}}