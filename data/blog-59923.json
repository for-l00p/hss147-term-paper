{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1528560964,"rating":9,"authorHandle":"edsomjr","modificationTimeSeconds":1528567770,"id":59923,"title":"\u003cp\u003eTópicos Especiais em Programação 2018-1 — Prova 2: Tutorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eCandies\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eBasta escolher o maior dentre os pacotes que deixam o menor resto possível. Uma maneira de fazer isto é ordenar os pacotes pela quantidade de doces e, da maior para a menor quantidade, computar os restos da divisão por M: caso o resto seja estritamente menor do que o menor resto encontrado até então, atualizar este resto e o valor associado a ele.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003ePassword\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eAs senhas que podem ser formadas correspondem aos anagramas formados pelos dígitos \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e6\u003c/sub\u003e\u003c/span\u003e. Uma maneira rápida de se resolver o problema é extrair os seis dígitos da data, formar uma string através da concatenação de todos eles, ordená-las e contar todas as possíveis permutações, usando a função \u003ccode\u003enext\\_permutation()\u003c/code\u003e do C++.\u003c/p\u003e\u003cp\u003eO número de senhas também pode ser computado diretamente: o número de permutações dos dígitos \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e6\u003c/sub\u003e\u003c/span\u003e, com possíveis repetições, é dada por\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/24/01/2401612e175a1c3885cf7c97071d31827f7d82c2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eonde \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e é o número de vezes que o dígito \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e apareceu na data de nascimento.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDebts\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eEste problema pode ser resolvido através de uma estratégia gulosa: basta ordenar as dívidas e os cheques em ordem decrescente. Começando do maior cheque, escolha a dívida de maior valor que pode ser paga com ele, remova a dívida paga (e as mais caras do que ela) e passe para o próximo cheque, até que não restem mais cheques a serem avaliados.\u003c/p\u003e\u003cp\u003eA complexidade desta solução é \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDistinct Prime Factors\u003c/strong\u003e\u003c/p\u003e\u003cp\u003ePara computar o valor de \u003cspan class\u003d\"tex-span\"\u003eω(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e de forma eficiente, podemos usar uma variante do crivo de Erastótenes, onde cada múltiplo de um primo recebe um incremento de mais um em seu total \\texttt{ps}.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003econst int MAX { 3000010 };\n\nint ps[MAX], ns[MAX];\nbitset\u0026lt;MAX\u0026gt; sieve;\n\nvoid precomp()\n{\n    sieve.set();\n\n    for (ll k \u003d 2; k \u0026lt; MAX; k +\u003d 2)\n    {\n        ++ps[k];\n        sieve[k] \u003d false;\n    }\n\n    for (ll k \u003d 3; k \u0026lt; MAX; k +\u003d 2)\n    {\n        if (sieve[k])\n        {\n            for (ll r \u003d k; r \u0026lt; MAX; r +\u003d k)\n            {\n                ++ps[r];\n                sieve[r] \u003d false;\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEsta versão do crivo tem complexidade \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eOs comandos podem ser respondidos, de maneira eficiente, usando-se uma árvore de segmentos (\\textit{Segment Tree}), cujos nós armazenam uma trinca de valores: o índice \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, o valor \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e e o número de elementos \u003cspan class\u003d\"tex-span\"\u003eω(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eNa operação de soma, é preciso atualizar o valor de \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e para \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e e também atualizar o terceiro valor para \u003cspan class\u003d\"tex-span\"\u003eω(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e. Como a atualização é pontual, não é preciso usar \\textit{lazy propagation}: os nós pais são atualizados segundo as regras descritas no texto.\u003c/p\u003e\u003cp\u003eNa operação de consulta, basta consultar o resultado dos nós que compõem o intervalo de busca, e escolher o melhor dentre eles. Cada uma das operações acima tem complexidade \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e, de modo que a solução tem complexidade \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e + \u003ci\u003eQlogN\u003c/i\u003e) \u003d \u003ci\u003eO\u003c/i\u003e((\u003ci\u003eN\u003c/i\u003e + \u003ci\u003eQ\u003c/i\u003e)\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eFinal Exam\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eHá \u003cspan class\u003d\"tex-span\"\u003e16! \u003d 20922789888000\u003c/span\u003e permutações possíveis dos alunos, o que inviabiliza uma verificação de cada uma delas. Contudo, se observarmos que muitas destas permutações levam a pareamentos equivalentes (por exemplo, as permutações 1234, 2143, 3421, etc levam ao pareamento {1, 2}, {3, 4}), podemos reduzir o número de pareamentos possíveis através destas simetrias.\u003c/p\u003e\u003cp\u003ePara explorarmos estas simetrias, devemos gerar os pareamentos com os elementos \u0026quot;à esquerda\u0026quot; do par em ordem crescente. Assim, fixando o número 1 na primeira posição, teremos \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - 1\u003c/span\u003e alunos possíveis para completar o par. Escolhido o primeiro par, o elemento à esquerda do segundo par deve ser o de menor identificador ainda não pareado. Daí teremos \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - 3\u003c/span\u003e escolhas possíveis para a segunda dupla.\u003c/p\u003e\u003cp\u003eSeguindo este raciocínio para \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 16\u003c/span\u003e, teremos $15!! \u003d 15\\times 13\\times 11 \\times \\ldots \\times 3 \\times 1 \u003d 2027025$ pares possíveis, quantia que permite a busca completa.\u003c/p\u003e\u003cp\u003eA busca pode ser acelerada usando-se a técnica da poda: armazenando em uma variável global o melhor resultado encontrado até o momento, se na escolha de uma dupla o \u003cspan class\u003d\"tex-span\"\u003eδ\u003c/span\u003e correspondente for maior ou igual ao melhor resultado, a busca pode ser interrompida, melhorando o tempo de execução.\u003c/p\u003e\u003cp\u003eExiste uma solução de programação dinâmica com máscara de \\textit{bits} para este problema.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eFactorials\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eEste problema pode ser resolvido em duas etapas. Primeiramente, é preciso determinar a decomposição de \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e em fatores primos, o que pode ser feito com complexidade \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8e/ef/8eeff7abbcf0ace1b2efac3e2c0fc5e1908847cf.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e com o algoritmo de fatoração convencional, pois \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e14\u003c/sup\u003e\u003c/span\u003e. A fatoração de \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e segue direto da fatoração de \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, bastando multiplicar todos os expoentes por dois.\u003c/p\u003e\u003cp\u003eA segunda etapa consiste em determinar a divisibilidade de \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e!\u003c/span\u003e por \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e. Para saber se \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e divide o não \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e!\u003c/span\u003e, basta verificar se a função \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eE\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003em\u003c/i\u003e)\u003c/span\u003e é menor ou igual ao expoente de \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e na fatoração de \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e, onde \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eE\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003em\u003c/i\u003e)\u003c/span\u003e é o maior expoente \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e tal que \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e divide \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e!\u003c/span\u003e mas \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/sup\u003e\u003c/span\u003e não divide. Abaixo uma possível implementação desta função em C++:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003elong long Ep(long long n, long long p)\n{\n    long long res \u003d 0;\n\n    while (n / p)\n    {\n        res +\u003d n / p;\n        n /\u003d p;\n    }\n    \n    return res;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ePor fim, para determinar o menor \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e possível, basta fazer uma busca binária, começando em \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e \u003d 0\u003c/span\u003e (lembre que \u003cspan class\u003d\"tex-span\"\u003e0! \u003d 1\u003c/span\u003e) e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e\u003c/span\u003e (uma cota superior: efetivamente, qualquer número superior a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ekn\u003c/i\u003e\u003c/span\u003e serviria, pois \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ekE\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003en\u003c/i\u003e) ≤ \u003ci\u003eE\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003ekn\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e","tags":[]}}