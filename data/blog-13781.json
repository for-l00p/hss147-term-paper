{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1410658445,"rating":0,"authorHandle":"Renegade","modificationTimeSeconds":1410688014,"id":13781,"title":"\u003cp\u003eMy solution to Google APAC 2015 Cut Tiles\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eProblem\u003c/p\u003e\u003cp\u003eEnzo is doing renovation for his new house. The most difficult part is to buy exactly the right number of tiles. He wants N tiles of different sizes. Of course they have to be cut from the tiles he bought. All the required tiles are square. The lengths of side of the tiles are 2S1, 2S2, ..., 2SN. He can only buy a lot of tiles sized M*M, and he decides to only cut tiles parallel to their sides for convenience. How many tiles does he need to buy? Input\u003c/p\u003e\u003cp\u003eThe first line of the input gives the number of test cases: T. T lines follow. Each line start with the number N and M, indicating the number of required tiles and the size of the big tiles Enzo can buy. N numbers follow: S1, S2, ... SN, showing the sizes of the required tiles. [cut] Output\u003c/p\u003e\u003cp\u003eFor each test case, output one line containing \u0026quot;Case #x: y\u0026quot;, where x is the test case number (starting from 1) and y is the number of the big tiles Enzo need to buy. [cut] Limits\u003c/p\u003e\u003cp\u003e1 ≤ 2Sk ≤ M ≤ 2^31-1.\u003c/p\u003e\u003cp\u003eSmall dataset\u003c/p\u003e\u003cp\u003e1 ≤ T ≤ 100. 1 ≤ N ≤ 20. Large dataset\u003c/p\u003e\u003cp\u003e1 ≤ T ≤ 1000. 1 ≤ N ≤ 500. [cut]\u003c/p\u003e\u003cp\u003eSoluton: The core of this solution is : given a rectangle, add the max size tile that fits, and recurse on the remaining 2 rectangles formed. Do this till all tiles are exhausted. The rectangles are taken so as to maximize the length and breadth of each. sides[] stores the available sides. Its pretty easy actually :)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\t\tint[] sides;\n\t\tint count \u003d 0;\n\n\t\tpublic void rec(int a, int b) {\n\t\t\t//Switch sides so that a is the greater one\n\t\t\tif (a \u0026lt; b) {\n\t\t\t\tint t \u003d a;\n\t\t\t\ta \u003d b;\n\t\t\t\tb \u003d t;\n\t\t\t}\n\t\t\tif (a \u003d\u003d 0 || b \u003d\u003d 0)\n\t\t\t\treturn;\n\t\t\t//Select the max size tile that fits\n\t\t\tint max \u003d (int) (Math.log(b) / Math.log(2));\n\t\t\t\n\t\t\twhile (max \u0026gt;\u003d 0 \u0026amp;\u0026amp; sides[max] \u003d\u003d 0)\n\t\t\t\tmax--;//max size tile that is available\n\t\t\tif (max \u003d\u003d -1)\n\t\t\t\treturn;\n\t\t\tsides[max]--;//remove it\n\t\t\tcount++;\n\t\t\tint ss \u003d 1 \u0026lt;\u0026lt; max;\n\t\t\t//recurse on the remaining rectangles\n\t\t\trec(b - ss, ss);\n\t\t\trec(a - ss, b);\n\t\t}\n\n\t\tpublic int Solve() {\n\t\t\tint n \u003d ni();//input\n\t\t\tint m \u003d ni();\n\t\t\tsides \u003d new int[32];\n\t\t\tfor (int i \u003d 0; i \u0026lt; n; i++)\n\t\t\t\tsides[ni()]++;\n\t\t\tint ans \u003d 0;\n\t\t\tfor (; count \u0026lt; n; ans++) {\n\t\t\t\trec(m, m);\n\t\t\t}\n\t\t\tcount \u003d 0;\n\t\t\treturn ans;\n\n\t\t}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["apac","bin packing","recursion"]}}