{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1414588894,"rating":-47,"authorHandle":"cdexswzaq123","modificationTimeSeconds":1414589164,"id":14498,"title":"\u003cp\u003eТопологическая сортировка\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eДан ориентированный граф с n вершинами и m рёбрами. Требуется перенумеровать его вершины таким образом, чтобы каждое рёбро вело из вершины с меньшим номером в вершину с большим.\u003c/p\u003e\u003cp\u003eИными словами, требуется найти перестановку вершин (топологический порядок), соответствующую порядку, задаваемому всеми рёбрами графа.\u003c/p\u003e\u003cp\u003eТопологическая сортировка может быть не единственной (например, если граф — пустой; или если есть три такие вершины a, b, c, что из a есть пути в b и в c, но ни из b в c, ни из c в b добраться нельзя).\u003c/p\u003e\u003cp\u003eТопологической сортировки может не существовать вовсе — если граф содержит циклы (поскольку при этом возникает противоречие: есть путь и из одной вершины в другую, и наоборот).\u003c/p\u003e\u003cp\u003eРаспространённая задача на топологическую сортировку — следующая. Есть n переменных, значения которых нам неизвестны. Известно лишь про некоторые пары переменных, что одна переменная меньше другой. Требуется проверить, не противоречивы ли эти неравенства, и если нет, выдать переменные в порядке их возрастания (если решений несколько — выдать любое). Легко заметить, что это в точности и есть задача о поиске топологической сортировки в графе из n вершин.\u003c/p\u003e\u003cp\u003eАлгоритм Для решения воспользуемся обходом в глубину.\u003c/p\u003e\u003cp\u003eПредположим, что граф ацикличен, т.е. решение существует. Что делает обход в глубину? При запуске из какой-то вершины v он пытается запуститься вдоль всех рёбер, исходящих из v. Вдоль тех рёбер, концы которых уже были посещены ранее, он не проходит, а вдоль всех остальных — проходит и вызывает себя от их концов.\u003c/p\u003e\u003cp\u003eТаким образом, к моменту выхода из вызова {\\rm dfs}(v) все вершины, достижимые из v как непосредственно (по одному ребру), так и косвенно (по пути) — все такие вершины уже посещены обходом. Следовательно, если мы будем в момент выхода из {\\rm dfs}(v) добавлять нашу вершину в начало некоего списка, то в конце концов в этом списке получится топологическая сортировка.\u003c/p\u003e\u003cp\u003eЭти объяснения можно представить и в несколько ином свете, с помощью понятия \u0026quot;времени выхода\u0026quot; обхода в глубину. Время выхода для каждой вершины v — это момент времени, в который закончил работать вызов {\\rm dfs}(v) обхода в глубину от неё (времена выхода можно занумеровать от 1 до n). Легко понять, что при обходе в глубину время выхода из какой-либо вершины v всегда больше, чем время выхода из всех вершин, достижимых из неё (т.к. они были посещены либо до вызова {\\rm dfs}(v), либо во время него). Таким образом, искомая топологическая сортировка — это сортировка в порядке убывания времён выхода.\u003c/p\u003e\u003cp\u003eРеализация на С++:\u003c/p\u003e\u003cp\u003eint n; // число вершин\u003c/p\u003e\u003cp\u003evector g[MAXN]; // граф\u003c/p\u003e\u003cp\u003ebool used[MAXN];\u003c/p\u003e\u003cp\u003evector ans;\u003c/p\u003e\u003cp\u003evoid dfs (int v) {\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eused[v] \u003d true;\n\nfor (size_t i\u003d0; i\u0026lt;g[v].size(); ++i) {\n\nint to \u003d g[v][i];\n\nif (!used[to])\n\ndfs (to);\n}\nans.push_back (v);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e}\u003c/p\u003e\u003cp\u003evoid topological_sort() {\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (int i\u003d0; i\u0026lt;n; ++i)\n\nused[i] \u003d false;\n\nans.clear();\n\nfor (int i\u003d0; i\u0026lt;n; ++i)\n\nif (!used[i])\n\ndfs (i);\n\nreverse (ans.begin(), ans.end());\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e}\u003c/p\u003e\u003cp\u003eОсобая благодарность e-maxx.ru\u003c/p\u003e\u003c/div\u003e","tags":[]}}