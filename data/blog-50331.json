{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1486672942,"rating":14,"authorHandle":"pimenta","modificationTimeSeconds":1486673386,"id":50331,"title":"\u003cp\u003eEditorial\u0027s solution for problem 758E\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eAs you can check \u003ca href\u003d\"//codeforces.com/blog/entry/49880\"\u003ehere\u003c/a\u003e, it was very hard for many people (including me) to understand editorial\u0027s solution for problem \u003ca href\u003d\"/contest/758/problem/E\" title\u003d\"Codeforces Round 392 (Div. 2)\"\u003e758E - Broken Tree\u003c/a\u003e. The solution has two parts: one DFS to compute the current, minimum and maximum weights for each subtree and check if we should print -1; and then a second DFS to reduce the values of the edges and fix the tree. The explanation for the first part is great, just check it and remember to ignore the \u0026quot;dp\u0026quot; prefix in variable names (there is no overlapping subproblems, so that\u0027s not dynamic programming). But when it came to explain the second part (which is the harder one), the author decided to spare words. So here it goes the full explanation. I\u0027ll assume you\u0027ve read the explanation for the first part and I\u0027ll use the same (bad) variable names.\u003c/p\u003e\u003cp\u003eBefore calling \u003ccode\u003edfs2(1)\u003c/code\u003e, we should create an array \u003ccode\u003egoal\u003c/code\u003e such that \u003ccode\u003egoal[u]\u003c/code\u003e will store how many units we should remove from the edges of the subtree rooted at \u003ccode\u003eu\u003c/code\u003e. Therefore we should start with \u003ccode\u003egoal[1] \u003d dpw[1]-dpmax[1]\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eThe second DFS is a \u0026quot;pre-order\u0026quot; traversal in the following sense. Suppose we\u0027re visiting \u003ccode\u003eu\u003c/code\u003e. First, we should break the value \u003ccode\u003egoal[u]\u003c/code\u003e and store the pieces in \u003ccode\u003egoal[v]\u003c/code\u003e for each edge \u003ccode\u003e(u, v)\u003c/code\u003e. In other words, we should break the goal for vertex \u003ccode\u003eu\u003c/code\u003e into possibly smaller goals for the children of \u003ccode\u003eu\u003c/code\u003e. Then we should call \u003ccode\u003edfs2(v)\u003c/code\u003e recursively \u003cstrong\u003eonly after\u003c/strong\u003e no more transfers are possible from \u003ccode\u003egoal[u]\u003c/code\u003e to the branch that contains \u003ccode\u003ev\u003c/code\u003e. Let\u0027s see some code for this idea.\u003c/p\u003e\u003cp\u003eFirst, let\u0027s code a helper function to transfer \u003ccode\u003ew\u003c/code\u003e units from \u003ccode\u003egoal[u]\u003c/code\u003e to \u003ccode\u003egoal[v]\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etransfer(u, v, w):\n  goal[u] -\u003d w\n  goal[v] +\u003d w\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe first reduction is to remove the obligatory units, i.e., \u003ccode\u003edpw[v]-dpmax[v]\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003edfs2(u):\n  for each (u, v, w, p) in E:\n    transfer(u, v, dpw[v]-dpmax[v])\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAfter this reduction, it\u0027s possible that \u003ccode\u003egoal[u]\u003c/code\u003e is still greater than zero (but never less than zero, by the construction of the arrays \u003ccode\u003edpw\u003c/code\u003e and \u003ccode\u003edpmax\u003c/code\u003e). Then we should greedily remove some units from the subtrees rooted at the children of \u003ccode\u003eu\u003c/code\u003e, assuming their current weights as \u003ccode\u003edpmax[v]\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e  for each (u, v, w, p) in E:\n    transfer(u, v, min(goal[u], dpmax[v]-dpmin[v]))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe do that because it\u0027s always better to remove units from deeper edges (this is not hard to see). It\u0027s important to note that these two loops cannot be merged. We should take some additional units from the subtrees rooted at the children of \u003ccode\u003eu\u003c/code\u003e only if taking the obligatory units was not enough.\u003c/p\u003e\u003cp\u003eNow, if \u003ccode\u003egoal[u]\u003c/code\u003e is still greater than zero, then all we can do is to take some units from the edges adjacent to \u003ccode\u003eu\u003c/code\u003e, assuming the current weights of the subtrees as \u003ccode\u003edpmin[v]\u003c/code\u003e. This is the last transfer operation from \u003ccode\u003eu\u003c/code\u003e to each of its children, so we can finally do the recursion:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e  for each (u, v, w, p) in E:\n    tmp \u003d min(goal[u], min(w-1, p-dpmin[v]))\n    w -\u003d tmp\n    p -\u003d tmp\n    goal[u] -\u003d tmp\n    dfs2(v)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI\u0027d like to thank \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Jakube\" title\u003d\"Candidate Master Jakube\"\u003eJakube\u003c/a\u003e for his submission \u003ca href\u003d\"/contest/758/submission/24488076\" title\u003d\"Submission 24488076 by Jakube\"\u003e24488076\u003c/a\u003e which helped me to understand the editorial\u0027s solution and hope this post can help others.\u003c/p\u003e\u003cp\u003eHere is my code: \u003ca href\u003d\"/contest/758/submission/24557663\" title\u003d\"Submission 24557663 by pimenta\"\u003e24557663\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["editorial","trees","dfs and similar","greedy"]}}