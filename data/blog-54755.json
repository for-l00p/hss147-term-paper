{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1506309754,"rating":-5,"authorHandle":"duckladydinh","modificationTimeSeconds":1506451614,"id":54755,"title":"\u003cp\u003eHelp! Strange Segmentation Fault Error for Recursive Matrix Fast Exponentiation\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi friends,\u003c/p\u003e\u003cp\u003eDuring the implementation of matrix fast exponentiation, I have encountered a segmentation fault in the recursive approach. Even if I have managed to fix it by changing it to a loop, but I really want to know what is wrong with my code. I wonder if you can help me.\u003c/p\u003e\u003cp\u003eThis is my recursive implementation. I cannot understand what is wrong with it. With n \u003d 1, it is fine, but if n is greater than 1, then segmentation fault.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003econst int N \u003d 100;\n\nstruct Matrix {\n  llnum c[N+N][N+N];\n  int n \u003d 0, m \u003d 0;\n  Matrix(int _n, int _m) {\n    n \u003d _n, m \u003d _m;\n    for (int i \u003d 0; i \u0026lt; n; ++i) {\n      for (int j \u003d 0; j \u0026lt; m; ++j) {\n        c[i][j] \u003d 0;\n      }\n    }\n  }\n  void out() {\n    REP(i, n) {\n      REP(j, m) {\n        cout \u0026lt;\u0026lt; c[i][j] \u0026lt;\u0026lt; \u0026quot; \\n\u0026quot;[j+1 \u003d\u003d m];\n      }\n    }\n    cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n  }\n};\n\nMatrix fast_pow(Matrix A, int n) {\n  if (n \u003d\u003d 0) return ident(A.m);\n  if (n \u003d\u003d 1) return A;\n  Matrix E \u003d fast_pow(A, (n/2));\n  if (n % 2 \u003d\u003d 1) {\n    return mul(E, A);\n  }\n  return E;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThank you.\u003c/p\u003e\u003c/div\u003e","tags":[]}}