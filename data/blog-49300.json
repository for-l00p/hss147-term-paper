{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1482613936,"rating":2,"authorHandle":"0day20hour","modificationTimeSeconds":1482613936,"id":49300,"title":"\u003cp\u003eNeed help on a bitmask DP problem\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eProblem link: \u003ca href\u003d\"http://www.lightoj.com/volume_showproblem.php?problem\u003d1018\"\u003ehttp://www.lightoj.com/volume_showproblem.php?problem\u003d1018\u003c/a\u003e\u003c/p\u003e\u003cp\u003eVerdict: TLE â€” O(n^2 * 2^n) solution\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/7JjcIX\"\u003ehttp://ideone.com/7JjcIX\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI transformed the problem into this. The idea is to given N integer \u003cstrong\u003e0 \u0026lt;\u003d N \u0026lt; 2^M\u003c/strong\u003e where \u003cstrong\u003eM \u0026lt;\u003d 16\u003c/strong\u003e, find the minimum number of integer needed to make 2^M-1 by the operation bitwise-OR. My solution is a variation of subset sum as it is the only DP algorithm I know. But, The test cases are huge, 1000. Can you suggest a better approach? Thanks for your attention.\u003c/p\u003e\u003c/div\u003e","tags":["dp","bitmasks","lightoj"]}}