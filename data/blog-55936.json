{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1511286395,"rating":-3,"authorHandle":"haris471","modificationTimeSeconds":1511286674,"id":55936,"title":"\u003cp\u003eHard Interval Intersection Problem\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eGiving N (0\u0026lt;N\u0026lt;\u003d100000) intervals, ordered I_1, I_2, …, I_N, such that\u003c/p\u003e\u003cp\u003eI_k \u003d [left_k, right_k] for 0 \u0026lt; k \u0026lt;\u003d N with 0 \u0026lt;\u003d left_k \u0026lt;\u003d right_k \u0026lt;\u003d 100000.\u003c/p\u003e\u003cp\u003eThis is followed by a large number of queries (O(N) queries) of the form: Given x and m (0\u0026lt;x,m\u0026lt;\u003d100000), find smallest k, such that x intersects exactly m intervals in \u003c/p\u003e\u003cp\u003e{I_1, I_2, …, I_k} or report it does not exist.\u003c/p\u003e\u003cp\u003eIs there an easy O(n*log^2n) or O(n*logn) solution?\u003c/p\u003e\u003cp\u003eIs there simpler solution than just binary search + persistent segment tree with range updates and point lookups? Is there an easy to read code of persistent segment tree with Range updates and point lookups (have not found anywhere) ? Thanks!\u003c/p\u003e\u003c/div\u003e","tags":[]}}