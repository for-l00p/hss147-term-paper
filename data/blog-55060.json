{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1507465376,"rating":0,"authorHandle":"Slamur","modificationTimeSeconds":1507465376,"id":55060,"title":"\u003cp\u003eБазовые структуры данных. Массив, список\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eПроцесс решения задачи представляет собой обработку данных тем или иным алгоритмом. Одним из видов обработки данных является их хранение в той или иной структуре.\u003c/p\u003e\u003cp\u003eКакие-то структуры данных приходится реализовывать для каждой задачи самостоятельно, но простейшие структуры данных зачастую уже реализованы в стандартных библиотеках. \u003c/p\u003e\u003cp\u003eЯ посвящу структурам данных несколько постов:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eо теоретических основах тех или иных структур (не слишком углубляясь в детали);\u003c/li\u003e   \u003cli\u003eоб использовании описанных структур на различных языках программирования.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eДанный пост является открывающим, в нем я расскажу про \u003cstrong\u003eмассив\u003c/strong\u003e и \u003cstrong\u003eсписок\u003c/strong\u003e. \u003cbr /\u003e\u003c/p\u003e\u003ch3\u003e0) Массив [Array] (одномерный, двумерный, многомерный).\u003c/h3\u003e\u003cp\u003eСамая первая из изучаемых структур данных. Массив представляет собой набор однотипных элементов, расположенных в памяти последовательно.\u003c/p\u003e\u003cp\u003eДлина массива является величиной постоянной, для изменения длины придется пересоздать весь массив.\u003c/p\u003e\u003cp\u003eОперации, доступные для массива:\u003c/p\u003e \u003col\u003e   \u003cli\u003eПолучить значение элемента массива по индексу;\u003c/li\u003e   \u003cli\u003eУстановить по индексу значение;\u003c/li\u003e   \u003cli\u003eПолучить длину (количество элементов в нем) [length].\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eПлюсы: \u003c/p\u003e \u003cul\u003e   \u003cli\u003eВ силу статичности операции над массивом выполняются очень быстро — O(1).\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eМинусы:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eСтатичность является также и главным минусом — невозможность изменять структуру массива после создания накладывает ограничения на работу с ним.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eМассив хотя и кажется очень простой структурой, но большинство несложных задач не потребуют структур сложнее.\u003c/p\u003e\u003cp\u003eПростейший вид массива обладает одним измерением — его легко представить в виде линии стоящих подряд элементов. На самом деле массив может обладать любым количеством измерений. Например, двумерный массив (матрица) легко представим, как массив строк, где каждая строка — массив (одинаковой или различной длины между собой). В общем случае, это можно обобщить на любое количество измерений.\u003c/p\u003e\u003cp\u003eМассив представляет настолько базовую структуру данных, что синтаксис работы с ним практически не отличается от языка к языку.\u003c/p\u003e\u003cp\u003eЧтобы обратиться к элементу массива по индексу, обычно используются квадратные скобки \u0027[]\u0027:\u003c/p\u003e \u003col\u003e   \u003cli\u003evalue \u003d array[index]\u003c/li\u003e   \u003cli\u003earray[index] \u003d value\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eДля двумерных массивов обычно встречаются два вида обращения по индексам: \u003c/p\u003e \u003col\u003e   \u003cli\u003earray[row, column]\u003c/li\u003e   \u003cli\u003earray[row][column]\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eСмысл у этих двух записей одинаковый — получить элемент в строке row и колонке column.\u003c/p\u003e\u003cp\u003eДля больших измерений вы просто добавляете необходимые индексы, больше ничего не нужно.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eВАЖНО:\u003c/strong\u003e В языках C/C++, C#, Java, Python индексация начинается с 0. Это значит, что для массива array \u003d (1, 2, 4)\u003c/p\u003e \u003cul\u003e   \u003cli\u003earray[0] -\u0026gt; 1\u003c/li\u003e   \u003cli\u003earray[1] -\u0026gt; 2\u003c/li\u003e   \u003cli\u003earray[2] -\u0026gt; 4\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eОбратившись по отрицательному индексу или индексу, большему или равному чем длина массива, вы словите ошибку выхода за границу массива.\u003c/p\u003e\u003ch3\u003e1) Список [List] (на массивах, связный).\u003c/h3\u003e\u003cp\u003eГлавным минусом массива является его статичность — после создания массива единственным способом изменить его структуру является пересоздание всего массива за O(N).\u003c/p\u003e\u003cp\u003eСписком называют диначеский массив — массив, у которого возможно изменять структуру прямо в процессе выполнения программы.\u003c/p\u003e\u003cp\u003eОперации, доступные для списка (перечислены лишь основные):\u003c/p\u003e \u003col\u003e   \u003cli\u003eПолучить значение элемента массива по индексу [get];\u003c/li\u003e   \u003cli\u003eУстановить по индексу значение [set];\u003c/li\u003e   \u003cli\u003eПолучить длину (количество элементов в нем) [size];\u003c/li\u003e   \u003cli\u003eДобавить элемент в начало/конец/по индексу [add / insert].\u003c/li\u003e   \u003cli\u003eУдалить элемент из начала/конца/по индексу [remove].\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eСуществует две основные разновидности списков: Array-based и Linked.\u003c/p\u003e\u003ch4\u003eСвязный список (Linked list).\u003c/h4\u003e\u003cp\u003eСвязный список состоит из отдельных узлов, \u003ci\u003eсвязанных\u003c/i\u003e между собой. В нем выделены два специальных узла — \u0026quot;голова\u0026quot; (первый узел) и \u0026quot;хвост\u0026quot; (последний узел).\u003c/p\u003e\u003cp\u003eКаждый узел состоит из двух частей: область связи и область информации. Простейший вариант узла — ссылка на следующий по порядку узел (отсутствует у хвоста) и значение узла. Список из таких узлов называется \u003ci\u003eодносвязным\u003c/i\u003e.\u003c/p\u003e\u003cp\u003eНа практике удобнее использовать узел, связанный со следующим (next) и предыдущим (prev) узлами в списке. Список, состоящий из таких узлов, называется \u003ci\u003eдвусвязным\u003c/i\u003e.\u003c/p\u003e\u003cp\u003eПлюсы: \u003c/p\u003e \u003cul\u003e   \u003cli\u003eОперации вставки и удаления заданного узла выполняются за O(1).\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eМинусы:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eНевозможно индексироваться быстрее, чем прямым проходом по узлам. Следствием является сложность O(n) для любых операций, связанных с поиском элемента по индексу.\u003c/li\u003e \u003c/ul\u003e\u003ch4\u003eСписок на массиве (ArrayList).\u003c/h4\u003e\u003cp\u003eНазвание явно нам показывает, что основой данной списка является массив. Главная идея заключается в том, что если при попытке добавить элемент длины текущего массива не хватает, то мы расширяем массив не на 1, а удваиваем его длину.\u003c/p\u003e\u003cp\u003eМожно показать, что при таком алгоритме пересоздания массива N добавлений элементов в конце списка будут произведены в среднем за O(N). \u003c/p\u003e\u003cp\u003eОценка сложности операции, равная сложности N операций, деленной на количество операций, называется \u003ci\u003eамортизированной оценкой\u003c/i\u003e. В данном случае N операций добавления будут произведены за O(N), откуда амортизированная оценка равна O(1).\u003c/p\u003e\u003cp\u003eЗаметим, что такая скорость доступна только при добавлении/удалении с конца списка, вставить элемент в середину займет O(N) операций, так как потребуется явно передвигать элементы.\u003c/p\u003e\u003cp\u003eПлюсы: \u003c/p\u003e \u003cul\u003e   \u003cli\u003eИндексация делается за O(1) — мы просто обращаемся ко внутреннему массиву;\u003c/li\u003e   \u003cli\u003eОперации вставки и удаления с конца списка выполняются в среднем за O(1) (амортизированная оценка).\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eМинусы:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eВставка и удаление не последнего элемента требуют O(N — index) \u003d O(N) операций в среднем.\u003c/li\u003e \u003c/ul\u003e\u003c/div\u003e","tags":["самара","структуры данных","массив","список"]}}