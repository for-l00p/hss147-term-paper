{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1496842233,"rating":0,"authorHandle":"just_solve_it","modificationTimeSeconds":1496934398,"id":52447,"title":"\u003cp\u003eРазбор 2012-2013 Тренировка СПбГУ B #1 \u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eТут будет разбор 2012-2013 Тренировка СПбГУ B #1. Если вы уже вдоволь подумали над этими задачами и у вас нет ни одной годной идеи, то тут будет разбор этих задач .\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/ysnvR1E45m/contest/100070/submit/A\"\u003eЗадача A\u003c/a\u003e\u003c/p\u003e\u003cp\u003eТут нет ничего интересного -- все можно хранить в \u003ccode\u003eint\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/ysnvR1E45m/contest/100070/submit/B\"\u003eЗадача B\u003c/a\u003e\u003c/p\u003e\u003cp\u003eТут нужна просто топологическая сортировка. Как обычно, вы просто запоминаете порядок выхода из \u003ccode\u003eDFS\u003c/code\u003e, а затем, если это необходимо, разворачиваете его. Не забудьте, что нужно проверять нет ли цикла и в случае чего бросать исключение, что легко делать крася вершины в три цвета \u003ccode\u003e{NEW, LOOKING, LOOKED}\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/ysnvR1E45m/contest/100070/submit/C\"\u003eЗадача C\u003c/a\u003e\u003c/p\u003e\u003cp\u003eМожно каждый раз при встрече отдельного элемента пихать его позицию в \u003ccode\u003estd::map\u0026lt;int, size_t\u0026gt;\u003c/code\u003e(внимание, тут следует пользоваться оператором \u003ccode\u003e.at(key)\u003c/code\u003e, потому что он не создает новых элементов), либо можно просто каждый раз при помощи \u003ccode\u003estd::upper_bound\u003c/code\u003e искать позицию, а при помощи \u003ccode\u003estd::binary_search\u003c/code\u003e проверять встречается ли эта позиция.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/ysnvR1E45m/contest/100070/submit/D\"\u003eЗадача D\u003c/a\u003e\u003c/p\u003e\u003cp\u003eМожно не париться и просто отсортировать все элементы -- благо у \u003ccode\u003estd::sort\u003c/code\u003e безумно маленькая константа. Либо, можно включить мозг и понять, что, учитывая специфику модуля, нам достаточно хранить количества вхождений каждого остатка. Как ответ восстановить, думаю, понятно.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/ysnvR1E45m/contest/100070/submit/E\"\u003eЗадача E\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЕсли мало думать, то прийдется много кодить, но в целом суть понятна -- находим все мосты, находим какой-то путь от одной вершины к другой, а потом проверяем сколько на нем лежит мостов. Если это аккуратно сделать, то получится что-то вроде \u003ccode\u003eO(n + m + n log n)\u003c/code\u003e. Но можно пользоваться чем-то между ушей и вспомнить как ищутся мосты -- мы сначала запускаем режущий \u003ccode\u003eDFS\u003c/code\u003e, а потом, в порядке его обхода, запускаем красящий. Если при первом \u003ccode\u003eDFS\u003c/code\u003e, запомнить ветку обхода, которая идет непосредственно к искомой вершине, то потом можно красящий запускать не из всего обхода, а только из этого пути. Последнее можно реализовать, например, в \u003ccode\u003eDFS\u003c/code\u003e возвращая следующее -- а попадем ли мы из этой вершины в конечную не проходя по перекрестным и обратным ребрам?\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/ysnvR1E45m/contest/100070/submit/F\"\u003eЗадача F\u003c/a\u003e\u003c/p\u003e\u003cp\u003eВ этой задаче можно просто написать бор. Это такое дерево, на каждом ребре которого написана буква и, как следствие, каждый путь от корня до вершины является суффиксом. Каждая вершина соответствует какой-то подстроке, которая формируется как строка, составленная из символов на ребрах пути от корня. Его удобно хранить в \u003c/p\u003e \u003cpre\u003e\u003ccode\u003estruct CharTree {\n  std::map\u0026lt;char, CharTree*\u0026gt; sons;\n};\nusing Iterator \u003d std::string::const_iterator;\nvoid InsertSuffix(Iterator begin, Iterator end, CharTree* tree);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДалее, следует для каждой пары итераторов исходной строки \u003ccode\u003e{smth, end}\u003c/code\u003e вставить его начиная с корня, а затем простым \u003ccode\u003eDFS\u003c/code\u003e посчитать количество вершин. По сколько нас интересуют только непустые суффиксы, то следует вычесть единицу -- корень как раз соответствует пустой подстроке.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/ysnvR1E45m/contest/100070/submit/H\"\u003eЗадача H\u003c/a\u003e\u003c/p\u003e\u003cp\u003eТут нужно очень аккуратно обращаться с памятью. Поэтому, не следует пользоваться \u003ccode\u003estd::deque\u003c/code\u003e, \u003ccode\u003estd::vector\u003c/code\u003e и прочими, а вот \u003ccode\u003estd::array\u003c/code\u003e и \u003ccode\u003estd::list\u003c/code\u003e неплохо справляются.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/ysnvR1E45m/contest/100070/submit/I\"\u003eЗадача I\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЭто довольно непонятная на первый взгляд задача. Для того, чтобы она стала понятнее, можно развернуть список запросов и получим следующее: дан пустой граф, в котором нужно отвечать на запросы: \u0026quot;а лежат ли \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e в одной компоненте связности?\u0026quot;, \u0026quot;а соедини ка вершины \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e\u0026quot;. И то и другое легко сделать при помощи СНМ. Не забудьте только развернуть список ответов.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/ysnvR1E45m/contest/100070/submit/J\"\u003eЗадача J\u003c/a\u003e\u003c/p\u003e\u003cp\u003eВ этой задаче нужно реализовать декартово дерево по неявному ключу. Об обычном декартовом дереве и декартовом дереве по неявному ключу можно прочитать, например, \u003ca href\u003d\"https://habrahabr.ru/post/101818/\"\u003eтут\u003c/a\u003e или \u003ca href\u003d\"http://e-maxx.ru/algo/treap\"\u003eтут\u003c/a\u003e, ну или \u003ca href\u003d\"https://neerc.ifmo.ru/wiki/index.php?title\u003dДекартово_дерево\"\u003eтут\u003c/a\u003e. После того как вы с этим разберетесь -- в вершинах дерева нужно хранить элемент который соответствует этой вершине, минимум в ее поддереве и размер самого поддерева. Затем делом техники будет поддерживать требуемые \u003ccode\u003eleft\u003c/code\u003e и \u003ccode\u003eright\u003c/code\u003e для запроса минимума. Вставка происходит по стандартной технике с использованием операций \u003ccode\u003eSplit\u003c/code\u003e и \u003ccode\u003eMerge\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/ysnvR1E45m/contest/100070/submit/K\"\u003eЗадача K\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЭто стандартная задача динамического программирования -- можно, например, отвечать на вопрос вида \u0026quot;какой максимальный ответ, если мы начинаем перед ступенькой номер \u003ccode\u003en\u003c/code\u003e\u0026quot;. Уделите внимание тому, чтобы записать эту задачу нормально -- тут пригодится функтор и попробуйте написать его так, чтобы было понятно, что это не чистая функция только в начале в фазах \u0026quot;а не посчитано ли это значение?\u0026quot; и \u0026quot;ну ладно, пусть результат изначально будет ссылкой на адрес в памяти\u0026quot;.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/ysnvR1E45m/contest/100070/submit/L\"\u003eЗадача L\u003c/a\u003e\u003c/p\u003e\u003cp\u003eТут нас встретит более-менее стандартная задача на алгоритм Дейкстры. Можно извратиться и хранить три \u003ccode\u003estd::deque\u003c/code\u003e для вершин на расстояниях от корня \u003ccode\u003ek\u003c/code\u003e, \u003ccode\u003ek + 1\u003c/code\u003e, \u003ccode\u003ek + 2\u003c/code\u003e, но делать мы так конечно же не будем (по меньшей мере я -- там целых три контейнера). Учтите, что веса ребер можно хранить либо явно, либо считать их в какой-нибудь лямбде \u0026quot;на лету\u0026quot;. Можно просто написать Дейстру и не париться, но тут вам поможет либо куча, либо куча. А еще может помочь куча. Её поучительно написать самому, либо же воспользоваться (не приведи господь пользоваться \u003ccode\u003estd::set\u003c/code\u003e для этих целей -- получится добыча изюма из булочек) \u003ccode\u003estd::priority_queue\u003c/code\u003e, но там какая-то лажа по умолчанию с компаратором (вверху хранится максимум), и шаблон не очень приятный (тип элемента, тип хранилища, тип компаратора, поэтому придется использовать что-то вроде)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e  using QueueNode \u003d std::pair\u0026lt;Cost, pair\u0026lt;Node, Node\u0026gt;\u0026gt;;\n  using Container \u003d std::vector\u0026lt;QueueNode\u0026gt;;\n  using Compare \u003d std::greater\u0026lt;QueueNode\u0026gt;;\n\n  std::priority_queue\u0026lt;QueueNode, Container, Compare\u0026gt; queue;\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eК счастью, вам больше не прийдется париться с этими шаблонами, поэтому все в порядке.\u003c/p\u003e\u003c/div\u003e","tags":[]}}