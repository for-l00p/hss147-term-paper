{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1497020444,"rating":0,"authorHandle":"SAeed","modificationTimeSeconds":1497020444,"id":52494,"title":"\u003cp\u003eSPU Contest #3 tutorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e \u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/213986/problem/Blue\"\u003eBlue — Vacations\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eDynamic Programming\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDP[\u003c/strong\u003e current day \u003cstrong\u003e][\u003c/strong\u003e activity done yesterday \u003cstrong\u003e]\u003c/strong\u003e :\u003c/p\u003e\u003cp\u003e0 — If you rested yesterday. 1 — If you went to the gym yesterday. 2 — If you participated in a contest yesterday.\u003c/p\u003e\u003cp\u003ePay attention not to do the same activity as yesterday on the current day.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits\\stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint n;\nint a[111];\nint memo[111][3];\n/*\nlasti:\n\t0- means I rested yesterday\n\t1- means I went to the gym yesterday\n\t2- means I participate in a contest yesterday\n*/\nint dp(int i, int lasti){\n\tif (i \u003d\u003d n) return 0;\n\n\tint \u0026amp;ret \u003d memo[i][lasti];\n\tif (ret !\u003d -1) return ret;\n\n\tret \u003d 1e9;\n\t// try to go to the gym on this day\n\tif (lasti !\u003d 1 \u0026amp;\u0026amp; (a[i] \u003d\u003d 2 || a[i] \u003d\u003d 3)) ret \u003d min(ret, dp(i + 1, 1));\n\n\t// try to participate in a contest on this day\n\tif (lasti !\u003d 2 \u0026amp;\u0026amp; (a[i] \u003d\u003d 1 || a[i] \u003d\u003d 3)) ret \u003d min(ret, dp(i + 1, 2));\n\n\t// try to rest on this day\n\tret \u003d min(ret, 1 + dp(i + 1, 0));\n\n\treturn ret;\n}\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tcin \u0026gt;\u0026gt; n;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i];\n\tmemset(memo, -1, sizeof memo);\n\tcout \u0026lt;\u0026lt; dp(0, 0) \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/213986/problem/Green\"\u003eGreen — Santa Claus and a Place in a Class\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eMath\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eYou just need to calculate the answer step by step using basic math operations. I tried to add comments to my code so it would be easier to understand it.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(1)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits\\stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\n\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tll lane, desk, pos; cin \u0026gt;\u0026gt; lane \u0026gt;\u0026gt; desk \u0026gt;\u0026gt; pos;\n\n\tchar santaLeftOrRight; // the left side is always odd, and the right side is always even\n\tif (pos % 2 \u003d\u003d 0) santaLeftOrRight \u003d \u0027R\u0027;\n\telse santaLeftOrRight \u003d \u0027L\u0027;\n\n\t// number of places in each lane\n\tll placesInEachLane \u003d desk * 2; \n\t// number of the lane santa is sitting on\n\tll santaLane \u003d pos / placesInEachLane;\n\t// in the figure shown in the problem, if pos was 6, then 12/6 \u003d 2, while santa is in the second lane\n\tif (pos % placesInEachLane \u003d\u003d 0) santaLane--; \n\tsantaLane++; // problem starts numbering from 1 not 0\n\n\t// how many sits is there before santa, in his same lane\n\tll orderInLane \u003d pos - (santaLane - 1) * placesInEachLane; \n\t// number of the desk santa is sitting on\n\tll santaDesk \u003d orderInLane / 2; \n\t// in the figure shown in the problem, if pos was 4, then 4/2 \u003d 2, while santa is in the second desk\n\tif (orderInLane % 2 \u003d\u003d 0) santaDesk--; \n\tsantaDesk++; // problem starts numbering from 1 not 0\n\n\tcout \u0026lt;\u0026lt; santaLane \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; santaDesk \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; santaLeftOrRight \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/213986/problem/Purple\"\u003ePurple — The Labyrinth\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eGraph\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe simple solution for this problem is to run a DFS for each obstacle. However, this solution will give TLE.\u003c/p\u003e\u003cp\u003eWe can run a single DFS, and calculate two things for each cell:\u003c/p\u003e\u003cp\u003eFirst, we will give each connected component a unique ID, and mark all the cells belonging to this component with this ID. We will call this array: \u003ccode\u003ecomponentID\u003c/code\u003e. \u003cstrong\u003ecomponentID[x][y]\u003c/strong\u003e means the id of the component to which cell \u003ccode\u003e(x, y)\u003c/code\u003e belongs.\u003c/p\u003e\u003cp\u003eSecond, we will calculate the size of each component and store this size in array: \u003ccode\u003ecomponentSize\u003c/code\u003e. \u003cstrong\u003ecomponentSize[id]\u003c/strong\u003e means the size of the components whose id is \u003ccode\u003eid\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eNow we have to iterate through the whole grid. If the current cell is a \u003ccode\u003e.\u003c/code\u003e then just print it. Otherwise, check the components that are on the (top, bottom, left, right) of you, and add their size to the answer. Be careful not to add the same component to the answer more than once by keeping a set called \u003ccode\u003etakenComponents\u003c/code\u003e which stores the components you added to the answer.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n x m)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits\\stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint dx[4] \u003d { 0, 0, 1, -1 };\nint dy[4] \u003d { -1, 1, 0, 0 };\nint n, m;\nchar G[1010][1010];\nint componentID[1010][1010];\nint componentSize[10010000];\nint currentComponentID \u003d 0, currentComponentSize \u003d 0;\nint vis[1010][1010];\nvoid dfs(int x, int y){\n\tvis[x][y] \u003d 1;\n\tcomponentID[x][y] \u003d currentComponentID;\n\tcomponentSize[currentComponentID]++;\n\n\tfor (int i \u003d 0; i \u0026lt; 4; i++){\n\t\tint newX \u003d x + dx[i];\n\t\tint newY \u003d y + dy[i];\n\t\tif (newX \u0026lt; 0 || newX \u0026gt;\u003d n || newY \u0026lt; 0 || newY \u0026gt;\u003d m) continue;\n\t\tif (vis[newX][newY]) continue;\n\t\tif (G[newX][newY] \u003d\u003d \u0027*\u0027) continue;\n\t\tdfs(newX, newY);\n\t}\n}\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) for (int j \u003d 0; j \u0026lt; m; j++) cin \u0026gt;\u0026gt; G[i][j];\n\n\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\tfor (int j \u003d 0; j \u0026lt; m; j++){\n\t\t\tif (G[i][j] \u003d\u003d \u0027*\u0027) continue;\n\t\t\tif (vis[i][j]) continue;\n\t\t\tcurrentComponentID++;\n\t\t\tdfs(i, j);\n\t\t}\n\t}\n\n\tfor (int x \u003d 0; x \u0026lt; n; x++){\n\t\tfor (int y \u003d 0; y \u0026lt; m; y++){\n\t\t\tif (G[x][y] \u003d\u003d \u0027.\u0027) cout \u0026lt;\u0026lt; G[x][y];\n\t\t\telse{\n\t\t\t\tint ans \u003d 1; // 1 because the cell it self should be added to the answer\n\t\t\t\tset\u0026lt;int\u0026gt; takenComponents;\n\t\t\t\tfor (int i \u003d 0; i \u0026lt; 4; i++){\n\t\t\t\t\tint newX \u003d x + dx[i];\n\t\t\t\t\tint newY \u003d y + dy[i];\n\t\t\t\t\tif (newX \u0026lt; 0 || newX \u0026gt;\u003d n || newY \u0026lt; 0 || newY \u0026gt;\u003d m) continue;\n\t\t\t\t\tif (G[newX][newY] \u003d\u003d \u0027*\u0027) continue;\n\t\t\t\t\tif (takenComponents.find(componentID[newX][newY]) !\u003d takenComponents.end())\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// this component has been added to the answer before\n\n\t\t\t\t\tans +\u003d componentSize[componentID[newX][newY]];\n\t\t\t\t\ttakenComponents.insert(componentID[newX][newY]);\n\t\t\t\t}\n\t\t\t\tcout \u0026lt;\u0026lt; ans % 10;\n\t\t\t}\n\t\t}\n\t\tcout \u0026lt;\u0026lt; endl;\n\t}\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/213986/problem/Red\"\u003eRed — New Year and North Pole\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAdHock\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eFirst, you can see that moving to the east and to the west is useless. Moving to the east and to the west should only be considered when you are at the north or the south pole, in which this move makes the answer NO.\u003c/p\u003e\u003cp\u003eNow, keep a variable called \u003ccode\u003epos\u003c/code\u003e to store your current position. 0 means you are at the north pole, and 20 000 means you are at the south pole. If you moved further than the north or the south pole, the answer is NO. If at the end you are not the north pole (position 0) the answer is also NO. Otherwise, the answer is YES.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits\\stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\n\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tint n; cin \u0026gt;\u0026gt; n;\n\tint pos \u003d 0;\n\tbool valid \u003d true;\n\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\tint t; string s; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; s;\n\t\tif (s \u003d\u003d \u0026quot;North\u0026quot;){\n\t\t\tif (pos - t \u0026lt; 0) valid \u003d false; // we can\u0027t move further than the north pole\n\t\t\tpos -\u003d t;\n\t\t}\n\t\telse if (s \u003d\u003d \u0026quot;South\u0026quot;){\n\t\t\tif (pos + t \u0026gt; 20000) valid \u003d false; // we can\u0027t move further than the south pole\n\t\t\tpos +\u003d t;\n\t\t}\n\t\telse { // if we should move to the east or to the west\n\t\t\tif (pos \u003d\u003d 0 || pos \u003d\u003d 20000) valid \u003d false; // if we are at the north or south pole we can\u0027t move to the east\n\t\t}\n\t}\n\tif (valid \u0026amp;\u0026amp; pos \u003d\u003d 0) cout \u0026lt;\u0026lt; \u0026quot;YES\u0026quot; \u0026lt;\u0026lt; endl;\n\telse cout \u0026lt;\u0026lt; \u0026quot;NO\u0026quot; \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/213986/problem/Yellow\"\u003eYellow — New Year and Hurry\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAdHock\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSince the contests lasts for four hours, then the total contest time is (4 x 60).\u003c/p\u003e\u003cp\u003eIf you need \u003ccode\u003ek\u003c/code\u003e minutes to be home, then you have \u003ccode\u003e4 x 60 - k\u003c/code\u003e minutes left to solve problems. All you have to do is iterate over the problems and see which problems you can solve.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits\\stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\n\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\tint n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k;\n\tint hasTime \u003d 4 * 60 - k;\n\tint ans \u003d 0;\n\tfor (int i \u003d 1; i \u0026lt;\u003d n; i++){\n\t\tif (i * 5 \u0026lt;\u003d hasTime) ans++, hasTime -\u003d i * 5; // if he has enough time to solve this problem\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}