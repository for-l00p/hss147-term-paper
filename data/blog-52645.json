{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1497587482,"rating":32,"authorHandle":"ZhassanB","modificationTimeSeconds":1497589569,"id":52645,"title":"\u003cp\u003eVery Fast Input Scanner\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi there! Couple of days ago I was solving problem \u003ca href\u003d\"//codeforces.com/problemset/problem/796/C\"\u003e796C-Bank Hacking\u003c/a\u003e. I came up with O(nlog(n)) order solution, but it failed with Time Limit Exceeded status. The max input size was 3*10^5, which implies that order O(n*log(n)) algorithm must fit into time limit. The tutorial for the contest also mentioned the same order solution. After a few hours of debugging, I have realized that the problem is in input reading part. Well, my code used built in BufferedReader in java:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eBufferedReader br \u003d new BufferedReader(new InputStreamReader(System.in));\nint n \u003d  Integer.parseInt(br.readLine());\nBank banks[] \u003d new Bank[n];\nString tokens[] \u003d br.readLine().split(\u0026quot; \u0026quot;);\nList\u0026lt;Integer\u0026gt; g[] \u003d new List[n];\t\nint max \u003d Integer.MIN_VALUE;\t\nfor(int i \u003d0 ;i\u0026lt;n;i++) {\n\tg[i] \u003d new ArrayList\u0026lt;\u0026gt;();\t\n\tint val \u003d Integer.parseInt(tokens[i]);\n\tmax \u003d Math.max(max, val);\t\t\t\n\tbanks[i] \u003d new Bank(i, val);\n}\t\t\nfor(int i \u003d 0;i\u0026lt;n-1;i++){\n\ttokens \u003d br.readLine().split(\u0026quot; \u0026quot;);\n\tint a \u003d Integer.parseInt(tokens[0])-1;\n\tint b \u003d Integer.parseInt(tokens[1])-1;\n\tg[a].add(b);\n\tg[b].add(a);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe code slice already consumed about 800 ms for the maximum size input. After I have submitted a linear time alternative solution, but I still decided to find more faster way of reading. I have found \u003ca href\u003d\"https://github.com/williamfiset/FastJavaIO/blob/master/src/main/java/fastjavaio/InputReader.java\"\u003ewilliamfiset\u003c/a\u003e \u0027s InputReader which claimed to be much faster than the BufferedReader. Finally I decided to write my own FastScanner inspired with his idea. Well here it is (Currently I have just implemented it for Integers):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport java.io.*;\nimport java.util.*;\n\npublic class FastScanner {\n\n    static final int DEFAULT_BUFF \u003d 1024, EOF \u003d -1, INT_MIN \u003d 48, INT_MAX \u003d 57;\n    static final byte NEG \u003d 45;\n    static final int[] ints \u003d new int[58];\n\n    static {\n        int value \u003d 0;\n        for (int i \u003d 48; i \u0026lt; 58; i++) {\n            ints[i] \u003d value++;\n        }\n    }\n\n    InputStream stream;\n\n    byte[] buff;\n    int buffPtr;\n\n    public FastScanner(InputStream stream) {\n        this.stream \u003d stream;\n        this.buff \u003d new byte[DEFAULT_BUFF];\n        this.buffPtr \u003d -1;\n    }\n\n    public int nextInt() throws IOException {\n        int val \u003d 0;\n        int sign \u003d readNonDigits();\n        while (isDigit(buff[buffPtr]) \u0026amp;\u0026amp; buff[buffPtr] !\u003d EOF) {\n            val \u003d (val \u0026lt;\u0026lt; 3) + (val \u0026lt;\u0026lt; 1) + ints[buff[buffPtr]];\n            buffPtr++;\n            if (buffPtr \u003d\u003d buff.length) {\n                updateBuff();\n            }\n        }\n        return val*sign;\n    }\n\n    private int readNonDigits() throws IOException {\n        if (buffPtr \u003d\u003d -1 || buffPtr \u003d\u003d buff.length) {\n            updateBuff();\n        }\n        if (buff[buffPtr] \u003d\u003d EOF) {\n            throw new IOException(\u0026quot;End of stream reached\u0026quot;);\n        }\n        int signByte \u003d -1;\n        while (!isDigit(buff[buffPtr])) {\n            signByte \u003d buff[buffPtr];\n            buffPtr++;\n            if (buffPtr \u0026gt;\u003d buff.length) {\n                updateBuff();\n            }\n            if (buff[buffPtr] \u003d\u003d EOF) {\n                throw new IOException(\u0026quot;End of stream reached\u0026quot;);\n            }\n        }\n        if(signByte \u003d\u003d NEG) return -1;\n        return 1;\n    }\n\n    public void close() throws IOException {\n        stream.close();\n    }\n\n    private boolean isDigit(int b) {\n        return b \u0026gt;\u003d INT_MIN \u0026amp;\u0026amp; b \u0026lt;\u003d INT_MAX;\n    }\n\n    private void updateBuff() throws IOException {\n        buffPtr \u003d 0;\n        stream.read(buff);\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe FastScanner class in my code worked very fast and the maximum size input reading time has reduced up to 47 ms. As a result I have got accepted even with O(nlog(n)) order solution, just by replacing the reading part by the following code slice:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eFastScanner in \u003d new FastScanner(System.in);\nint n \u003d  in.nextInt();\nBank banks[] \u003d new Bank[n];\nList\u0026lt;Integer\u0026gt; g[] \u003d new List[n];\t\nfor(int i \u003d0 ;i\u0026lt;n;i++) {\n\tg[i] \u003d new ArrayList\u0026lt;\u0026gt;();\t\n\tint val \u003d in.nextInt();;\n\tbanks[i] \u003d new Bank(i, val+2);\n}\t\t\nfor(int i \u003d 0;i\u0026lt;n-1;i++){\n\tint a \u003d in.nextInt()-1;\n\tint b \u003d in.nextInt()-1;\n\tg[a].add(b);\n\tg[b].add(a);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou may find my last submission \u003ca href\u003d\"//codeforces.com/contest/796/submission/27793950\"\u003ehere\u003c/a\u003e if you want.\u003c/p\u003e\u003cp\u003eFurther I plan to upgrade and test my FastScanner, and never use BufferedReader when fast reading is important.\u003c/p\u003e\u003cp\u003eThank you for attention. \u003c/p\u003e\u003c/div\u003e","tags":["fastscanner","fastreader","fast input","input reading","large inputs","fast","big inputs","bufferedreader"]}}