{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1457907412,"rating":-9,"authorHandle":"DNA","modificationTimeSeconds":1457907412,"id":43782,"title":"\u003cp\u003eDFS without recursion\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHow do you implement a DFS without recursion, if you have to perform an operation after the recursive DFS is called on a neighbor?\u003c/p\u003e\u003cp\u003eAn example of such a DFS is the following (untested) algorithm to check for a cycle in an undirected graph:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid dfs(int u, int p)\n{\n    color[u] \u003d 1;\n    for (int i \u003d 0; i \u0026lt; adj[u].size(); i++)\n    {\n        int v \u003d adj[u][i];\n        if (v \u003d\u003d p)\n        {\n            continue;\n        }\n        if (color[v] \u003d 1)\n        {\n            cycle \u003d true;\n            return;\n        }\n        else if (color[v] \u003d 0)\n        {\n            dfs(v, u);\n        }\n    }\n    color[u] \u003d 2;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnother question I have is, why would you ever use recursive DFS? It could always be hacked by a case where the graph is one line, causing stack overflow (although I have never seen this happen for some reason).\u003c/p\u003e\u003c/div\u003e","tags":["graphs"]}}