{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1438432053,"rating":4,"authorHandle":"anh1l1ator","modificationTimeSeconds":1438432088,"id":19551,"title":"\u003cp\u003eHow to solve SWAPS — Counting inversions in a faster way?\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eSo , formally the problem statement :\u003c/p\u003e\u003cp\u003eYou are given a sequence A of N (N≤250000) integers between 1 and 50000. On this sequence you have to apply M (M≤10000) operations of the form: modify the i-th element in the sequence and then say how many inversions are there in the sequence. The number of inversions in a sequence is given by the number of pairs (i,j) with i \u0026lt; j and Ai \u0026gt; Aj.\u003c/p\u003e\u003cp\u003eMy approach is to , 1) Divide the array into square root pieces , and maintain a fenwick tree for each of the blocks that stores 1 corresponding to each number in that block ( For querying number of numbers lesser than a particular value in that block )\u003c/p\u003e\u003cp\u003e2) Count the inversions .\u003c/p\u003e\u003cp\u003e3) Now whenever Update comes , I update get inversions from all blocks except the index\u0027s box(I count the difference between the inversions due to the new value — inversions due to old value and add it to the inversions) and add it ! Plus I traverse the block of index ! Total Query time O( Sqquare root of N * log 50000 ) .\u003c/p\u003e\u003cp\u003eIt is giving TLE Even with fast scanning and outputting Here is my code , can it be further optimised ? \u003ca href\u003d\"http://ideone.com/gzgzgH\"\u003eIdeone\u003c/a\u003e \u003c/p\u003e\u003cp\u003eLink to problem \u003ca href\u003d\"http://www.spoj.com/problems/SWAPS/\"\u003eSpoj\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIs there any other approach to it ?\u003c/p\u003e\u003c/div\u003e","tags":["inversions","spoj","algorithms"]}}