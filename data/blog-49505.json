{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1483344445,"rating":-17,"authorHandle":"farmersrice","modificationTimeSeconds":1483362601,"id":49505,"title":"\u003cp\u003eBoth wrong answer and unexpected TLE\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eSo, I was recently trying to solve this problem: \u003ca href\u003d\"http://usaco.org/index.php?page\u003dviewproblem2\u0026amp;cpid\u003d231\"\u003ehttp://usaco.org/index.php?page\u003dviewproblem2\u0026amp;cpid\u003d231\u003c/a\u003e. Unfortunately I am in China right now, so I can\u0027t access pastebin or ideone. The code is at the bottom. \u003c/p\u003e\u003cp\u003eHere is an explanation of my algorithm: Firstly, we store segments of empty spaces. A segment is represented as an integer in the array called \u0026quot;vacant\u0026quot;. \u003ccode\u003evacant[i]\u003c/code\u003e means that there is a segment without cows starting at position i and covering \u003ccode\u003evacant[i]\u003c/code\u003e spaces. For example, if \u003ccode\u003evacant[5]\u003c/code\u003e is equal to 2, that means there is a segment from [5, 6]. Then, we store these length values in the same way as in the vacant array, but instead in a segment tree that gives maximums.\u003c/p\u003e\u003cp\u003eTo handle a group of cows entering the barn, I first check if there is a space to accommodate them: if the largest free space is smaller than the group of cows, then we reject them and increment the answer. If they can fit, then I binary search with the segment tree maximum to figure out which space they should occupy, based on the statement that the cows will sit at the first location that they fit in. Then, I take the segment that they sit in and chop the beginning part (where the cows sit) off, and I modify my segment tree and vacant array.\u003c/p\u003e\u003cp\u003eTo handle some cows leaving the barn, I use a TreeSet (a balanced binary search tree) called \u0026quot;startTree\u0026quot; to store the start points of vacant segments. When I receive a query, I look to the left and right of the start point of the query interval, and see if I can merge those two intervals. If I can merge the intervals, then I do so and remove the merged interval from the array and segment tree and TreeSet. At the end I insert the interval into the tree.\u003c/p\u003e\u003cp\u003eHowever, I only pass the first two test cases, then I get two WA, then I get everything else TLE. I have been looking for quite a while already, and I have found no clues.\u003c/p\u003e\u003cp\u003eOn WA, I have no idea what is happening.\u003c/p\u003e\u003cp\u003eFor TLE, it seems strange to me: the first query of cows entering takes log^2 n to process, while the second query of cows leaving takes amortized log n to process. How is it possible that I get TLE with a 4 second time limit when I only perform at most M * log^2 N ~ 110m operations? Is my code too inefficient/large constant?\u003c/p\u003e\u003cp\u003eHere is the code, with comments:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class seating {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t//BufferedReader r \u003d new BufferedReader(new InputStreamReader(System.in));\n    \t//PrintWriter w \u003d new PrintWriter(System.out);\n        \n    \tBufferedReader r \u003d new BufferedReader(new FileReader(\u0026quot;seating.in\u0026quot;));\n    \tPrintWriter w \u003d new PrintWriter(new BufferedWriter(new FileWriter(\u0026quot;seating.out\u0026quot;)));\n\n    \tStringTokenizer st \u003d new StringTokenizer(r.readLine());\n    \tint n \u003d Integer.parseInt(st.nextToken());\n    \tint m \u003d Integer.parseInt(st.nextToken());\n    \t\n    \tint answer \u003d 0;\n    \tSegtree segtree \u003d new Segtree(new long[n]);\n    \tint[] vacant \u003d new int[n];\n    \tvacant[0] \u003d n;\n    \tsegtree.update(0, 0, n);\n    \t\n    \tTreeSet\u0026lt;Integer\u0026gt; startTree \u003d new TreeSet\u0026lt;Integer\u0026gt;();\n    \tstartTree.add(0);\n    \t\n    \tfor (int i \u003d 0; i \u0026lt; m; i++) {\n    \t\tst \u003d new StringTokenizer(r.readLine());\n    \t\tif (st.nextToken().equals(\u0026quot;A\u0026quot;)) { //Should be log n\n    \t\t\t//group arrives\n    \t\t\tint size \u003d Integer.parseInt(st.nextToken());\n    \t\t\t//Binary search on the index for which to place this group.\n    \t\t\tint start \u003d segtree.getIndex(size);\n    \t\t\t\n    \t\t\tif (start \u003d\u003d -1) {\n    \t\t\t\tanswer++;\n    \t\t\t\tcontinue;\n    \t\t\t}\n    \t\t\t\n    \t\t\t//the segment that has start point at integer \u0026quot;start\u0026quot; is the one that group will sit in.\n    \t\t\tif (size + start \u0026lt; n)\n    \t\t\tvacant[size + start] \u003d vacant[start] - size;\n    \t\t\tstartTree.remove(start);\n    \t\t\t\n    \t\t\tif (size + start \u0026lt; n \u0026amp;\u0026amp; vacant[size + start] !\u003d 0) startTree.add(size + start);\n    \t\t\t\n    \t\t\tif (size + start \u0026lt; n)\n    \t\t\tsegtree.update(size + start, size + start, vacant[size + start] - segtree.query(size + start, size + start));\n    \t\t\tsegtree.update(start, start, -segtree.query(start, start));\n    \t\t\t\n    \t\t\tvacant[start] \u003d 0;\n    \t\t} else { //Should be amortized O(log n) because each segment is only checked once, and if there are collisions the other\n    \t\t\t//segments get merged and shouldn\u0027t be seen again\n    \t\t\t\n    \t\t\t//get out of here cows\n    \t\t\tint start \u003d Integer.parseInt(st.nextToken()) - 1;\n    \t\t\tint end \u003d Integer.parseInt(st.nextToken()) - 1;\n\n    \t\t\t//first check to see if we are covered.\n    \t\t\tif (startTree.contains(start)) {\n    \t\t\t\tif (end - start + 1 \u0026lt;\u003d vacant[start]) continue;\n    \t\t\t\tstartTree.remove(start);\n    \t\t\t\tvacant[start] \u003d 0;\n    \t\t\t\tsegtree.update(start, start, -segtree.query(start, start));\n    \t\t\t}\n    \t\t\t\n    \t\t\tboolean modified \u003d true;\n    \t\t\t\n    \t\t\t//check to the left and right and merge any intervals\n    \t\t\twhile (modified) {\n    \t\t\t\tmodified \u003d false;\n    \t\t\t\tInteger left \u003d startTree.lower(start);\n    \t\t\t\tInteger right \u003d startTree.higher(start);\n    \t\t\t\t\n    \t\t\t\tint leftend \u003d 0;\n    \t\t\t\tint rightend \u003d 0;\n    \t\t\t\t\n    \t\t\t\tif (left !\u003d null) leftend \u003d vacant[left] + left - 1;\n    \t\t\t\tif (right !\u003d null) rightend \u003d vacant[right] + right - 1;\n    \t\t\t\tif (left !\u003d null \u0026amp;\u0026amp; left \u0026lt;\u003d start \u0026amp;\u0026amp; start \u0026lt;\u003d leftend) {\n    \t\t\t\t\t//They intersect\n    \t\t\t\t\tstart \u003d Math.min(start, left);\n    \t\t\t\t\tend \u003d Math.max(end, leftend);\n    \t\t\t\t\tmodified \u003d true;\n    \t\t\t\t\tstartTree.remove(left);\n    \t\t\t\t\tsegtree.update(left, left, -segtree.query(left, left));\n    \t\t\t\t\tvacant[left] \u003d 0;\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tif (right !\u003d null \u0026amp;\u0026amp; right \u0026lt;\u003d end \u0026amp;\u0026amp; end \u0026lt;\u003d rightend) {\n    \t\t\t\t\tstart \u003d Math.min(start, right);\n    \t\t\t\t\tend \u003d Math.max(end, rightend);\n    \t\t\t\t\tmodified \u003d true;\n    \t\t\t\t\tstartTree.remove(right);\n    \t\t\t\t\tsegtree.update(right, right, -segtree.query(right, right));\n    \t\t\t\t\tvacant[right] \u003d 0;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\t\n    \t\t\tstartTree.add(start);\n    \t\t\tvacant[start] \u003d end - start + 1;\n    \t\t\tsegtree.update(start, start, vacant[start] - segtree.query(start, start));\n    \t\t}\n    \t\t\n    \t}\n    \t\n    \tw.println(answer);\n    \tw.flush();\n\t}\n\t\n\t\n\tpublic static class Segtree {\n\t\t\n\t\tpublic long[] tree; // bottom row\n\t\tpublic long[] lazy;\n\t\tpublic int size;\n\t\tpublic boolean[] leaf;\n\t\tpublic int[] index;\n\n\t\tpublic Segtree(long[] base) {\n\t\t\tsize \u003d base.length;\n\t\t\ttree \u003d new long[4 * base.length + 10];\n\t\t\tlazy \u003d new long[4 * base.length + 10];\n\t\t\tleaf \u003d new boolean[4 * base.length + 10];\n\t\t\tindex \u003d new int[4 * base.length + 10];\n\t\t\tmakeTree(1, 0, base.length - 1, base);\n\t\t}\n\n\t\tpublic void makeTree(int current, int start, int end, long[] base) {\n\t\t\tif (start \u003d\u003d end) {\n\t\t\t\ttree[current] \u003d base[start];\n\t\t\t\tleaf[current] \u003d true;\n\t\t\t\tindex[current] \u003d start;\n\t\t\t} else {\n\t\t\t\tint mid \u003d (start + end) / 2;\n\t\t\t\tmakeTree(2 * current, start, mid, base);\n\t\t\t\tmakeTree(2 * current + 1, mid + 1, end, base);\n\t\t\t\ttree[current] \u003d Math.max(tree[2 * current], tree[2 * current + 1]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//[start, end]\n\t\tpublic void update(int start, int end, long value) {\n\t\t\tupdate(1, 0, size - 1, start, end, value);\n\t\t}\n\t\t\n\t\tpublic void update(int current, int left, int right, int start, int end, long val) {\n\t\t\tif (left \u0026gt;\u003d start \u0026amp;\u0026amp; right \u0026lt;\u003d end) {\n\t\t\t\tlazy[current] +\u003d val;\n\t\t\t\tif (leaf[current]) {\n\t\t\t\t\ttree[current] \u003d val;\n\t\t\t\t\tlazy[current] -\u003d val;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint updateLeft \u003d Math.max(start, left);\n\t\t\t\tint updateRight \u003d Math.min(end, right);\n\t\t\t\t//sorry for the tricky stuff on the next line. It should work, but only because my updates start and end are the same\n\t\t\t\ttree[current] \u003d Math.max(query(current, left, right, updateLeft, updateRight) + val, Math.max(query(current, left, right, left, updateLeft - 1), query(current, left, right, updateRight + 1, right))); \n\t\t\t\tint mid \u003d (left + right) / 2;\n\t\t\t\t\n\t\t\t\tif (mid \u0026gt;\u003d start \u0026amp;\u0026amp; left \u0026lt;\u003d end) {\n\t\t\t\t\tupdate(2 * current, left, mid, start, end, val);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (right \u0026gt;\u003d start \u0026amp;\u0026amp; mid + 1 \u0026lt;\u003d end) {\n\t\t\t\t\tupdate(2 * current + 1, mid + 1, right, start, end, val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//[start, end]\n\t\tpublic long query(int start, int end) {\n\t\t\tif (start \u0026gt; end) return 0 / 4;\n\t\t\treturn query(1, 0, size - 1, start, end);\n\t\t}\n\t\t\n\t\tpublic long query(int current, int left, int right, int start, int end) {\n\t\t\tif (left \u0026gt;\u003d start \u0026amp;\u0026amp; right \u0026lt;\u003d end) {\n\t\t\t\tif (lazy[current] !\u003d 0) {\n\t\t\t\t\ttree[current] +\u003d lazy[current];\n\t\t\t\t\t\n\t\t\t\t\tif (2 * current \u0026lt; lazy.length) { //if it is not a base node\n\t\t\t\t\t\tlazy[2 * current] +\u003d lazy[current];\n\t\t\t\t\t\tlazy[2 * current + 1] +\u003d lazy[current];\n\t\t\t\t\t}\n\t\t\t\t\tlazy[current] \u003d 0;\n\t\t\t\t}\n\t\t\t\treturn tree[current];\n\t\t\t} else {\n\t\t\t\ttree[current] +\u003d lazy[current];\n\t\t\t\t\n\t\t\t\tif (2 * current \u0026lt; lazy.length) {\n\t\t\t\t\tlazy[2 * current] +\u003d lazy[current];\n\t\t\t\t\tlazy[2 * current + 1] +\u003d lazy[current];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlazy[current] \u003d 0;\n\t\t\t\tint mid \u003d (left + right) / 2;\n\t\t\t\tlong answer \u003d 0;\n\t\t\t\t\n\t\t\t\tif (mid \u0026gt;\u003d start \u0026amp;\u0026amp; left \u0026lt;\u003d end) {\n\t\t\t\t\tanswer \u003d Math.max(answer, query(2 * current, left, mid, start, end));\n\t\t\t\t}\n\t\t\t\tif (right \u0026gt;\u003d start \u0026amp;\u0026amp; mid + 1 \u0026lt;\u003d end) {\n\t\t\t\t\tanswer \u003d Math.max(answer, query(2 * current + 1, mid + 1, right, start, end));\n\t\t\t\t}\n\t\t\t\treturn answer;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int getIndex(int size) {\n\t\t\tint current \u003d 1;\n\t\t\tif (tree[current] \u0026lt; size) return -1;\n\t\t\t\n\t\t\twhile (!leaf[current]) {\n\t\t\t\tif (tree[2 * current] \u0026gt;\u003d size) {\n\t\t\t\t\tcurrent \u003d 2 * current;\n\t\t\t\t} else {\n\t\t\t\t\tcurrent \u003d 2 * current + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn index[current];\n\t\t}\n\t}\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ePlease help. I would really appreciate it. Thank you!\u003c/p\u003e\u003cp\u003eEdit: added a few lines, but the result didn\u0027t change.\u003c/p\u003e\u003c/div\u003e","tags":["help","usaco","hardproblem","tle"]}}