{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1434938673,"rating":3,"authorHandle":"siddv","modificationTimeSeconds":1434938944,"id":18784,"title":"\u003cp\u003eWriting Code — CF round 302 problem\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eSo I recently solved this problem and learned a lot. Being not an expert in DP, I struggled to understand the editorial. So I read the comments and found \u003ca href\u003d\"//codeforces.com/profile/ediston\"\u003eediston\u0027s\u003c/a\u003e blog on this problem. Even though I understood his blog, somehow I thought there is a need to complement his writing so here I have a more detailed explanation of the problem.\u003c/p\u003e\u003cp\u003eThe most naive approach for this problem.\u003c/p\u003e\u003cp\u003edp[i][j][k] \u003d ways of using first i programmers to write j lines of code and have k total bugs. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (int i \u003d 1; i \u0026lt;\u003d n; i++) {\n\tfor (int j \u003d 1; j \u0026lt;\u003d m; j++) {\n\t\tfor (int k \u003d 0; k \u0026lt;\u003d b; k++) {\n\t\t\tdp[i][j][k] \u003d dp[i - 1][j][k];\n\t\t\tfor (int l \u003d 1; l \u0026lt;\u003d j; l++) {\n\t\t\t\tif (k - (l * bpp[i - 1]) \u0026gt;\u003d 0) {\n\t\t\t\t\tdp[i][j][k] +\u003d dp[i - 1][j - l][k- (l * bpp[i - 1])];\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][j][k] \u003d dp[i][j][k] % MOD;\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis one will TLE \u0026amp; MLE both. Lets optimize it till it passes the time and memory constraints. To overcome TLE lets modify it to the following code snippet:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (int i \u003d 1; i \u0026lt;\u003d n; i++) {\n\tfor (int j \u003d 1; j \u0026lt;\u003d m; j++) {\n\t\tfor (int k \u003d 0; k \u0026lt;\u003d b; k++) {\n\t\t\tdp[i][j][k] \u003d dp[i - 1][j][k];\n\t\t\tif (k - bpp[i - 1] \u0026gt;\u003d 0) {\n\t\t\t\tdp[i][j][k] +\u003d dp[i][j - 1][k - bpp[i - 1]];\n\t\t\t}\n\t\t\tdp[i][j][k] %\u003d MOD;\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo in the above snippet, when we iterate for the ith programmer, either he writes 0 lines which correspond to dp[i][j][k] \u003d dp[i — 1][j][k] OR he writes 1 or more lines which correspond to the if statement inside the innermost for loop. This if statement needs more explanation.\u003c/p\u003e\u003cp\u003eSince the ith programmer has already written at least one line of code, we add dp[i][j — 1][k — bpp[i — 1]] (instead of dp[i — 1][j — 1][k — bpp[i — 1]]) to dp[i][j][k]. It\u0027s like we have already used 1 to i programmers.\u003c/p\u003e\u003cp\u003eEven though we have optimized the time constraints, we haven\u0027t optimized the memory constraints. From the snippet it should be clear that we only need the current 2D array and the previous 2D array, so we can replace dp[n][m][b] with dp[2][m][b] and it should get accepted. \u003c/p\u003e\u003cp\u003eHowever we can further reduce the memory to just dp[m][b]. And this is precisely the approach explained by ediston in his \u003ca href\u003d\"//codeforces.com/blog/entry/17783\"\u003eblog\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e","tags":["dp"]}}