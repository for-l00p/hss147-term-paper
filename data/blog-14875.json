{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1417000384,"rating":-14,"authorHandle":"dustbite","modificationTimeSeconds":1417002352,"id":14875,"title":"\u003cp\u003eSuffix Array / Manber and Myers Algo\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e(Actually this is a question) So I thought I knew the intuition behind the Manber and Myers algorithm. Here is what I understood.\u003c/p\u003e\u003cp\u003eSuppose the string is \u0026quot;banana\u0026quot;\u003c/p\u003e\u003cp\u003eWe first partition the suffixes in terms of similar first character as\u003c/p\u003e\u003cp\u003ea, anana, ana \u003d\u0026gt; bucket 1\u003c/p\u003e\u003cp\u003ebanana \u003d\u0026gt; bucket 2\u003c/p\u003e\u003cp\u003ena, nana \u003d\u0026gt; bucket 3\u003c/p\u003e\u003cp\u003eThen to get the partition by the next 2h characters, my algo is:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003escan each bucket one by one\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003etake the first bucket\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003efor each suffix in this bucket, find the position of sa + 2h, if we go out of bounds assign position \u003d 0 \u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eSo picture looks like this:\u003c/p\u003e\u003cp\u003ea \u003d 0, anana \u003d 3, ana \u003d 3 (since a + 1 \u0026gt; n, nana is in 3rd bucket and na is also in third bucket)\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eNow, sort the assigned indices of the bucket using counting sort.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eScan the new indices one by one and create new partitions, here we get\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003e[a], [anana, ana]\u003c/p\u003e \u003col\u003e   \u003cli\u003eDo this until buckets \u003d n\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eMy problem is in 4th part, where I use counting sort.\u003c/p\u003e\u003cp\u003eFirst I coded as I had thought that I had understood the algorithm. But then I ran into trouble. As the number of buckets goes on increasing during each iteration, my algorithm approaches O(n^2) (as I assign ranks during counting sort according to the location of s + 2h suffix). So with some modification to the algorithm can I get O(nlogn)? If not what should I do? \u003c/p\u003e\u003cp\u003eOk. I removed the code. So please answer me now.\u003c/p\u003e\u003c/div\u003e","tags":["suffix array","manber","myers"]}}