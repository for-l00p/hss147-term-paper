{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1476187940,"rating":0,"authorHandle":"kb.","modificationTimeSeconds":1476187940,"id":47669,"title":"\u003cp\u003eМоё решение C\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cpre\u003e\u003ccode\u003e#define _CRT_SECURE_NO_WARNINGS\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;bitset\u0026gt;\n#include \u0026lt;complex\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;ctime\u0026gt;\nusing namespace std;\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define eprintf(...) (void)0\n#endif\n\ntypedef long long ll;\nconst int N \u003d 400500;\nconst int MOD \u003d (int)1e9 + 7;\nconst int SZ \u003d 2;\nconst int P[SZ] \u003d { 17239, 31 };\n\nint add(int a, int b)\n{\n\ta +\u003d b;\n\tif (a \u0026gt;\u003d MOD)\n\t\ta -\u003d MOD;\n\treturn a;\n}\nint sub(int a, int b)\n{\n\ta -\u003d b;\n\tif (a \u0026lt; 0)\n\t\ta +\u003d MOD;\n\treturn a;\n}\nint mul(int a, int b)\n{\n\treturn (ll)a * b % MOD;\n}\n\nint pow_p[SZ][N];\n\nstruct Hash\n{\n\tint a[SZ];\n\tHash() : a() {}\n\tHash(char c)\n\t{\n\t\tfor (int i \u003d 0; i \u0026lt; SZ; i++)\n\t\t\ta[i] \u003d c - \u0027a\u0027 + 1;\n\t}\n\tint \u0026amp;operator[](int p)\n\t{\n\t\treturn a[p];\n\t}\n\tint operator[](int p) const\n\t{\n\t\treturn a[p];\n\t}\n\tHash operator+(const Hash \u0026amp;b)\n\t{\n\t\tHash c;\n\t\tfor (int i \u003d 0; i \u0026lt; SZ; i++)\n\t\t\tc[i] \u003d add(a[i], b[i]);\n\t\treturn c;\n\t}\n\tHash operator-(const Hash \u0026amp;b)\n\t{\n\t\tHash c;\n\t\tfor (int i \u003d 0; i \u0026lt; SZ; i++)\n\t\t\tc[i] \u003d sub(a[i], b[i]);\n\t\treturn c;\n\t}\n\tHash up(int p)\n\t{\n\t\tHash c;\n\t\tfor (int i \u003d 0; i \u0026lt; SZ; i++)\n\t\t\tc[i] \u003d mul(a[i], pow_p[i][p]);\n\t\treturn c;\n\t}\n\tbool operator\u003d\u003d(const Hash \u0026amp;b) const\n\t{\n\t\tfor (int i \u003d 0; i \u0026lt; SZ; i++)\n\t\t\tif (a[i] !\u003d b[i])\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n};\n\nvector\u0026lt;Hash\u0026gt; build_hash(const string \u0026amp;s)\n{\n\tint n \u003d (int)s.length();\n\tvector\u0026lt;Hash\u0026gt; res(n);\n\tHash cur;\n\tfor (int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tcur \u003d cur + Hash(s[i]).up(i);\n\t\tres[i] \u003d cur;\n\t}\n\treturn res;\n}\n\nHash get_hash(const vector\u0026lt;Hash\u0026gt; \u0026amp;h, int l, int r)\n{\n\tHash s \u003d h[r];\n\tif (l \u0026gt; 0)\n\t\ts \u003d s - h[l - 1];\n\treturn s.up(N - 1 - l);\n}\n\nbool is_less(const vector\u0026lt;Hash\u0026gt; \u0026amp;h, const string \u0026amp;s, int a, int b)\n{\n\tint n \u003d (int)s.length();\n\tint left \u003d 0, right \u003d n - max(a, b) + 1;\n\twhile (right - left \u0026gt; 1)\n\t{\n\t\tint mid \u003d (left + right) / 2;\n\t\tif (get_hash(h, a, a + mid - 1) \u003d\u003d get_hash(h, b, b + mid - 1))\n\t\t\tleft \u003d mid;\n\t\telse\n\t\t\tright \u003d mid;\n\t}\n\tchar ca \u003d a + left \u0026lt; n ? s[a + left] : 0;\n\tchar cb \u003d b + left \u0026lt; n ? s[b + left] : 0;\n\treturn ca \u0026lt; cb;\n}\n\nvector\u0026lt;int\u0026gt; calc_z(const string \u0026amp;s)\n{\n\tint n \u003d (int)s.length();\n\tvector\u0026lt;int\u0026gt; z(n);\n\tint l \u003d 0, r \u003d -1;\n\tfor (int i \u003d 1; i \u0026lt; n; i++)\n\t{\n\t\tif (i \u0026lt;\u003d r)\n\t\t\tz[i] \u003d min(r - i + 1, z[i - l]);\n\t\twhile (i + z[i] \u0026lt; n \u0026amp;\u0026amp; s[z[i]] \u003d\u003d s[i + z[i]])\n\t\t\tz[i]++;\n\t\tif (i + z[i] - 1 \u0026gt; r)\n\t\t{\n\t\t\tl \u003d i;\n\t\t\tr \u003d i + z[i] - 1;\n\t\t}\n\t}\n\treturn z;\n}\n\nbool check(const string \u0026amp;s, int pref)\n{\n\tstring t \u003d s.substr(0, pref);\n\tt \u003d t + t;\n\tauto hashes \u003d build_hash(t);\n\tint best \u003d 0;\n\tfor (int i \u003d 1; i \u0026lt; pref; i++)\n\t\tif (is_less(hashes, t, i, best))\n\t\t\tbest \u003d i;\n\tt \u003d t.substr(best, pref);\n\n\tstring text \u003d t + (char)(\u0027z\u0027 + 1);\n\tfor (int i \u003d pref; i \u0026lt; (int)s.length(); i +\u003d pref)\n\t{\n\t\tstring x \u003d s.substr(i, pref);\n\t\ttext +\u003d x;\n\t\ttext +\u003d x;\n\t}\n\n\tauto z \u003d calc_z(text);\n\tfor (int i \u003d (int)t.length() + 1; i \u0026lt; (int)text.length(); i +\u003d 2 * pref)\n\t{\n\t\tbool any \u003d false;\n\t\tfor (int j \u003d 0; j \u0026lt; pref; j++)\n\t\t\tany |\u003d z[i + j] \u0026gt;\u003d (int)t.length();\n\t\tif (!any)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid solve()\n{\n\tfor (int d \u003d 0; d \u0026lt; SZ; d++)\n\t{\n\t\tpow_p[d][0] \u003d 1;\n\t\tfor (int i \u003d 1; i \u0026lt; N; i++)\n\t\t\tpow_p[d][i] \u003d mul(pow_p[d][i - 1], P[d]);\n\t}\n\n\tstring s;\n\tcin \u0026gt;\u0026gt; s;\n\n\tint n \u003d (int)s.length();\n\tvector\u0026lt;int\u0026gt; res;\n\tfor (int d \u003d 1; d \u0026lt;\u003d n; d++)\n\t\tif (n % d \u003d\u003d 0)\n\t\t\tif (check(s, d))\n\t\t\t\tres.push_back(n / d);\n\n\tsort(res.begin(), res.end());\n\tprintf(\u0026quot;%d\\n\u0026quot;, (int)res.size());\n\tfor (int e : res)\n\t\tprintf(\u0026quot;%d \u0026quot;, e);\n\tprintf(\u0026quot;\\n\u0026quot;);\n}\n\nint main()\n{\n#ifdef LOCAL\n\tfreopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;output.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n#else\n\tfreopen(\u0026quot;kdivision.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\tfreopen(\u0026quot;kdivision.out\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n#endif\n\n\tsolve();\n\n\teprintf(\u0026quot;\\n\\ntime: %.3lf\\n\u0026quot;, (double)clock() / CLOCKS_PER_SEC);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}