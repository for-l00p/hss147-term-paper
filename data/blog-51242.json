{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1490610282,"rating":0,"authorHandle":"xsc","modificationTimeSeconds":1490610282,"id":51242,"title":"\u003cp\u003eI love Pascal\u0027s read | write input/output procedures.\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003ePure C have scanf and printf, gets , getchar, ... puts, putchar functions.\u003c/p\u003e\u003cp\u003eC++ have std::cin, std::cout iostream objects ...\u003c/p\u003e\u003cp\u003eBut, I\u0027d like Pascal\u0027s \u003ccode\u003eread\u003c/code\u003e and \u003ccode\u003ewrite\u003c/code\u003e functions, they are easy to write and easy to understand.\u003c/p\u003e\u003cp\u003eSo, why we can\u0027t emulate \u003ccode\u003eread\u003c/code\u003e and \u003ccode\u003ewrite\u003c/code\u003e in C++ and C++11 ?!\u003c/p\u003e\u003cp\u003eGo...\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eread\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e// write basic types: int, long long, double , and string\nint read(int\u0026amp; a) { return scanf(\u0026quot;%d\u0026quot;,\u0026amp;a);}\n\nint read(long long\u0026amp; a) { return scanf(\u0026quot;%lld\u0026quot;,\u0026amp;a);}\nint read(char\u0026amp;c){ return (c \u003d getchar()), 1; }\nint read(double\u0026amp; a) { return scanf(\u0026quot;%lf\u0026quot;,\u0026amp;a);}\nint read(char s[], int n){  return fgets(s, n, stdin) !\u003d 0;}\ntemplate\u0026lt;size_t n\u0026gt; int read(char (\u0026amp;s)[n]){ return read((char*)s, n);}\nint read(string\u0026amp;s){int c ; while((c \u003d getchar()) !\u003d \u0027\\n\u0027 \u0026amp;\u0026amp; c !\u003d EOF)s+\u003d(char)c; return 1;}\n\n// now generalize for all situations, C++11 variadic template helps us.\ntemplate\u0026lt;typename ... T\u0026gt;\nint read(T\u0026amp; ... a)\n{\n    using shadow \u003d int[];\n    shadow sh \u003d {read(a) ...};\n    return sizeof(sh)/sizeof(sh[0]);\n}\n\n\n//usage: \nint main(){\n\nint a,b,c,d,e;\nread(a,b,c,d,e);\n\nprintf(\u0026quot;max is : %d\\n\u0026quot;, max({a,b,c,d,e});\n\nreturn 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ewrite\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eint write(int a){return printf(\u0026quot;%d\u0026quot;, a);}\nint write(ll a){ return printf(\u0026quot;%lld\u0026quot;, a);}\nint write(double f){ return printf(\u0026quot;%.8f\u0026quot;, f);}\nint write(char c){return printf(\u0026quot;%c\u0026quot;,c);}\nint write(const char * s){ return printf(\u0026quot;%s\u0026quot;,s);}\nint write(string const\u0026amp; s){ return write(s.c_str());}\n\n\n// Generalize for all situations.\ntemplate\u0026lt;typename ...T\u0026gt;\nint write(T const\u0026amp; ... a)\n{\n    using shadow \u003d int[];\n    shadow sh \u003d {write(a)...};\n    return sizeof(sh) / sizeof(sh[0]);\n}\n\n// writeln \u003d\u003d write  +  line break .\ntemplate\u0026lt;typename ... T\u0026gt;\nint writeln(T const\u0026amp; ... a){ writeln(a..., \u0027\\n\u0027);}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["c++ vs pascal","input","output","c Ð¸ c++"]}}