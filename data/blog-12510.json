{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1401621795,"rating":27,"authorHandle":"andrewzta","modificationTimeSeconds":1401621828,"id":12510,"title":"\u003cp\u003eRCC 2014 Qual 4 — Разбор задач\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eЗадача А. Соцопрос.\u003c/h2\u003e\u003cp\u003e\u003cb\u003eИдея:\u003c/b\u003e Андрей Станкевич.\u003cbr /\u003e \u003cb\u003eРеализация:\u003c/b\u003e Николай Ведерников.\u003cbr /\u003e \u003cb\u003eРазбор:\u003c/b\u003e Николай Ведерников.\u003cbr /\u003e \u003c/p\u003e\u003cp\u003e В задаче требуется найти минимальное и макимальное возможное количество участников, которые решат задачу. Если всего участников \u003ci\u003en\u003c/i\u003e, умеют решать задачу \u003ci\u003ea\u003c/i\u003e, а задача противна \u003ci\u003eb\u003c/i\u003e участникам. \u003c/p\u003e \u003cp\u003e Так как по условию задачи задачу решат только те, кому она не противна и умеют решать, то максимум, кто попытается решить задачу будет \u003ci\u003en\u003c/i\u003e−\u003ci\u003eb\u003c/i\u003e. То есть если среди всех кто попытается решить задачу, будут те кто умеет, то это будет максимум кто решит, а это min(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e−\u003ci\u003eb\u003c/i\u003e). \u003c/p\u003e \u003cp\u003e Минимум же достигается, если все кому противна задача, будут уметь решать задачу, тогда ответ max(0, \u003ci\u003ea\u003c/i\u003e−\u003ci\u003eb\u003c/i\u003e) \u003c/p\u003e \u003ch2\u003eЗадача B. Сто.\u003c/h2\u003e\u003cp\u003e\u003cb\u003eИдея:\u003c/b\u003e Виталий Аксёнов.\u003cbr /\u003e \u003cb\u003eРеализация:\u003c/b\u003e Павел Кротков.\u003cbr /\u003e \u003cb\u003eРазбор:\u003c/b\u003e Павел Кротков.\u003cbr /\u003e \u003c/p\u003e\u003cp\u003e Решением задачи является программа, аккуратно рассматривающая несколько несложных случаев. Самым простым случаем является ситуация, когда количество цифр в числе \u003ci\u003ex\u003c/i\u003e равно \u003ci\u003ek\u003c/i\u003e+1. В этом случае необходимо вывести −1, если число не содержит ни одного нуля, и ноль — если хотя бы один ноль в числе присутствует. \u003c/p\u003e \u003cp\u003e Если же количество чисел в числе \u003ci\u003ex\u003c/i\u003e превышает \u003ci\u003ek\u003c/i\u003e хотя бы на три, эту ситуацию необходимо обрабатывать более аккуратно. Найдем в числе второй ноль с конца. Убедимся, что за ним стоит не более, чем \u003ci\u003ek\u003c/i\u003e+1 цифра. Вычеркнем из числа все ненулевые цифры, стоящие за вторым с конца нулем, а также вычеркнем необходимое количество цифр, стоящих сразу перед вторым с конца нулем. Заметим, что первая цифра никогда не вычеркивается, а значит, в итоговом числе не будет ведущих нулей. \u003c/p\u003e \u003cp\u003e Важно было не забыть о том, что операция вычеркивания цифры не должна выполняться за длину числа — решения с такой ошибкой получили превышение предела времени на третьем тесте. \u003c/p\u003e \u003ch2\u003eЗадача C. Поход в гости.\u003c/h2\u003e\u003cp\u003e\u003cb\u003eИдея:\u003c/b\u003e Георгий Корнеев.\u003cbr /\u003e \u003cb\u003eРеализация:\u003c/b\u003e Борис Минаев.\u003cbr /\u003e \u003cb\u003eРазбор:\u003c/b\u003e Борис Минаев.\u003cbr /\u003e \u003c/p\u003e\u003cp\u003e Чтобы решить поставленную задачу необходимо аккуратно проэмулировать процесс, который описан в условии. При реализации удобно использовать встроенные средства для поддержания очереди. В самих очередях можно хранить, например, номер человека, который купил соответствующий подарок. Тогда очередной поход в гости происходит следующим образом. Возьмем элемент из очереди, которая соответствует человеку, идущему в гости. Если его очередь пуста, то будем считать, что из очереди был взят элемент, который соответствует этому человеку. После этого добавим данный элемент в очередь, которая соответствует человеку, к которому пришли в гости. Если значение добавленного элемента равно номеру очереди, в которую его добавили, необходимо вывести YES, иначе NO. \u003c/p\u003e \u003ch2\u003eЗадача D. СНМ.\u003c/h2\u003e\u003cp\u003e\u003cb\u003eИдея:\u003c/b\u003e Артем Васильев \u003cbr /\u003e \u003cb\u003eРеализация:\u003c/b\u003e Артем Васильев \u003cbr /\u003e \u003cb\u003eРазбор:\u003c/b\u003e Артем Васильев \u003cbr /\u003e \u003c/p\u003e\u003cp\u003e В задаче была описана реализация системы непересекающихся множеств с ранговой эвристикой, но без эвристики сжатия путей. Будем решать задачу для каждого корневого дерева независимо, также следует рассмотреть случай наличия циклов. \u003c/p\u003e \u003cp\u003e Хоть массив \u003ci\u003erank\u003c/i\u003e и не задавался во входных данных, легко понять, что без сжатия путей, \u003ci\u003erank\u003csub\u003ei\u003c/sub\u003e\u003c/i\u003e это высота поддерева с вершиной \u003ci\u003ei\u003c/i\u003e в корне. Также отметим, алгоритм устроен так, что \u003ci\u003erank\u003csub\u003ei\u003c/sub\u003e\u003c/i\u003e каждый раз увеличивается не более, чем на единицу, а после того, как вершина подвешивается к другой, ее \u003ci\u003eparent\u003c/i\u003e и \u003ci\u003erank\u003c/i\u003e не изменяются, поэтому можно строить от листьев к корню. \u003c/p\u003e \u003cp\u003e Рассмотрим поддерево с корнем в вершине \u003ci\u003eu\u003c/i\u003e. Если \u003ci\u003erank\u003csub\u003eu\u003c/sub\u003e\u003c/i\u003e \u003d \u003ci\u003er\u003c/i\u003e, то у вершины \u003ci\u003eu\u003c/i\u003e должны существовать дети с рангом 0, 1, ..., \u003ci\u003er\u003c/i\u003e-1. Легко показать, что это условие является также достаточным: если провести операции \u003ci\u003eunion\u003c/i\u003e в порядке увеличения ранга сына, все операции пройдут корректно. \u003c/p\u003e \u003cp\u003e Отсюда следует решение для одного дерева: \u003c/p\u003e\u003cul\u003e \u003cli\u003e Рекурсивно построим решение для всех детей корня дерева. \u003c/li\u003e \u003cli\u003e Проверим, что для всех \u003ci\u003eh\u003c/i\u003e от 0 до \u003ci\u003erank\u003csub\u003eroot\u003c/sub\u003e\u003c/i\u003e — 1 существует сын с рангом \u003ci\u003eh\u003c/i\u003e. \u003c/li\u003e \u003cli\u003e Проделаем операции \u003ci\u003eunion\u003c/i\u003e(\u003ci\u003eroot\u003c/i\u003e, \u003ci\u003echild\u003csub\u003ei\u003c/sub\u003e\u003c/i\u003e) в порядке увеличения ранга \u003ci\u003echild\u003csub\u003ei\u003c/sub\u003e\u003c/i\u003e. \u003c/li\u003e \u003c/ul\u003e Также возможно реализовать СНМ и непосредственно проделать все операции, проверив, что получившийся массив \u003ci\u003eparent\u003c/i\u003e совпал с нужным.  \u003cp\u003e Время работы решения — \u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e log (\u003ci\u003en\u003c/i\u003e)). \u003c/p\u003e \u003ch2\u003eЗадача E. Нанороботы.\u003c/h2\u003e\u003cp\u003e\u003cb\u003eИдея:\u003c/b\u003e Виталий Аксёнов.\u003cbr /\u003e \u003cb\u003eРеализация:\u003c/b\u003e Андрей Комаров.\u003cbr /\u003e \u003cb\u003eРазбор:\u003c/b\u003e Андрей Комаров.\u003cbr /\u003e \u003c/p\u003e\u003cp\u003e В задаче требуется за минимальное число действий перемещения или разбиения на две части перевести всех нанороботов из левого верхнего угла в правый нижний. \u003c/p\u003e \u003cp\u003e Будем решать эту задачу при помощи динамического программирования. Обозначим за \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ew\u003c/i\u003e][\u003ci\u003ex\u003c/i\u003e][\u003ci\u003ey\u003c/i\u003e] минимальное число шагов, за которое можно довести робота массой \u003ci\u003ew\u003c/i\u003e из клетки (\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e) до финальной клетки (\u003ci\u003en\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e). Начальные значения \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ew\u003c/i\u003e][\u003ci\u003en\u003c/i\u003e][\u003ci\u003em\u003c/i\u003e] \u003d 0 говорят о том, что из целевой клетки идти никуда не надо. После того, как \u003ci\u003edp\u003c/i\u003e будет посчитано, ответ будет содержаться в ячейке \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ew\u003c/i\u003e][1][1]. \u003c/p\u003e \u003cp\u003e Научимся считать \u003ci\u003edp\u003c/i\u003e. Чтобы посчитать \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ew\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e], сделаем одно из двух: \u003c/p\u003e\u003cul\u003e \u003cli\u003eДойдём до финиша, не разбивая робота на части. Для этого, с помощью обхода в глубину, найдём кратчайший путь до финиша по выдерживающим клеткам. \u003c/li\u003e\u003cli\u003eЛибо, дойдём до какой-то клетки, разобъёмся на две части и дойдём ими оттуда. \u003c/li\u003e\u003c/ul\u003e Чтобы не было проблем с пониманием того, в каком порядке считать значения динамики, можно считать её лениво. Итоговая сложность алгоритма: \u003ci\u003eO\u003c/i\u003e(\u003ci\u003ew\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e\u003ci\u003en\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e\u003ci\u003em\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e).\u003c/div\u003e","tags":[]}}