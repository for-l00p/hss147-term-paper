{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1425148818,"rating":129,"authorHandle":"cgy4ever","modificationTimeSeconds":1425154121,"id":16692,"title":"\u003cp\u003eShort Editorial of SRM 651 Div1\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello, I\u0027m the writer of SRM 651.\u003c/p\u003e\u003cp\u003eIt turns out this round is unrated due to some system failure. Sorry about the inconvenience it caused. I hope Topcoder can improve their infrastructure soon so that can be as good as codeforces.\u003c/p\u003e\u003cp\u003eI will post the problem statement, reference solution and a short editorial here.\u003c/p\u003e\u003cp\u003eWelcome to discuss the tasks, as well as to give feedback about them!\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem Statement\u003c/strong\u003e: \u003ca href\u003d\"http://www.speedyshare.com/2kRaC/task.rar\"\u003ehttp://www.speedyshare.com/2kRaC/task.rar\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eReference solution\u003c/strong\u003e: \u003c/p\u003e\u003cp\u003eDiv1-Easy: \u003ca href\u003d\"http://ideone.com/a9siv1\"\u003ehttp://ideone.com/a9siv1\u003c/a\u003e\u003c/p\u003e\u003cp\u003eDiv1-Medium: \u003ca href\u003d\"http://ideone.com/sbEZSH\"\u003ehttp://ideone.com/sbEZSH\u003c/a\u003e\u003c/p\u003e\u003cp\u003eDiv1-Hard: \u003ca href\u003d\"http://ideone.com/9JXoSL\"\u003ehttp://ideone.com/9JXoSL\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDiv1-Easy: RobotOnMoon\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eLook at this example:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e....\n.S.#\n....\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThere will be infinite long perfect safe sequence, why? because we have \u0026quot;RRR...\u0026quot;. That means if there is one \u0027#\u0027 at any of the 4 direction of \u0027S\u0027, then the answer will be -1..\u003c/p\u003e\u003cp\u003eThen look at this example:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#.##\n.S..\n#.##\n#.##\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003esince there is only 1 cell to the left of \u0027S\u0027, there can be at most 1 \u0027L\u0027 in any perfect safe sequence, otherwise if all characters other than \u0027L\u0027 are missing, it will lead the robot to die. So we can have a maximal bound of length of any perfect safe sequence: we have at most 1 \u0027L\u0027, at most 2 \u0027R\u0027, at most 1 \u0027U\u0027 and at most 2 \u0027D\u0027. And we could find \u0026quot;LRRUDD\u0026quot; is perfectly safe: we have only 1 \u0027L\u0027 so it is impossible to move outside the board from the left edge, etc.\u003c/p\u003e\u003cp\u003eSo if the answer is not -1, then it must be n+m-2.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDiv1-Medium: FoxConnection3\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe key is notice that there can be few \u0026quot;shapes\u0026quot; of the result connected foxes. In fact if n \u003d 6 there can be at most 216 of them: \u003ca href\u003d\"http://oeis.org/A001168\"\u003ehttp://oeis.org/A001168\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAnd then we should figure out which fox goes to which position in the final shape. There will be 6! ways.\u003c/p\u003e\u003cp\u003eThen we need to decide the position of our final shape. \u003c/p\u003e\u003cp\u003eAfter decide the position, we will calculate how many steps do we need to get it. It is simply the sum of length of shortest paths from s[i] to t[i] where s[i] is the start position of fox[i] and t[i] is the end position of fox[i], because we can ignore \u0026quot;there cannot be two foxes in the same cell at the same time.\u0026quot; by this way:\u003c/p\u003e\u003cp\u003eSuppose we want to move O to x in this situation: \u003c/p\u003e\u003cp\u003e\u003ccode\u003e.O..o...o.x.\u003c/code\u003e\u003c/p\u003e\u003cp\u003eThere are 2 foxes block our way, but we can do this:\u003c/p\u003e\u003cp\u003e\u003ccode\u003e.o..o...o.x.  -\u0026gt;  .o..o.....o.  -\u0026gt;  .o......o.o.  -\u0026gt;  ....o...o.o.\u003c/code\u003e\u003c/p\u003e\u003cp\u003eThe if we write down the equation, it will be something like abs(offsetX — u[0]) + ... + abs(offsetX — u[n-1]) + abs(offsetY — v[0]) + ... + abs(offsetY — v[n-1]). We can find we should set offsetX \u003d middle number of u[] and offsetY \u003d middle number of v[].\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDiv1-Hard: FoxAndSouvenir\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eIt will be quite easy to get a solution run in O(n^4) for each query, a classic DP:\u003c/p\u003e\u003cp\u003edp[i] \u003d how may ways to get exactly i dollar.\u003c/p\u003e\u003cp\u003einitially we have dp[i] \u003d {1, 0, 0, ...}\u003c/p\u003e\u003cp\u003eFor each souvenir of price p, we update new_dp[i] \u003d dp[i] + (i-p\u0026gt;\u003d0 ? dp[i-p] : 0).\u003c/p\u003e\u003cp\u003eSo how to improve this? One observation is that this kind of dp can be write into convolutions:\u003c/p\u003e\u003cp\u003efor example, new_dp[i] \u003d dp[i] x {1, 0, 0, ..., 1, 0, .., 0}.\u003c/p\u003e\u003cp\u003eThen one possible improvement is FFT with 2D segment tree, but it will need O(n^4 (logn)^4) which is too slow.\u003c/p\u003e\u003cp\u003eAnother observation is that, we shouldn\u0027t do lots of FFT to merge segments again and again, for example, the answer will be {1, 0, .. , 1, 0, ..} x {1, 0, .. , 1, 0, ..} x {1, 0, .. , 1, 0, ..} ... We should first transform all of them into frequence domain, do the pointwise product of all of them. then transform back the result into time domain.\u003c/p\u003e\u003cp\u003eThe last observation is it: we can transform {1, 0, .. , 1, 0, ..} into frequence domain in O(n) by bruteforce instead of O(n logn) by FFT, because we only have 2 non-zero values. And we just need one point value in time domain, so we can get it by brutefoce in O(n) instead of paying O(n logn) to reconver all elements in time domain.\u003c/p\u003e\u003cp\u003eSo the solution looks like: preprocoss s[i][j][k] — the pointwise product of index k in frequence domain of the subrectangle [0, 0] — [i, j]. Then for one query we can find the frequence domain value of index k by calculate s[xMax][yMax][k] * s[xMin-1][yMax][k]^(-1) * s[xMax][yMin-1][k]^(-1) * s[xMin-1][yMin-1][k].\u003c/p\u003e\u003cp\u003eWe should do the DFT over GF(1000000009). And we can avoid 0s in s[i][j][k] by use a length of an odd number. There are lots of divisors of 1000000008, we can choose 3507, the smallest odd divisor that is no less than 2500.\u003c/p\u003e\u003c/div\u003e","tags":["srm651"]}}