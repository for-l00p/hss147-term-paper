{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1434140437,"rating":60,"authorHandle":"nikola12345","modificationTimeSeconds":1434195585,"id":18508,"title":"\u003cp\u003eCodeforces #307 (Div. 2) Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eProblems proved to be much harder than we expected. There were some corner cases we didn\u0027t include in pretests, so many solutions failed, which was definitely a mistake. Anyway, I hope you find this problemset interesting!\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem A.\u003c/strong\u003e \u003ca href\u003d\"//codeforces.com/problemset/problem/551/A\"\u003eGukiZ and Contest\u003c/a\u003e\u003c/p\u003e\u003cp\u003eVery simple implementation problem. Just implement what is written in the statement: for every element of array, find the number of array elements greater than it, and add one to the sum. This can be easily done with two nested loops. Total complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSolution: \u003ca href\u003d\"http://ideone.com/dFNSmE\"\u003elink\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem B.\u003c/strong\u003e \u003ca href\u003d\"//codeforces.com/problemset/problem/551/B\"\u003eZgukistringZ\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst, calculate the number of occurences of every English letter in strings \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e. We can now iterate by number of non-overlapping substrings of the resulting string equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, then we can calculate in constant time how many substrings equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e can be formed (by simple operations on the number of occurences of English letters in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e). In every iteration, maximise the sum of numbers of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e. Number of iterations is not greater than \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003ea\u003c/i\u003e|\u003c/span\u003e. At the end, we can easily build the resulting string by concatenating previously calculated number of strings \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e, and add the rest of the letters to get the string obtainable from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. Total complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003ea\u003c/i\u003e| + |\u003ci\u003eb\u003c/i\u003e| + |\u003ci\u003ec\u003c/i\u003e|)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSolution: \u003ca href\u003d\"http://ideone.com/sHqQfs\"\u003elink\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem C.\u003c/strong\u003e \u003ca href\u003d\"//codeforces.com/problemset/problem/551/C\"\u003eGukiZ hates Boxes\u003c/a\u003e\u003c/p\u003e\u003cp\u003eProblem solution (complete work time) can be binary searched, because if the work can be done for some amount of time, it can certainly be done for greater amount of time. Let the current search time be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. We can determine if we can complete work for this time by folowing greedy algorithm: find last non-zero pile of boxes and calculate the time needed to get there (which is equal to it\u0027s index in array) and take with first man as much boxes as we can. If he can take even more boxes, find next non-zero (to the left) pile, and get as much boxes from it, and repete untill no time is left. When the first man does the job, repete the algorithm for next man, and when all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e men did their maximum, if all boxes are removed we can decrease upper bound in binary search. Otherwise, we must increase lower bound. Total compexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8d/3f/8d3f3281bf32be5674a399b714d7acd449c5a47c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eSolution: \u003ca href\u003d\"http://ideone.com/1ZTCtR\"\u003elink\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem D.\u003c/strong\u003e \u003ca href\u003d\"//codeforces.com/problemset/problem/551/D\"\u003eGukiZ and Binary Operations\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst convert number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e into binary number system. If some bit of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e than the result of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eor\u003c/i\u003e\u003c/span\u003e opertion applied for every adjacent pair of those bits in array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e must be \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, that is no two adjacent those bits in array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e are \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. We should count how many times this is fulfilled. If the values were smaller we could count it with simply \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e + \u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 2\u003c/sub\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is equal to number of ways to make array od i bits where no two are adjacent ones. With first values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u003d 2\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u003d 3\u003c/span\u003e, we can see that this is ordinary Fibonacci number. We can calculate Fibonacci numbers up to \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e\u003c/span\u003e easily by fast matrix multiplication. If some bit at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e than number of ways is \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e — \\t{(number of ways bit is 0)}, which is also easy to calculate. We must be cearful for cases when \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e smaller than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e (solution is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e then) and when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d 63\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d 64\u003c/span\u003e. Total complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/04/21/0421eb7f9d8fc81b90e8a4d4206fd713b69af5dc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eSolution: \u003ca href\u003d\"http://ideone.com/bdDxMn\"\u003elink\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem E.\u003c/strong\u003e \u003ca href\u003d\"//codeforces.com/problemset/problem/551/E\"\u003eGukiZ and GukiZiana\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst we divide array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/90/d5/90d5a6cd550a25d4a1e92f4f6e6a222c64aa7a2e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e groups with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/90/d5/90d5a6cd550a25d4a1e92f4f6e6a222c64aa7a2e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e numbers. Every group in each moment will be kept sorted. For type \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e query, If we update some interval, for each group, which is whole packed in the interval, we will add the number it is being increased to it\u0027s current increasing value (this means all the elements are increased by this number). If some part of group is covered by interval, update these elements and resort them. Now, let\u0027s handle with type \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e queries. When we want find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eGukiZiana\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e, we search for the first and the last occurence of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e by groups. One group can be binary searched in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e2/9c/e29c57138af7a67a34d80f670940c84db493e12d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, because of sorted values, and most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/90/d5/90d5a6cd550a25d4a1e92f4f6e6a222c64aa7a2e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e groups will be searched. Of course, for the first occurence we search for minimum index of value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, and for the last occurence maximum index of value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e in array. When we find these \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e indexes, we must restore their original positions in array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and print their difference. If there is no occurence of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, print \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e. Total complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/59/0d/590db76536b6aeead0d9c47a3798705e7d9da6c7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eSolution: \u003ca href\u003d\"http://ideone.com/9WEbNP\"\u003elink\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}