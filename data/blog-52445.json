{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1496836204,"rating":1,"authorHandle":"Hamzqq9","modificationTimeSeconds":1496836488,"id":52445,"title":"\u003cp\u003eSINAV SORU F EDITORIAL\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eMantık\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eacaba tablodan her seferinde en küçük sayıyı mı alsak?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eMantığı kullanarak çözüm yolu\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003een küçük sayıyı aldıktan sonra en küçük sayının sol üstünde kalan bölge ve sag altında kalan bölge için de aynı işlemi yapsak?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ezaman karmaşıklığı?\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eher seferinde en küçük sayıyı hızlı bir şekilde elde edebileceğimiz bir algoritma kullansak? Çünkü dümdüz bakarsak zaman karmaşıklığı yaklaşık n^3 oluyor.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eispat\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003e1 2 3 4 ... n . . .\u003cbr /\u003en şeklinde bir tablomuz olsun.her seferinde sağ en alttaki sayı en küçük sayımız olursa geriye kalan sayıların en fazla olacağı durum gerçekleşir. Yani zaman karmaşıklığı adına en kötü durum bu olur. Eğer böyle olursa 1. işlem n^2 maliyet sağ en alttaki sayıyı aldık tablomuz : 1 2 3 4 .... n-1 . . . n-1 oldu. 2. işlem (n-1)^2 maliyet 3. işlem (n-2)^2 . . . n. işlem 1 maliyet\u003c/p\u003e\u003cp\u003ekareler toplamı ile n*(n+1)*(2n+1) / 6 --\u0026gt; O(n^3) yapar.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHangi algoritma?\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003ebildiğimiz üzere segment tree algoritması bizlere O(logn) zaman karmaşıklığında belirli bir aralıktaki en küçük sayıyı sunabilmekte. Peki bu algoritmanın 2D sini burada nasıl kodlarız?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eNasıl kodlarım?\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003e1D segment tree de her seferinde en ortadaki değeri alıp onun sağındaki ve solundaki değerler için alt ağaç oluşturuyorduk. Burada ben 2D segment tree de ikiye bölme işlemini dikey ve yataydan gerçekleştirdim. Build() fonksiyonuna parametrelere ek olarak w değişkenini gönderdim ve\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eif(w\u003d\u003d0) {\n  build(dikeyden ikiye böl ve sol tarafa git, w\u003d1);\n  build(dikeyden ikiye böl ve sağ tarafa git, w\u003d1);\n}\nelse {\n  build(yataydan ikiye böl ve sol tarafa git, w\u003d0);\n  build(yataydan ikiye böl ve sağ tarafa git, w\u003d0);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAma burada özel bir durum bulunmakta.O da eğer şuan cevabını bulmak istediğim parçanın 1D olması yani tek boyutlu. Örneğin 1 2 3 4 5 6 7 8 9 tablomuz üzerinde 2D segment tree oluşturalım ve cevabını bulmak istediğimiz bölge 7 8 9 bölgesi olsun. Mantıken bu bölgeyi yatay bölemeyeceğimden if yazarak dallanmayı dikey yapıyoruz.\u003c/p\u003e\u003cp\u003eNOT: Bu benim implementasyonum olduğundan en doğrusu olmayabilir. Araştırmanınzı tavsiye ederim.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eDerlenmiş Editorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eÖncelikle elimizde a ve b dizileri olsun. Lexicographical olarak bu iki diziyi karşılaştırdıktan sonra a\u0026lt;b olması için bu iki dizinin elemanlarını karşılaştıralım ve değeri farklı olan ilk eleman i\u0027nci eleman olsun. ozaman a[i]\u0026lt;b[i] olmalıdır. Soruda da bizden aldığımız elemanları sıraladığımızda Lexicographical olarak elde edilecek minimum dizi istenmekte olduğundan eğer ben tablodaki en küçük elemanı alırsam, o elemanı almadan elde edeceğim dizilerin hepsi Lexicographical olarak daha büyük olacaktır ki bu da bizim istemediğimiz bir durumdur. O zaman çözüm mantığımız her zaman alabileceğimiz en küçük elemanı alarak problemi çözmek. Fakat soruda sadece sağ ve aşağı gidilebildiğinden bu elemanın sol alt ve sağ üstünde kalan elemanları alamayacağız. Bu yüzden bu elemanın sol üst ve sağ altındaki bölge için soruyu bir daha çözeceğiz.Böylelikle her seferinde en alınabilecek en küçük alınarak soru çözülecek.Fakat her seferinde en küçüğü bulma işini hızlıca yapmadığımızdan zaman karmaşıklığımız en kötü durumda o(n^3) e varacak. Bu yüzden her seferinde en küçüğü dümdüz aramak yerine 2D segment tree algoritmasını kullanacağız. \u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://paste.ubuntu.com/24800191/\"\u003eÖrnek kod\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}