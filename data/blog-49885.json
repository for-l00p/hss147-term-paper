{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1484858504,"rating":3,"authorHandle":"battuzz94","modificationTimeSeconds":1484907099,"id":49885,"title":"\u003cp\u003eSolution to some problems\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHere are the solutions to three problems that I have found quite interesting.\u003c/p\u003e\u003ch1\u003eJapanese Menu\u003c/h1\u003e\u003ch2\u003eStatement\u003c/h2\u003e\u003cp\u003eThe full statement of the problem can be found here (in italian): \u003ca href\u003d\"https://cms.di.unipi.it/#/task/mat_menu/statement\"\u003ehttps://cms.di.unipi.it/#/task/mat_menu/statement\u003c/a\u003e Gabriele is in Kyoto and enters a restaurant. He wants to make the best use of his budget consisting in B ¥ (that means he wants to spend it all). The menu has N dishes. The i-th dish costs Ci ¥. He can order each dish only once. Help Gabriele choose the dishes from the menu so that the total expense is as much as possible (considering that he has a limited budget).\u003c/p\u003e\u003cp\u003eThe input consists in N + 1 lines: the first line contains two integer N (N ≤ 5000) — the number of items in the menu and B (B ≤ 5000) — the budget Gabriele can spend. Then N lines follow. i-th line contains the cost Ci of the item in the menu.\u003c/p\u003e\u003cp\u003eThe output should consist in K integers (K ≤ N) — the cost of the items Gabriele should choose to maximize his expense. \u003c/p\u003e\u003ch2\u003eSolution\u003c/h2\u003e\u003cp\u003eThis problem can be solved using Dynamic Programming. In fact, imagine to start with a menu with only one item. Of course the solution is to choose that only item only if its cost is less than or equal to the budget, that is Ci \u0026lt;\u003d B. Of course our solution is still the same for every budget B\u0027 ≥ B, since we can choose each item only once. So far so easy. Add one more item. What should happen now? We have only 2 possibilities: - We choose to put the new item in our solution - We discard the new item and stick with the old solution Consider the first case: if we have a budget B, then we should spend Ci for this item, leaving us with a budget of B-Ci. If the remaining budget is enough, we can also choose the previous item thus increasing the solution. In the second case, instead, we would have the same \u0027value\u0027 of the solution with the first item.\u003c/p\u003e\u003cp\u003eLet\u0027s generalize with N items. Let D[i][j] be the total expense that we can do using only the first i items (that is, items 1, 2, ..., i) with a budget of j. Then, the following holds:\u003c/p\u003e\u003cp\u003e\u003cimg src\u003d\"/predownloaded/d8/4c/d84c332346bab3b4260cdb5f46c6aaa752167c00.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" width\u003d\"250px\" /\u003e\u003c/p\u003e\u003cp\u003eIf we choose every time the maximum of the two alternatives, we can dynamically construct the solution using dynamic programming.\u003c/p\u003e\u003ch2\u003eImplementation\u003c/h2\u003e\u003cp\u003eAfter reading the input, we can construct our matrix D starting from the bottom:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (int i \u003d 1; i \u0026lt;\u003d N; i++) \n\tfor (int j \u003d 1; j \u0026lt;\u003d B; j++) \n\t\tif (j - C[i] \u0026gt;\u003d 0) {\n\t\t\tif (C[i] + D[i-1][j-C[i]] \u0026gt; D[i-1][j]) {   // We choose item i\n\t\t\t\tD[i][j] \u003d C[i] + D[i-1][j - C[i]];\n\t\t\t\tP[i][j] \u003d 1;\n\t\t\t}\n\t\t\telse                                       // We discard item i\n\t\t\t\tD[i][j] \u003d D[i-1][j];\n\t\t}\n\t\telse\n\t\t\tD[i][j] \u003d D[i-1][j];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNote that the output requires that you reconstruct the solution. This can be done by saving in a matrix P[i][j] the value 1, if the best solution D[i][j] contains item i, otherwise we can leave a 0. In this way we can reconstruct the solution like this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eauto ans \u003d vector\u0026lt;int\u0026gt;();\nint b \u003d B, i \u003d N;\nwhile (i \u0026gt;\u003d 0) {\n\tif (P[i][b] \u003d\u003d 1) {\n\t\tans.push_back(i);\n\t\tb -\u003d C[i];\n\t}\n\ti--;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe vector ans will contain the cost of the items to choose from the menu.\u003c/p\u003e\u003ch1\u003eLearning Language\u003c/h1\u003e\u003ch2\u003eStatement\u003c/h2\u003e\u003cp\u003eThe statement of the problem with a full description can be found here: \u003ca href\u003d\"/contest/277/problem/A\" title\u003d\"Codeforces Round 170 (Div. 1)\"\u003e277A - Learning Languages\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe \u0026quot;BerCorp\u0026quot; company has got n employees. These employees can use m approved official languages for the formal correspondence. The languages are numbered with integers from 1 to m. For each employee we have the list of languages, which he knows. This list could be empty, i. e. an employee may know no official languages. But the employees are willing to learn any number of official languages, as long as the company pays their lessons. A study course in one language for one employee costs 1 berdollar.\u003c/p\u003e\u003cp\u003eFind the minimum sum of money the company needs to spend so as any employee could correspond to any other one (their correspondence can be indirect, i. e. other employees can help out translating).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eInput\u003c/strong\u003e The first line contains two integers n and m (2 ≤ n, m ≤ 100) — the number of employees and the number of languages.\u003c/p\u003e\u003cp\u003eThen n lines follow — each employee\u0027s language list. At the beginning of the i-th line is integer ki (0 ≤ ki ≤ m) — the number of languages the i-th employee knows. Next, the i-th line contains ki integers — aij (1 ≤ aij ≤ m) — the identifiers of languages the i-th employee knows. It is guaranteed that all the identifiers in one list are distinct. Note that an employee may know zero languages.\u003c/p\u003e\u003cp\u003eThe numbers in the lines are separated by single spaces.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eOutput\u003c/strong\u003e Print a single integer — the minimum amount of money to pay so that in the end every employee could write a letter to every other one (other employees can help out translating).\u003c/p\u003e\u003ch2\u003eSolution\u003c/h2\u003e\u003cp\u003eWe can build a graph in which every employee represent a node 1..N and each language is a node N+1..N+M. We can add an arc from an employee E to a language L if and only if E knows L. This creates a bipartite graph because we don\u0027t add arcs between employees and between languages: every arc goes from the set of employees to the set of languages and vice versa (arcs are bidirectional). In this way, every employee is able to talk to any other employee if and only if there is a path from the two employee. This is equivalent to say that the two employees E1 and E2 can talk to each other if they belong to the same connected component. If two employees E1 and E2 belong to different connected components C1 and C2, that means that there is no employee E* such that E* knows either a language spoken in C1 and a language spoken in C2 (otherwise such E* can be a translator. In this case we must pay 1 berdollar in order to teach to an employee of C1 (C2) a language spoken in C2 (C1). It does not matter what language is to be taught, neither it is important to know who will learn said language: the only important thing is that the two components C1 and C2 will be connected.\u003c/p\u003e\u003cp\u003eThis problem is then reduced to find the number of connected components that has at least one employee in the graph. If NC is the number of connected components, then the answer to the problem is NC — 1. (You need at least n-1 arcs to connect n different components). But there is one exception: if initially everyone knows no languages, we\u0027ll have to add n edges, because we can\u0027t add the edges between employees (remember that the graph is bipartite).\u003c/p\u003e\u003ch2\u003eImplementation\u003c/h2\u003e\u003cp\u003eWe have two alternatives:\u003c/p\u003e\u003ch3\u003eDFS\u003c/h3\u003e\u003cp\u003eWe can mark all nodes in the graph as non visited. Then we run a DFS (or BFS) to the first node and mark all the encountered nodes as visited. Then, we search for nodes that we haven\u0027t visited yet: if there is such a node, it must belong to a different connected component (otherwise the DFS would mark the node as visited). We run a DFS on that node and we increment the number of connected components. We will repeat this process until all the nodes are visited.\u003c/p\u003e\u003cp\u003eThe code (in Python) is the following:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eV \u003d [False for i in xrange(300)]\nG \u003d [[] for i in xrange(300)]\n\n# Depth first search\ndef dfs(s):\n\tfor u in G[s]:\n\t\tif not V[u]:\n\t\t\tV[u] \u003d True\n\t\t\tdfs(u);\n\ndef solve():\n\t# Read input\n\tN, M \u003d map(int, raw_input().split())\n\tL \u003d [map(int, raw_input().split())[1:] for row in xrange(N)]\n\n\t# Handle trivial case\n\tif all(len(L[i]) \u003d\u003d 0 for i in xrange(N)):\n\t\tprint N\n\t\texit()\n\n\t# Build graph\n\tfor i in xrange(N):\n\t\tfor l in L[i]:\n\t\t\tG[i].append(N+l)\n\t\t\tG[N+l].append(i)\n\n\t# Count connected components\n\tcount \u003d 0\n\tfor i in xrange(N):\n\t\tif not V[i]:\n\t\t\tdfs(i)\n\t\t\tcount +\u003d 1\n\t\n\tprint count - 1 \n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n\tsolve()\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eDisjoint sets\u003c/h3\u003e\u003cp\u003eInstead of building the graph and run a DFS visit, we can see that the only important thing is whether two nodes belong in the same connected component or not. This can be done with a union-find. In the beginning, we create N+M isolated nodes (N employees and M languages). Then, for each edge of the graph, we call the union between the two nodes, stating that they are in the same connected component. After this process, we can just count how many different values we have in the first N nodes (the employee set).\u003c/p\u003e\u003cp\u003eThe following code (in Python) uses this idea:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e# Union find implementation\ndef make_set(size):\n\treturn [i for i in xrange(size)]\n\ndef union(S, a, b):\n\tS[find(S,b)] \u003d find(S,a)\n\ndef find(S, a):\n\tif S[a] \u003d\u003d a:\n\t\treturn a\n\tS[a] \u003d find(S, S[a])\n\treturn S[a]\n\n\ndef solve():\n\t# Read input\n\tN, M \u003d map(int, raw_input().split())\n\tL \u003d [map(int, raw_input().split())[1:] for row in xrange(N)]\n\n\t# Handle trivial case\n\tif all(len(L[i]) \u003d\u003d 0 for i in xrange(N)):\n\t\tprint N\n\t\texit()\n\n\t# Create and populate union find\n\tS \u003d make_set(N+M)\n\n\tfor i in xrange(N):\n\t\tfor j in L[i]:\n\t\t\tunion(S, i, N+j-1)\n\n\t# Sum connected components\n\tcount \u003d sum([S[i] \u003d\u003d i for i in xrange(N)])\n\t\n\tprint count - 1 \n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n\tsolve()\n\u003c/code\u003e\u003c/pre\u003e\u003ch1\u003eCastle Corners\u003c/h1\u003e\u003ch2\u003eStatement\u003c/h2\u003e\u003cp\u003eThis problem was taken from Bloomberg Codecon v2\u003c/p\u003e\u003cp\u003eKing Charles\u0027 Castle is about to be besieged by the enemy\u0027s army. Charles wants to keep an eye on the army\u0027s movements as he prepares for the siege, but doesn\u0027t have many scouts to spare. He is looking at a top-down map of the area between his castle and the enemy\u0027s army, represented as follows: - . is flat, unobstructed land. - X is blocking scenery such as hills, mountains, or forests, through which his sentries can\u0027t see. Charles\u0027 castle (C) is going to be attacked. - The enemy\u0027s army is A. Place the minimum amount of sentries S such that there is a chain of communication through line of sight formed between your castle and the enemy army, to be able to communicate between the castle and the front-line scouts and make sure that the army cannot attack you by surprise. Sentries cannot look diagonally. There will always be a unique minimal valid sentry placement.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eInput\u003c/strong\u003e X — representing the number of columns on the map. 2 \u0026lt; X \u0026lt; 100. Y — representing the number of rows on the map. 2 \u0026lt; Y \u0026lt; 100. Y lines of X characters, representing the terrain.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eOutput\u003c/strong\u003e Y lines of X characters, representing the terrain with sentries placed.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSample input\u003c/strong\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e15\n7 \nXXX............\nXXA...........X\nX..XXXXXX.....X\nX.XX....X.....X\nX..XXXX.XXXXX.X\nXXC...........X\nXXXXXXXXXXXXXXX\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eSample output\u003c/strong\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eXXX............\nXXA..........SX\nX..XXXXXX.....X\nX.XX....X.....X\nX..XXXX.XXXXX.X\nXXC..........SX\nXXXXXXXXXXXXXXX\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn the sample, the minimum number of sentries that have to be placed is 2.\u003c/p\u003e\u003ch2\u003eSolution\u003c/h2\u003e\u003cp\u003eWe can construct a graph as follows: - Every character that is not blocking the view (is not a \u0027X\u0027) will be a node in the graph - Edge (u,v) belongs to the graph if and only if the node u and the node v are in sight, that is u and v are in the same row (column) and there is no blocking scenery in between.\u003c/p\u003e\u003cp\u003eOnce we have this graph, we can see that the shortest path from C to A requires exactly the least number of sentries. In fact, each node of such a path (except A and C) is a \u0027turning node\u0027 in which we must add a sentry.\u003c/p\u003e\u003cp\u003eConsider a simple case: C and A are in sight. Then, the shortest path is simply from A to C and no sentries are required. Let\u0027s consider now a case in which we have one sentry to be added, like this one:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eXXX............\nXXA...........X\nX..XXXXXX.....X\nX.XX....X.....X\nX..XXXX.XXXXX.X\nXX...........CX\nXXXXXXXXXXXXXXX\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe sentry must be added in row 2 and column 14, that is exactly the node that should be in the shortest path between A and C in the previously built graph.\u003c/p\u003e\u003cp\u003eWe can see that this statement holds in general, so we can use a bfs to find the shortest path from A to C and then add sentries in the inner nodes of such a path.\u003c/p\u003e\u003ch2\u003eImplementation\u003c/h2\u003e\u003cp\u003eThe main challenge in the implementation of this problem is how to build the graph. We can say that node in row i and column j is mapped to node i*M + j. In this way we can identify uniquely each node with a single integer.\u003c/p\u003e\u003cp\u003eThe following Python code does the job:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efrom collections import deque\n\nMAXN \u003d 120\nMAXM \u003d 120\n\nG \u003d [[] for i in xrange(MAXN * MAXM)]\n\n# Find the shortest path from C to A and return the inner nodes\ndef bfs(s, f):\n\tif s \u003d\u003d f:\n\t\treturn []\n\n\tans \u003d []\n\tvisited \u003d [False for i in xrange(MAXN * MAXM)]\n\tQ \u003d deque()\n\tQ.append(s)\n\tP \u003d [-1 for i in xrange(MAXN * MAXM)]\n\n\tfound \u003d False\t\t# This variable checks if there is a possible path from A to C\n\twhile len(Q) \u0026gt; 0:\n\t\tu \u003d Q.popleft()\n\t\tif u \u003d\u003d f:\n\t\t\tfound \u003d True\n\t\t\tbreak\n\t\tfor v in G[u]:\n\t\t\tif not visited[v]:\n\t\t\t\tQ.append(v)\n\t\t\t\tvisited[v] \u003d True\n\t\t\t\tP[v] \u003d u\t\t# Stores the parent to reconstruct the path\n\n\tif found:\n\t\t# Reconstruct the shortest path\n\t\tnode \u003d f\n\t\twhile node !\u003d s:\n\t\t\tans.append(node)\n\t\t\tnode \u003d P[node]\n\n\t\treturn ans[1:]\t\t# Don\u0027t consider source node\n\telse:\n\t\treturn []\n\n\ndef solve():\n\tglobal N, M, X\n\tN,M \u003d map(int, raw_input().split(\u0027 \u0027))\n\tX \u003d [list(raw_input()) for i in xrange(N)]\n\n\t# Connect all columns\n\tfor row in xrange(N):\n\t\tfor i in xrange(M):\n\t\t\tfor j in range(i+1, M):\n\t\t\t\tif all(X[row][k] in \u0027AC.\u0027 for k in range(i,j+1)):\n\t\t\t\t\t# connect node in (row,i) with node in (row, j)\n\t\t\t\t\tG[M*row + i].append(M*row + j)\n\t\t\t\t\tG[M*row + j].append(M*row + i)\n\n\t# Connect all rows\n\tfor col in xrange(M):\n\t\tfor i in xrange(N):\n\t\t\tfor j in range(i+1, N):\n\t\t\t\tif all(X[k][col] in \u0027AC.\u0027 for k in range(i,j+1)):\n\t\t\t\t\t# connect node in (i,col) with node in (j,col)\n\t\t\t\t\tG[M*i + col].append(M*j + col)\n\t\t\t\t\tG[M*j + col].append(M*i + col)\n\n\n\t# Search for start and end position\n\tposA \u003d -1\n\tposC \u003d -1\n\tfor i in xrange(N):\n\t\tfor j in xrange(M):\n\t\t\tif X[i][j] \u003d\u003d \u0027A\u0027:\n\t\t\t\tposA \u003d i*M + j\n\t\t\tif X[i][j] \u003d\u003d \u0027C\u0027:\n\t\t\t\tposC \u003d i*M + j\n\n\n\tans \u003d bfs(posA, posC)\n\n\t# Print solution\n\tfor i in xrange(N):\n\t\tprint \u0027\u0027.join(\u0027S\u0027 if i*M+j in ans else X[i][j] for j in xrange(M))\n\nif __name__\u003d\u003d\u0027__main__\u0027:\n\tsolve()\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}