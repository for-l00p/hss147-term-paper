{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1418725739,"rating":16,"authorHandle":"islam-al-aarag","modificationTimeSeconds":1418726040,"id":15182,"title":"\u003cp\u003eRound 1 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eNice Patterns Strike Back\u003c/h3\u003e\u003cp\u003eThe large value for N makes you suspect eithe an O(1) or a logarithmic algorithm. You can construct tranisition functions between rows by checking them against each other. For example, row 1011 can follow 1100 but can\u0027t follow 1111. Once you construct this function, you are left with a graph where you can start at any node and finish at any node after doing n steps. This is a traditional problem that can be computed using matrix exponentation for small number of nodes.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/TNAEhb\"\u003ehttp://ideone.com/TNAEhb\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eBeautiful People\u003c/h3\u003e\u003cp\u003eAt first sight, the problem is easily reduced to LIS where Pi \u0026lt; Pj if  P[i].first \u0026lt; P[j].first \u0026amp; P[i].second \u0026lt; P[j].second. The 1-D version of  this problem can be easily solved using nlog n LIS (you can read about it  here: \u003ca\u003ehttp://bit.ly/1wnXvr1)\u003c/a\u003e. The 2-D version is a bit trickier. What you need  to do is ensure the order on one dimension and then do LIS on the other. You  will sort by the first paramter and then do LIS on the second one. The problem  that arise is with pairs Pi and Pj where Pi.first \u003d Pj.first and Pi.second \u0026lt;Pj.second  and Pi came before Pj. They will contribute to the answer although it\u0027s invalid so  the solution is to avoid this by soring descendingly on second in case of ties.  Answer reconstruction can be done easily by keeping the element previous to i you  in the LIS ending at i.  The same logic can be done using a segment tree but that\u0027s left as an exercise :)\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/Z0jGy6\"\u003ehttp://ideone.com/Z0jGy6\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eHyperhuffman\u003c/h3\u003e\u003cp\u003eThe problem is a direct application of huffman coding algorithm  which is a greedy one. You simply put lower occurence as lower  leaves and merge them to complete as one node. The only trick is  that the time limit is very small so you have to be very careful  and deal only with numbers instead of forming the tree.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/zObc8o\"\u003ehttp://ideone.com/zObc8o\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eBeloved Sons\u003c/h3\u003e\u003cp\u003eThe problem is a very standard one. You have a bipartite graph that you need  to do a matching on so that some value (the kings happiness) is maximied.  Without further explanation, this is the standard Maximum Matching on Bipartite  Graph which can be solved using hungarian algorithm. You can read about it in  \u003ca href\u003d\"http://bit.ly/12X7vwQ\"\u003ehttp://bit.ly/12X7vwQ\u003c/a\u003e and \u003ca href\u003d\"http://bit.ly/1zgr13l\"\u003ehttp://bit.ly/1zgr13l\u003c/a\u003e. The algorithm runs in O(n^3).  There is another smart idea that you can do witch just bi partite matching. The  trick is to match nodes that have higher hapiness first. This is always better  because when later nodes try to take matches from older node, they will always  find new matches for them first (This is how bipartite matching runs)\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/mAM9WB\"\u003ehttp://ideone.com/mAM9WB\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eRailroad Sort\u003c/h3\u003e\u003cp\u003eGiven that n is small and the numbers given are 2^n numbers, you should  directly suspect that the solution has to do with bits in the number.  The problem has a simple divide and conquer solution. After dead end i,  make sure that numbers \u0026lt; 2^i are ahead of all numbers \u0026gt; 2^i (Dead ends are  numbered front to back, last one is n — 1). You can simply do the following  If x \u0026lt; 2 ^ i, move it to dead end and directly out of of it, otherwise only  move it to the end dead and wait till all numbers \u0026lt; 2^i have gone in and out  then move all those left in the dead end. One you do that for the first dead  end, you are left with 2 problems with a smaller n (original n — 1) which  you can solve recursively using the same way.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/VGHAgm\"\u003ehttp://ideone.com/VGHAgm\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eCryptography\u003c/h3\u003e\u003cp\u003eThe problem is not different from any problem doing range queries  whether it\u0027s RMQ, finding sum, product...etc. Any solution for RMQ  works for this problem and you can read all of them here \u003ca href\u003d\"http://bit.ly/1wzE1zY\"\u003ehttp://bit.ly/1wzE1zY\u003c/a\u003e.  The most elegant and easiest to code for an offline problem like this  is the sparse table solution which is coded below.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/90IZcM\"\u003ehttp://ideone.com/90IZcM\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eFibonacci Subsequence\u003c/h3\u003e\u003cp\u003eThere is a direct knap-sack dp solution for this problem which runs in O(n^3).  The idea is simply to keep f(beforeLast, last, current) and you try  to include current in the solution if A[current] \u003d A[beforeLast]+A[last].  Unfortuantely, this will time out. If you think a little bit, you will see that  if there are mutiply nexts to take it\u0027s always better to use the first one  because it gives you more options later on. There are mutliple ways to do that:\u003cbr /\u003e  1. Keep all occurences of a certain value in a sorted list and binary search for  the next occurence after your last index.\u003cbr /\u003e  2. Start your solution from the end and only keep last occurence of each value.  The second idea eliminates the log from binary search which is not necessary to  make the problem pass. The rest is simple DP.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/hYFlp7\"\u003ehttp://ideone.com/hYFlp7\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eLong Dominoes\u003c/h3\u003e\u003cp\u003eThis is a standard tiling problem. You need to keep track of two masks  representing the current and next row. In a certain row and column,  you decide to put a certain tile (horizontal or vertical) based on the masks.  The complexity is n m 2 ^(2m) which passes for this problem.  This is the complexity when you calculate it but the hidden actual complexity  is much less. If you think a little, you will notice that some masks never  exist together. For example, you can never have two masks where bit i is not  set in the current mask and set in the next because a vertial tile couldn\u0027t  have jumped in bit i. So in reality, you only need one mask whereeach bit  actually have 1 of 3 states, not set, set or double set. Now the real complexity  is n m 3^m but we still use the same memory.  We can reduce the memory by using actually a tertiary mask. To set bit i to 1  in the mask you add 3^i, to set it to 2 you add 2 3^i. To unset a bit,  you subtract bit(i) 3^i. You can cache needed powers of 3 beforehand  to reduce the computation. This idea is the on coded.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/ZGJJaQ\"\u003ehttp://ideone.com/ZGJJaQ\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eUnfair Contest\u003c/h3\u003e\u003cp\u003eThe problem description seems very complicated because it has  so many text and so many rules but in reality it\u0027s an adhoc brute force  problem where you just try all sets of problems and simulate the rules.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/CGIQbm\"\u003ehttp://ideone.com/CGIQbm\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eBlack and White\u003c/h3\u003e\u003cp\u003eThe whole idea of the problem, is to find away to calculate the total area by making each edge contribute independantly from the other (You can see that if you managed to know how to get the total area, counting black and white will be easy just some observations and small equations). Here\u0027s how one model of the situation can be. Imagine any polygon that it\u0027s points are sorted counter-clockwise (or clock-wise), then if you considered the edges between the consecutive points of the polygon, you will see that the area \u003d (sum of the area to the left of the vertical edges going up) - (sum of the area to the left of the vertical edges going down). This method will work even for concave polygons.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/la2jhk\"\u003ehttp://ideone.com/la2jhk\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eIslands\u003c/h3\u003e\u003cp\u003eThe idea is to find a way so that when a new tile convert to an island, it finds a way to merge itself and its neighbours into one big component. This is done using union find sets, the challenges are that each node in our model will correspond to a tile in the hexaagonal structure and merging nodes together correctly.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/bfldco\"\u003ehttp://ideone.com/bfldco\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eCheater\u0027s Shuffle\u003c/h3\u003e\u003cp\u003eThe brute force solution for this problem when simulating is time:O(N * P ^ T) and will result in O (P ^ T) final states. Which is big, (but not \u003cem\u003etoo\u003c/em\u003e big as you can see). The key observation in this problem, is that the desired final state of the cards are given, this indicates that many of the simulations we were going to process were to end into a none-desirable state. But how can we prune some branchings during our brute force simulation? The final state can\u0027t be used to clearly declare some intermediate states to be not reachable and therefore ignore them in our search. Here we can see something interesting, which is, whether we start our brute force solution from the initial state to the desired, or from the desired state to the initial it is the same case. Then, why not start from both ends, and figure out some logic to \u0026quot;meet in the middle\u0026quot; :). First, lets analyize what are we gaining by doing this. Now, the brute force solution is O(N * (P / 2) ^ T) \u003d SZ and will result in O((P / 2) ^ T) final states (or should we call it middle states?). Given the constraints, this is around 300,000 states. If we did that from the start state to the middle (300,000 state generated) and then from the desired state to the middle (another 300,000 state generated) Now, if we only find a state of cards, that is identical in the middle states of both directions. Then we can know for sure, that the path that led to that state from the beginning, can continue to the desired state from this middle state. This can be done by containing a Hashset of the middle states from one direction, and then looping on the middle states of the other direction and checking if it is contained in the set generated O(SZ * log (SZ) * N) (N is for string comparison). This is to check if a solution exists or not, to calculate the solution steps you can store the necessary steps with the states you reach, you can revise the necessary time and space complexity in that case.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/99GEGV\"\u003ehttp://ideone.com/99GEGV\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eInverse Range Minimum Query\u003c/h3\u003e\u003cp\u003eLet\u0027s think about the constraints a bit. Once I say rmq(x, y) \u003d z  this means that each element between x and y inclusive has to be  at least z. If we manage to fullfill all the constraints without  contradiction, that would be a solution. We will set all elements  initially to infinity. We will then process all queries one by one  each time setting all elements between x and y to the minimum of  their current value and z where rmq(x,y) \u003d z. Setting the elements  naively ill time out so we will do that using segment tree  and lazy propagation. Once we are done we should recheck the conditions  again that each query is actually correct. We can do that either using  a segment tree as well all all techniques for LCA (as described before)\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/okcqLz\"\u003ehttp://ideone.com/okcqLz\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eFinite Automata\u003c/h3\u003e\u003cp\u003eWhen you see a value that small, the first idea that should pop into  your mind is it has to do with a binary mask. A normal solution would  be to keep 3 things (currentRow, mask of current column, mask of next column)  but this will lead to a large number of states. A very nice optimization  to do (it helps with DP problems as well) is to use only one mask where bits  up to current row represent those of next column (since u already passed them  in the current column) and those after represents those of current columns.  The number of states is then reduced to m 2^m. The only thing left is  to create the transitions that modify the masks and have a FAIL state  that you move to whenever there is an invalid move and stay there forever.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/LqQ9im\"\u003ehttp://ideone.com/LqQ9im\u003c/a\u003e\u003c/p\u003e\u003ch3\u003ePalindromes\u003c/h3\u003e\u003cp\u003eThis problem is pretty standard and can be solved by multiple solutions.  We will discuss some of them: \u003cbr /\u003e  1. Using String Matching: You can use either Z-Function where you run it  n times considering s.substring(i, n) as your current string. Any substring  (i,j) that occurs as a prefix of any of the strings shouldn\u0027t be counted  since it occured before. The complexity is O(n^2).\u003cbr /\u003e  2. Using Hashing and DP: You will do a DP to check for all substring palidromes  (runs in O(n^2)) and then u hash all substrings (runs in O(n^2) using cumulative  hashing) and then if the string is a palidrome you simply insert the hash in  a set and count the size eventually. You might get TLE with that so an optimization  is to keep multiple sets, one for each length.\u003cbr /\u003e  There is another solution that runs in O(n) using what\u0027s called a palidromic tree.  You can read about it here \u003ca href\u003d\"http://bit.ly/1GKRd7H\"\u003ehttp://bit.ly/1GKRd7H\u003c/a\u003e\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/tZbPQw\"\u003ehttp://ideone.com/tZbPQw\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}