{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1509636249,"rating":-8,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1509636249,"id":55541,"title":"\u003cp\u003eNotes on Codeforces Beta Round #89, A, B, C, D, E (DFS and Bridge in Graph)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/118/problem/A\" title\u003d\"Codeforces Beta Round 89 (Div. 2)\"\u003e118A - String Task\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis problem can be solved by the following three steps. Firstly, change all the letters into lower case ones. Secondly, remove all the required letters. Thirdly, add “.” in front of each survived letter.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/118/problem/B\" title\u003d\"Codeforces Beta Round 89 (Div. 2)\"\u003e118B - Present from Lena\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTake care of the number of spaces that should be output before each digit.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/118/problem/C\" title\u003d\"Codeforces Beta Round 89 (Div. 2)\"\u003e118C - Fancy Number\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe can enumerate all the digits, and for each digit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e, we replace several original digits so that there exist at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e digits which are the same. To achieve the minimum cost and also the minimum lexicographic order, we should replace digits in the order of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e (this can be viewed as a trivial case), \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e + 1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e - 1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e + 2\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e - 2\u003c/span\u003e, and so on. The replacement should be stopped once we have obtained \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e same digits.\u003c/p\u003e\u003cp\u003eTo simplify the implementation, for each digit, we can also record how many of them should be replaced. Finally, we implement the replacment. However, here we should be very careful. Suppose that the original digit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e is replaced with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e \u0026lt; \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e, then we should replace digit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e from right to left; otherwise we should do it from left to right, so that we can achieve the minimum lexicographic order.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/118/problem/D\" title\u003d\"Codeforces Beta Round 89 (Div. 2)\"\u003e118D - Caesar\u0027s Legions\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe solution is DP. Let us use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e][\u003ci\u003em\u003c/i\u003e][\u003ci\u003ee\u003c/i\u003e]\u003c/span\u003e to denote the number of all the feasible patterns that have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e type-1 people standing at the end of the line one after another, while the total number of type-1 and type-2 people are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e, respectively. Similarly, we use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e][\u003ci\u003em\u003c/i\u003e][\u003ci\u003ef\u003c/i\u003e]\u003c/span\u003e to denote the total number of feasible patterns that have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e type-2 people standing at the end of the line.\u003c/p\u003e\u003cp\u003eThe recursive formula is as follows:\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/93/7e/937e7a954bde67c5f21437b6ef555299f3a56884.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/37/d7/37d7c010d8fbb3538e02e50087a0b329489c8486.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThe initialization should be done as follows:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[0][\u003ci\u003em\u003c/i\u003e][\u003ci\u003em\u003c/i\u003e] \u003d 1\u003c/span\u003e, for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e \u0026lt; \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e][0][\u003ci\u003en\u003c/i\u003e] \u003d 1\u003c/span\u003e, for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u0026lt; \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/118/problem/E\" title\u003d\"Codeforces Beta Round 89 (Div. 2)\"\u003e118E - Bertown roads\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe can start from any node, and implement DFS. During this process, when we are visiting a node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and enumerating its “child” (since this may not be its true child node) node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e is still not visited, we add a directed edge from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e has been visited but its “child” nodes are still not fully visited, then we add a directed edge from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e as well. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e has been visited and all of its “child” nodes have also been visited, then we do nothing, since this edge must have been assigned with a “direction”.\u003c/p\u003e\u003cp\u003eAfter the above operations, we in fact have established a directed graph. Then, we check whether it is strongly connected or not, which can be done by inversing all the direction of the edges and implement DFS again.\u003c/p\u003e\u003cp\u003eThe last step is to prove that if the above obtained directed graph is not strongly connected, then it is impossible to construct any strongly connected directed graph. Well, I did not figure out a strict proof. But from an intuitive understanding, if the constructed directed graph is not strongly connected, it implies that there is at least one bridge edge, and thus it is impossible to establish any strongly connected graph.\u003c/p\u003e\u003c/div\u003e","tags":[]}}