{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1405104435,"rating":11,"authorHandle":"Wsl_F","modificationTimeSeconds":1405115067,"id":13017,"title":"\u003cp\u003eДейкстра или нет?\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eНедавно я с удивлением узнал, что алгоритм, которым я пользовался для нахождения минимального пути в графе от одной вершины до остальных, не совпадает с классической дейстрой описанной на \u003ca href\u003d\"http://ru.wikipedia.org/wiki/Алгоритм_Дейкстры\"\u003eвикипедии\u003c/a\u003e или \u003ca href\u003d\"http://e-maxx.ru/algo/dijkstra\"\u003ee-maxx\u003c/a\u003e. Теперь напишу, как я ищу минимальный путь.\u003c/p\u003e \u003col\u003e   \u003cli\u003eСоздаем линейный массив \u003cem\u003ecost\u003c/em\u003e в котором будем хранить минимальное расстояние до каждой вершины. Инициализируем его БОЛЬШИМИ значениями, а для стартовой вершины запишем 0.\u003c/li\u003e   \u003cli\u003eСоздаем сет интов \u003cem\u003es\u003c/em\u003e, в него мы будем помещать вершины, которые стоит посетить. Изначально \u003cem\u003es\u003c/em\u003e содержит только стартовую вершину.\u003c/li\u003e   \u003cli\u003eПока \u003cem\u003es\u003c/em\u003e не пустой выполняем следующее\u003c/li\u003e \u003c/ol\u003e \u003cul\u003e   \u003cli\u003eберем вершину с начала \u003cem\u003es\u003c/em\u003e, обозначим ее через \u003cem\u003eu\u003c/em\u003e, удаляем из сета;\u003c/li\u003e   \u003cli\u003eпроходимся по всем ребрам идущим из \u003cem\u003eu\u003c/em\u003e. Пусть текущее ребро соединяет вершину \u003cem\u003eu\u003c/em\u003e с вершиной \u003cem\u003ev\u003c/em\u003e и имеет вес \u003cem\u003ew\u003c/em\u003e. Если \u003cem\u003ecost[u]+w \u0026lt; cost[v]\u003c/em\u003e тогда обновляем значение для \u003cem\u003ecost[v]\u003d cost[u]+w\u003c/em\u003e и добавляем в \u003cem\u003es\u003c/em\u003e вершину \u003cem\u003ev\u003c/em\u003e, так как мы нашли до нее \u0026quot;более короткий\u0026quot; путь.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eВ массиве \u003cem\u003ecost\u003c/em\u003e содержаться минимальные расстояния до каждой вершины.\u003c/p\u003e\u003cp\u003eкод:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003econst int inf\u003d INT_MAX/2;\nconst int MaxN\u003d 2000;\nvector\u0026lt;pii\u0026gt; a[MaxN+5]; // список смежности. \n//a[i][j].vartex – номер вершины смежной с i-ой, \n//a[i][j].weight – вес ребра, соединяющего эти вершины.\nint cost[MaxN+5];\n...\nint u,w;\nint from; //номер стартовой вершины. \n\n// заполняем массив БОЛЬШИМИ значениями\nfor (int i\u003d0; i\u0026lt;\u003dMaxN; i++)\n   cost[i]\u003d inf;\n\nset\u0026lt;int\u0026gt; s;\ns.clear();\n// кладем в начало сета \u0026quot;стартовую вершину\u0026quot; и ставим расстояние до нее 0\ns.insert(from); cost[from]\u003d 0; \nint c;\n\nwhile (!s.empty()) //пока сет не пустой\n{\n    u\u003d *s.begin(); c\u003d cost[u];\n    s.erase(s.begin());\n    for (int i\u003da[u].size()-1; i\u0026gt;\u003d0; i--)\n    {// проходимся по всем вершинам смежным с u\n       if (cost[a[u][i].vartex]\u0026gt;c+a[u][i].weight) \n       {// если до текущей вершины путь через u \u0026quot;короче\u0026quot;\n           cost[a[u][i].vartex]\u003d c+a[u][i].weight; // обновляем значение в массиве\n           s.insert(a[u][i].vartex); // добавляем в сет\n       }\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЯ пока что точно не оценил сложность алгоритма, но надеюсь на что-то вроде \u003cem\u003eO(E logV)\u003c/em\u003e, где \u003cem\u003eV\u003c/em\u003e – количество вершин, а \u003cem\u003eE\u003c/em\u003e – количество ребер в графе. Из возможных преимуществ данного алгоритма можно считать: чуть более краткий код, корректность работы при отрицательном весе ребер. \u003c/p\u003e\u003cp\u003eИ собственно вопрос)) можно ли этот алгоритм считать модификацией Дейкстры или он как-то по-другому называется? Или это вообще не ясно что?))\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD\u003c/strong\u003e Как уже написали хорошие люди, этот алгоритм неэффективный. так что лучше им не пользововаться\u003c/p\u003e\u003c/div\u003e","tags":["дейкстра","вопрос"]}}