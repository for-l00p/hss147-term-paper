{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1472076493,"rating":11,"authorHandle":"Edvard","modificationTimeSeconds":1472511407,"id":46761,"title":"\u003cp\u003eEditorial of Educational Codeforces Round 16\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/710/problem/A\" title\u003d\"Educational Codeforces Round 16\"\u003e710A - King Moves\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eEasy to see that there are only three cases in this problem. If the king is in the corner of the board the answer is \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e. If the king is on the border of the board but not in a corner then the answer is \u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e. Otherwise the answer is \u003cspan class\u003d\"tex-span\"\u003e8\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eС++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003echar c, d;\n\nbool read() {\n\treturn !!(cin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d);\n}\n\nvoid solve() {\n\tint cnt \u003d 0;\n\tif (c \u003d\u003d \u0027a\u0027 || c \u003d\u003d \u0027h\u0027) cnt++;\n\tif (d \u003d\u003d \u00271\u0027 || d \u003d\u003d \u00278\u0027) cnt++;\n\tif (cnt \u003d\u003d 0) puts(\u0026quot;8\u0026quot;);\n\telse if (cnt \u003d\u003d 1) puts(\u0026quot;5\u0026quot;);\n\telse if (cnt \u003d\u003d 2) puts(\u0026quot;3\u0026quot;);\n\telse throw;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/710/problem/B\" title\u003d\"Educational Codeforces Round 16\"\u003e710B - Optimal Point on a Line\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe function of the total distance is monotonic between any pair of adjacent points from the input, so the answer is always in some of the given points. We can use that observation to solve the problem by calculating the total distance for each point from the input and finding the optimal point.\u003c/p\u003e\u003cp\u003eThe other solution uses the observation that the answer is always is the middle point (by index) in the sorted list of the given points. The last fact is also can be easily proven.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003econst int N \u003d 300300;\n\nint n, a[N];\n\nbool read() {\n\tif (!(cin \u0026gt;\u0026gt; n)) return false;\n\tforn(i, n) assert(scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]) \u003d\u003d 1);\n\treturn true;\n}\n\nvoid solve() {\n\tsort(a, a + n);\n\n\tli suml \u003d 0, sumr \u003d accumulate(a, a + n, 0ll);\n\tli ansv \u003d LLONG_MAX, ansp \u003d LLONG_MIN;\n\tforn(i, n) {\n\t\tli curv \u003d li(i) * a[i] - suml;\n\t\tcurv +\u003d sumr - li(n - i) * a[i];\n\t\tif (ansv \u0026gt; curv) {\n\t\t\tansv \u003d curv;\n\t\t\tansp \u003d a[i];\n\t\t}\n\t\tsuml +\u003d a[i];\n\t\tsumr -\u003d a[i];\n\t}\n\tassert(sumr \u003d\u003d 0);\n\n\tassert(ansv !\u003d LLONG_MAX);\n\tcerr \u0026lt;\u0026lt; \u0026quot;ansv: \u0026quot; \u0026lt;\u0026lt; ansv \u0026lt;\u0026lt; endl;\n\tcout \u0026lt;\u0026lt; ansp \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlogn\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/710/problem/C\" title\u003d\"Educational Codeforces Round 16\"\u003e710C - Magic Odd Square\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem was suggested by Resul Hangeldiyev \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/PieceOfCake\" title\u003d\"Expert PieceOfCake\"\u003ePieceOfCake\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThe solution can be got from the second sample testcase. Easy to see that if we place all odd numbers in the center in form of rhombus we will get a magic square.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eint n;\n\nbool read() {\n\treturn !!(cin \u0026gt;\u0026gt; n);\n}\n\nconst int N \u003d 101;\n\nint a[N][N];\n\nvoid solve() {\n\tmemset(a, 0, sizeof(a));\n\n\tforn(i, n / 2) {\n\t\tint len \u003d n / 2 - i;\n\t\tforn(j, len) {\n\t\t\tint x1 \u003d i, x2 \u003d n - 1 - i;\n\t\t\tint y1 \u003d j, y2 \u003d n - 1 - j;\n\t\t\ta[x1][y1] \u003d 1;\n\t\t\ta[x1][y2] \u003d 1;\n\t\t\ta[x2][y1] \u003d 1;\n\t\t\ta[x2][y2] \u003d 1;\n\t\t}\n\t}\n\n\tint odd \u003d 1, even \u003d 2;\n\tforn(i, n)\n\t\tforn(j, n)\n\t\t\tif (a[i][j]) a[i][j] \u003d even, even +\u003d 2;\n\t\t\telse a[i][j] \u003d odd, odd +\u003d 2;\n\n\tforn(i, n) {\n\t\tforn(j, n) {\n\t\t\tif (j) putchar(\u0027 \u0027);\n\t\t\tprintf(\u0026quot;%d\u0026quot;, a[i][j]);\n\t\t}\n\t\tputs(\u0026quot;\u0026quot;);\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/710/problem/D\" title\u003d\"Educational Codeforces Round 16\"\u003e710D - Two Arithmetic Progressions\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eI wanted to give this problem a lot of time ago. I thought it is very standard problem, but I underestimated its difficulty.\u003c/p\u003e\u003cp\u003eLet\u0027s write down the equation describing the problem: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003ci\u003ek\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003ci\u003el\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e → \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003ci\u003ek\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003ci\u003el\u003c/i\u003e \u003d \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e. So we have linear Diofant equation with two variables: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAx\u003c/i\u003e + \u003ci\u003eBy\u003c/i\u003e \u003d \u003ci\u003eC\u003c/i\u003e, \u003ci\u003eA\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eB\u003c/i\u003e \u003d  - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003eC\u003c/i\u003e \u003d \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e. The solution has the form: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b6/27/b627f4b12c644ade30a1f53a31183a23814f2453.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where the last equation can be solved by extended Euclid algorithm and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is any integral number. The variable \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e should satisfy two conditions: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/46/8a/468aa58af8b9c44f96a902a75a4ebb5455b009fb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cd/ed/cded92f893458da06dccb029c5f6660274cca4f9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. The values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e are fixed, so we can get the segment of possible values for the values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e. The length of the segment is the answer for the problem.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eli a1, b1, a2, b2, l, r;\n\nbool read() {\n\treturn !!(cin \u0026gt;\u0026gt; a1 \u0026gt;\u0026gt; b1 \u0026gt;\u0026gt; a2 \u0026gt;\u0026gt; b2 \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r);\n}\n\nli _ceil(li, li);\nli _floor(li a, li b) { return b \u0026lt; 0 ? _floor(-a, -b) : a \u0026lt; 0 ? -_ceil(-a, b) : a / b; }\nli _ceil(li a, li b) { return b \u0026lt; 0 ? _ceil(-a, -b) : a \u0026lt; 0 ? -_floor(-a, b) : (a + b - 1) / b; }\n\nli gcd(li a, li b, li\u0026amp; x, li\u0026amp; y) {\n\tif (!a) {\n\t\tx \u003d 0, y \u003d 1;\n\t\treturn b;\n\t}\n\tli xx, yy, g \u003d gcd(b % a, a, xx, yy);\n\tx \u003d yy - b / a * xx;\n\ty \u003d xx;\n\treturn g;\n}\n\nvoid solve() {\n\tl \u003d max(0ll, _ceil(l - b1, a1));\n\tr \u003d _floor(r - b1, a1);\n\tif (l \u0026gt; r) {\n\t\tputs(\u0026quot;0\u0026quot;);\n\t\treturn;\n\t}\n\n\tli A \u003d a1, B \u003d -a2, C \u003d b2 - b1;\n\tli x0, y0;\n\tli g \u003d gcd(A, B, x0, y0);\n\tif (C % g) {\n\t\tputs(\u0026quot;0\u0026quot;);\n\t\treturn;\n\t}\n\n\tif (g \u0026lt; 0) {\n\t\tg \u003d -g;\n\t\tx0 \u003d -x0;\n\t\ty0 \u003d -y0;\n\t}\n\n\tli L \u003d _ceil(r * g - x0 * C, B);\n\tli R \u003d _floor(l * g - x0 * C, B);\n\tR \u003d min(R, _floor(y0 * C, A));\n\n\tli ans \u003d max(0ll, R - L + 1);\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003emax\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)))\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/710/problem/E\" title\u003d\"Educational Codeforces Round 16\"\u003e710E - Generate a String\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem was suggested by Zi Song Yeoh \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/zscoder\" title\u003d\"Candidate Master zscoder\"\u003ezscoder\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThis problem has a simple solution described by participants in the comments.\u003c/p\u003e\u003cp\u003eMy solution is a little harder. Let\u0027s solve it using dynamic programming. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the smallest amount of time needed to get \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e letters \u0027a\u0027. Let\u0027s consider transitions: the transition for adding one letter \u0027a\u0027 can be simply done. Let\u0027s process transitions for multiplying by two and subtraction by one simultaneously: let\u0027s decrease the number \u003cspan class\u003d\"tex-span\"\u003e2·\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e times by one right after getting it. Easy to see that such updates never include each other, so we can store them in queue by adding the new update at the tail of the queue and taking the best update from the head.\u003c/p\u003e\u003cp\u003eThe solution is hard to describe, but it is very simple in the code, so please check it to understand the idea :-)\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eint n;\nli x, y;\n\nbool read() {\n\treturn !!(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y);\n}\n\nconst int N \u003d 20 * 1000 * 1000 + 13;\n\nli z[N];\n\nvoid solve() {\n\tforn(i, N) z[i] \u003d LLONG_MAX;\n\n\tlist\u0026lt;pair\u0026lt;li, int\u0026gt;\u0026gt; q;\n\n\tz[0] \u003d 0;\n\tforn(i, n + 1) {\n\t\twhile (!q.empty() \u0026amp;\u0026amp; q.front().y \u0026lt; i) q.pop_front();\n\n\t\tif (!q.empty()) z[i] \u003d min(z[i], q.front().x - i * x);\n\t\tassert(z[i] !\u003d LLONG_MAX);\n\n\t\tpair\u0026lt;li, int\u0026gt; cur(z[i] + y + 2 * i * x, 2 * i);\n\t\twhile (!q.empty() \u0026amp;\u0026amp; q.back().x \u0026gt; cur.x) q.pop_back();\n\t\tq.pb(cur);\n\n\t\tz[i + 1] \u003d min(z[i + 1], z[i] + x);\n\t}\n\n\tcout \u0026lt;\u0026lt; z[n] \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/710/problem/F\" title\u003d\"Educational Codeforces Round 16\"\u003e710F - String Set Queries\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem was suggested by Alexandr Kulkov \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/adamant\" title\u003d\"Master adamant\"\u003eadamant\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eLet\u0027s get rid of the queries for deleting a string. There are no strings that will be added two times, so we can calculate the answer for the added (but not deleted strings) and for the deleted separately and subtract the second from the first to get the answer. So we can consider that there are no queries of deletion.\u003c/p\u003e\u003cp\u003eNow let\u0027s use Aho-Corasik algorithm. The only difficulty is that the strings are adding in online mode, but Aho-Corasik algorithm works only after adding all the strings. Note that the answer for the given set of strings equal to the answer for any part of the set plus the answer for the remaining part. Let\u0027s use the trick with converting the static data structure (Aho-Corasik in this case) to the dynamic one.\u003c/p\u003e\u003cp\u003eFor the set of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e strings let\u0027s maintain a set of no more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elogn\u003c/i\u003e\u003c/span\u003e sets of the strings with sizes of different powers of two. After adding new string we should move the sets from the lowest powers of two to the largest until we got an invariant set of sets.\u003c/p\u003e\u003cp\u003eEasy to see that each string will be moved no more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elogm\u003c/i\u003e\u003c/span\u003e times, so we can process each query in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogn\u003c/i\u003e)\u003c/span\u003e time.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003econst int N \u003d 4 * 300300, A \u003d 26, LOGN \u003d 20;\n\nstruct node {\n    char c;\n    int parent, link, output;\n    int next[A], automata[A];\n\t\tint cnt;\n    \n    node(char c \u003d -1, int parent \u003d -1, int link \u003d -1, int output \u003d -1, int cnt \u003d -1):\n        c(c), parent(parent), link(link), output(output), cnt(cnt) {\n        memset(next, -1, sizeof(next));\n        memset(automata, -1, sizeof(automata));\n    }\n};\nnode t[N];\n\nvector\u0026lt;int\u0026gt; ids;\ninline int get_idx() {\n\tassert(!ids.empty());\n\tint ans \u003d ids.back();\n\tids.pop_back();\n\tt[ans] \u003d node();\n\treturn ans;\n}\ninline void return_idx(int idx) {\n\tids.pb(idx);\n}\n\ninline int add(const string\u0026amp; s, int root) {\n    int v \u003d root;\n    forn(i, sz(s)) {\n        if (t[v].next[s[i] - \u0027a\u0027] \u003d\u003d -1) {\n\t\t\t\t\tint idx \u003d get_idx();\n\t\t\t\t\tt[v].next[s[i] - \u0027a\u0027] \u003d idx;\n\t\t\t\t\tt[idx] \u003d node(s[i], v, -1, -1);\n        }\n        v \u003d t[v].next[s[i] - \u0027a\u0027];\n    }\n    t[v].output \u003d v;\n    return v;\n}\nint link(int v, int root) {\n    int\u0026amp; ans \u003d t[v].link;\n    if (ans !\u003d -1) return ans;\n\t\tif (v \u003d\u003d root || t[v].parent \u003d\u003d root) return ans \u003d root;\n    char c \u003d t[v].c;\n    int vv \u003d link(t[v].parent, root);\n    while (vv !\u003d root \u0026amp;\u0026amp; t[vv].next[c - \u0027a\u0027] \u003d\u003d -1)\n        vv \u003d link(vv, root);\n    return ans \u003d (t[vv].next[c - \u0027a\u0027] \u003d\u003d -1? root: t[vv].next[c - \u0027a\u0027]);\n}\nint output(int v, int root) {\n    int\u0026amp; ans \u003d t[v].output;\n    if (ans !\u003d -1) return ans;\n    return ans \u003d (v \u003d\u003d root? root: output(link(v, root), root));\n}\nint cnt(int v, int root) {\n\tint\u0026amp; ans \u003d t[v].cnt;\n\tif (ans !\u003d -1) return ans;\n\tv \u003d output(v, root);\n\tif (v \u003d\u003d root) return ans \u003d 0;\n\treturn ans \u003d 1 + cnt(link(v, root), root);\n}\nint next(int v, char c, int root) {\n    int\u0026amp; ans \u003d t[v].automata[c - \u0027a\u0027];\n    if (ans !\u003d -1) return ans;\n    if (t[v].next[c - \u0027a\u0027] !\u003d -1)\n        return ans \u003d t[v].next[c - \u0027a\u0027];\n    return ans \u003d (v \u003d\u003d root? root: next(link(v, root), c, root));\n}\n\nvoid dfs_clear(int v) {\n\tforn(i, A) if (t[v].next[i] !\u003d -1) dfs_clear(t[v].next[i]);\n\treturn_idx(v);\n}\n\nstring a[N];\n\nint build(int root, const vector\u0026lt;int\u0026gt;\u0026amp; ids) {\n\tdfs_clear(root);\n\troot \u003d get_idx();\n\tforn(i, sz(ids)) add(a[ids[i]], root);\n\treturn root;\n}\n\nint calc(int root, int idx) {\n\tint ans \u003d 0;\n\tconst string\u0026amp; s \u003d a[idx];\n\tint v \u003d root;\n\tforn(i, sz(s)) {\n\t\tv \u003d next(v, s[i], root);\n\t\tans +\u003d cnt(v, root);\n\t}\n\treturn ans;\n}\n\nint m;\n\nbool read() {\n\treturn !!(cin \u0026gt;\u0026gt; m);\n}\n\nstruct blocks {\n\tint root[LOGN];\n\tvector\u0026lt;int\u0026gt; block[LOGN];\n\n\tvoid clear() {\n\t\tforn(i, LOGN) {\n\t\t\tblock[i].clear();\n\t\t\troot[i] \u003d get_idx();\n\t\t}\n\t}\n\n\tvoid insert(int i) {\n\t\tvector\u0026lt;int\u0026gt; cur(1, i);\n\t\tforn(i, LOGN)\n\t\t\tif (sz(block[i]) \u003d\u003d sz(cur)) {\n\t\t\t\tcur.insert(cur.end(), all(block[i]));\n\t\t\t\tblock[i].clear();\n\t\t\t\troot[i] \u003d build(root[i], block[i]);\n\t\t\t} else {\n\t\t\t\tblock[i] \u003d cur;\n\t\t\t\troot[i] \u003d build(root[i], block[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\tli calc2(int idx) {\n\t\tli ans \u003d 0;\n\t\tforn(i, LOGN) {\n\t\t\tans +\u003d calc(root[i], idx);\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nchar buf[N];\nblocks z1, z2;\n\nvoid solve() {\n\tids.clear();\n\tnfor(i, N) ids.pb(i);\n\n\tz1.clear();\n\tz2.clear();\n\n\tforn(i, m) {\n\t\tint type;\n\t\tassert(scanf(\u0026quot;%d%s\u0026quot;, \u0026amp;type, buf) \u003d\u003d 2);\n\t\ta[i] \u003d buf;\n\n\t\tif (type \u003d\u003d 1) {\n\t\t\tz1.insert(i);\n\t\t} else if (type \u003d\u003d 2) {\n\t\t\tz2.insert(i);\n\t\t} else if (type \u003d\u003d 3) {\n\t\t\tli ans \u003d z1.calc2(i) - z2.calc2(i);\n\t\t\tprintf(\u0026quot;%lld\\n\u0026quot;, ans);\n\t\t\tfflush(stdout);\n\t\t} else throw;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003eslen\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003ci\u003elogm\u003c/i\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eslen\u003c/i\u003e\u003c/span\u003e is the total length of the string from the input.\u003c/p\u003e\u003c/div\u003e","tags":["educational round 16","editorial"]}}