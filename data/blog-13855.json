{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1411110003,"rating":94,"authorHandle":"ItsNear","modificationTimeSeconds":1411110255,"id":13855,"title":"\u003cp\u003eMemSQL Start[c]UP 2.0 Round 1 and 2 Editorials\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eRound1\u003c/h1\u003e\u003ch2\u003eProblem B\u003c/h2\u003e\u003cp\u003eThe critical observation in this problem is that the points will be at the corners or very close to the corners. After that one simple solution would be to generate a set of all the points that are within 4 cells from some corner, and consider all quadruplets of points from that set.\u003c/p\u003e\u003ch2\u003eProblem C\u003c/h2\u003e\u003cp\u003eWhen the magician reveals the card, he has \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f0/28/f028d5541a7f35f3ec77da67a801b5f3a1a29b46.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e chance to reveal the same exact card that you have chosen. With the remaining \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b7/f8/b7f8314dcfc2a34a7d6cb6c915774d670059b044.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e chance he will reveal some other card. Since all the cards in all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e decks are equally likely to be in the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e cards that he uses to perform the trick, he is equally likely to reveal any card among the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e × \u003ci\u003em\u003c/i\u003e - 1\u003c/span\u003e cards (-1 for the card that you have chosen, which we assume he has not revealed). There are only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/span\u003e cards that can be revealed that have the same value as the card you chose but are not the card you chose. Thus, the resulting probability is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/48/90/4890a8d9da24af11da9a6cd2c91a0ae588faa25e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch2\u003eProblem D\u003c/h2\u003e\u003cp\u003eOne way to solve this problem is to maintain three deques, one per machine type, each one containing moments of time when the machines of this type will be available in increasing order. Originally each deck has as many zeroes, as many machines of that type are available. For each piece of laundry, see the earliest moment of time when each of the three machines will be available, and chose the time to put it in a washer in such a way, that there will be no delay when you move it to the dryer and to the folder. Remove the first elements from each of the deques, and push back moments of time when the piece of laundry you are processing is washed, dried and folded correspondingly. It can be shown that by doing that you will maintain all the deques sorted.\u003c/p\u003e\u003ch2\u003eProblem E\u003c/h2\u003e\u003cp\u003eThis problem requires one to use one of the datastructures, such as suffix array, suffix tree or suffix automata. The easiest solution uses a compressed suffix tree. Build one suffix tree on all three strings. For simplicity add some non-alphabetic character at the end of each string. For every node in the tree store how many times the corresponding suffix occurs in each string. Then traverse the tree once. If the tree had no shortcuts, for every node that is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e characters away from the root you would have increased the answer for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e by the product of numbers of occurrences of the suffix in each of the strings. Since you do have shortcuts, you need to update the answer for all the lengths from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e are the distances of two ends of the shortcut from the root. One way to do it with constant time updates and linear time to print all the answers is the following. If the array of answers is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, then instead of computing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e we can compute the array of differences \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e, such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e. This way when you traverse the shortcut, rather than adding some value at all the positions from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, you only need to add that value at position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, and subtract it at position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. When \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is computed, it is easy to restore \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in one pass.\u003c/p\u003e\u003ch2\u003eProblem F\u003c/h2\u003e\u003cp\u003eThere are at least two different ways to solve this problem\u003c/p\u003e\u003cp\u003eFirst way is to notice that almost all the permutations have such numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. Consider solving the opposite problem: given \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, build a permutation such that no subsequence of length 3 forms an arithmetic progression. One way to do that is to solve similar problem recursively for odd and even elements and concatenate the answer, i.e. solve it for \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/42/74/42749afbcb5c577b60d7d6a5cc75944bd01cf30a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, and then form the answer for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e as all the elements of the solution for \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/42/74/42749afbcb5c577b60d7d6a5cc75944bd01cf30a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e multiplied by two, followed by those elements multiplied by two minus one. This way we first place all the even numbers of the sequence, and then all the odd or vice versa.\u003c/p\u003e\u003cp\u003eNow one observation that can be made is that all the permutations that don’t have a subsequence of length 3 that is an arithmetic progression are similar, with may be several elements in the middle being mixed up. As a matter of fact, it can be proven that the farthest distance an odd number can have from the odd half (or even number can have from the even part) is 6. With this knowledge we can build simple divide and conquer solution. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u0026lt;  \u003d 20\u003c/span\u003e, use brute force solution, otherwise, if the first and the last elements have the same remainder after division by two, then the answer is YES, otherwise, assuming without loss of generality that the first element is odd, if the distance from the first even element to the last odd element is more than 12, then the answer is YES, otherwise one can just recursively check all the odd elements separately, all the even elements separately, and then consider triplets of numbers, where one number is either in the odd or even part, and two numbers are among the at most 12 elements in the middle. This solution works in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enlog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time. Another approach, that does not rely on the observation above, is to consider elements one by one, from left to right, maintaining a bitmask of all the numbers we’ve seen so far. If the current element we are considering is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, then for every element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e that we saw, if we didn’t see \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e (assuming both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e are between \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e), then the answer is YES. Note that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e was seen and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e was not seen for some \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e if and only if the bitmask is not a palindrome with a center at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. To verify if it is a palindrome or not one can use polynomial hashes, making the complexity to be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e × \u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch1\u003eRound 2\u003c/h1\u003e\u003ch2\u003eProblem A\u003c/h2\u003e\u003cp\u003eThe important observation one needs to make is that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e \u003d \u003ci\u003eq\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sup\u003e + \u003ci\u003eq\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - 2\u003c/sup\u003e\u003c/span\u003e, which means that we can replace two consecutive ‘1’ digits with one higher significance digit without changing the value. Note that sometimes the next digit may become more than ‘1’, but that doesn’t affect the solution.\u003c/p\u003e\u003cp\u003eThere are two different kinds of solutions for this problem\u003c/p\u003e\u003cp\u003eThe first kind of solution involves normalizing both numbers first. The normalization itself can be done in two ways — from the least significant digit or from the highest significant one using the replacement operation mentioned above. In either we will need \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e operations for each number and we then just need to compare them lexicographically.\u003c/p\u003e\u003cp\u003eOther kind of solutions compare numbers digit by digit. We can start from the highest digit of the numbers, and propagate them to the lower digits. On each step we can do the following:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eIf both numbers have ones in the highest bit, then we can replace both ones with zeroes, and move on to the next highest bit.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eNow only one number has one in the highest bit. Without loss of generality let’s say it’s the first number. We subtract one from the highest bit, and add it to the next two highest bits. Now the next two bits of the first number are at least as big as the first two bits of the second number. Let’s subtract the values of these two bits of the second number from both first and second number. By doing so we will make the next two bits of the second numbers become \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. If first number has at least one two, then it is most certainly bigger (because the sum of all the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is smaller than twice \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e + 1\u003c/sup\u003e\u003c/span\u003e). Otherwise we still have only $0$s and $1$s, and can move on to the next highest bit, back to step (1). Since the ordinal of the highest bit is now smaller, and we only spent constant amount of time, the complexity of the algorithm is linear.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003ch2\u003eProblem B\u003c/h2\u003e\u003cp\u003eOne of the optimal strategies in this problem is to locate a node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e with the most rows, then move all the data from the cluster \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e does not belong to onto \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, and then for every other node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e in the cluster that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e belongs to either move all the data from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e onto \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, or move all the rows from the other cluster into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, whichever is cheaper.\u003c/p\u003e\u003ch2\u003eProblem C\u003c/h2\u003e\u003cp\u003eFirst let’s consider a subproblem in which we know how many votes we will have at the end, and we want to figure out how much money we will spend. To solve this problem, one first needs to buy the cheapest votes from all the candidates who have as many or more votes. If after that we still don’t have enough votes, we buy the cheapest votes overall from the remaining pool of votes until we have enough votes. Both can be done in linear time, if we maintain proper sorted lists of votes. This approach itself leads to an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e solution. There are two ways of improving it. One is to come up with a way of computing the answer for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e votes based on the answer for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e votes. If for each number of votes we have a list of candidates, who have at least that many votes, and we also maintain a set of all the votes that are available for sale, then to move from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e we first need to return the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e-th most expensive vote for each candidate that has at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e votes (we had to buy them before, but now we do not have to anymore) back into the pool, and then get that many plus one votes from the pool (that many to cover votes we just returned, plus one because now we need \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e votes, not \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e). This solution has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enlogn\u003c/i\u003e\u003c/span\u003e complexity, if we use a priority queue to maintain the pool of the cheapest votes. In fact, with certain tweaks one can reduce the complexity of moving from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e to amortized constant, but the overall complexity will not improve, since one still needs to sort all the candidates at the beginning.\u003c/p\u003e\u003cp\u003eAnother approach is to notice that the answer for the problem first strictly decreases with the number of votes we want to buy, and then strictly increases, so one can use ternary search to find the number of votes that minimizes the cost.\u003c/p\u003e\u003ch2\u003eProblem D\u003c/h2\u003e\u003cp\u003eThe score function of a board in the problem is \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is number of rows and columns fully covered. Since \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e is the number of all the subsets of a set of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e (including both a full set and an empty set), the score function is essentially the number of ways to select a set of fully covered rows and columns on the board. The problem reduces to computing the expected number of such sets. For a given set of rows \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e and a given set of columns \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e we define \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e as a probability that those rows and columns are fully covered. Then the answer is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/aa/58/aa587938357d5e15fd9343f502926090239e0421.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. For two sets of rows of the same size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e and two sets of columns of the same size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e will be the same, let’s call it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. With that observation the answer can be computed as \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ee/e0/eee0bb7c8dba7c1a79c818ba0c323ab69d41fb06.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e in turn is just the probability that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e + \u003ci\u003ec\u003c/i\u003e) - \u003ci\u003erc\u003c/i\u003e\u003c/span\u003e numbers on the board are chosen from the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e numbers that were called, and the remaining \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e - \u003ci\u003ec\u003c/i\u003e)(\u003ci\u003en\u003c/i\u003e - \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e numbers on the board are chosen from the remaining \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e - (\u003ci\u003en\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e + \u003ci\u003ec\u003c/i\u003e) - \u003ci\u003erc\u003c/i\u003e)\u003c/span\u003e numbers available.\u003c/p\u003e\u003ch2\u003eProblem E\u003c/h2\u003e\u003cp\u003eLet’s begin by considering an arbitrary cycle in the given graph (if one exists). We could add some amount of flow to each edge in the cycle, and doing so must result in an equivalent or worse cost (otherwise the intern’s solution would clearly be non-optimal). Thus if we consider the function c(x) \u003d sum(w_i * (f_i + x)^2), it should be minimized at x\u003d0. Since this function is continuous, a necessary condition is c’(0) \u003d 0. This implies sum(w_i * f_i) \u003d 0 for any cycle.\u003c/p\u003e\u003cp\u003eLet us denote w_i * f_i as the “potential” of an edge. We can define the potential between two vertices in the same connected component as the sum of the potentials of the edges along any path between them. If the potential is not well defined, then the intern’s solution is not optimal. Additionally, the potential from node 1 to any other node must be positive (It cannot be zero because the original graph is biconnected), and similarly the potential from any node to node N must be positive. Furthermore no potential can exceed or equal the potential between node 1 and node N (if they are connected). These conditions can be verified in linear time using a dfs, allowing us to binary search the answer in O(N log N). Alternatively, the union-find algorithm can be modified to track potentials as well as components.\u003c/p\u003e\u003cp\u003eThe true nature of the problem is revealed by making the following replacements:\u003c/p\u003e\u003cp\u003eweight -\u0026gt; resistance\u003c/p\u003e\u003cp\u003ebandwidth -\u0026gt; current\u003c/p\u003e\u003cp\u003ecost -\u0026gt; power\u003c/p\u003e\u003cp\u003epotential -\u0026gt; voltage\u003c/p\u003e\u003cp\u003eThe problem asks you to determine if the given currents in a resistor network are optimal.\u003c/p\u003e\u003ch2\u003eProblem F\u003c/h2\u003e\u003cp\u003eThe solution for this problem is a dynamic programming on a tree with O(n) complexity.\u003c/p\u003e\u003cp\u003eIn this editorial “even tree” means a tree in which players will make an even number of turns, while “odd tree” is the tree in which players will make an odd number of turns.\u003c/p\u003e\u003cp\u003eWe will be solving a slightly modified problem: one in which all the numbers on the leaves are $0$s and $1$s. Once this problem is solved, the general problem can be solved by doing a binary search on the answer, and then marking all the leaves with higher or equal value as $1$s, and all other values as $0$s.\u003c/p\u003e\u003cp\u003eIf the tree is an odd tree, then the first player makes the last turn, and it is enough that at that moment only one of the two children of the root is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. If the tree is an even tree, then the second player makes the last turn, so for the first player it is critical that by that time both children of the tree are \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e if he wants to win.\u003c/p\u003e\u003cp\u003eOne simple case is the case when the tree is an odd tree, and both its immediate subtrees are even trees (by an immediate subtree, or just “subtree‘ of a node, here we will mean a subtree rooted at one of the nodes\u0027 immediate children).\u003c/p\u003e\u003cp\u003eIn this case we can recursively solve each of the immediate subtrees, and if the first player wins any of them, he wins the entire tree. He does that by making his first turn into the tree that he can win, and then every time the second player makes a turn in that tree, responding with a corresponding optimal move, and every time the second player makes a turn in the other tree, making a random move there.\u003c/p\u003e\u003cp\u003eIf both immediate subtrees are odd trees, however, a similar logic will not work. If the second player sees that the first player can win one of the trees, and the first player already made a turn in that tree, the second player can force the first player to play in the other tree, in which the second player will make the last turn, after which the first player will be forced to make a turn in the first tree, effectively making himself do two consecutive turns there. So to win the game the first player needs to be able to win a tree even if the second player has an option to skip one turn.\u003c/p\u003e\u003cp\u003eSo we will need a second dimension to the dynamic programming solution that will indicate whether one of the players can skip one turn or not (we call the two states “canskip” if one can skip a turn and “noskip‘ if such an option does not exist). It can be easily shown, that we don’t need to store how many turns can be skipped, since if two turns can be skipped, and it benefits one player to skip a turn, another player will immediately use another skip, effectively making skips useless.\u003c/p\u003e\u003cp\u003eTo make the terminology easier, we will use a term “we” to describe the first player, and “he” to describe the second player. “we can win a subtree” means that we can win it, if we go first there, “he can win a subtree” means that he can win it if he goes first (so “if one goes first” is always assumed and omitted). If we want to say that “we can win going second”, we will instead say “he cannot win [going first]” or “he loses [going first]”, which has the same meaning\u003c/p\u003e\u003cp\u003eNow we need to consider six cases (three possible parities of children multiplied by whether one can skip a turn or not). In all cases we assume that both children have at least two turns in them left. Cases when a child has no turns left (it is a leaf node), or when it has only one turn left (it is a node whose both children are leaves) are both corner cases and need to be handled separately. It is also important to note, that when one starts handling those corner cases, he will encounter an extra state, when the players have to skip a turn, even if it is not beneficial for whomever will be forced to do that. We call such state “forceskip”. In the case when both subtrees have more than one turn left, forceskip and canskip are the same, since players can always agree to play in such a way, that the skip, if available, is used, without changing the outcome. Below we only describe canskip and noskip cases, in terms of transitions from canskip and noskip states. One will need, however, to introduce forceskip state when he handles corner cases, which we do not describe in this editorial. The answer for forceskip will be the same as the answer for skip in general case, but different for corner cases.\u003c/p\u003e\u003cp\u003eeven-even-noskip: the easiest case, described above, it is enough if we win any of the subtrees with no skip.\u003c/p\u003e\u003cp\u003eeven-even-canskip: this case is similar to a case when there’s one odd subtree and one even subtree, and there’s no skip (the skip can be just considered as an extra turn attached to one of the trees), so the transition is similar to the one for odd-even-noskip case described below. We win iff we can win one tree with canskip, and he cannot win the other with noskip.\u003c/p\u003e\u003cp\u003eodd-even-noskip: if we can win the odd tree without a skip, and he cannot win the even tree without a skip, then we make a turn into the odd tree, and bring it into the even-even-noskip case, where he loses both trees, so we win. The other, less trivial, condition under which we win is If we can win the even tree with canskip, and he can’t win the odd tree with canskip. A motivation for this case is that odd subtree with a skip is similar to an even subtree, so by making a turn into the even case, we bring our opponent to an odd-odd case, where he loses both threes with a skip, which means that no matter which tree he makes a turn into, we will be responding to that tree, and even if he uses another tree to make a skip, he will still lose the tree into which he made his first turn. Since we make the last move, we win.\u003c/p\u003e\u003cp\u003eodd-even-skip: this is a simple case. We can consider the skip as an extra turn in the odd subtree, so as long as we can win even subtree with no skip, or odd subtree with a skip, we win.\u003c/p\u003e\u003cp\u003eodd-odd-noskip: we need to win either of the subtrees with a skip to win.\u003c/p\u003e\u003cp\u003eodd-odd-skip: to handle this case we can first consider immediately skipping: if he loses noskip case for the current subtree, then we win. Otherwise we win iff we can win one of trees with a skip, and he can’t win the other without a skip.\u003c/p\u003e\u003cp\u003eThe more detailed motivation for each of the cases is left as an exercise.\u003c/p\u003e\u003c/div\u003e","tags":["startcup","editorial"]}}