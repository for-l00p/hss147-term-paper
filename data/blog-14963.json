{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1417508488,"rating":0,"authorHandle":"geakstr","modificationTimeSeconds":1417508488,"id":14963,"title":"\u003cp\u003eРазбор контеста 22 ноября\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eA. Короли\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eМожно решать по-разному: написать те или иные условия, посортировать и отобрать по X. \u003c/p\u003e\u003cp\u003eНапример, так\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nint main() \n{\n    int n, m, k, a, b, c;\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c;\n    int j \u003d n * a;\n    int r \u003d m * b;\n    int s \u003d k * c;\n    if (j \u0026gt; r \u0026amp;\u0026amp; j \u0026gt; s)\n        cout \u0026lt;\u0026lt; \u0026quot;Joffrey\u0026quot;;   \n    if (r \u0026gt; j \u0026amp;\u0026amp; r \u0026gt; s)\n        cout \u0026lt;\u0026lt; \u0026quot;Robb\u0026quot;;   \n    if (s \u0026gt; r \u0026amp;\u0026amp; s \u0026gt; j)\n        cout \u0026lt;\u0026lt; \u0026quot;Stannis\u0026quot;;   \n    if (j \u003d\u003d s \u0026amp;\u0026amp; j \u0026gt; r)\n        cout \u0026lt;\u0026lt; \u0026quot;Joffrey Stannis\u0026quot;;   \n    if (r \u003d\u003d j \u0026amp;\u0026amp; r \u0026gt; s)\n        cout \u0026lt;\u0026lt; \u0026quot;Joffrey Robb\u0026quot;;   \n    if (s \u003d\u003d r \u0026amp;\u0026amp; s \u0026gt; j)\n        cout \u0026lt;\u0026lt; \u0026quot;Robb Stannis\u0026quot;;   \n    if (s \u003d\u003d r \u0026amp;\u0026amp; s \u003d\u003d j)\n        cout \u0026lt;\u0026lt; \u0026quot;Joffrey Robb Stannis\u0026quot;;   \n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eB. Проблема\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eСамая сложная задача на контесте. Будем делать всё, как сказано в задании: переберем путь от каждого города и будем выбирать среди таких путей минимум. Так как из каждого города есть прямой путь до любого другого, нет смысла хранить граф \u0026quot;как есть\u0026quot;, просто расположим точки на плоскости по координатам {x, y} и будем ходить между ними до ближайшей. Конечно, нужно запоминать вершины в которых мы уже были.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;memory.h\u0026gt;\n\nusing namespace std;\n\nconst int maxn \u003d 333;\n\nint n, x[maxn], y[maxn];\nbool vis[maxn];\n\nint d(int u, int v) {\n    int ans \u003d 0;\n    ans +\u003d (x[u] - x[v]) * (x[u] - x[v]);\n    ans +\u003d (y[u] - y[v]) * (y[u] - y[v]);\n    return ans;\n}\n\nint rec(int v) {\n    vis[v] \u003d 1;\n    int u \u003d -1;\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        if (!vis[i] \u0026amp;\u0026amp; (u \u003d\u003d -1 || d(v, u) \u0026gt; d(v, i))) {\n            u \u003d i;\n        }\n    }\n    if (u \u003d\u003d -1) return 0;\n    return rec(u) + d(v, u);\n}\n\nint main() {\n    cin \u0026gt;\u0026gt; n;\n    for (int i \u003d 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; y[i];\n    \n    int ans \u003d 2e9;\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        memset(vis, 0, sizeof(vis));\n        ans \u003d min(ans, rec(i));\n    }\n    cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eC. Баскетбол\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eДля каждой строчки будем считать разницу с предыдущей и добавлять ее в соответсвующую игроку ячейку массива. В конце найдем оттуда максимум.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;cassert\u0026gt;\nusing namespace std;\n\n#define taskname \u0026quot;basketball\u0026quot;\n\nint main() \n{\n    int n, m;\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    vector\u0026lt;string\u0026gt; names(n);\n    for (int i \u003d 0; i \u0026lt; n; i++)\n        cin \u0026gt;\u0026gt; names[i];\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;m);\n    int prev_score_a \u003d 0, prev_score_b \u003d 0;\n    vector\u0026lt;int\u0026gt; points(n, 0);\n    for (int q \u003d 0; q \u0026lt; m; q++)\n    {\n        int new_score_a, new_score_b;\n        string name;\n        scanf(\u0026quot;%d:%d\u0026quot;, \u0026amp;new_score_a, \u0026amp;new_score_b);\n        cin \u0026gt;\u0026gt; name;\n        int ind \u003d 0;\n        while (ind \u0026lt; n \u0026amp;\u0026amp; names[ind] !\u003d name)\n            ind++;\n        assert(ind \u0026lt; n);\n        points[ind] +\u003d new_score_a + new_score_b - prev_score_a - prev_score_b;\n        prev_score_a \u003d new_score_a;\n        prev_score_b \u003d new_score_b;\n    }\n    int maxi \u003d 0;\n    for (int i \u003d 1; i \u0026lt; n; i++)\n        if (points[maxi] \u0026lt; points[i])\n            maxi \u003d i;\n    cout \u0026lt;\u0026lt; names[maxi] \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; points[maxi] \u0026lt;\u0026lt; endl;    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eD. Штурм\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eНужно было аккуратно поработать с границами массива.\u003c/p\u003e\u003cp\u003eМожно было создать массив большей размерности и использовать индексы на +1 от границ. Таким образом можно избавиться от условий проверки на выход за границы массива, т.к. мы ходим в существующие ячейки, где значения равны 0.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;vector\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n\nusing namespace std;\n\nconst int MAXN \u003d 201;\nconst int dx[] \u003d {0, 1, 0, -1};\nconst int dy[] \u003d {1, 0, -1, 0};\n\nint a[MAXN][MAXN];\n\nint main()\n{\n  int n, m;\n  cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n  for (int i \u003d 1; i \u0026lt;\u003d n; i++)\n    for (int j \u003d 1; j \u0026lt;\u003d m; j++)\n      cin \u0026gt;\u0026gt; a[i][j];\n  int ans \u003d 0;\n  for (int i \u003d 1; i \u0026lt;\u003d n; i++)\n    for (int j \u003d 1; j \u0026lt;\u003d m; j++)\n    {\n      int cnt \u003d 0;\n      for (int k \u003d 0; k \u0026lt; 4; k++)\n        cnt +\u003d (a[i][j] \u0026gt; a[i + dx[k]][j + dy[k]]);\n      ans +\u003d cnt \u003d\u003d 4;\n    }\n  cout \u0026lt;\u0026lt; ans;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eE. Завоеватель\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВозьмем первое значение и пройдем до конца массива наращивая итоговый ответ, на каждом шаге выбирая минимум скорости с предыдущим значением.\u003c/p\u003e\u003cp\u003eТонкость — на тестах близких к максимально возможным значениям входных данных происходит переполнение типа int в ответе. Нужно использовать типы данных большей размерности.\u003c/p\u003e\u003cp\u003eИсходный код на Java, решение в методе solve().\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport java.io.*;\nimport java.util.*;\n\npublic class conquest_pk {\n\n  BufferedReader br;\n  PrintWriter out;\n  StringTokenizer st;\n\n  public String nextToken() throws IOException {\n    while ((st \u003d\u003d null) || (!st.hasMoreTokens()))\n      st \u003d new StringTokenizer(br.readLine());\n    return st.nextToken();\n  }\n\n  public int nextInt() throws IOException {\n    return Integer.parseInt(nextToken());\n  }\n\n  public double nextDouble() throws IOException {\n    return Double.parseDouble(nextToken());\n  }\n\n  public long nextLong() throws IOException {\n    return Long.parseLong(nextToken());\n  }\n\n  public void solve() throws IOException {\n    int n \u003d nextInt();\n    int speed \u003d nextInt();\n    long time \u003d 0;\n    for (int i \u003d 1; i \u0026lt; n; i++) {\n      time \u003d time + speed;\n      speed \u003d Math.min(nextInt(), speed);\n    }\n    out.println(time);\n  }\n\n  public void run() {\n    try {\n      br \u003d new BufferedReader(new InputStreamReader(System.in));\n      out \u003d new PrintWriter(System.out);\n\n      solve();\n\n      out.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n\n  public static void main(String[] args) {\n    new conquest_pk().run();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}