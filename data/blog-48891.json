{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1481110812,"rating":0,"authorHandle":"Slamur","modificationTimeSeconds":1481112755,"id":48891,"title":"\u003cp\u003eБазовые структуры данных. Java. Коллекции. Множество и словарь\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eДанная лекция заканчивает цикл статей по структурам в Java, расскажет она про множество и словарь.\u003c/p\u003e\u003cp\u003eТак как множество является частным случаем словаря, то текст в двух пунктах будет очень схож, как и примеры кода. Но я все-таки продублирую его для наглядности и отсутствия недопонимания. \u003cbr /\u003e\u003c/p\u003e\u003ch4\u003e4) Множество\u003c/h4\u003e\u003cp\u003eБазовым интерфейсом для множества является Set:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tinterface Set\u0026lt;T\u0026gt; extends Collection\u0026lt;T\u0026gt; {\n\t\t\n\t\t// размер множества\n\t\tint size(); \n\t\t\n\t\t// добавить значение (true, если не было ранее)\n\t\tboolean add(T value);\n\t\t\n\t\t// удалить значение (true, если был до удаления)\n\t\tboolean remove(T value);\n\t\t\n\t\t// проверить наличие значения\n\t\tboolean contains(T value);\n\t\t\n\t\t// поддерживает итерацию по элементам\n\t\tIterator\u0026lt;T\u0026gt; iterator();\n\t\t\n\t\t// очистить множество\n\t\tvoid clear();\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ Java существует две основные реализации множества: HashSet и TreeSet. \u003c/p\u003e\u003cp\u003eHashSet реализован на основе хеш-таблицы и выполняет операции за амортизированное O(1). \u003c/p\u003e\u003cp\u003eВ случае, если подразумевается использовать HashSet с новым классом, то у класса необходимо переопределить equals и hashCode() для корректного сравнения объектов (по умолчанию — сравнение по ссылке). Все стандартные типы работают корректно с HashSet.\u003c/p\u003e\u003cp\u003eНа примере HashSet рассмотрим базовые операции с множествами:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\timport java.util.*;\n\t\n\tSet\u0026lt;Integer\u0026gt; set \u003d new HashSet\u0026lt;Integer\u0026gt;();\n\t\n\tset.add(5);\n\tset.add(3);\n\tset.add(5);\n\tset.add(2);\n\t\n\t// set \u003d {5, 3, 2}\n\t\n\t// выведет 5, 3, 2 в каком-либо порядке (у HashSet порядок не определен)\n\tfor (int value : set) {\n\t\tprint(value);\n\t}\n\t\n\tset.remove(5); // true - { 3, 2 }\n\tset.remove(5); // false - { 3, 2 }\n\t\n\tboolean x \u003d set.contains(3); // x \u003d\u003d true\n\tx \u003d set.contains(4); // x \u003d\u003d false\n\t\n\tSet\u0026lt;String\u0026gt; stringSet \u003d new HashSet\u0026lt;String\u0026gt;();\n\t\n\tstringSet.add(\u0026quot;aa\u0026quot;);\n\tstringSet.add(\u0026quot;bb\u0026quot;);\n\tstringSet.add(\u0026quot;aa\u0026quot;);\n\t\n\t// stringSet \u003d { aa, bb }\n\t// String - стандартный тип, с ним работает корректно\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTreeSet является множеством на основе двоичного дерева поиска, поэтому в нем операции выполняются за O(logN). Зато он хранит элементы в порядке возрастания, а также позволяет делать некоторые запросы намного эффективнее, чем при использовании HashSet.\u003c/p\u003e\u003cp\u003eВажно! Тип хранимых объектов должен быть сравним. String и обертки примитивов удовлетворяют этому требованию.\u003c/p\u003e\u003cp\u003eВот выжимка дополнительных функций из интерфейсов SortedSet и NavigableSet, которые реализует TreeSet:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\t// все перечисленные ниже операции выполняются за O(logN) для TreeSet\u0026lt;T\u0026gt; - очень эффективно для этих операций\n\n\tinterface SortedSet\u0026lt;T extends Comparable\u0026lt;T\u0026gt;\u0026gt; extends Set\u0026lt;T\u0026gt; {\n\t\n\t\t// Важно! Выбросят исключения, если множество пустое\n\t\tT first(); // минимальный элемент\n\t\tT last(); // максимальный элемент\n\t}\n\t\n\t// все описанные функции вернут null в случае отсутствия элемента\n\tinterface NavigableSet\u0026lt;T extends Comparable\u0026lt;T\u0026gt;\u0026gt; extends SortedSet\u0026lt;T\u0026gt; {\n\t\t\n\t\t\n\t\tT pollFirst(); // вернуть минимум и удалить его\n\t\tT pollLast(); // вернуть максимум и удалить его\n\t\t\n\t\t// элемент множества, ближе всего к заданному значению по операции сравнения\n\t\tT lower(T value); // \u0026lt;\n\t\tT floor(T value); // \u0026lt;\u003d\n\t\tT ceiling(T value); // \u0026gt;\u003d\n\t\tT higher(T value); // \u0026gt;\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eРассмотрим применение описанных дополнительных функций:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\timport java.util.*;\n\t\n\tNavigableSet\u0026lt;Integer\u0026gt; set \u003d new TreeSet\u0026lt;Integer\u0026gt;();\n\t\n\tset.add(5);\n\tset.add(2);\n\tset.add(5);\n\tset.add(3);\n\t\n\t// set \u003d {2, 3, 5}\n\t\n\t// выведет 2, 3, 5 в каком-либо порядке\n\tfor (int value : set) {\n\t\tprint(value);\n\t}\n\t\n\t// Так как данные функции могут вернуть null, то лучше юзать обертку для переменной\n\tInteger lower \u003d set.lower(5); // lower \u003d 3\n\tInteger floor \u003d set.floor(5); // floor \u003d 5\n\tInteger ceiling \u003d set.ceiling(5); // ceiling \u003d 5\n\tInteger higher \u003d set.higher(5); // higher \u003d null\n\t\n\tInteger first \u003d set.first(); // first \u003d 2, set \u003d { 2, 3, 5 }\n\tfirst \u003d set.pollFirst(); // first \u003d 2, set \u003d {3, 5}\n\t\n\tInteger last \u003d set.last(); // last \u003d 5, set \u003d {3, 5}\n\tlast \u003d set.pollLast(); // last \u003d 5, set \u003d { 3 }\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e5) Словарь.\u003c/h4\u003e\u003cp\u003eСловарь является единственной структурой, не являющейся формально коллекцией.\u003c/p\u003e\u003cp\u003eТак как множество является частным случаем словаря, то и операции у них схожи — идейно и по названиям. Все операции, которые определены в множестве, определены в словаре для ключей.\u003c/p\u003e\u003cp\u003eБазовым интерфейсом для словарь является Map\u0026lt;K, V\u0026gt;:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tinterface Map\u0026lt;K, V\u0026gt; {\n\t\t\n\t\t// размер словаря\n\t\tint size(); \n\t\t\n\t\t// для ключа key положить значение value\n\t\t// возващает предыдущее значение для key\n\t\tV put(K key, V value);\n\t\t\n\t\t// для ключа key удалить значение\n\t\t// возващает удаленное  значение для key\n\t\tV remove(K key);\n\t\t\n\t\t// вернуть значение по заданному ключу\n\t\tV get(K key);\n\t\t\n\t\t// проверить наличие ключа\n\t\tboolean containsKey(K key);\n\t\t\n\t\t// проверить наличие значения\n\t\t// Настоятельно не рекомендуется для использования!\n\t\t// Важно! Выполняется за O(N) независимо от типа словаря!\n\t\tboolean containsValue(V value);\n\t\t\n\t\t// Возвращает множество всех пар \u0026lt;Ключ, Значение\u0026gt;\n\t\t// Удобно для итерации по элементам словаря\n\t\t// Важно! Изменение данного множества изменяет словарь!\n\t\t// Важно! Данное множество не является HashSet или TreeSet, это специальная реализация Set.\n\t\tSet\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; entrySet();\n\t\t\n\t\t// Сам интерфейс Entry\u0026lt;K, V\u0026gt;\n\t\tinterface Entry\u0026lt;K, V\u0026gt; {\n\t\t\tK getKey();\n\t\t\tV getValue();\n\t\t}\n\t\t\n\t\t// Возвращает множество всех ключей словаря\n\t\t// Является оберткой для entrySet()\n\t\tSet\u0026lt;K\u0026gt; keySet();\t\n\t\t\n\t\t// Возвращает коллекцию всех значений словаря\n\t\t// Является оберткой для entrySet()\n\t\t// Важно! Это не множество, так как значения могут повторяться в словаре!\n\t\tCollection\u0026lt;V\u0026gt; values();\t\n\t\t\n\t\t// очистить словарь\n\t\tvoid clear();\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ Java существует две основные реализации словаря: HashMap\u0026lt;K, V\u0026gt; и TreeMap\u0026lt;K, V\u0026gt;. \u003c/p\u003e\u003cp\u003eHashMap\u0026lt;K, V\u0026gt; реализован на основе хеш-таблицы и выполняет операции за амортизированное O(1). \u003c/p\u003e\u003cp\u003eВ случае, если подразумевается использовать HashMap\u0026lt;K, V\u0026gt; с новым классом ключа, то у класса необходимо переопределить equals и hashCode() для корректного сравнения объектов (по умолчанию — сравнение по ссылке). Все стандартные типы работают корректно в качестве ключей HashMap\u0026lt;K, V\u0026gt;.\u003c/p\u003e\u003cp\u003eНа примере HashMap\u0026lt;K, V\u0026gt; рассмотрим базовые операции со словарями:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\timport java.util.*;\n\t\n\tMap\u0026lt;String, Integer\u0026gt; map \u003d new HashMap\u0026lt;String, Integer\u0026gt;();\n\t\n\t// посчитаем количество вхождений каждой строки в массив\n\tString[] strings \u003d { \u0026quot;bbb\u0026quot;, \u0026quot;aaa\u0026quot;, \u0026quot;bbb\u0026quot;, \u0026quot;ccc\u0026quot; };\n\tfor (String s : strings) {\n\t\t// если для ключа нет значения, то возвращается null\n\t\tInteger count \u003d map.get(s);\n\t\tif (count \u003d\u003d null) count \u003d 0;\n\t\t\n\t\t// put перезаписывает значение (см. bbb)\n\t\tmap.put(s, count + 1);\n\t}\n\t\n\t// map \u003d { [aaa, 1], [bbb, 2], [ccc, 1] }\n\t\n\t// выведет \u0026quot;aaa -\u0026gt; 1\u0026quot;, \u0026quot;bbb -\u0026gt; 2\u0026quot;, \u0026quot;ccc -\u0026gt; 1\u0026quot; в каком-либо порядке (у HashMap порядок не определен)\n\tfor (Map.Entry\u0026lt;String, Integer\u0026gt; e : map.entrySet()) {\n\t\tprint(e.getKey() + \u0026quot; -\u0026gt; \u0026quot; + e.getValue());\n\t}\n\t\n\t// выведет aaa, bbb, ccc в порядке таком же, как у entrySet()\n\tfor (String key : map.keySet()) {\n\t\tprint(key);\n\t}\n\t\n\t// выведет 2, 1, 1 в порядке таком же, как у entrySet()\n\tfor (int value : map.values()) {\n\t\tprint(value);\n\t}\n\t\n\tboolean x \u003d map.containsKey(\u0026quot;aaa\u0026quot;); // x \u003d\u003d true\n\tx \u003d set.containsKey(\u0026quot;abc\u0026quot;); // x \u003d\u003d false\n\t\n\t// Настоятельно не рекомендуется для использования - работает за O(N)\n\tboolean y \u003d map.containsValue(2); // y \u003d\u003d true\n\ty \u003d map.containsValue(3); // y \u003d\u003d false\n\t\n\tInteger count \u003d map.remove(\u0026quot;bbb\u0026quot;); // count \u003d 2, map \u003d { [aaa, 1], [ccc, 1] }\n\tcount \u003d map.remove(\u0026quot;bbb\u0026quot;); // count \u003d null, map \u003d { [aaa, 1], [ccc, 1] }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTreeMap\u0026lt;K, V\u0026gt; является словарем на основе двоичного дерева поиска по ключам, поэтому в нем операции над ключами выполняются за O(logN). Зато он хранит ключи в порядке возрастания, а также позволяет делать некоторые запросы для ключей намного эффективнее, чем при использовании HashMap.\u003c/p\u003e\u003cp\u003eВажно! Тип ключей должен быть сравним. String и обертки примитивов удовлетворяют этому требованию.\u003c/p\u003e\u003cp\u003eВот выжимка дополнительных функций из интерфейсов SortedMap\u0026lt;K, V\u0026gt; и NavigableMap\u0026lt;K, V\u0026gt;, которые реализует TreeMap\u0026lt;K, V\u0026gt;:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\t// все перечисленные ниже операции выполняются за O(logN) для TreeMap\u0026lt;K, V\u0026gt; - очень эффективно для этих операций\n\n\tinterface SortedMap\u0026lt;K extends Comparable\u0026lt;K\u0026gt;, V\u0026gt; extends Map\u0026lt;K, V\u0026gt; {\n\t\n\t\t// Важно! Выбросят исключения, если множество пустое\n\t\tK firstKey(); // минимальный ключ\n\t\tK lastKey(); // максимальный ключ\n\t}\n\t\n\t// все описанные функции вернут null в случае отсутствия элемента\n\tinterface NavigableMap\u0026lt;K extends Comparable\u0026lt;K\u0026gt;, V\u0026gt; extends SortedMap\u0026lt;K, V\u0026gt; {\n\t\t\n\t\tK pollFirstKey(); // вернуть минимальный ключ и удалить его\n\t\tK pollLastKey(); // вернуть максимальный ключ и удалить его\n\t\t\n\t\t// ключ, ближе всего к заданному значению по операции сравнения\n\t\tK lowerKey(K key); // \u0026lt;\n\t\tK floorKey(K key); // \u0026lt;\u003d\n\t\tK ceilingKey(K key); // \u0026gt;\u003d\n\t\tK higherKey(K key); // \u0026gt;\n\t\t\n\t\t// аналогично операциям над ключами, есть такие же операции с результатом \u0026quot;ключ-значение\u0026quot;\n\t\t\n\t\t// вернут null, а не выбросят исключение при пустом словаре\n\t\tMap.Entry\u0026lt;K, V\u0026gt; firstEntry();\n\t\tMap.Entry\u0026lt;K, V\u0026gt; lastEntry();\n\t\t\n\t\tMap.Entry\u0026lt;K, V\u0026gt; pollFirstEntry();\n\t\tMap.Entry\u0026lt;K, V\u0026gt; pollLastEntry();\n\t\t\n\t\tMap.Entry\u0026lt;K, V\u0026gt; lowerEntry(K key); // \u0026lt;\n\t\tMap.Entry\u0026lt;K, V\u0026gt; floorEntry(K key); // \u0026lt;\u003d\n\t\tMap.Entry\u0026lt;K, V\u0026gt; ceilingEntry(K key); // \u0026gt;\u003d\n\t\tMap.Entry\u0026lt;K, V\u0026gt; higherEntry(K key); // \u0026gt;\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eРассмотрим применение описанных дополнительных функций:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\timport java.util.*;\n\t\n\tNavigableMap\u0026lt;String, Integer\u0026gt; map \u003d new TreeMap\u0026lt;String, Integer\u0026gt;();\n\t\n\t// посчитаем количество вхождений каждой строки в массив\n\tString[] strings \u003d { \u0026quot;bbb\u0026quot;, \u0026quot;aaa\u0026quot;, \u0026quot;bbb\u0026quot;, \u0026quot;ccc\u0026quot; };\n\tfor (String s : strings) {\n\t\tInteger count \u003d map.get(s);\n\t\tif (count \u003d\u003d null) count \u003d 0;\n\t\t\n\t\tmap.put(s, count + 1);\n\t}\n\t\n\t// map \u003d { [aaa, 1], [bbb, 2], [ccc, 1] }\n\t\n\t// выведет \u0026quot;aaa -\u0026gt; 1\u0026quot;, \u0026quot;bbb -\u0026gt; 2\u0026quot;, \u0026quot;ccc -\u0026gt; 1\u0026quot; (по возрастанию строк в лексикографическом порядке)\n\tfor (Map.Entry\u0026lt;String, Integer\u0026gt; e : map.entrySet()) {\n\t\tprint(e.getKey() + \u0026quot; -\u0026gt; \u0026quot; + e.getValue());\n\t}\n\t\n\t// выведет aaa, bbb, ccc\n\tfor (String key : map.keySet()) {\n\t\tprint(key);\n\t}\n\t\n\t// выведет 1, 2, 1\n\tfor (int value : map.values()) {\n\t\tprint(value);\n\t}\n\t\n\tString first \u003d map.firstKey(); // first \u003d \u0026quot;aaa\u0026quot;, map \u003d { [aaa, 1], [bbb, 2], [ccc, 1] }\n\tMap.Entry\u0026lt;String, Integer\u0026gt; firstEntry \u003d map.firstEntry(); // firstEntry \u003d [aaa, 1], map \u003d { [aaa, 1], [bbb, 2], [ccc, 1] }\n\t\n\tString last \u003d map.lastKey(); // last \u003d \u0026quot;ccc\u0026quot;, map \u003d { [aaa, 1], [bbb, 2], [ccc, 1] }\n\tMap.Entry\u0026lt;String, Integer\u0026gt; lastEntry \u003d map.lastEntry(); // lastEntry \u003d [ccc, 1], map \u003d { [aaa, 1], [bbb, 2], [ccc, 1] }\n\t\n\tString lowerKey \u003d map.lowerKey(\u0026quot;bbb\u0026quot;); // lowerKey \u003d aaa\n\tMap.Entry\u0026lt;String, Integer\u0026gt; floorEntry \u003d map.floorEntry(\u0026quot;bbb\u0026quot;); // floorEntry \u003d [bbb, 2]\n\tString ceilingKey \u003d map.ceilingKey(\u0026quot;bbb\u0026quot;); // ceilingKey \u003d bbb\n\tMap.Entry\u0026lt;String, Integer\u0026gt; higherEntry \u003d map.higherEntry(\u0026quot;bbb\u0026quot;); // higherEntry \u003d [ccc, 1]\n\t\n\tfirst \u003d map.pollFirstKey(); // first \u003d \u0026quot;aaa\u0026quot;, map \u003d { [bbb, 2], [ccc, 1] }\n\tfirstEntry \u003d map.pollFirstEntry(); // firstEntry \u003d [bbb, 2], map \u003d { [ccc, 1] }\n\t\n\tlast \u003d map.pollLastKey(); // last \u003d ccc, map \u003d { } \n\tlastEntry \u003d map.pollLastEntry(); // lastEntry \u003d null, map \u003d {  }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["самара","структруры данных","коллекции","java","множество","словарь"]}}