{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1499441326,"rating":-8,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1499482967,"id":53160,"title":"\u003cp\u003eNotes on Codeforces Beta Round #59, A, B, C, D, E (Bit-Mask technique and how to implement transition among states)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/63/problem/A\" title\u003d\"Codeforces Beta Round 59 (Div. 2)\"\u003e63A - Sinking Ship\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe solution to this problem is straightforward. We can enumerate the elements in the given order, and store every one of them in an appropriate array. For instance, we can adopt four arrays A, B, C and D, which represent \u0026quot;rat\u0026quot;, \u0026quot;woman and child\u0026quot;, \u0026quot;man\u0026quot; and \u0026quot;captain\u0026quot;, respectively. For each element, we just put it into the correct array and finally we output the elements stored in the arrays in the order of A, B, C and D.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/63/problem/B\" title\u003d\"Codeforces Beta Round 59 (Div. 2)\"\u003e63B - Settlers\u0027 Training\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe can simulate the process of training and count the number of coins that we need to meet the requirement. We can adopt a hash table H[n] to represent the number of people belonging to different ranks. For instance, H[i] denotes the number of people belonging to rank i. Then, we scan the hash table H[n] from k-1 to 1, and as the problem claims, whenever we find that H[i]\u0026gt;0, we just decrease H[i] by 1 while increasing H[i+1] by 1. The above operations should be repeated until we find that H[k]\u003dn is satisfied, and the number of loops is just the answer.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/63/problem/C\" title\u003d\"Codeforces Beta Round 59 (Div. 2)\"\u003e63C - Bulls and Cows\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAt first, we enumerate all the integers from 0 (in fact this is 0000) to 9999, inclusively. For each enumeration, if all the four digits are different, then it can be viewed as a reasonable integer that is selected by the thinker. Given such an integer, for each guessed number, we can directly calculate the number of digits that give both correct values and positions, and the number of digits that only give correct values but incorrect positions as well. Then, we compare these results with the number of \u0026quot;bulls\u0026quot; and \u0026quot;cows\u0026quot;. If they are exactly the same for all the guessed numbers, it means that the integer in the current enumeration can serve as a correct \u0026quot;data\u0026quot;. After all the enumeration has been completed, if the number of correct \u0026quot;data\u0026quot; is larger than 1, it means that we \u0026quot;Need more data\u0026quot;; if the number of correct \u0026quot;data\u0026quot; is exactly equal to 1, it means that the \u0026quot;data\u0026quot; is enough and we can just output this correct \u0026quot;data\u0026quot;; if the number of \u0026quot;data\u0026quot; is equal to 0, it means that the thinker must have made a mistake and we should output \u0026quot;Incorrect data\u0026quot;.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/63/problem/D\" title\u003d\"Codeforces Beta Round 59 (Div. 2)\"\u003e63D - Dividing Island\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFor problem like this one, we can fill the grids like a snake. If a is an even number, we can start from the upper left corner and go down first to fill the first column, and then we reach the bottom of the second column and go up to fill the second column, and so on. If a is an odd number, we should start from the bottom left corner and go up first to fill the first column, and then we arrive at the top of the second column and go down to fill the second column, and so on. With the above operations, it can be seen that we can \u0026quot;safely\u0026quot; switch from the last column of \u0026quot;b*a square\u0026quot; to the first column of \u0026quot;d*c square\u0026quot;.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/63/problem/E\" title\u003d\"Codeforces Beta Round 59 (Div. 2)\"\u003e63E - Sweets Game\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI think this is really a nice problem to practice the bit-mask technique, and be familiar with the transition among different states, which has also been frequently used in bit-mask Dynamic Programming technique. I think it mainly contains the following steps:\u003c/p\u003e\u003cp\u003e1) Given M positions, we usually use \u0026quot;1\u0026quot; to denote that some position has been taken while \u0026quot;0\u0026quot; to denote that the position is NULL. Therefore, the total number of states should be (1\u0026lt;\u0026lt;M)\u003d2^M. If M\u0026lt;32, it suffices to use an \u0026quot;int\u0026quot; to cover all the potential states, since the binary form of \u0026quot;int\u0026quot; just consists of \u0026quot;0\u0026quot; or \u0026quot;1\u0026quot;. For instance, for an integer i\u003d5 with binary form of i\u003d(101), it means that the first and third position have been taken while the other ones are NULL. Alternatively, one can also use the most significant bit to denote the first position. \u003c/p\u003e\u003cp\u003e2) For each state S, it can transit to another state T by implementing some \u0026quot;move\u0026quot;. In general, we still use an \u0026quot;int\u0026quot; to denote the \u0026quot;move\u0026quot;, as done in step 1). However, for many problems (not all), a reasonable \u0026quot;move\u0026quot; should satisfy the following condition\u003c/p\u003e\u003cp\u003e(S \u0026amp; move) \u003d\u003d move\u003c/p\u003e\u003cp\u003eThis constraint implies that we can only take away \u0026quot;1\u0026quot; at state S rather than \u0026quot;0\u0026quot;, since \u0026quot;0\u0026quot; means NULL and there is nothing can be taken. For instance, S\u003d(101), thus move\u003d(100) is reasonable however move\u003d(110) is not. \u003c/p\u003e\u003cp\u003e3) With a reasonable move, another state T can be reached by T\u003d (S ^ move). (S ^ move) in fact achieves the effect that some \u0026quot;1\u0026quot;s at state S have been taken by the \u0026quot;move\u0026quot;. For instance, S\u003d(101), move\u003d(100), and thus we have T\u003d S ^ move\u003d(001).\u003c/p\u003e\u003cp\u003e4) In general, we can enumerate all the states from 0 to (1\u0026lt;\u0026lt;M)-1, inclusively, or from (1\u0026lt;\u0026lt;M)-1 to 0, according to the problem. For each enumeration, we generate all the possible \u0026quot;move\u0026quot; and only select the reasonable ones to obtain the next states that can be transited to. For instance, for this problem we are taking away \u0026quot;1\u0026quot; from some state S, and thus we can start the enumeration from 0 to (1\u0026lt;\u0026lt;M)-1. The state S\u003d0 is initialized to be \u0026quot;losing state\u0026quot;. Note that for each state S during the enumeration, (S ^ move)\u0026lt; S always holds. Thus, the next states that S can transit to have been already determined to result in \u0026quot;winning state\u0026quot; or \u0026quot;losing state\u0026quot;, and the current state S can be determined as well.\u003c/p\u003e\u003c/div\u003e","tags":[]}}