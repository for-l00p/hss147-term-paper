{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1457642477,"rating":74,"authorHandle":"baobab","modificationTimeSeconds":1457738853,"id":43723,"title":"\u003cp\u003eO(n) solution for 631E (Convex Hull Trick special case)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThe editorial and other published solutions for \u003ca href\u003d\"//codeforces.com/contest/631/problem/E\"\u003ethis problem\u003c/a\u003e have at least O(n log n) time complexity. Here is a O(n) solution.\u003c/p\u003e\u003cp\u003etl;dr for those who solved this problem with the Convex Hull Trick is that we can keep lines in a queue rather than a tree/sorted list, because we only add lines of increasing/decreasing slope. This solution doesn\u0027t require conceptualizing the geometry though .\u003c/p\u003e\u003ch4\u003eExplanation with examples\u003c/h4\u003e\u003cp\u003eWe have 2 cases: moving an item forwards or backwards. Since they are mirrors of each other, I\u0027ll only talk about the forwards case.\u003c/p\u003e\u003cp\u003eWe iterate from 2-\u0026gt;n and for each index we want to answer \u0026quot;which previously seen item is the best choice to move here?\u0026quot;. We\u0027re going to build a queue where the first item of the queue is always the answer to this question. Why is this possible? Let\u0027s look at some examples:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e[6,2,3,9,0,0,0] Input\n[-,6,6,6,6,9,9] Best choice\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTo start, we put an item representing the 6 into our queue. As we pass through 2 and 3 we calculate the value for moving the 6 there, but we don\u0027t have to consider adding 2 or 3 to the queue. Intuitively, we want the small items to the left and the large items to the right. When we move from left to right and a new item is smaller than the largest item we\u0027ve previously seen, it\u0027s always better to move the \u003cem\u003elarge item many steps\u003c/em\u003e rather than the \u003cem\u003esmall item fewer steps\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eWe reach 9 and it\u0027s larger than 6, so we consider adding it to the queue. We want to know at what point it becomes better to move the 9 rather than the 6. Well, if we moved the 6 onto the 9 we would gain 6*3 and lose (9+2+3) \u003d 4. We can consider this value as the \u0026quot;head start\u0026quot; that 6 has over 9. Then each additional step that we move the 6, we gain +6-t[i]. If we moved 9 instead of 6, each step would yield +9-t[i]. So each step further 9 \u0026quot;catches up\u0026quot; 6 by 3 points. This means that we can trivially calculate the index where 9 becomes a better choice.\u003c/p\u003e\u003cp\u003eAfter 9 we have 2 items in the queue:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eFIRST \u003d [0,1] (where 0 is the index for 6 and 1 is the index where 6 becomes the best choice to move)\nLAST \u003d [3,5] (where 3 is the index for 9 and 5 is the index where 9 becomes the best choice to move)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe could also have more than 2 items in the queue. Imagine the following input:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e[5,0,0,0,0,0,6,0,0,7,0,0,0,0...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIntuitively, 5 will be the best choice to move for a long time. At some point 6 takes over, then 7 takes over. We\u0027re going to have 3 items in the queue. It\u0027s not obvious why the last item is always added to the end of the queue, or at least it\u0027s not obvious to me. Let\u0027s think about the following input:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e[5,0,6,1000,0,0]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen we reach the 1000 it becomes the best item to move, so we want to put it to the front of the queue, right? Well, not exactly. 5 and 6 become obsolete so we want to remove them from the queue, then we add 1000 to the end of the (now empty) queue. This is still pretty obvious, but can we say for sure there\u0027s never a case where we would want to add something to the middle of the queue? Remember that every item we add is larger than the largest previously seen item. Remember also that the larger item always \u0026quot;catches up\u0026quot; in score as you step more to the right. This means that once a larger item becomes best choice, it\u0027s impossible for a smaller item to become best choice later on. Thus, we always add items to the end of the queue, after possibly removing obsolete items. Sometimes we also need to remove obsolete items from the front of the queue. As for time complexity, whenever we read more than 3 items from the queue, we are removing items. Each item can only be added once (and thus can only be removed once). This gives us O(n) time complexity.\u003c/p\u003e\u003cp\u003eThe geometric version of this explanation would be that our queue represents the Convex Hull and we can add to the end of the queue because we only add lines of increasing slope. When we want to get the \u0026quot;current line\u0026quot; of the Convex Hull we can — rather than binary/ternary searching — just read the first item of the queue, because as we step to the right we erase obsolete lines off the convex.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/631/submission/16639027\"\u003eHere\u003c/a\u003e is my commented java implementation.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/631/submission/16641609\"\u003eHere\u003c/a\u003e is a better C++ implementation by \u003ca href\u003d\"//codeforces.com/profile/ffao\"\u003effao\u003c/a\u003e (edited into this post)\u003c/p\u003e\u003cp\u003eI struggled with my Convex Hull Trick implementation for a long time so it was pretty satisfying to find an alternate solution with better time complexity. Thanks to \u003ca href\u003d\"//codeforces.com/profile/zscefn\"\u003ezscefn\u003c/a\u003e, \u003ca href\u003d\"//codeforces.com/profile/pllk\"\u003epllk\u003c/a\u003e, \u003ca href\u003d\"//codeforces.com/profile/Laakeri\"\u003eLaakeri\u003c/a\u003e and \u003ca href\u003d\"//codeforces.com/profile/OliKoJo\"\u003eOliKoJo\u003c/a\u003e for helping me debug \u0026amp; helping me understand the geometry behind this.\u003c/p\u003e\u003c/div\u003e","tags":["geometry","convexhull","convex hull optimization"]}}