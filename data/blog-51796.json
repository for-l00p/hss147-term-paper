{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1493682542,"rating":76,"authorHandle":"Swistakk","modificationTimeSeconds":1493682542,"id":51796,"title":"\u003cp\u003eSome questions about past ACM-ICPC WF problems\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello. I gathered some questions about older (2006-2008) problems. As commonly agreed, if you possibly plan to ever use these problemsets for training then please do not read this blog in order not to spoil valuable problemsets. But if you know these problems/solved them or whatever then maybe you can answer some of them.\u003c/p\u003e\u003cp\u003eLink to past problems is here: \u003ca href\u003d\"https://icpc.baylor.edu/worldfinals/problems\"\u003ehttps://icpc.baylor.edu/worldfinals/problems\u003c/a\u003e\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eProblem C 2006 \u0026quot;Ars Longa\u0026quot;\u003cbr /\u003e How to solve it? We have an idea how to determine which of these 2 conditions hold: 1) non-static, 2) unstable or stable, however we do not know how to distinguish unstable and stable. Since every rod affects two balls on its ends with opposite forces (parallel to rod) we can create a variable on coefficient how this rod affects balls and create equations for every coordinate of every not glued to floor ball stating that resulting force is 0 and use Gauss to check whether such system has solution. If it has then construction is static. It seems that in order to check stability we should try using force on every ball (in 3 different directions) and check whether system still has solution, but if we are not mistaken this reasoning fails for a case of a cube (with one side lying on floor) with 4 main diagonals. It is stable, but I think there are no good coefficients for rods if we want to neutralize horizontal force applied to one ball. Did we assume wrong physics model? Or did we simply make some silly mistake along the way?\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eProblem H 2006 \u0026quot;Pockets\u0026quot;\u003cbr /\u003e I think this is algorithmically relatively simple problem, I coded it, but I keep getting WA/RTE and I came to the point when I suspect the test data is wrong. If I get RTE this is because of various asserts I put in my code. I deduced that my code thinks that resulting sheet has width 6 or 7 on test it fails on ejudge (thanks to asserts), but computing that width alone is relatively simple. I stress-tested my solution on many tests and that gave 0 errors, I have read that simple part many times and I see no errors. Is there anyone that got this problem accepted?\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eProblem H 2007 \u0026quot;Raising the roof\u0026quot;\u003cbr /\u003e I don\u0027t how to solve it faster than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eT\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e (with significant constant) what clearly would get TLE. Solution in such complexity is pretty straightforward algorithmically, so I won\u0027t go into details. I have an idea that might result in faster program, but I don\u0027t know if it really does. For every pair of triangles we might compute whether one of them covers another one and in such case create a directed edge between them. Such graph is acyclic, so we can process these triangles in topological order, starting from highest ones. When considering some fixed trinalge in order to compute its visible part it suffices to look at this triangle from above and substract regions that are covered by already processed triangles. When done naively that is too slow, but if we store sum of already processed triangles as some set of boundaries maybe that will speed it up. If it would be allowed to give us many thin triangles such boundary will be of quadratic size, so no improvement is done, but maybe since those triangles have small amount of different vertices (at most V\u0026lt;\u003d300) it is possible to give better bound? Or maybe there is a different approach?\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eProblem C 2008 \u0026quot;Conveyor Belt\u0026quot;\u003cbr /\u003e I coded simplest possible approach (backtrack considering all possibilities in every step) with some time-heuristics and got OK on my first submission. Then I removed all heuristics and it still gets OK. I can\u0027t bound running time by something better than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e!)\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is up to 20), but I can\u0027t also construct a case when it needs a lot of work (worst I came up with was \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/31/52/3152e032f8b7f8aa01581edbf430f9759f06fea9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and I think higher constant may be achieved). Both proving better complexity bound than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e!)\u003c/span\u003e and constructing cases worse than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ec\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e for some constant c both seem to be challenging problems. Is someone able of doing either of these? Or maybe there is a completely different approach in better complexity (I doubt that)? Or did judges simply pose a problem that they have some solution for that simply empirically runs fast enough on their test data?\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003c/div\u003e","tags":["wf","acm","icpc","finals"]}}