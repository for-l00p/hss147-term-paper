{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1486006500,"rating":7,"authorHandle":"Iwaskid","modificationTimeSeconds":1486082209,"id":50183,"title":"\u003cp\u003eSegment Tree Implementation (Lazy Propagation)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi all, I am trying to code up a solution to the \u0026quot;\u003ca href\u003d\"http://www.usaco.org/index.php?page\u003dviewproblem2\u0026amp;cpid\u003d231\"\u003eSeating\u003c/a\u003e\u0026quot; problem in USACO January 2013 Gold, which uses a segment tree with lazy propagation. My code passes the first 2 test cases, but fails the rest. I have checked multiple times about my code but I don\u0027t see the problem.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;fstream\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n#include\u0026lt;assert.h\u0026gt;\n#include\u0026lt;string\u0026gt;\n#include\u0026lt;vector\u0026gt;\nusing namespace std;\nint n, m;\nint t;\nvector\u0026lt;int\u0026gt; A;\nvector\u0026lt;int\u0026gt; l0, r0, lazy0, lazy1,ans;\n\nvoid build(int a,int l,int r) {\n\tif (r - l \u0026lt; 1) {\n\t\tl0[a] \u003d 1;\n\t\tr0[a] \u003d 1;\n\t\tans[a] \u003d 1;\n\t\treturn;\n\t}\n\tl0[a] \u003d r - l + 1;\n\tr0[a] \u003d r - l + 1;\n\tans[a] \u003d r - l + 1;\n\tbuild(a * 2, l, (r + l) / 2);\n\tbuild(a * 2 + 1, (r + l) / 2 + 1, r);\n}\nvoid lazyupdate(int a,int l,int r) {\n\tassert(!(lazy0[a]\u003d\u003d1\u0026amp;\u0026amp; lazy1[a]));\n\tif (lazy0[a]) {\n\t\tlazy0[a] \u003d 0;\n\t\tl0[a] \u003dans[a]\u003d r - l + 1;\n\t\tr0[a] \u003d r - l + 1;\n\t\tif (l !\u003d r) { lazy0[2 * a] \u003d 1; lazy0[2 * a + 1] \u003d 1; lazy1[2 * a] \u003d 0; lazy1[2 * a + 1] \u003d 0; }\n\t}\n\telse if (lazy1[a]) {\n\t\tl0[a] \u003d ans[a]\u003dr0[a] \u003d 0;\n\t\tif (l !\u003d r) { lazy1[2 * a] \u003d 1; lazy1[2 * a + 1] \u003d 1; lazy0[2 * a] \u003d 0; lazy0[2 * a + 1] \u003d 0; }\n\t\tlazy1[a] \u003d 0;\n\t}\n}\nvoid updateint(int a, int l, int r) {\n\tint left \u003d 2 * a, right \u003d 2 * a + 1;\n\tl0[a] \u003d ans[a] \u003d r0[a] \u003d 0;\n\tif (l0[left] \u003d\u003d ((l + r) / 2 - l + 1)) {\n\t\tl0[a] \u003d max(l0[a], max(l0[left], l0[left] + l0[right]));\n\t}\n\telse l0[a] \u003d max(l0[a], l0[left]);\n\tif (r0[right] \u003d\u003d (r - (l + r) / 2)) {\n\t\tr0[a] \u003d max(r0[a], r0[right] + r0[left]);\n\t}\n\telse r0[a] \u003d max(l0[a], r0[right]);\n\tans[a] \u003d max(r0[a], max(l0[a], r0[left] + l0[right]));\n}\nvoid update0(int i, int j,int a\u003d1, int l\u003d0, int r\u003dn-1) {\n\tlazyupdate(a, l, r);\n\tif (j\u0026lt;l || i\u0026gt;r)return;\n\t\n\tif (l \u0026gt;\u003d i\u0026amp;\u0026amp;r \u0026lt;\u003d j) {\n\t\tl0[a] \u003d r - l + 1;\n\t\tr0[a] \u003dans[a]\u003d r - l + 1;\n\t\tif (l \u003d\u003d r)return;\n\t\tlazy0[2 * a] \u003d 1; lazy0[2 * a + 1] \u003d 1;\n\t\tlazy1[2 * a] \u003d 0; lazy1[2 * a + 1] \u003d 0;\n\t\treturn;\n\t}\n\tint left \u003d 2 * a, right \u003d 2 * a + 1;\n\tupdate0(i, j, left, l, (l + r) / 2);\n\tupdate0(i, j, right, (l + r) / 2 + 1, r);\n\tupdateint(a, l, r);\n\n}\nvoid update1(int i, int j, int a \u003d 1, int l \u003d 0, int r \u003d n - 1) {\n\tlazyupdate(a, l, r);\n\tif (j\u0026lt;l || i\u0026gt;r)return;\n\n\tif (l \u0026gt;\u003d i\u0026amp;\u0026amp;r \u0026lt;\u003d j) {\n\t\tl0[a] \u003d 0;\n\t\tr0[a] \u003d 0;\n\t\tans[a] \u003d 0;\n\t\tif (l \u003d\u003d r)return;\n\t\tlazy1[2 * a] \u003d 1; lazy1[2 * a + 1] \u003d 1; \n\t\tlazy0[2 * a] \u003d 0; lazy0[2 * a + 1] \u003d 0;\n\t\treturn;\n\t}\n\tint left \u003d 2 * a, right \u003d 2 * a + 1;\n\tupdate1(i, j, left, l, (l + r) / 2);\n\tupdate1(i, j, right, (l + r) / 2 + 1, r);\n\tupdateint(a, l, r);\n}\npair\u0026lt;int,int\u0026gt; getint(int num, int a \u003d 1, int l \u003d 0, int r \u003d n - 1) {\n\tlazyupdate(a, l, r);\n\tif(l!\u003dr)lazyupdate(2 * a, l, (l + r) / 2);\n\tif(l!\u003dr)lazyupdate(2 * a + 1, (l + r) / 2 + 1, r);\n\tif (ans[a] \u003d\u003d num\u0026amp;\u0026amp;r-l+1\u003d\u003dnum) {\n\t\treturn pair\u0026lt;int, int\u0026gt;(l, r);\n\t}\n\tint left \u003d 2 * a, right \u003d 2 * a + 1;\n\tif (ans[left] \u0026gt;\u003d num) {\n\t\treturn getint(num, a * 2, l, (l + r) / 2);\n\t}\n\n\tif (r0[left] + l0[right] \u0026gt;\u003d num\u0026amp;\u0026amp;r0[left]!\u003d0) {\n\t\t\tint need \u003d num - r0[left];\n\t\t\tpair\u0026lt;int, int\u0026gt; p1;\n\t\t\tp1.first \u003d (l + r) / 2 - r0[left] + 1;\n\t\t\tp1.second \u003d (l + r) / 2 + need;\n\t\t\t\n\t\t\treturn p1;\n\t}\n\tif (ans[right]\u0026gt;\u003dnum) {\n\t\treturn getint(num, a * 2 + 1, (l + r) / 2 + 1, r);\n\t}\n\tassert(0);\n}\nint main() {\n\tifstream fin(\u0026quot;seating.in\u0026quot;);\n\tofstream fout(\u0026quot;seating.out\u0026quot;);\n\tfin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tl0, r0, lazy0, lazy1, ans;\n\tA.resize(n);\n\tl0.resize(4 * n); r0.resize(4 * n); lazy0.resize(4 * n); lazy1.resize(4 * n); ans.resize(4 * n);\n\tbuild(1, 0, n - 1);\n\tint res \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; m; i++) {\n\n\t\tstring stat;\n\t\tfin \u0026gt;\u0026gt; stat;\n\t\tif (stat[0] \u003d\u003d \u0027A\u0027) {\n\t\t\tint add; fin \u0026gt;\u0026gt; add;\n\t\t\tif (ans[1] \u0026lt; add) {\n\t\t\t\tres++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpair\u0026lt;int, int\u0026gt; p \u003d getint(add);\n\t\t\tupdate1(p.first, p.second);\n\t\t}\n\t\telse {\n\t\t\tint from, to; fin \u0026gt;\u0026gt; from \u0026gt;\u0026gt; to;\n\t\t\tfrom--; to--;\n\t\t\tupdate0(from, to);\n\t\t}\n\t}\n\tfout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn my segment tree, \u003ccode\u003eupdate0\u003c/code\u003e updates a given range of values to 0,\u003ccode\u003eupdate1\u003c/code\u003e updates a given range of values to 1, \u003ccode\u003eupdateint\u003c/code\u003e updates the interval whenever some of its values have changed.\u003ccode\u003egetInt(add)\u003c/code\u003e gets the lowest position to insert the group of people. \u003ccode\u003elazy0\u003c/code\u003e and\u003ccode\u003elazy1\u003c/code\u003e stores respectively the lazy propagation for setting to 0 and setting to 1. Thank you so much for your help.\u003c/p\u003e\u003c/div\u003e","tags":["c++","data structures","segment tree","lazy propagation"]}}