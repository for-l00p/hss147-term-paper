{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1408776429,"rating":-2,"authorHandle":"warlock","modificationTimeSeconds":1408776429,"id":13503,"title":"\u003cp\u003eSIGSEGV in Spoj GSS1\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi,\u003c/p\u003e\u003cp\u003eI have been trying to solve GSS1 on Spoj and its giving me segmentation fault. I am not able to figure out whats the problem. Below is my code, please see if you can figure out whats the problem.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://www.spoj.com/problems/GSS1/\"\u003ehttp://www.spoj.com/problems/GSS1/\u003c/a\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#define MAX 500005\nusing namespace std;\n\nstruct data {\n    long long sum, prefix_sum, suffix_sum, ans;\n    data(long long val) {\n        sum \u003d val;\n        prefix_sum \u003d suffix_sum \u003d ans \u003d max(0LL, val);\n    }\n    data(long long a, long long b, long long c, long long d) : sum(a), prefix_sum(b), suffix_sum(c), ans(d) {}\n    data(){}\n};\n\ndata tree[4 * MAX];\nlong long arr[MAX];\n\ndata combine(data l, data r)\n{\n    data res;\n    res.sum \u003d l.sum + r.sum;\n    res.prefix_sum \u003d max(l.prefix_sum, l.sum + r.prefix_sum);\n    res.suffix_sum \u003d max(r.suffix_sum, r.sum + l.suffix_sum);\n    res.ans \u003d max(max(l.ans, r.ans), l.suffix_sum + r.prefix_sum);\n\n    return res;\n}\n\nvoid build(long long node, long long tl, long long tr)\n{\n    if (tl \u0026gt; tr) return;\n\n    if (tl \u003d\u003d tr)\n        tree[node] \u003d data(arr[tl]);\n    else {\n        long long tm \u003d (tl + tr) / 2;\n        build(node * 2, tl, tm);\n        build((node * 2) + 1, tm + 1, tr);\n\n        tree[node] \u003d combine(tree[node * 2], tree[(node * 2) + 1]);\n    }\n}\n\ndata query(long long node, long long tl, long long tr, long long l, long long r)\n{\n    if (tl \u0026gt; tr || r \u0026lt; tl || l \u0026gt; tr) return data(0, -1e9, -1e9, -1e9);\n\n    if (tl \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026gt;\u003d tr)\n        return tree[node];\n\n    long long tm \u003d (tl + tr) / 2;\n    data n1 \u003d query(node * 2, tl, tm, l, r);\n    data n2 \u003d query((node * 2) + 1, tm + 1, tr, l, r);\n\n    return combine(n1, n2);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    long long n;\n    cin \u0026gt;\u0026gt; n;\n    for (long long i \u003d 0; i \u0026lt; n; i++)\n        cin \u0026gt;\u0026gt; arr[i];\n\n    build(1, 0, n - 1);\n    long long m;\n    cin \u0026gt;\u0026gt; m;\n    while (m--) {\n        long long x, y;\n        cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n        cout \u0026lt;\u0026lt; query(1, 0, n - 1, x - 1, y - 1).ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n    }\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["sigsegv","gss1","spoj"]}}