{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1494763597,"rating":26,"authorHandle":"RussianCodeCup","modificationTimeSeconds":1494763637,"id":51984,"title":"\u003cp\u003eRussian Code Cup 2017 Elimination Round — Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eA. Small Numbers\u003c/h2\u003e\u003cp\u003eFirst of all, find prime factorization of numbers \u003ci\u003ea\u003c/i\u003e and \u003ci\u003eb\u003c/i\u003e.\u003c/p\u003e\u003cp\u003eAfter that you need to notice that if \u003ci\u003eab\u003c/i\u003e is divisible by \u003ci\u003ep\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e, (where \u003ci\u003ep\u003c/i\u003e is a prime number), it is either possible to divide both \u003ci\u003ea\u003c/i\u003e and \u003ci\u003eb\u003c/i\u003e by \u003ci\u003ep\u003c/i\u003e instantly, or you will need to perform one of the latter two operations first to move one of \u003ci\u003ep\u003c/i\u003e factors to the other number, and then divide both by \u003ci\u003ep\u003c/i\u003e.\u003c/p\u003e\u003cp\u003eObviously, parity of occurrence of prime numbers in the multiple \u003ci\u003eab\u003c/i\u003e remains unchanged in all operations. Therefore we can either remove \u003ci\u003ep\u003c/i\u003e factor completely from \u003ci\u003eab\u003c/i\u003e or leave it occurring only once. After removing all primes, lets say the ones left are \u003ci\u003ep\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e. Let us call multiple of all these numbers \u003ci\u003ed\u003c/i\u003e. Important observation is that \u003ci\u003en\u003c/i\u003e can\u0027t exceed 14 because multiple of first 15 prime numbers is more than 10\u003csup\u003e18\u003c/sup\u003e, which means it can\u0027t be a product of two numbers \u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e ≤ 10\u003csup\u003e9\u003c/sup\u003e. Now we simply need to iterate over all possible pairs and chose one with minimum sum that we can obtain from \u003ci\u003ed\u003c/i\u003e. This can be done in \u003ci\u003eO\u003c/i\u003e(2\u003csup\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e) which fits the time limit.\u003c/p\u003e\u003ch2\u003eB. New Keyboard\u003c/h2\u003e \u003cp\u003eLet us use dynamic programming. The state is d[i][j][k], where \u003ci\u003ei\u003c/i\u003e — is the flag that denotes the previous action (0 for layout switch, and 1 for typing character), \u003ci\u003ej\u003c/i\u003e is the number of the current layout, and \u003ci\u003ek\u003c/i\u003e is the number of characters typed so far. The value is the minimal time to reach the state.\u003c/p\u003e\u003cp\u003eNow iterate over \u003ci\u003ek\u003c/i\u003e. For a given \u003ci\u003ek\u003c/i\u003e first iterate \u003ci\u003ej\u003c/i\u003e from 1 to \u003ci\u003en\u003c/i\u003e twice. Both times relax d[0][j % n + 1][k] \u003d min(d[0][j % n + 1][k], min(d[0][j][k] + b, d[1][j][k] + a)). Two iterations of \u003ci\u003ej\u003c/i\u003e from 1 to \u003ci\u003en\u003c/i\u003e are needed to ensure that if the layout switches from \u003ci\u003en\u003c/i\u003e to 1 it is processed correctly.\u003c/p\u003e\u003cp\u003eNow iterate \u003ci\u003ej\u003c/i\u003e from 1 to \u003ci\u003en\u003c/i\u003e again and relax values for \u003ci\u003ek\u003c/i\u003e + 1. If there is the \u003ci\u003ek\u003c/i\u003e-th character of the message in the \u003ci\u003ej\u003c/i\u003e-th layout, update d[1][j][k + 1] \u003d min(d[0][j][k], d[1][j][k]) + c.\u003c/p\u003e\u003cp\u003eThe answer is min(d[1][j][m]), where \u003ci\u003em\u003c/i\u003e \u003d \u003ci\u003elength\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e), for all \u003ci\u003ej\u003c/i\u003e from 1 to \u003ci\u003en\u003c/i\u003e.\u003c/p\u003e\u003ch2\u003eC. Folding the Figure\u003c/h2\u003e \u003cp\u003eNote that there are exactly 4 possible folding lines: two horizontal and two vertical, because the figure must be at one side of the folding line, and must touch it.\u003c/p\u003e\u003cp\u003eTake any square of the folded figure with the minimal \u003ci\u003ex\u003c/i\u003e-coordinate. Let it be the cell (\u003ci\u003ex\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e). Take line \u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e as the folding line. Now we need to find \u003ci\u003ek\u003c/i\u003e - \u003ci\u003en\u003c/i\u003e squares of the original figure on the other side of the folding line. So let us find \u003ci\u003ek\u003c/i\u003e - \u003ci\u003en\u003c/i\u003e connected squares of the folded figure containing the square (\u003ci\u003ex\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e), for example, using DFS.\u003c/p\u003e\u003ch2\u003eD. Acute Triangles\u003c/h2\u003e \u003cp\u003eTo count the number of acute triangles let us count the total number of triangles and subtract the number of right and obtuse triangles. For the purpose of this problem let us consider three points on a line to be a degenerate obtuse triangle.\u003c/p\u003e\u003cp\u003eThe total number of triangles is equal to the number of ways to choose 3 points of \u003ci\u003en\u003c/i\u003e.\u003c/p\u003e\u003cp\u003eNow note the fact: each right or obtuse triangle has exactly one right or obtuse angle. So the number of bad triangles is equal to the number of bad angles.\u003c/p\u003e\u003cp\u003eNow let us count the number of angles not less than 90 degrees with vertices in the given points. Consider the angle vertex and sort other points by their polar angle relative to the chosen point. Now use two pointers: consider the first of the other two points, the matching third points form a continuous segment along the circle, and its ends move in the same direction.\u003c/p\u003e\u003cp\u003eTime complexity is \u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)).\u003c/p\u003e\u003ch2\u003eE. Joining Arrays\u003c/h2\u003e \u003cp\u003eLet us consider two solutions for the problem, that take \u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e·\u003ci\u003elog\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e)) and \u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e) respectively. The first one brings up core ideas, while the second one being more elusive has simpler implementation.\u003c/p\u003e\u003cp\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e·\u003ci\u003elog\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e)) solution:\u003c/p\u003e\u003cp\u003eConsider three main steps of the solution \u003c/p\u003e\u003col\u003e \u003cli\u003e For each array \u003ci\u003eX\u003c/i\u003e (\u003ci\u003eA\u003c/i\u003e or \u003ci\u003eB\u003c/i\u003e) and each length 1 ≤ \u003ci\u003elength\u003c/i\u003e ≤ |\u003ci\u003eX\u003c/i\u003e| find \u003ci\u003eminSubsequence\u003c/i\u003e\u003csub\u003e\u003ci\u003eX\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003elength\u003c/i\u003e] — lexicographically smallest subsequence of \u003ci\u003eX\u003c/i\u003e that has the given length; \u003c/li\u003e\u003cli\u003e Iterate over \u003ci\u003et\u003c/i\u003e such that 1 ≤ \u003ci\u003et\u003c/i\u003e ≤ \u003ci\u003emin\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e - 1, |\u003ci\u003eA\u003c/i\u003e|) and 1 ≤ \u003ci\u003ek\u003c/i\u003e - \u003ci\u003et\u003c/i\u003e ≤ |\u003ci\u003eB\u003c/i\u003e|, take \u003ci\u003eminSubsequence\u003c/i\u003e\u003csub\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003et\u003c/i\u003e] and \u003ci\u003eminSubsequence\u003c/i\u003e\u003csub\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ek\u003c/i\u003e - \u003ci\u003et\u003c/i\u003e], join them; \u003c/li\u003e\u003cli\u003e Joining the given sequences, get the optimal sequence of length \u003ci\u003ek\u003c/i\u003e, update the answer with that sequence. \u003c/li\u003e\u003c/ol\u003e\u003cp\u003e1) To find \u003ci\u003eminSubsequence\u003c/i\u003e\u003csub\u003e\u003ci\u003eX\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003elength\u003c/i\u003e] for each \u003ci\u003elength\u003c/i\u003e, let us do the following: \u003c/p\u003e\u003cul\u003e \u003cli\u003e Calculate \u003ci\u003enext\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ec\u003c/i\u003e] that will store the next occurence of value \u003ci\u003ec\u003c/i\u003e after \u003ci\u003ei\u003c/i\u003e in \u003ci\u003eX\u003c/i\u003e; \u003c/li\u003e\u003cli\u003e Calculate \u003ci\u003efirstSymbol\u003c/i\u003e[\u003ci\u003elength\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e] — the first character of lexicographically smallest subsequence of \u003ci\u003eX\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e..|\u003ci\u003eX\u003c/i\u003e| - 1] that has given \u003ci\u003elength\u003c/i\u003e. To calculate it note the following: \u003cul\u003e \u003cli\u003e If \u003ci\u003ej\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e \u003d \u003ci\u003enext\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][1], and it exists, then \u003ci\u003efirstSymbol\u003c/i\u003e[1][\u003ci\u003ei\u003c/i\u003e], \u003ci\u003efirstSymbol\u003c/i\u003e[2][\u003ci\u003ei\u003c/i\u003e], ... \u003ci\u003efirstSymbol\u003c/i\u003e[|\u003ci\u003eX\u003c/i\u003e| - \u003ci\u003ej\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e][\u003ci\u003ei\u003c/i\u003e] are equal to 1; \u003c/li\u003e\u003cli\u003e If, if \u003ci\u003ej\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e \u003d \u003ci\u003enext\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][2], and it exists, then \u003ci\u003efirstSymbol\u003c/i\u003e[|\u003ci\u003eX\u003c/i\u003e| - \u003ci\u003ej\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e + 1][\u003ci\u003ei\u003c/i\u003e], ..., \u003ci\u003efirstSymbol\u003c/i\u003e[|\u003ci\u003eX\u003c/i\u003e| - \u003ci\u003ej\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e][\u003ci\u003ei\u003c/i\u003e] are equal to 2; \u003c/li\u003e\u003cli\u003e ... \u003c/li\u003e\u003cli\u003e If \u003ci\u003ej\u003c/i\u003e\u003csub\u003e3000\u003c/sub\u003e \u003d \u003ci\u003enext\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][3000], and it exists, then \u003ci\u003efirstSymbol\u003c/i\u003e[\u003ci\u003emax\u003c/i\u003e(|\u003ci\u003eX\u003c/i\u003e| - \u003ci\u003ej\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e, |\u003ci\u003eX\u003c/i\u003e| - \u003ci\u003ej\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e, ..., |\u003ci\u003eX\u003c/i\u003e| - \u003ci\u003ej\u003c/i\u003e\u003csub\u003e3000 - 1\u003c/sub\u003e) + 1][\u003ci\u003ei\u003c/i\u003e], ..., \u003ci\u003efirstSymbol\u003c/i\u003e[|\u003ci\u003eX\u003c/i\u003e| - \u003ci\u003ej\u003c/i\u003e\u003csub\u003e|\u003ci\u003ealphabet\u003c/i\u003e|\u003c/sub\u003e][\u003ci\u003ei\u003c/i\u003e] are equal to 3000. \u003c/li\u003e\u003c/ul\u003e \u003c/li\u003e\u003cli\u003e After that we can use \u003ci\u003efirstSymbol\u003c/i\u003e[\u003ci\u003elength\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e] to restore lexicographically smallest subsequence of each array, one by one. \u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThis step takes \u003ci\u003eO\u003c/i\u003e(|\u003ci\u003eX\u003c/i\u003e|\u003csup\u003e2\u003c/sup\u003e).\u003c/p\u003e\u003cp\u003e3) Given two lexicographically minimal subsequences \u003ci\u003eS\u003c/i\u003e\u003csub\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e and \u003ci\u003eS\u003c/i\u003e\u003csub\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e, now we need to join them to lexicographically smallest sequence. Let us use two pointers \u003ci\u003ep\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e and \u003ci\u003ep\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e. If \u003ci\u003eS\u003c/i\u003e\u003csub\u003e\u003ci\u003eA\u003c/i\u003e\u003csub\u003e\u003ci\u003ep\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e\u003c/sub\u003e\u003c/sub\u003e ≠ \u003ci\u003eS\u003c/i\u003e\u003csub\u003e\u003ci\u003eB\u003c/i\u003e\u003csub\u003e\u003ci\u003ep\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e\u003c/sub\u003e\u003c/sub\u003e, we move the smaller pointer, appending the value it points at to the answer. If \u003ci\u003eS\u003c/i\u003e\u003csub\u003e\u003ci\u003eA\u003c/i\u003e\u003csub\u003e\u003ci\u003ep\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e\u003c/sub\u003e\u003c/sub\u003e \u003d \u003ci\u003eS\u003c/i\u003e\u003csub\u003e\u003ci\u003eB\u003c/i\u003e\u003csub\u003e\u003ci\u003ep\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e\u003c/sub\u003e\u003c/sub\u003e, use binary search to find the longest common prefix of \u003ci\u003eS\u003c/i\u003e\u003csub\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e..|\u003ci\u003eS\u003c/i\u003e\u003csub\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e|] and \u003ci\u003eS\u003c/i\u003e\u003csub\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e..|\u003ci\u003eS\u003c/i\u003e\u003csub\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e|], and compare the following elements. Use hashes to compare subarrays of \u003ci\u003eS\u003c/i\u003e\u003csub\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e and \u003ci\u003eS\u003c/i\u003e\u003csub\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e.\u003c/p\u003e\u003cp\u003eThis step takes \u003ci\u003eO\u003c/i\u003e((|\u003ci\u003eS\u003c/i\u003e\u003csub\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e| + |\u003ci\u003eS\u003c/i\u003e\u003csub\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e|)·\u003ci\u003elog\u003c/i\u003e(\u003ci\u003emax\u003c/i\u003e(|\u003ci\u003eS\u003c/i\u003e\u003csub\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e|, |\u003ci\u003eS\u003c/i\u003e\u003csub\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e|))) \u003d \u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e·\u003ci\u003elog\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e)).\u003c/p\u003e\u003cp\u003eSo the total time complexity is \u003ci\u003eO\u003c/i\u003e(|\u003ci\u003eA\u003c/i\u003e|\u003csup\u003e2\u003c/sup\u003e + |\u003ci\u003eB\u003c/i\u003e|\u003csup\u003e2\u003c/sup\u003e + \u003ci\u003ek\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e·\u003ci\u003elog\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e)) \u003d \u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e·\u003ci\u003elog\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e)).\u003c/p\u003e\u003cp\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e) solution:\u003c/p\u003e\u003cp\u003eLet us index arrays, let array \u003ci\u003eA\u003c/i\u003e have number 0, and array \u003ci\u003eB\u003c/i\u003e have number 1. Let us build the answer one element after another, and maintain the values \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e], where \u003ci\u003ei\u003c/i\u003e is the number of the array (0 or 1), \u003ci\u003ej\u003c/i\u003e is the index in this array, \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e] is the minimal index in array 1 - \u003ci\u003ei\u003c/i\u003e, that can be appended to the answer, if we are at index \u003ci\u003ej\u003c/i\u003e in array \u003ci\u003ei\u003c/i\u003e.\u003c/p\u003e\u003cp\u003eAt the \u003ci\u003et\u003c/i\u003e-th of the \u003ci\u003ek\u003c/i\u003e iterations we find the minimum element that can be appended to the answer, and still the answer can be completed by adding another \u003ci\u003ek\u003c/i\u003e - \u003ci\u003et\u003c/i\u003e - 1 elements. Also we must note that both subsequences from the two arrays must be non-empty.\u003c/p\u003e\u003cp\u003eAfter adding the element \u003ci\u003ev\u003c/i\u003e, update the \u003ci\u003edp\u003c/i\u003e values in \u003ci\u003eO\u003c/i\u003e(|\u003ci\u003eA\u003c/i\u003e| + |\u003ci\u003eB\u003c/i\u003e|). To do it, use \u003ci\u003enext\u003c/i\u003e array, the same as in previous solution.\u003c/p\u003e\u003ch2\u003eF. Two Trees\u003c/h2\u003e \u003cp\u003eThere is a requirement that \u003ci\u003ek\u003c/i\u003e-subtree must have a vertex at depth \u003ci\u003ek\u003c/i\u003e. Let us temporarily remove this limitation.\u003c/p\u003e\u003cp\u003eConsider all \u003ci\u003ek\u003c/i\u003e-subtrees for some value of \u003ci\u003ek\u003c/i\u003e. They can be divided to equivalence classes. Let each vertex \u003ci\u003ev\u003c/i\u003e have \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ev\u003c/i\u003e] — the label of its equivalence class that its \u003ci\u003ek\u003c/i\u003e-subtree belongs to.\u003c/p\u003e\u003cp\u003eIf \u003ci\u003ek\u003c/i\u003e \u003d 0 all \u003ci\u003ec\u003c/i\u003e\u003csub\u003e0\u003c/sub\u003e[\u003ci\u003ev\u003c/i\u003e] are the same, because 0-subtree of any vertex is this vertex by itself.\u003c/p\u003e\u003cp\u003eIf \u003ci\u003ek\u003c/i\u003e \u003d 1 then \u003ci\u003ec\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e[\u003ci\u003ev\u003c/i\u003e] is the number of children of \u003ci\u003ev\u003c/i\u003e .\u003c/p\u003e\u003cp\u003eNow let us see how we can convert arrays \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ev\u003c/i\u003e] and \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ev\u003c/i\u003e] to an array \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ek\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ev\u003c/i\u003e]. First let us assign the array \u003ci\u003earr\u003c/i\u003e\u003csub\u003e\u003ci\u003ek\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ev\u003c/i\u003e] to each vertex \u003ci\u003ev\u003c/i\u003e, that will uniquely identify its \u003ci\u003ek\u003c/i\u003e-subtree. Let \u003ci\u003eu\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e, ..., \u003ci\u003eu\u003c/i\u003e\u003csub\u003e\u003ci\u003es\u003c/i\u003e\u003c/sub\u003e be its descendants of level \u003ci\u003ek\u003c/i\u003e in DFS order. Then \u003ci\u003earr\u003c/i\u003e\u003csub\u003e\u003ci\u003ek\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ev\u003c/i\u003e] \u003d \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ev\u003c/i\u003e], \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003eu\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e], ..., \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003eu\u003c/i\u003e\u003csub\u003e\u003ci\u003es\u003c/i\u003e\u003c/sub\u003e]. So its (\u003ci\u003ek\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)-subtree is identified by its \u003ci\u003ek\u003c/i\u003e-subtree and \u003ci\u003em\u003c/i\u003e-subtrees from the bottom vertices of its \u003ci\u003ek\u003c/i\u003e-subtree. See the picture below for \u003ci\u003ek\u003c/i\u003e \u003d 3 and \u003ci\u003em\u003c/i\u003e \u003d 1.\u003c/p\u003e\u003ccenter\u003e \u003cimg src\u003d\"/predownloaded/12/68/1268acedf0137ac112235fc245251040c6d2a74a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003c/center\u003e\u003cp\u003eTo get the list of descendants at level \u003ci\u003ek\u003c/i\u003e, let us run one DFS from the root, when entering the vertex, put it to its \u003ci\u003ek\u003c/i\u003e levels ancestor list.\u003c/p\u003e\u003cp\u003eTo transform \u003ci\u003earr\u003c/i\u003e\u003csub\u003e\u003ci\u003ek\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ev\u003c/i\u003e] to integers \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ek\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ev\u003c/i\u003e] we can either use hashing, or trie, or unordered_map. Each vertex is considered only once in each of these arrays, so the total time is \u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e).\u003c/p\u003e\u003cp\u003eGiven array \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e[\u003ci\u003ev\u003c/i\u003e] it is easy to check whether there are two equal \u003ci\u003ek\u003c/i\u003e-subtrees. To do it you must find two vertices with the same \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e, considering only vertices that have descendants of level \u003ci\u003ek\u003c/i\u003e (now we need to bring back this requirement). \u003c/p\u003e\u003cp\u003eTo find the maximal such \u003ci\u003ek\u003c/i\u003e, let us first count \u003ci\u003ec\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e[\u003ci\u003ev\u003c/i\u003e], \u003ci\u003ec\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e[\u003ci\u003ev\u003c/i\u003e], ..., \u003ci\u003ec\u003c/i\u003e\u003csub\u003e2\u003csup\u003e\u003ci\u003et\u003c/i\u003e\u003c/sup\u003e\u003c/sub\u003e[\u003ci\u003ev\u003c/i\u003e] (2\u003csup\u003e\u003ci\u003et\u003c/i\u003e\u003c/sup\u003e is the maximal power of 2 not exceeding \u003ci\u003en\u003c/i\u003e). After that make some kind of binary ascending by \u003ci\u003ek\u003c/i\u003e: start with \u003ci\u003ek\u003c/i\u003e \u003d 0, and try to add 2\u003csup\u003e\u003ci\u003et\u003c/i\u003e\u003c/sup\u003e, 2\u003csup\u003e\u003ci\u003et\u003c/i\u003e - 1\u003c/sup\u003e, ..., 2\u003csup\u003e0\u003c/sup\u003e, one by one.\u003c/p\u003e\u003cp\u003eTime complexity: \u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)).\u003c/p\u003e\u003c/div\u003e","tags":[]}}