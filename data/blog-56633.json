{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1514295420,"rating":0,"authorHandle":"madhur4127","modificationTimeSeconds":1514302241,"id":56633,"title":"\u003cp\u003eSIGSEGV on Segment Tree for large sized array\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eAfter reading some tutorials on segment tree:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/blog/entry/18051\"\u003eEfficient and easy segment trees\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ca href\u003d\"http://e-maxx.ru/algo/segment_tree\"\u003eSegment Tree by e-maxx\u003c/a\u003e \u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eI thought to implement this data structure in Object Oriented methodology whereby I used vector instead of arrays in (contrast with tutorials) approach to hide implementation details, but it verdicts SIGSEGV for size in order of 10^5. But works fine (I hope) for array size less than of 10^4 order;\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etypedef struct SegmentTree{\n   vector\u0026lt;int\u0026gt; tree, udp; int orgsize;\n  /******************BUILD***********************/\n  SegmentTree(vector\u0026lt;int\u0026gt;\u0026amp; list){ //CONSTRUCTOR\n    orgsize\u003dlist.size();\n    int size\u003d((int)(pow(2,31-__builtin_clz(orgsize))))\u0026lt;\u0026lt;1;\n    tree.resize(size); udp.assign(size,0); build(1,0,orgsize-1,list);\n  }\n  void build(int cur, int s, int e, vector\u0026lt;int\u0026gt;\u0026amp; list){\n    if(s\u003d\u003de){ tree[cur]\u003dlist[s]; return ;}\n    else{\n      int mid\u003d(s+e)/2;\n      build(cur\u0026lt;\u0026lt;1,s,mid,list); build((cur\u0026lt;\u0026lt;1)+1,mid+1,e,list);\n      tree[cur]\u003d tree[cur\u0026lt;\u0026lt;1]+tree[(cur\u0026lt;\u0026lt;1)+1];     //NODE FUNCTION\n    }\n  }\n  /***************  UPDATE  **************************/\n  void update(int s, int e, int val){ update(1,0,orgsize-1,s,e,val);}\n  void update(int cur, int ts, int te, int s, int e, int val){ //ts: temporary start, cur: current\n    if(ts\u0026gt;\u003ds \u0026amp;\u0026amp; te\u0026lt;\u003de) udp[cur]+\u003dval;\n    else{\n      tree[cur]+\u003d(min(te,e)-max(ts,s)+1)*val;      //NODE FUNCTION\n      int mid\u003d(ts+te)/2;\n      if(mid\u0026gt;\u003ds \u0026amp;\u0026amp; ts\u0026lt;\u003de) update(cur\u0026lt;\u0026lt;1,ts,mid,s,e,val);\n      if(mid+1\u0026lt;\u003de \u0026amp;\u0026amp; te\u0026gt;\u003ds) update((cur\u0026lt;\u0026lt;1)+1,mid+1,te,s,e,val);\n    }\n  }\n  /***************  QUERY ***************************/\n  ll query(int s, int e){return q(1,0,orgsize-1,s,e);}\n  ll q(int cur, int ts,int te, int s, int e){    //ts: temporary start, cur: current\n    if(ts\u0026gt;\u003ds \u0026amp;\u0026amp; te\u0026lt;\u003de){\n      if(udp[cur]!\u003d0){\n        tree[cur]+\u003d(te-ts+1)*udp[cur];            //NODE FUNCTION\n        if(2*cur \u0026lt; udp.size()){\n          udp[cur\u0026lt;\u0026lt;1]+\u003dudp[cur];\n          udp[(cur\u0026lt;\u0026lt;1)+1]+\u003dudp[cur];\n        }\n        udp[cur]\u003d0;\n      }\n      return tree[cur];\n    }\n    else{\n      tree[cur]+\u003d(te-ts+1)*udp[cur];\n      if((cur\u0026lt;\u0026lt;1) \u0026lt; udp.size()){\n        udp[cur\u0026lt;\u0026lt;1]+\u003dudp[cur];\n        udp[(cur\u0026lt;\u0026lt;1)+1]+\u003dudp[cur];\n      }\n      udp[cur]\u003d0;\n      ll temp\u003d0; int mid\u003d(ts+te)/2;\n      if(mid\u0026gt;\u003ds \u0026amp;\u0026amp; ts\u0026lt;\u003de) temp+\u003dq(cur\u0026lt;\u0026lt;1,ts,mid,s,e);\n      if(mid+1\u0026lt;\u003de \u0026amp;\u0026amp; te\u0026gt;\u003ds) temp+\u003dq((cur\u0026lt;\u0026lt;1)+1,mid+1,te,s,e);\n      return temp;\n    }\n  }\n} ST;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI tried this program for \u003ca href\u003d\"http://www.spoj.com/problems/HORRIBLE/\"\u003eSPOJ-Horrible\u003c/a\u003e and get \u0026quot;Runtime error â€” SIGSEGV\u0026quot; which then I presume to arise from implementation as when I tried running on 10^5 it shows that error again.\u003c/p\u003e\u003cp\u003eMy submission for above mention problem: \u003ca href\u003d\"https://ideone.com/1bfAaO\"\u003eIdeone\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI tried using global vector of the object udp \u0026amp; tree and also the vector which I used to build this segment tree. But it didn\u0027t work. Is there a fix or shall I not use this OOP based implementation? Because \u003c/p\u003e\u003cp\u003eThank you for having time to read this.! \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD\u003c/strong\u003e: Its solved! For those who are wondering the source of bug, it was in the calculation of size in constructor changing to \u003ccode\u003e2 \u0026lt;\u0026lt; (32 - __builtin_clz(orgsize - 1))\u003c/code\u003e led to Accepted verdict.\u003c/p\u003e\u003c/div\u003e","tags":["segment tree","sigsegv","lazy propagation","lazy updates","help needed","c++ 14"]}}