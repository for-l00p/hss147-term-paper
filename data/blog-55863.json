{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1511024723,"rating":10,"authorHandle":"dalex","modificationTimeSeconds":1511027197,"id":55863,"title":"\u003cp\u003eО подготовке контестов\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eЯ готовлю контесты уже 7 лет, и у меня много опыта, о котором наконец-то надо написать. Большинство из того, что тут написано, и так многим известно, однако многие авторы чем-то пренебрегают и их контест оказывается, так скажем, плохим.\u003c/p\u003e\u003ch4\u003eПридумывание задач\u003c/h4\u003e\u003cp\u003eБез задач контест не состоится, а значит, их придется придумывать. Есть несколько основных способов:\u003c/p\u003e \u003col\u003e   \u003cli\u003eПожалуй, самый лучший способ — взять задачу из реальной жизни или придумать задачу, которая описывает гипотетически возможную ситуацию. Такие задачи самые интересные, потому что они не высосаны из пальца. Например, про сотрудников, которые состоят в отношениях \u0026quot;начальник — подчиненный\u0026quot;, про мероприятия, на которые надо успеть, про деньги, которыми надо распорядиться самым выгодным способом, про персонажей компьютерных игр, которые наносят и получают урон и тратят ману.\u003c/li\u003e   \u003cli\u003eВзять какой то абстрактный объект, типичный для задач по программированию (массив, дерево, клетчатый лабиринт) и попробовать поиграться с ним. Способов поиграться можно придумать много, например: придумать операцию и попросить что-то сделать за минимальное количество операций, или назначить стоимости и попросить за поменьше денег что-то сделать, или поставить дедлайны и попросить успеть как можно больше чего-то сделать до дедлайнов. В какой-то момент придуманная задача окажется решаемой. Такие задачи тоже приятно решать — они хоть и придуманы, но как правило, условие у них легко парсится и понимается.\u003c/li\u003e   \u003cli\u003eВзять уже имеющуюся задачу и поднять / изменить в ней ограничения, так чтобы она перестала решаться старым способом. Трудноосуществимо.\u003c/li\u003e   \u003cli\u003eВзять стандартный объект из задач по программированию, назначить над ним операцию и попросить ответить на запросы. Обычно этим способом получаются скучные и унылые задачи, но не всегда.\u003c/li\u003e   \u003cli\u003eМатематика (теория чисел, линейная алгебра, геометрия). Только не переусердствуйте.\u003c/li\u003e \u003c/ol\u003e\u003ch4\u003eСоставление контеста\u003c/h4\u003e\u003cp\u003eКак только придумано достаточное количество задач (желательно где-то 2 * количество задач в контесте, или даже больше), надо отобрать задачи для контеста. Следует учитывать уровень участников и не перегробить / перехалявить. Каждую социальную группу (а как это еще назвать?) надо обеспечить задачами до конца контеста, чтобы они не сидели 3 последних часа без дела. Это относится и к лидерам — в идеале лидер должен уходить без одной, которую пытался, но не смог. Каждую социальную группу участников надо разделять некоторыми задачами (чтобы не было 10 халяв и 2 гроба, и все решили 10). И для каждой социальной группы должны быть 2-3 задачи, на которых они будут бодаться между собой.\u003c/p\u003e\u003cp\u003eНадо стараться балансировать контест по тематике, набирая задач на самые разнообразные темы. Если в контесте много новичков, не берите слишком много задач на стандартные приемы — новички им еще не обучены и будут сидеть без AC половину контеста. Чем больше задач из первой половины по сложности решаются без стандартных приемов — только с помощью каких-то рассуждений — тем лучше.\u003c/p\u003e\u003ch4\u003eНаписание условий\u003c/h4\u003e\u003cp\u003eНе пытайтесь написать сквозные условия для всего контеста. Обычно получается фигня (я пробовал, и получилась фигня — с тех пор не пробую). 4-5 задач удастся хорошо вписать в сеттинг, а по остальным будет видно, что условие подгоняли после придумывания задачи. Лучше сохранять оригинальные условия, какими они были на момент придумывания. Конечно, можно добавить немного сказок, но не сильно — 4-5 строчек вполне хватит. Условие на всю страницу — это плохо.\u003c/p\u003e\u003ch4\u003eНаписание валидаторов и чекеров\u003c/h4\u003e\u003cp\u003eОбязательно напишите валидаторы и чекеры, а также тесты к ним в самом начале подготовки задачи. Это не очень сложная работа, но ее все равно придется сделать, а если сделать ее раньше, можно избежать дальнейшей возни с некорректными тестами или несколькими правильными ответами.\u003c/p\u003e\u003cp\u003eПишите валидаторы и чекеры максимально надежно. Используйте STL, не используйте массивы, не используйте глобальные переменные. Ставьте разнообразные assert-ы. Компилируйте их локально (для этого надо всего-то скачать testlib.h и (если вы под виндой) поставить MinGW), компилируйте с очень жесткими опциями ворнингов, так чтобы их не было ни одного.\u003c/p\u003e\u003ch4\u003eАвторские решения и другие решения\u003c/h4\u003e\u003cp\u003eАвторское решение пишите на Java (можно также на Kotlin или C#). Во-первых, это нужно, чтобы гаранировать, что у джавакодеров на контесте не будет джавапроблем (т.е. когда решение на C++ заходит, а такое же на Java — нет, особенно это характерно для польских контестов). Во-вторых, Java и C# — более строгие языки, в них меньше вероятность выстрелить себе в ногу, а в авторских решениях этого точно делать не стоит.\u003c/p\u003e\u003cp\u003eTL-ные решения пишутся для двух целей. Во-первых, проверить, что решение за квадрат действительно не заходит при n \u003d 100000. Такие решения, которые проверяют качество TL-тестов, пишите на C++. Просто потому что это самый быстрый язык, и если на нем не пройдет, то ни на чем не пройдет. Другая цель написания TL-ных решений — стресс тесты. Такие решения должны быть максимально тупыми, в которых точно негде ошибиться.\u003c/p\u003e\u003cp\u003eОбязательно пишите неверные решения. На каждую задачу неверных решений можно придумать очень и очень много — это может быть и неверная эвристика или жадность, может быть просто опечатка / забыл посортить / что-нибудь в этом роде. Надо это все написать и убедиться, что все такие решения действительно получают WA.\u003c/p\u003e\u003ch4\u003eТесты\u003c/h4\u003e\u003cp\u003eЭто самая сложная часть подготовки, на нее уходит процентов 80 времени. Если у вас это не так — вы делаете плохие тесты.\u003c/p\u003e\u003cp\u003eКакие надо делать тесты?\u003c/p\u003e \u003col\u003e   \u003cli\u003eВ самом начале добавьте штук 10-15 ручных тестов, для которых вы можете руками посчитать ответ и проверить его глазами. Обязательно добавьте минимальные тесты (массив из 1, 2 элементов, дерево из 1, 2, 3, а то и 4 вершин, сетка 1х1, 1х2, 2х2, 1х3).\u003c/li\u003e   \u003cli\u003eДалее поместите несколько полностью рандомных тестов, максимальных по размеру. Чисто чтобы проверить TL / ML. Это нужно делать сразу же после ручных тестов, чтобы программы, не проходящие по времени или памяти, сразу отсекались и не тратили время тестирующей системы. Хорошо, если такие тесты имеют индексы примерно 15 — 20 (а до них должны быть маленькие ручные!)\u003c/li\u003e   \u003cli\u003eДалее подготовьте штук 10-20 максимальных тестов, сгенерированных специальным генератором. Здесь должны быть учтены все краевые случаи. Например, если в вашей задаче массив, то надо добавить тест со всеми единицами / всеми 10^9 / посорченный массив. Если дерево, то надо добавить солнышко (ребра 1 — i for all i), палку (ребра i — (i+1) for all i), а также их комбинации (например, половина дерева палка, а вторая половина солнышко). Если не написать подобные тесты, то очень вероятно, что пройдет какое-то неправильное (TL-ное) решение, т.к. чисто рандомные тесты могут покрывать только какой-то очень среднестатистический случай и не выходить из него.\u003c/li\u003e   \u003cli\u003eРандомные тесты тоже нужны. Добавьте несколько.\u003c/li\u003e   \u003cli\u003eВозможно, есть какие-то эвристики, против которых генерить тест надо специально. Сделайте это.\u003c/li\u003e   \u003cli\u003eВозможно, вы придумаете какой-то красивый вид тестов, который ни за что в жизни не сгенерится рандомом, однако он может что-то поломать в неверных решениях. Сделайте это, даже если вы сейчас не понимаете, какое именно решение может на таком тесте поломаться. Это за вас придумают участники, и вы должны быть во всеоружии заранее.\u003c/li\u003e   \u003cli\u003eПострессьте все ваши неверные решения и добавьте тест против каждого из них.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eИ немного внимания семплам. Вам решать, должны быть семплы показательные или нет — зависит от задачи. Лучше делать показательные, но так, чтоб они не палили идею решения. Также, если в тестах бывает YES / NO, No solution, -1, переполнение инта — все это в полной мере надо отразить в семплах.\u003c/p\u003e\u003c/div\u003e","tags":["подготовка контестов"]}}