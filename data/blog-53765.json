{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1502287264,"rating":5,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1502287264,"id":53765,"title":"\u003cp\u003eNotes on Codeforces Beta Round #67, A, B, C, D\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/75/problem/A\" title\u003d\"Codeforces Beta Round 67 (Div. 2)\"\u003e75A - Life Without Zeros\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is a \u0026quot;straightforward-implementation\u0026quot; problem. Eliminate all the zeros in each integer and check whether the sum equation still holds or not.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/75/problem/B\" title\u003d\"Codeforces Beta Round 67 (Div. 2)\"\u003e75B - Facetook Priority Wall\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe main issue involved in this problem is how to correctly sort out the names and actions. After this, we only need to record the scores that every user can obtain, and output them in the required order.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/75/problem/C\" title\u003d\"Codeforces Beta Round 67 (Div. 2)\"\u003e75C - Modified GCD\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAt first, we should compute the GCD of the given two integers. As their common divisors must also be the divisors of GCD, the next step is to calculate all the divisors of GCD, and store them in the array S. Then, we sort S in a decreasing order, and for each query, we can directly enumerate S from the last element to the first one while stopping if we find the first element that falls into the interval. \u003c/p\u003e\u003cp\u003eIt seems that the above algorithm might lead to a risk of TLE. However, it turns out that the number of divisors of GCD cannot be very large, even if the maximum integer is up to 1E+9. Suppose that one integer only has 2 as its prime divisor. Then, it cannot exceed 2^36, and thus the number of divisors is at most 37. If it has 2 and 3 as its prime diviosrs, the number turns out to be at most 18*18. Furthermore, if it has 2, 3 and 5, the number seems to be less than 10^3. According to these observations, the above enumeration algorithm almost surely works well.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/75/problem/D\" title\u003d\"Codeforces Beta Round 67 (Div. 2)\"\u003e75D - Big Maximum Sum\u003c/a\u003e\u003c/p\u003e\u003cp\u003eA well designed problem! We should first implement some pre-calculation before solving it. For the i-th small array a[n], we compute its total sum T[i], the maximum prefix sum P[i], the maximum suffix sum S[i] and the maximum sum of sub-sequence M[i]. \u003c/p\u003e\u003cp\u003eFor the large array b[m], we use b_end[m] to denote the maximum sum with b[j] as the ending. This can be calculated by the following formula:\u003c/p\u003e\u003cp\u003e1）if b_end[j-1]+T[b[j]]\u0026gt;S[b[j]], then b_end[j]\u003db_end[j-1]+T[b[j]]\u003c/p\u003e\u003cp\u003e2）otherwise b_end[j]\u003dS[b[j]]\u003c/p\u003e\u003cp\u003ewith b_end[0] initialized as S[b[0]].\u003c/p\u003e\u003cp\u003eThen, we enumerate b_end[m] and find out the maximum b_end[j]+P[j]. Note that we should further compare this value with all the M[j] that have appeared in b[m], and find out the maximum one as the final answer.\u003c/p\u003e\u003c/div\u003e","tags":[]}}