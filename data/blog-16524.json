{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1424439623,"rating":3,"authorHandle":"pranay2063","modificationTimeSeconds":1424439623,"id":16524,"title":"\u003cp\u003eInverse modulo of a range of numbers modulo m\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi all,\u003c/p\u003e\u003cp\u003eWhile searching about inverse modulo, i got to know about a concise algorithm to find inverse modulo of numbers in range[1...n) under modulo m.\u003c/p\u003e\u003cp\u003eTime complexity of this approach is O(n).\u003c/p\u003e\u003cp\u003eImplementation of the algorithm:\u003c/p\u003e\u003cp\u003er[1] \u003d 1; for (int i\u003d2; i\u0026lt;n; ++i)  r[i] \u003d (m â€” (m/i) * r[m%i] % m) % m;\u003c/p\u003e\u003cp\u003eHere is the link: \u003ca href\u003d\"http://e-maxx.ru/algo/reverse_element\"\u003ehttp://e-maxx.ru/algo/reverse_element\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI am unable to understand the proof of the algorithm. It would be very helpful if anyone explains the same in a simple way.\u003c/p\u003e\u003c/div\u003e","tags":["modular inverse"]}}