{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1465411012,"rating":99,"authorHandle":"Errichto","modificationTimeSeconds":1465560477,"id":45310,"title":"\u003cp\u003eCodeforces Round #356 — Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003e\u003ca href\u003d\"/contest/680/problem/A\" title\u003d\"Codeforces Round 356 (Div. 2)\"\u003e680A - Bear and Five Cards\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eIterate over all pairs and triples of numbers, and for each of them check if all two/three numbers are equal. If yes then consider the sum of remaining numbers as the answer (the final answer will be the minimum of considered sums). Below you can see two ways to implement the solution.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint main() {\n\tint t[5];\n\tint s \u003d 0;\n\tfor(int i \u003d 0; i \u0026lt; 5; ++i) {\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;t[i]);\n\t\ts +\u003d t[i];\n\t}\n\tint best \u003d s;\n\t\n\t// discard 2 cards\n\tfor(int a \u003d 0; a \u0026lt; 5; ++a)\n\t\tfor(int b \u003d a + 1; b \u0026lt; 5; ++b)\n\t\t\tif(t[a] \u003d\u003d t[b])\n\t\t\t\tbest \u003d min(best, s - 2 * t[a]);\n\t\n\t// or discard 3 cards\n\tfor(int a \u003d 0; a \u0026lt; 5; ++a)\n\t\tfor(int b \u003d a + 1; b \u0026lt; 5; ++b)\n\t\t\tfor(int c \u003d b + 1; c \u0026lt; 5; ++c)\n\t\t\t\tif(t[a] \u003d\u003d t[b] \u0026amp;\u0026amp; t[a] \u003d\u003d t[c])\n\t\t\t\t\tbest \u003d min(best, s - 3 * t[a]);\n\t\n\tprintf(\u0026quot;%d\\n\u0026quot;, best);\n\treturn 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint main() {\n\tint t[5];\n\tfor(int i \u003d 0; i \u0026lt; 5; ++i)\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;t[i]);\n\tsort(t, t + 5);\n\tint best_remove \u003d 0;\n\tfor(int i \u003d 0; i \u0026lt; 5; ++i) {\n\t\tif(i + 1 \u0026lt; 5 \u0026amp;\u0026amp; t[i] \u003d\u003d t[i+1])\n\t\t\tbest_remove \u003d max(best_remove, 2 * t[i]);\n\t\tif(i + 2 \u0026lt; 5 \u0026amp;\u0026amp; t[i] \u003d\u003d t[i+2])\n\t\t\tbest_remove \u003d max(best_remove, 3 * t[i]);\n\t}\n\tprintf(\u0026quot;%dn\u0026quot;, t[0]+t[1]+t[2]+t[3]+t[4]-best_remove);\n\treturn 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch1\u003e\u003ca href\u003d\"/contest/680/problem/B\" title\u003d\"Codeforces Round 356 (Div. 2)\"\u003e680B - Bear and Finding Criminals\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eLimak can\u0027t catch a criminal only if there are two cities at the same distance and only one of them contains a criminal. You should iterate over the distance and for each distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e check if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e - \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e are both in range \u003cspan class\u003d\"tex-span\"\u003e[1, \u003ci\u003en\u003c/i\u003e]\u003c/span\u003e and if only one of them has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 1\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int nax \u003d 1005;\nint t[nax];\nint main() {\n\tint n, a;\n\tscanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;a);\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; ++i)\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;t[i]);\n\tint answer \u003d 0;\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; ++i) if(t[i]) {\n\t\t// can we catch criminal in city i?\n\t\tint distance \u003d i - a; // distance from a\n\t\tint j \u003d a - distance; // the other city at the same distance\n\t\tif(j \u0026lt; 1 || j \u0026gt; n || t[i] \u003d\u003d t[j])\n\t\t\t++answer;\n\t}\n\tprintf(\u0026quot;%dn\u0026quot;, answer);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int nax \u003d 1005;\nint t[nax];\nbool impossible[nax];\nint main() {\n\tint n, a;\n\tscanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;a);\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; ++i)\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;t[i]);\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; ++i)\n\t\tfor(int j \u003d i + 1; j \u0026lt;\u003d n; ++j)\n\t\t\tif(abs(i - a) \u003d\u003d abs(j - a) \u0026amp;\u0026amp; t[i] !\u003d t[j]) {\n\t\t\t\t// i and j have the same distance to a\n\t\t\t\t// also, there is a criminal in exactly one of them\n\t\t\t\timpossible[i] \u003d impossible[j] \u003d true;\n\t\t\t}\n\tint answer \u003d 0;\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; ++i)\n\t\tif(t[i] \u003d\u003d 1 \u0026amp;\u0026amp; !impossible[i])\n\t\t\t++answer;\n\tprintf(\u0026quot;%dn\u0026quot;, answer);\n\treturn 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch1\u003e\u003ca href\u003d\"/contest/679/problem/A\" title\u003d\"Codeforces Round 356 (Div. 1)\"\u003e679A - Bear and Prime 100\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eIf a number is composite then it\u0027s either divisible by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e for some prime \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e, or divisible by two distinct primes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e. To check the first condition, it\u0027s enough to check all possible \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e (so, numbers \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e9\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e25\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e49\u003c/span\u003e). If at least one gives \u0026quot;yes\u0026quot; then the hidden number if composite.\u003c/p\u003e\u003cp\u003eIf there are two distinct prime divisors \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e then both of them are at most \u003cspan class\u003d\"tex-span\"\u003e50\u003c/span\u003e — otherwise the hidden number would be bigger than \u003cspan class\u003d\"tex-span\"\u003e100\u003c/span\u003e (because for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e ≥ 2\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e \u0026gt; 50\u003c/span\u003e we would get \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e·\u003ci\u003eq\u003c/i\u003e \u0026gt; 100\u003c/span\u003e). So, it\u0027s enough to check primes up to \u003cspan class\u003d\"tex-span\"\u003e50\u003c/span\u003e (there are \u003cspan class\u003d\"tex-span\"\u003e15\u003c/span\u003e of them), and check if at least two of them are divisors.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nbool isPrime(int a) {\n\tfor(int i \u003d 2; i * i \u0026lt;\u003d a; ++i)\n\t\tif(a % i \u003d\u003d 0)\n\t\t\treturn false;\n\treturn true;\n}\n\nbool divisible(int a) {\n\tprintf(\u0026quot;%dn\u0026quot;, a);\n\tfflush(stdout);\n\tchar sl[10];\n\tscanf(\u0026quot;%s\u0026quot;, sl);\n\treturn sl[0] \u003d\u003d \u0027y\u0027 || sl[0] \u003d\u003d \u0027Y\u0027;\n}\n\nint HIGH \u003d 100;\n\nint main() {\n\tint counter \u003d 0; // we print \u0026quot;composite\u0026quot; if counter \u0026gt;\u003d 2\n\tfor(int a \u003d 2; a \u0026lt;\u003d HIGH/2 \u0026amp;\u0026amp; counter \u0026lt; 2; ++a)\n\t\tif(isPrime(a))\n\t\t\tif(divisible(a)) {\n\t\t\t\t++counter;\n\t\t\t\tif(a * a \u0026lt;\u003d HIGH \u0026amp;\u0026amp; divisible(a * a))\n\t\t\t\t\t++counter;\n\t\t\t}\n\tputs(counter \u0026gt;\u003d 2 ? \u0026quot;composite\u0026quot; : \u0026quot;prime\u0026quot;);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode2, Python\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003efrom sys import stdout\n\nPRIMES \u003d [x for x in range(2,100) if 0 not in [x%i for i in range(2,x)]]\n\nNORMAL \u003d PRIMES[:15]\nSQUARES \u003d [x*x for x in PRIMES[:4]]\n\nfor ele in SQUARES:\n    print(ele)\n    stdout.flush()\n    x \u003d input()\n    if x \u003d\u003d \u0026quot;yes\u0026quot;:\n        print(\u0026quot;composite\u0026quot;)\n        exit(0)\n\nyes \u003d 0\nfor ele in NORMAL:\n    print(ele)\n    stdout.flush()\n    x \u003d input()\n    if x \u003d\u003d \u0026quot;yes\u0026quot;:\n        yes +\u003d 1\n\nprint(\u0026quot;prime\u0026quot; if yes \u0026lt; 2 else \u0026quot;composite\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch1\u003e\u003ca href\u003d\"/contest/679/problem/B\" title\u003d\"Codeforces Round 356 (Div. 1)\"\u003e679B - Bear and Tower of Cubes\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eLet\u0027s find the maximum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e ≤ \u003ci\u003em\u003c/i\u003e\u003c/span\u003e. Then, it\u0027s optimal to choose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e that the first block will have side \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e - 1\u003c/span\u003e. Let\u0027s see why.\u003c/p\u003e \u003cul\u003e   \u003cli\u003eIf the first block has side \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e then we are left with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u003d \u003ci\u003em\u003c/i\u003e - \u003ci\u003efirst\u003c/i\u003e_\u003ci\u003eblock\u003c/i\u003e \u003d \u003ci\u003em\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eIf the first block has side \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e - 1\u003c/span\u003e then the initial \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e must be at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e - 1\u003c/span\u003e (because otherwise we would take a block with side \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e), so we are left with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e - 1 - \u003ci\u003efirst\u003c/i\u003e_\u003ci\u003eblock\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e - 1 - (\u003ci\u003ea\u003c/i\u003e - 1)\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003c/span\u003e\u003c/li\u003e   \u003cli\u003eIf the first blocks has side \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e - 2\u003c/span\u003e then the initial \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e must be at most \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e - 1)\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e - 1\u003c/span\u003e, so we are left with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u003d (\u003ci\u003ea\u003c/i\u003e - 1)\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e - 1 - \u003ci\u003efirst\u003c/i\u003e_\u003ci\u003eblock\u003c/i\u003e \u003d (\u003ci\u003ea\u003c/i\u003e - 1)\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e - 1 - (\u003ci\u003ea\u003c/i\u003e - 2)\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eWe want to first maximize the number of blocks we can get with new limit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e. Secondarily, we want to have the biggest initial \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e. You can analyze the described above cases and see that the first block with side \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e - 2)\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003c/span\u003e must be a worse choice than \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e - 1)\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003c/span\u003e. It\u0027s because we start with smaller \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e and we are left with smaller \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e. The situation for even smaller side of the first block would be even worse.\u003c/p\u003e\u003cp\u003eNow, you can notice that the answer will be small. From \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e of magnitude \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003c/span\u003e after one block we get \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e of magnitude \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e. So, from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e we go to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2 / 3\u003c/sup\u003e\u003c/span\u003e, which means that the answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eloglog\u003c/i\u003e(\u003ci\u003em\u003c/i\u003e))\u003c/span\u003e. The exact maximum answer turns out to be \u003cspan class\u003d\"tex-span\"\u003e18\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe intended solution is to use the recursion and brutally check both cases: taking \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003c/span\u003e and taking \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e - 1)\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e is maximum that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e ≤ \u003ci\u003em\u003c/i\u003e\u003c/span\u003e. It\u0027s so fast that you can even find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003em\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e1 / 3\u003c/sup\u003e)\u003c/span\u003e, increasing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e by one.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\npair\u0026lt;ll,ll\u0026gt; best;\n\nll my_pow(ll x) { return x * x * x; }\n\nvoid rec(ll m, ll steps, ll subtracted) {\n\tif(m \u003d\u003d 0) {\n\t\tbest \u003d max(best, make_pair(steps, subtracted));\n\t\treturn;\n\t}\n\tll x \u003d 1;\n\twhile(my_pow(x+1) \u0026lt;\u003d m) ++x;\n\trec(m - my_pow(x), steps+1, subtracted + my_pow(x));\n\tif(x - 1 \u0026gt;\u003d 0)\n\t\trec(my_pow(x)-1-my_pow(x-1), steps+1, subtracted + my_pow(x-1));\n}\n\nint main() {\n\tll m;\n\tscanf(\u0026quot;%lld\u0026quot;, \u0026amp;m);\n\trec(m, 0, 0);\n\tprintf(\u0026quot;%lld %lldn\u0026quot;, best.first, best.second);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nll my_pow(ll x) { return x * x * x; }\n\nll steps(ll m) { // works in O(m^(1/3))\n\tif(m \u0026lt;\u003d 7) return m;\n\tll x \u003d 1;\n\twhile(my_pow(x+1) \u0026lt;\u003d m) ++x;\n\treturn 1 + steps(max(m - my_pow(x), my_pow(x)-1-my_pow(x-1)));\n}\n\nint main() {\n\tll m;\n\tscanf(\u0026quot;%lld\u0026quot;, \u0026amp;m);\n\tll subtracted \u003d 0, steps_so_far \u003d 0;\n\twhile(m) {\n\t\t++steps_so_far;\n\t\tll x \u003d 1;\n\t\twhile(my_pow(x+1) \u0026lt;\u003d m) ++x;\n\t\tif(steps(m) \u003d\u003d 1 + steps(m - my_pow(x))) {\n\t\t\tm -\u003d my_pow(x);\n\t\t\tsubtracted +\u003d my_pow(x);\n\t\t}\n\t\telse {\n\t\t\tm \u003d my_pow(x) - 1 - my_pow(x-1);\n\t\t\tsubtracted +\u003d my_pow(x-1);\n\t\t}\n\t}\n\tprintf(\u0026quot;%lld %lldn\u0026quot;, steps_so_far, subtracted);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode3\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\n\nusing namespace std;\n\n#define ll long long\n\nvector \u0026lt;ll\u0026gt; X;\nmap \u0026lt;ll, pair \u0026lt;int, ll\u0026gt; \u0026gt; M;\n\npair \u0026lt;int, ll\u0026gt; go(ll x)\n{\n  if(x \u0026lt;\u003d 1)\n    return {x,x};\n  if(M.find(x) !\u003d M.end())\n    return M[x];\n  int i \u003d upper_bound(X.begin(), X.end(), x) - X.begin() - 1;\n  int p1, p2;\n  long long q1, q2;\n  tie(p1, q1) \u003d go(x - X[i]);\n  tie(p2, q2) \u003d go(X[i] - 1);\n  return M[x] \u003d  max(make_pair(p1+1, q1+X[i]), {p2, q2});\n}\n\nint main()\n{\n  for(int i\u003d0; i\u0026lt;\u003d1e5+7; i++)\n    X.push_back(1LL*i*i*i);\n  ll x;\n  cin \u0026gt;\u0026gt; x;\n  int a;\n  long long b;\n  tie(a,b) \u003d go(x);\n  cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026quot;n\u0026quot;;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch1\u003e\u003ca href\u003d\"/contest/679/problem/C\" title\u003d\"Codeforces Round 356 (Div. 1)\"\u003e679C - Bear and Square Grid\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eLet\u0027s first find CC\u0027s (connected components) in the given grid, using DFS\u0027s.\u003c/p\u003e\u003cp\u003eWe will consider every possible placement of a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e × \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e square. When the placement is fixed then the answer is equal to the sum of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e the the sum of sizes of CC\u0027s touching borders of the square (touching from outside), but for those CC\u0027s we should only count their cells that are outside of the square — not to count something twice. We will move a square, and at the same time for each CC we will keep the number of its cells outside the square.\u003c/p\u003e\u003cp\u003eWe will used a sliding-window technique. Let\u0027s fix row of the grid — the upper row of the square. Then, we will first place the square on the left, and then we will slowly move a square to the right. As we move a square, we should iterate over cells that stop or start to belong to the square. For each such empty cell we should add or subtract \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e from the size of its CC (ids and sizes of CC\u0027s were found at the beginning).\u003c/p\u003e\u003cp\u003eAnd for each placement we consider, we should iterate over outside borders of the square (\u003cspan class\u003d\"tex-span\"\u003e4\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e cells — left, up, right and down side) and sum up sizes of CC\u0027s touching our square. Be careful to not count some CC twice — you can e.g. keep an array of booleans and mark visited CC\u0027s. After checking all \u003cspan class\u003d\"tex-span\"\u003e4\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e cells you should clear an array, but you can\u0027t do it in O(number_of_all_components) because it would be too slow. You can e.g. also add visited CC\u0027s to some vector, and later in the boolean array clear only CC\u0027s from the vector (and then clear vector).\u003c/p\u003e\u003cp\u003eThe complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e·\u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int nax \u003d 505;\nint n;\nchar grid[nax][nax]; // input\nint cc[nax][nax]; // id of CC in which this cell is\nint cc_size[nax*nax]; // size of CC\nint when_added[nax*nax];\n\nconst int dx[4] \u003d {-1, 1, 0, 0};\nconst int dy[4] \u003d {0, 0, -1, 1};\nconst char EMPTY \u003d \u0027.\u0027;\n\nbool inside(int x, int y) {\n\treturn 0 \u0026lt;\u003d min(x, y) \u0026amp;\u0026amp; max(x, y) \u0026lt; n;\n}\n\nvoid dfs(int x, int y, int which_cc) {\n\tcc[x][y] \u003d which_cc;\n\t++cc_size[which_cc];\n\tfor(int i \u003d 0; i \u0026lt; 4; ++i) { // iterate of 4 adjacent cells\n\t\tint x2 \u003d x + dx[i];\n\t\tint y2 \u003d y + dy[i];\n\t\tif(inside(x2, y2) \u0026amp;\u0026amp; grid[x2][y2] \u003d\u003d EMPTY \u0026amp;\u0026amp; cc[x2][y2] \u003d\u003d 0)\n\t\t\tdfs(x2, y2, which_cc);\n\t}\n}\n\nvoid add(int x, int y, int \u0026amp; answer, int current_time) {\n\tif(inside(x, y) \u0026amp;\u0026amp; grid[x][y] \u003d\u003d EMPTY) {\n\t\tint id \u003d cc[x][y];\n\t\tif(when_added[id] !\u003d current_time) {\n\t\t\twhen_added[id] \u003d current_time;\n\t\t\tanswer +\u003d cc_size[id];\n\t\t}\n\t}\n}\n\nint main() {\n\tint k;\n\tscanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;k);\n\tfor(int i \u003d 0; i \u0026lt; n; ++i)\n\t\tscanf(\u0026quot;%s\u0026quot;, grid[i]);\n\t\n\t// run DFS many times to find CC\u0027s (connected components)\n\tint how_many_cc \u003d 0;\n\tfor(int x \u003d 0; x \u0026lt; n; ++x)\n\t\tfor(int y \u003d 0; y \u0026lt; n; ++y)\n\t\t\tif(grid[x][y] \u003d\u003d EMPTY \u0026amp;\u0026amp; cc[x][y] \u003d\u003d 0)\n\t\t\t\tdfs(x, y, ++how_many_cc);\n\t\n\tint cur_time \u003d 1;\n\tint best_answer \u003d 0;\n\t\n\tfor(int y_low \u003d 0; y_low + k \u0026lt;\u003d n; ++y_low) {\n\t\t// first we put a square with corner in (0, y_low)\n\t\tfor(int x \u003d 0; x \u0026lt; k; ++x)\n\t\t\tfor(int y \u003d y_low; y \u0026lt; y_low + k; ++y)\n\t\t\t\t--cc_size[cc[x][y]]; // subtract cells inside a square\n\t\t\n\t\tfor(int x_low \u003d 0; x_low  + k \u0026lt;\u003d n; ++x_low) {\n\t\t\tint answer \u003d k * k; // all cells inside a square\n\t\t\t// consider one row: below, above, left, right\n\t\t\tfor(int x \u003d x_low; x \u0026lt; x_low + k; ++x) {\n\t\t\t\tadd(x, y_low - 1, answer, cur_time);\n\t\t\t\tadd(x, y_low + k, answer, cur_time);\n\t\t\t}\n\t\t\tfor(int y \u003d y_low; y \u0026lt; y_low + k; ++y) {\n\t\t\t\tadd(x_low - 1, y, answer, cur_time);\n\t\t\t\tadd(x_low + k, y, answer, cur_time);\n\t\t\t}\n\t\t\t++cur_time;\n\t\t\tbest_answer \u003d max(best_answer, answer);\n\t\t\t\n\t\t\tif(x_low + k !\u003d n) {\n\t\t\t\t// move a square to increase x_low by 1\n\t\t\t\tfor(int y \u003d y_low; y \u0026lt; y_low + k; ++y) {\n\t\t\t\t\t++cc_size[cc[x_low][y]]; // remove cells with x \u003d x_low\n\t\t\t\t\t--cc_size[cc[x_low+k][y]]; // insert cells with x \u003d x_low+k\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int x \u003d n - k; x \u0026lt; n; ++x)\n\t\t\tfor(int y \u003d y_low; y \u0026lt; y_low + k; ++y)\n\t\t\t\t++cc_size[cc[x][y]]; // we don\u0027t need cells inside to be subtracted\n\t}\n\tprintf(\u0026quot;%dn\u0026quot;, best_answer);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define FOR(i,a,b) for(int i \u003d (a); i \u0026lt;\u003d (b); ++i)\n#define FORD(i,a,b) for(int i \u003d (a); i \u0026gt;\u003d (b); --i)\n#define RI(i,n) FOR(i,1,(n))\n#define REP(i,n) FOR(i,0,(n)-1)\n#define mini(a,b) a\u003dmin(a,b)\n#define maxi(a,b) a\u003dmax(a,b)\n#define mp make_pair\n#define pb push_back\n#define st first\n#define nd second\n#define sz(w) (int) w.size()\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair\u0026lt;int,int\u0026gt; pii;\nconst int inf \u003d 1e9 + 5;\nconst int nax \u003d 500 + 5;\nconst int nax2 \u003d nax * nax;\n\nint n,k;\n\nint ile_na_zew, akt_stan \u003d 1;\n\nchar t[nax][nax];\nint ojc[nax][nax];\nint ilosc[nax2], lewo[nax2], prawo[nax2], gora[nax2], dol[nax2];\nint suma[nax][nax], kol[nax], stan[nax2];\nbool bylo[nax][nax];\n\nvector\u0026lt;pair\u0026lt;pii, int\u0026gt; \u0026gt; wiersz[nax];\n\nint ruchi[] \u003d {-1, 0, 1, 0};\nint ruchj[] \u003d {0, -1, 0, 1};\n\nvoid dfs(int i, int j, int wsk) {\n  ilosc[wsk]++;\n  ojc[i][j] \u003d wsk;\n  bylo[i][j] \u003d true;\n  lewo[wsk] \u003d  min(lewo[wsk], j);\n  prawo[wsk] \u003d max(prawo[wsk], j);\n  gora[wsk] \u003d  min(gora[wsk], i);\n  dol[wsk] \u003d   max(dol[wsk], i);  \n  \n  REP(g,4) {\n    int ni \u003d i + ruchi[g];\n    int nj \u003d j + ruchj[g];\n    \n    if (t[ni][nj] \u003d\u003d \u0027.\u0027 \u0026amp;\u0026amp; bylo[ni][nj] \u003d\u003d false)\n      dfs(ni,nj,wsk);\n  }\n}\n\nvoid check(int o) {\n  if (stan[o] !\u003d akt_stan)\n    ile_na_zew +\u003d ilosc[o];\n  stan[o] \u003d akt_stan;  \n}\n\nint main() {\t\n  scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;k);\n  FOR(i,1,n) scanf(\u0026quot; %s\u0026quot;,t[i]+1);\n  \n  int wsk \u003d 1;\n  FOR(i,1,n) FOR(j,1,n) if (t[i][j] \u003d\u003d \u0027.\u0027 \u0026amp;\u0026amp; !bylo[i][j]) {\n    lewo[wsk] \u003d prawo[wsk] \u003d j;\n    gora[wsk] \u003d dol[wsk] \u003d i;\n    dfs(i,j,wsk);\n    //printf(\u0026quot;%dn\u0026quot;,ilosc[wsk]);\n    if (prawo[wsk] - lewo[wsk] + 1 \u0026lt;\u003d k \u0026amp;\u0026amp; dol[wsk] - gora[wsk] + 1 \u0026lt;\u003d k) {\n      //puts(\u0026quot;DD\u0026quot;);\n      int x \u003d max(1, dol[wsk] - k + 1);\n      wiersz[x].pb(mp(mp(lewo[wsk], prawo[wsk]), ilosc[wsk]));\n      wiersz[gora[wsk]+1].pb(mp(mp(lewo[wsk], prawo[wsk]), -ilosc[wsk]));\n    }\n    ++wsk;\n  }\n  \n  FOR(i,1,n) FOR(j,1,n) suma[i][j] \u003d suma[i-1][j] + suma[i][j-1] - suma[i-1][j-1] + (t[i][j] \u003d\u003d \u0027.\u0027);\n  //FOR(i,1,n) FOR(j,1,n) printf(\u0026quot;(%d,%d): %dn\u0026quot;,i,j,suma[i][j]);\n  \n  int res \u003d 0;\n  FOR(i,1,n-k+1) {\n    for (auto p: wiersz[i]) {\n      int l \u003d max(1, p.st.nd - k + 1);\n      //printf(\u0026quot;%d %d %dn\u0026quot;,l,p.st.st,p.nd);\n      kol[l] +\u003d p.nd;\n      kol[p.st.st + 1] -\u003d p.nd;\n    }\n    \n    int suma_s \u003d 0;\n    FOR(j,1,n-k+1) {\n      suma_s +\u003d kol[j];\n      int ile_w_s \u003d suma[i+k-1][j+k-1] - suma[i-1][j+k-1] - suma[i+k-1][j-1] + suma[i-1][j-1];\n      ile_na_zew \u003d 0;\n      REP(g,k) {\n        check(ojc[i-1][j+g]);\n        check(ojc[i+k][j+g]);\n        check(ojc[i+g][j-1]);\n        check(ojc[i+g][j+k]);\n      }\n      \n      int x \u003d ile_na_zew + (k * k  - ile_w_s) + suma_s;\n      //printf(\u0026quot;(%d,%d) : %d %d %d %dn\u0026quot;,i,j,ile_na_zew, ile_w_s, suma_s, x);\n      \n      res \u003d max(res, x);\n      ++akt_stan;\n    }\n  }\n  printf(\u0026quot;%dn\u0026quot;,res);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode3, Java\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author AlexFetisov\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream \u003d System.in;\n        OutputStream outputStream \u003d System.out;\n        InputReader in \u003d new InputReader(inputStream);\n        PrintWriter out \u003d new PrintWriter(outputStream);\n        TaskE_356 solver \u003d new TaskE_356();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE_356 {\n        int n;\n        int k;\n        boolean[][] f;\n        List\u0026lt;Integer\u0026gt; componentCellCount;\n        int[][] color;\n        int x \u003d 0;\n        int y \u003d 0;\n        int totalEmpty \u003d 0;\n        int sumInComponents \u003d 0;\n        int[] amInComponents;\n        int[] flag;\n        int currentFlagColor \u003d 0;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            n \u003d in.nextInt();\n            k \u003d in.nextInt();\n            f \u003d new boolean[n][n];\n            color \u003d new int[n][n];\n            ArrayUtils.fill(color, -1);\n            for (int i \u003d 0; i \u0026lt; n; ++i) {\n                char[] c \u003d in.nextString().toCharArray();\n                for (int j \u003d 0; j \u0026lt; n; ++j) {\n                    f[i][j] \u003d (c[j] \u003d\u003d \u0027.\u0027);\n                }\n            }\n\n            // Caclulate all CC\n            int res \u003d 0;\n            componentCellCount \u003d new ArrayList\u0026lt;Integer\u0026gt;();\n            int currentComponentId \u003d 0;\n            for (int i \u003d 0; i \u0026lt; n; ++i) {\n                for (int j \u003d 0; j \u0026lt; n; ++j) {\n                    if (color[i][j] \u003d\u003d -1) {\n                        int count \u003d dfs(i, j, currentComponentId++);\n                        componentCellCount.add(count);\n                        res \u003d Math.max(res, count);\n                    }\n                }\n            }\n\n            flag \u003d new int[currentComponentId];\n            amInComponents \u003d new int[currentComponentId];\n            // Preprocess first square\n            for (int i \u003d 0; i \u0026lt; k; ++i) {\n                for (int j \u003d 0; j \u0026lt; k; ++j) {\n                    addCell(i, j);\n                }\n            }\n\n            res \u003d Math.max(res, checkResult());\n\n            for (int i \u003d 0; i \u0026lt;\u003d n - k; ++i) {\n                int delta \u003d i % 2 \u003d\u003d 0 ? 1 : -1;\n                for (int j \u003d 0; j \u0026lt; n - k; ++j) {\n                    moveSquare(0, x, y, x, y + delta);\n                    y +\u003d delta;\n                    res \u003d Math.max(res, checkResult());\n                }\n                if (i !\u003d n - k) {\n                    moveSquare(1, x, y, x + 1, y);\n                    ++x;\n                    res \u003d Math.max(res, checkResult());\n                }\n            }\n            out.println(res);\n        }\n\n        void moveSquare(int type, int cx, int cy, int nx, int ny) {\n            if (type \u003d\u003d 0) {\n                if (ny \u0026lt; cy) {\n                    for (int i \u003d 0; i \u0026lt; k; ++i) {\n                        removeCell(cx + i, cy + k - 1);\n                        addCell(cx + i, ny);\n                    }\n                } else {\n                    for (int i \u003d 0; i \u0026lt; k; ++i) {\n                        removeCell(cx + i, cy);\n                        addCell(cx + i, ny + k - 1);\n                    }\n                }\n            } else {\n                for (int i \u003d 0; i \u0026lt; k; ++i) {\n                    removeCell(cx, cy + i);\n                    addCell(nx + k - 1, cy + i);\n                }\n            }\n        }\n\n        void removeCell(int cx, int cy) {\n            if (f[cx][cy]) {\n                --totalEmpty;\n                amInComponents[color[cx][cy]]--;\n                if (amInComponents[color[cx][cy]] \u003d\u003d 0) {\n                    sumInComponents -\u003d componentCellCount.get(color[cx][cy]);\n                }\n            }\n        }\n\n        void addCell(int cx, int cy) {\n            if (f[cx][cy]) {\n                ++totalEmpty;\n                amInComponents[color[cx][cy]]++;\n                if (amInComponents[color[cx][cy]] \u003d\u003d 1) {\n                    sumInComponents +\u003d componentCellCount.get(color[cx][cy]);\n                }\n            }\n        }\n\n        int dfs(int cx, int cy, int cId) {\n            if (cx \u0026lt; 0 || cx \u0026gt;\u003d n || cy \u0026lt; 0 || cy \u0026gt;\u003d n) return 0;\n            if (color[cx][cy] !\u003d -1) return 0;\n            if (!f[cx][cy]) return 0;\n            color[cx][cy] \u003d cId;\n            int am \u003d 1;\n            am +\u003d dfs(cx - 1, cy, cId);\n            am +\u003d dfs(cx + 1, cy, cId);\n            am +\u003d dfs(cx, cy - 1, cId);\n            am +\u003d dfs(cx, cy + 1, cId);\n            return am;\n        }\n\n        int checkResult() {\n            ++currentFlagColor;\n            int res \u003d k * k - totalEmpty + sumInComponents;\n            for (int i \u003d 0; i \u0026lt; k; ++i) {\n                res +\u003d checkCell(x - 1, y + i);\n                res +\u003d checkCell(x + k, y + i);\n                res +\u003d checkCell(x + i, y - 1);\n                res +\u003d checkCell(x + i, y + k);\n            }\n            return res;\n        }\n\n        int checkCell(int cx, int cy) {\n            if (cx \u0026lt; 0 || cx \u0026gt;\u003d n || cy \u0026lt; 0 || cy \u0026gt;\u003d n) return 0;\n            if (!f[cx][cy]) return 0;\n            if (amInComponents[color[cx][cy]] \u0026gt; 0) return 0;\n            if (flag[color[cx][cy]] \u003d\u003d currentFlagColor) return 0;\n            flag[color[cx][cy]] \u003d currentFlagColor;\n            return componentCellCount.get(color[cx][cy]);\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static void fill(int[][] f, int value) {\n            for (int i \u003d 0; i \u0026lt; f.length; ++i) {\n                Arrays.fill(f[i], value);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer stt;\n\n        public InputReader(InputStream stream) {\n            reader \u003d new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public String nextString() {\n            while (stt \u003d\u003d null || !stt.hasMoreTokens()) {\n                stt \u003d new StringTokenizer(nextLine());\n            }\n            return stt.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextString());\n        }\n\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch1\u003e\u003ca href\u003d\"/contest/679/problem/D\" title\u003d\"Codeforces Round 356 (Div. 1)\"\u003e679D - Bear and Chase\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eCheck my code below, because it has a lot of comments.\u003c/p\u003e\u003cp\u003eFirst, in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e or faster find all distances between pairs of cities.\u003c/p\u003e\u003cp\u003eIterate over all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e1\u003c/span\u003e — the first city in which you use the BCD. Then, for iterate over all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e1\u003c/span\u003e — the distance you get. Now, for all cities calculate the probability that Limak will be there in the second day (details in my code below). Also, in a vector \u003ccode\u003einteresting\u003c/code\u003e let\u0027s store all cities that are at distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e1\u003c/span\u003e from city \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThen, iterate over all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e2\u003c/span\u003e — the second city in which you use the BCD. For cities from \u003ccode\u003einteresting\u003c/code\u003e, we want to iterate over them and for each distinct distance from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e2\u003c/span\u003e to choose the biggest probability (because we will make the best guess there is).\u003c/p\u003e\u003cp\u003eMagic: the described approach has four loops (one in the other) but it\u0027s \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eProof is very nice and I encourage you to try to get it yourself.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProof here\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eAfter fixing g1 divide cities by their distance from g1. Then, when we get distance d1 in the first day, then in the second day all possible cities are at distance d1-1, d1 and d1+1. So, we will consider each city at most three times.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define FOR(i,a,b) for(int i \u003d (a); i \u0026lt;\u003d (b); ++i)\ntypedef double T;\nconst int nax \u003d 1005;\nint dist[nax][nax];\nvector\u0026lt;int\u0026gt; w[nax];\nT p_later[nax]; // p[v] - probability for city v in the second day\nT p_dist_max[nax];\nbool vis[nax];\n\nvoid max_self(T \u0026amp; a, T b) {\n\ta \u003d max(a, b);\n}\n\nT consider_tomorrow(int n, int g1, int dist1) {\n\tT best_tomorrow \u003d 0;\n\t// we need complexity O(n * x)\n\t// where x denotes the number of v that |dist1-dist[g1][v]| \u0026lt;\u003d 1\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; ++i) {\n\t\tp_later[i] \u003d 0;\n\t\tvis[i] \u003d false;\n\t}\n\tvector\u0026lt;int\u0026gt; interesting;\n\tfor(int v \u003d 1; v \u0026lt;\u003d n; ++v) if(dist[g1][v] \u003d\u003d dist1)\n\t\tfor(int b : w[v]) {\n\t\t\t// Limak started in v with prob. 1/n\n\t\t\t// he then moved to b with prob. 1/degree[v]\n\t\t\tp_later[b] +\u003d (T) 1 / n / w[v].size();\n\t\t\tif(!vis[b]) {\n\t\t\t\tvis[b] \u003d true;\n\t\t\t\tinteresting.push_back(b);\n\t\t\t}\n\t\t}\n\t\n\t// interesting.size() \u0026lt;\u003d x, where x is defined above (needed for complexity)\n\tfor(int g2 \u003d 1; g2 \u0026lt;\u003d n; ++g2) {\n\t\tT local_sum \u003d 0; // over situations with fixed g1, dist1, g2\n\t\t\n\t\tfor(int b : interesting)\n\t\t\tmax_self(p_dist_max[dist[g2][b]], p_later[b]);\n\t\tfor(int b : interesting) {\n\t\t\tlocal_sum +\u003d p_dist_max[dist[g2][b]];\n\t\t\tp_dist_max[dist[g2][b]] \u003d 0; // so it won\u0027t be calculated twice\n\t\t}\n\t\tmax_self(best_tomorrow, local_sum);\n\t}\n\treturn best_tomorrow;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m);\n\tFOR(i,1,n) FOR(j, 1, n) if(i !\u003d j)\n\t\tdist[i][j] \u003d n + 1; // infinity\n\tFOR(i,1,m) {\n\t\tint a, b;\n\t\tscanf(\u0026quot;%d%d\u0026quot;, \u0026amp;a, \u0026amp;b);\n\t\tw[a].push_back(b);\n\t\tw[b].push_back(a);\n\t\tdist[a][b] \u003d dist[b][a] \u003d 1;\n\t}\n\t// Floyd-Warshall\n\tFOR(b,1,n)FOR(a,1,n)FOR(c,1,n)\n\t\tdist[a][c] \u003d min(dist[a][c], dist[a][b] + dist[b][c]);\n\t\n\t// g1 is the first guess\n\tT answer \u003d 0;\n\tFOR(g1, 1, n) {\n\t\tT sum_over_dist1 \u003d 0;\n\t\tFOR(dist1, 0, n) {\n\t\t\tint cnt_cities \u003d 0;\n\t\t\tFOR(i, 1, n) if(dist[g1][i] \u003d\u003d dist1)\n\t\t\t\t++cnt_cities;\n\t\t\tif(cnt_cities \u003d\u003d 0) continue; // there are no cities within distance dist1\n\t\t\t\n\t\t\t// 1) consider guessing immediately\n\t\t\tT immediately \u003d (T) 1 / n; // how much it counts towards the answer\n\t\t\t// 2) consider waiting for tomorrow\n\t\t\tT second_day \u003d consider_tomorrow(n, g1, dist1);\n\t\t\tsum_over_dist1 +\u003d max(immediately, second_day);\n\t\t}\n\t\tmax_self(answer, sum_over_dist1);\n\t}\n\tprintf(\u0026quot;%.12lfn\u0026quot;, (double) answer);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch1\u003e\u003ca href\u003d\"/contest/679/problem/E\" title\u003d\"Codeforces Round 356 (Div. 1)\"\u003e679E - Bear and Bad Powers of 42\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eThe only special thing in numbers \u003cspan class\u003d\"tex-span\"\u003e1, 42, ...\u003c/span\u003e was that there are only few such numbers (in the possible to achieve range, so up to about \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e14\u003c/sup\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eLet\u0027s first solve the problem without queries \u0026quot;in the interval change all numbers to x\u0026quot;. Then, we can make a tree with operations (possible with lazy propagation):\u003c/p\u003e \u003cul\u003e   \u003cli\u003eadd on the interval\u003c/li\u003e   \u003cli\u003efind minimum in the whole tree\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eIn a tree for each index \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e6/aa/e6aa139d54fafb298b2d569825276fb29bf98eb6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e let\u0027s keep the distance to the next power of 42. After each \u0026quot;add on the interval\u0026quot; we should find the minimum and check if it\u0027s positive. If not then we should change value of the closest power of \u003cspan class\u003d\"tex-span\"\u003e42\u003c/span\u003e for this index, and change the value in the tree. Then, we should again find the minimum in the tree, and so on. The amortized complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003en\u003c/i\u003e + \u003ci\u003eq\u003c/i\u003e) * \u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e) * \u003ci\u003elog\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e42\u003c/sub\u003e(\u003ci\u003evalues\u003c/i\u003e))\u003c/span\u003e. It can be proved that numbers won\u0027t exceed \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003eq\u003c/i\u003e) * 1\u003ci\u003ee\u003c/i\u003e9 * \u003ci\u003elog\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow let\u0027s think about the remaining operation of changing all interval to some value. We can set only one number (the last one) to the given value, and set other values to INF. We want to guarantee that if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] ≠ \u003ci\u003et\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1]\u003c/span\u003e then the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th value is correctly represented in the tree. Otherwise, it can be INF instead (or sometimes it may be correctly represented, it doesn\u0027t bother me). When we have the old query of type \u0026quot;add something to interval \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e]\u003c/span\u003e\u0026quot; then if index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e - 1\u003c/span\u003e or index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e contains INF in the tree then we should first retrieve the true value there. You can see that each operation changes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e values from INF to something finite. So, the amortized complexity is still \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003en\u003c/i\u003e + \u003ci\u003eq\u003c/i\u003e) * \u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e) * \u003ci\u003elog\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e42\u003c/sub\u003e(\u003ci\u003evalues\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eOne thing regarding implementation. In my solution there is \u0026quot;\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eset\u003c/i\u003e \u0026lt; \u003ci\u003eint\u003c/i\u003e \u0026gt; \u003ci\u003einteresting\u003c/i\u003e\u003c/span\u003e\u0026quot; containing indices with INF value. I think it\u0027s easier to implemement the solution with this set.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\nconst int nax \u003d 1e6 + 5;\nconst int pot \u003d 256 * 1024;\nconst ll INF \u003d 3e18L;\nll cur_power[nax]; // the least power of 42 larger than the current value\n// true_value + remaining \u003d cur_power,  where remaining\u003dtr[pot+i]\n\nstruct Node {\n\tll local;\n\tll lazy;\n\tll smallest() { return local + lazy; } // smallest value in this subtree\n} tr[2*pot];\n\nvoid propagate(int i) {\n\tassert(i \u0026lt; pot);\n\ttr[2*i].lazy +\u003d tr[i].lazy;\n\ttr[2*i+1].lazy +\u003d tr[i].lazy;\n\ttr[i].local +\u003d tr[i].lazy;\n\ttr[i].lazy \u003d 0;\n}\nvoid act(int i) {\n\tassert(i \u0026lt; pot);\n\tassert(tr[i].lazy \u003d\u003d 0);\n\ttr[i].local \u003d min(tr[2*i].smallest(), tr[2*i+1].smallest());\n}\n\nvoid change(int i, int low, int high, int q_low, int q_high, ll val) {\n\tif(q_low \u0026lt;\u003d low \u0026amp;\u0026amp; high \u0026lt;\u003d q_high) {\n\t\ttr[i].lazy +\u003d val;\n\t\treturn;\n\t}\n\tpropagate(i);\n\tint mid1 \u003d (low + high) / 2;\n\tif(q_low \u0026lt;\u003d mid1)\n\t\tchange(2*i, low, mid1, q_low, q_high, val);\n\tif(q_high \u0026gt;\u003d mid1+1)\n\t\tchange(2*i+1, mid1+1, high, q_low, q_high, val);\n\tact(i);\n}\nvoid change(int q_low, int q_high, ll val) {\n\tchange(1, 0, pot - 1, q_low, q_high, val);\n}\n\nint where_smallest(int i \u003d 1) {\n\tif(i \u0026gt;\u003d pot) return i - pot;\n\tpropagate(i);\n\tint ret;\n\tif(tr[2*i].smallest() \u0026lt; tr[2*i+1].smallest())\n\t\tret \u003d where_smallest(2*i);\n\telse\n\t\tret \u003d where_smallest(2*i+1);\n\tact(i);\n\treturn ret;\n}\n\nll move_power(int i, ll rem) {\n\tassert(rem \u0026lt;\u003d 0);\n\twhile(rem \u0026lt; 0) {\n\t\tll cur_value \u003d cur_power[i] - rem;\n\t\tcur_power[i] *\u003d 42;\n\t\trem \u003d cur_power[i] - cur_value;\n\t}\n\treturn rem;\n}\n\nset\u0026lt;int\u0026gt; interesting; // the set of indices i that t[i] !\u003d t[i+1] (and maybe few others)\n// all other indices have value INF in the tree\n\nll get_value(int i) {\n\tassert(interesting.count(i));\n\tvector\u0026lt;int\u0026gt; w;\n\tfor(int x \u003d (pot + i) / 2; x \u0026gt;\u003d 1; x /\u003d 2)\n\t\tw.push_back(x);\n\treverse(w.begin(), w.end());\n\tfor(int x : w) propagate(x); // top-down\n\treturn tr[pot+i].smallest();\n}\n\nconst int SET_TYPE \u003d 10042;\nconst int INC_TYPE \u003d 10043;\nvoid set_or_inc(int i, ll val, const int type) {\n\tvector\u0026lt;int\u0026gt; w;\n\tfor(int x \u003d (pot + i) / 2; x \u0026gt;\u003d 1; x /\u003d 2)\n\t\tw.push_back(x);\n\treverse(w.begin(), w.end());\n\tfor(int x : w) propagate(x); // top-down\n\tif(type \u003d\u003d SET_TYPE) {\n\t\ttr[pot+i].lazy \u003d 0;\n\t\ttr[pot+i].local \u003d val;\n\t}\n\telse if(type \u003d\u003d INC_TYPE) {\n\t\ttr[pot+i].local +\u003d val;\n\t}\n\telse assert(false);\n\treverse(w.begin(), w.end());\n\tfor(int x : w) act(x); // bottom-up\n}\n\nvoid re_insert(int i) {\n\tint j \u003d *interesting.lower_bound(i);\n\tif(i \u003d\u003d j) return;\n\tcur_power[i] \u003d cur_power[j];\n\tset_or_inc(i, get_value(j), SET_TYPE);\n\tinteresting.insert(i);\n}\n\nvoid init_value(int i, int val) {\n\tcur_power[i] \u003d 1;\n\tll how_much_remains \u003d 1 - val; // how much remains to cur_power[i]\n\tll rem \u003d move_power(i, how_much_remains);\n\tset_or_inc(i, rem, SET_TYPE);\n}\n\nint main() {\n\tint n, q;\n\tscanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;q);\n\tfor(int i \u003d 0; i \u0026lt; 2 * pot; ++i)\n\t\ttr[i].local \u003d INF;\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; ++i) {\n\t\tinteresting.insert(i); // we don\u0027t mind that maybe t[i] \u003d t[i+1]\n\t\tint val;\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;val);\n\t\tinit_value(i, val);\n\t}\n\t// queries\n\twhile(q--) {\n\t\tint type;\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;type);\n\t\tif(type \u003d\u003d 1) { // print value\n\t\t\tint i;\n\t\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;i);\n\t\t\ti \u003d *interesting.lower_bound(i);\n\t\t\tprintf(\u0026quot;%lldn\u0026quot;, cur_power[i] - get_value(i));\n\t\t}\n\t\telse if(type \u003d\u003d 2) { // set interval to x\n\t\t\tint low, high, val;\n\t\t\tscanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;low, \u0026amp;high, \u0026amp;val);\n\t\t\t// t[low] \u003d t[low+1] \u003d ... \u003d t[high-1] \u003d INF\n\t\t\t// t[high] \u003d val\n\t\t\tif(low - 1 \u0026gt;\u003d 1)\n\t\t\t\tre_insert(low - 1);\n\t\t\tinteresting.insert(high);\n\t\t\tinit_value(high, val);\n\t\t\twhile(true) {\n\t\t\t\tauto it \u003d interesting.lower_bound(low);\n\t\t\t\tassert(it !\u003d interesting.end());\n\t\t\t\tint i \u003d *it;\n\t\t\t\tassert(i \u0026lt;\u003d high);\n\t\t\t\tif(i \u003d\u003d high) break; // we only want [low, high-1]\n\t\t\t\tinteresting.erase(it);\n\t\t\t\tset_or_inc(i, INF, SET_TYPE);\n\t\t\t}\n\t\t}\n\t\telse { // increase by x\n\t\t\tassert(type \u003d\u003d 3);\n\t\t\tint low, high, val;\n\t\t\tscanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;low, \u0026amp;high, \u0026amp;val);\n\t\t\tif(low - 1 \u0026gt;\u003d 1)\n\t\t\t\tre_insert(low - 1);\n\t\t\tre_insert(high);\n\t\t\tbool ok \u003d false;\n\t\t\twhile(!ok) {\n\t\t\t\tok \u003d true;\n\t\t\t\tchange(low, high, -val);\n\t\t\t\twhile(true) {\n\t\t\t\t\tint i \u003d where_smallest();\n\t\t\t\t\tll rem \u003d tr[pot+i].smallest();\n\t\t\t\t\tassert(1 \u0026lt;\u003d i \u0026amp;\u0026amp; i \u0026lt;\u003d n);\n\t\t\t\t\tif(rem \u0026gt; 0) break;\n\t\t\t\t\tif(rem \u003d\u003d 0) {\n\t\t\t\t\t\tok \u003d false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tll new_rem \u003d move_power(i, rem);\n\t\t\t\t\tset_or_inc(i, new_rem, SET_TYPE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint n, q;\n\nvector \u0026lt;long long\u0026gt; poty;\n\nint n1;\n\nlong long inf\u003d(long long)1000000000*1000000000;\n\nlong long narz[1000007];\nint czybom[1000007];\nlong long bom[1000007];\n\nlong long maxd[1000007];\nlong long mind[1000007];\nlong long zos[1000007];\n\nint typ, p1, p2, p3;\n\ninline int potenga(int v)\n{\n    for (int i\u003d1; 1; i\u0026lt;\u0026lt;\u003d1)\n    {\n        if (i\u0026gt;\u003dv)\n        {\n            return i;\n        }\n    }\n}\n\ninline long long wie(long long v)\n{\n    return poty[lower_bound(poty.begin(), poty.end(), v)-poty.begin()];\n}\n\ninline long long brak(long long v)\n{\n    return wie(v)-v;\n}\n\ninline void pusz(int v)\n{\n    if (v\u0026gt;\u003dn1)\n    {\n        czybom[v]\u003d1;\n        bom[v]+\u003dnarz[v];\n        narz[v]\u003d0;\n        maxd[v]\u003dbom[v];\n        mind[v]\u003dbom[v];\n        zos[v]\u003dbrak(bom[v]);\n        return;\n    }\n    int cel1, cel2;\n    cel1\u003d(v\u0026lt;\u0026lt;1);\n    cel2\u003d(cel1^1);\n    if (czybom[v])\n    {\n        czybom[cel1]\u003d1;\n        bom[cel1]\u003dbom[v];\n        narz[cel1]\u003d0;\n\n        czybom[cel2]\u003d1;\n        bom[cel2]\u003dbom[v];\n        narz[cel2]\u003d0;\n\n        czybom[v]\u003d0;\n        bom[v]\u003d0;\n    }\n    narz[cel1]+\u003dnarz[v];\n    narz[cel2]+\u003dnarz[v];\n    narz[v]\u003d0;\n\n    mind[v]\u003dinf;\n    maxd[v]\u003d-inf;\n    zos[v]\u003dinf;\n\n    for (int h\u003d0; h\u0026lt;2; h++)\n    {\n\n        if (czybom[cel1])\n        {\n            bom[cel1]+\u003dnarz[cel1];\n            narz[cel1]\u003d0;\n            maxd[v]\u003dmax(maxd[v], bom[cel1]);\n            mind[v]\u003dmin(mind[v], bom[cel1]);\n            zos[v]\u003dmin(zos[v], brak(bom[cel1]));\n        }\n        else\n        {\n            maxd[v]\u003dmax(maxd[v], maxd[cel1]+narz[cel1]);\n            mind[v]\u003dmin(mind[v], mind[cel1]+narz[cel1]);\n            zos[v]\u003dmin(zos[v], zos[cel1]-narz[cel1]);\n        }\n\n        swap(cel1, cel2);\n    }\n}\n\nvoid dod(int v, int a, int b, int graa, int grab, long long w)\n{\n    if (a\u0026gt;\u003dgraa \u0026amp;\u0026amp; b\u0026lt;\u003dgrab)\n    {\n        narz[v]+\u003dw;\n        return;\n    }\n    if (a\u0026gt;grab || b\u0026lt;graa)\n    {\n        return;\n    }\n    pusz(v);\n    dod((v\u0026lt;\u0026lt;1), a, (a+b)\u0026gt;\u0026gt;1, graa, grab, w);\n    dod((v\u0026lt;\u0026lt;1)^1, (a+b+2)\u0026gt;\u0026gt;1, b, graa, grab, w);\n    pusz(v);\n}\n\nvoid zmi(int v, int a, int b, int graa, int grab, long long w)\n{\n    if (a\u0026gt;\u003dgraa \u0026amp;\u0026amp; b\u0026lt;\u003dgrab)\n    {\n        narz[v]\u003d0;\n        czybom[v]\u003d1;\n        bom[v]\u003dw;\n        return;\n    }\n    if (a\u0026gt;grab || b\u0026lt;graa)\n    {\n        return;\n    }\n    pusz(v);\n    zmi((v\u0026lt;\u0026lt;1), a, (a+b)\u0026gt;\u0026gt;1, graa, grab, w);\n    zmi((v\u0026lt;\u0026lt;1)^1, (a+b+2)\u0026gt;\u0026gt;1, b, graa, grab, w);\n    pusz(v);\n}\n\nvoid popr(int v)\n{\n    pusz(v);\n    if (zos[v]\u0026gt;\u003d0)\n    {\n        return;\n    }\n    if (mind[v]\u003d\u003dmaxd[v])\n    {\n        czybom[v]\u003d1;\n        bom[v]\u003dmind[v];\n        narz[v]\u003d0;\n        pusz(v);\n        return;\n    }\n    popr((v\u0026lt;\u0026lt;1));\n    popr((v\u0026lt;\u0026lt;1)^1);\n    pusz(v);\n}\n\nlong long wyn;\n\nvoid czyt(int v, int a, int b, int cel)\n{\n    if (a\u0026gt;cel || b\u0026lt;cel)\n    return;\n    pusz(v);\n    if (a\u003d\u003db)\n    {\n        wyn\u003dbom[v];\n        return;\n    }\n    czyt((v\u0026lt;\u0026lt;1), a, (a+b)\u0026gt;\u0026gt;1, cel);\n    czyt((v\u0026lt;\u0026lt;1)^1, (a+b+2)\u0026gt;\u0026gt;1, b, cel);\n}\n\nint main()\n{\n    scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;q);\n    n1\u003dpotenga(n+2);\n    poty.push_back(1);\n    for (int i\u003d1; i\u0026lt;\u003d11; i++)\n    poty.push_back(poty.back()*42);\n    zmi(1, 1, n1, 1, n1, 0);\n    for (int i\u003d1; i\u0026lt;\u003dn; i++)\n    {\n        scanf(\u0026quot;%d\u0026quot;, \u0026amp;p1);\n        zmi(1, 1, n1, i, i, p1);\n    }\n    while(q--)\n    {\n        scanf(\u0026quot;%d\u0026quot;, \u0026amp;typ);\n        if (typ\u003d\u003d1)\n        {\n            scanf(\u0026quot;%d\u0026quot;, \u0026amp;p1);\n            czyt(1, 1, n1, p1);\n            printf(\u0026quot;%lldn\u0026quot;, wyn);\n        }\n        if (typ\u003d\u003d2)\n        {\n            scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;p1, \u0026amp;p2, \u0026amp;p3);\n            zmi(1, 1, n1, p1, p2, p3);\n        }\n        if (typ\u003d\u003d3)\n        {\n            scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;p1, \u0026amp;p2, \u0026amp;p3);\n            dod(1, 1, n1, p1, p2, p3);\n            while(1)\n            {\n                popr(1);\n                if (zos[1]\u003d\u003d0)\n                {\n                    dod(1, 1, n1, p1, p2, p3);\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["bear","limak","editorial","round 356"]}}