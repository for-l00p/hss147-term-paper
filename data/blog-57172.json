{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1516170661,"rating":3,"authorHandle":"ZzZZzzzZZZZZzzzzzzzz","modificationTimeSeconds":1516170661,"id":57172,"title":"\u003cp\u003eAho-Korasik Code\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003econst int N \u003d 1e5 + 1;\n\nstruct node {\n  unordered_map \u0026lt;int, int\u0026gt; nxt;\n  bool end;\n  int suff;\n  node () {\n    suff \u003d end \u003d 0;\n    nxt.clear();\n  }\n};              \nstruct aho { \n  vector \u0026lt;node\u0026gt; t(1);\n  bool used[N];\n\n  void add (char *s) {\n    int v \u003d 0;\n    for (int i \u003d 0;s[i];i ++) {\n      int c \u003d s[i];\n      if (!t[v].nxt[c]) {\n        t[v].nxt[c] \u003d sz(t);\n        t.pb (node());\n      }\n      v \u003d t[v].nxt[c];\n    }               \n    t[v].end \u003d 1;\n  }      \n  void build_links () {\n    queue \u0026lt;int\u0026gt; q;\n    q.push (0);    \n    t[0].suff \u003d -1;\n    while (!q.empty()) {\n      int v \u003d q.front();\n      q.pop();  \n      for (auto e : t[v].nxt) {\n        int to \u003d e.S, c \u003d e.F;\n        if (to) {           \n          int j \u003d t[v].suff;\n          while (j !\u003d -1 \u0026amp;\u0026amp; !t[j].nxt.count (c)) \n            j \u003d t[j].suff;\n\n          if (j !\u003d -1)\n            t[to].suff \u003d t[j].nxt[c];\n          q.push (to);\n        }\n      }\n    }\n  }            \n  bool solve ( char *s) {\n    int v \u003d 0;\n    for (int i \u003d 0; s[i]; i++) {\n      int c \u003d s[i];      \n      int cur \u003d v;\n      while (cur \u0026gt; 0 \u0026amp;\u0026amp; !t[cur].nxt[c])\n        cur \u003d t[cur].suff;\n\n      if (t[cur].nxt.count (c))  \n        v \u003d t[cur].nxt[c];\n      else\n        v \u003d 0;\n    \tused[v] \u003d 1;\n    }\n    return relax (0); \n  }           \n  bool relax (int v) {   \n    for (auto to : g[v]) {\n  \tif (relax (to.S))\n  \t\treturn 1;\n  \t\n  \tif (used[to.S])\n   \t  used[v] \u003d 1;\n    }\t\n      if (used[v] \u0026amp;\u0026amp; t[v].end)\n        return 1;\n      else\n  \treturn 0;    \n   }\t\n};\n\n\n\n\n\n// Coded by Z...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}