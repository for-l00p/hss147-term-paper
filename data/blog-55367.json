{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1508796699,"rating":5,"authorHandle":"zscoder","modificationTimeSeconds":1508841445,"id":55367,"title":"\u003cp\u003eMath Challenge Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eProblem A\u003c/h3\u003e\u003cp\u003eConsider the subset \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e that is the answer to the problem. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e,  \u003ci\u003eb\u003c/i\u003e,  \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e be the arbitrary three elements from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and let no more than one of them is equal to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. By the pigeonhole principle two of three elements from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e,  \u003ci\u003eb\u003c/i\u003e,  \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e have the same parity. So we have two integers with even sum and only one of them can be equal to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, so their sum is also greater than \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e. So the subset \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e is not simple. In this way \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e consists of only two numbers greater than one (with a prime sum) or consists of some number of ones and also maybe other value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, so that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e  +  1\u003c/span\u003e is a prime.\u003c/p\u003e\u003cp\u003eThe rest is simple, since we can brute force all pairs of numbers in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e time for the first case and check the second case in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time. Use a prime sieve to be able to determine whether a number \u003cspan class\u003d\"tex-span\"\u003e ≤ 2·10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e is prime in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time.\u003c/p\u003e\u003cp\u003eTime Complexity : \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9a/0e/9a0ee853403d945e8d2bbab44649948468d05b2d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e + \u003ci\u003eM\u003c/i\u003e)\u003c/span\u003e if linear sieve is used, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e is the maximum number in the input.\u003c/p\u003e\u003ch3\u003eProblem B\u003c/h3\u003e\u003cp\u003eWe can view the string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e as a function of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is the initial number of clones before we start executing the instructions in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e. We claim that the function is linear, i.e. the function can be written in the form \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eax\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e for some constants \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e is empty, the function is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Npw, we update the function as we iterate through the characters of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eSuppose the current function is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d \u003ci\u003eax\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. If we encounter a command \u0027N\u0027, the function becomes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d \u003ci\u003eax\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e + 1\u003c/span\u003e. Otherwise, the function becomes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d 20000\u003ci\u003eax\u003c/i\u003e + 20000\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. Note that we perform operations modulo the given prime.\u003c/p\u003e\u003cp\u003eThus, in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003eS\u003c/i\u003e|)\u003c/span\u003e time, we can find the constants \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e such that if we start with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e Misakas, we\u0027ll end up with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAx\u003c/i\u003e + \u003ci\u003eB\u003c/i\u003e\u003c/span\u003e Misakas after one round of operations. It remains to apply this function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e times. \u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d \u003ci\u003eAx\u003c/i\u003e + \u003ci\u003eB\u003c/i\u003e\u003c/span\u003e. Thus, our task is to find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sup\u003e(1)\u003c/span\u003e. Suppose we found that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/8b/328b414c5171efe6cd07979da24cb106d4ef994d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Then, we can find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sup\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time by composing \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/8b/328b414c5171efe6cd07979da24cb106d4ef994d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e by itself. Also, we can derive \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sup\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eN\u003c/i\u003e - 1\u003c/sup\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e as well. Thus, we can derive \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sup\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e1\u003c/sup\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/66/6c/666cc239bd9595b8818555e063d8d8b69ad0cda0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time. The total complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3a/0d/3a0d24cca454b143783a9662070535fe62375b14.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eTime Complexity : \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3a/0d/3a0d24cca454b143783a9662070535fe62375b14.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003ch3\u003eProblem C\u003c/h3\u003e\u003cp\u003eLet\u0027s see what properties must a valid \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e have. Firstly, if Kotomi sees the same object on days \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, then \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/29/04/290429e79ebe16081c15956307a83818aa16fabe.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e must hold. Also, if Kotomi sees distinct objects on days \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e, then \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3b/fb/3bfb36b86ff4f1dd35df24afac7c98816d1b67c3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e must hold. On the other hand, if this property holds for each pair of days given in the statement, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e is a valid solution. Thus, we just have to find the smallest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e that satisfy the above property for all pairs of days.\u003c/p\u003e\u003cp\u003eEach condition can be written as either \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e must divide \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e must not divide \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e for some positive integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e. Iterate through all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e pairs of days and now our task reduces to finding the smallest integer that divides some integers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e but does not divide any of the integers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003en\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003en\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Firstly, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e divides \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e if and only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e divides their greatest common divisor \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e. Now, how do we handle the second type of conditions? \u003c/p\u003e\u003cp\u003eSuppose for each integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e we find all its divisors and mark them as bad. Then, our answer is just the smallest non-bad integer that divides \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e. Unfortunately, there can be \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e numbers and getting the list of divisors for each of them one by one might be too slow. Instead, consider an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebad\u003c/i\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebad\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d 1\u003c/span\u003e if the number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is bad and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebad\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d 0\u003c/span\u003e otherwise. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebad\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e] \u003d 1\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Now, for each integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e, we iterate through \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebad\u003c/i\u003e[\u003ci\u003ed\u003c/i\u003e], \u003ci\u003ebad\u003c/i\u003e[2\u003ci\u003ed\u003c/i\u003e], ..., \u003ci\u003ebad\u003c/i\u003e[\u003ci\u003ekd\u003c/i\u003e]\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is the maximum integer such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ekd\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e. If any of these values are \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, then we mark \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebad\u003c/i\u003e[\u003ci\u003ed\u003c/i\u003e]\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Clearly, after we iterate through all \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ed\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e, all bad integers will be marked. Thus, we can just loop through the integers \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e one by one later to find the minimum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e that is not bad and divides \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eThe complexity of marking the bad array is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9d/0a/9d0aad808e44705b7a31ac2093aa612f0bd44116.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eTime complexity : \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1a/0e/1a0e99f2607e3d49b369b97c35aa19f1ffef970b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e is the maximum day in the input.\u003c/p\u003e\u003ch3\u003eProblem D\u003c/h3\u003e\u003cp\u003eFirst, let\u0027s find a closed form expression for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e \u003d 1\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d \u003ci\u003ex\u003c/i\u003e + \u003ci\u003enb\u003c/i\u003e\u003c/span\u003e. Otherwise, we can prove by induction on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a3/37/a3375d27fbf55e3c4c48c6b9d363a9ba08ff699c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eFirstly, suppose we set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e \u003d 1\u003c/span\u003e, then we require \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ca/51/ca517c6a5f6052f7f33757af46079a5c84fb9ba0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, or \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6c/59/6c598f3325a2616b85287d7ea08d026140088d90.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. If \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/59/90/5990762ae77386ebf5f934c18e2f825e17a459b3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, then just take \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e \u003d (\u003ci\u003et\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e)\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e - 1\u003c/sup\u003e\u003c/span\u003e and we\u0027re done. If \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e9/0d/e90dba91dbfdcb8c2e1d32a6ff757bcd6c48649b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e we can also take \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e \u003d 0\u003c/span\u003e and we\u0027re done. Otherwise, there is no solution for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e \u003d 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow, we iterate through all \u003cspan class\u003d\"tex-span\"\u003e2 ≤ \u003ci\u003eA\u003c/i\u003e \u0026lt; \u003ci\u003eP\u003c/i\u003e\u003c/span\u003e and try to find if there exist a suitable \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e fast. For a fix \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e, we require \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/22/a5/22a52b7de377d7523e48240e7acc8dc67b234d1f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. If \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/fe/95/fe95baeac037a294c05d80c39f60597610471e9a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, then choose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e \u003d 0\u003c/span\u003e. Otherwise, if \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/34/7d/347dfca7aed62f851435de942a2d4495b904ae20.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, there is no solution here. Finally, if neither of these are true, then set \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8f/ee/8fee195b646cebb31b27f1bb324a2ebe5d1ae3f1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and we\u0027re done.\u003c/p\u003e\u003cp\u003eTime complexity : \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/78/a6/78a6bc215132a3492ec89f132e776acf7236ec98.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch3\u003eProblem E\u003c/h3\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e be the side length of the triangle. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u003d 16\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e. By Heron\u0027s Formula, \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e + \u003ci\u003ec\u003c/i\u003e)(\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e - \u003ci\u003ec\u003c/i\u003e)(\u003ci\u003ea\u003c/i\u003e + \u003ci\u003ec\u003c/i\u003e - \u003ci\u003eb\u003c/i\u003e)(\u003ci\u003eb\u003c/i\u003e + \u003ci\u003ec\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e) \u003d \u003ci\u003eS\u003c/i\u003e\u003c/span\u003e. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e - \u003ci\u003ec\u003c/i\u003e, \u003ci\u003eY\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e + \u003ci\u003ec\u003c/i\u003e - \u003ci\u003eb\u003c/i\u003e, \u003ci\u003eZ\u003c/i\u003e \u003d \u003ci\u003eb\u003c/i\u003e + \u003ci\u003ec\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. By triangle inequality, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e, \u003ci\u003eY\u003c/i\u003e, \u003ci\u003eZ\u003c/i\u003e \u0026gt; 0\u003c/span\u003e. Additionally, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e + \u003ci\u003eY\u003c/i\u003e \u003d 2\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eX\u003c/i\u003e + \u003ci\u003eZ\u003c/i\u003e \u003d 2\u003ci\u003eb\u003c/i\u003e, \u003ci\u003eY\u003c/i\u003e + \u003ci\u003eZ\u003c/i\u003e \u003d 2\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e so \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e, \u003ci\u003eY\u003c/i\u003e, \u003ci\u003eZ\u003c/i\u003e\u003c/span\u003e have the same parity. Also, since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e is even, at least one of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e, \u003ci\u003ez\u003c/i\u003e\u003c/span\u003e is even and thus all are even. Conversely, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e, \u003ci\u003eY\u003c/i\u003e, \u003ci\u003eZ\u003c/i\u003e\u003c/span\u003e are all even we can construct a valid solution \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e)\u003c/span\u003e. Thus, we just have to focus on the equation \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eXYZ\u003c/i\u003e(\u003ci\u003eX\u003c/i\u003e + \u003ci\u003eY\u003c/i\u003e + \u003ci\u003eZ\u003c/i\u003e) \u003d \u003ci\u003eS\u003c/i\u003e\u003c/span\u003e, or equivalently \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exyz\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e + \u003ci\u003ez\u003c/i\u003e) \u003d \u003ci\u003eX\u003c/i\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e, \u003ci\u003ez\u003c/i\u003e\u003c/span\u003e are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e, \u003ci\u003eY\u003c/i\u003e, \u003ci\u003eZ\u003c/i\u003e\u003c/span\u003e divided by \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e respectively. \u003c/p\u003e\u003cp\u003eOne way to solve this problem is to first find all the divisors of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/67/c6/67c6da75fd017e1954232d8e1ac391467d591756.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Now, WLOG \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e ≤ \u003ci\u003ey\u003c/i\u003e ≤ \u003ci\u003ez\u003c/i\u003e\u003c/span\u003e. Then, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e3/29/e3296046f5ddb270327b2693f775eb665f74b95b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. For a fixed pair \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e, we can determine \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e using the quadratic formula and check whether we have an integer. Since the highly composite less than \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e15\u003c/sup\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e866421317361600\u003c/span\u003e which has \u003cspan class\u003d\"tex-span\"\u003e26880\u003c/span\u003e divisors. Since we\u0027re only checking the divisors \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/18/59/185911d20af504bb05af049d1a9b1be9339de2c5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, there are practically much less values to check. This solution will pass the time limit.\u003c/p\u003e\u003cp\u003eTime Complexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ed\u003c/i\u003e(\u003ci\u003eX\u003c/i\u003e)\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003eProblem F\u003c/h3\u003e\u003cp\u003eWhich numbers can be written as sum of two squares. It is a well-known fact a number can be written as the sum of two squares if and only if the prime power of each prime of the form \u003cspan class\u003d\"tex-span\"\u003e4\u003ci\u003ek\u003c/i\u003e + 3\u003c/span\u003e in the prime factorization of the number is even.\u003c/p\u003e\u003cp\u003eThus, if we store for each number the prime factors of the form \u003cspan class\u003d\"tex-span\"\u003e4\u003ci\u003ek\u003c/i\u003e + 3\u003c/span\u003e that occurs odd number of times and the exponent of \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e in the number, then we can find out whether \u003cspan class\u003d\"tex-span\"\u003e3\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is good in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/dd/3b/dd3b355c797ca8774375eb45fe047d61d88d1a47.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time.\u003c/p\u003e\u003cp\u003eConsider a graph where the vertices are the elements of the set and two vertices are connected if and only if \u003cspan class\u003d\"tex-span\"\u003e3\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e can be written as the sum of two squares. Then, our task is to find the maximum independent set of this graph.\u003c/p\u003e\u003cp\u003eThe key is to note that the graph is bipartite. If there is an edge between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, then the power of \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e in their prime factorizations must have different parities, otherwise \u003cspan class\u003d\"tex-span\"\u003e3\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e cannot be the sum of two squares. Thus, we can split the vertices into two groups, one group containing the numbers with odd exponent of \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e and one group containing numbers with even exponent of \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e. In a bipartite graph, the size of the maximum matching is equal to the size of the minimum vertex cover, which is the complement of a maximum independent set. Thus, we just need to find a maximum matching and derive the minimum vertex cover from it then take the complement. See \u003ca\u003ehttps://en.wikipedia.org/wiki/K%C5%91nig%27s_theorem_(graph_theory)#Proof\u003c/a\u003e for the algorithm.\u003c/p\u003e\u003cp\u003eWe can use Hopcroft-Karp algorithm or Dinic\u0027s algorithm (max flow) to find the maximum matching in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0b/e70b2987ffe2dcbb752c4f0458e814715a782be3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e or \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5e/69/5e6984805af8049266d53b333d0b3658120e0fa3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eTime Complexity : \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ab/c2/abc208daf382756202ecc037c7b583411ac424f5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch3\u003eProblem G\u003c/h3\u003e\u003cp\u003eTo solve the problem, we obviously need to solve the version given to the kindergarten kids first. Let\u0027s analyze what the sum of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0c/5e/0c5e4d82f3e98a211914ad5938049325601dcef4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is.\u003c/p\u003e\u003cp\u003eThe sum looks totally arbitary. Let\u0027s look at the sum from a combinatorial point of view. What does the sum actually count? \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4d/62/4d62b473ad611771f144fd266e9283fd6db3aa43.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Does this term look familiar? We know that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/df/0a/df0a251d78a59811d2a8f9ba71c3bb76f13b2725.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e counts the number of words of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e which contains \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e occurences of the letter \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Also, since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003en\u003c/i\u003e\u003c/span\u003e, the term we\u0027re calculating is just \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/73/b3/73b33cf8ab49cf1636670e45695ff2ae22661bae.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Thus, now we know what the term \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/73/b3/73b33cf8ab49cf1636670e45695ff2ae22661bae.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e means.\u003c/p\u003e\u003cp\u003eNow, what is the meaning of the sum of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/73/b3/73b33cf8ab49cf1636670e45695ff2ae22661bae.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e over all ordered tuples of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e nonnegative integers that sum up to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. We can view the elements of the tuples as the desired frequency of each character in the word. Thus, the sum of all these fractions is simply the number of words of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e where there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e possibilities for each letter. However, the number of such words is exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. Thus, we have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/21/2d/212dc3236a628f9312a8c1e7e577098210e7e0be.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e or \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a6/a7/a6a7f28e533bd40a945831a78cf193414397af54.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e + 3\u003c/span\u003e for brevity.\u003c/p\u003e\u003cp\u003eThus, our task is to find tuples \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e such that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6c/46/6c468178b24fa2811a81da268b61af083f2bd9ec.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, or equivalently \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f8/bf/f8bf7e31047140f4f776a8ce4cf7e9b471c38b41.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eLet\u0027s iterate through all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and find a valid \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. The right hand side is fixed, so we just have to solve the congruence \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9f/0e/9f0eff19ed715be51b9b5f347b68973e00a0ce40.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. To find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, we need to take the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e-th root of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e. First, let\u0027s find the primitive root modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e. (one must exist since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e is a prime) This can be done by brute forcing all the integers from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e - 1\u003c/span\u003e, and check for each integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003c/span\u003e whether \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3e/7f/3e7f3285f0b234f3c903807710b3a492162e534d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for some \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8a/54/8a5475624de04fb4063279c6431bd22dc94086ca.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. (we only need to check the divisors of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e - 1\u003c/span\u003e because \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d6/f4/d6f4aa231495da302cd33d2e8ae4737a560d191e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e by Fermat\u0027s Little Theorem and thus the order of multiplicity of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003c/span\u003e modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e divides \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e - 1\u003c/span\u003e.) In the worse case, it will take \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/55/7e/557eee8944d665eb596e71e4cbbf022b5db06816.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time to find the primitive root but in practice, it is extremely fast because we\u0027ll find a primitive root after a small number of tries.\u003c/p\u003e\u003cp\u003eNow that we have the primitive root, for each integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e be such that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c4/d0/c4d0a16c6ac54fbd2c9bb9d7cae19341f56c36e4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Thus, the given congruence can be transformed to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e8/19/e819faf4689e8a798bad6eaf7ff380843af14d79.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, which is equivalent to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/95/67/9567cd8b2a69bc6ec30801898a048eaf62cffc66.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Now, if we only decide to find the answer for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e which is coprime to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e - 1\u003c/span\u003e, we can take \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/59/d5/59d522872d87d4a82c91881c84d04ff016a97ffb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and get \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e from here. It turns out that we have enough solutions even if we only consider \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e coprime to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e - 1\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003eφ(1000006) \u003d 333332 \u0026gt; 300000\u003c/span\u003e. Thus, we\u0027re done.\u003c/p\u003e\u003cp\u003eThere\u0027s a much simpler way to find the desired \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Again, we only consider those \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e that are coprime to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e - 1\u003c/span\u003e. Then, we just have to take \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/90/68/90682d01537e74e48d8e48c1f9ff0da9368fd3d2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for each such \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTime Complexity : \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/13/10/1310a4f1ece6330311a4670483e15609f279bea2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003ch3\u003eProblem H\u003c/h3\u003e\u003cp\u003eView the tournament as a Markov Chain, where the states are Ash\u0027s possible ratings, including \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e + 1\u003c/span\u003e for convenience. Note that it is in fact an absorbing Markov Chain, where \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e + 1\u003c/span\u003e are the absorbing states while the rest are transient states. From state \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, there is probability \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c9/6f/c96f048a407379188953386da1a44ad52384df0a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e of going to state \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e - \u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, 0)\u003c/span\u003e and probability \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9d/bd/9dbd8a06fd71391020f60678a46f427f28b32c92.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e of going to state \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e + \u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eN\u003c/i\u003e + 1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThus, the solution is simple. We can just construct the fundamental matrix and find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e \u003d (\u003ci\u003eI\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003eQ\u003c/i\u003e)\u003csup class\u003d\"upper-index\"\u003e - 1\u003c/sup\u003e\u003c/span\u003e using Gaussian Elimination. After that, the solution can be read from the matrix \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e \u003d \u003ci\u003eNR\u003c/i\u003e\u003c/span\u003e. Note that all calculations should be done in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a4/83/a483ee0a4db655e2fe2d011e64637e4962339168.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e \u003d 998244353\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSee \u003ca href\u003d\"https://en.wikipedia.org/wiki/Absorbing_Markov_chain\"\u003ethis\u003c/a\u003e for an explanation of Absorbing Markov Chain.\u003c/p\u003e\u003cp\u003eTime Complexity : \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/12/85/1285e585a0b831d142743bb726d976a6f292d64a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003ch3\u003eProblem I\u003c/h3\u003e\u003cp\u003eFirstly, let\u0027s see when are two songs \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e equivalent. Obviously, the total number of ones in the song must be invariant. However, the operation has another invariant. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the position of ones in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the position of ones in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e. It turns out that the operation preserves the invariant \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Indeed, it selects two numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e and replaces it with either \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - 1, \u003ci\u003ey\u003c/i\u003e + 1\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + 1, \u003ci\u003ey\u003c/i\u003e - 1\u003c/span\u003e, so the sum never changes. Conversely, it is possible to obtain \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e and vice versa if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. We can prove this by induction on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, where the base case is trivial and the inductive step is to move the larger element of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e towards the other while increasing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e) when doing so. Then, we can ignore \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and induct down. (Note that this proof only works when the song is infinite, but it is easy to prove the same fact if the song is finite)\u003c/p\u003e\u003cp\u003eFrom now on, let\u0027s denote a song by the position of its ones. Thus, we know that two songs \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e are equivalent if and only if they have equal number of ones and the sum of the positions of ones in each of them is equal.\u003c/p\u003e\u003cp\u003eNext, we turn back to the original problem : Compute the number of songs equivalent to a given song \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u003d (\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e. (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e denote the positions of ones in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e)\u003c/p\u003e\u003cp\u003eNote that if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d 0\u003c/span\u003e, then the answer is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. So, assume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u0026gt; 0\u003c/span\u003e. Note that the only info that matters is the sum of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, so let\u0027s denote our problem as a pair of integers \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003esum\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e\u003c/span\u003e is the sum of all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eOur task is to find the number of tuples \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e with sum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u0026lt; \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u0026lt; ... \u0026lt; \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFirst, let\u0027s look at the naive solution. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003esum\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e be the number of solutions for \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003esum\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e, such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. We can iterate through all possible next numbers from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e until the sum exceeds the limit. Obviously, this solution is way too slow.\u003c/p\u003e\u003cp\u003eOne big problem is that the variables \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e are dependent, i.e. they need to be sorted in strictly increasing order. Is it possible to make them independent? Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Then, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Thus, our conditions become \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≥ 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ekd\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + (\u003ci\u003ek\u003c/i\u003e - 1)\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003esum\u003c/i\u003e\u003c/span\u003e. A valid solution to \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e corresponds to a valid solution to the original problem. Subtract d_{i} by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and reverse the array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Thus, our task reduces to finding the number of nonnegative integer solutions to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5a/5b/5a5b3b59dbe24c329e53dc0b7255d9fe1c8ccd75.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. For brevity, let \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/45/8e/458e128f736aa4e4dd7b1afe26936c492b3d3fed.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eWhat does the curious constraints that the song is created by swapping adjacent elements of some song \u003cspan class\u003d\"tex-span\"\u003e1111....100....\u003c/span\u003e at most \u003cspan class\u003d\"tex-span\"\u003e200000\u003c/span\u003e times mean? The minimum number of adjacent swaps needed to create a song \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b1/58/b1589ab2eb3ee945674760be995d0dccf0c3bdde.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Thus, translating to our notation above, this simply means that we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e ≤ 200000\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow, let\u0027s try a direct dp solution. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e denotes the number of ways to choose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + 2\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003eid\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. Then, we just have to iterate through all possible values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e. You can prove that this solution works in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/09/7e/097ee792656fa96ce694f41a4757baa31cc62ef5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time, which is too slow.\u003c/p\u003e\u003cp\u003eWe can optimize this solution. Let\u0027s interpret the sum as the sum of a set of elements \u003cspan class\u003d\"tex-span\"\u003e{1, 1, ..., 1, 2, 2, ..., 2, 3, ..., 3, ..., \u003ci\u003ek\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e, ..., \u003ci\u003ek\u003c/i\u003e}\u003c/span\u003e, where the element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e appears \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e times. Now, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e denotes the number of ways to choose the set so that the largest element is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e and the sum is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Now, state transitions can be done in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time and we have an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ekS\u003c/i\u003e)\u003c/span\u003e solution. Sadly, when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d \u003ci\u003eS\u003c/i\u003e \u003d 200000\u003c/span\u003e, this solution is still too slow.\u003c/p\u003e\u003cp\u003eNow, let\u0027s bring out the big guns. We\u0027ll employ generating functions here.\u003c/p\u003e\u003cp\u003eThe generating function is :\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a6/41/a6411747578b1210728996bb1e10e92326653776.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003c/p\u003e\u003cp\u003eHere \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eln\u003c/i\u003e\u003c/span\u003e denotes the natural logarithm function and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eexp\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e))\u003c/span\u003e denotes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/sup\u003e\u003c/span\u003e. Some of the equalities above are from the Maclaurin series (see \u003ca href\u003d\"https://en.wikipedia.org/wiki/Taylor_series#List_of_Maclaurin_series_of_some_common_functions\"\u003ehttps://en.wikipedia.org/wiki/Taylor_series#List_of_Maclaurin_series_of_some_common_functions\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eNote that we only need terms with degree \u003cspan class\u003d\"tex-span\"\u003e ≤ \u003ci\u003eS\u003c/i\u003e\u003c/span\u003e, thus there are at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6b/de/6bdec557781c40ca6c3779ac9470760c128dd350.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e terms to consider for the polynomial inside the last \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eexp\u003c/i\u003e\u003c/span\u003e. Grouping like terms together leaves us with a degree-\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e polynomial \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e and our task is to find the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e + 1\u003c/span\u003e terms of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eexp\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e))\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eWe\u0027ll demonstrate how to calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eexp\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e))\u003c/span\u003e in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/07/06/0706b1e0812d319bc1e5623f21788be3baced80d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time, and thus our answer can be obtained in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/07/06/0706b1e0812d319bc1e5623f21788be3baced80d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time in total.\u003c/p\u003e\u003cp\u003eFirst, we can do multiplication of polynomials in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5d/1f/5d1f29f648247e77966a5b1703590aea2a6a75b6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e with NTT (Number Theoretic Transform) as \u003cspan class\u003d\"tex-span\"\u003e998244353 \u003d 2\u003csup class\u003d\"upper-index\"\u003e23\u003c/sup\u003e·7·17\u003c/span\u003e and thus we can find a primitive \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e23\u003c/sup\u003e\u003c/span\u003e root of unity to replace the root of unity in our usual FFT. (see \u003ca\u003ehttps://en.wikipedia.org/wiki/Discrete_Fourier_transform_(general)#Number-theoretic_transform\u003c/a\u003e for how to obtain this root of unity. It turns out that \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e is a primitive root modulo \u003cspan class\u003d\"tex-span\"\u003e998244353\u003c/span\u003e.)\u003c/p\u003e\u003cp\u003eNow, let\u0027s go one step further and calculate the inverse of a polynomial modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e \u003d 998244353\u003c/span\u003e. Let the inverse be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e. First, we find the constant term of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e by just taking the inverse of the constant term of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e. Now, suppose we have the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e terms of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e, i.e.\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/93/d4/93d4c6c6c12b6ebc84260f9dcc6d19a7781711e6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eThen, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7f/1a/7f1a047a70cc5f96051122a4cba2d73f5ab3fb1e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, or \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ef/ec/efeca5a8fdfe27d2e5d19ee3d25a36027ba0d73d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Thus, we can replace \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003eB\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) - \u003ci\u003eB\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e to get the first \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003en\u003c/i\u003e\u003c/span\u003e terms of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e. Repeating this \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c0/f4/c0f44c41ead5dd2ff655011e4c85cf528b73750a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e times, we\u0027ll get the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e terms of the inverse. You can prove that the complexity of the algorithm is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5d/1f/5d1f29f648247e77966a5b1703590aea2a6a75b6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where you need to calculate the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e terms of the inverse of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNext step is to calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eln\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e))\u003c/span\u003e. Fortunately, this is much easier provided that we know how to calculate \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3a/8a/3a8a9a30de1f9484d837a56d29f93bb414a0589b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d \u003ci\u003eln\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e))\u003c/span\u003e, then by Chain Rule,\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/ee/7cee9655c643829148b4ae196ae0ac3043384608.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eWe can find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u0027(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3a/8a/3a8a9a30de1f9484d837a56d29f93bb414a0589b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5d/1f/5d1f29f648247e77966a5b1703590aea2a6a75b6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time. Multiplying these polynomials take another \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5d/1f/5d1f29f648247e77966a5b1703590aea2a6a75b6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time. Finally, integrate the result in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time. \u003c/p\u003e\u003cp\u003eFinally, let\u0027s calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eexp\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e))\u003c/span\u003e. We\u0027ll use a method similar to Newton\u0027s method of finding roots of polynomials.\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d \u003ci\u003ee\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/sup\u003e\u003c/span\u003e, and let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003c/span\u003e be a function such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)) \u003d 0 \u003d \u003ci\u003eln\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)) - \u003ci\u003eA\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFirstly, we can compute the constant term of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e by using the Maclaurin series. Suppose we know the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e terms of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e, call it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e, thus \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d5/d0/d5d08c1433517aebe2e9ad79684ffbacf1544cb0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eBy Taylor\u0027s expansion,\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5c/57/5c57fa5953675c050e85f17c6241cdb433c7524f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eHere \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e(2)\u003c/sup\u003e\u003c/span\u003e denotes the second differential of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThus, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/26/d7/26d7c81cd18bb3b649f7ee269b0ce64dc7d5d263.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e,\u003c/p\u003e\u003cp\u003eSubstituting \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e(\u003ci\u003ex\u003c/i\u003e)) \u003d \u003ci\u003eln\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e(\u003ci\u003ex\u003c/i\u003e)) - \u003ci\u003eA\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e, we get \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/39/e1/39e18c3b5eaf747c3d3fda56e778f2105f17029d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003c/p\u003e\u003cp\u003eThus, it is sufficient to compute the last term to get the first \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003en\u003c/i\u003e\u003c/span\u003e terms of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e. Similar to finding the inverse, we can prove that this works in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5d/1f/5d1f29f648247e77966a5b1703590aea2a6a75b6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time.\u003c/p\u003e\u003cp\u003eTherefore, the generating function can be computed in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/07/06/0706b1e0812d319bc1e5623f21788be3baced80d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time and we just have to find the coefficient of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTime Complexity : \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/07/06/0706b1e0812d319bc1e5623f21788be3baced80d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e is the number of swaps made to the initial string.\u003c/p\u003e\u003cp\u003eCodes :\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem A\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nint a[1111];\nint prime[2000011];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tfor(int i\u003d2;i\u0026lt;\u003d2000000;i++) prime[i]\u003d1;\n\tfor(int i\u003d2;i\u0026lt;\u003d2000000;i++)\n\t{\n\t\tif(prime[i])\n\t\t{\n\t\t\tfor(int j\u003d2*i;j\u0026lt;\u003d2000000;j+\u003di) prime[j]\u003d0;\n\t\t}\n\t}\n\tint n; cin\u0026gt;\u0026gt;n;\n\tint cntone\u003d0;\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tcin\u0026gt;\u0026gt;a[i];\n\t\tif(a[i]\u003d\u003d1) cntone++;\n\t}\n\tint ans1\u003d1;\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tfor(int j\u003di+1;j\u0026lt;n;j++)\n\t\t{\n\t\t\tif(prime[a[i]+a[j]]) ans1\u003d2;\n\t\t}\n\t}\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tif(a[i]!\u003d1\u0026amp;\u0026amp;prime[a[i]+1]){cntone++; break;}\n\t}\n\tcout\u0026lt;\u0026lt;max(cntone,ans1)\u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem B\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int MOD \u003d 998244353;\n\nll add(ll a, ll b)\n{\n\ta\u003d(a+b)%MOD;\n\tif(a\u0026lt;0) a+\u003dMOD;\n\treturn a;\n}\n\nll mult(ll a, ll b)\n{\n\ta%\u003dMOD; b%\u003dMOD;\n\tll ans\u003d(a*b)%MOD;\n\tif(ans\u0026lt;0) ans+\u003dMOD;\n\treturn ans;\n}\n\nconst ll A \u003d 20000;\nconst ll B \u003d 1;\n\npair\u0026lt;ll,ll\u0026gt; func(pair\u0026lt;ll,ll\u0026gt; a, ll n)\n{\n\tif(n\u003d\u003d0) return mp(0,1);\n\tif(n\u003d\u003d1) return a;\n\tpair\u0026lt;ll,ll\u0026gt; hf \u003d func(a,n/2);\n\tpair\u0026lt;ll,ll\u0026gt; ans;\n\tans.fi\u003dmult(hf.fi,hf.fi);\n\tans.se\u003dadd(mult(hf.fi,hf.se),hf.se);\n\tif(n\u0026amp;1)\n\t{\n\t\tpair\u0026lt;ll,ll\u0026gt; res;\n\t\tres.fi\u003dmult(ans.fi,a.fi);\n\t\tres.se\u003dadd(mult(ans.fi,a.se),ans.se);\n\t\treturn res;\n\t}\n\telse return ans;\n}\n\nll fast(string \u0026amp;s, ll n)\n{\n\tll a \u003d 1; ll b \u003d 0;\n\tfor(int i\u003d0;i\u0026lt;s.length();i++)\n\t{\n\t\tif(s[i]\u003d\u003d\u0027C\u0027)\n\t\t{\n\t\t\ta\u003dmult(a,A);\n\t\t\tb\u003dmult(b,A);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb\u003dadd(b,1);\n\t\t}\n\t}\n\tpair\u0026lt;ll,ll\u0026gt; tmp \u003d func(mp(a,b),n);\n\treturn add(tmp.fi,tmp.se);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tstring s; cin\u0026gt;\u0026gt;s; ll n; cin\u0026gt;\u0026gt;n;\n\tcout\u0026lt;\u0026lt;fast(s,n)\u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem C\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int MAXN \u003d 1000011;\n\nint cnt[MAXN];\nint d[5011];\nint c[5011];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin\u0026gt;\u0026gt;n;\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tcin\u0026gt;\u0026gt;d[i]\u0026gt;\u0026gt;c[i];\n\t}\n\tint g\u003d0;\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tfor(int j\u003di+1;j\u0026lt;n;j++)\n\t\t{\n\t\t\tif(c[i]!\u003dc[j]) cnt[abs(d[i]-d[j])]\u003d1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(g\u003d\u003d0) g\u003dabs(d[i]-d[j]);\n\t\t\t\telse g\u003d__gcd(g,abs(d[i]-d[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i\u003d1;i\u0026lt;\u003d1000001;i++)\n\t{\n\t\tfor(int j\u003di;j\u0026lt;\u003d1000001;j+\u003di)\n\t\t{\n\t\t\tif(cnt[j])\n\t\t\t{\n\t\t\t\tcnt[i]\u003d1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i\u003d1;i\u0026lt;\u003d1000001;i++)\n\t{\n\t\tif(!cnt[i]\u0026amp;\u0026amp;(g\u003d\u003d0||(g%i\u003d\u003d0)))\n\t\t{\n\t\t\tcout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem D\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nll power(ll a, ll b, ll p)\n{\n\tll r\u003d1;\n\twhile(b)\n\t{\n\t\tif(b\u0026amp;1) r\u003d(r*a)%p;\n\t\ta\u003d(a*a)%p;\n\t\tb\u0026gt;\u0026gt;\u003d1;\n\t}\n\treturn r;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll x, n, t, p;\n\tcin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; n \u0026gt;\u0026gt; t \u0026gt;\u0026gt; p;\n\tif((t-x)%p \u003d\u003d 0)\n\t{\n\t\tcout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; 0;\n\t\treturn 0;\n\t}\n\tif(n % p !\u003d 0)\n\t{\n\t\tn %\u003d p;\n\t\tif(n \u0026lt; 0) n +\u003d p;\n\t\tll b \u003d power(n, p - 2, p);\n\t\tll c \u003d (t-x)%p;\n\t\tif(c \u0026lt; 0) c +\u003d p;\n\t\tb \u003d (b * c)%p;\n\t\tif(b \u0026lt; 0) b +\u003d p;\n\t\tcout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; b;\n\t}\n\telse\n\t{\n\t\tll tmp, tmp2;\n\t\tfor(ll a \u003d 2; a \u0026lt;\u003d p - 1; a++)\n\t\t{\n\t\t\ttmp \u003d power(a,n,p) - 1;\n\t\t\ttmp \u003d (tmp * power(a-1,p-2,p))%p;\n\t\t\ttmp2 \u003d (t - power(a,n,p)*x)%p;\n\t\t\tif(tmp2 \u0026lt; 0) tmp2 +\u003d p;\n\t\t\tif(tmp \u0026lt; 0) tmp +\u003d p;\n\t\t\tif(tmp2 \u003d\u003d 0)\n\t\t\t{\n\t\t\t\tcout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(tmp !\u003d 0)\n\t\t\t\t{\n\t\t\t\t\ttmp2 \u003d (tmp2 * power(tmp, p-2, p))%p;\n\t\t\t\t\tif(tmp2 \u0026lt; 0) tmp2 +\u003d p;\n\t\t\t\t\tcout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; tmp2;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout \u0026lt;\u0026lt; -1;\n\t}\n\treturn 0;\n}\n\t\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem E\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nll srt(ll a)\n{\n    ll tmp\u003dsqrt(a);\n    for(ll i\u003dtmp-2;i\u0026lt;\u003dtmp+2;i++)\n    {\n        if(i\u0026gt;\u003d0\u0026amp;\u0026amp;i*i\u003d\u003da) return i;\n    }\n    return -1;\n}\nll solve(ll b, ll c)\n{\n\tll disc \u003d b*b + 4*c; ll S \u003d srt(disc);\n\tif(S\u0026gt;\u003d0)\n\t{\n\t\tll ans \u003d -b + S;\n\t\tif(ans % 2 !\u003d 0)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn ans/2;\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn -1;\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tvector\u0026lt;ll\u0026gt; divisors;\n\tll x;\n\tcin \u0026gt;\u0026gt; x;\n\t\n\tll a, b;\n\t\n\tfor(ll i \u003d 1; i*i \u0026lt;\u003d x; i++)\n\t{\n\t\tif(x % i \u003d\u003d 0)\n\t\t{\n\t\t\tdivisors.push_back(i);\n\t\t}\n\t}\n\tll xtmp, root;\n\tfor(int i \u003d 0; divisors[i]\u0026lt;\u003d10000\u0026amp;\u0026amp;divisors[i]*divisors[i]*divisors[i]*divisors[i] \u0026lt;\u003d x; i++)\n\t{\n\t\tfor(int j \u003d i;j \u0026lt; divisors.size()\u0026amp;\u0026amp;divisors[j]\u0026lt;\u003d100000\u0026amp;\u0026amp;divisors[j]*divisors[j]*divisors[j]\u0026lt;\u003dx; j++)\n\t\t{\n\t\t\txtmp \u003d x;\n\t\t\ta \u003d divisors[i];\n\t\t\tb \u003d divisors[j];\n\t\t\txtmp /\u003d b;\n\t\t\tif(xtmp % a \u003d\u003d 0)\n\t\t\t{\n\t\t\t\txtmp /\u003d a;\n\t\t\t\troot \u003d solve(a + b, xtmp);\n\t\t\t\tif(root \u0026gt;\u003d b \u0026amp;\u0026amp; xtmp % root \u003d\u003d 0)\n\t\t\t\t{\n\t\t\t\t\txtmp /\u003d root;\n\t\t\t\t\tif(xtmp \u003d\u003d a + b + root)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout \u0026lt;\u0026lt;a+b \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; a+root \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; b+root \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem F\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nint a[2001];\nvector\u0026lt;ll\u0026gt; primes;\nbool prime[500001];\nvector\u0026lt;int\u0026gt; adj[2001];\nint match[2001];\nbool mark[2001];\nvector\u0026lt;int\u0026gt; factors[2001];\nvi directed[2001];\nint color[2001];\nbool adjmatrix[2001][2001];\nbool visited[2001];\n\nvoid Sieve(int n)\n{\n\tmemset(prime, true, sizeof(prime));\n\tprime[1] \u003d false;\n\tfor(int i \u003d 2; i \u0026lt;\u003d n; i++)\n\t{\n\t\tif(prime[i])\n\t\t{\n\t\t\tprimes.pb(i);\n\t\t\tfor(int j \u003d 2*i; j \u0026lt;\u003d n; j +\u003d i)\n\t\t\t{\n\t\t\t\tprime[j] \u003d false;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool sos(int a, int b)\n{\n    return (factors[a]\u003d\u003dfactors[b]\u0026amp;\u0026amp;(color[a]!\u003dcolor[b]));\n}\n\nvector\u0026lt;int\u0026gt; ans;\n\nconst int MX \u003d 1111;\nconst int INF \u003d int(1e9);\nstruct MaxFlow \n{\n\tstruct edge\n\t{\n\t\tint to,cap,rev;\n\t\tedge(int to\u003d0,int cap\u003d0,int rev\u003d0):to(to),cap(cap),rev(rev){}\n\t};\n\tvector \u0026lt;edge\u0026gt; vec[MX];\n\tint level[MX];\n\tint iter[MX];\n\t\n\tvoid addedge(int s,int t,int c) //adds an edge of cap c to the flow graph\n\t{\n\t\tint S\u003dvec[s].size(),T\u003dvec[t].size();\n\t\tvec[s].push_back(edge(t,c,T));\n\t\tvec[t].push_back(edge(s,0,S));\n\t}\n\tvoid bfs(int s)\n\t{\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue \u0026lt;int\u0026gt; que;\n\t\tlevel[s] \u003d 0;\n\t\tque.push(s);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint v \u003d que.front();que.pop();\n\t\t\tfor(int i\u003d0;i\u0026lt;vec[v].size();i++)\n\t\t\t{\n\t\t\t\tedge\u0026amp;e\u003dvec[v][i];\n\t\t\t\tif (e.cap\u0026gt;0\u0026amp;\u0026amp;level[e.to]\u0026lt;0)\n\t\t\t\t{\n\t\t\t\t\tlevel[e.to]\u003dlevel[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll flow_dfs(int v,int t,ll f)\n\t{\n\t\tif (v\u003d\u003dt) return f;\n\t\tfor(int \u0026amp;i\u003diter[v];i\u0026lt;vec[v].size();i++)\n\t\t{\n\t\t\tedge \u0026amp;e\u003dvec[v][i];\n\t\t\tif (e.cap\u0026gt;0\u0026amp;\u0026amp;level[v]\u0026lt;level[e.to])\n\t\t\t{\n\t\t\t\tll d\u003dflow_dfs(e.to,t,min(f,ll(e.cap)));\n\t\t\t\tif (d\u0026gt;0)\n\t\t\t\t{\n\t\t\t\t\te.cap-\u003dd;\n\t\t\t\t\tvec[e.to][e.rev].cap+\u003dd;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tll maxflow(int s,int t) //finds max flow using dinic from s to t\n\t{\n\t\tll flow \u003d 0;\n\t\twhile(1)\n\t\t{\n\t\t\tbfs(s);\n\t\t\tif (level[t]\u0026lt;0) return flow;\n\t\t\tmemset(iter,0,sizeof(iter));\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tll f\u003dflow_dfs(s,t,INF);\n\t\t\t\tif(f\u003d\u003d0) break;\n\t\t\t\tflow +\u003d f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nvoid dfs2(int v)\n{\n    if(visited[v]) return;\n    visited[v] \u003d true;\n    for (int i \u003d 0; i \u0026lt; (int)directed[v].size(); i++)\n    {\n        int to \u003d directed[v][i];\n\t\tdfs2(to);\n    }\n}\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tSieve(500000);\n\tint n;\n\tcin \u0026gt;\u0026gt; n;\n\tint tmp; int cnt;\n\tfor(int i \u003d 0; i \u0026lt; n; i++) \n\t{\n\t\tcin \u0026gt;\u0026gt; a[i];\n\t\ttmp \u003d a[i];\n\t\tcnt \u003d 0;\n\t\twhile(tmp % 3 \u003d\u003d 0 \u0026amp;\u0026amp; tmp)\n\t\t{\n\t\t\ttmp /\u003d 3;\n\t\t\tcnt++;\n\t\t}\n\t\tif(cnt % 2) color[i] \u003d 2;\n\t\telse color[i] \u003d 1;\n\t\tfor(int j \u003d 0; primes[j]*primes[j]\u0026lt;\u003dtmp; j++)\n\t    {\n\t        int ct\u003d0;\n\t        while(tmp%primes[j]\u003d\u003d0)\n\t        {\n\t            tmp/\u003dprimes[j];\n\t            ct++;\n\t        }\n\t        if((ct\u0026amp;1)\u0026amp;\u0026amp;primes[j]%4\u003d\u003d3) factors[i].pb(primes[j]);\n\t    }\n\t    if(tmp\u0026gt;0\u0026amp;\u0026amp;tmp%4\u003d\u003d3) factors[i].pb(tmp);\n\t}\n\tfor(int i\u003d0;i\u0026lt;n;i++) \n\t{\n\t    sort(factors[i].begin(),factors[i].end());\n\t}\n\tMaxFlow mf;\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tfor(int j \u003d i+1; j \u0026lt; n; j++)\n\t\t{\n\t\t\tif(sos(i,j))\n\t\t\t{\n\t\t\t\tadjmatrix[i][j] \u003d true;\n\t\t\t\tadjmatrix[j][i] \u003d true;\n\t\t\t\tadj[i].pb(j);\n\t\t\t\tadj[j].pb(i);\n\t\t\t\tassert(color[i]!\u003dcolor[j]);\n\t\t\t\tif(color[i]\u003d\u003d1) mf.addedge(i,j,1);\n\t\t\t\telse mf.addedge(j,i,1);\n\t\t\t}\n\t\t}\n\t}\n\tint s\u003dMX-2; int e\u003dMX-1;\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tif(color[i]\u003d\u003d1)\n\t\t{\n\t\t\tmf.addedge(s,i,1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmf.addedge(i,e,1);\n\t\t}\n\t}\n\tmf.maxflow(s,e);\n\tmemset(match,-1,sizeof(match));\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tif(color[i]\u003d\u003d1)\n\t\t{\n\t\t\tfor(int j\u003d0;j\u0026lt;mf.vec[i].size();j++)\n\t\t\t{\n\t\t\t\tif(mf.vec[i][j].cap\u003d\u003d0)\n\t\t\t\t{\n\t\t\t\t\tint v\u003dmf.vec[i][j].to;\n\t\t\t\t\tif(v\u0026gt;\u003dn) continue;\n\t\t\t\t\tmatch[i]\u003dv; match[v]\u003di;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tfor(int j \u003d i + 1; j \u0026lt; n; j++)\n\t\t{\n\t\t\tif(adjmatrix[i][j])\n\t\t\t{\n\t\t\t\tif(match[i] \u003d\u003d j)\n\t\t\t\t{\n\t\t\t\t\tif(color[i] \u003d\u003d 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdirected[j].pb(i);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdirected[i].pb(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(color[i] \u003d\u003d 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdirected[i].pb(j);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdirected[j].pb(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tif(color[i] \u003d\u003d 1 \u0026amp;\u0026amp; match[i] \u003d\u003d -1)\n\t\t{\n\t\t\tdfs2(i);\n\t\t}\n\t}\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tif(visited[i] \u0026amp;\u0026amp; color[i] \u003d\u003d 1)\n\t\t{\n\t\t\tans.pb(a[i]);\n\t\t}\n\t\tif(!visited[i] \u0026amp;\u0026amp; color[i] \u003d\u003d 2)\n\t\t{\n\t\t\tans.pb(a[i]);\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; \u0027\\n\u0027;\n\tfor(int i \u003d 0; i \u0026lt; int(ans.size()); i++)\n\t{\n\t\tcout \u0026lt;\u0026lt; ans[i];\n\t\tif(i+1\u0026lt;ans.size()) cout \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n\t}\n\tcout \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem G\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;ll\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int MOD \u003d 1e6 + 3;\nint g;\n\nll modpow(ll a, ll b, ll mod)\n{\n\tll r\u003d1;\n\twhile(b)\n\t{\n\t\tif(b\u0026amp;1) r\u003d(r*a)%mod;\n\t\ta\u003d(a*a)%mod;\n\t\tb\u0026gt;\u0026gt;\u003d1;\n\t}\n\treturn r;\n}\n\nvector\u0026lt;ii\u0026gt; ans;\n\nvoid add(ll n, ll k)\n{\n\tans.pb(mp(n,k));\n}\nconst int N \u003d 300000;\nvi divisors;\nint invpow[1000005];\nll fact[1000005];\nll phi;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tfact[0]\u003d1;\n\tfor(int i \u003d 1; i \u0026lt;\u003d MOD; i++)\n\t{\n\t\tfact[i]\u003d(fact[i-1]*i)%MOD;\n\t}\n\tphi\u003d0;\n\tfor(int i \u003d 1; i \u0026lt;\u003d MOD - 1; i++)\n\t{\n\t\tif(__gcd(i,MOD-1)\u003d\u003d1) phi++;\n\t}\n\tfor(int i \u003d 1; i*i \u0026lt;\u003d MOD-1; i++)\n\t{\n\t\tdivisors.pb(i);\n\t\tif(i!\u003d1) divisors.pb((MOD-1)/i);\n\t}\n\tint m; cin\u0026gt;\u0026gt;m;\n\tfor(int i \u003d 2; i \u0026lt; MOD; i++)\n\t{\n\t\tbool pos\u003d1;\n\t\tfor(int j \u003d 0; j \u0026lt; divisors.size(); j++)\n\t\t{\n\t\t\tif(modpow(i,divisors[j],MOD)\u003d\u003d1)\n\t\t\t{\n\t\t\t\tpos\u003d0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(pos)\n\t\t{\n\t\t\tg\u003di;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i \u003d 1; i \u0026lt; MOD - 1; i++)\n\t{\n\t\tassert(modpow(g,i,MOD)!\u003d1);\n\t\tinvpow[modpow(g,i,MOD)] \u003d i;\n\t}\n\tinvpow[1] \u003d MOD - 1;\n\tll invm \u003d invpow[m];\n\tfor(int i \u003d 1; i \u0026lt;\u003d MOD - 1; i++)\n\t{\n\t\tif(ans.size()\u0026gt;\u003dN) break;\n\t\tif(__gcd(i,MOD-1)!\u003d1) continue;\n\t\tll z \u003d invpow[fact[i]];\n\t\tz\u003d(z+invm)%(MOD-1);\n\t\tll power \u003d (modpow(i,phi-1,MOD-1)*z)%(MOD-1);\n\t\tadd(i, modpow(g,power,MOD));\n\t}\n\tfor(int i \u003d 0; i \u0026lt; N; i++)\n\t{\n\t\tcout\u0026lt;\u0026lt;ans[i].fi\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;ans[i].se\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem H\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int MOD \u003d 998244353;\n\nll mult(ll a, ll b)\n{\n\treturn (a*b)%MOD;\n}\n\nll add(ll a, ll b)\n{\n\ta+\u003db;\n\twhile(a\u0026gt;\u003dMOD) a-\u003dMOD;\n\treturn a;\n}\n\nll modpow(ll a, ll b)\n{\n\tll r\u003d1;\n\twhile(b)\n\t{\n\t\tif(b\u0026amp;1) r\u003dmult(r,a);\n\t\ta\u003dmult(a,a);\n\t\tb\u0026gt;\u0026gt;\u003d1;\n\t}\n\treturn r;\n}\n\nll divide(ll a, ll b)\n{\n\treturn mult(a, modpow(b,MOD-2));\n}\n\nvoid GaussJordan(vector\u0026lt;vector\u0026lt;ll\u0026gt; \u0026gt; \u0026amp;a) \n{\n\tconst int n \u003d a.size();\n\tvector\u0026lt;ll\u0026gt; irow(n), icol(n), ipiv(n);\n\tfor(int i \u003d 0; i \u0026lt; n; i++) \n\t{\n\t\tint pj \u003d -1, pk \u003d -1;\n\t\tfor(int j \u003d 0; j \u0026lt; n; j++) \n\t\t{\n\t\t\tif (!ipiv[j])\n\t\t\t{\n\t\t\t\tfor(int k \u003d 0; k \u0026lt; n; k++) \n\t\t\t\t{\n\t\t\t\t\tif (!ipiv[k])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pj \u003d\u003d -1) { pj \u003d j; pk \u003d k; }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(a[pj][pk]!\u003d0);\n\t\tipiv[pk]++;\n\t\tswap(a[pj], a[pk]);\n\t\tirow[i] \u003d pj;\n\t\ticol[i] \u003d pk;\n\t\tassert(a[pk][pk]!\u003d0);\n\t\tll c \u003d modpow(a[pk][pk],MOD-2);\n\t\ta[pk][pk] \u003d 1;\n\t\tfor(int p \u003d 0; p \u0026lt; n; p++) a[pk][p]\u003dmult(a[pk][p],c);\n\t\tfor(int p \u003d 0; p \u0026lt; n; p++) \n\t\t{\n\t\t\tif (p !\u003d pk) \n\t\t\t{\n\t\t\t\tc \u003d a[p][pk];\n\t\t\t\ta[p][pk] \u003d 0;\n\t\t\t\tfor (int q \u003d 0; q \u0026lt; n; q++) a[p][q] \u003d add(a[p][q], MOD - mult(a[pk][q], c));\n\t\t\t}\n\t\t}\n\t\tfor(int p \u003d n-1; p \u0026gt;\u003d 0; p--) \n\t\t{\n\t\t\tif (irow[p] !\u003d icol[p]) \n\t\t\t{\n\t\t\t\tfor (int k \u003d 0; k \u0026lt; n; k++) swap(a[k][irow[p]], a[k][icol[p]]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector\u0026lt;vector\u0026lt;ll\u0026gt; \u0026gt; a;\nint p[511];\nint r[511];\nvector\u0026lt;vector\u0026lt;ll\u0026gt; \u0026gt; b;\nvector\u0026lt;vector\u0026lt;ll\u0026gt; \u0026gt; res;\n\nvoid mult(vector\u0026lt;vector\u0026lt;ll\u0026gt; \u0026gt; \u0026amp;A, vector\u0026lt;vector\u0026lt;ll\u0026gt; \u0026gt; \u0026amp;B, vector\u0026lt;vector\u0026lt;ll\u0026gt; \u0026gt; \u0026amp;C)\n{\n\tint r1\u003dA.size(); int c1\u003dA[0].size();\n\tint r2\u003dB.size(); int c2\u003dB[0].size();\n\tassert(c1\u003d\u003dr2);\n\tC.resize(r1);\n\tfor(int i\u003d0;i\u0026lt;r1;i++)\n\t{\n\t\tC[i].assign(c2,0);\n\t\tfor(int j\u003d0;j\u0026lt;c2;j++)\n\t\t{\n\t\t\tfor(int k\u003d0;k\u0026lt;c1;k++)\n\t\t\t{\n\t\t\t\tC[i][j]\u003dadd(C[i][j],mult(A[i][k],B[k][j]));\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin\u0026gt;\u0026gt;n;\n\ta.resize(n);\n\tfor(int i\u003d0;i\u0026lt;n;i++) a[i].assign(n,0);\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tcin\u0026gt;\u0026gt;p[i]\u0026gt;\u0026gt;r[i];\n\t\tint P \u003d divide(p[i],100);\n\t\tint Q \u003d divide(100-p[i],100);\n\t\tif(i+r[i]\u0026lt;n)\n\t\t{\n\t\t\ta[i][i+r[i]] \u003d (MOD-P)%MOD;\n\t\t}\n\t\tif(i-r[i]\u0026gt;\u003d0)\n\t\t{\n\t\t\ta[i][i-r[i]] \u003d (MOD-Q)%MOD;\n\t\t}\n\t}\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\ta[i][i]\u003dadd(a[i][i],1);\n\t}\n\tGaussJordan(a);\n\tb.resize(n);\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tb[i].assign(2,0);\n\t}\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tint P \u003d divide(p[i],100);\n\t\tint Q \u003d divide(100-p[i],100);\n\t\tif(i+r[i]\u0026gt;\u003dn)\n\t\t{\n\t\t\tb[i][1] \u003d P;\n\t\t}\n\t\tif(i-r[i]\u0026lt;0)\n\t\t{\n\t\t\tb[i][0] \u003d Q;\n\t\t}\n\t}\n\tmult(a,b,res);\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tcout\u0026lt;\u0026lt;res[i][1];\n\t\tif(i+1\u0026lt;n) cout\u0026lt;\u0026lt;\u0027 \u0027;\n\t\tassert(add(res[i][1],res[i][0])\u003d\u003d1);\n\t}\n\tcout\u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem I\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int MOD \u003d 998244353;\n\nint add(int a, int b)\n{\n\ta+\u003db;\n\twhile(a\u0026gt;\u003dMOD) a-\u003dMOD;\n\treturn a;\n}\n\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\n\nint mod_pow(int a, int n, int mod) { int ret \u003d 1; while (n) { if (n \u0026amp; 1) ret \u003d ret *1LL* a % mod; a \u003d a *1LL* a % mod; n \u0026gt;\u0026gt;\u003d 1; } return ret; }\nint inv(int n){return mod_pow(n,MOD-2,MOD);}\nconst int LG \u003d 22;\nconst int root_pw \u003d (1\u0026lt;\u0026lt;LG);\nint iprt,prt;\n\nvoid fft (vector\u0026lt;int\u0026gt; \u0026amp; a, bool invert) \n{\n\tint n \u003d (int) a.size();\n \n\tfor (int i\u003d1, j\u003d0; i\u0026lt;n; ++i) {\n\t\tint bit \u003d n \u0026gt;\u0026gt; 1;\n\t\tfor (; j\u0026gt;\u003dbit; bit\u0026gt;\u0026gt;\u003d1)\n\t\t\tj -\u003d bit;\n\t\tj +\u003d bit;\n\t\tif (i \u0026lt; j)\n\t\t\tswap (a[i], a[j]);\n\t}\n \n\tfor (int len\u003d2; len\u0026lt;\u003dn; len\u0026lt;\u0026lt;\u003d1) {\n\t\tint wlen \u003d invert ? iprt : prt;\n\t\tfor (int i\u003dlen; i\u0026lt;root_pw; i\u0026lt;\u0026lt;\u003d1)\n\t\t\twlen \u003d int((wlen*1LL*wlen)%MOD);\n\t\tfor (int i\u003d0; i\u0026lt;n; i+\u003dlen) {\n\t\t\tint w \u003d 1;\n\t\t\tfor (int j\u003d0; j\u0026lt;len/2; ++j) {\n\t\t\t\tint u \u003d a[i+j]; int v \u003d int((a[i+j+len/2]*1LL*w)%MOD);\n\t\t\t\ta[i+j] \u003d u+v \u0026lt; MOD ? u+v : u+v-MOD;\n\t\t\t\ta[i+j+len/2] \u003d u-v \u0026gt;\u003d 0 ? u-v : u-v+MOD;\n\t\t\t\tw \u003d int (w * 1LL * wlen % MOD);\n\t\t\t}\n\t\t}\n\t}\n\tif (invert) {\n\t\tll nrev \u003d inv(n);\n\t\tfor (int i\u003d0; i\u0026lt;n; ++i)\n\t\t\ta[i] \u003d int((a[i]*1LL*nrev)%MOD);\n\t}\n}\n\nvoid multiply(vector\u0026lt;int\u0026gt;\u0026amp; a, vector\u0026lt;int\u0026gt;\u0026amp; b, vector\u0026lt;int\u0026gt;\u0026amp; res)\n{\n\tvector\u0026lt;int\u0026gt; fa(a.begin(), a.end()), fb(b.begin(), b.end());\n\tint n \u003d 1;\n\twhile(n \u0026lt; max(a.size(), b.size())) n \u0026lt;\u0026lt;\u003d 1;\n\tfa.resize(n); fb.resize(n);\n\tfft(fa, 0); fft(fb, 0);\n\tres.resize(n);\n\tfor(int i \u003d 0; i \u0026lt; n; i++) \n\t{\n\t\tres[i] \u003d int((fa[i]*1LL*fb[i])%MOD);\n\t}\n\tfft(res, 1);\n}\n\nvector\u0026lt;int\u0026gt; inverse(vector\u0026lt;int\u0026gt; \u0026amp;a, int deg) //returns a 2^{deg} polynomial\n{\n\tvector\u0026lt;int\u0026gt; h[2];\n\th[0].pb(mod_pow(a[0],MOD-2,MOD));\n\tint cur\u003d0; int pre\u003d1;\n\tfor(int i\u003d0;i\u0026lt;deg;i++) //after this it\u0027ll be of size 2^{deg}\n\t{\n\t\tcur^\u003d1; pre^\u003d1;\n\t\th[cur].resize((1\u0026lt;\u0026lt;(i+1)));\n\t\th[pre].resize((1\u0026lt;\u0026lt;(i+1)));\n\t\tmultiply(h[pre],h[pre],h[cur]);\n\t\tvector\u0026lt;int\u0026gt; pf;\n\t\tpf.assign((1\u0026lt;\u0026lt;(i+1)),0);\n\t\tfor(int j\u003d0;j\u0026lt;min(pf.size(),a.size());j++) pf[j]\u003da[j];\n\t\th[cur].resize((1\u0026lt;\u0026lt;(i+2))); pf.resize((1\u0026lt;\u0026lt;(i+2)));\n\t\tmultiply(pf,h[cur],h[cur]);\n\t\th[cur].resize((1\u0026lt;\u0026lt;(i+1)));\n\t\tfor(int j\u003d0;j\u0026lt;(1\u0026lt;\u0026lt;i);j++)\n\t\t{\n\t\t\th[cur][j] \u003d add(h[pre][j], add(h[pre][j], MOD - h[cur][j]));\n\t\t}\n\t\tfor(int j\u003d(1\u0026lt;\u0026lt;i);j\u0026lt;(1\u0026lt;\u0026lt;(i+1));j++)\n\t\t{\n\t\t\tif(h[cur][j]!\u003d0) h[cur][j] \u003d MOD - h[cur][j];\n\t\t}\n\t}\n\treturn h[cur];\n}\n\nvector\u0026lt;int\u0026gt; ln(vector\u0026lt;int\u0026gt; \u0026amp;a, int deg)\n{\n\twhile(a.size()\u0026lt;(1\u0026lt;\u0026lt;deg)) a.pb(0);\n\tvector\u0026lt;int\u0026gt; num,denom;\n\tdenom \u003d inverse(a, deg);\n\tnum.resize((1\u0026lt;\u0026lt;deg));\n\tfor(int i \u003d 0; i \u0026lt; (1\u0026lt;\u0026lt;deg); i++)\n\t{\n\t\tif(i+1\u0026lt;a.size())\n\t\t{\n\t\t\tnum[i] \u003d mult(a[i+1], i+1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnum[i] \u003d 0;\n\t\t}\n\t}\n\tnum.resize((1\u0026lt;\u0026lt;(deg+1))); denom.resize((1\u0026lt;\u0026lt;(deg+1)));\n\tvector\u0026lt;int\u0026gt; res;\n\tmultiply(num,denom,res);\n\tres.resize(1\u0026lt;\u0026lt;deg);\n\tvector\u0026lt;int\u0026gt; ans(1\u0026lt;\u0026lt;deg,0);\n\tfor(int i\u003d1;i\u0026lt;(1\u0026lt;\u0026lt;deg);i++)\n\t{\n\t\tans[i]\u003dmult(res[i-1],inv(i));\n\t}\n\treturn ans;\n}\n\nvector\u0026lt;int\u0026gt; exp(vector\u0026lt;int\u0026gt; \u0026amp;a, int deg)\n{\n\tvector\u0026lt;int\u0026gt; h[2];\n\th[0].pb(1);\n\tint cur\u003d0; int pre\u003d1;\n\tfor(int i\u003d0;i\u0026lt;deg;i++) //after this it\u0027ll be of size 2^{deg}\n\t{\n\t\tcur^\u003d1; pre^\u003d1;\n\t\tvector\u0026lt;int\u0026gt; pf;\n\t\tpf.assign((1\u0026lt;\u0026lt;(i+1)),0);\n\t\tfor(int j\u003d0;j\u0026lt;min(pf.size(),a.size());j++) pf[j]\u003da[j];\n\t\tpf[0]\u003dadd(pf[0],1);\n\t\tvector\u0026lt;int\u0026gt; LN \u003d ln(h[pre],i+1);\n\t\tfor(int j\u003d0;j\u0026lt;(1\u0026lt;\u0026lt;(i+1));j++)\n\t\t{\n\t\t\tpf[j] \u003d add(pf[j], MOD - LN[j]);\n\t\t}\n\t\th[pre].resize((1\u0026lt;\u0026lt;(i+2))); pf.resize((1\u0026lt;\u0026lt;(i+2)));\n\t\tmultiply(pf,h[pre],h[cur]);\n\t\th[cur].resize((1\u0026lt;\u0026lt;(i+1)));\n\t}\n\treturn h[cur];\n}\n\nint fast(ll sum, ll cnt)\n{\n\tsum-\u003d(cnt*(cnt+1))/2;\n\tassert(sum\u0026gt;\u003d0);\n\tvector\u0026lt;int\u0026gt; gd(sum+1,0);\n\tfor(int i \u003d 1; i \u0026lt;\u003d sum; i++)\n\t{\n\t\tint tmp \u003d inv(i);\n\t\tfor(int j \u003d 1; j*i\u0026lt;\u003dsum\u0026amp;\u0026amp;j\u0026lt;\u003dcnt; j++)\n\t\t{\n\t\t\tgd[i*j]\u003dadd(gd[i*j],tmp);\n\t\t}\n\t}\n\tint S \u003d 0;\n\twhile(sum\u0026gt;\u003d(1\u0026lt;\u0026lt;S)) S++;\n\tvector\u0026lt;int\u0026gt; res \u003d exp(gd,S);\n\treturn res[sum];\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint tmpmult \u003d 7*17;\n\ttmpmult \u003d mult(tmpmult, mod_pow(2, 23 - LG, MOD)); \n\tprt \u003d mod_pow(3, tmpmult, MOD);\n\tiprt \u003d inv(prt);\n\tstring s; \n\tcin\u0026gt;\u0026gt;s;\n\tll sum\u003d0; ll cnt\u003d0;\n\tfor(int i\u003d0;i\u0026lt;s.length();i++)\n\t{\n\t\tif(s[i]\u003d\u003d\u00271\u0027)\n\t\t{\n\t\t\tsum+\u003di+1;\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt\u003d\u003d0)\n\t{\n\t\tcout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\treturn 0;\n\t}\n\tll ans \u003d fast(sum,cnt);\n\tcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}