{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1457967661,"rating":71,"authorHandle":"GlebsHP","modificationTimeSeconds":1457970588,"id":43794,"title":"\u003cp\u003eРазбор задач VK Cup 2016 — Квалификация 1 \u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eЭто был бы самый обычный разбор, если бы не новая фича — спойлеры. Заценить как это круто и удобно можно уже прямо в этом посте, к каждой задаче под спойлером прикладывается код решения. Скажем спасибо \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/kuviman\" title\u003d\"Мастер kuviman\"\u003ekuviman\u003c/a\u003e :)\u003c/p\u003e\u003cp\u003eТекст разбора: \u003ca class\u003d\"rated-user user-admin\" href\u003d\"/profile/MikeMirzayanov\" title\u003d\"Штаб, MikeMirzayanov\"\u003eMikeMirzayanov\u003c/a\u003e, \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/fcspartakm\" title\u003d\"Кандидат в мастера fcspartakm\"\u003efcspartakm\u003c/a\u003e и \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/GlebsHP\" title\u003d\"Гроссмейстер GlebsHP\"\u003eGlebsHP\u003c/a\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/637/problem/A\" title\u003d\"VK Cup 2016 - Квалификация 1\"\u003e637A - Голосование за фотографии\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eАвтор идеи: \u003ca class\u003d\"rated-user user-admin\" href\u003d\"/profile/MikeMirzayanov\" title\u003d\"Штаб, MikeMirzayanov\"\u003eMikeMirzayanov\u003c/a\u003e. Разработка: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/fcspartakm\" title\u003d\"Кандидат в мастера fcspartakm\"\u003efcspartakm\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eДля решения данной задачи достаточно было проитерироваться по поставленным лайкам в хронологическом порядке и в отдельном массиве поддерживать количество лайков, которые уже были поставлены фотографиям (например, в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e будет храниться количество лайков, поставленных \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-й фотографии). Для нахождения ответа достаточно на каждой итерации обновлять имеющийся максимум лайков текущим значением \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e, и если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u0026gt; \u003ci\u003emaxCnt\u003c/i\u003e\u003c/span\u003e обновлять ответ, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emaxCnt\u003c/i\u003e\u003c/span\u003e — это текущее максимальное количество лайков.\u003c/p\u003e\u003cp\u003eАсимптотика такого решения — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e — количество поставленных лайков.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПример решения\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eОсновная часть решения:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint n;\nint a[N];\nint cnt[M];\n\nint main() {\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    int maxCnt \u003d 0, ans;\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]);\n        cnt[a[i]]++;\n        if (cnt[a[i]] \u0026gt; maxCnt) {\n            ans \u003d a[i];\n            maxCnt \u003d cnt[a[i]];\n        }\n    }\n    printf(\u0026quot;%d\u0026quot;, ans);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/637/problem/B\" title\u003d\"VK Cup 2016 - Квалификация 1\"\u003e637B - Порядок чатов\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eАвтор идеи: \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/GlebsHP\" title\u003d\"Гроссмейстер GlebsHP\"\u003eGlebsHP\u003c/a\u003e. Разработка: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/fcspartakm\" title\u003d\"Кандидат в мастера fcspartakm\"\u003efcspartakm\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eДля решения данной задачи нужно проитерироваться в обратном порядке по адресатам сообщений, начиная с последнего, так как верно то, что чем позднее Поликарп отправит сообщение какому-то собеседнику, тем выше этот собеседник будет в списке чатов. На каждой итерации нужно проверять, что текущий собеседник еще не был добавлен в список чатов (то есть Поликарп еще не писал ему сообщение). Это можно сделать с помощью структуры данных \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eset\u003c/i\u003e\u003c/span\u003e. Таким образом, если текущего собеседника еще нет в списке чатов, нужно добавить имя этого собеседника в конец ответного списка чатов и добавить имя этого собеседника в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eset\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eАсимптотика такого решения — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e·\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e — количество сообщений, отправленных Поликарпом.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПример решения\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eОсновная часть решения:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint n;\nstring a[N];\nset\u0026lt;string\u0026gt;names;\n\nint main () {\n\tcin \u0026gt;\u0026gt; n;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\t\t\n\t\tcin \u0026gt;\u0026gt; a[i];\n\t}\t\n\tfor (int i \u003d n - 1; i \u0026gt;\u003d 0; i--) {\n\t\tif(names.count(a[i]))\n\t\t\tcontinue;\n\t\tnames.insert(a[i]);\n\t\tcout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; endl;\n\t}\t\t\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/637/problem/C\" title\u003d\"VK Cup 2016 - Квалификация 1\"\u003e637C - Промокоды с ошибками\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eАвтор идеи: \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/GlebsHP\" title\u003d\"Гроссмейстер GlebsHP\"\u003eGlebsHP\u003c/a\u003e. Разработка: \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/GlebsHP\" title\u003d\"Гроссмейстер GlebsHP\"\u003eGlebsHP\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eДля начала научимся решать задачу проверки фиксированного значения \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Правда ли, что если мы в каждом промокоде совершим не более чем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e ошибок, ты мы сможем однозначно идентифицировать исходных промокод? Иначе говоря, верно ли, что для любой последовательности из шести цифр, существует не более одного промокода отличающегося от данной последовательности в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e или менее позициях.\u003c/p\u003e\u003cp\u003eДля каждого промокода можно построить множество последовательностей отличающихся от него не более чем в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e позициях, то есть шар радиуса \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e в данной метрике. Так, для промокода \u003cspan class\u003d\"tex-span\"\u003e123456\u003c/span\u003e подойдут последовательности \u003cspan class\u003d\"tex-span\"\u003e?23456\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e1?3456\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e12?456\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e123?56\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e1234?6\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e12345?\u003c/span\u003e (вопросик заменяется на любую цифру). Очевидно, что некоторое \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e подходит, если никакие два шара радиуса \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e не пересекаются. Этого уже достаточно для решения задачи, просто честно перебрать значения \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e и проверить наличие пересечения шаров. Единственная тонкость — процесс необходимо остановить как только найдётся любая последовательность принадлежащая двум шарам.\u003c/p\u003e\u003cp\u003eБлагодаря условию \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≤ 1000\u003c/span\u003e задачу можно было решить и гораздо проще. Заметим, что два шара радиуса \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e пересекаются если расстояние между их центрами не превосходит \u003cspan class\u003d\"tex-span\"\u003e2·\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Таким образом достаточно найти пару прокодов с минимальным расстоянием между ними и выбрать максимальное подходящее \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Не забываем про случай \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 1\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПример решения\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eОсновная часть решения:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint calc_dist(const string\u0026amp; s1, const string\u0026amp; s2) {\n    int d \u003d 0;\n    for (int i \u003d 0; i \u0026lt; (int) s1.size(); i++)\n        d +\u003d (s1[i] !\u003d s2[i]);\n\n    return d;\n}\n\nint main() {\n    int n;\n    cin \u0026gt;\u0026gt; n;\n    vector \u0026lt;string\u0026gt; code(n);\n\n    for (int i \u003d 0; i \u0026lt; n; i++)\n        cin \u0026gt;\u0026gt; code[i];\n\n    int ans \u003d 12;\n    for (int i \u003d 0; i \u0026lt; n; i++)\n        for (int j \u003d i + 1; j \u0026lt; n; j++)\n            ans \u003d min(ans, calc_dist(code[i], code[j]) - 1);\n\n    cout \u0026lt;\u0026lt; ans / 2 \u0026lt;\u0026lt; endl;\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/637/problem/D\" title\u003d\"VK Cup 2016 - Квалификация 1\"\u003e637D - Бег с препятствиями\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eАвтор идеи: \u003ca class\u003d\"rated-user user-admin\" href\u003d\"/profile/MikeMirzayanov\" title\u003d\"Штаб, MikeMirzayanov\"\u003eMikeMirzayanov\u003c/a\u003e. Разработка: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/fcspartakm\" title\u003d\"Кандидат в мастера fcspartakm\"\u003efcspartakm\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eВ самом начале отсортируем все координаты препятствий по возрастанию. Затем воспользуемся следующим фактом: если спортсмен может преодолеть препятствие номер \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e и успевает разбежаться перед прыжком до препятствия номер \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + 1\u003c/span\u003e (то есть \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e ≤ \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e + 1] - \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] - 2\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e — длина разбега перед прыжком), ему выгодно разбежаться и начать новый прыжок в точке \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e + 1] - 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eТаким образом, для решения задачи достаточно проитерироваться по препятствиям слева направо. Пусть спортсмен преодолеть препятствие с номером \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Тогда нужно найти первое такое препятствие с номером \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e (правее \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e), что спортсмен успеет разбежаться для прыжка после препятствия \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e - 1\u003c/span\u003e и до препятствия \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. В таком случае спортсмену необходимо выполнить прыжок из точки \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1] - 1\u003c/span\u003e в точку \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e - 1] + 1\u003c/span\u003e. Если расстояние между этими точками больше чем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e, значит спортсмен не сможет добраться до финиша. В противном случае нужно выполнить такой прыжок и продолжить работу программы. После преодоления всех препятствий нужно проверить нужно ли спортсмену бежать до финишной точки, или он уже находится в ней. \u003c/p\u003e\u003cp\u003eАсимптотика такого решения — \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e — количество препятствий.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПример решения\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eОсновная часть решения:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint a[N];\nint n, m, s, d;\nvector\u0026lt;pair\u0026lt;string, int\u0026gt; \u0026gt; ans;\n\nint main () {\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; d;\n\tfor(int i \u003d 0; i \u0026lt; n; i++) {\n\t\tcin \u0026gt;\u0026gt; a[i];\n\t}\n\tsort(a, a + n);\n\tint curPos \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; ) {\n\t\tint prev \u003d i;\n\t\tif(a[i] - curPos - 1 \u0026gt;\u003d s) {\n\t\t\ti++;\n\t\t\twhile(i \u0026lt; n \u0026amp;\u0026amp; a[i] - a[i - 1] - 2 \u0026lt; s)\n\t\t\t\ti++;\n\t\t\tint jumpDist \u003d a[i - 1] + 1 - (a[prev] - 1);\n\t\t\tif (jumpDist \u0026gt; d) {\n\t\t\t    cout \u0026lt;\u0026lt; \u0026quot;IMPOSSIBLE\u0026quot; \u0026lt;\u0026lt; endl;\n\t\t\t    return 0;\n\t\t\t}\n\t\t\tans.push_back(make_pair(\u0026quot;RUN\u0026quot;, a[prev] - curPos - 1));\n\t\t\tans.push_back(make_pair(\u0026quot;JUMP\u0026quot;, jumpDist));\n\t\t\tcurPos \u003d a[i - 1] + 1;\n\t\t} else {\n\t\t\tcout \u0026lt;\u0026lt; \u0026quot;IMPOSSIBLE\u0026quot; \u0026lt;\u0026lt; endl;\n\t\t\treturn 0;\n\t\t}\t\t\n\t}\n\tif(curPos !\u003d m)\n\t\tans.push_back(make_pair(\u0026quot;RUN\u0026quot;, m - curPos));\n\tfor(int i \u003d 0; i \u0026lt; (int)ans.size(); i++) {\n\t\tcout \u0026lt;\u0026lt; ans[i].first \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; ans[i].second \u0026lt;\u0026lt; endl;\n\t}                  \n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["разбор задач","vkcup2016"]}}