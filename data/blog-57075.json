{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1515818258,"rating":-3,"authorHandle":"remidinishanth","modificationTimeSeconds":1515826539,"id":57075,"title":"\u003cp\u003eHow to solve this? [Game theory]\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello,\u003c/p\u003e\u003cp\u003eCan someone explain the logic [and formal proof why this logic works] to solve this problem?\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://csacademy.com/contest/round-64/task/limited-moves/\"\u003ehttps://csacademy.com/contest/round-64/task/limited-moves/\u003c/a\u003e\u003c/p\u003e\u003cp\u003eConsider a heap of \u003cstrong\u003eN\u003c/strong\u003e objects. Two players take turns playing the following game:\u003c/p\u003e\u003cp\u003eAt his very first move, the first player removes from the heap between \u003cstrong\u003e1\u003c/strong\u003e and \u003cstrong\u003eN-1\u003c/strong\u003e objects After that, at each step the player to move can remove any number of objects between 1 and the number of objects removed by the other player at the previous move When the heap becomes empty, the player to move loses the game.\u003c/p\u003e\u003cp\u003e[UPD.]\u003c/p\u003e\u003cp\u003eI know that removing the number of objects from Last on bit works. The Last on-bit, I mean the below.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint k\u003d0;\nwhile( n % (1\u0026lt;\u0026lt;(k+1)) \u003d\u003d 0)\n            k++;\nprintf(\u0026quot;%d\u0026quot;,(1\u0026lt;\u0026lt;k));\nfflush(stdout);\nn -\u003d (1\u0026lt;\u0026lt;k);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI need a formal proof/Argument that why is this working. Or why this is guaranteed to work?\u003c/p\u003e\u003cp\u003eThank you.\u003c/p\u003e\u003c/div\u003e","tags":["game theory","game playing","interactive problem"]}}