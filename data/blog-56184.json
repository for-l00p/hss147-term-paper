{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1512481611,"rating":107,"authorHandle":"NeercNews","modificationTimeSeconds":1512483017,"id":56184,"title":"\u003cp\u003eKotlin in ICPC\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cimg align\u003d\"right\" alt\u003d\"text\" src\u003d\"/predownloaded/b8/2b/b82bb0a59563a41dd4c43f64daa1e0c16bed95db.png\" style\u003d\"height: 200.0px;margin: 5.0px;max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eLet us introduce the new programming language in ICPC: Kotlin. It is modern and developing language created by our sponsor JetBrains. Kotlin is inspired by Java and as Java is named after the island. Currently, Kotlin programs are compiled into JVM bytecode, all Java written code can be used from Kotlin sources and Kotlin written code can be used from Java sources as well out of the box. Kotlin being developed now most of the standard libraries are Java library classes, making Kotlin a programing language that is already used in many projects being the main language of their development. \u003c/p\u003e\u003cp\u003eComparing to Java language some Java disadvantages fixed and new features added. Some of them we will see in today\u0027s solution of ICPC World Finals 2016 problem C (\u003ca href\u003d\"/gym/101242/problem/C\" title\u003d\"2016 ACM-ICPC World Finals\"\u003e101242C - Ceiling Function\u003c/a\u003e). Less boilerplate code and syntactic sugar added\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cstrong\u003enew\u003c/strong\u003e operator omitted\u003c/li\u003e   \u003cli\u003edata classes implement \u003cstrong\u003ehashCode\u003c/strong\u003e, \u003cstrong\u003eequals\u003c/strong\u003e and \u003cstrong\u003etoString\u003c/strong\u003e methods depending on constructor parameters\u003c/li\u003e   \u003cli\u003eoperator overloading\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003ewith\u003c/strong\u003e function, to implement a block of code, making captured value as this\u003c/li\u003e   \u003cli\u003e\u003cstrong\u003ewhen\u003c/strong\u003e operator providing better readability of conditional operator in some cases\u003c/li\u003e   \u003cli\u003etype inference (IDE supports hints on variable and function types, it\u0027s just you don\u0027t have to type it)\u003c/li\u003e   \u003cli\u003efunctional programming style\u003c/li\u003e \u003c/ol\u003e \u003cpre\u003e\u003ccode\u003eimport java.util.*\n\ndata class Tree(var left: Tree? \u003d null, var right: Tree? \u003d null) {\n    var value \u003d 0\n}\n\noperator fun Tree?.plus(x: Int): Tree? {\n    if (this \u003d\u003d null) return Tree().apply { value \u003d x }\n    if (x \u0026lt; value) {\n        left +\u003d x\n    } else {\n        right +\u003d x\n    }\n    return this\n}\n\nfun main(args: Array\u0026lt;String\u0026gt;) \u003d with(Scanner(System.`in`)) {\n    val n \u003d nextInt()\n    val k \u003d nextInt()\n    val a \u003d Array(n) { IntArray(k) { nextInt() } }\n    println(a.map { it.fold(null, Tree?::plus) }.toSet().size)\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can try Kotlin at: \u003ca href\u003d\"https://try.kotlinlang.org\"\u003ehttps://try.kotlinlang.org\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["kotlin","jetbrains","icpc world finals"]}}