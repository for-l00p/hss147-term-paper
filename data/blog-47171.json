{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1474132630,"rating":-20,"authorHandle":"meeeep","modificationTimeSeconds":1474152995,"id":47171,"title":"\u003cp\u003e372\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eFor what it\u0027s worth, here is a possible way of solving the questions of CF 372 Div 2, possibly with mistakes (since I only coded 3/5).\u003c/p\u003e\u003cp\u003eEdit: I didn\u0027t think the official editorial would be out so quickly! Wrote this without even checking for the official editorial. Since the official editorial is EXTREMELY GOOD this time, please check it out at \u003ca href\u003d\"//codeforces.com/blog/entry/47169\"\u003ehttp://codeforces.com/blog/entry/47169\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eA - From the last timing, keep proceeding until you hit a gap of more than c seconds. Count how many steps you took. (and possibly +1)\u003c/p\u003e\u003cp\u003eB - For each substring of length 26, it is valid if and only if it does not already contain 2 of the same letter.\u003c/p\u003e\u003cp\u003eSo firstly, we loop through all such substrings and using a boolean array of size 26 check which letters have been used. If no letter that has been used appears again, then the substring is fine, and we have found a place where we can insert a nice substring.\u003c/p\u003e\u003cp\u003eFor those 26 positions, insert in place of the ?s any letter that has not yet been used.\u003c/p\u003e\u003cp\u003eFor anything else, insert your favourite letter.\u003c/p\u003e\u003cp\u003eIf the initial string has length \u0026lt;26 or you could not find a substring position that could possibly be nice, print -1 and exit. Else, print out the string with the ?s filled in.\u003c/p\u003e\u003cp\u003eC - One way of doing it is to add until the number is (L*(L+1))^2 before taking the squareroot. We can verify that for level 1 this takes 2 moves and otherwise it takes L*(L*L+L)-1 moves.\u003c/p\u003e\u003cp\u003eD - Since we are only interested whether a path of length L exists between \u003cem\u003es\u003c/em\u003e and \u003cem\u003et\u003c/em\u003e, an edge of weight L+1 is as good as infinity.\u003c/p\u003e\u003cp\u003eConsider the case where all erased edges are 1. Find the pairwise distance of any two points \u003cem\u003ea\u003c/em\u003e and \u003cem\u003eb\u003c/em\u003e. Call this d1(_a_, \u003cem\u003eb\u003c/em\u003e). This can be accomplished using Dijkstra, for example.\u003c/p\u003e\u003cp\u003eConsider the case where all erased edges are L+1. Find the pairwise distance of any two points \u003cem\u003ea\u003c/em\u003e and \u003cem\u003eb\u003c/em\u003e. Call this d2(_a_, \u003cem\u003eb\u003c/em\u003e).\u003c/p\u003e\u003cp\u003eIf d1(_s_, \u003cem\u003et\u003c/em\u003e)\u0026gt;L, then there is no solution. Similarly, if d2(_s_, \u003cem\u003et\u003c/em\u003e)\u0026lt;L, there is no solution. Otherwise, if we hypothetically increased random erased edges\u0027 costs by 1, one edge at a time, then each step increases d1(_s_, \u003cem\u003et\u003c/em\u003e) by either 0 or 1, so we will definitely pass by L at some point, and it is possible.\u003c/p\u003e\u003cp\u003eSo we just need to increase the weights of erased edges not on the path giving d1(_s_, \u003cem\u003et\u003c/em\u003e) to L+1 and increase the weights of those that are until the length of the path is exactly L, subject to not increasing costs of erased edges by more than d2(start, end) of the edge.\u003c/p\u003e\u003cp\u003eE - Let the multiplicative inverse of 10 mod M be N. If we head towards the node, read the number in base 10. Else read it base N. It can be proven that a path is valid if and only if the left and right paths are negatives modulo M.\u003c/p\u003e\u003cp\u003eConsider the center of the tree. Say we wish to count the number of paths passing through it. Find all residue classes modulo M of paths that lead towards it and those that lead away from it. In total, there are at most 200k such classes. For each pair of classes (1 towards and 1 away) with correspondingly negative values mod M, add the product of their sizes. This counts all legitimate paths, but overcounts those which double back on themselves. For each branch, we simply have to subtract those away.\u003c/p\u003e\u003c/div\u003e","tags":[]}}