{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1491690454,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1491827992,"id":51500,"title":"\u003cp\u003eИспользование структур данных (из Collection API) (пока простые задачи)\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eНа лекциях уже обсуждались такие структуры данных, как ArrayList (и немного ArrayDeque), LinkedList, TreeSet (и немного HashSet) (в недалёком будущем планируются к рассмотрению TreeMap, HashMap). Ближайшие тренировки будут ориентированы на использование этих структур данных. \u003cbr /\u003e Эти структуры данных относятся к так называемому Java Collection Framework, которому посвящен \u003ca href\u003d\"http://docs.oracle.com/javase/tutorial/collections/index.html\"\u003eотдельный раздел\u003c/a\u003e Tutorials. Настоятельно рекомендуется обращаться не только к документации, но и к этому ресурсу (как минимум, в нем вы найдете весьма содержательные примеры). \u003c/p\u003e\u003cp\u003eЗдесь же приведем краткий обзор некоторых структур данных, являющихся коллекциями.\u003c/p\u003e\u003cp\u003e\u003ccode\u003eArrayList\u003c/code\u003e может пониматься как динамический массив, поскольку допускает добавление и удаление элементов. С обычным массивом проделать такое нельзя, можно только выделить память заново (с помощью оператора \u003ccode\u003enew\u003c/code\u003e), при этом уже имеющиеся элементы не будут сохранены. Конечно, нужно понимать, что добавление элемента в динамический массив или удаление элемента из динамического массива сопряжено с определенными накладными расходами. Поэтому частое обращение к этим операциям может привести к замедлению работы программы. В документации \u003ca href\u003d\"https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html\"\u003eговорится\u003c/a\u003e, что операция добавления выполняется за \u003cem\u003eамортизированное константное время\u003c/em\u003e (т.е. на добавление \u003ccode\u003en\u003c/code\u003e элементов будет затрачено время порядка \u003ccode\u003eO(n)\u003c/code\u003e, но время добавления для конкретного элемента может находиться в диапазоне от 0 до этой величины). Обращение к элементу, хранящемуся в \u003ccode\u003eArrayList\u003c/code\u003e, осуществляется за константное время (как и в случае обычного массива).\u003c/p\u003e\u003cp\u003e\u003ccode\u003eLinkedList\u003c/code\u003e де-факто является двусвязным списком, что обеспечивает быстрое удаление и добавление элементов. Однако любые операции, требующие обращения к элементу по индексу, будут приводить к последовательному просмотру списка с начала или с конца (в отличие от \u003ccode\u003eArrayList\u003c/code\u003e). Такие операции могут сильно замедлить работу вашей программы.\u003c/p\u003e\u003cp\u003eВ некотором смысле улучшенной версией такого списка является \u003ccode\u003eArrayDeque\u003c/code\u003e, который большинство операций выполняет за амортизированное константное время, исключение составляют некоторые операции удаления и массовые операции (\u003ca href\u003d\"https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html\"\u003eдокументация\u003c/a\u003e). Обратите внимание, что интерфейс \u003ccode\u003eList\u003c/code\u003e этот класс не поддерживает (так что способа обратиться к элементу по индексу в нем попросту нет). Однако, поскольку частой ситуацией является именно добавление и удаление элементов в конец (или начало) списка (при организации стека или очереди, например), то возможность обращаться к произвольному элементу списка может быть излишней и вполне компенсируется быстродействием. \u003c/p\u003e\u003cp\u003e\u003ccode\u003eTreeSet\u003c/code\u003e по своей сути упорядоченное множество. В нем могут храниться элементы, для которых определена операция сравнения (т.е. про любые два элемента того типа, который хранится в множестве, можно сказать, что один больше другого, один меньше другого или же один равен другому). Для ряда предопределенных классов (в частности, \u003ccode\u003eInteger\u003c/code\u003e, \u003ccode\u003eString\u003c/code\u003e) операции сравнения определены. Если же вы будете хранить в множестве объекты класса, определенного вами, то либо ваш класс должен реализовывать интерфейс \u003ccode\u003eComparable\u003c/code\u003e, либо при создании экземпляра \u003ccode\u003eTreeSet\u003c/code\u003e ему следует передать компаратор (экземпляр класса \u003ccode\u003eComparator\u003c/code\u003e), который обеспечит корректное сравнение элементов. \u003c/p\u003e\u003cp\u003eИ операции добавления, и операции доступа к элементам имеют асимптотику \u003ccode\u003eO(log n)\u003c/code\u003e (внутри \u003ccode\u003eTreeSet\u003c/code\u003e в действительности лежит \u003ccode\u003eTreeMap\u003c/code\u003e, реализованный как красно-черное дерево). Заметим, что метод \u003ccode\u003eadd\u003c/code\u003e, добавляющий элемент в множество, возвращает логическое значение: \u003ccode\u003etrue\u003c/code\u003e, если элемент был добавлен, и \u003ccode\u003efalse\u003c/code\u003e, если такой элемент в множестве уже присутствовал. \u003c/p\u003e\u003cp\u003e\u003ccode\u003eHashSet\u003c/code\u003e также является множеством, но порядок элементов в нем не гарантирован (подобно \u003ccode\u003eTreeSet\u003c/code\u003e внутри \u003ccode\u003eHashSet\u003c/code\u003e лежит \u003ccode\u003eHashMap\u003c/code\u003e, реализованный посредством хеш-таблиц). Чтобы хранить объекты в \u003ccode\u003eHashSet\u003c/code\u003e, достаточно уметь отвечать на вопрос, равны они или нет (т.е. достаточно подходящей реализации метода \u003ccode\u003eequals()\u003c/code\u003e; впрочем, изменение \u003ccode\u003eequals()\u003c/code\u003e влечет за собой необходимость переопределить и \u003ccode\u003ehashCode()\u003c/code\u003e). Реализация \u003ccode\u003eHashSet\u003c/code\u003e обеспечивает для базовых операций (обращение к элементу и помещение элемента в множество) константное время выполнения; так что при прочих равных \u003ccode\u003eHashSet\u003c/code\u003e будет работать быстрее, нежели \u003ccode\u003eTreeSet\u003c/code\u003e (и если упорядоченность элементов не требуется, разумно предпочесть именно эту реализацию множества).\u003c/p\u003e\u003cp\u003eКраткое представление о коллекциях может дать также \u003ca href\u003d\"https://compscicenter.ru/media/slides/java_2013_autumn/2013_10_21_java_2013_autumn.pdf\"\u003eпрезентация А.Владыкина\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eСейчас вам предлагается решить несколько достаточно простых задач, в которых, вообще говоря, можно попытаться обойтись без описанных выше структур данных. Но нельзя не заметить, что их использование может существенно упростить написание решения. \u003c/p\u003e\u003cp\u003eСегодня — задачи с \u003ca href\u003d\"http://acm.timus.ru\"\u003eacm.timus.ru\u003c/a\u003e. \u003c/p\u003e\u003cp\u003eЗадача 2033 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d2033\"\u003eДевайсы\u003c/a\u003e \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПодсказка\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eМожно поступить, например, следующим образом: определить класс, содержащий название девайса (строку), количество друзей, обладающих им (целое число), минимальная цена (среди уже известных) (целое число). Поскольку у каждого друга ровно один девайс, то придется создать максимум 6 объектов. Поиск среди такого количества объектов можно выполнять линейно (т.е. последовательно просматривая все имеющиеся объекты), поэтому для хранения достаточно использовать ArrayList (а не сортирующую структуру данных — например, TreeSet).\u003c/p\u003e\u003cp\u003eЛогика каждого шага следующая: - прочитываем информацию об очередном девайсе (имя владельца, которое, вообще говоря, нам не нужно; собственно название девайса и его цену; - последовательно просматриваем все уже имеющиеся элементы в ArrayList. Для каждого элемента проверяем, не совпадают ли названия девайсов. Если совпадают, то делаем две вещи: увеличиваем на единицу количество обладающих девайсом друзей и проверяем, не является ли новая цена минимальной (если является, то обновляем цену). Если названия девайсов не совпадают — переходим к следующему элементу ArrayList - если все элементы в ArrayList закончились, а совпадающего названия мы так и не нашли, создаем из информации о девайсе новый объект, устанавливая количество обладающих им друзей в 1.\u003c/p\u003e\u003cp\u003eКогда мы прочитали информацию обо всех друзьях, пройдем еще раз по ArrayList и будем запоминать индекс девайса, который есть у наибольшего количества друзей. Пусть это индекс i. Далее, если мы встречаем девайс (пусть с индексом j), который есть у большего количества друзей, нежели девайс с индексом i, мы \u0026quot;забываем\u0026quot; про девайс с индексом i и \u0026quot;помним\u0026quot; теперь про девайс с индексом j. Если же девайсами i и j обладает одинаковое количество друзей, сравним их цены и запомним индекс того, у которого меньше цена.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cbr /\u003e Задача 1563. \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1563\"\u003eБаяны\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПодсказка\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eЗаведем TreeSet на строках (TreeSet) и будем пробовать помещать в него каждую прочитанную строку. Метод add() в TreeSet устроен следующим образом: если элемент добавлен в TreeSet (т.е. его там не было), метод вернет значение true. Если же элемент уже присутствовал в TreeSet (и не может быть добавлен), метод возвращает значение false. Таким образом, нам нужно посчитать, сколько раз при добавлении строки в множество (TreeSet) мы получим false — и это будет количество магазинов, в которые не зашла Анжела.\u003c/p\u003e\u003cp\u003eОбратите внимание, что нужно вычитывать именно строку целиком (т.е. метод next() класса Scanner не годится, он \u0026quot;читает слово до разделителя\u0026quot;, надо использовать nextLine()). Еще одна тонкость состоит в том, что, если Вы прочитали число n методом nextInt(), то конец первой строки (где записано n) остался \u0026quot;непрочитанным\u0026quot;, и первый вызов nextLine() как раз \u0026quot;прочитает\u0026quot; именно его.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cbr /\u003e Задача 1496. \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1496\"\u003eСпамер\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПодсказка\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eЭта задача идейно не отличается от задачи \u0026quot;Баяны\u0026quot;. Вновь заведем TreeSet, в который будем помещать прочитанные аккаунты. Когда попытка поместить в TreeSet очередной аккаунт приводит к неудаче (метод add() возвращает false, поскольку такая строка уже содержится в множестве), поместим этот аккаунт в другое множество TreeSet. Использовать для хранения аккаунтов спамеров нужно именно множество, поскольку спамеры могли отсылать задачу более двух раз (а каждый спамерский аккаунт нам надо вывести единожды — поэтому нужна структура данных, добавляющая в себя только один экземпляр каждой строки).\u003c/p\u003e\u003cp\u003eЗаметим, что аккаунты могут состоять из строчных латинских букв и цифр, при этом не гарантируется, что аккаунт всегда начинается с буквы. Поэтому рекомендуется перед отправкой проверить свое решение на тесте, в котором имеется спамерский аккаунт, начинающийся с цифры.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cbr /\u003e Задача 2023. \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d2023\"\u003eДональд-почтальон\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПодсказка\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eОдин из способов решения этой задачи состоит в следующем. Заведем ArrayList\u0026lt;TreeSet\u0026gt;. Этот список будет состоять всего из трех элементов, а каждый TreeSet будет описывать отдельный шкаф. Поместим все имена (строки) на ящиках в соответствующие TreeSet.\u003c/p\u003e\u003cp\u003eПоскольку между соседними шкафами расстояние составляет один шаг (Дональда), то определить расстояние, на которое ему придется переместиться, чтобы положить очередное письмо в ящик, можно, взяв разность между номерами шкафов (их индексами в ArrayList) по абсолютной величине.\u003c/p\u003e\u003cp\u003eЛогика действий следующая: \u003cbr /\u003e - на каждом шаге мы знаем текущую позицию Дональда. Для очередного письма выясняем, в каком шкафу находится ящик адресата: для этого достаточно перебрать все три элемента ArrayList и воспользоваться методом contains() класса TreeSet (он позволяет выяснить, содержится ли та или иная строка в множестве). Номер этого шкафа и станет новой позицией Дональда. \u003cbr /\u003e - добавляем к пройденному расстоянию абсолютную величину разности текущей и новой позиций, заменяем значение текущей позиции новой.\u003c/p\u003e\u003cp\u003eВ конце остается вывести количество сделанных Дональдом шагов. Кажется, главная сложность в этой задаче — правильно перепечатать имена на ящиках (скопировать с рисунка их не получается).\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cbr /\u003e Задача 1100. \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1100\"\u003eТаблица результатов\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПодсказка\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eПузырьковая сортировка работает за O(n^2) шагов, где n — количество сортируемых элементов (этот вопрос обсуждался на лекции). Поэтому применять ее в задаче, где n может достигать 150000 — не очень хорошая идея. Следовательно, надо применить более эффективную сортировку, но таким образом, чтобы итоговый результат был таким же, как у пузырьковой.\u003c/p\u003e\u003cp\u003eПроанализируем, к каким результатам приводит пузырьковая сортировка, показанная в задаче. Она обмениваем местами в списке команды i и i + 1, если у команды i + 1 больше решенных задач. Если же команды решили одинаковое количество задач, то их относительный порядок не меняется. Следовательно, мы должны выполнить сортировку таким образом, чтобы сохранить этот относительный порядок. Вообще такое свойство сортировки называется стабильностью.\u003c/p\u003e\u003cp\u003eВ Java есть методы сортировки sort() в классах Arrays (сортировка массивов) и Collections (сортировка списков). Приходится отметить, что оба этих метода не лишены проблем. Так, несмотря на то, что \u0026quot;в среднем\u0026quot; Arrays.sort() работает за порядка O(n log n) шагов, можно подобрать тесты, на которых он будет работать за количество шагов порядка O(n^2). Метод сортировки из класса Collections на некоторых входных данных давал ошибку ArraysOutOfBoundExceptions. Вместе с тем следует отметить, что существует негласная договоренность не добавлять в олимпиадные задачи такие тесты специально (бороться же с такими тестами можно, выполнив предварительно дополнительное небольшое перемешивание данных).\u003c/p\u003e\u003cp\u003eВ описании этих методов в документации Java говорится, что они стабильны и не переупорядочивают элементы, считающиеся равными. Значит, если мы будем сравнивать команды только по количеству решенных задач, то получим нужный ответ.\u003c/p\u003e\u003cp\u003eМожно описать класс команды, содержащий два поля: идентификатор команды (целое число, ID) и количество решенных задач (целое число, M), реализовать в нем интерфейс Comparable, и в методе compareTo() производить сравнение только по количеству задач. Этот метод и обеспечит нужную сортировку при вызове метода sort().\u003c/p\u003e\u003cp\u003eОднако \u0026quot;подводным камнем\u0026quot; в этой задаче является достаточно большой объем входных и выходных данных. Дело в том, что Scanner фактически выполняет распознавание вводимых данных, а это процесс медленный. Кроме того, он делает это поэлементно. Также поэлементно происходит вывод данных посредством System.out.println(). Что с этим делать — будет описано в отдельной записи, посвященной \u0026quot;быстрому\u0026quot; вводу и выводу данных: такая проблема возникает не только для этой задачи (хотя из списка в этой записи — только для этой; так что если Ваше решение упало примерно на 11 тесте с Time Limit Exceeded, то, вероятно, Вам потребуется внести только изменения в чтение данных и печать результата).\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cbr /\u003e Задача 1161. \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1161\"\u003eStripies\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПодсказка\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eПостараемся понять, как можно получить минимальный результирующий вес колонии полосатиков. Два полосатика объединяются в одного с весом 2 cdot sqrt{m_1 cdot m_2}, если получившегося полосатика объединить с каким-то еще, то вес будет уже 2 cdot sqrt{m_3 cdot 2 cdot sqrt{m_1 cdot m_2}} (и т.д.)\u003c/p\u003e\u003cp\u003eНам \u0026quot;выгодно\u0026quot; извлекать корень как можно большее количество раз из большего числа (чтобы как можно больше его уменьшить). Это значит, что для получения минимально возможного результирующего веса колонии следует каждый раз выбирать двух самых тяжелых полосатиков.\u003c/p\u003e\u003cp\u003eЗаметим, что для чисел m_1 и m_2 число sqrt{m_1 cdot m_2} является средним геометрическим и имеет величину в диапазоне между минимумом и максимумом из этих двух чисел. Значит, если мы упорядочим полосатиков по весу, то, когда мы выберем двух самых тяжелых из них и заменим их на одного, этот один будет (в том числе и за счет умножения среднего геометрического на 2) тяжелее, чем самый легкий из выбранных, и тяжелее, чем любой из оставшихся. Следовательно, мы можем поместить этого нового полосатика на последнее место в списке и объединять с ним уже следующего по весу. Процесс продолжается, пока не останется один-единственный полосатик.\u003c/p\u003e\u003cp\u003eТаким образом, мы можем \u0026quot;сложить\u0026quot; всех полосатиков в ArrayList, отсортировать его, а затем пройти от конца к началу, попарно объединяя самых тяжелых полосатиков.\u003c/p\u003e\u003cp\u003eМожно подойти к задаче и более формально. Если бы функция, описывающая вес полосатика, получающегося в результате объединения двух полосатиков, имела бы не столь простой вид (в частности, не было бы очевидно, что полосатик, получившийся в результате объединения, является самым тяжелым), следовало бы воспользоваться структурой данных TreeSet. Эта структура данных фактически сортирует свое содержимое при добавлении или удалении каждого элемента. Поэтому \u0026quot;общий подход\u0026quot; состоит в следующем: \u003cbr /\u003e - проверяем, что в TreeSet содержится более одного элемента; \u003cbr /\u003e - с помощью метода pollLast() удаляем из TreeSet сначала самого тяжелого полосатика, потом второго по весу; \u003cbr /\u003e - выполняем объединение полосатиков (вычисляем массу объединенного); \u003cbr /\u003e - помещаем полученное значение в TreeSet (помня, что TreeSet поддерживает упорядоченность элементов) \u003cbr /\u003e - повторяем описанные выше действия, пока в TreeSet не останется один элемент — это и есть минимально возможный результирующий вес колонии.\u003c/p\u003e\u003cp\u003eПредставляется, что написание второго \u0026quot;общего\u0026quot; решения является полезным упражнением, которое следует выполнить.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cbr /\u003e Задача 1106. \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1106\"\u003eДве команды\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПодсказка\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eСначала постараемся понять, как надо делить людей на команды. Рассмотрим товарища #1. Отправим его в первую команду, а всех его друзей — во вторую. Поскольку отношение дружбы взаимно, то для этой подгруппы товарищей будет выполнено требование \u0026quot;у каждого человека должен быть друг в другой команде\u0026quot;. Теперь рассмотрим кого-то из списка первого товарища (для определенности — того друга, который упомянут в его списке первым). Всех друзей этого товарища (первого друга) будем отправлять уже в первую команду: так мы вновь обеспечим требование наличия друга в другой команде. Конечно, может оказаться, что некоторые из друзей этого товарища уже включены в какую-то из команд, но если это так — то это сделано с соблюдением условия задачи, и беспокоиться об этом не нужно. Нужно только обеспечить корректность: каждый человек может быть включен только в одну команду. Повторить этот процесс следует для каждого человека. Если этот человек уже включен в какую-то команду, то его друзей мы должны отправить в \u0026quot;противоположную\u0026quot;; если нет — включить его в любую команду. Заметим, однако, что разрывать цепочку нельзя. Действительно, представим отношения в группе в виде графа. Тогда можно сказать, что мы должны вычерпывать одну за другой компоненты связности. И, когда какая-то вершина компоненты связности была приписана к некоторой команде, нам придется соблюсти требование задачи для всех остальных вершин. Если же мы исчерпали некоторую компоненту связности и перешли к следующей, то мы вольны в выборе команды для первого рассматриваемого в ней человека.\u003c/p\u003e\u003cp\u003eКак для обеспечения корректности, так и для хранения текущих списков команд хорошо подойдет структура данных TreeSet. При добавлении в команду очередного участника следует проверить, не входит ли он уже в (другую) команду.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cbr /\u003e Задача 2002. \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d2002\"\u003eТестовое задание\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПодсказка\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eВ этой задаче нужно аккуратно прочитывать и анализировать строки: сначала определять команду (register, login, logout), затем имя пользователя и (если есть) пароль. Структуры данных нужны для контроля за текущим составом зарегистрированных пользователей (можно написать свой класс, содержащий два строковых поля: имя пользователя и пароль, и хранить объекты этого класса в TreeSet; можно воспользоваться TreeMap), а также для контроля за пользователями, которые находятся в системе (здесь достаточно хранить только имена, поэтому можно обойтись TreeSet).\u003c/p\u003e\u003cp\u003eВ остальном задача чисто реализационная (if/switch по вкусу).\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cbr /\u003e Задача 1126. \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1126\"\u003eМагнитные бури\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПодсказка\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eВ этой задаче нужно воспользоваться либо PriorityQueue, либо TreeSet (в таком же качестве): нам необходима структура, которая сумеет за относительно быстрое время сообщать максимум на текущем отрезке.\u003c/p\u003e\u003cp\u003eВозможно, окажется полезной мысль, что не все элементы прошедших отрезков времени обязательно сразу же удалять.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cbr /\u003e Задача 1795. \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1795\"\u003eМужья в магазине\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПодсказка\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eВ этой задаче нужно \u0026quot;просто\u0026quot; воспользоваться стандартными структурами данных. А в целом — из серии \u0026quot;сделай, что написано\u0026quot;.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cbr /\u003e Задача 1889. \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1889\"\u003eОбъявление в аэропорту\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПодсказка\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eВ этой задаче также нужно \u0026quot;просто\u0026quot; воспользоваться стандартными структурами данных. Впрочем, по сравнению с предыдущей задачей, в этой придётся немного поразмышлять.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["java","collections"]}}