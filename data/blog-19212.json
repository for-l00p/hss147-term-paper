{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1436895861,"rating":96,"authorHandle":"HardW3ll","modificationTimeSeconds":1436952574,"id":19212,"title":"\u003cp\u003eCodeforces Round #312 (Div. 2) Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/558/problem/A\" title\u003d\"Codeforces Round 312 (Div. 2)\"\u003e558A - Lala Land and Apple Trees\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLet\u0027s divide all the trees into two different groups, trees with a positive position and trees with a negative position. Now There are mainly two cases:\u003c/p\u003e \u003col\u003e   \u003cli\u003eIf the sizes of the two groups are equal. Then we can get all the apples no matter which direction we choose at first.\u003c/li\u003e   \u003cli\u003eIf the size of one group is larger than the other. Then the optimal solution is to go to the direction of the group with the larger size. If the size of the group with the smaller size is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e then we can get apples from all the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e apple trees in it, and from the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e + 1\u003c/span\u003e trees in the other group.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eSo we can sort each group of trees by the absolute value of the trees position and calculate the answer as mentioned above.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eTime complexity:\u003c/strong\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bf/50/bf50fe8dec6136c862e5438af39c14bfd5bcf665.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/3zzpsd\"\u003e\u003cstrong\u003eImplementation\u003c/strong\u003e\u003c/a\u003e .\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/558/problem/B\" title\u003d\"Codeforces Round 312 (Div. 2)\"\u003e558B - Amr and The Large Array\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eFirst observation in this problem is that if the subarray chosen has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e as a value that has the maximum number of occurrences among other elements, then the subarray should be \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ex\u003c/i\u003e, ..., \u003ci\u003ex\u003c/i\u003e]\u003c/span\u003e. Because if the subarray begins or ends with another element we can delete it and make the subarray smaller.\u003c/p\u003e\u003cp\u003eSo, Let\u0027s save for every distinct element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e in the array three numbers, the smallest index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, the largest index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and the number of times it appears in the array. And between all the elements that has maximum number of occurrences we want to minimize \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e (i.e. the size of the subarray).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eTime complexity:\u003c/strong\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1d/c7/1dc7b07a2d137b865cf893b72a8c1a93a91b0c1f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/QNw51a\"\u003e\u003cstrong\u003eImplementation\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/558/problem/C\" title\u003d\"Codeforces Round 312 (Div. 2)\"\u003e558C - Amr and Chemistry\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLet the maximum number in the array be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/span\u003e. Clearly, changing the elements of the array to any element larger than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/span\u003e won\u0027t be optimal, because the last operation is for sure multiplying all the elements of the array by two. And not doing this operation is of course a better answer.\u003c/p\u003e\u003cp\u003eNow we want to count the maximum number of distinct elements that can be reached from some element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e that are not larger than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/span\u003e. Consider an element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e that has a zero in the first bit of its binary representation. If we divided the number by two and the multiplied it by two we will get the original number again. But if it has a one, the resulting number will be different. So, for counting the maximum number of distinct elements we will assume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e has only ones in its binary representation.\u003c/p\u003e\u003cp\u003eFrom \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e we can only reach elements that have a prefix of ones in its binary representation, and the other bits zeros (e.g. \u003cspan class\u003d\"tex-span\"\u003e{0, 1, 10, 11, 100, 110, 111, 1000, ...}\u003c/span\u003e ). Let\u0027s assume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/span\u003e has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e bits in its binary representation, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e can reach exactly \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/57/f5/57f530b1f44b5f37cfd65bc44fd1ea6053198d6e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e distinct elements. So, from each element in the array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e we can reach at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/57/f5/57f530b1f44b5f37cfd65bc44fd1ea6053198d6e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e elements.\u003c/p\u003e\u003cp\u003eSo, Let\u0027s generate the numbers that can be reached from each element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e using bfs to get minimum number of operations. And between all the numbers that are reachable from all the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e elements let\u0027s minimize the total number of operations.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eTime complexity:\u003c/strong\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/dd/08/dd088dec9e2dc46ed5c7c8ab1103c4dd847ed59d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/9wXvKz\"\u003e\u003cstrong\u003eImplementation\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/558/problem/D\" title\u003d\"Codeforces Round 312 (Div. 2)\"\u003e558D - Guess Your Way Out! II\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eFirst, each query in the level \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e can be transmitted into level \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e * 2\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e * 2 + 1\u003c/span\u003e, so, we can transform each query to the last level.\u003c/p\u003e\u003cp\u003eLet\u0027s maintain a set of correct ranges such that the answer is contained in one of them. At the beginning we will assume that the answer is in the range \u003cspan class\u003d\"tex-span\"\u003e[2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eh\u003c/i\u003e - 1\u003c/sup\u003e, 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/sup\u003e - 1]\u003c/span\u003e inclusive. Now Let\u0027s process the queries. If the query\u0027s answer is yes, then we want to get the intersection of this query\u0027s range with the current set of correct ranges, and update the set with the resulting set. If the query\u0027s answer is no, we want to exclude the query\u0027s range from the current set of correct ranges, and update the set with the resulting set.\u003c/p\u003e\u003cp\u003eAfter we finish processing the queries, if the set of correct ranges is empty, then clearly the game cheated. Else if the set has only one correct range \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e]\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e \u003d \u003ci\u003eR\u003c/i\u003e\u003c/span\u003e then we\u0027ve got an answer. Otherwise there are multiple exit candidates and the answer can\u0027t be determined uniquely using the current data.\u003c/p\u003e\u003cp\u003eWe will have to use stl::set data structure to make updating the ranges faster. In each yes query we delete zero or more ranges. In each no query we may add one range if we split a correct range, so worst case will be linear in queries count.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eTime complexity:\u003c/strong\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c4/44/c4444e9a86a8aa2831adc1202b3d00a20224f30d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/s8HPBx\"\u003e\u003cstrong\u003eImplementation\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/558/problem/E\" title\u003d\"Codeforces Round 312 (Div. 2)\"\u003e558E - A Simple Task\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eIn this problem we will be using \u003ca href\u003d\"https://en.wikipedia.org/wiki/Counting_sort\"\u003ecounting sort\u003c/a\u003e. So for each query we will count the number of occurrences for each character, and then update the range like this\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor(int j\u003dx;j\u0026lt;\u003dy;j++)\n  cnt[s[j] - \u0027a\u0027]++;\nind \u003d 0;\nfor(int j\u003dx;j\u0026lt;\u003dy;j++)\n{\n  while(cnt[ind] \u003d\u003d 0)\n    ind++;\n  s[j] \u003d ind + \u0027a\u0027;\n  cnt[ind]--;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut this is too slow. We want a data structure that can support the above operations in appropriate time.\u003c/p\u003e\u003cp\u003eLet’s make 26 segment trees each one for each character. Now for each query let’s get the count of every character in the range, and then arrange them and update each segment tree with the new values. We will have to use lazy propagation technique for updating ranges.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eTime complexity:\u003c/strong\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ba/f3/baf3eb5aa8dee7d28fa4df5c18fee380f7b4d5ed.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e where sz is the size of the alphabet (i.e. \u003d 26).\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/wHwvnU\"\u003e\u003cstrong\u003eImplementation\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["codeforces round 312"]}}