{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1500478425,"rating":0,"authorHandle":"metatron","modificationTimeSeconds":1500562942,"id":53385,"title":"\u003cp\u003eProblemes d\u0027Exemple\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eGirant una llista de paraules (1)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nvoid llegeix() {\n\tstring s;\n\tif(cin \u0026gt;\u0026gt; s){\n\t\tllegeix();\n\t\tcout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl;\n\t}\n}\n\nint main() {\n\tllegeix();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTorres de Hanoi\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nvoid hanoi(int n, char from, char to, char aux) {\n\tif(n \u003d\u003d 0) return;\n\thanoi(n-1, from, aux, to);\n\tcout \u0026lt;\u0026lt; from \u0026lt;\u0026lt; \u0026quot; \u003d\u0026gt; \u0026quot; \u0026lt;\u0026lt; to \u0026lt;\u0026lt; endl;\n\thanoi(n-1, aux, to, from);\n}\n\nint main() {\n\tint n;\n\tcin \u0026gt;\u0026gt; n;\n\thanoi(n, \u0027A\u0027, \u0027C\u0027, \u0027B\u0027);\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eFiles i columnes\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n\nusing namespace std;\n\n\nint main(){\n\tint n, m;\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tvector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; taula(n, vector\u0026lt;int\u0026gt;(m));\n\tfor (int i \u003d 0; i \u0026lt; n; ++i){\n\t\tfor (int j \u003d 0; j \u0026lt; m; ++j) cin \u0026gt;\u0026gt; taula[i][j];\n\t}\n\t\n\tstring s;\n\tint i;\n\twhile (cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; i){\n\t\tif (s \u003d\u003d \u0026quot;fila\u0026quot;){\n\t\t\tcout \u0026lt;\u0026lt; \u0026quot;fila \u0026quot; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027:\u0027;\n\t\t\tfor (int j \u003d 0; j \u0026lt; m; ++j) cout \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; taula[i-1][j];\n\t\t\tcout \u0026lt;\u0026lt; endl; \n\t\t}\n\t\telse if (s \u003d\u003d \u0026quot;element\u0026quot;){\n\t\t\tint j;\n\t\t\tcin \u0026gt;\u0026gt; j;\n\t\t\tcout \u0026lt;\u0026lt; \u0026quot;element \u0026quot; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026quot;: \u0026quot; \u0026lt;\u0026lt; taula[i-1][j-1] \u0026lt;\u0026lt; endl;\n\t\t}\n\t\telse{\n\t\t\tcout \u0026lt;\u0026lt; \u0026quot;columna \u0026quot; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027:\u0027;\n\t\t\tfor (int j \u003d 0; j \u0026lt; n; ++j) cout \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; taula[j][i-1];\n\t\t\tcout \u0026lt;\u0026lt; endl;\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eOrdenació\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eEn aquest cas el criteri d\u0027ordenació consisteix a posar primer els parells ordenats de petit a gran i després els senars de gran a petit.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n\nusing namespace std;\n\nbool compara(const int\u0026amp; a, const int\u0026amp; b) {\n\tif(a%2 \u003d\u003d 0 and b%2 !\u003d 0) return true;\n\tif(a%2 !\u003d 0 and b%2 \u003d\u003d 0) return false;\n\tif(a%2 \u003d\u003d 0 and b%2 \u003d\u003d 0) return a \u0026lt; b;\n\treturn a \u0026gt; b;\n\t\n\t/*if(a%2 \u003d\u003d 0 and b%2 \u003d\u003d 0) {\n\t\tif(a \u0026lt; b) return true;\n\t\treturn false;\n\t}\n\tif(a \u0026gt; b) return true;\n\treturn false;*/\n}\n\nint main() {\n\tint n;\n\twhile(cin \u0026gt;\u0026gt; n) {\n\t\tvector\u0026lt;int\u0026gt; v(n);\n\t\tfor (int i \u003d 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; v[i];\n\t\tsort(v.begin(),v.end(), compara);\n\t\tfor (int i \u003d 0; i \u0026lt; n; ++i) cout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; \u0027 \u0027;\n\t}\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eBinària\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n\nusing namespace std;\n\n\nint main(){\n\tint n;\n\tcin \u0026gt;\u0026gt; n;\n\tvector\u0026lt;int\u0026gt; v(n);\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; v[i];\n\tsort(v.begin(), v.end());\n\tint x;\n\twhile (cin \u0026gt;\u0026gt; x){\n\t\tint l \u003d 0, r \u003d v.size(); //cota inferior inclusiva, cota superior exclusiva\n\t\twhile (r-l !\u003d 1){\n\t\t\tint mid \u003d (l+r)/2;\n\t\t\tif (v[mid] \u0026lt;\u003d x) l \u003d mid;\n\t\t\telse r \u003d mid;\n\t\t}\n\t\tif (v[l] \u003d\u003d x) cout \u0026lt;\u0026lt; \u0026quot;Hi es\u0026quot; \u0026lt;\u0026lt; endl;\n\t\telse cout \u0026lt;\u0026lt; \u0026quot;No hi es\u0026quot; \u0026lt;\u0026lt; endl;\n\t}\n\t\n\t\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eGarbell d\u0027Eratostenes\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n\nusing namespace std;\n\n\nint main() {\n\tint N \u003d 1000001;\n\tvector\u0026lt;bool\u0026gt; primer(N, true);\n\tprimer[0] \u003d primer[1] \u003d false;\n\tfor (int i \u003d 2; i*i \u0026lt; N; ++i) {\n\t\tif (primer[i]) {\n\t\t\tfor (int j \u003d 2*i; j \u0026lt; N; j +\u003d i) primer[j] \u003d false;\n\t\t}\n\t}\n\tint n;\n\twhile(cin \u0026gt;\u0026gt; n) {\n\t\tfor(int i \u003d 0; i \u0026lt; n; ++i) if(primer[i]) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl;\n\t}\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eFibonacci: Dinmica\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n\nusing namespace std;\n\nint fib(int n, vector\u0026lt;int\u0026gt;\u0026amp; v) {\n\tif(n \u003d\u003d 0 or n \u003d\u003d 1) v[n] \u003d n;\n\telse if(v[n] \u003d\u003d -1) v[n] \u003d fib(n-1, v) + fib(n-2, v);\n\treturn v[n];\n}\n\nint main() {\n\tint n;\n\twhile(cin \u0026gt;\u0026gt; n){\n\t\tvector\u0026lt;int\u0026gt; v(n+1, -1);\n\t\tcout \u0026lt;\u0026lt; fib(n, v) \u0026lt;\u0026lt; endl;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSome sequences of bits(1): Dinamica\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n\nusing namespace std;\n\ntypedef long long ll;\n\nll sol(int n, int tipus, vector\u0026lt;vector\u0026lt;ll\u0026gt; \u0026gt; \u0026amp;dp) {\n\tif (n \u003d\u003d 2) return 1;\n\tif (dp[tipus][n] \u003d\u003d -1){\n\t\tif (tipus \u003d\u003d 0) dp[tipus][n] \u003d sol(n-1, 1, dp) + sol(n-1, 2, dp);\n\t\telse if (tipus \u003d\u003d 1) dp[tipus][n] \u003d sol(n-1, 2, dp);\n\t\telse dp[tipus][n] \u003d sol(n-1, 0, dp);\n\t}\n\treturn dp[tipus][n];\n}\n\nint main() {\n\tint n;\n\tvector\u0026lt;vector\u0026lt;ll\u0026gt; \u0026gt; dp(3, vector\u0026lt;ll\u0026gt;(151,-1));\n\twhile(cin \u0026gt;\u0026gt; n){\n\t\tif (n \u003d\u003d 0) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl;\n\t\telse if (n \u003d\u003d 1) cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; endl;\n\t\telse cout \u0026lt;\u0026lt; sol(n, 0, dp) + sol(n, 1, dp) + sol(n, 2, dp) \u0026lt;\u0026lt; endl;\n\t\t\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}