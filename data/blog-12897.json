{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1404127876,"rating":0,"authorHandle":"adiko2008","modificationTimeSeconds":1404135024,"id":12897,"title":"\u003cp\u003eРазбор дня №7 (01.07.2014)\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eA. Игра с тарелками\u003c/h3\u003e\u003cp\u003eПервый игрок выигрывает почти всегда: ему достаточно положить тарелку в центр, а затем повторять ходы второго симметрично относительно центра. Таким образом, второй игрок выигрывает, только если первая же тарелка не помещается. \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003ch3\u003eB. Стол для переговоров\u003c/h3\u003e\u003cp\u003eЗаведём булевский массив \u003ccode\u003edp[i][j][x][y]\u003c/code\u003e. (true, если прямоугольник с левым верхним углом i, j и правым нижним x, y нельзя занять столом, и false иначе). Тогда переход будет таким:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003edp[i][j][x][y] \u003d dp[i][j][x - 1][y] || dp[i][j][x][y - 1] || a[x][y] \u003d\u003d \u00271\u0027;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДалее просто перебираем весь массив и находим наибольший периметр.\u003c/p\u003e\u003ch3\u003eC. Теплица\u003c/h3\u003e\u003cp\u003eОчевидно, что на координаты можно не обращать внимания. Пусть какие-то растения мы перемещаем, тогда оставшиеся на местах уже должны образовывать неубывающую последовательность. Таким образом, надо просто найти наидлиннейшую неубывающую последовательность. Для этого заведём массив \u003ccode\u003edp[i][j]\u003c/code\u003e — максимальная длина такой последовательности на отрезке с 1 по i-й элемент и оканчивающаяся на элемент со значением j. В частности, \u003ccode\u003edp[1][a[1]] \u003d 1\u003c/code\u003e. Переход такой:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eif (a[i] \u003d\u003d j) dp[i][j] \u003d max(dp[i-1][1], dp[i-1][2], dp[i-1][3], ..., dp[i-1][j]) + 1\nelse dp[i][j] \u003d dp[i-1][j];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОтветом будет \u003ccode\u003en - max(dp[n][1], dp[n][2], dp[n][3], ..., dp[n][m])\u003c/code\u003e.\u003c/p\u003e\u003ch3\u003eD. Тренировка\u003c/h3\u003e\u003cp\u003eЗаведём 4 массива вида \u003ccode\u003edp[i][j]\u003c/code\u003e — максимальная выгода тренировки, которую можно получить при попадании в клетку (i, j), если идти из клетки (1, 1). (Остальные три массива на три других угла.) Переход будет таким:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003edp[i][j] \u003d max(dp[i-1][j], dp[i][j-1]) + a[i][j];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДля трёх остальных массивов аналогично. Теперь переберём все клетки, в которых Яхуб и Яхубина могли встретиться. (Все, кроме крайних.) Для каждой такой клетки возможны две ситуации:\u003cbr /\u003e 1) Яхуб пришёл слева и пойдёт направо, Яхубина пришла снизу и пошла вверх;\u003cbr /\u003e 2) Яхуб пришёл сверху и пойдёт вниз, Яхубина пришла слева и пойдёт вправо.\u003cbr /\u003e В каждом случае искомая выгодность будет равна сумме четырёх элементов из четырёх разных массивов. Перебором и находим максимум.\u003c/p\u003e\u003ch3\u003eE. Династические головоломки\u003c/h3\u003e\u003cp\u003eЗаведём массив \u003ccode\u003edp[c1][c2]\u003c/code\u003e — наидлиннейшее название династии, начинающееся с символа c1 и оканчивающееся символом c2. Переход таков: пусть мы считали слово, начинающееся на символ x и оканчивающееся символом y длиной len, тогда\u003c/p\u003e \u003cpre\u003e\u003ccode\u003edp[x][y] \u003d max(dp[x][y], len);\nfor i \u003d \u0027a\u0027..\u0027z\u0027\n    if (dp[i][y] !\u003d 0)\n       dp[i][y] \u003d max(dp[i][y], dp[i][x] + len);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОтветом будет \u003ccode\u003emax(dp[\u0027a\u0027][\u0027a\u0027], dp[\u0027b\u0027][\u0027b\u0027], dp[\u0027c\u0027][\u0027c\u0027], ..., dp[\u0027z\u0027][\u0027z\u0027])\u003c/code\u003e\u003c/p\u003e\u003ch3\u003eF. Счастливая общая подпоследовательность\u003c/h3\u003e\u003cp\u003eЗадача похожа на нахождение наибольшей общей подпоследовательности. Только здесь вместо\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eif (a[i] \u003d\u003d b[j])\n    dp[i][j] \u003d max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + 1);\nelse\n    dp[i][j] \u003d max(dp[i-1][j], dp[i][j-1]);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eбудет\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eif (a[i] \u003d\u003d b[j])\n    if (a[i] \u003d\u003d virus[k+1] \u0026amp;\u0026amp; dp[i-1][j-1][k] + 1 \u0026gt; dp[i-1][j][k] \u0026amp;\u0026amp; dp[i-1][j-1][k] + 1 \u0026gt; dp[i][j-1][k])\n        dp[i][j][k+1] \u003d dp[i-1][j-1][k] + 1;\n...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗдесь параметр k — сколько подряд идущих первых букв вируса мы набрали.\u003c/p\u003e\u003ch3\u003eG. Штрихкод\u003c/h3\u003e\u003cp\u003eРазбор по ссылке \u003ca href\u003d\"http://codeforces.ru/blog/entry/5322\"\u003ehttp://codeforces.ru/blog/entry/5322\u003c/a\u003e. Там это задача C.\u003c/p\u003e\u003c/div\u003e","tags":[]}}