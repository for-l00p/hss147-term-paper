{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1412706850,"rating":1,"authorHandle":"Enchom","modificationTimeSeconds":1416257532,"id":14162,"title":"\u003cp\u003ePolly Training #2 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003e\u003cstrong\u003eA. Game\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eТази задача не изисква никаква теория, а по-скоро прости наблюдения. Губещата позиция е {1;1}. В нея имаме две нечетни числа. Да допуснем, че на наш ход имаме поне едно четно. То тогава можем да изберем него и да го разбием на две нечетни, водейки противника си в позиция с две нечетни. Да забележим също, че от позиция с две нечетни със сигурност се отива в позиция с поне едно четно. От тези наблюдения следва, че ако има две нечетни числа, то това е губеща позиция. В противен случай е печеливша. Трябва да се внимава да се спази формата на изхода.\u003c/p\u003e\u003cp\u003eРешението има сложност O(1).\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003eB. Crops\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eТова беше задача от IOI 2011, решена от 113 човека. Задачата позволява няколко решения, които се базират на наблюдения и сметки.\u003c/p\u003e\u003cp\u003eПървото очевидно наблюдение е, че множеството от ниви, чиято реколта ще събираме, е непрекъснат интервал. Знаейки това възниква важната част от задачата. Нека X[i] е мястото на i-тата нива. Ако сме избрали да вземем реколтата от нивите L,L+1,...,R, то трябва да можем бързо да избираме най-доброто място за склада.\u003c/p\u003e\u003cp\u003eТвърдение : Склада трябва да е на медианата на нивите. Тоест, ако (R-L+1) е нечетно то склада трябва да е на (L+R)/2 — та нива (средната нива), а ако е четно то склада може да е където и да е между (L+R)/2 — та и (L+R)/2+1 — та нива (между средните две ниви или в тях).\u003c/p\u003e\u003cp\u003eДоказателство : Да допуснем, че склада не е на гореописаната позиция. То тогава от едната му страна ще има повече ниви от колкото от другата. Премествайки го с единица растояние в посоката на повечето ниви намаляме цената — следователно такава позиция не може да е оптимална.\u003c/p\u003e\u003cp\u003eВ такъв случай можем за O(1) да открием оптималната позиция на склада по даден интервал [L;R] от ниви. Нека разгледаме как можем да сметнем цената в такъв случай. Нека склада е на позиция K, а нивите съответно на X[L],X[L+1]..., и нека нивата M e първата нива отляво на склада. Получаваме :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ecost \u003d (K-X[L]) + (K-X[L+1]) + ... + (K-X[M]) + (X[M+1]-K) + ... + (X[R]-K) \u003d\n\u003d (M-L+1)*K - Sum(L,M) + Sum(M+1,R) - (R-M)*K\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSum(A,B) — сумата от кординатите на нивите от нива A до нива B. Можем да имплементираме горната формула за O(1) чрез префиксни суми.\u003c/p\u003e\u003cp\u003eОказва, че за фиксиран интервал от ниви [L;R] можем за O(1) да намерим минималната цена, за която можем да вземем реколтата от тези ниви. Това води до две решения :\u003c/p\u003e\u003cp\u003e1) Фиксираме всяка нива като начало и правим двуично търсене по края на интервала. Решението е със сложност O(NlogN).\u003c/p\u003e\u003cp\u003e2) Използваме \u0026quot;Two-pointer walk\u0026quot; техника като обхождаме масива с два пойнтера за начало и край опитвайки се във всеки един момент текущият интервал да е максимално дълъг. Решението е със сложност O(N).\u003c/p\u003e\u003cp\u003eИ двете решения взимат максимален брой точки.\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003eC. Tree\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eТова всъщност бе моя задача комбинираща две интересни техники — offline обработка на заявки, и растояния в дърво.\u003c/p\u003e\u003cp\u003eНека първо покажем как можем да отговаряме на зявките за растояние между два върха. Нужна ни е единствено формулата :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eDist(A,B) \u003d Depth(A) + Depth(B) - 2*Depth( LCA(A,B) )\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДълбочините на върховете могат да бъдат намерени за O(N), а LCA може да бъде смятано за O(1) след O(NlogN) precompute.\u003c/p\u003e\u003cp\u003eТова е по-простата част от задачата. Правейки това можем да отговаряме на заявките за растояние за O(1). Очевидно е, че премахвайки ребра е възможна пътят между два върха да изчезне, но не и да измени дължината си. Затова трябва да намерим начин да проверяваме дали между два върха има път и да поддържаме структура махаща ребра. Очевидно union-find не би проработил, а и като цяло лесна структура правеща това online не ми е известна.\u003c/p\u003e\u003cp\u003eНека използваме следният трик — построяваме дървото както си е на вход и минаваме през всички заявки за махане на ребро като ги изпълняваме — махаме реброто. След това обръщаме реда на заявките и всяка заявка за махане третираме като заявка за добавяне на това ребро. Това вече можем да поддържаме с union-find. По този начин вървим от бъдещите заявки към сегащните и обръщаме махането в добяване.\u003c/p\u003e\u003cp\u003eСложността на целият алгоритъм се доминира от precomputing-а на LCA — O(NlogN).\u003c/p\u003e\u003c/div\u003e","tags":[]}}