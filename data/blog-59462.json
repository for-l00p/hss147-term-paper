{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1526322231,"rating":37,"authorHandle":"htoj","modificationTimeSeconds":1526561055,"id":59462,"title":"\u003cp\u003eCodeforces Round #482 (Div. 2) Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi Codeforces!\u003c/p\u003e\u003cp\u003eThis is the editorial of \u003ca href\u003d\"/contest/979\" title\u003d\"Codeforces Round 482 (Div. 2)\"\u003eCodeforces Round #482 (Div. 2)\u003c/a\u003e. I hope you guys enjoy it.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/979/problem/A\" title\u003d\"Codeforces Round 482 (Div. 2)\"\u003e979A - Pizza, Pizza, Pizza!!!\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 0\u003c/span\u003e, the answer is obviously \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + 1\u003c/span\u003e is even, we can make \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/61/d6/61d65f09c05374157c6476aa2a452d84f864825b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e diametric cuts. Otherwise, the only way is to make \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + 1\u003c/span\u003e cuts.\u003c/p\u003e\u003cp\u003eTime complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;stdio.h\u0026gt;\nusing namespace std;\n\nlong long n;\n\nint main()\n{\n    scanf(\u0026quot;%I64d\u0026quot;, \u0026amp;n);\n    n++;\n    if (n \u003d\u003d 1) printf(\u0026quot;0\u0026quot;); else if (n % 2 \u003d\u003d 0) printf(\u0026quot;%I64d\u0026quot;, n / 2); else printf(\u0026quot;%I64d\u0026quot;, n);\n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/979/problem/B\" title\u003d\"Codeforces Round 482 (Div. 2)\"\u003e979B - Treasure Hunt\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eWe all knew that the substrings with length \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e appear at most in the string. So, to make a string as beautiful as possible, we will choose the letter that firstly appears at most in the string and replace all the other letters with the chosen letter.\u003c/p\u003e\u003cp\u003eThere is some cases. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is less than or equal to the number of remaining letters, just add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e to the beauty. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is even after replacing all letters with the chosen, we can choose an arbitrary letter, replace it with some other letter, return it back and repeat the work till \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e reach \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. Otherwise, we will not replace all the other letters. Instead, we will replace the letters until there is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e letter left (now \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is even) then replace that one with another letter different from our chosen letter. After that, replace that letter with our chosen letter. Now \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is even again, we repeat the work discussed above.\u003c/p\u003e\u003cp\u003eIn conclusion, let\u0027s call our string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, our chosen letter \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and its number of occurrences in the string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, then our answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003en\u003c/i\u003e, |\u003ci\u003es\u003c/i\u003e|)\u003c/span\u003e. Be careful with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTime complexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/05/f9/05f9517bdc7cc8a047b6093876e0980181d4f7a1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/24/ee/24ee03e3e3bded5aef5f15ac10ba5b60d15cc9e5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is the total length of the three strings.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint a[256], b[256], c[256], n, ma, mb, mc;\nstring p, q, r;\n\nint main() {\n      cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p \u0026gt;\u0026gt; q \u0026gt;\u0026gt; r;\n      for (char x: p) ma \u003d max(ma, ++a[x]);\n      for (char x: q) mb \u003d max(mb, ++b[x]);\n      for (char x: r) mc \u003d max(mc, ++c[x]);\n      if (n \u003d\u003d 1 \u0026amp;\u0026amp; ma \u003d\u003d (int)p.length()) p.pop_back();\n      if (n \u003d\u003d 1 \u0026amp;\u0026amp; mb \u003d\u003d (int)q.length()) q.pop_back();\n      if (n \u003d\u003d 1 \u0026amp;\u0026amp; mc \u003d\u003d (int)r.length()) r.pop_back();\n      ma \u003d min(ma + n, (int)p.length());\n      mb \u003d min(mb + n, (int)q.length());\n      mc \u003d min(mc + n, (int)r.length());\n      if (ma \u0026gt; mb \u0026amp;\u0026amp; ma \u0026gt; mc) {\n            puts(\u0026quot;Kuro\u0026quot;);\n            return 0;\n      }\n      if (mb \u0026gt; ma \u0026amp;\u0026amp; mb \u0026gt; mc) {\n            puts(\u0026quot;Shiro\u0026quot;);\n            return 0;\n      }\n      if (mc \u0026gt; ma \u0026amp;\u0026amp; mc \u0026gt; mb) {\n            puts(\u0026quot;Katie\u0026quot;);\n            return 0;\n      }\n      puts(\u0026quot;Draw\u0026quot;);\n      return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/979/problem/C\" title\u003d\"Codeforces Round 482 (Div. 2)\"\u003e979C - Kuro and Walking Route\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eWe can consider the city as a graph, in which every town is a vertex and every road connecting two towns is an edge. Since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e \u0026lt; \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, we can deduce that this graph is a tree. Now, instead of finding the number of pairs that Kuro can choose, we can find the number of pairs that Kuro cannot choose. In other words, we must find the number of pairs of vertices \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e, in which the shortest path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e passes through \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and then through \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. But how can we do this?\u003c/p\u003e\u003cp\u003eIf we take vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e as the root of the tree, we can see that every pair of vertices that Kuro cannot choose begins from any node within the subtree of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, and finishes at any node but within the subtree of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e, which \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e is a direct child of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e lying on the shortest path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. In total, the number of pairs of vertices that we are looking for is equal of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e·(\u003ci\u003en\u003c/i\u003e - 1) - \u003ci\u003es\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e]·(\u003ci\u003es\u003c/i\u003e[\u003ci\u003ey\u003c/i\u003e] - \u003ci\u003es\u003c/i\u003e[\u003ci\u003ez\u003c/i\u003e])\u003c/span\u003e, which \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e denotes the size of the subtree of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. We can implement this using simple DFS.\u003c/p\u003e\u003cp\u003eTime complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;vector\u0026gt;\nusing namespace std;\n\nconst int MAXN \u003d 3e5;\n\nint n, m, u, v, x, y, sub_size[MAXN + 5];\nbool vis[MAXN + 5], chk_sub[MAXN + 5];\nvector\u0026lt;int\u0026gt; adj[MAXN + 5];\n\nint DFS(int u)\n{\n    vis[u] \u003d true; sub_size[u] \u003d 1;\n    if (u \u003d\u003d x)\n        chk_sub[u] \u003d true;\n    else chk_sub[u] \u003d false;\n    for (int v: adj[u])\n        if (!vis[v])\n        {\n            sub_size[u] +\u003d DFS(v);\n            chk_sub[u] |\u003d chk_sub[v];\n        }\n    return sub_size[u];\n}\n\nint main()\n{\n    scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;n, \u0026amp;x, \u0026amp;y);\n    m \u003d n - 1;\n    while (m--)\n    {\n        scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;u, \u0026amp;v);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    DFS(y);\n\n    long long fin;\n    for (int v: adj[y])\n        if (chk_sub[v])\n        {\n            fin \u003d sub_size[y] - sub_size[v];\n            break;\n        }\n\n    printf(\u0026quot;%I64d\u0026quot;, 1LL * n * (n - 1) - fin * sub_size[x]);\n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/979/problem/D\" title\u003d\"Codeforces Round 482 (Div. 2)\"\u003e979D - Kuro and GCD and XOR and SUM\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eWe first look at the condition \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/fe/0e/fe0e0843c7c79a4f3da41c926777dbd5ef7ff83b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. This condition holds iff both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e are divisible by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Therefore, if \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e0/b9/e0b947144cb5f9931ed5acc30606fc7cbedf91be.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, we return \u003ccode\u003e-1\u003c/code\u003e immediately, else we only consider numbers in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e that are divisible by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFinding the maximum XOR of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in the array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e reminds us of a classic problem, where the data structure trie is used to descend from the higher bit positions to the lower bit positions. But since we only consider \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e such that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/17/3e/173e9d9961453fc0e85450bbaf8bc5b75c74a9e4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ev\u003c/i\u003e ≤ \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, we build \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e tries, where the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eth\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e trie holds information of numbers in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e that are divisible by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, and we only descend to a branch in the trie if the branch is not empty and the minimum value in the branch is \u003cspan class\u003d\"tex-span\"\u003e ≤ \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eAdding a number into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e is trivial by now: we update every \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eth\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e trie where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e divides the number we need to add into the array. Notice that we only add a number if the number doesn\u0027t exist in the array yet.\u003c/p\u003e\u003cp\u003eTime complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eMAXlog\u003c/i\u003e(\u003ci\u003eMAX\u003c/i\u003e) + \u003ci\u003eqlog\u003c/i\u003e(\u003ci\u003eMAX\u003c/i\u003e)\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;vector\u0026gt;\nusing namespace std;\n\nconst int MAX \u003d 1E5 + 5;\n\nstruct SNode\n{\n    int mi;\n    SNode *bit[2];\n\n    SNode()\n    {\n        mi \u003d MAX;\n        bit[0] \u003d bit[1] \u003d nullptr;\n    }\n} *rt[MAX];\nvector\u0026lt;int\u0026gt; di[MAX];\nint q, t, u, k, x, s;\nbool chk[MAX];\n\nvoid init()\n{\n    for (int i \u003d 1; i \u0026lt; MAX; i++)\n    {\n        for (int j \u003d i; j \u0026lt; MAX; j +\u003d i)\n            di[j].push_back(i);\n        rt[i] \u003d new SNode();\n    }\n}\n\nvoid add(int k, int u)\n{\n    SNode *cur \u003d rt[k];\n    cur-\u0026gt;mi \u003d min(cur-\u0026gt;mi, u);\n    for (int i \u003d 18; i \u0026gt;\u003d 0; i--)\n    {\n        if (cur-\u0026gt;bit[u \u0026gt;\u0026gt; i \u0026amp; 1] \u003d\u003d nullptr)\n            cur-\u0026gt;bit[u \u0026gt;\u0026gt; i \u0026amp; 1] \u003d new SNode();\n        cur \u003d cur-\u0026gt;bit[u \u0026gt;\u0026gt; i \u0026amp; 1];\n        cur-\u0026gt;mi \u003d min(cur-\u0026gt;mi, u);\n    }\n}\n\nint que(int x, int k, int s)\n{\n    SNode *cur \u003d rt[k];\n    if (x % k !\u003d 0 || cur-\u0026gt;mi + x \u0026gt; s)\n        return -1;\n    int ret \u003d 0;\n    for (int i \u003d 18; i \u0026gt;\u003d 0; i--)\n    {\n        int bi \u003d x \u0026gt;\u0026gt; i \u0026amp; 1;\n        if (cur-\u0026gt;bit[bi ^ 1] !\u003d nullptr \u0026amp;\u0026amp; cur-\u0026gt;bit[bi ^ 1]-\u0026gt;mi + x \u0026lt;\u003d s)\n        {\n            ret +\u003d ((bi ^ 1) \u0026lt;\u0026lt; i);\n            cur \u003d cur-\u0026gt;bit[bi ^ 1];\n        }\n        else\n        {\n            ret +\u003d (bi \u0026lt;\u0026lt; i);\n            cur \u003d cur-\u0026gt;bit[bi];\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    init();\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;q);\n    while (q--)\n    {\n        scanf(\u0026quot;%d\u0026quot;, \u0026amp;t);\n        if (t \u003d\u003d 1)\n        {\n            scanf(\u0026quot;%d\u0026quot;, \u0026amp;u);\n            if (!chk[u])\n            {\n                chk[u] \u003d true;\n                for (int k : di[u])\n                    add(k, u);\n            }\n        }\n        else\n        {\n            scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;x, \u0026amp;k, \u0026amp;s);\n            printf(\u0026quot;%d\\n\u0026quot;, que(x, k, s));\n        }\n    }\n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/979/problem/E\" title\u003d\"Codeforces Round 482 (Div. 2)\"\u003e979E - Kuro and Topological Parity\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThe problem asks us to find the number of different simple directed acyclic graphs with \u003cspan class\u003d\"tex-span\"\u003e1 → \u003ci\u003en\u003c/i\u003e\u003c/span\u003e forming its topological order to ensure the parity of the number of alternating paths to be equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e. We will solve this problem using the dynamic programming approach. \u003c/p\u003e\u003cp\u003eLet\u0027s define \u003cstrong\u003eeven-white\u003c/strong\u003e as the number of different nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e colored in white that has an even number of alternating paths that end in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e. In the same fashion, let\u0027s define \u003cstrong\u003eodd-white\u003c/strong\u003e as the number of different nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e colored in white that has an odd number of alternating paths that end in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, \u003cstrong\u003eeven-black\u003c/strong\u003e — the number of different nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e colored in black that has an even number of alternating paths that end in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, and \u003cstrong\u003eodd-black\u003c/strong\u003e — the number of different nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e colored in black that has an odd number of alternating paths that end in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e. Let\u0027s also define \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003eew\u003c/i\u003e][\u003ci\u003eow\u003c/i\u003e][\u003ci\u003eeb\u003c/i\u003e]\u003c/span\u003e as the number of different graphs following the requirements that can be built using the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e nodes, with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eew\u003c/i\u003e\u003c/span\u003e even-white nodes, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eow\u003c/i\u003e\u003c/span\u003e odd-white nodes and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eeb\u003c/i\u003e\u003c/span\u003e even-black nodes (the number of odd-black nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eob\u003c/i\u003e \u003d \u003ci\u003ei\u003c/i\u003e - \u003ci\u003eew\u003c/i\u003e - \u003ci\u003eow\u003c/i\u003e - \u003ci\u003eeb\u003c/i\u003e\u003c/span\u003e). We will figure out how to calculate such value. For the sake of simplicity, let\u0027s consider the current node — the \u003cspan class\u003d\"tex-span\"\u003e{\u003ci\u003ei\u003c/i\u003e}\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eth\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e node to be a white node.\u003c/p\u003e\u003cp\u003eWe can notice a few things:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eIf none of the previous \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/span\u003e nodes connects to the current node, the current node becomes an odd-white node (the only alternating path that ends the current node is the node itself).\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eHow the previous white nodes connect to the current node does not matter. There are \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eow\u003c/i\u003e + \u003ci\u003eew\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e ways to add edges between the previous white nodes and the current node.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eHow the previous even-black nodes connect to the current node does not matter, as it does not change the state of the current white node (i.e. odd-white to even-white or even-white to odd-white). There are \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eeb\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e ways to add edges between the previous even-black nodes and the current node.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf there are an odd number of previous odd-black nodes that have edges to the current node, the current node becomes an even-white node. There are \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/19/b4/19b43c38ca7243f9dad964f909668d8c537f0d0d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e ways to do this.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf there are an even number of previous odd-black nodes that have edges to the current node, the current node becomes an odd-white node. There are \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/75/f8/75f8a86758a1384948b9bb4c9d2405d3f16cb301.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e ways to do this.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eIn conclusion, we can figure out that:\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c9/9b/c99b5a56c77aa33601dfad50484555fc2dc797e4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eIt is worth mentioning that we can use the same analogy to process when the current node is black.\u003c/p\u003e\u003cp\u003eIn total, we process through \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e\u003c/span\u003e states, with an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e iteration for each stage, so the time complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e)\u003c/span\u003e. However, with precomputation of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/60/ba/60ba8d3a003464efe88343843758c47e72a3ee67.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/74/88/74880667ac250085e61be7effc7fe43ded3eb170.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for every value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eob\u003c/i\u003e\u003c/span\u003e, we can optimize the time complexity to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTime complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\nusing namespace std;\n\nconst int N \u003d 55, MOD \u003d 1E9 + 7;\n\nint n, p, c[N];\nlong long ans \u003d 0, pw[N], fct[N], inv[N], od[N], ev[N], f[N][N][N][N];\n\nlong long power(int u, int p)\n{\n    if (p \u003d\u003d 0)\n        return 1;\n    long long ret \u003d power(u, p \u0026gt;\u0026gt; 1);\n    (ret *\u003d ret) %\u003d MOD;\n    if (p \u0026amp; 1)\n        (ret *\u003d u) %\u003d MOD;\n    return ret;\n}\n\nlong long C(int n, int k)\n{\n    return fct[n] * inv[k] % MOD * inv[n - k] % MOD;\n}\n\nvoid init()\n{\n    f[0][0][0][0] \u003d 1;\n    pw[0] \u003d 1;\n    fct[0] \u003d 1;\n    for (int i \u003d 1; i \u0026lt; N; i++)\n    {\n        pw[i] \u003d pw[i - 1] * 2 % MOD;\n        fct[i] \u003d fct[i - 1] * i % MOD;\n    }\n    inv[N - 1] \u003d power(fct[N - 1], MOD - 2);\n    for (int i \u003d N - 2; i \u0026gt;\u003d 0; i--)\n        inv[i] \u003d inv[i + 1] * (i + 1) % MOD;\n    for (int i \u003d 0; i \u0026lt; N; i++)\n    {\n        for (int j \u003d 0; j \u0026lt;\u003d i; j +\u003d 2)\n            (ev[i] +\u003d C(i, j)) %\u003d MOD;\n        for (int j \u003d 1; j \u0026lt;\u003d i; j +\u003d 2)\n            (od[i] +\u003d C(i, j)) %\u003d MOD;\n    }\n}\n\nvoid find_ans(int ob, int eb, int ow, int ew, int col, long long \u0026amp;ret)\n{\n    // current node is even-white\n    if (col !\u003d 0 \u0026amp;\u0026amp; ew !\u003d 0)\n        (ret +\u003d f[ob][eb][ow][ew - 1] * pw[ow + ew - 1 + eb] % MOD * od[ob] % MOD) %\u003d MOD;\n\n    // current node is odd-white\n    if (col !\u003d 0 \u0026amp;\u0026amp; ow !\u003d 0)\n        (ret +\u003d f[ob][eb][ow - 1][ew] * pw[ow - 1 + ew + eb] % MOD * ev[ob] % MOD) %\u003d MOD;\n\n    // current node is even-black\n    if (col !\u003d 1 \u0026amp;\u0026amp; eb !\u003d 0)\n        (ret +\u003d f[ob][eb - 1][ow][ew] * pw[ob + eb - 1 + ew] % MOD * od[ow] % MOD) %\u003d MOD;\n\n    // current node is odd-black\n    if (col !\u003d 1 \u0026amp;\u0026amp; ob !\u003d 0)\n        (ret +\u003d f[ob - 1][eb][ow][ew] * pw[ob - 1 + eb + ew] % MOD * ev[ow] % MOD) %\u003d MOD;\n}\n\nint main()\n{\n    init();\n    scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;p);\n    for (int i \u003d 1; i \u0026lt;\u003d n; i++)\n        scanf(\u0026quot;%d\u0026quot;, c + i);\n    for (int i \u003d 1; i \u0026lt;\u003d n; i++)\n        for (int ob \u003d 0; ob \u0026lt;\u003d i; ob++)\n            for (int eb \u003d 0; ob + eb \u0026lt;\u003d i; eb++)\n                for (int ow \u003d 0; ob + eb + ow \u0026lt;\u003d i; ow++)\n                {\n                    int ew \u003d i - ob - eb - ow;\n                    find_ans(ob, eb, ow, ew, c[i], f[ob][eb][ow][ew]);\n                    if (i \u003d\u003d n \u0026amp;\u0026amp; ((ob + ow) \u0026amp; 1) \u003d\u003d p)\n                        (ans +\u003d f[ob][eb][ow][ew]) %\u003d MOD;\n                }\n    printf(\u0026quot;%lld\u0026quot;, ans);\n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["codeforces","482","div2","editorial"]}}