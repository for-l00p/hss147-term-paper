{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1522207877,"rating":5,"authorHandle":"mohamedeltair","modificationTimeSeconds":1522220857,"id":58598,"title":"\u003cp\u003eRange bit flips in a range of numbers ?\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"https://www.hackerearth.com/practice/data-structures/advanced-data-structures/segment-trees/practice-problems/algorithm/big-number-array-043361b7/\"\u003eThe problem\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThere are two types of queries in the problem:\u003c/p\u003e \u003col\u003e   \u003cli\u003eflip from the Lth bit to the Rth bit inclusive in the elements from index x to index y inclusive\u003c/li\u003e   \u003cli\u003eanswer that question: is the xth number equal to the yth number ?\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eThe elements are all initially zeros. N and Q (numbers of elements and queries) are up to 1e5. And 0 \u0026lt;\u003d l \u0026lt;\u003d r \u0026lt;\u003d 1e9.\u003c/p\u003e\u003cp\u003eAn intuitive idea (if the number of bits was small) is:\u003c/p\u003e \u003col\u003e   \u003cli\u003efor the 1st query type: xor elements in the range [x,y] with (2^(r+1)-1 xor 2^(l)-1) (can be done easily using range update structures)\u003c/li\u003e   \u003cli\u003efor the 2nd query type: just check if the xth elements is equal to the yth elements using a point query\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eBut the number of bits is very large, I noticed from people\u0027s solutions that they hashed 2^x for all x that appeared in the first query type (l and r) to represent them in smaller numbers. So any mask which was originally (2^(r+1)-1 xor 2^(l)-1) maps to a another mask which is (hash(r+1) xor hash(l)). and the original combination of 1e9+1 bits for any element will map to a combination of smaller number of bits.\u003c/p\u003e\u003cp\u003eThis type of solution has two sides in the second query type:\u003c/p\u003e \u003col\u003e   \u003cli\u003eif the answer is Yes, it is guaranteed that this solution will output Yes.\u003c/li\u003e   \u003cli\u003eif the answer is No, it may happen that that two different combination of 1e9+1 bits map to the same combination in the smaller number of bits, and hence the solution will output Yes.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eWhat is the probability that the problem in the second side happens if (for example) the hash for any 2^x was a long long in the form of (rand()\u0026lt;\u0026lt;32)|rand())?\u003c/p\u003e\u003cp\u003eNote: rand() here is the C++ rand.\u003c/p\u003e\u003c/div\u003e","tags":[]}}