{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1461163187,"rating":70,"authorHandle":"Edvard","modificationTimeSeconds":1461188804,"id":44466,"title":"\u003cp\u003eEditorial of Educational Codeforces Round 12\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/665/problem/A\" title\u003d\"Educational Codeforces Round 12\"\u003e665A - Автобусы между городами\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem was suggested by Sergey Erlikh \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/unprost\" title\u003d\"Эксперт unprost\"\u003eunprost\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eConsider the time interval when Simion will be on the road strictly between cities \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u003d 60\u003ci\u003eh\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e). Let\u0027s iterate over the oncoming buses. Let \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e be the time interval when the oncoming bus will be strictly between two cities. If the intersection of that intervals \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003emax\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e), \u003ci\u003ey\u003c/i\u003e \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e))\u003c/span\u003e is not empty than Simion will count that bus.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eС++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eint a, ta;\nint b, tb;\nint h, m;\n\nbool read() {\n\tif (!(cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; ta)) return false;\n\tassert(cin \u0026gt;\u0026gt; b \u0026gt;\u0026gt; tb);\n\tassert(scanf(\u0026quot;%d:%d\u0026quot;, \u0026amp;h, \u0026amp;m) \u003d\u003d 2);\n\treturn true;\n}\n\nvoid solve() {\n\tint x1 \u003d h * 60 + m;\n\tint y1 \u003d x1 + ta;\n\n\tint ans \u003d 0;\n\tfor (int x2 \u003d 5 * 60 + 0; x2 \u0026lt; 24 * 60; x2 +\u003d b) {\n\t\tint y2 \u003d x2 + tb;\n\t\tint x \u003d max(x1, x2), y \u003d min(y1, y2);\n\t\tif (x \u0026lt; y)\n\t\t\tans++;\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/665/problem/B\" title\u003d\"Educational Codeforces Round 12\"\u003e665B - Покупки\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem was suggested by Ayush Anand \u003ca class\u003d\"rated-user user-gray\" href\u003d\"/profile/FanOfTourist\" title\u003d\"Новичок FanOfTourist\"\u003eFanOfTourist\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eIn this problem you should simply do what was written in the problem statement. There are no tricks.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003econst int N \u003d 111;\n\nint n, m, k;\nint p[N];\nint a[N][N];\n\nbool read() {\n\tif (!(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k)) return false;\n\tforn(i, k) {\n\t\tassert(scanf(\u0026quot;%d\u0026quot;, \u0026amp;p[i]) \u003d\u003d 1);\n\t\tp[i]--;\n\t}\n\tforn(i, n)\n\t\tforn(j, m) {\n\t\t\tassert(scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i][j]) \u003d\u003d 1);\n\t\t\ta[i][j]--;\n\t\t}\n\treturn true;\n}\n\nvoid solve() {\n\tint ans \u003d 0;\n\tforn(i, n)\n\t\tforn(j, m) {\n\t\t\tint pos \u003d int(find(p, p + k, a[i][j]) - p);\n\t\t\tans +\u003d pos + 1;\n\t\t\tnfor(l, pos) p[l + 1] \u003d p[l];\n\t\t\tp[0] \u003d a[i][j];\n\t\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enmk\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/665/problem/C\" title\u003d\"Educational Codeforces Round 12\"\u003e665C - Простые строки\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem was suggested by Zi Song Yeoh \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/zscoder\" title\u003d\"Кандидат в мастера zscoder\"\u003ezscoder\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThere are two ways to solve this problem: greedy approach and dynamic programming.\u003c/p\u003e\u003cp\u003eThe first apprroach: Considerr some segment of consecutive equal characters. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e be the length of that segment. Easy to see that we should change at least \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cd/69/cd69deaf3b6e9553293b31193fcfe18accb6de5b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e characters in the segment to remove all the pairs of equal consecutive letters. On the other hand we can simply change the second, the fourth etc. symbols to letter that is not equal to the letters before and after the segment.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eGreedy approach on C++\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003econst int N \u003d 200200;\n\nint n;\nchar s[N];\n\nbool read() {\n\tif (!gets(s)) return false;\n\tn \u003d int(strlen(s));\n\treturn true;\n}\n\nvoid solve() {\n\tfor (int i \u003d 0, j \u003d 0; i \u0026lt; n; i \u003d j) {\n\t\twhile (j \u0026lt; n \u0026amp;\u0026amp; s[j] \u003d\u003d s[i]) j++;\n\t\tchar c \u003d \u0027a\u0027;\n\t\twhile (c \u003d\u003d s[i] || (i \u0026gt; 0 \u0026amp;\u0026amp; c \u003d\u003d s[i - 1]) || (j \u0026lt; n \u0026amp;\u0026amp; c \u003d\u003d s[j]))\n\t\t\tc++;\n\t\tfore(k, i, j)\n\t\t\tif ((i + k) \u0026amp; 1)\n\t\t\t\ts[k] \u003d c;\n\t}\n\tputs(s);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eThe second approach: Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eka\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the minimal number of changes so that the prefix of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e has no equal consecutive letters and the symbol \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u0027\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e equals to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. Let\u0027s iterate over the letter on the position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e and if it is not equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e make transition. The cost of the transition is equal to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e if we put the same letter as in the original string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e on the position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e. Otherwise the cost is equal to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eDP solution on C++\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003econst int N \u003d 1200300, A \u003d 27;\n\nint n;\nchar s[N];\n\nbool read() {\n\tif (!gets(s)) return false;\n\tn \u003d int(strlen(s));\n\treturn true;\n}\n\nint z[N][A];\nint p[N][A];\nchar ans[N];\n\nvoid solve() {\n\tmemset(z, 63, sizeof(z));\n\n\tz[0][A - 1] \u003d 0;\n\tforn(i, n) {\n\t\tint c \u003d int(s[i] - \u0027a\u0027);\n\t\tforn(j, A) {\n\t\t\tint dv \u003d z[i][j];\n\t\t\tif (dv \u0026gt; INF / 2) continue;\n\t\t\tforn(nj, A - 1) {\n\t\t\t\tif (nj \u003d\u003d j) continue;\n\t\t\t\tint ct \u003d nj !\u003d c;\n\t\t\t\tif (z[i + 1][nj] \u0026gt; dv + ct) {\n\t\t\t\t\tz[i + 1][nj] \u003d dv + ct;\n\t\t\t\t\tp[i + 1][nj] \u003d j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint idx \u003d int(min_element(z[n], z[n] + A) - z[n]);\n\n\tfor (int i \u003d n, j \u003d idx; i \u0026gt; 0; j \u003d p[i][j], i--)\n\t\tans[i - 1] \u003d char(\u0027a\u0027 + j);\n\tans[n] \u003d 0;\n\n\tcerr \u0026lt;\u0026lt; z[n][idx] \u0026lt;\u0026lt; endl;\n\tputs(ans);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/665/problem/D\" title\u003d\"Educational Codeforces Round 12\"\u003e665D - Красивое подмножество\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem was suggested by Zi Song Yeoh \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/zscoder\" title\u003d\"Кандидат в мастера zscoder\"\u003ezscoder\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eConsider the subset \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e that is the answer to the problem. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e be the arbitrary three elements from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and let no more than one of them is equal to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. By the pigeonhole principle two of three elements from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e have the same parity. So we have two integers with even sum and only one of them is equal to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, so their sum is also greater than \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e. So the subset \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e is not simple. In this way \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e consists of only two numbers greater than one (with a prime sum) or consists of some number of ones and also maybe other value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, so that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + 1\u003c/span\u003e is a prime.\u003c/p\u003e\u003cp\u003eWe can simply process the first case in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e time. The second case can be processed in linear time. Also we should choose the best answer from that two.\u003c/p\u003e\u003cp\u003eTo check the value of order \u003cspan class\u003d\"tex-span\"\u003e2·10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e for primality in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time we can use the simple or the linear Eratosthenes sieve.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003econst int N \u003d 1010, X \u003d 2100300;\n\nint n, a[N];\n\nbool read() {\n\tif (!(cin \u0026gt;\u0026gt; n)) return false;\n\tforn(i, n) assert(scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]) \u003d\u003d 1);\n\treturn true;\n}\n\nint szp, p[X];\nint mind[X];\n\nvoid prepare() {\n\tfore(i, 2, X) {\n\t\tif (!mind[i]) {\n\t\t\tp[szp++] \u003d i;\n\t\t\tmind[i] \u003d i;\n\t\t}\n\t\tfor (int j \u003d 0; j \u0026lt; szp \u0026amp;\u0026amp; p[j] \u0026lt;\u003d mind[i] \u0026amp;\u0026amp; i * p[j] \u0026lt; X; j++)\n\t\t\tmind[i * p[j]] \u003d p[j];\n\t}\n}\n\nvoid printAns(int cnt1, int a \u003d -1, int b \u003d -1) {\n\tvector\u0026lt;int\u0026gt; ans;\n\tforn(i, cnt1) ans.pb(1);\n\tif (a !\u003d -1) ans.pb(a);\n\tif (b !\u003d -1) ans.pb(b);\n\tassert(!ans.empty());\n\trandom_shuffle(all(ans));\n\n\tcout \u0026lt;\u0026lt; sz(ans) \u0026lt;\u0026lt; endl;\n\tforn(i, sz(ans)) {\n\t\tif (i) putchar(\u0027 \u0027);\n\t\tprintf(\u0026quot;%d\u0026quot;, ans[i]);\n\t}\n\tputs(\u0026quot;\u0026quot;);\n}\n\nvoid solve() {\n\tint cnt1 \u003d (int) count(a, a + n, 1);\n\n\tfunction\u0026lt;bool(int)\u0026gt; isPrime \u003d [](int p) { return mind[p] \u003d\u003d p; };\n\n\tif (cnt1 \u0026gt; 0)\n\t\tforn(i, n)\n\t\t\tif (a[i] !\u003d 1 \u0026amp;\u0026amp; isPrime(a[i] + 1)) {\n\t\t\t\tprintAns(cnt1, a[i]);\n\t\t\t\treturn;\n\t\t\t}\n\n\tif (cnt1 \u0026gt; 1) {\n\t\tprintAns(cnt1);\n\t\treturn;\n\t}\n\n\tforn(i, n)\n\t\tforn(j, i)\n\t\t\tif (isPrime(a[i] + a[j])) {\n\t\t\t\tprintAns(0, a[i], a[j]);\n\t\t\t\treturn;\n\t\t\t}\n\n\tprintAns(0, a[0]);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e + \u003ci\u003eX\u003c/i\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e is the maximal value in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/665/problem/E\" title\u003d\"Educational Codeforces Round 12\"\u003e665E - Красивые подмассивы\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem was suggested by Zi Song Yeoh \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/zscoder\" title\u003d\"Кандидат в мастера zscoder\"\u003ezscoder\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThe sign \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c1/5d/c15d2b716fe31376e2f869457fe96754821bf274.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is used for the binary operation for bitwise exclusive or.\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the xor of the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e elements on the prefix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. Then the interval \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e is beautiful if \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b7/f0/b7f0a63b20f3bbbe9410e4f1947915e174588cb0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Let\u0027s iterate over \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and consider the values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e as the binary strings. On each iteration we should increase the answer by the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — the number of numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e) so \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b7/f0/b7f0a63b20f3bbbe9410e4f1947915e174588cb0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. To do that we can use the \u003ca href\u003d\"https://ru.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e data structure. Let\u0027s store in the trie all the values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. Besides the structure of the trie we should also store in each vertex the number of leaves in the subtree of that vertex (it can be easily done during adding of each binary string). To calculate the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e let\u0027s go down by the trie from the root. Let\u0027s accumulate the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecur\u003c/i\u003e\u003c/span\u003e equals to the xor of the prefix of the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e with the already passed in the trie path. Let the current bit in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e be the depth of the current vertex in the trie. If the number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecur\u003c/i\u003e + 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e ≥ \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e then we can increase \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e by the number of leaves in vertex \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bd/68/bd68fd1666e2f22fa9649fee208f2aa1540c980d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, because all the leaves in the subtree of tha vertex correspond to the values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e that for sure gives \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b7/f0/b7f0a63b20f3bbbe9410e4f1947915e174588cb0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. After that we should go down in the subtree \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. Otherwise if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecur\u003c/i\u003e + 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e \u0026lt; \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e then we should simply go down to the subtree \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/20/31/203148fd3ac19c4cfb2291da011eb2155ef5e5f9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and recalculate the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecur\u003c/i\u003e \u003d \u003ci\u003ecur\u003c/i\u003e + 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003econst int N \u003d 1200300, LOGN \u003d 30, V \u003d N * LOGN;\n\nint n, k;\nint a[N];\n\nbool read() {\n\tif (!(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k)) return false;\n\tforn(i, n) assert(scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]) \u003d\u003d 1);\n\treturn true;\n}\n\nint tsz;\nint nt[V][2];\nint cnt[V];\n\nvoid clear() {\n\tforn(i, V) {\n\t\tnt[i][0] \u003d nt[i][1] \u003d -1;\n\t\tcnt[i] \u003d 0;\n\t}\n\ttsz \u003d 1;\n}\n\nvoid add(int x) {\n\tint v \u003d 0;\n\tcnt[v]++;\n\n\tnfor(i, LOGN) {\n\t\tint b \u003d (x \u0026gt;\u0026gt; i) \u0026amp; 1;\n\t\tif (nt[v][b] \u003d\u003d -1) {\n\t\t\tassert(tsz \u0026lt; V);\n\t\t\tnt[v][b] \u003d tsz++;\n\t\t}\n\t\tv \u003d nt[v][b];\n\t\tcnt[v]++;\n\t}\n}\n\n\nint calc(int x) {\n\tint v \u003d 0;\n\tint ans \u003d 0;\n\n\tauto getCnt \u003d [](int v) { return v \u003d\u003d -1 ? 0 : cnt[v]; };\n\n\tint cur \u003d 0;\n\tnfor(i, LOGN) {\n\t\tif (v \u003d\u003d -1) break;\n\t\tint b \u003d (x \u0026gt;\u0026gt; i) \u0026amp; 1;\n\t\tif ((cur | (1 \u0026lt;\u0026lt; i)) \u0026gt;\u003d k) {\n\t\t\tans +\u003d getCnt(nt[v][b ^ 1]);\n\t\t\tv \u003d nt[v][b];\n\t\t} else {\n\t\t\tv \u003d nt[v][b ^ 1];\n\t\t\tcur |\u003d (1 \u0026lt;\u0026lt; i);\n\t\t}\n\t}\n\tif (cur \u0026gt;\u003d k) ans +\u003d getCnt(v);\n\treturn ans;\n}\n\nvoid solve() {\n\tclear();\n\n\tadd(0);\n\n\tli ans \u003d 0;\n\tint s \u003d 0;\n\tforn(i, n) {\n\t\ts ^\u003d a[i];\n\t\tli cur \u003d calc(s);\n\t\tans +\u003d cur;\n\t\tadd(s);\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComlpexity by the time and the memory: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlogX\u003c/i\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e is the maximal xor on the prefixes.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/665/problem/F\" title\u003d\"Educational Codeforces Round 12\"\u003e665F - Четыре делителя\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe editorial for this problem is a little modification of the materials from the lecture of Mikhail Tikhomirov \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Endagorion\" title\u003d\"Международный гроссмейстер Endagorion\"\u003eEndagorion\u003c/a\u003e of the autumn of 2015 in Moscow Institute of Physics and Technology. Thanks a lot to \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Endagorion\" title\u003d\"Международный гроссмейстер Endagorion\"\u003eEndagorion\u003c/a\u003e for that materials.\u003c/p\u003e\u003cp\u003eEasy to see that only the numbers of the form \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e·\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003c/span\u003e (for different prime \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e, \u003ci\u003eq\u003c/i\u003e\u003c/span\u003e) have exactly four positive divisors.\u003c/p\u003e\u003cp\u003eWe can easily count the numbers of the form \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003c/span\u003e in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/06/f3069ae7b62da27bbd3069c15ad1c7d0f1ae9a0a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is the number from the problem statement.\u003c/p\u003e\u003cp\u003eNow let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e \u0026lt; \u003ci\u003eq\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003eπ(\u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e be the number of primes from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Let\u0027s iterate over all the values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e. Easy to see that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/97/e2/97e2bfba085c3318b4cfc7749457cc01ff4ec466.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. So for fixed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e we should increase the answer by the value \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/41/33/413381c5d2674028f2cb7efcee2766bf27c43ef2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eSo the task is ot to find \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/41/33/413381c5d2674028f2cb7efcee2766bf27c43ef2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e — the number of primes not exceeding \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/d5/7cd5dba1f36c7682eb61d28b05951b1f81ffaba4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eDenote \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e-th prime number. Denote \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e the number of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ek\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e, and all prime divisors of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e are at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (note that 1 is counted in all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, since the set of its prime divisors is empty). \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e satisfy a simple recurrence:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e, 1\u003c/sub\u003e \u003d \u003ci\u003en\u003c/i\u003e\u003c/span\u003e (since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e \u003d 2)\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e + 1\u003c/sub\u003e + \u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e⌊ \u003ci\u003en\u003c/i\u003e / \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e⌋, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, hence \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e + 1\u003c/sub\u003e \u003d \u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e⌊ \u003ci\u003en\u003c/i\u003e / \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e⌋, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the smallest prime greater than \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/5c/4e5c9f371024ad4e1f5b0f2dfeb967ffe7cb5f4e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Then \u003cspan class\u003d\"tex-span\"\u003eπ(\u003ci\u003en\u003c/i\u003e) \u003d \u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e (by definition, the first summand accounts for all the primes not less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eIf we evaluate the recurrence \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e straightforwardly, all the reachable states will be of the form \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e⌊ \u003ci\u003en\u003c/i\u003e / \u003ci\u003ei\u003c/i\u003e⌋, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. We can also note that if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e are both greater than \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/5c/4e5c9f371024ad4e1f5b0f2dfeb967ffe7cb5f4e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ej\u003c/i\u003e \u003d \u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Thus, for each \u003cspan class\u003d\"tex-span\"\u003e⌊ \u003ci\u003en\u003c/i\u003e / \u003ci\u003ei\u003c/i\u003e⌋\u003c/span\u003e it makes sense to keep only \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ab/35/ab3557a69141c9e0d0bcd22ee3e1ad7a60bbbede.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e⌊ \u003ci\u003en\u003c/i\u003e / \u003ci\u003ei\u003c/i\u003e⌋, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eInstead of evaluating all DP states straightforwardly, we perform a two-step process:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eChoose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eRun recursive evaluation of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. If we want to compute a state with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u0026lt; \u003ci\u003eK\u003c/i\u003e\u003c/span\u003e, memorize the query ``count the numbers not exceeding \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e with all prime divisors at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e\u0027\u0027.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eAnswer all the queries off-line: compute the sieve for numbers up to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e, then sort all numbers by the smallest prime divisor. Now all queries can be answered using RSQ structure. Store all the answers globally.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eRun recurisive evaluation of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e yet again. If we want to compute a state with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u0026lt; \u003ci\u003eK\u003c/i\u003e\u003c/span\u003e, then we must have preprocessed a query for this state, so take it from the global set of answers.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eThe performance of this approach relies heavily on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e — the number of queries we have to preprocess.\u003c/p\u003e\u003cp\u003e\u003cem\u003eStatement\u003c/em\u003e. \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c3/31/c331879d8f1b3053e407e3aaaab21505736f634d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003e\u003cem\u003eProof\u003c/em\u003e:\u003c/p\u003e\u003cp\u003eEach state we have to preprocess is obtained by following a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e⌊ \u003ci\u003en\u003c/i\u003e / \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e⌋, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e transition from some greater state. It follows that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e doesn\u0027t exceed the total number of states for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u0026gt; \u003ci\u003eK\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7b/fd/7bfd4058740fb62751d4af2a24be726a193ce47f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eThe preprocessing of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e queries can be done in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/16/8f/168f0713ed88b263fbfce3a439c37337a746e995.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, and it is the heaviest part of the computation. Choosing optimal \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b5/e1/b5e121607a9f35db80dace866db6bc80c3c0ccfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, we obtain the complexity \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cd/3f/cd3f56aef8dfa0f61e0dc96c6676537ef1d8da04.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eli n;\n\nbool read() {\n\treturn !!(cin \u0026gt;\u0026gt; n);\n}\n\nconst int K \u003d 10 * 1000 * 1000;\nconst int N \u003d K;\nconst int P \u003d 700100;\nconst int Q \u003d 25 * 1000 * 1000;\n\nint szp, p[P];\nint mind[N];\n\nvoid prepare() {\n\tszp \u003d 0;\n\tforn(i, N) mind[i] \u003d -1;\n\tfore(i, 2, N) {\n\t\tif (mind[i] \u003d\u003d -1) {\n\t\t\tassert(szp \u0026lt; P);\n\t\t\tmind[i] \u003d szp;\n\t\t\tp[szp++] \u003d i;\n\t\t}\n\t\tfor (int j \u003d 0; j \u0026lt; szp \u0026amp;\u0026amp; j \u0026lt;\u003d mind[i] \u0026amp;\u0026amp; i * p[j] \u0026lt; N; j++)\n\t\t\tmind[i * p[j]] \u003d j;\n\t}\n}\n\ninline int getk(li n) {\n\tint lf \u003d 0, rg \u003d szp - 1;\n\twhile (lf !\u003d rg) {\n\t\tint md \u003d (lf + rg) \u0026gt;\u0026gt; 1;\n\t\tif (p[md] * 1ll * p[md] \u0026gt; n) rg \u003d md;\n\t\telse lf \u003d md + 1;\n\t}\n\tassert(p[lf] * 1ll * p[lf] \u0026gt; n);\n\treturn lf;\n}\n\nint t[K];\nvoid inc(int i, int val) {\n\tfor ( ; i \u0026lt; K; i |\u003d i + 1)\n\t\tt[i] +\u003d val;\n}\nint sum(int i) {\n\tint ans \u003d 0;\n\tfor ( ; i \u0026gt;\u003d 0; i \u003d (i \u0026amp; (i + 1)) - 1)\n\t\tans +\u003d t[i];\n\treturn ans;\n}\n\nint szq;\npti q[Q];\nint ans[Q];\nvector\u0026lt;int\u0026gt; vs[P];\n\nvoid process() {\n\tsort(q, q + szq, greater\u0026lt;pti\u0026gt; ());\n\tmemset(t, 0, sizeof(t));\n\n\tforn(i, szp) vs[i].clear();\n\tfore(i, 2, K)\n\t\tvs[mind[i]].pb(i);\n\n\tinc(1, +1);\n\n\tint p \u003d szp - 1;\n\tfor (int i \u003d 0, j \u003d 0; i \u0026lt; szq; i \u003d j) {\n\t\twhile (p \u0026gt;\u003d q[i].x) {\n\t\t\tfor (auto v : vs[p])\n\t\t\t\tinc(v, +1);\n\t\t\tp--;\n\t\t}\n\n\t\twhile (j \u0026lt; szq \u0026amp;\u0026amp; q[j].x \u003d\u003d q[i].x) {\n\t\t\tans[j] \u003d sum(q[j].y);\n\t\t\tj++;\n\t\t}\n\t}\n}\n\nmap\u0026lt;pair\u0026lt;li, int\u0026gt;, li\u0026gt; z;\n\nli solve(li n, int jj, bool fs) {\n\tif (!n) return 0;\n\tint j \u003d min(jj, getk(n));\n\tif (!j) return n + j - jj;\n\n\tli ans \u003d 0;\n\tif (n \u0026lt; K) {\n\t\tpti p(j, (int) n);\n\t\tif (fs) {\n\t\t\tassert(szq \u0026lt; Q);\n\t\t\tq[szq++] \u003d p;\n\t\t\tans \u003d 0;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tint idx \u003d int(lower_bound(q, q + szq, p, greater\u0026lt;pti\u0026gt; ()) - q);\n\t\t\tassert(idx \u0026lt; szq \u0026amp;\u0026amp; q[idx] \u003d\u003d p);\n\t\t\tans \u003d ::ans[idx];\n\t\t}\n\t} else {\n\t\tif (!z.count(mp(n, j))) {\n\t\t\tans \u003d solve(n, j - 1, fs);\n\t\t\tans -\u003d solve(n / p[j - 1], j - 1, fs);\n\t\t\tz[mp(n, j)] \u003d ans;\n\t\t} else {\n\t\t\tans \u003d z[mp(n, j)];\n\t\t}\n\t}\n\n\tans +\u003d j - jj;\n\n\treturn ans;\n}\n\ninline li pi(li n, bool fs) {\n\tint k \u003d szp - 1;\n\treturn solve(n, k, fs) + k - 1;\n}\n\nvoid solve() {\n\tszq \u003d 0;\n\tz.clear();\n\tfor (int j \u003d 0; p[j] * 1ll * p[j] \u0026lt;\u003d n; j++) {\n\t\tli nn \u003d n / p[j];\n\t\tif (nn \u0026gt; p[j]) {\n\t\t\tpi(n / p[j], true);\n\t\t}\n\t}\n\n\tprocess();\n\n\tz.clear();\n\tli ans \u003d 0;\n\tfor (int j \u003d 0; p[j] * 1ll * p[j] \u0026lt;\u003d n; j++) {\n\t\tli nn \u003d n / p[j];\n\t\tif (nn \u0026gt; p[j]) {\n\t\t\tans +\u003d pi(n / p[j], false);\n\t\t\tans -\u003d j + 1;\n\t\t}\n\t}\n\n\tfor (int i \u003d 0; i \u0026lt; szp \u0026amp;\u0026amp; p[i] * 1ll * p[i] * 1ll * p[i] \u0026lt;\u003d n; i++)\n\t\tans++;\n\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cd/3f/cd3f56aef8dfa0f61e0dc96c6676537ef1d8da04.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003c/div\u003e","tags":["education round 12","editorial"]}}