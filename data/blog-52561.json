{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1497278745,"rating":-5,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1497371045,"id":52561,"title":"\u003cp\u003eNotes on Codeforces Beta Round #52, A, B, C, D(Edit Distance), E(Jumping Pointer and Amortized Analysis)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA. Bar\u003c/p\u003e\u003cp\u003eIf the current input is a number, i.e., the age, then it suffices to check whether this is not younger than 18 or not. If the current input is the name of some drink, then it is sufficient to check whether this belongs to the list of alcohol drinks or not.\u003c/p\u003e\u003cp\u003eB. Spoilt Permutation\u003c/p\u003e\u003cp\u003eWe can adopt two pointers p1 and p2, which start at the first position and the last position, respectively. Then, we move p1 to the right until we meet an element which is not equal to its index. Similarlt, we move p2 to the left and find the first element that is not equal to its index. It is obvious that if p1\u0026gt;\u003dp2, then the answer should be \u0026quot;0 0\u0026quot;; otherwise we should further check that whether each element a[j], where p1\u0026lt;\u003dj\u0026lt;\u003dp2, will satisfy the condition \u003c/p\u003e\u003cp\u003ea[j]\u003dp2-(j-p1)\u003c/p\u003e\u003cp\u003eIf for all the elements from p1 to p2, inclusively, the above equation hold, the answer will be \u0026quot;p1 p2\u0026quot;; otherwise it is \u0026quot;0 0\u0026quot;.\u003c/p\u003e\u003cp\u003eC. Corporation Mail\u003c/p\u003e\u003cp\u003eAt first sight, this problem might seem a little complicated. Nevertheless, it can be solved by using \u0026quot;stack\u0026quot; in a simple and straightforward manner. It is convenient to use the \u0026quot;vector\u0026quot; to simulate the \u0026quot;stack\u0026quot; (also you can directly use the \u0026quot;stack\u0026quot;). \u003c/p\u003e\u003cp\u003eStarting from the first character, whenever a name is found, we search the vector and whenever we find a string that is the same as the name, we add the answer by 1. Then, we also push the name into the vector (push_back). Next, whenever we meet a \u0027.\u0027, the last string (or name) in the vector is taken out (pop_back). \u003c/p\u003e\u003cp\u003eD. Changing a String\u003c/p\u003e\u003cp\u003eThis is well known as \u0026quot;Edit Distance\u0026quot; problem as far as I consider. One can search on the Internet and will find a lot of useful information.\u003c/p\u003e\u003cp\u003eE. Domino Principle\u003c/p\u003e\u003cp\u003eFor each domino, denoted as D[i], we assign it with four parameters, position D[i].x, height D[i].h, original index D[i].idx and the index of the most right domino that it can hit, denoted as D[i].nidx. Note that here \u0026quot;hit\u0026quot; does not mean that the current domino must hit it directly. Instead, just as domino implies, we say that it can hit another domino if we push it to the right, this domino will fall down finally. \u003c/p\u003e\u003cp\u003eAt first, we sort the dominoes in an increasing order of their positions, and then deal with the dominoes from right to left one by one. Suppose that we are now arriving at the i-th domino. Then, we start from the (i+1)-th domino and check whether the i-th domino can hit it or not. This is straightforward by checking if D[i+1].x falls into the interval [D[i].x+1, D[i].x+D[i].h-1]. If the answer is NO, it means that D[i].idx\u003di, i.e., this domino can only \u0026quot;hit\u0026quot; itself. Otherwise, we further whether the i-th domino can hit that one with index D[i+1].nidx+1. The reason is that since we can hit the (i+1)-th domino, and if it falls down, D[i+1].nidx implies that the (D[i+1].nidx)-th domino will also fall down. Thus, we can directly skip to the (D[i+1].nidx+1)-th domino and check whether it can be hit or not, and repeat the above operations. During this whole process, we can update and store the number of dominoes that every domino can \u0026quot;hit\u0026quot;. \u003c/p\u003e\u003cp\u003eThe complexity can be calculated by using the \u0026quot;Amortized Analysis\u0026quot; technique. Note that checking whether some domino can hit another one on the right contributes to the total complexity, and thus we count the number of such \u0026quot;checking\u0026quot;. When \u0026quot;checking\u0026quot; occurs, if the answer is YES, i.e., it can hit another one on the right, we assign this \u0026quot;checking\u0026quot; to the right one which can be hit and denote this event as Type-1; otherwise, we assign this \u0026quot;checking\u0026quot; to the current domino and denote this event as Type-2. Now we prove that for each domino, both Type-1 and Type-2 event can occur for at most once. Therefore, the total complexity is O(N).\u003c/p\u003e\u003cp\u003eProof: Suppose that the (i+1)-th domino is checked whether it can be hit by the i-th domino or not. If the answer is YES, then Type-1 event occurs at the (i+1)-th domino. Note that Type-1 event will never occur at the (i+1)-th domino any more, since when we later visit the (i-1)-th domino, we will compare it with the i-th domino while the (i+1)-th domino will be skipped (the reason is that if the i-th domino can be hit, then the (i+1)-th domino can be hit as well). Similarly, if the answer is NO, Type-1 event occurs at the i-th domino, however this Type-1 event will never occur at the i-th domino, either, according to the our definition.\u003c/p\u003e\u003cp\u003eAn intuitive understanding of \u0026quot;Amortized Analysis\u0026quot; is that the same operation is amortized, or separately counted, and finally added together.\u003c/p\u003e\u003c/div\u003e","tags":[]}}