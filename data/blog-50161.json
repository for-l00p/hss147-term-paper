{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1485938851,"rating":-2,"authorHandle":"t3rminated","modificationTimeSeconds":1485938851,"id":50161,"title":"\u003cp\u003ecode TLEs for \u003ca href\u003d\"https://www.codechef.com/problems/ALGFLXQF\"\u003ehttps://www.codechef.com/problems/ALGFLXQF\u003c/a\u003e\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eMy code Tle\u0027s for \u003ca href\u003d\"https://www.codechef.com/problems/ALGFLXQF\"\u003ethis\u003c/a\u003e problem but I am sure about the complexity. Here\u0027s my code --\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\nusing namespace std;\n#define lli long long\n#define gc getchar_unlocked\n#define MAX 10000001\nbool vv[MAX];\nint len, sp[MAX];\nint dp[MAX];\nmap\u0026lt;int, map\u0026lt;lli,lli\u0026gt; \u0026gt;  dpsum;\nvector\u0026lt;pair\u0026lt;lli, lli\u0026gt; \u0026gt; v[4*MAX];\n\nvoid scanint(int \u0026amp;x)\n{\n    register int c \u003d gc();\n    x \u003d 0;\n    for(;(c\u0026lt;48 || c\u0026gt;57);c \u003d gc());\n    for(;c\u0026gt;47 \u0026amp;\u0026amp; c\u0026lt;58;c \u003d gc()) {x \u003d (x\u0026lt;\u0026lt;1) + (x\u0026lt;\u0026lt;3) + c - 48;}\n}\nvoid Sieve(){\n    for (int i \u003d 2; i \u0026lt; MAX; i +\u003d 2) sp[i] \u003d 2;//even numbers have smallest prime factor 2\n    for (lli i \u003d 3; i \u0026lt; MAX; i +\u003d 2){\n    if (!vv[i]){\n    sp[i] \u003d i;\n    for (lli j \u003d i; (j*i) \u0026lt; MAX; j +\u003d 2){\n    if (!vv[j*i]) vv[j*i] \u003d true, sp[j*i] \u003d i;\n    }\n    }\n    }\n}\n\nvoid build(int node, int l, int r)\n{\n    if(l \u0026gt; r)return;\n    for(int i \u003d l; i \u0026lt;\u003d r; i++)\n    {\n        v[node].push_back(make_pair((lli)dp[i], (lli)i));\n    }\n    sort(v[node].begin(), v[node].end());\n    dpsum[node][0] \u003d v[node][0].second*v[node][0].first;\n    for(int i \u003d 1; i \u0026lt; v[node].size(); i++)\n    {\n        dpsum[node][i] \u003d dpsum[node][i-1] + v[node][i].first*v[node][i].second;\n    }\n    if(l\u003d\u003dr)return;\n    build(node*2, l, (l+r)/2);\n    build(node*2+1, (l+r)/2+1, r);\n}\n\nlli query(int node, int L, int R, int l, int r, int k)\n{\n    if(l \u0026gt; R || r \u0026lt; L || L \u0026gt; R)return 0;\n    if(L \u0026gt;\u003d l \u0026amp;\u0026amp; R \u0026lt;\u003d r)\n    {\n        int idx \u003d lower_bound(v[node].begin(), v[node].end(), make_pair((lli)k+1,(lli)0)) - v[node].begin();\n        lli sum \u003d 0;\n        int tt \u003d v[node].size()-1;\n        sum \u003d dpsum[node][tt] - dpsum[node][idx-1];\n        return sum;\n    }\n    lli aa \u003d query(node*2, L, (L+R)/2, l, r, k);\n    lli bb \u003d query(node*2+1, (L+R)/2+1, R, l, r, k);\n    return (aa+bb);\n}\n\nint main()\n{\n    Sieve();\n    \n    int n, q;\n    \n    scanint(n);\n    scanint(q);\n    \n    int a[n+1];\n    for(int i \u003d 1; i \u0026lt;\u003d n; i++)\n        scanint(a[i]);\n        \n    map\u0026lt;int, int\u0026gt; ss;\n    \n    for(int i \u003d 1; i \u0026lt;\u003d n; i++)\n    {\n        int temp \u003d a[i];\n        while(temp \u0026gt; 1)\n        {\n            if(ss[sp[temp]] \u003d\u003d 0){\n            dp[i] +\u003d sp[temp];ss[sp[temp]]\u003d1;}\n            temp \u003d temp/sp[temp];\n        }\n        ss.clear();\n    }\n    \n    build(1, 1, n);\n    while(q--)\n    {\n        int l, r, k;\n        scanint(l);scanint(r);scanint(k);\n        printf(\u0026quot;%lld\\n\u0026quot;,query(1, 1, n, l, r, k));\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["seg tree"]}}