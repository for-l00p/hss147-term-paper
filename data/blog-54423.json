{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1504936054,"rating":5,"authorHandle":"jamiechoi","modificationTimeSeconds":1504936717,"id":54423,"title":"\u003cp\u003eEditorial for Mini-Competition #5\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eA. Takagi and Calculator\u003c/h3\u003e\u003cp\u003eThis is a straightforward problem. Just process all N queries one by one. Using int to store the two numbers and the result is enough, as the largest value to be stored \u003d 10^4 * 10^4 \u003d 10^8.\u003c/p\u003e\u003cp\u003eComplexity: O(N)\u003c/p\u003e\u003cp\u003e[submission:30205401]\u003c/p\u003e\u003ch3\u003eB. Takagi and Atbash Cipher\u003c/h3\u003e\u003cp\u003eThis is also a straightforward problem.\u003c/p\u003e\u003cp\u003eCreate a character array of size at least 127. Fill the array with the character with character code equal to the index of the array. Then process the alphabet by storing the reverse of each character in the array. Finally, replace every character in the message with the value in the array and output the string.\u003c/p\u003e\u003cp\u003eComplexity: O(N + K), where N is the length of message and K is the size of the alphabet.\u003c/p\u003e\u003cp\u003e[submission:30205404]\u003c/p\u003e\u003ch3\u003eC. Takagi and Factors\u003c/h3\u003e\u003cp\u003eWith the constraints, it is easily seen that a brute force solution would not work. Therefore, we need to use maths to help us.\u003c/p\u003e\u003cp\u003eLet f(x, y) denote the number of factors of m in the range [1, n].\u003c/p\u003e\u003cp\u003eTo solve this problem, you need to know that f(m, n) \u003d n / m. Therefore, the number of factors of m in the range [L, R] would be f(m, R) — f(m, L — 1). We can now calculate the number of factors of x and y in the range [L, R]. \u003c/p\u003e\u003cp\u003eHowever, we need to subtract the overlapped part, which is f(LCM(x, y), R) — f(LCM(x, y), L — 1). However, LCM(x, y) may overflow long long, so you may need to check whether it will overflow. Another solution to prevent overflowing is using Python or Java, which has BigInteger implemented in the language. (Note: Python solution require 904 ms)\u003c/p\u003e\u003cp\u003eComplexity: O(T)\u003c/p\u003e\u003cp\u003e[submission:30205408]\u003c/p\u003e\u003ch3\u003eD. Takagi and Circles\u003c/h3\u003e\u003cp\u003eWe can reduce this problem to a case where there are only two circles. Then we would need to decide whether the two circles would intersect / touch.\u003c/p\u003e\u003cp\u003eGiven two circles, it can be easily shown that these two circles intersect if the distance between the two centres is not longer than the sum of the radius of the two circles.\u003c/p\u003e\u003cp\u003eFor cases with more than two circles, simply exhaust all pairs of circles and check if they intersect.\u003c/p\u003e\u003cp\u003eComplexity: O(N^2)\u003c/p\u003e\u003cp\u003e[submission:30205413]\u003c/p\u003e\u003ch3\u003eE. Takagi and Squares\u003c/h3\u003e\u003cp\u003eFor this question, we can observe the fact that each pair of horizontal and vertical segment of the same length form one square. If there are x horizontal line segments and y vertical line segments of length L, then x * y squares of size L * L will be formed.\u003c/p\u003e\u003cp\u003eTherefore, exhaust all pairs of points on x-axis and y-axis and store them in two separate frequency arrays xf and yf. Iterate through the two frequency arrays to calculate the sum of xfi * yfi, which is the required answer.\u003c/p\u003e\u003cp\u003eComplexity: O(N^2 + M^2)\u003c/p\u003e\u003cp\u003e[submission:30205418]\u003c/p\u003e\u003ch3\u003eF. Takagi and Markup\u003c/h3\u003e\u003cp\u003eMaintain a stack of the tags and iterate through the post.\u003c/p\u003e\u003cp\u003eWhen there is a start tag, push it to the stack.\u003c/p\u003e\u003cp\u003eWhen there is a end tag, check if it is equal to the top in the stack. If it is equal, pop the stack. If it isn\u0027t equal, then output \u0026quot;NO\u0026quot; and terminate the program.\u003c/p\u003e\u003cp\u003eFinally, check whether the stack is empty. Output \u0026quot;YES\u0026quot; if the stack is empty, and output \u0026quot;NO\u0026quot; otherwise.\u003c/p\u003e\u003cp\u003eComplexity: O(N) where N is the length of the post.\u003c/p\u003e\u003cp\u003e[submission:30205423]\u003c/p\u003e\u003ch3\u003eG. Takagi and Food\u003c/h3\u003e\u003cp\u003eWe should notice that both the total health and deliciousness at the last day must be within the range [-900, 900]. So we can DP on either the health or the deliciousness by greedily choosing the best food.\u003c/p\u003e \u003cul\u003e   \u003cli\u003edp[d][n] can denote the maximum healthiness on day d with deliciousness n; or\u003c/li\u003e   \u003cli\u003edp[d][n] can denote the maximum deliciousness on day d with healthiness n.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eAfter this, just iterate through the array one to choose the maximum deliciousness achievable.\u003c/p\u003e\u003cp\u003eComplexity: O(N^2 * max(x_i) * max(w_i))\u003c/p\u003e\u003cp\u003e[submission:30205429]\u003c/p\u003e\u003c/div\u003e","tags":[]}}