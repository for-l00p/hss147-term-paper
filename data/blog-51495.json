{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1491650051,"rating":-5,"authorHandle":"Kasparyan_Mikhail","modificationTimeSeconds":1491907308,"id":51495,"title":"\u003cp\u003eЗадача\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eДан граф из N вершин. Граф задан матрицей смежности. Ребра нагружены. Найти дешевый гамильтонов цикл. Стоимость равна сумме весов ребер в построенном цикле. Решение предоставляется в виде последовательности вершин. Первая и последняя вершины — вершина с номером 0. В файле в первой строке записано число вершин в графе. Затем идет N строк матрицы смежности. \u003ca href\u003d\"https://drive.google.com/open?id\u003d0Bz7LEA5c-pA5TWRWeTRZbE9jclU\"\u003eСсылка на файл.\u003c/a\u003e Ниже написан код глупого решения. Вам там понадобится только функция оценки решения \u003cstrong\u003ecalcSolution\u003c/strong\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;limits\u0026gt;\n#include \u0026lt;set\u0026gt;\nusing namespace std;\n\nuint64_t calcSolution(int n, vector\u0026lt;int\u0026gt;\u0026amp; solution, vector\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt;\u0026amp; mtr) {\n  if (solution.size() !\u003d n + 1) return numeric_limits\u0026lt;uint64_t\u0026gt;::max();\n  if(solution[0] !\u003d solution[n]) return numeric_limits\u0026lt;uint64_t\u0026gt;::max();\n  set\u0026lt;int\u0026gt; st(solution.begin(), solution.end());\n  if(st.size() !\u003d n) return numeric_limits\u0026lt;uint64_t\u0026gt;::max();\n  uint64_t ans \u003d 0;\n  for (int i \u003d 0; i \u0026lt; n; ++i) {\n    ans +\u003d mtr[solution[i]][solution[i + 1]];\n  }\n  return ans;\n}\n\nvector\u0026lt;int\u0026gt; solve(int n, vector\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt;\u0026amp; mtr) {\n  vector\u0026lt;int\u0026gt; ans(n);\n  for (int i \u003d 0; i \u0026lt; n; ++i) {\n    ans[i] \u003d i;\n  }\n  for (int i \u003d 0; i \u0026lt; 10000; ++i) {\n    int x \u003d rand() % (n - 1) + 1;\n    int y \u003d rand() % (n - 1) + 1;\n    swap(ans[x], ans[y]);\n  }\n  ans.push_back(0);\n  return ans;\n}\n\nint main() {\n  int n;\n  cin \u0026gt;\u0026gt; n;\n  vector\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; mtr(n, vector\u0026lt;int\u0026gt;(n));\n  for (int i \u003d 0; i \u0026lt; n; ++i) {\n    for (int j \u003d 0; j \u0026lt; n;++j) {\n      cin \u0026gt;\u0026gt; mtr[i][j];\n    }\n  }\n  vector\u0026lt;int\u0026gt; sol \u003d solve(n, mtr);\n  cout \u0026lt;\u0026lt; calcSolution(n, sol, mtr);\n\n  return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}