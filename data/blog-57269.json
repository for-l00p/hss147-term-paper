{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1516565635,"rating":0,"authorHandle":"SinByCos","modificationTimeSeconds":1516565803,"id":57269,"title":"\u003cp\u003ePersistent Segment Tree help needed â€” implementation giving TLE with pointers, AC without pointers\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI\u0027m solving this problem on Codechef: \u003ca href\u003d\"https://www.codechef.com/problems/PSHTTR\"\u003ehttps://www.codechef.com/problems/PSHTTR\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis problem can be solved online with persistent segment tree (can also be solved offline without persistence), but my solution is giving TLE when I implement it using pointers. Is there any reason why pointers may be significantly slower?? I get AC without pointers in 0.63s but TLE with a time limit of 1.5s.\u003c/p\u003e\u003cp\u003eHere is my implementation using pointers: \u003ca href\u003d\"https://www.codechef.com/viewsolution/17104558\"\u003ehttps://www.codechef.com/viewsolution/17104558\u003c/a\u003e And implementation without pointers: \u003ca href\u003d\"https://www.codechef.com/viewsolution/17104790\"\u003ehttps://www.codechef.com/viewsolution/17104790\u003c/a\u003e\u003c/p\u003e\u003cp\u003eHere is the crux of my implementation using pointers. Its simple point updates and range xor queries:\u003c/p\u003e\u003cp\u003eNote: This is a dynamic persistent segment tree, i.e memory of my tree is not predefined but index of element can be in range of 1 to 1e9. I\u0027m assigning new nodes whenever I find nullptr in left or right positions. Maybe I\u0027m doing something wrong here, or maybe this itself is a very slow method. Any ideas how to speed this up, or is there a better method? I don\u0027t know much about pointers so please forgive me :P\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estruct node {\n    int val;\n    node *left, *right;\n    node (int v, node* l, node* r) {\n        val \u003d v;\n        left \u003d l;\n        right \u003d r;\n    }\n};\n#define null new node (0, NULL, NULL);\n \nnode *version[maxn];\n \nvoid update(node *prev, node *curr, int L, int R, int idx, int val) {\n    curr-\u0026gt;val \u003d prev-\u0026gt;val;\n    if (L \u003d\u003d R) {\n        assert(idx \u003d\u003d L);\n        curr-\u0026gt;val ^\u003d val;\n    }\n    else {\n        if (prev-\u0026gt;left \u003d\u003d nullptr) prev-\u0026gt;left \u003d null;\n        if (prev-\u0026gt;right \u003d\u003d nullptr) prev-\u0026gt;right \u003d null;\n        int mid \u003d (L+R)/2;\n        if (idx \u0026lt;\u003d mid) {\n            curr-\u0026gt;right \u003d prev-\u0026gt;right;\n            curr-\u0026gt;left \u003d null;\n            update(prev-\u0026gt;left, curr-\u0026gt;left, L, mid, idx, val);\n        }\n        else {\n            curr-\u0026gt;left \u003d prev-\u0026gt;left;\n            curr-\u0026gt;right \u003d null;\n            update(prev-\u0026gt;right, curr-\u0026gt;right, mid+1, R, idx, val);\n        }\n        curr-\u0026gt;val \u003d curr-\u0026gt;left-\u0026gt;val ^ curr-\u0026gt;right-\u0026gt;val;\n    }\n}\n \nint query (node *curr, int L, int R, int li, int ri) {\n    if (curr \u003d\u003d nullptr || ri \u0026lt; L || li \u0026gt; R)\n        return 0;\n    if (li \u0026lt;\u003d L \u0026amp;\u0026amp; ri \u0026gt;\u003d R)\n        return curr-\u0026gt;val;\n    int mid \u003d (L+R)/2;\n    return query(curr-\u0026gt;left, L, mid, li, ri) ^ query(curr-\u0026gt;right, mid+1, R, li, ri);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCrux of my implementation using a buffer array, without pointers:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estruct node {\n    int val;\n    int left, right;\n    node() : val(0), left(0), right(0) {}\n    node(int val) : val(val), left(0), right(0) {}\n    node(int val, int l, int r) : val(val), left(l), right(r) {}\n};\n \nnode stree[35*maxn];\nint root[maxn], nodeCnt \u003d 0;\n \nvoid update(int old, int \u0026amp;curr, int L, int R, int idx, int val) {\n    curr \u003d ++nodeCnt;\n    stree[curr] \u003d stree[old];\n    if (L \u003d\u003d R) {\n        assert(idx \u003d\u003d L);\n        stree[curr].val ^\u003d val;\n    }\n    else {\n        int mid \u003d (L+R)/2;\n        if (idx \u0026lt;\u003d mid) {\n            update(stree[old].left, stree[curr].left, L, mid, idx, val);\n        }\n        else {\n            update(stree[old].right, stree[curr].right, mid+1, R, idx, val);\n        }\n        stree[curr].val \u003d stree[stree[curr].left].val ^ stree[stree[curr].right].val;\n    }\n}\n \nint query (int curr, int L, int R, int li, int ri) {\n    if (curr \u003d\u003d 0 || ri \u0026lt; L || li \u0026gt; R)\n        return 0;\n    if (li \u0026lt;\u003d L \u0026amp;\u0026amp; ri \u0026gt;\u003d R)\n        return stree[curr].val;\n    int mid \u003d (L+R)/2;\n    return query(stree[curr].left, L, mid, li, ri) ^ query(stree[curr].right, mid+1, R, li, ri);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHelp would be much appreciated!\u003c/p\u003e\u003c/div\u003e","tags":["#help","persistent segment tree","pointers","range xor"]}}