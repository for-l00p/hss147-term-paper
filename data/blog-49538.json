{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1483452179,"rating":3,"authorHandle":"LawlietYagami","modificationTimeSeconds":1483452179,"id":49538,"title":"\u003cp\u003e3D Kadane\u0027s Algorithm\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI was solving \u003ca href\u003d\"https://uva.onlinejudge.org/index.php?option\u003dcom_onlinejudge\u0026amp;Itemid\u003d8\u0026amp;page\u003dshow_problem\u0026amp;problem\u003d1696\"\u003eUVa 10755 â€” Garbage Heap\u003c/a\u003e abridged statement : Given values in 3D space, compute a 3D rectangle with maximum sum. The 2D version is given a matrix, find a submatrix with maximum sum which can be easily done by using 2D Kadane algorithm. But the 3D version of it seems quite difficult, I solved it using a rather different approach:\u003c/p\u003e\u003cp\u003eFirst storing the 3D rectangle sums starting from (0, 0, 0) to (i, j, k):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    for (int i\u003d0;i\u0026lt;A;++i) for (int j\u003d0;j\u0026lt;B;++j) for (int k\u003d0;k\u0026lt;C;++k) {\n      long long g; cin\u0026gt;\u0026gt;g;\n      if (i\u0026gt;0) g+\u003dm[i-1][j][k];\n      if (j\u0026gt;0) g+\u003dm[i][j-1][k];\n      if (k\u0026gt;0) g+\u003dm[i][j][k-1];\n      if (i\u0026gt;0 \u0026amp;\u0026amp; j\u0026gt;0) g-\u003dm[i-1][j-1][k];\n      if (j\u0026gt;0 \u0026amp;\u0026amp; k\u0026gt;0) g-\u003dm[i][j-1][k-1];\n      if (i\u0026gt;0 \u0026amp;\u0026amp; k\u0026gt;0) g-\u003dm[i-1][j][k-1];\n      if (i\u0026gt;0 \u0026amp;\u0026amp; j\u0026gt;0 \u0026amp;\u0026amp; k\u0026gt;0) g+\u003dm[i-1][j-1][k-1];\n      m[i][j][k]\u003dg;\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen, iterating over all the values in the array and updating max:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (int i\u003d0;i\u0026lt;A;++i) for (int j\u003d0;j\u0026lt;B;++j) for (int k\u003d0;k\u0026lt;C;++k) \n    for (int i1\u003di;i1\u0026lt;A;++i1) for (int j1\u003dj;j1\u0026lt;B;++j1) for (int k1\u003dk;k1\u0026lt;C;++k1)  {\n      long long s \u003d m[i1][j1][k1];\n      if (i\u0026gt;0) s-\u003dm[i-1][j1][k1];\n      if (j\u0026gt;0) s-\u003dm[i1][j-1][k1];\n      if (k\u0026gt;0) s-\u003dm[i1][j1][k-1];\n      if (i\u0026gt;0 \u0026amp;\u0026amp; j\u0026gt;0) s+\u003dm[i-1][j-1][k1];\n      if (j\u0026gt;0 \u0026amp;\u0026amp; k\u0026gt;0) s+\u003dm[i1][j-1][k-1];\n      if (i\u0026gt;0 \u0026amp;\u0026amp; k\u0026gt;0) s+\u003dm[i-1][j1][k-1];\n      if (i\u0026gt;0 \u0026amp;\u0026amp; j\u0026gt;0 \u0026amp;\u0026amp; k\u0026gt;0) s-\u003dm[i-1][j-1][k-1];\n      if (s\u0026gt;max_sum) max_sum \u003d s;\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003emax_sum will be the answer, but the time complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e)\u003c/span\u003e which I believe could be reduced by first applying 2D Kadane over the 2D space and 1D kadane for the remaining dimension, but I\u0027m not sure on how to do that, if anyone\u0027s solved this problem, could you hint me on the right direction Thanks!\u003c/p\u003e\u003c/div\u003e","tags":["kadane","3d kadane","dp","dynamic programming"]}}