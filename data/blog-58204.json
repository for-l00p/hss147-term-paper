{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1520353633,"rating":8,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1520353633,"id":58204,"title":"\u003cp\u003eNotes on Codeforces Beta Round #121, Div2- A, B, C, D, E (classical LCA trick)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/192/problem/A\" title\u003d\"Codeforces Round 121 (Div. 2)\"\u003e192A - Funky Numbers\u003c/a\u003e\u003c/p\u003e\u003cp\u003eMy solution is to first calculate all the integers that have a form of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/11/77/11776e09b647065c7d06c3a8caeffe885671c366.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e while not exceeding \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e. Then, for the given integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, we can enumerate the first term from the previously obtained results and check whether their difference is also an integer that we have computed, which can be implemented based on binary search. The total complexity is thus \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/192/problem/B\" title\u003d\"Codeforces Round 121 (Div. 2)\"\u003e192B - Walking in the Rain\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe can test the threshold from small values to large ones. For each threshold, we check whether the first and last elements are both still “accessible” (event-1), and further check whether there are two consecutive elements, except for the first and last ones, that are not “accessible” (event-2). We find the maximum threshold that event-1 is true and event-2 is false.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/192/problem/C\" title\u003d\"Codeforces Round 121 (Div. 2)\"\u003e192C - Dynasty Puzzles\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe basic idea is dp. We use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e to denote the maximum length that we can obtain while using all the given strings, with starting letter “i” and ending letter “j”. The recursive formula is as follows:\u003c/p\u003e\u003cp\u003eWhen we meet a new string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, with starting letter “k” and ending letter “j”, we should update all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u003d 0, 1, ..., 25\u003c/span\u003e, according to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e] \u003d \u003ci\u003emax\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e], \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e] + \u003ci\u003elength\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e))\u003c/span\u003e, as long as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e] \u0026gt; 0\u003c/span\u003e (this means that we have found some combination of strings that starts with letter “i” and ends with letter “k”). Besides, string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e can also serve as the first string, and thus we should further update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e] \u003d \u003ci\u003emax\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e], \u003ci\u003elength\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e))\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eFinally, we should find out the maximum value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e as the answer.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/192/problem/D\" title\u003d\"Codeforces Round 121 (Div. 2)\"\u003e192D - Demonstration\u003c/a\u003e\u003c/p\u003e\u003cp\u003eNotice that the last element does not affect the result. We first sort the other \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e elements in a decreasing order, and compute the sum of the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e terms as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eks\u003c/i\u003e\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eks\u003c/i\u003e ≤ \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, it means that we have no choice but to select the last element. The reason is that they have enough money to reject any choice unless we select the last one. \u003c/p\u003e\u003cp\u003eOn the other hand, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eks\u003c/i\u003e \u0026gt; \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, it implies that we have a chance to obtain a better result. At first, as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eks\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e[1] + \u003ci\u003ea\u003c/i\u003e[2] + ... + \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e] \u0026gt; \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e (index starts from “1”), it means that we can select any one of their original indices (remember that they have been sorted and thus we should find their “true” indices) as the final result, since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e - (\u003ci\u003ea\u003c/i\u003e[1] + \u003ci\u003ea\u003c/i\u003e[2] + ... + \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e - 1] + \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e + 1] + ... + \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e]) \u0026lt; \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e holds for any \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e and our final choice can not be rejected. Besides, we also have a chance to select any one of the other \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e (the last one is excluded) indices as our final result. It is obvious that we should first try \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[1], \u003ci\u003ea\u003c/i\u003e[2], ..., \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e - 1]\u003c/span\u003e so that the administration has the least money with a value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e - (\u003ci\u003eks\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e])\u003c/span\u003e to reject our final choice. Therefore, we can test the other \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e indices and check whether their cost is larger than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e - (\u003ci\u003eks\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e])\u003c/span\u003e, and if yes, then we can select it. \u003c/p\u003e\u003cp\u003eWe keep updating the “best” result according to the above steps and finally output the answer.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/192/problem/E\" title\u003d\"Codeforces Round 121 (Div. 2)\"\u003e192E - Fools and Roads\u003c/a\u003e\u003c/p\u003e\u003cp\u003eA classical LCA problem.\u003c/p\u003e\u003cp\u003eAt first, we should figure out how to calculate LCA of any given two nodes with compleixty of order \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elogN\u003c/i\u003e\u003c/span\u003e. There are several classical algorithms to solve this and as one can find a large number of materials talking about this, we omit the details here. As for me, I used dfs to build a “timestamp array” and implemented RMQ to calculate LCA.\u003c/p\u003e\u003cp\u003eNext, we use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e to denote the number for which the edges from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to the root node have been visited (quite similar to prefix idea). For instance, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e] \u003d 2\u003c/span\u003e means that every edge from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to the root node has been visited for two times. \u003c/p\u003e\u003cp\u003eFor each query with given nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, we should imcrease \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e by one, respectively while decreasing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003eLCA\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)]\u003c/span\u003e by two. One can draw a simple graph and check this with paper and pen. \u003c/p\u003e\u003cp\u003eAfter dealing with all the queries, we are going to calculate the times for which each edge has been visited. To obtain a correct result, we should visit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e in a decreasing order of the depth of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, and whenever we complete a node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, we should add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e to its parent node. For instance, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is a leaf node and also serves as a child node of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. Then, the edge between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e has been visited for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e times, and we update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e] \u003d \u003ci\u003edis\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e] + \u003ci\u003edis\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e. The reason is that any edge from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e to the root node is counted both in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e, as it belongs to two prefix arrays. \u003c/p\u003e\u003c/div\u003e","tags":[]}}