{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1403075536,"rating":5,"authorHandle":"qwerty787788","modificationTimeSeconds":1403167674,"id":12715,"title":"\u003cp\u003eCodeforces #253 editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eAs my english is not very good, please if you see any mistake write me a private message about it.\u003c/p\u003e\u003cp\u003e(link Div2A)\u003c/p\u003e\u003cp\u003eIn this task you are to count the number of different letters in the set. In my opinion the easiest way to do this looks like this. You jush iterate over all small latin letters and check if the string contains it (with built-in functions).\u003c/p\u003e\u003cp\u003e(link Div2B)\u003c/p\u003e\u003cp\u003eLet\u0027s add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e question marks to the string. Than we can check all possible starting and ending positions of tandem repeat in a new string. We can check each of them in time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e. We only need to check that some symbols are equal (in our task question mark is equal to every symbol).\u003c/p\u003e\u003cp\u003e(link Div1A)\u003c/p\u003e\u003cp\u003eIt\u0027s obvious that the order of hints doesn\u0027t metter. There are 10 types of hints, so we can try all \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e10\u003c/sup\u003e\u003c/span\u003e vartiants of what other players should do. Now we need to check if Boris can describe all of his cards. He can do it iff he can distinguish all pairs of different cards. He can do it if somebody told at least one distinction. It can be a hint about color of one of cards (if they don\u0027t have same one) or it can be hint about value of some card.\u003c/p\u003e\u003cp\u003e(link Div1B)\u003c/p\u003e\u003cp\u003eLet\u0027s sort all friends in such a way that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e iff \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. If there is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 1\u003c/span\u003e Andrey should ask only this friend. Now we can assume that all probabilities are less then 1. What should we maximize?\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7b/55/7b5554320f179a1434ad23f39527bfc5e7f52691.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eLet \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0c/16/0c16ac6bc9f18b0a4c83698fef33638ac1c8572c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1a/97/1a97f3a54a49b7cb5445fc67cd232f5fb777f994.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Assume we already have some group of pepole we would ask a help. Let\u0027s look what will happen with the probability of success if we add a friend with probability \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to this group:\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/27/d3/27d389aff60abe89688c3b02c05c35fab92a4f30.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eIt means adding a new people to group will increase a probability os success only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u0026lt; 1\u003c/span\u003e. Now let\u0027s look at another question. We have some group of people with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u0026lt; 1\u003c/span\u003e. And we want to add only one friend to this group. Which one is better? Let the probability of the first friend is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and the second friend is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. It\u0027s better to add first one if \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003eΔ\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - Δ\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eP\u003c/i\u003e·\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e·(1 - \u003ci\u003eS\u003c/i\u003e) - \u003ci\u003eP\u003c/i\u003e·\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e·(1 - \u003ci\u003eS\u003c/i\u003e) \u003d \u003ci\u003eP\u003c/i\u003e·(1 - \u003ci\u003eS\u003c/i\u003e)·(\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e) \u0026gt; 0\u003c/span\u003e. As \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u0026lt; 1\u003c/span\u003e we get \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u0026gt; \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eBut it\u0027s only a local criteria of optimality. But, we can prove that globally you should use only a group of pepole with the biggest probabilities. We can use proof by contradiction. Let\u0027s look on the optimal answer with biggest used suffix (in the begining of editorial we sort all friends). Of all such answers we use one with minimum number of people in it. Where are two friends \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e \u0026lt; \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e) and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th friend is in answer and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e-th isn\u0027t. Let\u0027s look on the answer if we exclude \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th friend. It should be smaller because we used optimal answer with minimum numer of people in it. So adding a new people to this group will increase success probability. But we know that adding \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e-th is better than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th. So we have found a better answer.\u003c/p\u003e\u003cp\u003eSo we have a very easy solution of this problem. After sorting probabilities we should you some suffix of it. Because of sorting time complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlogn\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e(link Div1C)\u003c/p\u003e\u003cp\u003eIt\u0027s obvious that we should never delete the first and last elements of array. Let\u0027s look on the minimum number. Let it be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e elements in the array. We can subtract \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e from all elements and the answer for the problem will dicrese on \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e - 2)·\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, becouse we will do \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 2\u003c/span\u003e delitions of middle elements and each of this delitions will not give Artem exectly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e more points.\u003c/p\u003e\u003cp\u003eIf minimal element was the first or the last one, we can not to count it now (it equals to 0 now, so it will not affect the answer now). If it locates in the middle of array, we can prove that there is exist an optimal solution when Artem deletes this element on first move. We can prove it by contradaction. Let\u0027s look at the optimal answer where the minimal element is deleted on the minimal possible move (but not on first one). We can prove that we can delete it earlier. If move which is exactly before deleting minimum uses element of array which isn\u0027t a neighbour of minimual one we can swap this two delitions and it will not affect the answer. If those elements are neighbours we can write down the number of points which we obtain in both cases and understand that to delete minimum first is the best choice.\u003c/p\u003e\u003cp\u003eSo, in this task we need to maintain a set of all not deleted elements and to find a smallest alive element. All of it we can do with built-in data structures in time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlogn\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e(link Div1D)\u003c/p\u003e\u003cp\u003eFirst, let\u0027s solve the task with already built tree. We can do it with easy dymanic programming. We will count the answer for subtree with an edge to the parent. If we can count it for all vertices we can calculate the answer for the whole tree as maximum of answers for children of root. How to calculate it for one vertex? Suppose we already know answers for children of this vertex. We should color the edge to the parent in the same color as edge to the child with maximum answer. Let two maximum answers for child are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e than the answer for this vertex would be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(\u003ci\u003emax\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003emax\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + 1)\u003c/span\u003e if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ≥ \u003ci\u003emax\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWhat changes when we can add new vertices? Nothing. We can calculate the value of dynamic programming for new vertex (it always would be 1) and recalculate value for its parent. If it doesn\u0027t change we should stop this process, in another case we continue recalculations of dynamic programming values: go to its parent and recalculate answer for it and so on. If we maintain two maximums for each vertex in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e the asymptotic of the algorithm would be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlogn\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTo prove it we can use some facts about Heavy-light decomposion. We can use the way Heavy-light decomposion splits edges of tree as our decomposition. We know that answer for such decomposition will be less than logarithm of the number of vertices. So each value of dynamic programming will be increased not more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogn\u003c/i\u003e)\u003c/span\u003e times.\u003c/p\u003e\u003cp\u003e(link Div1E)\u003c/p\u003e\u003cp\u003eTo solve this problem we can use a binary search. How do we check that answer if not less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e? It means that we can draw a circle with such radius which center locates in the rectangle and there are no more than one point inside this circle. How could we check it? We always can shift this circle in such a way that at least one point would be on its border. We can try all points as one which is on border. Than we should draw a circle with center in it and intersect it with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e circles built on other points. If there is a point on this circle which is covered with no more than one other circle, than answer is greater or equal \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e. Finding such point is almost a typical problem which can be solved in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eklogk\u003c/i\u003e)\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e — number of intersections points of circles.\u003c/p\u003e\u003cp\u003eWe described a solution which works in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogAnswer\u003c/i\u003e·\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e·\u003ci\u003elogn\u003c/i\u003e)\u003c/span\u003e. But we can make it faster. Let\u0027s try all vertices as centers of circles and inside this loop make a binary search. We can make one optimize: if we can\u0027t find a point on circle with radius which is equal to the best now known than we shouldn\u0027t do a binary search in this point (because we can\u0027t increase the answer). It can be proved that this solution in avarage case works in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/74/8f/748f39de6aea6fe486bcd29fde2c2e70202d8364.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e if we shuffle points. It\u0027s true because a binary search will be used in avarage only \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/23/25/23252b0fc4d48df9962f8b56307b87565eba520a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e times. This is connected to the fact that the biggest increasing subseqence in random permutation has length near \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/23/25/23252b0fc4d48df9962f8b56307b87565eba520a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (you can find more information about it in wikipedia). \u003c/p\u003e\u003cp\u003eIn this task there are some technical issues you need to know about. For example, we would do a binary search only \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/91/32913ddf691f31b4d68f1a13d186d75779229920.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e times if we find a stricly incresing subseqence of answers. That\u0027s why before using a binary search we should check that we can obtain not current answer but current answer plus some small value. Also we need to understand what \u0026quot;small value\u0026quot; is (it should be something like \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eeps\u003c/i\u003e·\u003ci\u003ecurAnswer\u003c/i\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eeps\u003c/i\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e - 9\u003c/sup\u003e\u003c/span\u003e, in another case you will probably have some problems with accuracy).\u003c/p\u003e\u003cp\u003eAlso one interesting fact about this problem. If you write a solution with time compexity equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogAnswer\u003c/i\u003e·\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e·\u003ci\u003elogn\u003c/i\u003e)\u003c/span\u003e, it will work very fast on random tests becaue there are will be a very small number of circle intersections.\u003c/p\u003e\u003c/div\u003e","tags":[]}}