{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1456155323,"rating":41,"authorHandle":"darkshadows","modificationTimeSeconds":1456366118,"id":43286,"title":"\u003cp\u003e[GYM] 2016 CodeCraft IIIT Hyderabad Tutorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100889/problem/A\" title\u003d\"2016 CodeCraft IIIT Hyderabad Replay\"\u003e100889A - A Beautiful Array\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eGiven an array of integers, find a permutation of the array to maximize the sum \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f2/c2/f2c2b2e0e894633f7d10bce4fe5bb79337c0a334.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003c/p\u003e\u003cp\u003eIf we observe the formula closely we see that we have to calculate \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/72/df/72df48cb2e9fb7b1fac82343ecbd032148006146.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. If the array is of odd length, we can simply skip the middle element. This can be maximized by putting the large numbers in the right half, and the small numbers in the left half. One good way to do this is to simply sort the array in ascending order.\u003c/p\u003e\u003cp\u003eComplexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bb/3f/bb3fe14216c01555ddffcd9026f0cf662ff533a4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003cbr /\u003eCode: \u003ca href\u003d\"http://ideone.com/nJddvt\"\u003ehttp://ideone.com/nJddvt\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100889/problem/B\" title\u003d\"2016 CodeCraft IIIT Hyderabad Replay\"\u003e100889B - Backward and Forward\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eGiven an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e, make it palindromic using minimum merging operations. In one merging operation two adjacent elements can be replaced by their sum.\u003c/p\u003e\u003cp\u003eTo make an array a palindromic we can simply apply merging operations \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e times where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is the size of array. In that case,size of array will be reduced to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. But, in this problem we are asked to do it in minimum number of operations.\u003c/p\u003e\u003cp\u003eLet’s denote by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e as minimum merging operations to make a given array a mirror from index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. If , \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u003d \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e answer is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e.\u003cbr /\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d  \u003d \u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, then there is no need to do any merging operations at index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e or index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e . Our answer in this case will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003ej\u003c/i\u003e - 1)\u003c/span\u003e.\u003cbr /\u003eBut if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003earr\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] ≠ \u003ci\u003earr\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e, then we need to do merging operations. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003earr\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u0026gt; \u003ci\u003earr\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e, then we should do merging operation at index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. We merge index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e - 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, and update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e - 1\u003c/sub\u003e \u003d \u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e - 1\u003c/sub\u003e + \u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Our answer in this case will be \u003cspan class\u003d\"tex-span\"\u003e1 + \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e - 1)\u003c/span\u003e.\u003cbr /\u003eFor the case when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u0026lt; \u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e \u003d \u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e. Our answer in this case will be \u003cspan class\u003d\"tex-span\"\u003e1 + \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eOur answer will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(0, \u003ci\u003en\u003c/i\u003e - 1)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is size of array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e. This problem can also be solved iteratively using 2 pointers(first pointer pointing to start of the array and second pointer pointing to last element of the array) method and keeping count of total merging operations done till now.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e.\u003cbr /\u003eCode: \u003ca href\u003d\"http://ideone.com/lIHYJF\"\u003ehttp://ideone.com/lIHYJF\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100889/problem/C\" title\u003d\"2016 CodeCraft IIIT Hyderabad Replay\"\u003e100889C - Chunin Exam\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eYou are required to reach \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eN\u003c/i\u003e, \u003ci\u003eM\u003c/i\u003e)\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e(1, 1)\u003c/span\u003e, where in matrix \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e cells are blocked and you are allowed two type of queries:\u003cbr /\u003e- Look at adjacent squares. - Go to adjacent squares.\u003c/p\u003e\u003cp\u003eYou can use constant memory and at-most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(12 * \u003ci\u003eP\u003c/i\u003e)\u003c/span\u003e queries.\u003c/p\u003e\u003cp\u003eHow would you come out of a maze full of darkness(i.e. you can just check adjacent cells) and with you having memory just enough to remember the last cell you came from? The idea is very intuitive: just walk along the walls(assume blocked cells as a wall)! Its guaranteed that path exists, so in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eP\u003c/i\u003e + \u003ci\u003eN\u003c/i\u003e + \u003ci\u003eM\u003c/i\u003e)\u003c/span\u003e queries worst case, we should safely reach our destination.\u003c/p\u003e\u003cp\u003eSo, we put our left/right hand on wall and start walking in that direction. For each cell that we are visiting, we maintain the current direction in which wall is. Based on that, we try to extend the wall in possible directions by looking at adjacent blocked cells.\u003c/p\u003e\u003cp\u003eThe worst case where you might perform \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(12 * \u003ci\u003eP\u003c/i\u003e)\u003c/span\u003e queries is when there is a pattern like this:\u003c/p\u003e\u003cp\u003e\u003ccode\u003e| | | | |\u003c/code\u003e\u003cbr /\u003e\u003ccode\u003e| | |0| |\u003c/code\u003e\u003cbr /\u003e\u003ccode\u003e| |0| | |\u003c/code\u003e\u003cbr /\u003e\u003ccode\u003e| | |0| |\u003c/code\u003e\u003cbr /\u003e\u003ccode\u003e| |0| | |\u003c/code\u003e \u003c/p\u003e\u003cp\u003eHere 0 denotes a blocked cell.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/Fintxx\"\u003ehttp://ideone.com/Fintxx\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100889/problem/D\" title\u003d\"2016 CodeCraft IIIT Hyderabad Replay\"\u003e100889D - Dicy Numbers\u003c/a\u003e\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003eAuthor :\u003c/strong\u003e \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/vmrajas\" title\u003d\"Expert vmrajas\"\u003evmrajas\u003c/a\u003e\u003cbr /\u003e\u003cstrong\u003eTester :\u003c/strong\u003e \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Toshad\" title\u003d\"Expert Toshad\"\u003eToshad\u003c/a\u003e\u003cbr /\u003e\u003cstrong\u003eExplanation :\u003c/strong\u003e\u003cbr /\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is represented in its canonical prime factorization as follows :\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sup\u003e * \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sup\u003e...\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/sup\u003e\u003c/span\u003e\u003cbr /\u003eThe number of numbers having their number of positive divisors equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e with their highest prime factor \u003cspan class\u003d\"tex-span\"\u003e ≤ \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u0027\u003ci\u003eth\u003c/i\u003e\u003c/span\u003e prime number is given by : \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e \u003d  \u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e - 1\u003c/sup\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e *  \u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - 1\u003c/sup\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e... *  \u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e - 1\u003c/sup\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eExplanation of Formula :\u003c/strong\u003e The number of divisors of a number x : \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003eα\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sup\u003e * \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003eα\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sup\u003e...\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003eα\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/sup\u003e\u003c/span\u003e\u003cbr /\u003eis given by :\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e \u003d (α\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + 1) * (α\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + 1) * ... * (α\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + 1)\u003c/span\u003e\u003cbr /\u003ewhere \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e denotes number of divisors of number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. We need to find number of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e such that their corresponding \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e \u003d \u003ci\u003en\u003c/i\u003e\u003c/span\u003e.\u003cbr /\u003eThe problem can be seen as for every \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e goes from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e , we need to distribute \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e balls into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e boxes. This reduces the problem to the formula stated above. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComputation of ans :\u003c/strong\u003e Given the formula stated above, we can compute it as follows :\u003cbr /\u003ePrime factors of all number from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e2 * 10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e can be computed efficienlty using sieve. Now, if we know the prime factors of a given number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e , the answer can be computed in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enumber\u003c/i\u003e \u003ci\u003eof\u003c/i\u003e \u003ci\u003eprime\u003c/i\u003e \u003ci\u003efactors\u003c/i\u003e \u003ci\u003eof\u003c/i\u003e \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. As this number is very low (~15) , \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e queries can be easily handled. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCode :\u003c/strong\u003e \u003ca href\u003d\"http://ideone.com/w202fV\"\u003ehttp://ideone.com/w202fV\u003c/a\u003e \u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100889/problem/E\" title\u003d\"2016 CodeCraft IIIT Hyderabad Replay\"\u003e100889E - Everyone wants Khaleesi\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eYou are given a Direct Acyclic Graph(DAG) with no multi-edges and self-loops. Two players play a game in which Player 1 starts at node \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and has to reach node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e by taking one existing directed edge in the graph in one move. Player 2, in one move can remove any existing edge of the graph. Game ends when player 1 has reached node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e or he can\u0027t make a move. Report who wins if both play optimally.\u003c/p\u003e\u003cp\u003eThis is a troll problem! Initially it might look really complex, but the very basic idea is that if player 1 is at distance \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e from his destination and its player 2\u0027s move, player 2 can just remove the edge that player 1 could use to reach node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e in next move. The only way player 2 loses if when nodes \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e are directly connected, in which case player 1 will win in first move.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e\u003cbr /\u003eCode: \u003ca href\u003d\"http://ideone.com/oiXQTR\"\u003ehttp://ideone.com/oiXQTR\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100889/problem/F\" title\u003d\"2016 CodeCraft IIIT Hyderabad Replay\"\u003e100889F - Flipping Rectangles\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem asks for the maximum area of destination rectangle that can be covered by the source rectangle by flipping it atmost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e times.\u003c/p\u003e\u003cp\u003eLet us formalize a good notation for the problem, so that it becomes easier to solve it.\u003cbr /\u003eLet us translate the two rectangles in such a way that the left bottom corner of the source rectangle becomes the origin. As translation does not affect the dimensions of the rectangles, the answer won\u0027t be affected because of this operation. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e denote the side length of the source rectangle along \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e-Axis and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e denote the side length of the source rectangle along \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e-Axis. Let (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e) denote the left bottom corner of the destination rectangle in new coordinate frame. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e be its side lengths along \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e-Axis and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e-Axis respectively.Therefore the corners of the destination rectangle can be given by (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e),(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e + \u003ci\u003ee\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e),(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e + \u003ci\u003ef\u003c/i\u003e\u003c/span\u003e),(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e + \u003ci\u003ee\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e + \u003ci\u003ef\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eLet Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e) denote the rectangle of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e along \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e-Axis and length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e along \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e-Axis such that its left bottom corner is at point (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e * \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e * \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e). Therefore, the original position of the source rectangle can be referred to as Rect(\u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e). Now, the given operation of flipping can be represented as follows \u003c/p\u003e \u003cul\u003e   \u003cli\u003eFlipping it right Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e) goes to Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e)\u003c/li\u003e   \u003cli\u003eFlipping it left Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e) goes to Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e)\u003c/li\u003e   \u003cli\u003eFlipping it above Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e) goes to Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/span\u003e)\u003c/li\u003e   \u003cli\u003eFlipping it below Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e) goes to Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e - 1\u003c/span\u003e)\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eNow, the minimum number of flips required to take source rectangle Rect(0,0) to Rect(i,j) can be found out as |\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e|+|\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e|. Let Rect(x,y) denote the rectangle whose intersection area with the destination rectangle is non-zero and |\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e|+|\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e| is as minimum as possible. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eKey Observation\u003c/strong\u003e : Atleast one of the rectangles Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e), Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + 1\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e), Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e + 1\u003c/span\u003e), Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + 1\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e + 1\u003c/span\u003e), Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - 1\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e), Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - 1\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e - 1\u003c/span\u003e), Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e - 1\u003c/span\u003e), Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + 1\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e - 1\u003c/span\u003e), Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - 1\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e + 1\u003c/span\u003e) covers the maximum intersection area with the destination rectangle.\u003c/p\u003e\u003cp\u003eTherefore, if we are able to find such \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, we can find the answer by finding the maximum intersection area of destination rectangle with the above 9 rectangles. To consider the extra constraint of maximum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e flips, we also need to check if |\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e|+|\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e| \u003cspan class\u003d\"tex-span\"\u003e ≤ \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e while considering Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e) for maximum intersection area.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eHow do we find the required \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e\u003c/strong\u003e?\u003c/p\u003e\u003cp\u003eThese can be found out by the observation that Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e) will contain at least one of the corners of destination rectangle or the points (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e), (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e + \u003ci\u003ee\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e), (\u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e), (\u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e + \u003ci\u003ef\u003c/i\u003e\u003c/span\u003e). Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e) will not contain the corners of destination rectangle in cases when the endpoints of the destination rectangle are on the opposite sides of the coordinate axes.\u003c/p\u003e\u003cp\u003eFor a given point the required \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e such that Rect(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e) contains the point can be computed easily using integer division of the coordinates of point by the sides of the source rectangles.\u003c/p\u003e\u003cp\u003eFor more details \u003ca href\u003d\"http://ideone.com/u97AYD\"\u003ehttp://ideone.com/u97AYD\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100889/problem/G\" title\u003d\"2016 CodeCraft IIIT Hyderabad Replay\"\u003e100889G - Gift Pack\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eSince XOR and AND are bit-wise operators, we can process \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e bit by bit separately. Lets try to construct \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e which gives optimal answer from MSB to LSB. Since they are bounded by \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e\u003c/span\u003e we need to consider less than \u003cspan class\u003d\"tex-span\"\u003e63\u003c/span\u003e bits.\u003c/p\u003e\u003cp\u003eLet\u0027s say \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e at a bit position \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/88/e1/88e13b355009d7ae48395818d341f2858897c81e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, the contribution of this position in answer is\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e((\u003ci\u003ei\u003c/i\u003e^\u003ci\u003ej\u003c/i\u003e) + (\u003ci\u003ej\u003c/i\u003e\u0026amp;\u003ci\u003ek\u003c/i\u003e) + (\u003ci\u003ek\u003c/i\u003e^\u003ci\u003ei\u003c/i\u003e)) * 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003epos\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e \u003c/p\u003e\u003cp\u003eSo now if there was no constraints on values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e we would move from MSB to LSB and simply chose the combination of bits of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e at every bit-position that resulted in maximum contribution to the answer. But how to deal with constraints on them?\u003c/p\u003e\u003cp\u003eA thing to note is:\u003cbr /\u003eLet\u0027s say we are constructing a number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e bit by bit from MSB to LSB. If at any position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e we make a choice such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e becomes greater than a number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e at that bit position, no matter what we choose for further bit position of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e, it can never become \u003cspan class\u003d\"tex-span\"\u003e ≤ \u003ci\u003eq\u003c/i\u003e\u003c/span\u003e.\u003cbr /\u003eSame thing can be said for p \u003cspan class\u003d\"tex-span\"\u003e ≥ \u003c/span\u003e q. \u003c/p\u003e\u003cp\u003eSo while constructing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e from MSB to LSB, the choice of values we have, for each of them, at every bit position depends on the previous choices of values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e.\u003cbr /\u003eWe solve the problem using dynamic programming. \u003c/p\u003e\u003cp\u003eDefine a state as \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0f/7f/0f7f12476c9eedb6d2608fbb6e2f800d9ee05fd7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Following code explains the transition between states. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e//f1 denotes if x has become \u0026gt; L\n//f2, g1, g2 denotes if x, y, z have become \u0026lt; R, \u0026lt; A, \u0026lt; B respectively\n//pos is the bit position currently being looked at\nlld solve(int pos, bool f1, bool f2, bool g1, bool g2)\n{\n\tif(pos\u0026lt;0) return 0; //base case\n\tlld ret \u003d dp[pos][f1][f2][g1][g2];\n\tif(ret!\u003d-1) return ret;\n\tret \u003d 0;\n\tint d1 \u003d 0, d2 \u003d 1; //min, max values the bit can take at this postion for x\n\tif(bit(pos, L) \u003d\u003d 1 \u0026amp;\u0026amp; !f1) d1 \u003d 1; //adjust min value at pos for x\n\tif(bit(pos, R) \u003d\u003d 0 \u0026amp;\u0026amp; !f2) d2 \u003d 0; //adjust max value at pos for x\n\tint D1 \u003d 0, D2 \u003d 1; //min, max values the bit can take at this postion for y\n\tif(bit(pos, A) \u003d\u003d 0 \u0026amp;\u0026amp; !g1) D2 \u003d 0; //adjust max value at pos for y\n\tint DD1 \u003d 0, DD2 \u003d 1; //min, max values the bir can take at this postion for z\n\tif(bit(pos, B) \u003d\u003d 0 \u0026amp;\u0026amp; !g2) DD2 \u003d 0; //adjust max value at pos for z\n\n\t//try all possible combinations for this postion for x, y, z\n\tfor(int i\u003dd1;i\u0026lt;\u003dd2;i++)\n\t\tfor(int j\u003dD1;j\u0026lt;\u003dD2;j++)\n\t\t\tfor(int k \u003d DD1;k\u0026lt;\u003dDD2;k++)\n\t\t\t{\n\t\t\t\t//calculate the contribution this bit cam make in final answer\n\t\t\t\tlld tmp \u003d (1LL*(i^j) + 1LL*(j\u0026amp;k) + 1LL*(k^i))\u0026lt;\u0026lt;pos;\n\t\t\t\t\n\t\t\t\tbool ff1 \u003d f1, ff2 \u003d f2;\n\t\t\t\tbool gg1 \u003d g1, gg2 \u003d g2;\n\t\t\t\t//adjust new flags (f1, f2, g1, g2) depending on current combinations\n\t\t\t\tif(i \u0026gt; bit(pos, L)) ff1 \u003d 1;\n\t\t\t\tif(i \u0026lt; bit(pos, R)) ff2 \u003d 1;\n\t\t\t\tif(j \u0026lt; bit(pos, A)) gg1 \u003d 1;\n\t\t\t\tif(k \u0026lt; bit(pos, B)) gg2 \u003d 1;\n\t\t\t\t//update the ans depending on result for this combination\n\t\t\t\tret \u003d max(ret, tmp + solve(pos-1, ff1, ff2, gg1, gg2));\n\t\t\t}\n\n\t//found the result for this state yay :D\n\treturn (dp[pos][f1][f2][g1][g2] \u003d ret);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100889/problem/H\" title\u003d\"2016 CodeCraft IIIT Hyderabad Replay\"\u003e100889H - Hitting Points\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eYou are given \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e points of a polygon \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e in counter clockwise order. In each query, for a different \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, we put polygon with origin at point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and edge \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e(\u003ci\u003el\u003c/i\u003e + 1)%\u003ci\u003eN\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-axis; and we put an infinite rod on line \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. When this rod falls in counter-clockwise direction, we are supposed to output the indices of vertices where this rod touches first time.\u003c/p\u003e\u003cp\u003eMost interesting observations in g### eometry come via visualisation and drawing. Consider the following image.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"image1\" src\u003d\"/predownloaded/dd/fb/ddfbf5def02048a3d63b2144d04235d5bcfd1b7f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eI have projected edges \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e(for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e ≥ 1\u003c/span\u003e) on new \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-axis(defined by base). If the vertical rod lies in region \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, \u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003c/span\u003e, it\u0027ll touch vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, if its in region \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e, it\u0027ll touch vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e and so on. So, we notice that all edges in counter-clockwise direction are creating a continuous region such that if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e lies in that region, the rod will touch the first point of that edge. If you think about the reason, its quite intuitive. We just have to find the region in which \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e lies, which can be done via binary search on the edges of polygon in counter-clockwise direction. We need to consider those edges whose intersection with new \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-axis lies to right side of polygon(i.e. +ve \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-axis); so basically are searching over right hull of convex polygon.\u003c/p\u003e\u003cp\u003eFor finding the distance on new \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-axis we take intersection with the base line(i.e new \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-axis) and see distance from base points. Also, we can easily take care of rod touching an whole edge, which happens when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is at the boundary of one of the regions of an edge.\u003c/p\u003e\u003cp\u003eComplexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/67/3d/673daf3ad954610b66351c83033ecbac16808cbf.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003cbr /\u003eCode: \u003ca href\u003d\"http://ideone.com/w6DGKA\"\u003ehttp://ideone.com/w6DGKA\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100889/problem/I\" title\u003d\"2016 CodeCraft IIIT Hyderabad Replay\"\u003e100889I - iChandu\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eGiven a string \u003cstrong\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e\u003c/strong\u003e of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e consisting of only lower case letters, you have to replace a character at exactly 1 position with the character \u0027$\u0027 such that the number of distinct palindromes in the final string is maximum.\u003c/p\u003e\u003cp\u003eWhat we need to do is for every position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e count the number of:\u003c/p\u003e \u003cul\u003e   \u003cli\u003enew palindromes that would be created, if the substitution was made at index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eold palindromes that would be destroyed, if the substitution was made at index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eFor the first case, since the new character is distinct from all the earlier ones it can only create odd length palindromes with \u0027$\u0027 at the middle.\u003c/p\u003e\u003cp\u003eHence the number of palindromes created when a substitution is made at index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, will be equal to the number of odd length palindromes that already exist with index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e as the center. This can be found for every \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e in O(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e) using Manacher\u0027s algorithm.\u003c/p\u003e\u003cp\u003eFor the second case, what we need to note is that the maximum number of distinct palindromes in a string of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, because at every index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, only 1 distinct palindrome can be ending there.\u003c/p\u003e\u003cp\u003eNow consider one of the distinct palindromes present in string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e, let it be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e might occur in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e more than once. After the substitution, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e will no longer exist if and only if the index of the substitution is present in each and every occurrence of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e. For index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to be present in each occurrence of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e must be present in the overlap of every occurrence of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e. The overlap of every occurrence of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e is equal to the overlap of the first and last occurrence of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e. So if the substitution is made in the overlap of the first and last occurrence of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e will be \u0027destroyed\u0027.\u003c/p\u003e\u003cp\u003eHence we need to find all distinct palindromes and for each one we need to find the first and last occurrence of it. This can be done with a palindromic tree.\u003c/p\u003e\u003cp\u003eConstruct a palindromic tree for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e, this will provide the first occurrence of every distinct palindrome. Similarly construct a palindromic tree reverse of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e, this will provide the last occurrence of every distinct palindrome. Now for every distinct palindrome preform a range update of +1 for the range of overlap of the first and last occurrence of that palindrome, because a substitution in that range will destroy that palindrome.\u003c/p\u003e\u003cp\u003eNow finally check which index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e has maximum of number of palindromes created \u003cspan class\u003d\"tex-span\"\u003e - \u003c/span\u003e number of palindrome destroyed.\u003c/p\u003e\u003cp\u003eFinal complexity: O(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e)\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/bxH8O0\"\u003ehttp://ideone.com/bxH8O0\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100889/problem/J\" title\u003d\"2016 CodeCraft IIIT Hyderabad Replay\"\u003e100889J - Jittery Roads\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eGiven a weighted undirected tree, handle 2 types of queries:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eUpdate weight of edge between two nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eFor a subset of nodes(special nodes), find for every special node the distance to the special node farthest from it.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eFirst let’s look at a simpler version of the problem. Consider there were no updates and all nodes of the tree were special nodes. Let the tree be rooted at node \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. For every node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, the farthest node from it will either be in its subtree or not. With one DFS, we can compute for every node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, what is the maximum distance to any node in its subtree. \u003c/p\u003e\u003cp\u003e\u003ccode\u003e-\u0026gt; in_subtree[u] \u003d max(in_subtree[v] + E(u,v)) for all ‘v’, where ‘v’ is a child of ‘u’ and E(u,v) is the weight of the edge between ‘u’ \u0026amp; ‘v’.\u003c/code\u003e \u003c/p\u003e\u003cp\u003eWith another DFS, we can compute for every node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, what is the maximum distance to any node NOT in its subtree. \u003c/p\u003e\u003cp\u003e\u003ccode\u003e-\u0026gt; out_of_subtree[u] \u003d max(in_subtree[v] + E(u,p) + E(v,p)) for all ‘v’, where ‘v’ is sibling of ‘u’ and ‘p’ is the parent of both.\u003c/code\u003e\u003cbr /\u003e\u003ccode\u003e-\u0026gt; out_of_subtree[u] \u003d max(out_of_subtree[u], out_of_subtree[p] + E(u,p)), where ‘p’ is the parent of ‘u’.\u003c/code\u003e\u003c/p\u003e\u003cp\u003eFinally for every node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, answer will be the maximum of \u003ccode\u003ein_subtree[u]\u003c/code\u003e and \u003ccode\u003eout_of_subtree[u]\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eComing to a slightly more advanced form of the problem, consider there are no updates but now special nodes can be any subset of nodes. When we have a query with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e special nodes, we can construct an auxiliary tree of those K nodes and solve for that new tree with the DP used above. \u003c/p\u003e\u003cp\u003eTo construct an auxiliary tree, we need all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e special nodes and LCAs of every pair of special nodes. But LCAs of every pair of special nodes is equal to LCAs of every adjacent pair of special nodes when the special nodes are sorted in preorder of the tree(arrival time of nodes in DFS). Now for the weights of the edges in the auxiliary tree, weight of edge between node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e will be equal to distance between nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in the original tree. This can be handled if distance between every node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and root of original tree is precomputed.\u003c/p\u003e\u003cp\u003eNow to handle updates as well. Note that for every node, the only information that we require and that can be changed after updates is the distance to root. If edge between node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and its parent \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is updated from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e, the only changes will be for distance to root from every node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e\u0027s subtree, and the change will be same for all, i.e. for every node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e:\u003cbr /\u003e\u003ccode\u003edist_to_root[v] \u003d dist_to_root[v] - w1 + w2\u003c/code\u003e \u003c/p\u003e\u003cp\u003eNow if we maintain an array of \u003ccode\u003edist_to_root[]\u003c/code\u003e sorted in preorder of nodes, any subtree is a continuous range. Thus the updates of edges can be handled with an array that can handle: \u003c/p\u003e \u003cul\u003e   \u003cli\u003eRange Update(add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - \u003ci\u003ew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e to range of subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e)\u003c/li\u003e   \u003cli\u003ePoint query(query for \u003ccode\u003edist_to_root[u]\u003c/code\u003e)\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThis can be handled using a Segment Tree or Fenwick Tree. \u003c/p\u003e\u003cp\u003eComplexity: \u003c/p\u003e \u003cul\u003e   \u003cli\u003eUpdate \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/72/bf/72bf5415ccb01677f64da293871792056ffcac77.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/li\u003e   \u003cli\u003eQuery \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/de/32de9b1acd742967a56aa98a1742275ee1941c7f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSolution: \u003ca href\u003d\"http://ideone.com/UyhQDX\"\u003ehttp://ideone.com/UyhQDX\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThere are others approaches as well, such as: \u003c/p\u003e \u003cul\u003e   \u003cli\u003eUpdates can be handled using HLD (Longer code and slower).\u003c/li\u003e   \u003cli\u003eCentroid Decomposition; Solution: \u003ca href\u003d\"http://ideone.com/2YnsZc\"\u003ehttp://ideone.com/2YnsZc\u003c/a\u003e\u003c/li\u003e   \u003cli\u003eBreaking apart the queries into those with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/64/d3/64d3d46a9e34317cdfb288e1c477de607bdd682a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and those with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/66/00/6600df095849af13908969e983eb79c78d7c87a0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Apply \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eK\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e brute force for first case and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e DFS on entire tree for latter case.\u003c/li\u003e \u003c/ul\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100889/problem/K\" title\u003d\"2016 CodeCraft IIIT Hyderabad Replay\"\u003e100889K - Kill Bridges\u003c/a\u003e\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003eSetter :\u003c/strong\u003e \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/tanujkhattar\" title\u003d\"Candidate Master tanujkhattar\"\u003etanujkhattar\u003c/a\u003e\u003cbr /\u003e\u003cstrong\u003eTester :\u003c/strong\u003e \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/itisalways42\" title\u003d\"Expert itisalways42\"\u003eitisalways42\u003c/a\u003e , \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/karanaggarwal\" title\u003d\"Candidate Master karanaggarwal\"\u003ekaranaggarwal\u003c/a\u003e\u003cbr /\u003e\u003cstrong\u003eProblem Statement :\u003c/strong\u003e\u003cbr /\u003eGiven a connected undirected unweighted graph with N nodes and M edges, you can add at most K edges in the graph, tell the maximum number of bridges that can be removed from the graph. There will be Q queries, each specifying a different K .\u003cbr /\u003e\u003cstrong\u003eSolution :\u003c/strong\u003e\u003cbr /\u003eFirst of all, shrink the 2-edge biconnected components of the given graph and build it\u0027s \u003ca href\u003d\"https://tanujkhattar.wordpress.com/2016/01/10/the-bridge-tree-of-a-graph/#more-7\"\u003eBridge Tree\u003c/a\u003e.The problem now reduces to :\u003cbr /\u003eGiven a tree , we need to do select 2*K leaves of the tree and do their matching such that if a pair of leaves (u,v) is matched, we color the path from u to v in the tree. We want to maximize the number of colored edges after the paths joining all the K pairs has been colored. Note that in the process an edge might be colored multiple times but it would be counted only once in the final answer.\u003cbr /\u003eBefore we solve the above problem, let us look at the following two lemmas :\u003cbr /\u003e\u003cstrong\u003eLemma-1 :\u003c/strong\u003e In the optimal solution , the subgraph formed by the colored edges would be connected.\u003cbr /\u003e\u003cstrong\u003eProof :\u003c/strong\u003e If it is not so, let (u,v) be an edge such that it is not colored and there exists colored subgraphs on either side of this edge in the tree. Let (x,y) be a pair of matched leaves towards the left side of the edge and let (p,q) be a pair of matched leaves towards the right side of the edge. Without loss of generality, we can match (x,p) and (y,q) such that whatever edges were colored earlier remain colored and the edge (u,v) is now also colored. Same argument can be inductively extended and we can say that in the optimal solution the subgraph formed would always be connected.\u003cbr /\u003e\u003cstrong\u003eLemma-2 :\u003c/strong\u003e The center of the tree would always be a part of the optimal connected subgraph.\u003cbr /\u003e\u003cstrong\u003eProof :\u003c/strong\u003e The proof of this is left as an exercise to the reader (Hint : For K\u003d1, we would always join the end points of the diameter )\u003c/p\u003e\u003cp\u003eUsing the above two lemma\u0027s, we can move on with the implementation of the greedy approach as follows :\u003cbr /\u003e1. Root the tree at its center.\u003cbr /\u003e2. Break the tree into chains using HLD type idea, where at any node a special child would be the one that has longest chain lying in it\u0027s subtree with one end point at that node.\u003cbr /\u003e3. For every leaf, define contribution of that leaf as the length of chain that ends at that leaf. The contribution can be found out as follows : \u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid dfs(int u,int p,int len\u003d0)\n{\n    bool isLeaf\u003dtrue;\n    for(auto w:tree[u])\n    {\n        if(w\u003d\u003dp)continue;\n        isLeaf\u003dfalse;\n        if(far[u]\u003d\u003dfar[w])dfs(w,u,len+1); //special child\n        else dfs(w,u,1); //start a new chain\n    }\n    if(isLeaf)cntbn.PB(len);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSort the leaves in descending order of their contributions and for a query K, pick the first 2*K leaves from the sorted order and add their contribution to get the final answer. \u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://ideone.com/pLCPcP\"\u003ehttp://ideone.com/pLCPcP\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/100889/problem/L\" title\u003d\"2016 CodeCraft IIIT Hyderabad Replay\"\u003e100889L - Lazy Mayor\u003c/a\u003e\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003eProblem Idea :\u003c/strong\u003e \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/vmrajas\" title\u003d\"Expert vmrajas\"\u003evmrajas\u003c/a\u003e\u003cbr /\u003e\u003cstrong\u003eAuthor :\u003c/strong\u003e \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/itisalways42\" title\u003d\"Expert itisalways42\"\u003eitisalways42\u003c/a\u003e\u003cbr /\u003e\u003cstrong\u003eTester :\u003c/strong\u003e \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/hulkblaster\" title\u003d\"Expert hulkblaster\"\u003ehulkblaster\u003c/a\u003e\u003cbr /\u003e\u003cstrong\u003eProblem Statement\u003c/strong\u003e:\u003cbr /\u003eGiven an undirected weighted graph of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e nodes, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e edges and a non-negative integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, you need to find out for each pair of nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, Let the shortest distance between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e using atmost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e edges be \u003ccode\u003edist[u][u]\u003c/code\u003e. We have to compute \u003ccode\u003edist[u][v]\u003c/code\u003e and the count of paths from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e with atmost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e edges such that the distance of such paths is equal to \u003ccode\u003edist[u][v]\u003c/code\u003e. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDifficulty\u003c/strong\u003e:Medium \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eExplanation\u003c/strong\u003e:\u003cbr /\u003eThe problem can be solved using dynamic programming. Let \u003ccode\u003edp[x][y][z]\u003c/code\u003e be the shortest distance between node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e using atmost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e edges and let \u003ccode\u003ecnt[x][y][z]\u003c/code\u003e denote its count. The recurrence to compute \u003ccode\u003edp[x][y][z]\u003c/code\u003e can be given as : \u003c/p\u003e \u003cpre\u003e\u003ccode\u003edp[x][y][z] \u003d min(dp[x][i][z/2] + dp[i][y][z-z/2],dp[x][y][z]) where i goes from 1 to n.    \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe base case :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003edp[i][j][0] \u003d 1  , if i\u003d\u003dj    \ndp[i][j][0] \u003d 0  , otherwise\t \n\ndp[i][j][1] \u003d g[i][j]\t \n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ewhere \u003ccode\u003eg[i][j]\u003c/code\u003e is the length of the edge between node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e (0 if it doesn\u0027t exist.) \u003c/p\u003e\u003cp\u003eUsing the above recurrence the 2-D matrix representing the shortest distance between any pair of nodes using at-most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e edges can be computed using matrix exponentiation. Also, the \u003ccode\u003ecnt\u003c/code\u003e table can also be computed along with the exponentiation to compute the dp table. \u003c/p\u003e\u003cp\u003eHave a look at the code below for implementation details. \u003c/p\u003e\u003cp\u003eCode : \u003ca href\u003d\"http://ideone.com/9r975m\"\u003ehttp://ideone.com/9r975m\u003c/a\u003e \u003c/p\u003e\u003c/div\u003e","tags":["codecraft","iiith","tutorial"]}}