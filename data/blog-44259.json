{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1460149405,"rating":32,"authorHandle":"Edvard","modificationTimeSeconds":1460303245,"id":44259,"title":"\u003cp\u003eEditorial of Educational Codeforces Round 11\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/660/problem/A\" title\u003d\"Educational Codeforces Round 11\"\u003e660A - Co-prime Array\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem was suggested by Ali Ibrahim \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/New_Horizons\" title\u003d\"Specialist New_Horizons\"\u003eNew_Horizons\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eNote that we should insert some number between any adjacent not co-prime elements. On other hand we always can insert the number \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eС++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003econst int N \u003d 1010;\n\nint n, a[N];\n\nbool read() {\n\tif (!(cin \u0026gt;\u0026gt; n)) return false;\n\tforn(i, n) assert(scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]) \u003d\u003d 1);\n\treturn true;\n}\n\nvoid solve() {\n\tfunction\u0026lt;int(int, int)\u0026gt; gcd \u003d [\u0026amp;](int a, int b) { return !a ? b : gcd(b % a, a); };\n\n\tvector\u0026lt;int\u0026gt; ans;\n\tforn(i, n) {\n\t\tans.pb(a[i]);\n\t\tif (i + 1 \u0026lt; n \u0026amp;\u0026amp; gcd(a[i], a[i + 1]) \u0026gt; 1)\n\t\t\tans.pb(1);\n\t}\n\n\tcout \u0026lt;\u0026lt; sz(ans) - n \u0026lt;\u0026lt; endl;\n\tforn(i, sz(ans)) {\n\t\tif (i) putchar(\u0027 \u0027);\n\t\tprintf(\u0026quot;%d\u0026quot;, ans[i]);\n\t}\n\tputs(\u0026quot;\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlogn\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/660/problem/B\" title\u003d\"Educational Codeforces Round 11\"\u003e660B - Seating On Bus\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem was suggested by Srikanth Bhat \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/srikkbhat\" title\u003d\"Expert srikkbhat\"\u003esrikkbhat\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eIn this problem you should simply do what was written in the problem statement. There are no tricks.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eint n, m;\n\nbool read() {\n\treturn !!(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m);\n}\n\nconst int N \u003d 111;\n\nint a[N][4];\n\nvoid solve() {\n\tforn(i, n) {\n\t\ta[i][0] \u003d 2 * i;\n\t\ta[i][1] \u003d 2 * (n + i);\n\t\ta[i][2] \u003d 2 * (n + i) + 1;\n\t\ta[i][3] \u003d 2 * i + 1;\n\t}\n\n\tvector\u0026lt;int\u0026gt; ans;\n\tforn(i, n) {\n\t\tans.pb(a[i][1]);\n\t\tans.pb(a[i][0]);\n\t\tans.pb(a[i][2]);\n\t\tans.pb(a[i][3]);\n\t}\n\n\tnfor(i, sz(ans)) // inverse order\n\t\tif (ans[i] \u0026gt;\u003d m)\n\t\t\tans.erase(ans.begin() + i);\n\n\tforn(i, m) {\n\t\tif (i) putchar(\u0027 \u0027);\n\t\tprintf(\u0026quot;%d\u0026quot;, ans[i] + 1);\n\t}\n\tputs(\u0026quot;\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/660/problem/C\" title\u003d\"Educational Codeforces Round 11\"\u003e660C - Hard Process\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem was suggested by Mohammad Amin Raeisi \u003ca class\u003d\"rated-user user-gray\" href\u003d\"/profile/aminra\" title\u003d\"Newbie aminra\"\u003eaminra\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eLet\u0027s call the segment \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e good if it contains no more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e zeroes. Note if segment \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e is good than the segment \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e + 1, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e is also good. So we can use the method of two pointers: the first pointer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and the second is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e. Let\u0027s iterate over \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e from the left to the right and move \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e while we can (to do that we should simply maintain the number of zeroes in the current segment).\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003econst int N \u003d 1200300;\n\nint n, k;\nint a[N];\n\nbool read() {\n\tif (!(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k)) return false;\n\tforn(i, n) assert(scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]) \u003d\u003d 1);\n\treturn true;\n}\n\nvoid solve() {\n\tint ansl \u003d 0, ansr \u003d 0;\n\tint j \u003d 0, cnt \u003d 0;\n\tforn(i, n) {\n\t\tif (j \u0026lt; i) {\n\t\t\tj \u003d i;\n\t\t\tcnt \u003d 0;\n\t\t}\n\n\t\twhile (j \u0026lt; n) {\n\t\t\tint ncnt \u003d cnt + !a[j];\n\t\t\tif (ncnt \u0026gt; k) break;\n\t\t\tcnt +\u003d !a[j];\n\t\t\tj++;\n\t\t}\n\t\t\n\t\tif (j - i \u0026gt; ansr - ansl)\n\t\t\tansl \u003d i, ansr \u003d j;\n\n\t\tif (cnt \u0026gt; 0) cnt -\u003d !a[i];\n\t}\n\n\tcout \u0026lt;\u0026lt; ansr - ansl \u0026lt;\u0026lt; endl;\n\tfore(i, ansl, ansr) a[i] \u003d 1;\n\tforn(i, n) {\n\t\tif (i) putchar(\u0027 \u0027);\n\t\tprintf(\u0026quot;%d\u0026quot;, a[i]);\n\t}\n\tputs(\u0026quot;\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/660/problem/D\" title\u003d\"Educational Codeforces Round 11\"\u003e660D - Number of Parallelograms\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem was suggested by Sadegh Mahdavi \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/smahdavi4\" title\u003d\"Expert smahdavi4\"\u003esmahdavi4\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eIt\u0027s known that the diagonals of a parallelogram split each other in the middle. Let\u0027s iterate over the pairs of points \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e and consider the middle of the segment \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f9/a3/f9a3f771bb0dd452eb453905fb8a1f64117e0738.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e1/70/e170c5e88799addc7e48e3807bf5bbcce804a302.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Let\u0027s calculate the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e for each middle. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is the number of segments \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e with the middle \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e. Easy to see that the answer is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/56/a9/56a9a41baad45306f5cff6129d13326fc0c84263.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003econst int N \u003d 2020;\n\nint n;\nint x[N], y[N];\n\nbool read() {\n\tif (!(cin \u0026gt;\u0026gt; n)) return false;\n\tforn(i, n)\n\t\tassert(scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;x[i], \u0026amp;y[i]) \u003d\u003d 2);\n\treturn true;\n}\n\ninline li C2(li n) { return n * (n - 1) / 2; }\n\nvoid solve() {\n\tmap\u0026lt;pti, int\u0026gt; cnt;\n\n\tforn(i, n)\n\t\tforn(j, i) {\n\t\t\tint cx \u003d x[i] + x[j];\n\t\t\tint cy \u003d y[i] + y[j];\n\t\t\tcnt[{cx, cy}]++;\n\t\t}\n\n\tli ans \u003d 0;\n\tfor (const auto\u0026amp; p : cnt)\n\t\tans +\u003d C2(p.y);\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003ci\u003elogn\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/660/problem/E\" title\u003d\"Educational Codeforces Round 11\"\u003e660E - Different Subsets For All Tuples\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem was suggested by Lewin Gan \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/lewin\" title\u003d\"International master lewin\"\u003elewin\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eLet\u0027s consider some subsequence with the length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u0026gt; 0\u003c/span\u003e (the empty subsequences we will count separately by adding the valye \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e at the end) and count the number of sequences that contains it. We should do that accurately to not count the same sequence multiple times. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the fixed subsequence. In the original sequence before the element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e can be some other elements, but none of them can be equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e (because we want to count the subsequence exactly one time). So we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/span\u003e variants for each of the elements before \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e. Similarly between elements \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e can be other elements and we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e - 1\u003c/span\u003e choices for each of them. And so on. After the element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e can be some elements (suppose there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e such elements) with no additional constraints (so we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e choices for each of them). We fixed the number of elements at the end \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, so we should distribute \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e - \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e numbers between numbers before \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e, \\ldots, between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Easy to see that we have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c8/69/c8691204b6e560aee2daf3315edc829324178364.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e choices to do that (it\u0027s simply binomial coefficient with allowed repititions). The number of sequences \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e equals to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. So the answer is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f2/f0/f2f0a108cbc62a2131aed04624dee1beec77904f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Easy to transform the last sum to the sum \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/56/02/5602af8295326e53db814e76ba264cba899797eb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Note the last inner sum can be calculating using the formula for parallel summing: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/75/6f/756f2b1add7edd666f24d913234fbad3a477e600.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. So the answer equals to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/85/83/85836e9641f1f441b7eb4ac13f7e8cf6bce5936e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Also we can get the closed formula for the last sum to get logarithmic solution, but it is not required in the problem.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eint n, m;\n\nbool read() {\n\treturn !!(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m);\n}\n\nconst int N \u003d 1200300;\n\nconst int mod \u003d 1000 * 1000 * 1000 + 7;\n\nint gcd(int a, int b, int\u0026amp; x, int\u0026amp; y) {\n\tif (!a) {\n\t\tx \u003d 0, y \u003d 1;\n\t\treturn b;\n\t}\n\tint xx, yy, g \u003d gcd(b % a, a, xx, yy);\n\tx \u003d yy - b / a * xx;\n\ty \u003d xx;\n\treturn g;\n}\n\ninline int inv(int a) {\n\tint x, y;\n\tassert(gcd(a, mod, x, y) \u003d\u003d 1);\n\tx %\u003d mod;\n\treturn x \u0026lt; 0 ? x + mod : x;\n}\n\ninline int mul(int a, int b) { return int(a * 1ll * b % mod); }\ninline int add(int a, int b) { return a + b \u0026gt;\u003d mod ? a + b - mod : a + b; }\ninline int sub(int a, int b) { return a - b \u0026lt; 0 ? a - b + mod : a - b; }\n\ninline void inc(int\u0026amp; a, int b) { a \u003d add(a, b); }\n\nint fact[N], ifact[N];\n\ninline int C(int n, int k) {\n\tif (k \u0026lt; 0 || k \u0026gt; n) return 0;\n\treturn mul(fact[n], mul(ifact[k], ifact[n - k]));\n}\n\nint pm[N], pm1[N];\n\nvoid solve() {\n\tconst int N \u003d n + 1;\n\n\tfact[0] \u003d 1; fore(i, 1, N) fact[i] \u003d mul(fact[i - 1], i);\n\tforn(i, N) ifact[i] \u003d inv(fact[i]);\n\n\tpm[0] \u003d 1; fore(i, 1, N) pm[i] \u003d mul(pm[i - 1], m);\n\tpm1[0] \u003d 1; fore(i, 1, N) pm1[i] \u003d mul(pm1[i - 1], sub(m, 1));\n\n\tint ans \u003d pm[n];\n\tfore(s, 1, n + 1) {\n\t\tint cur \u003d 1;\n\t\tcur \u003d mul(cur, pm[s]);\n\t\tcur \u003d mul(cur, pm1[n - s]);\n\t\tcur \u003d mul(cur, C(n, s - 1));\n\t\tinc(ans, cur);\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003ci\u003elog\u003c/i\u003e \u003ci\u003eMOD\u003c/i\u003e)\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eMOD\u003c/i\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e + 7\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/660/problem/F\" title\u003d\"Educational Codeforces Round 11\"\u003e660F - Bear and Bowling 4\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem was prepared by Kamil Debowski \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Errichto\" title\u003d\"International Grandmaster Errichto\"\u003eErrichto\u003c/a\u003e. The problem analysis is also prepared by him.\u003c/p\u003e\u003cp\u003eThe key is to use divide and conquer. We need a recursive function \u003ccode\u003ef(left, right)\u003c/code\u003e that runs \u003ccode\u003ef(left, mid)\u003c/code\u003e and \u003ccode\u003ef(mid+1, right)\u003c/code\u003e (where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e \u003d (\u003ci\u003eleft\u003c/i\u003e + \u003ci\u003eright\u003c/i\u003e) / 2\u003c/span\u003e) and also considers all intervals going through \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e\u003c/span\u003e. We will eventually need a convex hull of lines (linear functions) and let\u0027s see how to achieve it.\u003c/p\u003e\u003cp\u003eFor variables \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e\u003c/span\u003e (\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/72/e2/72e2f027e758fed5f098ab604f7d65beb5cefae5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/dd/f1/ddf144b7dc6bc12c42236a67b2b47231c1175bd0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e) we will try to write the score of interval \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e]\u003c/span\u003e as a linear function. It would be good to get something close to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/sub\u003e·\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e depend on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e depends on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e only.\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5b/1e/5b1e8bd8255ca1c5cb3a0b1ae76a9175b58f079d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eFor each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e we should find a linear function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/sub\u003e·\u003ci\u003ex\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e should fit the equation \u003cspan class\u003d\"tex-span\"\u003e( * )\u003c/span\u003e:\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cd/fe/cdfef9d3c8373880c119d46267efa6a6668f2616.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eNow we have a set of linear functions representing all possible left endpoints \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. For each right endpoint \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e we should find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003econst\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to fit equation \u003cspan class\u003d\"tex-span\"\u003e( * )\u003c/span\u003e again. With value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e we can iterate over functions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to find the one maximizing value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/sub\u003e·\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. And (still for fixed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e) we should add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003econst\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to get the maximum possible score of interval ending in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eBrute Force with functions\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\nconst int nax \u003d 1e6 + 5;\nll ans;\nll t[nax];\n\nstruct Fun {\n\tll a, b;\n\tll getValue(ll x) { return a * x + b; }\n};\n\nvoid rec(int first, int last) {\n\tif(first \u003d\u003d last) {\n\t\tans \u003d max(ans, t[first]);\n\t\treturn;\n\t}\n\tint mid \u003d (first + last) / 2;\n\t\n\trec(first, mid); // the left half is [first, mid]\n\trec(mid+1, last); // the right half is [mid+1, last]\n\t\n\t// we must consider all intervals starting in [first,mid] and ending in [mid+1, last]\n\t\n\tvector\u0026lt;Fun\u0026gt; functions;\n\tll sum_so_far \u003d 0; // t[i]+t[i+1]+...+t[mid]\n\tll score_so_far \u003d 0; // t[i]*1 + t[i+1]*2 + ... + t[mid]*(mid-i+1)\n\tfor(int i \u003d mid; i \u0026gt;\u003d first; --i) {\n\t\tsum_so_far +\u003d t[i];\n\t\tscore_so_far +\u003d sum_so_far;\n\t\tfunctions.push_back(Fun{mid - i + 1, score_so_far});\n\t}\n\t\n\tsum_so_far \u003d 0;\n\tscore_so_far \u003d 0;\n\tfor(int i \u003d mid+1; i \u0026lt;\u003d last; ++i) {\n\t\tsum_so_far +\u003d t[i];\n\t\tscore_so_far +\u003d t[i] * (i - mid);\n\t\tfor(Fun \u0026amp; f : functions) {\n\t\t\tll score \u003d score_so_far + f.getValue(sum_so_far);\n\t\t\tans \u003d max(ans, score);\n\t\t}\n\t}\n}\n\nint main() {\n\tint n;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; ++i) scanf(\u0026quot;%lld\u0026quot;, \u0026amp;t[i]);\n\trec(1, n);\n\tprintf(\u0026quot;%lldn\u0026quot;, ans);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eNow let\u0027s make it faster. After finding a set of linear functions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e we should build a convex hull of them (note that they\u0027re already sorted by slope). To achieve it we need something to compare \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e functions and decide whether one of them is unnecessary because it\u0027s always below one of other two functions. Note that in standard convex hull of points you also need something similar (but for \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e points). Below you can find an almost-fast-enough solution with a useful function \u003ccode\u003ebool is_middle_needed(f1, f2, f3)\u003c/code\u003e. You may check that numbers calculated there do fit in \u003ccode\u003elong long\u003c/code\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eAlmost fast enough\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\nconst int nax \u003d 1e6 + 5;\nll ans;\nll t[nax];\n\nstruct Fun {\n\tll a, b;\n\tll getValue(ll x) { return a * x + b; }\n};\n\nbool is_middle_needed(const Fun \u0026amp; f1, const Fun \u0026amp; f2, const Fun \u0026amp; f3) {\n\t// we ask if for at least one \u0027x\u0027 there is f2(x) \u0026gt; max(f1(x), f3(x))\n\tassert(0 \u0026lt; f1.a \u0026amp;\u0026amp; f1.a \u0026lt; f2.a \u0026amp;\u0026amp; f2.a \u0026lt; f3.a);\n\t\n\t// where is the intersection of f1 and f2?\n\t// f1.a * x + f1.b \u003d f2.a * x + f2.b\n\t// x * (f2.a - f1.a) \u003d f1.b - f2.b\n\t// x \u003d (f1.b - f2.b) / (f2.a - f1.a)\n\tll p1 \u003d f1.b - f2.b;\n\tll q1 \u003d f2.a - f1.a;\n\t// and the intersection of f1 and f3\n\tll p2 \u003d f1.b - f3.b;\n\tll q2 \u003d f3.a - f1.a;\n\tassert(q1 \u0026gt; 0 \u0026amp;\u0026amp; q2 \u0026gt; 0);\n\t// return p1 / q1 \u0026lt; p2 / q2\n\treturn p1 * q2 \u0026lt; q1 * p2;\n}\n\nvoid rec(int first, int last) {\n\tif(first \u003d\u003d last) {\n\t\tans \u003d max(ans, t[first]);\n\t\treturn;\n\t}\n\tint mid \u003d (first + last) / 2;\n\t\n\trec(first, mid); // the left half is [first, mid]\n\trec(mid+1, last); // the right half is [mid+1, last]\n\t\n\t// we must consider all intervals starting in [first,mid] and ending in [mid+1, last]\n\t\n\tvector\u0026lt;Fun\u0026gt; functions;\n\tll sum_so_far \u003d 0; // t[i]+t[i+1]+...+t[mid]\n\tll score_so_far \u003d 0; // t[i]*1 + t[i+1]*2 + ... + t[mid]*(mid-i+1)\n\tfor(int i \u003d mid; i \u0026gt;\u003d first; --i) {\n\t\tsum_so_far +\u003d t[i];\n\t\tscore_so_far +\u003d sum_so_far;\n\t\tFun f \u003d Fun{mid - i + 1, score_so_far};\n\t\twhile(true) {\n\t\t\tint s \u003d functions.size();\n\t\t\tif(s \u0026gt;\u003d 2 \u0026amp;\u0026amp; !is_middle_needed(functions[s-2], functions[s-1], f))\n\t\t\t\tfunctions.pop_back();\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tfunctions.push_back(f);\n\t}\n\t\n\tsum_so_far \u003d 0;\n\tscore_so_far \u003d 0;\n\tfor(int i \u003d mid+1; i \u0026lt;\u003d last; ++i) {\n\t\tsum_so_far +\u003d t[i];\n\t\tscore_so_far +\u003d t[i] * (i - mid);\n\t\tfor(Fun \u0026amp; f : functions) {\n\t\t\tll score \u003d score_so_far + f.getValue(sum_so_far);\n\t\t\tans \u003d max(ans, score);\n\t\t}\n\t}\n}\n\nint main() {\n\tint n;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; ++i) scanf(\u0026quot;%lld\u0026quot;, \u0026amp;t[i]);\n\trec(1, n);\n\tprintf(\u0026quot;%lldn\u0026quot;, ans);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eFinally, one last thing is needed to make it faster than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e. We should use the fact that we have built a convex hull of functions (lines). For each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e you should binary search optimal function. Alternatively, you can sort pairs \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003econst\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e and then use the two pointers method — check the implementation in my solution below. It gives complexity \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1f/7c/1f7c9ce8e567d0015a1bd017da7940958950d33e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e because we sort by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e inside of a recursive function. I think it\u0027s possible to get rid of this by sorting prefixes \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c4/17/c417583f39e5ffb69b408b0dd78d32d86dd5af22.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e in advance because it\u0027s equivalent to sorting by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. And we should use the already known order when we run a recursive function for smaller intervals. So, I think \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is possible this way — anybody implemented it?\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eIntended solution with two pointers\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e// O(n log^2(n))\n#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\nconst int nax \u003d 1e6 + 5;\nll ans;\nll t[nax];\n\nstruct Fun {\n\tll a, b;\n\tll getValue(ll x) { return a * x + b; }\n};\n\nbool is_middle_needed(const Fun \u0026amp; f1, const Fun \u0026amp; f2, const Fun \u0026amp; f3) {\n\t// we ask if for at least one \u0027x\u0027 there is f2(x) \u0026gt; max(f1(x), f3(x))\n\tassert(0 \u0026lt; f1.a \u0026amp;\u0026amp; f1.a \u0026lt; f2.a \u0026amp;\u0026amp; f2.a \u0026lt; f3.a);\n\t\n\t// where is the intersection of f1 and f2?\n\t// f1.a * x + f1.b \u003d f2.a * x + f2.b\n\t// x * (f2.a - f1.a) \u003d f1.b - f2.b\n\t// x \u003d (f1.b - f2.b) / (f2.a - f1.a)\n\tll p1 \u003d f1.b - f2.b;\n\tll q1 \u003d f2.a - f1.a;\n\t// and the intersection of f1 and f3\n\tll p2 \u003d f1.b - f3.b;\n\tll q2 \u003d f3.a - f1.a;\n\tassert(q1 \u0026gt; 0 \u0026amp;\u0026amp; q2 \u0026gt; 0);\n\t// return p1 / q1 \u0026lt; p2 / q2\n\treturn p1 * q2 \u0026lt; q1 * p2;\n}\n\nvoid rec(int first, int last) {\n\tif(first \u003d\u003d last) {\n\t\tans \u003d max(ans, t[first]);\n\t\treturn;\n\t}\n\tint mid \u003d (first + last) / 2;\n\t\n\trec(first, mid); // the left half is [first, mid]\n\trec(mid+1, last); // the right half is [mid+1, last]\n\t\n\t// we must consider all intervals starting in [first,mid] and ending in [mid+1, last]\n\t\n\tvector\u0026lt;Fun\u0026gt; functions;\n\tll sum_so_far \u003d 0; // t[i]+t[i+1]+...+t[mid]\n\tll score_so_far \u003d 0; // t[i]*1 + t[i+1]*2 + ... + t[mid]*(mid-i+1)\n\tfor(int i \u003d mid; i \u0026gt;\u003d first; --i) {\n\t\tsum_so_far +\u003d t[i];\n\t\tscore_so_far +\u003d sum_so_far;\n\t\tFun f \u003d Fun{mid - i + 1, score_so_far};\n\t\twhile(true) {\n\t\t\tint s \u003d functions.size();\n\t\t\tif(s \u0026gt;\u003d 2 \u0026amp;\u0026amp; !is_middle_needed(functions[s-2], functions[s-1], f))\n\t\t\t\tfunctions.pop_back();\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tfunctions.push_back(f);\n\t}\n\t\n\tvector\u0026lt;pair\u0026lt;ll, ll\u0026gt;\u0026gt; points;\n\tsum_so_far \u003d 0;\n\tscore_so_far \u003d 0;\n\tfor(int i \u003d mid+1; i \u0026lt;\u003d last; ++i) {\n\t\tsum_so_far +\u003d t[i];\n\t\tscore_so_far +\u003d t[i] * (i - mid);\n\t\tpoints.push_back({sum_so_far, score_so_far});\n\t\t/*for(Fun \u0026amp; f : functions) {\n\t\t\tll score \u003d score_so_far + f.getValue(sum_so_far);\n\t\t\tans \u003d max(ans, score);\n\t\t}*/\n\t}\n\t\n\tsort(points.begin(), points.end());\n\tint i \u003d 0; // which function is the best\n\tfor(pair\u0026lt;ll, ll\u0026gt; p : points) {\n\t\tsum_so_far \u003d p.first;\n\t\tscore_so_far \u003d p.second;\n\t\twhile(i + 1 \u0026lt; (int) functions.size()\n\t\t\t\u0026amp;\u0026amp; functions[i].getValue(sum_so_far) \u0026lt;\u003d functions[i+1].getValue(sum_so_far))\n\t\t\t\t++i;\n\t\tans \u003d max(ans, score_so_far + functions[i].getValue(sum_so_far));\n\t}\n}\n\nint main() {\n\tint n;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; ++i) scanf(\u0026quot;%lld\u0026quot;, \u0026amp;t[i]);\n\trec(1, n);\n\tprintf(\u0026quot;%lldn\u0026quot;, ans);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlog\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e","tags":["education round 11","editorial"]}}