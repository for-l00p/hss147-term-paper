{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1460994056,"rating":29,"authorHandle":"fcspartakm","modificationTimeSeconds":1460994452,"id":44430,"title":"\u003cp\u003eРазбор задач КРОК 2016 — Квалификация\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eЛучше поздно, чем никогда...\u003c/h2\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/644/problem/A\" title\u003d\"Чемпионат КРОК 2016 - Квалификация\"\u003e644A - Берляндский парламент\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eИз условия задачи следует, что либо демократов и республиканцев поровну (если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e чётно), либо демократов на одного больше (если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e нечётно). Так как представители одной и той же партии не должны сидеть на соседних креслах, представим парламентский зал в виде шахматной доски, где левая верхняя клетка будет белой. Затем начнем перебирать ряды клеток сверху вниз, а клетки в каждом ряду слева направо и будем по очереди сажать парламентариев — демократов в белые клетки, а республиканцев в черные. \u003c/p\u003e\u003cp\u003eТаким образом, если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u0026gt; \u003ci\u003ea\u003c/i\u003e·\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, ответом будет \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e. В противном случае рассадка всегда найдется. \u003c/p\u003e\u003cp\u003eДля определения того, какого цвета клетка (и, соответственно, кого нужно в нее посадить), находящаяся в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-й строке и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e-м столбце (в случае, если они нумеруются с единицы), можно поступить следующим образом. Если \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e + \u003ci\u003ej\u003c/i\u003e)\u003ci\u003emod\u003c/i\u003e2 \u003d 0\u003c/span\u003e, значит соответствующая клетка должна быть белой, иначе чёрной.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПример решения\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eОсновная часть решения:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ecin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\nm  \u003d  n - 1;\nif (n \u0026gt; a * b) {\n    cout \u0026lt;\u0026lt; -1;\n    return 0;\n}\nfor (int i \u003d 0; i \u0026lt; a; i++) {\n    for (int j \u003d 0; j \u0026lt; b; j++) {\n        if ((i + j) % 2 \u003d\u003d 0) {\n            cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n            n  \u003d  max(n - 2, 0);\n        } else {\n            cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n            m  \u003d  max(m - 2, 0);\n        }\n    }\n    cout \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/644/problem/B\" title\u003d\"Чемпионат КРОК 2016 - Квалификация\"\u003e644B - Обработка запросов\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eДля решения данной задачи очень удобно воспользоваться структурой данных, которая называется очередь.\u003c/p\u003e\u003cp\u003eОчередь — это структура данных со следующим принципом доступа к элементам: «первый пришёл — первый ушёл». Добавление элемента (\\textit{push}) возможно лишь в конец очереди, а взять элемент из очереди можно только из её начала (\\textit{front}). Удалить элемент можно также только из начала очереди (\\textit{pop}).\u003c/p\u003e\u003cp\u003eВ данной задаче нужно было перебрать все запросы в хронологическом порядке. Будем хранить в очереди времена окончания обработки запросов. Для текущего запроса, пока в начале очереди находятся запросы, которые закончат обрабатываться не позднее, чем появился текущий запрос, нужно просто удалять их из начала очереди, так как они никак не повлияют на текущий. Если после этих действий размер очереди равен максимальному допустимому числу, ответ для текущего запроса \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e. В противном случае, нужно добавить время окончания обработки текущего запроса в очередь, вывести это время и продолжить алгоритм.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПример решения\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eОсновная часть решения:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003equeue\u0026lt;long long\u0026gt; q;\nint main() {\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; b;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) \t{\n\t\tcin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; d;\n\t\twhile (q.size() \u0026amp;\u0026amp; q.front() \u0026lt;\u003d t)\n\t\t\tq.pop();\n\t\tif (q.empty()) \n\t\t\tans \u003d t;\n\t\tif (q.size() \u0026lt;\u003d b)  {\n\t\t\tans +\u003d d;\n                        q.push(ans);\n                        cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0027 \u0027;\n               } else\n\t\tcout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0027 \u0027;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/644/problem/C\" title\u003d\"Чемпионат КРОК 2016 - Квалификация\"\u003e644C - Псевдонимы серверов\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eДля решения данной задачи воспользуемся структурами данных \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eset\u003c/i\u003e\u003c/span\u003e. Переберем все имеющиеся адреса страниц, затем получим \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehostname\u003c/i\u003e\u003c/span\u003e и path для каждого адреса, и добавим текущий path в множество путей для текущего \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehostname\u003c/i\u003e\u003c/span\u003e (для этого будет нужен \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e\u003c/span\u003e, где ключом будет строка \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehostname\u003c/i\u003e\u003c/span\u003e, а значением — множество строк \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epath\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eОсталось только объединить все \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehostname\u003c/i\u003e\u003c/span\u003e, множества путей которых совпадают (это можно сделать с помощью map, где ключом будет множество строк \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epath\u003c/i\u003e\u003c/span\u003e, а значением — вектор строк \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehostname\u003c/i\u003e\u003c/span\u003e), и вывести те группы, размер которых больше единицы.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПример решения\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eОсновная часть решения:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ecin \u0026gt;\u0026gt; n;\nfor (int i \u003d 0; i \u0026lt; n; i++) {\n\tcin\u0026gt;\u0026gt;s, s +\u003d \u0027/\u0027;\n\tint p \u003d s.find(\u0027/\u0027,7);\n\tm[s.substr(0, p)].insert(s.substr(p));\n}\nfor (auto \u0026amp;i:m) {\n\tv[i.second].push_back(i.first);\n\tk +\u003d (v[i.second].size() \u003d\u003d 2);\n}\ncout\u0026lt;\u0026lt; k \u0026lt;\u0026lt; endl;\nfor (auto \u0026amp;i:v) {\n\tif (i.second.size()\u0026gt;1) {\n\t\tfor (auto \u0026amp;j:i.second) cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0027 \u0027; \n\t\tcout \u0026lt;\u0026lt; endl;\n \t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["крок-2016","квалификация","разбор"]}}