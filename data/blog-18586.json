{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1434370464,"rating":78,"authorHandle":"RussianCodeCup","modificationTimeSeconds":1434398966,"id":18586,"title":"\u003cp\u003eRussian Code Cup 2015, Отборочный тур — разбор задач\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eБлагодарности\u003c/h2\u003e\u003cp\u003eПрежде чем перейти к разбору задач, мы хотели бы поблагодарить всех, кто помогал делать отборочные раунды Russian Code Cup.\u003c/p\u003e\u003cp\u003eРуководитель подготовки задач Андрей Станкевич \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/andrewzta\" title\u003d\"Гроссмейстер andrewzta\"\u003eandrewzta\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЧлены жюри, авторы и разработчики задач: \u003c/p\u003e\u003cul\u003e \u003cli\u003eВиталий Аксенов \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Aksenov239\" title\u003d\"Международный мастер Aksenov239\"\u003eAksenov239\u003c/a\u003e \u003c/li\u003e\u003cli\u003eАртем Васильев \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/VArtem\" title\u003d\"Гроссмейстер VArtem\"\u003eVArtem\u003c/a\u003e \u003c/li\u003e\u003cli\u003eНиколай Ведерников \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Niko\" title\u003d\"Мастер Niko\"\u003eNiko\u003c/a\u003e \u003c/li\u003e\u003cli\u003eИлья Збань \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/izban\" title\u003d\"Международный гроссмейстер izban\"\u003eizban\u003c/a\u003e \u003c/li\u003e\u003cli\u003eГеоргий Корнеев \u003c/li\u003e\u003cli\u003eАнна Малова \u003c/li\u003e\u003cli\u003eБорис Минаев \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/qwerty787788\" title\u003d\"Международный гроссмейстер qwerty787788\"\u003eqwerty787788\u003c/a\u003e \u003c/li\u003e\u003cli\u003eДмитрий Филиппов \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/DimaPhil\" title\u003d\"Кандидат в мастера DimaPhil\"\u003eDimaPhil\u003c/a\u003e \u003c/li\u003e\u003cli\u003eГригорий Шовкопляс \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/GShark\" title\u003d\"Эксперт GShark\"\u003eGShark\u003c/a\u003e \u003c/li\u003e\u003c/ul\u003e\u003cp\u003eКоординатор разборов Виталий Аксенов \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Aksenov239\" title\u003d\"Международный мастер Aksenov239\"\u003eAksenov239\u003c/a\u003e\u003c/p\u003e\u003cp\u003eПрорешивали раунды: \u003c/p\u003e\u003cul\u003e \u003cli\u003eАнтон Банных \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/anton.bannykh\" title\u003d\"Кандидат в мастера anton.bannykh\"\u003eanton.bannykh\u003c/a\u003e \u003c/li\u003e\u003cli\u003eАдам Бардашевич \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/subscriber\" title\u003d\"Международный гроссмейстер subscriber\"\u003esubscriber\u003c/a\u003e \u003c/li\u003e\u003cli\u003eРоман Елизаров \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/elizarov\" title\u003d\"Кандидат в мастера elizarov\"\u003eelizarov\u003c/a\u003e \u003c/li\u003e\u003cli\u003eВладислав Исенбаев \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/winger\" title\u003d\"Гроссмейстер winger\"\u003ewinger\u003c/a\u003e \u003c/li\u003e\u003cli\u003eГеннадий Короткевич \u003ca class\u003d\"rated-user user-legendary\" href\u003d\"/profile/tourist\" title\u003d\"Легендарный гроссмейстер tourist\"\u003e\u003cspan class\u003d\"legendary-user-first-letter\"\u003et\u003c/span\u003eourist\u003c/a\u003e \u003c/li\u003e\u003cli\u003eПавел Маврин \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/pashka\" title\u003d\"Гроссмейстер pashka\"\u003epashka\u003c/a\u003e \u003c/li\u003e\u003cli\u003eСергей Мельников \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/SergeyMelnikov\" title\u003d\"Кандидат в мастера SergeyMelnikov\"\u003eSergeyMelnikov\u003c/a\u003e \u003c/li\u003e\u003cli\u003eВадим Семенов \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/vadimmm\" title\u003d\"Кандидат в мастера vadimmm\"\u003evadimmm\u003c/a\u003e \u003c/li\u003e\u003cli\u003eВладимир Смыкалов \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/enot.1.10\" title\u003d\"Гроссмейстер enot.1.10\"\u003eenot.1.10\u003c/a\u003e \u003c/li\u003e\u003c/ul\u003e\u003cp\u003eРазумеется, те, кто участвовал в чемпионате, прорешивали только раунды, в которых они не могли участвовать.\u003c/p\u003e\u003cp\u003eПерейдем теперь к разбору задач.\u003c/p\u003e \u003ch2\u003eЗадача A. Игра со строками\u003c/h2\u003e\u003cp\u003e\u003cb\u003eИдея:\u003c/b\u003e Григорий Шовкопляс.\u003cbr /\u003e \u003cb\u003eРеализация:\u003c/b\u003e Григорий Шовкопляс.\u003cbr /\u003e \u003cb\u003eРазбор:\u003c/b\u003e Григорий Шовкопляс.\u003cbr /\u003e \u003c/p\u003e\u003cp\u003e  В задаче дана строка, с которой можно делать следующие операции:  \u003c/p\u003e\u003cul\u003e  \u003cli\u003eудалить три подряд идущих единицы;\u003c/li\u003e  \u003cli\u003eудалить два подряд идущих нуля;\u003c/li\u003e  \u003cli\u003eзаменить подстроку «01» на подстроку «10»;\u003c/li\u003e  \u003cli\u003eзаменить подстроку «10» на подстроку «01».\u003c/li\u003e  \u003c/ul\u003e  Нужно посчитать, сколько существует способов получить строку определенной длины из данной, применяя эти операции.  \u003cp\u003e  Для начала посмотрим на операции замен и поймем, что это ни что иное как swap. Таким образом,  мы можем получить из данной строки любую, в которой содержится такое же количество нулей и единиц. \u003c/p\u003e \u003cp\u003e\u003cbr /\u003e Теперь с помощью этих операций получим из исходной строку, где все нули стоят в начале, а единицы в конце.  Из получившейся строки мы можем получить строку новой длины, ничего не переставляя, так как все единицы и нули уже сгруппированы.  Строку длины \u003ci\u003ek\u003c/i\u003e, можно получить из строки длины \u003ci\u003en\u003c/i\u003e, удалив \u003ci\u003e3x\u003c/i\u003e единиц и \u003ci\u003e2y\u003c/i\u003e нулей,  где \u003ci\u003ek\u003c/i\u003e \u003d \u003ci\u003en\u003c/i\u003e — (\u003ci\u003e3x\u003c/i\u003e + \u003ci\u003e2y\u003c/i\u003e). Значения \u003ci\u003ex\u003c/i\u003e и \u003ci\u003ey\u003c/i\u003e можно перебрать. \u003c/p\u003e \u003cp\u003e\u003cbr /\u003e И наконец, для каждой полученной строки нужной нам длины, нужно учесть все перестановки. Их можно посчитать,  например, как количество сочетаний из длины строки по количеству единиц в ней.  Ответ будет равен сумме этих сочетаний для всех строк нужной длины, которые можно получить из данной. \u003c/p\u003e \u003ch2\u003eЗадача B. Разбиение на команды\u003c/h2\u003e\u003cp\u003e\u003cb\u003eИдея:\u003c/b\u003e Григорий Шовкопляс.\u003cbr /\u003e \u003cb\u003eРеализация:\u003c/b\u003e Дмитрий Филиппов.\u003cbr /\u003e \u003cb\u003eРазбор:\u003c/b\u003e Дмитрий Филиппов.\u003cbr /\u003e \u003c/p\u003e\u003cp\u003e  В задаче дан граф, на каждом ребре которого написаны числа 0 или 1, означающие, что концы ребра одного цвета или разного соответственно. Также  некоторые вершины графа покрашены в белый или черный цвет. Спрашивается, можно ли как-нибудь покрасить в черный и белый цвета остальные  вершины, чтобы информация, написаная на ребрах, была верна, и количество вершин черного и белого цвета было одинаковым? \u003c/p\u003e \u003cp\u003e  Разобьем наш граф на компоненты связности. Заметим, что, зная цвет одной вершины в компоненте, мы можем восстановить цвет всех остальных.  Из этого следует, что если в компоненте хотя бы одна вершина уже покрашена, раскраска всей компоненты единственна (кроме случая, когда в полученной  раскраске нарушится какое-то из требуемых условий, тогда ответ на задачу — «NO»). Если же ни одна вершина еще не  покрашена, вариантов раскраски два — можно покрасить любую вершину компоненты в белый цвет, восстановить цвета остальных вершин,  а после этого, если их инвертировать — получим вторую раскраску. \u003c/p\u003e \u003cp\u003e\u003cbr /\u003e Несложно заметить, что мы свели нашу исходную задачу к задаче о рюкзаке — из каждой компоненты мы можем взять некоторое количество белых вершин,  и всего их надо набрать \u003ci\u003en\u003c/i\u003e ⁄ 2 (если \u003ci\u003en\u003c/i\u003e нечетное, ответ на задачу — «NO»).  А это уже можно решить с помощью динамического программирования за O(\u003ci\u003en\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e). \u003c/p\u003e \u003ch2\u003eЗадача C. Карта.\u003c/h2\u003e \u003cb\u003eИдея:\u003c/b\u003e Георгий Корнеев, Виталий Аксёнов.\u003cbr /\u003e \u003cb\u003eРеализация:\u003c/b\u003e Виталий Аксёнов.\u003cbr /\u003e \u003cb\u003eРазбор:\u003c/b\u003e Виталий Аксёнов.\u003cbr /\u003e \u003cp\u003e В задаче дан клетчатый выпуклый многоугольник на клетчатой плоскости. Нужно сложить его один раз по вертикальной линии сетки, чтобы площадь, занимаемая многоугольником после сложения, была минимальной. \u003c/p\u003e \u003cp\u003e Рассмотрим сначала самую простую версию задачи. Дан прямоугольник, и нужно его сложить, получив минимальную площадь. Очевидно, что его нужно складывать по линии сетки, ближайшей к середине. (Если таких две, то можно сложить по любой.) Рассмотрим функцию площади от позиции сгиба. Для прямоугольника с углами (\u003ci\u003ex\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e) и (\u003ci\u003ex\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e) эта функция имеет следующий вид: \u003c/p\u003e\u003cul\u003e \u003cli\u003eНа отрезках (-∞; \u003ci\u003ex\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e] и [\u003ci\u003ex\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e; +∞) функция равна площади прямоугольника;\u003c/li\u003e \u003cli\u003eНа отрезке [\u003ci\u003ex\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e; (\u003ci\u003ex\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e + \u003ci\u003ex\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e) / 2] функция линейно убывает с коэффициентом \u003ci\u003ey\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e — \u003ci\u003ey\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e;\u003c/li\u003e \u003cli\u003eНа отрезке [(\u003ci\u003ex\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e + \u003ci\u003ex\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e) / 2; \u003ci\u003ex\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e] функция линейно возрастает с коэффициентом \u003ci\u003ey\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e — \u003ci\u003ey\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e.\u003c/li\u003e \u003c/ul\u003e Итого: функция меняет своё состояние только в трёх точках. Между двумя подряд идущими точками функция является линейной.  \u003cp\u003e Заметим, что так как наша задача дискретная, в случае, когда (\u003ci\u003ex\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e + \u003ci\u003ex\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e) не делится на два, лучше бить функцию на пять участков между точками \u003ci\u003ex\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e, ⌊(\u003ci\u003ex\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e + \u003ci\u003ex\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e) / 2⌋, ⌈(\u003ci\u003ex\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e + \u003ci\u003ex\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e) / 2⌉ и \u003ci\u003ex\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e. \u003c/p\u003e \u003cp\u003e Пусть наш многоугольник задан \u003ci\u003en\u003c/i\u003e вершинами. Тогда несложно заметить, что выпуклый клетчатый многоугольник можно нарезать на не более \u003ci\u003en\u003c/i\u003e прямоугольников горизонтальными прямыми. Тогда функция зависимости площади от места сложения будет являться суммой функций для прямоугольников. Опять же несложно убедиться, что если мы возьмём все точки изменения для каждой функции и отсортируем их, то между двумя соседними точками глобальная функция будет линейной. Тогда в качестве ответа нужно взять минимум из значений в этих точках. \u003c/p\u003e \u003cp\u003e Чтобы это реализовать, нужно воспользоваться идеей событий. Каждое событие будет соответствовать точке изменения функции для какого-то прямоугольника. Тогда обрабатывая события слева направо и пересчитывая коэффициент линейной функции, несложно посчитать функцию в выделенных точках. \u003c/p\u003e \u003ch2\u003eЗадача D. Декартовы деревья.\u003c/h2\u003e \u003cb\u003eИдея:\u003c/b\u003e Артем Васильев.\u003cbr /\u003e \u003cb\u003eРеализация:\u003c/b\u003e Илья Збань.\u003cbr /\u003e \u003cb\u003eРазбор:\u003c/b\u003e Илья Збань.\u003cbr /\u003e \u003cp\u003e В задаче дано \u003ci\u003en\u003c/i\u003e чисел \u003ci\u003ey\u003c/i\u003e\u003csub\u003ei\u003c/sub\u003e, нужно было посчитать, сколько декартовых деревьев можно построить на множестве (\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub\u003ei\u003c/sub\u003e). \u003c/p\u003e \u003cp\u003e Для начала заметим, что если все \u003ci\u003en\u003c/i\u003e чисел \u003ci\u003ey\u003c/i\u003e\u003csub\u003ei\u003c/sub\u003e равны одному и тому же числу, то ответ — \u003ci\u003eC\u003c/i\u003e\u003csub\u003en\u003c/sub\u003e, \u003ci\u003en\u003c/i\u003e -е число Каталана. Понять это можно, например, исходя из рекуррентной формулы: если в левое поддерево определить \u003ci\u003ek\u003c/i\u003e вершин, то в правом окажется \u003ci\u003en\u003c/i\u003e-\u003ci\u003ek\u003c/i\u003e-1 вершин, то есть \u003ci\u003eC\u003c/i\u003e\u003csub\u003en\u003c/sub\u003e\u003dΣ\u003csub\u003ek\u003d0\u003c/sub\u003e\u003csup\u003en\u003c/sup\u003e \u003ci\u003eC\u003c/i\u003e\u003csub\u003ek\u003c/sub\u003e·\u003ci\u003eC\u003c/i\u003e\u003csub\u003en-k-1\u003c/sub\u003e. \u003c/p\u003e \u003cp\u003e Рассмотрим все вхождения максимального числа в массиве. Любая вершина с таким приоритетом может быть либо корнем, либо быть ребенком другой вершины с таким же приоритетом. Пусть вхождения максимума имеют индексы \u003ci\u003ea\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub\u003ek\u003c/sub\u003e. Тогда мы должны построить какое-то декартово дерево на вершинах \u003ci\u003ea\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub\u003ek\u003c/sub\u003e, и подвесить к нему какие-то декартовы деревья, построенные на вершинах (1, ..., \u003ci\u003ea\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e-1), (\u003ci\u003ea\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e+1, ..., \u003ci\u003ea\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e-1), ..., (\u003ci\u003ea\u003c/i\u003e\u003csub\u003ek\u003c/sub\u003e+1, ..., \u003ci\u003en\u003c/i\u003e). Заметим, что для соседних \u003ci\u003ea\u003c/i\u003e\u003csub\u003ei\u003c/sub\u003e и \u003ci\u003ea\u003c/i\u003e\u003csub\u003ei+1\u003c/sub\u003e в любом декартовом дереве, построенном лишь на максимальных вершинах, одна из этих вершин будем предком другой, поэтому поддерево, построенное на вершинах (\u003ci\u003ea\u003c/i\u003e\u003csub\u003ei\u003c/sub\u003e+1, ..., \u003ci\u003ea\u003c/i\u003e\u003csub\u003ei+1\u003c/sub\u003e-1), мы сможем однозначно подвесить за одну из этих двух вершин. \u003c/p\u003e \u003cp\u003e Таким образом, число способов построить декартово дерево на вершинах с \u003ci\u003el\u003c/i\u003e по \u003ci\u003er\u003c/i\u003e равно \u003ci\u003ecnt\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003d\u003ci\u003eC\u003c/i\u003e \u003csub\u003ek\u003c/sub\u003e · \u003ci\u003ecnt\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e-1) · ... · \u003ci\u003ecnt\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub\u003ek\u003c/sub\u003e+1, \u003ci\u003er\u003c/i\u003e). Ответом будет являться \u003ci\u003ecnt\u003c/i\u003e(1, \u003ci\u003en\u003c/i\u003e). \u003c/p\u003e \u003ch2\u003eЗадача E. Аллея.\u003c/h2\u003e \u003cb\u003eИдея:\u003c/b\u003e Борис Минаев.\u003cbr /\u003e \u003cb\u003eРеализация:\u003c/b\u003e Борис Минаев.\u003cbr /\u003e \u003cb\u003eРазбор:\u003c/b\u003e Борис Минаев.\u003cbr /\u003e \u003cp\u003e  С математической точки зрения в задаче даны отрезки целочисленной длины.  Необходимо разбить некоторые из них на более мелкие так, чтобы длина  наибольшего отрезка была как можно меньше, а количество разбиений не  превосходило заданного числа.  Задача несколько усложняется тем, что суммарная длина всех отрезков может достигать 10\u003csup\u003e9\u003c/sup\u003e, а количество запросов, на которые необходимо дать ответ, может достигать 10\u003csup\u003e6\u003c/sup\u003e. \u003c/p\u003e \u003cp\u003e Рассмотрим, сколько необходимо сделать разбиений, чтобы ответ получился не более \u003ci\u003eAns\u003c/i\u003e. Для каждого отрезка длины \u003ci\u003eLen\u003c/i\u003e необходимо сделать (\u003ci\u003eLen\u003c/i\u003e — 1)/\u003ci\u003eAns\u003c/i\u003e разбиений (результат деления округляется вниз). Построим функцию количества необходимых разбиений от ответа для каждого отрезка. Сложим эти функции для всех отрезков. Для того чтобы найти минимальное значение \u003ci\u003eAns\u003c/i\u003e, которое можно достичь, сделав не более чем \u003ci\u003eK\u003c/i\u003e разбиений, воспользуемся двоичным поиском. \u003c/p\u003e \u003cp\u003e Будем хранить функции в сжатом виде, а именно, сохраним значение функции для \u003ci\u003eAns\u003c/i\u003e только, если \u003ci\u003ef\u003c/i\u003e(\u003ci\u003eAns\u003c/i\u003e) ≠ \u003ci\u003ef\u003c/i\u003e(\u003ci\u003eAns\u003c/i\u003e-1). Можно доказать, что для отрезка длины \u003ci\u003eLen\u003c/i\u003e потребуется \u003ci\u003eO\u003c/i\u003e(sqrt(\u003ci\u003eLen\u003c/i\u003e)) памяти, чтобы сохранить его функцию. Позиции, в которых меняется значение функции, можно определить за время пропорциональное их количеству. Максимальное суммарное число позиций изменения будет достигаться на тесте, в котором все отрезки имеют одинаковую длину. В случае ограничений, которые даны в условии задачи, их количество не может превышать 10\u003csup\u003e6\u003c/sup\u003e·sqrt(10\u003csup\u003e3\u003c/sup\u003e)\u003d10\u003csup\u003e7.5\u003c/sup\u003e. \u003c/p\u003e \u003cp\u003e Чтобы объединить несколько функций, которые сохранены в сжатом формате, необходимо отсортировать все моменты изменения функций. Для этого разобьем все позиции, в которых функции изменяются, на два класса. В первый класс отнесем все позиции, которые меньше 10\u003csup\u003e6\u003c/sup\u003e. Их можно отсортировать подсчетом за время пропорциональное их количеству. Остальных же позиций будет немного, и для их сортировки можно использовать встроенные функции языка. Чтобы убедиться, что количество позиций, которые больше 10\u003csup\u003e6\u003c/sup\u003e невелико, сделаем следующее. Для того, чтобы отрезок максимальной длины не превосходил 10\u003csup\u003e6\u003c/sup\u003e, достаточно сделать не более \u003ci\u003eLen\u003c/i\u003e/10\u003csup\u003e6\u003c/sup\u003e разбиений отрезков. Поскольку, в условии задачи суммарная длина отрезков не превосходит 10\u003csup\u003e9\u003c/sup\u003e, то количество изменений функции, позиции которых превосходят 10\u003csup\u003e6\u003c/sup\u003e, будет меньше 1000. \u003c/p\u003e \u003ch2\u003eЗадача F. Освещение сцены.\u003c/h2\u003e \u003cb\u003eИдея:\u003c/b\u003e Артем Васильев.\u003cbr /\u003e \u003cb\u003eРеализация:\u003c/b\u003e Артем Васильев.\u003cbr /\u003e \u003cb\u003eРазбор:\u003c/b\u003e Артем Васильев.\u003cbr /\u003e \u003cp\u003e  В этой задаче с довольно запутанным условием дан массив пар (мощность, множество выходов),  и для каждой левой границы в массиве нужно найти минимальную правую границу,  чтобы на этом подмассиве существовало подмножество пар со следующими условиями:  \u003c/p\u003e\u003col\u003e  \u003cli\u003e Сумма мощностей должна быть не меньше \u003ci\u003eZ\u003c/i\u003e; \u003c/li\u003e  \u003cli\u003e Множества выходов выбранных прожекторов попарно не пересекаются. \u003c/li\u003e  \u003c/ol\u003e  Подмассив с такими свойствами будем называть хорошим.  \u003cp\u003e  Для начала решим задачу для одной фиксированной левой границы. Такую задачу можно  решить при помощи динамического программирования по двоичным маскам:  \u003ci\u003edp\u003csub\u003emask\u003c/sub\u003e\u003c/i\u003e — это максимальная стоимость прожекторов,  для которых объединение множеств выходов является подмножеством \u003ci\u003emask\u003c/i\u003e.  Формула пересчета для добавления одного элемента (\u003ci\u003ep\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e) выглядит так:  \u003ci\u003edp\u0027\u003csub\u003emask\u003c/sub\u003e\u003c/i\u003e \u003d max(\u003ci\u003edp\u003csub\u003emask\u003c/sub\u003e\u003c/i\u003e,  \u003ci\u003edp\u003csub\u003emask — m\u003c/sub\u003e\u003c/i\u003e + \u003ci\u003ep\u003c/i\u003e), если \u003ci\u003em\u003c/i\u003e является подмаской \u003ci\u003emask\u003c/i\u003e,  и \u003ci\u003edp\u003csub\u003emask\u003c/sub\u003e\u003c/i\u003e, иначе.  Добавление одного элемента можно реализовать за  \u003ci\u003eO\u003c/i\u003e(2\u003csup\u003ek\u003c/sup\u003e). Когда \u003ci\u003edp\u003c/i\u003e\u003csub\u003e2\u003csup\u003ek\u003c/sup\u003e — 1\u003c/sub\u003e становится  больше или равно \u003ci\u003eZ\u003c/i\u003e, надо выдать ответ. \u003c/p\u003e \u003cp\u003e    Легко доказать, что при возрастании левой границы, соответствующая правая граница    неубывает. Это позволяет использовать технику двух указателей для нахождения ответа.    Для реализации техники двух указателей необходимо реализовать структуру данных,     которая поддерживает следующие операции:    \u003c/p\u003e\u003col\u003e        \u003cli\u003eДобавить элемент в конец;\u003c/li\u003e        \u003cli\u003eУдалить элемент из начала;\u003c/li\u003e        \u003cli\u003eОтветить на запрос: \u0026quot;Является ли текущее множество прожекторов хорошим?\u0026quot;.\u003c/li\u003e    \u003c/ol\u003e  \u003cp\u003e    Решение данной задачи использует реализацию очереди на двух стеках с идеями из метода реализации    очереди с минимумом. Аналогично очереди с минимумом, будем хранить в стеках     не просто элементы, а пары (элемент; массив \u003ci\u003edp\u003csub\u003ei\u003c/sub\u003e\u003c/i\u003e, в котором содержатся значения     ДП для элементов с текущего и ниже). Добавление одного элемента в такой стек можно выполнить     за \u003ci\u003eO\u003c/i\u003e(2\u003csup\u003ek\u003c/sup\u003e), удаление за \u003ci\u003eO\u003c/i\u003e(1).     Окончательно, используя такую модификацию стека в очереди, можно отвечать на запрос типа 3 за    \u003ci\u003eO\u003c/i\u003e(2\u003csup\u003ek\u003c/sup\u003e): ответ на него положителен тогда и только тогда, когда    max\u003csub\u003e\u003ci\u003ei\u003c/i\u003e \u003d 0..2\u003csup\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e-1\u003c/sub\u003e    \u003ci\u003edp\u003c/i\u003e\u003csup\u003e1\u003c/sup\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e+\u003ci\u003edp\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e\u003csub\u003e2\u003csup\u003ek\u003c/sup\u003e-1-\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e    ≥ Z, где \u003ci\u003edp\u003c/i\u003e\u003csup\u003e1\u003c/sup\u003e, \u003ci\u003edp\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e — массивы значений ДП на вершине первого и второго    стека, соответственно.  \u003c/p\u003e \u003cp\u003e    В заключение, вспоминая, что каждый элемент в результаты работы очереди, реализованной на двух стеках,    перемещается \u003ci\u003eO\u003c/i\u003e(1) раз, получаем, что решение работает за \u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e2\u003ci\u003e\u003csup\u003ek\u003c/sup\u003e\u003c/i\u003e) времени и     использует \u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e2\u003ci\u003e\u003csup\u003ek\u003c/sup\u003e\u003c/i\u003e) памяти. \u003c/p\u003e\u003c/div\u003e","tags":[]}}