{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1416248677,"rating":114,"authorHandle":"MikeMirzayanov","modificationTimeSeconds":1416248943,"id":14741,"title":"\u003cp\u003eCodeforces Round #277.5 (Div. 2) Editorial [A-D for now]\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/489/problem/A\" title\u003d\"Codeforces Round 277.5 (Div. 2)\"\u003e489A - SwapSort\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eAll you need is to swap the current minimum with the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th element each time. You can do it with the code like:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    for (int i \u003d 0; i \u0026lt; n; i++)\n    {\n        int j \u003d i;\n        for (int t \u003d i; t \u0026lt; n; t++)\n            if (a[j] \u0026gt; a[t])\n                j \u003d t;\n        if (i !\u003d j)\n            answer.push_back(make_pair(i, j));\n        swap(a[i], a[j]);\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis solution makes at most n-1 swap operation. Also \u003ccode\u003eif (i !\u003d j)\u003c/code\u003e is not necessary.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/489/problem/B\" title\u003d\"Codeforces Round 277.5 (Div. 2)\"\u003e489B - BerSU Ball\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThere are about 100500 ways to solve the problem. You can find maximal matching in a bipartite graph boys-girls, write dynamic programming or just use greedy approach.\u003c/p\u003e\u003cp\u003eLet\u0027s sort boys and girls by skill. If boy with lowest skill can be matched, it is good idea to match him. It can\u0027t reduce answer size. Use girl with lowest skill to match. So you can use code like:\u003c/p\u003e \u003cpre\u003esort(boys.begin(), boys.end());\nsort(girls.begin(), girls.end());\n\nfor (int i \u003d 0; i \u0026lt; n; i++)\n    for (int j \u003d 0; j \u0026lt; m; j++)\n        if (abs(boys[i] - girls[j]) \u0026lt;\u003d 1)\n        {\n            girls[j] \u003d 1000;\n            result++;\n            break;\n        }\u003c/pre\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/489/problem/C\" title\u003d\"Codeforces Round 277.5 (Div. 2)\"\u003e489C - Given Length and Sum of Digits...\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThere is a greedy approach to solve the problem. Just try first digit from lower values to higher (in subtask to minimize number) and check if it is possible to construct a tail in such a way that it satisfies rule about length/sum. You can use a function `can(m,s)\u0027 that answers if it is possible to construct a sequence of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e with the sum of digits \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ebool can(int m, int s)\n{\n    return s \u0026gt;\u003d 0 \u0026amp;\u0026amp; s \u0026lt;\u003d 9 * m;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eUsing the function \u003ccode\u003ecan(m,s)\u003c/code\u003e you can easily pick up answer digit-by-digit. For the first part of problem (to minimize number) this part of code is:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    int sum \u003d s;\n    for (int i \u003d 0; i \u0026lt; m; i++)\n        for (int d \u003d 0; d \u0026lt; 10; d++)\n            if ((i \u0026gt; 0 || d \u0026gt; 0 || (m \u003d\u003d 1 \u0026amp;\u0026amp; d \u003d\u003d 0)) \u0026amp;\u0026amp; can(m - i - 1, sum - d))\n            {\n                minn +\u003d char(\u00270\u0027 + d);\n                sum -\u003d d;\n                break;\n            }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe equation \u003ccode\u003e(i \u0026gt; 0 || d \u0026gt; 0 || (m \u003d\u003d 1 \u0026amp;\u0026amp; d \u003d\u003d 0))\u003c/code\u003e is needed to be careful with leading zeroes.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/489/problem/D\" title\u003d\"Codeforces Round 277.5 (Div. 2)\"\u003e489D - Unbearable Controversy of Being\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eLet\u0027s iterate through all combinations of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e just two simple nested loops in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e and find all candidates for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e inside. To find candidates you can go through all neighbors of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and check that they are neighbors of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e. Among all the candidates you should choose two junctions as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e. So just use \u003ca href\u003d\"https://en.wikipedia.org/wiki/Combination\"\u003ehttps://en.wikipedia.org/wiki/Combination\u003c/a\u003e All you need is to add to the answer \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/41/e6/41e64790a3d08f5b8e5f948341f63922654227ca.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e is the number of candidates (common neighbors of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e). The code is:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    for (int a \u003d 0; a \u0026lt; n; a++)\n        for (int c \u003d 0; c \u0026lt; n; c++)\n            if (a !\u003d c)\n            {\n                int r \u003d 0;\n                for (int b \u003d 0; b \u0026lt; nxt[a].size(); b++)\n                    if (nxt[a][b] !\u003d a \u0026amp;\u0026amp; nxt[a][b] !\u003d c \u0026amp;\u0026amp; g[nxt[a][b]][c])\n                        r++;\n                result +\u003d r * (r - 1) / 2;\n            }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt is easy to see that the total complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e)\u003c/span\u003e, because of sum of number of neighbors over all junctions is exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eP.S. I\u0027ll be grateful if some of you will write editorial of E and F in comments because of now I should leave Codeforces and will return back some hours later. Thank you for participation!\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e","tags":["codeforces","round","2775","editorial"]}}