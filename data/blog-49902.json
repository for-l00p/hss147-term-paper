{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1484927551,"rating":0,"authorHandle":"maximumSHOT","modificationTimeSeconds":1484934128,"id":49902,"title":"\u003cp\u003eРазбор задач. День 4.\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eСсылки на полезные ресурсы!!!\u003c/h2\u003e\u003cp\u003e\u003ca href\u003d\"http://e-maxx.ru/algo/ternary_search\"\u003eТернарный поиск\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eКод авторских решений + разбор!\u003c/h1\u003e\u003cp\u003e[problem:101231A]\u003c/p\u003e\u003cp\u003eВ данной задаче требовалось реализовать классический алгоритм \u003ca href\u003d\"https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA\"\u003eбинарного поиска\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eВ некоторых языках программирования этот алгоритм уже реализован. Например, в \u003ccode\u003eC++\u003c/code\u003e существуют такие функции:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;algorithm\u0026gt;\n...\nlower_bound\nupper_bound\nbinary_search\n\u003c/code\u003e\u003c/pre\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eКод\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;math.h\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n\nusing namespace std;\n\n#define ALL(x) (x).begin(), (x).end()\n#define mp make_pair\n#define vec vector\n\ntypedef long long LL;\ntypedef long double LD;\n\nconst LL inf \u003d 1000000000ll;\nconst LL inf64 \u003d inf * inf;\n\nbool bp(vec\u0026lt;int\u0026gt; \u0026amp; a, int x)\n{\n    int l, r, mid;\n    l \u003d 0, r \u003d (int)a.size() - 1;\n    while(r - l \u0026gt; 1)\n    {\n        mid \u003d (l + r) \u0026gt;\u0026gt; 1;\n        if(a[mid] \u0026lt;\u003d x) l \u003d mid;\n        else r \u003d mid - 1;\n    }\n\n    return (a[r] \u003d\u003d x || a[l] \u003d\u003d x);\n}\n\nbool solve()\n{\n    freopen(\u0026quot;collect.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n    freopen(\u0026quot;collect.out\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n    int n;\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    vec\u0026lt;int\u0026gt; a(n);\n    for(int i(0);i \u0026lt; n;i++) scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]); \n\n    int m, x;\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;m);\n\n    for(int i(0);i \u0026lt; m;i++)\n    {\n        scanf(\u0026quot;%d\u0026quot;, \u0026amp;x);\n        puts(bp(a, x)?\u0026quot;YES\u0026quot; : \u0026quot;NO\u0026quot;);\n    }\n\n    return true;\n}\n\nint main()\n{\n    //while(solve());\n    solve();\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e[problem:101231B]\u003c/p\u003e\u003cp\u003eЗаметим, что если мы можем расположить коров по стойлам для числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e так, что минимальное расстояние между всеми парами коров будет равно \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, то можно сделать так и для любого \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/56/02/560214dab95f33ff538f2a3085a8299868400dc3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e можно воспользоваться алгоритмом \u003ca href\u003d\"https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA\"\u003eбинарного поиска\u003c/a\u003e по ответу (по расстоянию \u003cspan class\u003d\"tex-span\"\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e). Осталось только научиться проверять, можно ли расставить \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e коров по \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e стойлам для некоторого неотрицательного целого \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e (назовем функцию, проверяющее данное условие \u003ccode\u003echeck(x)\u003c/code\u003e). Итак, мы знаем число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Поставим первую корову в самое первое стойло и будем перебирать стойла в порядке возрастания их координат, запоминая позицию предыдущей (\u003ccode\u003elast\u003c/code\u003e) поставленной коровы и количество уже поставленных коров (\u003ccode\u003ecnt\u003c/code\u003e). Будем ставить следующие коровы в самом первом стойле \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e таком, что \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecrd\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ecrd\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003elast\u003c/i\u003e\u003c/sub\u003e ≥ \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, обновляя \u003ccode\u003elast \u003d i\u003c/code\u003e и \u003ccode\u003ecnt++\u003c/code\u003e. Так мы узнаем, какое максимальное количество коров мы сможем расставить по стойлам для нашего \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Итого: если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e ≥ \u003ci\u003eK\u003c/i\u003e\u003c/span\u003e, то \u003ccode\u003echeck(x) \u003d true\u003c/code\u003e, иначе \u003ccode\u003echeck(x) \u003d false\u003c/code\u003e \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eКод\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;math.h\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n\nusing namespace std;\n\n#define ALL(x) (x).begin(), (x).end()\n#define mp make_pair\n#define vec vector\n\ntypedef long long LL;\ntypedef long double LD;\n\nconst LL inf \u003d 1000000000ll;\nconst LL inf64 \u003d inf * inf;\n\nint n, k;\nvec\u0026lt;int\u0026gt; a, dp;\n\nbool check(int mid)\n{\n    dp.resize(n, 0);\n    dp[0] \u003d 1;\n    for(int i(1);i \u0026lt; n;i++)\n    {\n        int L, R, MID;\n\n        L \u003d 0, R \u003d i - 1;\n\n        while(R - L \u0026gt; 1)\n        {\n            MID \u003d (L + R) \u0026gt;\u0026gt; 1;\n\n            if(a[i] - a[MID] \u0026gt;\u003d mid) L \u003d MID;\n            else R \u003d MID - 1;\n        } \n\n        dp[i] \u003d 1;\n\n        if(a[i] - a[R] \u0026gt;\u003d mid) dp[i] +\u003d dp[R];\n        else if(a[i] - a[L] \u0026gt;\u003d mid) dp[i] +\u003d dp[L];\n    }   \n\n    return (*max_element(ALL(dp)) \u0026gt;\u003d k);\n}\n\nbool solve()\n{\n    freopen(\u0026quot;cows.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n    freopen(\u0026quot;cows.out\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n    scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;n, \u0026amp;k);\n\n    a.resize(n);\n\n    for(int i(0);i \u0026lt; n;i++) scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]);\n\n    int l \u003d 0, r \u003d a[n - 1] - a[0], mid;\n\n    while(r - l \u0026gt; 1)\n    {\n        mid \u003d (l + r) \u0026gt;\u0026gt; 1;\n        if(check(mid)) l \u003d mid;\n        else r \u003d mid - 1;\n    }\n\n    if(check(r)) printf(\u0026quot;%d\\n\u0026quot;, r);\n    else printf(\u0026quot;%d\\n\u0026quot;, l);\n\n    return true;\n}\n\nint main()\n{\n    //while(solve());\n    solve();\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e[problem:101231C]\u003c/p\u003e\u003cp\u003eЗаметим, что путь мальчика Ферма состоит из двух отрезков: сначала нужно пройти из точки \u003cspan class\u003d\"tex-span\"\u003e(0, 1)\u003c/span\u003e в точку входа из поля в лес \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ea\u003c/i\u003e)\u003c/span\u003e, затем из точки \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ea\u003c/i\u003e)\u003c/span\u003e в точку \u003cspan class\u003d\"tex-span\"\u003e(1, 0)\u003c/span\u003e. Давайте выведем функцию \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e — время в пути, если абсцисса точки входа в лес равна \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Первый отрезок имеет длину \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/36/c4/36c468d85702ea5ef7ef4bfab9c52b030e86147a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, второй — \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/50/97/50974a85f2db5f10096b59f2de21744255214317.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Таким образом общее время в пути \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4d/ff/4dff0425901bd3060a34539ff60308a281ba7ec5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Данная функция является выпуклой вниз (то есть сначала убывает, а с некоторого момента начинает возрастать). Нам нужно найти точку минимума функции \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e на отрезке \u003cspan class\u003d\"tex-span\"\u003e[0;1]\u003c/span\u003e. Воспользуемся классическим алгоритмом \u003ca href\u003d\"http://e-maxx.ru/algo/ternary_search\"\u003eтернарного поиска\u003c/a\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eКод\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n\nusing namespace std;\n\n#define ALL(x) (x).begin(), (x).end()\n#define mp make_pair\n#define vec vector\n\ntypedef long long LL;\ntypedef long double LD;\n\nconst LL inf \u003d 1000000000ll;\nconst LL inf64 \u003d inf * inf;\nconst double eps \u003d 1e-9;\n\ndouble vp, vf, a;\n\ndouble t(double x)\n{\n    return pow((1 - a) * (1 - a) + x * x, 0.5) * vp + \n           pow(a * a + (1 - x) * (1 - x), 0.5) * vf;\n}\n\n\nvoid check(double \u0026amp; m1, double \u0026amp; m2, double \u0026amp; l, double \u0026amp; r)\n{\n    if(t(m1) \u0026lt; t(m2)) r \u003d m2;\n    else l \u003d m1;\n}\n\nbool solve()\n{\n    freopen(\u0026quot;forest.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n    freopen(\u0026quot;forest.out\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n    scanf(\u0026quot;%lf %lf %lf\u0026quot;, \u0026amp;vf, \u0026amp;vp, \u0026amp;a);\n\n    double m1, m2, l, r;\n\n    l \u003d 0, r \u003d 1;\n\n    for(int iter \u003d 0;iter \u0026lt; 1337;iter++)\n    {\n        m1 \u003d l + (r - l) / 3.0;\n        m2 \u003d r - (r - l) / 3.0;\n        check(m1, m2, l, r);\n    }\n\n    if(t(r) \u0026gt; t(l)) printf(\u0026quot;%.10lf\\n\u0026quot;, l);\n    else printf(\u0026quot;%.10lf\\n\u0026quot;, r);\n\n    return true;\n}\n\nint main()\n{\n    //while(solve())\n    solve();\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e[problem:101231D]\u003c/p\u003e\u003cp\u003eПо условию \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e0/e2/e0e2b65ada23faa50c22001a03b938797373c7e0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, также сказано, что уравнение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d 0\u003c/span\u003e имеет \u003cstrong\u003eровно один\u003c/strong\u003e корень. Таким образом график функции \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e пересечет ось \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eOx\u003c/i\u003e\u003c/span\u003e ровно в одном месте (пусть в точке \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e0\u003c/span\u003e). Так как f(x) — непрерывная кубичная функция, то она поменяет свой знак в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e0\u003c/span\u003e. Таким образом знак \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e при \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026lt; \u003ci\u003ex\u003c/i\u003e0\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026gt; \u003ci\u003ex\u003c/i\u003e0\u003c/span\u003e противоположный. Поэтому здесь можно использовать алгоритм бинарного поиска по \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e0\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eРассмотрим два случая:\u003c/p\u003e\u003cp\u003e1) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u0026gt; 0\u003c/span\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/54/76/547607816865b878cfb3c3e53760cbd44cd321e5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e при \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026lt; \u003ci\u003ex\u003c/i\u003e0\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u0026gt; 0\u003c/span\u003e при \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026gt; \u003ci\u003ex\u003c/i\u003e0\u003c/span\u003e, так как \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/87/70/8770f158579b8c6c1e259a6137ffe4df3d12d518.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e2) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u0026lt; 0\u003c/span\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5d/43/5d43e21468edc4d906c82bef0577eb6e43b4f41d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e при \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026lt; \u003ci\u003ex\u003c/i\u003e0\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u0026lt; 0\u003c/span\u003e при \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026gt; \u003ci\u003ex\u003c/i\u003e0\u003c/span\u003e, так как \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1d/35/1d351bed3986fe442d20cfa83e6c54d053a9a4cc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eКод\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;math.h\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;queue\u0026gt;\n\nusing namespace std;\n\n#define ALL(x) (x).begin(), (x).end()\n#define mp make_pair \n#define vec vector\n\ntypedef long long LL;\ntypedef long double LD;\n\nconst LL inf \u003d 1000000000ll;\nconst LL inf64 \u003d inf * inf;\nconst LL base \u003d 1ll \u0026lt;\u0026lt; 32;\nconst LD eps \u003d 1e-8;\n\nLD a, b, c, d;\n\nLD f(LD x)\n{\n    return (a * x * x * x + b * x * x + c * x + d);\n}\n\nbool solve()\n{\n    freopen(\u0026quot;cubroot.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n    freopen(\u0026quot;cubroot.out\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n    scanf(\u0026quot;%Lf%Lf%Lf%Lf\u0026quot;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d);\n\n    if(a \u0026gt; 0)\n    {\n        LD l \u003d -inf / 1000, r \u003d inf / 1000, mid, p;\n\n        for(int iter \u003d 0;iter \u0026lt; 228;iter++)\n        {\n            mid \u003d (l + r) / 2.0;\n\n            if(f(mid) \u0026gt; 0) r \u003d mid - eps;\n            else l \u003d mid;\n        }\n        \n        if(fabs(f(r)) \u0026lt; fabs(f(l))) p \u003d r;\n        else p \u003d l;\n\n        printf(\u0026quot;%.10Lf\\n\u0026quot;, p);\n    }else\n    {\n        LD l \u003d -inf / 1000, r \u003d inf / 1000, mid, p;\n\n        for(int iter \u003d 0;iter \u0026lt; 228;iter++)\n        {\n            mid \u003d (l + r) / 2.0;\n\n            if(f(mid) \u0026lt; 0) r \u003d mid - eps;\n            else l \u003d mid;\n        }\n\n        if(fabs(f(r)) \u0026lt; fabs(f(l))) p \u003d r;\n        else p \u003d l;\n\n        printf(\u0026quot;%.10Lf\\n\u0026quot;, p);\n    }\n\n    return true; \n}\n\nint main()\n{\n    //while(solve());\n    solve();\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e[problem:101231E]\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eКод\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;math.h\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;iomanip\u0026gt;\n\n#define ALL(x) (x).begin(), (x).end()\n#define mp make_pair\n#define vec vector\n#define deb(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026quot; \u003d \u0026quot; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0027\\n\u0027;\n\ntypedef unsigned long long ull;\ntypedef long double LD;\ntypedef long long LL;\n\nconst LL inf \u003d 1000000000ll;\nconst LL inf64 \u003d inf * inf;\nconst LL base \u003d inf + 7;\nconst double pi \u003d acos(-1.0);\n\nusing namespace std;\n\nint n;\nLD l;\nvec\u0026lt; pair\u0026lt; int, int\u0026gt; \u0026gt; a;\n\nbool check(LD x1, LD v1, LD x2, LD v2, LD time) {\n    bool ans;\n    if(x1 - x2 \u0026lt; l) ans \u003d 0;\n    else if(v2 \u0026lt;\u003d v1) ans \u003d 1;\n    else ans \u003d (time * (v2 - v1) \u0026lt;\u003d x1 - x2 - l);\n    return ans;\n}\n\nbool solve()\n{\n    freopen(\u0026quot;trains.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n    freopen(\u0026quot;trains.out\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n    cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; n;\n\n    for(int t, v, i \u003d 0;i \u0026lt; n;i++) {\n        cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; v;\n        a.push_back(mp(t, v));\n    }\n\n    vec\u0026lt; int \u0026gt; sum(n);\n    vec\u0026lt; LL \u0026gt; crd(n);\n    sum[0] \u003d a[0].first;\n    crd[0] \u003d 0;\n    for(int i \u003d 1;i \u0026lt; n;i++) {\n        sum[i] \u003d sum[i - 1] + a[i].first;\n        crd[i] \u003d crd[i - 1] + 1ll * a[i].first * a[i].second;\n    }\n\n    LD bl \u003d 0, br \u003d 1e9, bm;\n\n    for(int kk \u003d 0;kk \u0026lt; 100;kk++) {\n        bm \u003d (bl + br) / 2.0;\n        //cin \u0026gt;\u0026gt; bm;\n        LD x1, v1, x2, v2;\n        x1 \u003d 0;\n        int i, j;\n        for(i \u003d 0;i \u0026lt; n;i++ ) {\n            if(sum[i] \u0026lt;\u003d bm) {\n                x1 +\u003d a[i].first * a[i].second;\n                continue;\n            }\n            LD tmp \u003d bm - (i?sum[i - 1] : 0);\n            x1 +\u003d tmp * (LD)a[i].second;\n            break;\n        }\n        LD time \u003d bm;\n        x2 \u003d 0;\n        bool ok \u003d 1;\n        for(j \u003d 0;j \u0026lt; n;j++) {\n            LD tmp \u003d a[j].first;\n            v2 \u003d a[j].second;\n            while(i \u0026lt; n) {\n                LD ost \u003d sum[i] - time;\n                if(ost \u0026lt;\u003d tmp) {\n                    v1 \u003d a[i].second;\n                    ok \u0026amp;\u003d check(x1, v1, x2, v2, ost);\n                    x1 +\u003d v1 * ost;\n                    x2 +\u003d v2 * ost;\n                    time +\u003d ost;\n                    tmp -\u003d ost;\n                    i++;\n                }else {\n                    v1 \u003d a[i].second;\n                    ok \u0026amp;\u003d check(x1, v1, x2, v2, tmp);\n                    x1 +\u003d v1 * tmp;\n                    x2 +\u003d v2 * tmp;\n                    time +\u003d tmp;\n                    tmp \u003d 0;\n                    break;\n                }\n            }\n            //cout \u0026lt;\u0026lt; ok \u0026lt;\u0026lt; \u0027\\n\u0027;\n            x2 +\u003d tmp * v2;\n        }\n        if(ok) br \u003d bm;\n        else bl \u003d bm;\n    }\n\n    cout.precision(10);\n    cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; bl \u0026lt;\u0026lt; \u0027\\n\u0027;\n\n    return true;\n}   \n\nint main() \n{\n    //while(solve());\n    solve();\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}