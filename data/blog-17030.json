{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1426793119,"rating":12,"authorHandle":"Renegade","modificationTimeSeconds":1426836577,"id":17030,"title":"\u003cp\u003eSolving Round #296 Div 1 A/Div 2 C using Segment Trees\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI know there are much simpler ways of solving this problem but segment trees were the first to come to my mind. Since I\u0027m not so good with trees I wanted to give it a shot. Here\u0027s the basic logic.\u003c/p\u003e \u003col\u003e   \u003cli\u003eMake a segment tree separately for both the width and the height. Each node must store its max volume, and the maximum sized fragment it can hold. Also, the leftmost and the rightmost cut.\u003c/li\u003e   \u003cli\u003eX height Cut is denoted by the left edge of the (X+1)th unit length segment of the segment tree leaves. eg. cut at height 3 would be denoted by the 4th block\u0027s left edge.\u003c/li\u003e   \u003cli\u003eOn cutting the glass, the info is updated on the larger segments as we move up. Ultimately the root holds the value of the largest fragment available.\u003c/li\u003e   \u003cli\u003eMultiply the largest of the height tree and width tree to get the size.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eNote: â€” leftmost and rightmost are initialized to -1 since no nodes contain any cut in the beginning PS. If you read it please point out any mistakes. This was the accepted \u003ca href\u003d\"//codeforces.com/contest/527/submission/10356860\"\u003eSolution\u003c/a\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e\t\tpublic class node {\n\t\t\tint leftmost, rightmost, max;\n\t\t\tint v \u003d 1;\n\n\t\t\t// v is the volume a segment occupies. Max is the maximum size of\n\t\t\t// glass fragment we can get from it in the current condition\n\t\t\tpublic node() {\n\t\t\t\tleftmost \u003d -1;\n\t\t\t\trightmost \u003d -1;\n\t\t\t\tmax \u003d 1;\n\t\t\t}\n\n\t\t}\n\n\t\tpublic class SegmentTree {\n\t\t\tnode[] arr;\n\t\t\tint k;\n\t\t\tint n;\n\n\t\t\tpublic SegmentTree(int n) {\n\t\t\t\tthis.n \u003d n;// initializing the segment tree.\n\t\t\t\tk \u003d (int) (Math.log(n) / Math.log(2));\n\t\t\t\tif (!((n \u0026amp; (n - 1)) \u003d\u003d 0)) {\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tk \u003d (int) Math.pow(2, k);\n\t\t\t\tarr \u003d new node[2 * k];\n\t\t\t\tinit(1);// max value and volume value\u0027s (max and v)\n\t\t\t\t\t\t// initialization is done.\n\t\t\t}\n\n\t\t\tpublic void init(int p) {\n\t\t\t\tif (p \u0026gt;\u003d k) {// p\u0026gt;\u003dk implies we reached the leaf node\n\t\t\t\t\tarr[p] \u003d new node();\n\t\t\t\t\tif (p \u0026gt;\u003d n + k)// implying that this node is beyond limits.\n\t\t\t\t\t\t\t\t\t// Inaccessible so vol\u003d0;\n\t\t\t\t\t\tarr[p].v \u003d arr[p].max \u003d 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tarr[p].v \u003d arr[p].max \u003d 1;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tinit(2 * p);\n\t\t\t\tinit(2 * p + 1);\n\t\t\t\tarr[p] \u003d new node();\n\t\t\t\tarr[p].v \u003d arr[p].max \u003d arr[2 * p].v + arr[2 * p + 1].v;\n\n\t\t\t}\n\n\t\t\t\n\n\t\t\tpublic int getLeftChild(int p) {\n\t\t\t\t//gets the leftmost child of a vertex. Used to get the relative height\n\t\t\t\twhile (p \u0026lt; arr.length)\n\t\t\t\t\tp *\u003d 2;\n\t\t\t\treturn p / 2;\n\t\t\t}\n\n\t\t\tpublic void insert(int h) {\n\t\t\t\tint p \u003d k + h;//reach the appropriate leaf node.\n\t\t\t\tarr[p].rightmost \u003d h;\n\t\t\t\tarr[p].leftmost \u003d h;\n\t\t\t\tp /\u003d 2;\n\t\t\t\twhile (p !\u003d 0) {//Iteratively update the parents\n\t\t\t\t\tint left \u003d 2 * p;\n\t\t\t\t\tint right \u003d 2 * p + 1;\n\t\t\t\t\tint start \u003d getLeftChild(p);\n\t\t\t\t\tstart -\u003d k;//make the start in terms of h\n                                        //3 cases arise:\n                                        //1. left child has no cut\n                                        //2. right child has no cut\n                                        //3. both childs have cuts\n\t\t\t\t\tif (arr[left].rightmost \u003d\u003d -1) {\n\t\t\t\t\t\tarr[p].max \u003d Math.max(\n\t\t\t\t\t\t\t\tMath.max(arr[left].max, arr[right].max),\n\t\t\t\t\t\t\t\tarr[right].leftmost - start);\n\n\t\t\t\t\t} else if (arr[right].leftmost \u003d\u003d -1) {\n\t\t\t\t\t\tarr[p].max \u003d Math.max(arr[p].v\n\t\t\t\t\t\t\t\t- (arr[left].rightmost - start),\n\t\t\t\t\t\t\t\tMath.max(arr[left].max, arr[right].max));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tarr[p].max \u003d Math.max(\n\t\t\t\t\t\t\t\tMath.max(arr[left].max, arr[right].max),\n\t\t\t\t\t\t\t\tarr[right].leftmost - arr[left].rightmost);\n\t\t\t\t\t}\n\t\t\t\t\t//reassign the leftmost and rightmost of the current node\n\t\t\t\t\tarr[p].leftmost \u003d arr[left].leftmost;\n\t\t\t\t\tarr[p].rightmost \u003d arr[right].rightmost;\n\t\t\t\t\tif (arr[p].leftmost \u003d\u003d -1)\n\t\t\t\t\t\tarr[p].leftmost \u003d arr[right].leftmost;\n\t\t\t\t\tif (arr[p].rightmost \u003d\u003d -1)\n\t\t\t\t\t\tarr[p].rightmost \u003d arr[left].rightmost;\n\t\t\t\t\tp /\u003d 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tpublic void Solve() {\n\t\t\tint w \u003d ni();\n\t\t\tint h \u003d ni();\n\t\t\tint n \u003d ni();\n\t\t\tSegmentTree width \u003d new SegmentTree(w);\n\t\t\tSegmentTree height \u003d new SegmentTree(h);\n\t\t\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\t\t\tString line[] \u003d l().split(\u0026quot; \u0026quot;);\n\t\t\t\tint p \u003d Integer.parseInt(line[1]);\n\t\t\t\tif (line[0].equals(\u0026quot;H\u0026quot;)) {\n\t\t\t\t\theight.insert(p);\n\t\t\t\t} else {\n\t\t\t\t\twidth.insert(p);\n\t\t\t\t}\n\t\t\t\tlong x1 \u003d height.arr[1].max;\n\t\t\t\tlong x2 \u003d width.arr[1].max;\n\t\t\t\tSystem.out.println(x1 * x2);\n\n\t\t\t}\n\n\t\t}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["segment tree","#round #296","logarithmic"]}}