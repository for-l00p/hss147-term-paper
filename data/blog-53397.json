{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1500564687,"rating":24,"authorHandle":"Miyukine","modificationTimeSeconds":1500564687,"id":53397,"title":"\u003cp\u003e[CEOI 2017] Defeated by Mousetrap\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI tried to solve CEOI 2017 Day1 problem — Mousetrap today during the \u003ca class\u003d\"rated-user user-black\" href\u003d\"/profile/csacademy\" title\u003d\"Unrated, csacademy\"\u003ecsacademy\u003c/a\u003e mirror.\u003c/p\u003e\u003cp\u003eMy idea is a bit different than what model solution does, but in the same time complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlogn\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eI\u0027ll describe it briefly. First, let\u0027s assume we can freeze the mouse for a while and prepare the way for her. Let\u0027s calculate answer for this case and call it pathOnly. This is computed by the simple formula.\u003c/p\u003e\u003cp\u003eNow let\u0027s unfreeze the mouse. We will do binary search on answer — how many additional operations do we need now. Let\u0027s precalculate cost[] for each vertex x, meaning: how many additional operations if mouse gets to vertex x and stays there forever. Forever means in this case: until we prepare the rest of the graph for her. \u003c/p\u003e\u003cp\u003eCost is computed by a simple recursive formula : cost[onPath] \u003d 0 and cost[x] \u003d cost[parent[x]] + degree(x) — 1 otherwise.\u003c/p\u003e\u003cp\u003eNow let\u0027s move to the last step of the solution. Assume we are at some step of binsearch checking if the result can be not greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e now. If a vertex has cost bigger than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, we should never let the mouse reach it. Otherwise, the mouse can safely get to that vertex. We compute dp[x] now -\u0026gt; how many operations do we need to succeed to be done before the mouse enters vertex x, dp[x] can be either \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. When a vertex is forbidden or sum of dps from its sons is greater than \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, dp[x] equals 1. Otherwise, it is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. In the end, if dp[root] \u0026gt; 0, the answer for our current \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e does not exist and does exist otherwise.\u003c/p\u003e\u003cp\u003eThe problem is that this solution doesn\u0027t work in at least two ways. I believe the implementation is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlogn\u003c/i\u003e\u003c/span\u003e) and should fit in the time limit, but it fails a lot. It gets WA twice, too. I would be very grateful if someone expressed his opinion about it.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://pastebin.com/SpdpEDRj\"\u003eCode (pastebin)\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThanks in advance. PS. How to link the submission on csacademy?\u003c/p\u003e\u003c/div\u003e","tags":[]}}