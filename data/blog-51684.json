{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1492974947,"rating":88,"authorHandle":"infinity","modificationTimeSeconds":1493024654,"id":51684,"title":"\u003cp\u003eFully Persistent Convex Hull Trick\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHey guys,\u003c/p\u003e\u003cp\u003eConvex hull optimization is a well known technique used for speeding up dynamic programming algorithms.A thorough explanation of the technique can be found in the end of the post at (1). You can also check the codeforces blog post about various dynamic programming optimizations at (2). I made this blog post to explain how to make convex hull optimization fully persistent. Even though the persistent version consists of a very natural extension of the original data structure I couldn\u0027t find anything with a quick search on google, therefore i decided to share it with the codeforces community. So here it goes.\u003c/p\u003e\u003cp\u003eAt first let me state the problem. We want to construct a DS which can support the following operations:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eInsert a line in the DS, given by a pair (a,b) which represents the slope of the line and the vertical displacement. We demand that the line we are inserting has greater slope than any of the lines previously on the DS.\u003c/li\u003e   \u003cli\u003eGiven a vertical line \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e, find the line in the DS which intersects the vertical line higher than any of the other lines in the DS. Basically we are searching for the line \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e * \u003ci\u003ex\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e for which the system of equations \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/04/7a/047ac843dbe7c17af0498dfe6e56ac1ba898dbd1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e has a solution \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e for which y is maximum.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThis is the original version of the convex hull problem. In order to get the fully persistent version of the problem we also demand that we can modify an older version of the DS and also query a certain version of the DS. To clarify, when we talk about versions of the DS we consider that version 0 consists of the empty data structure and every insertion defines a new version of the DS.\u003c/p\u003e\u003cp\u003eIn order to support the operations above we will use a technique similar to that of a persistent stack. We will build a rooted tree so that every node represents a line and a node to root path represents a version of the stack. The root represents the empty stack. We maintain a pointer that points to the current version of the DS. To insert a line to the current version, we simply insert a child from the current version to a new node that contains the line to be inserted and we update the pointer. For example if we add the following lines: \u003cspan class\u003d\"tex-span\"\u003e(1, 2), (2, 3), (3, 5)\u003c/span\u003e our DS will have the following form: \u003cimg alt\u003d\" \" src\u003d\"/predownloaded/42/c1/42c189776fe36ee4bfd20755eb8245e62fabfcd3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eWe use this model to support the persistent operations. When we want to add a line to a specific version we simply find the node that represents that version in our tree model and we add a new branch containing our line. To be able to do that we also need a version to node correspondence but this is easy to maintain with a simple array. Therefore if we wanted to add a line (e,g (4,5)) in version 2 of our DS we simply add a new child. Therefore we would have something like this:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/b7/0b/b70b829fbdfd8f264a2651fbd2731ba28ac18fe8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eOf course, when we add a specific line to a version, some of the lines may become irrelevant (i.e Never be optimal). therefore, if that\u0027s the case, we pop from the top of the stack until our lines are relevant. Of course, popping in our current setting is equivalent to traversing from the node of the current line in that version of the DS to the root and updating the version settings. This may create a problem in the complexity of our structure since we cannot make the same amortization argument we do in our original version (We may be asked to traverse to the root multiple times). We will see how to resolve that shortly.\u003c/p\u003e\u003cp\u003eThe question remains though, how could we query a version of our DS represented in the way we described above. We will use jump pointers. Every time we insert a line to a specific version we create links to its \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e parent for all k in the same way we do it for LCA. Now, in order to query a version we go to the node that represents the version in the tree and using the jump pointers we perform a binary search. Remember that we only care about the path from the specific node to the root since that\u0027s what our stack consists of in that version. Let\u0027s use u to represent our node in question (the version we are querying) and let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e be the \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e-th parent of node u. We find the largest k for which \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e ≤ \u003ci\u003edepth\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and we operate similarly to the original version of the problem. We check the node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e \u003d \u003ci\u003eP\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e and its parent \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e, if the line that is stored in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e intersects the vertical line higher than the line stored in v we go to v and continue our search from there. Otherwise we decrease k and continue.\u003c/p\u003e\u003cp\u003eBy using jump pointers we can also resolve the problems we had updating the data structure. We will simply perform a binary search to find the first line in the node to root path that should not be erased from the DS and add a child to that specific node. The binary search condition is the same as with the original version of the DS.\u003c/p\u003e\u003cp\u003eTherefore we have achieved to support our operations in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e space \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e worst case time for update and query. \u003c/p\u003e\u003cp\u003e(1) \u003ca href\u003d\"https://wcipeg.com/wiki/Convex_hull_trick\"\u003eConvex Hull Trick\u003c/a\u003e\u003c/p\u003e\u003cp\u003e(2) \u003ca href\u003d\"//codeforces.com/blog/entry/8219\"\u003eDynamic Programming Optimizations\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI am sure that a similar idea is probably discussed somewhere, I just felt like sharing it since i think that it can be used for many cool problems. If you know any problems that can be solved using this technique please add them in the comments. Feel free to make any corrections or point out any mistakes, there might be quite a few of them.\u003c/p\u003e\u003c/div\u003e","tags":["dynamic programming","convex hull optimization","persistent structures","geometry"]}}