{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1494041783,"rating":0,"authorHandle":"quinamatics","modificationTimeSeconds":1494042108,"id":51865,"title":"\u003cp\u003eNeed Help With Problem 615C\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI am trying Problem C on Round 338 Div2, Running Track. However my code receives TLE on Test Cast 16. I have had these issues in the past and would like details on if my solution can be optimized or if I need to switch to a faster method.\u003c/p\u003e\u003cp\u003eHere is my code below.\u003c/p\u003e\u003cp\u003eimport java.util.ArrayList; import java.util.Arrays; import java.util.Scanner;\u003c/p\u003e\u003cp\u003epublic class D2615C {  public static void main(String[] args) {\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e  Scanner s \u003d new Scanner(System.in);\n  int inc \u003d 0;\n  String[] sol \u003d new String[100000];\n  String str \u003d s.nextLine();\n  String tgt \u003d s.nextLine();\n  String[] item \u003d new String[tgt.length()+1];\n  int[] index \u003d new int[tgt.length()+1];\n  Arrays.fill(index,Integer.MAX_VALUE);\n\n  int[] dp \u003d new int[tgt.length()+1];\n  dp[0] \u003d 0;\n\n\n\n  for(int i \u003d 1; i \u0026lt; dp.length; i++){\n\n\n\n      String reverse \u003d \u0026quot;\u0026quot;;\n      int min \u003d 99999;\n      int prevMin \u003d 99999;\n\n      for(int j \u003d 0; j \u0026lt; i; j++){\n        String rev \u003d \u0026quot;\u0026quot;; \n\n\n        if(dp[j] \u003d\u003d -1)\n          continue;\n\n        String seg \u003d tgt.substring(j,i);\n        for(int k \u003d 0; k \u0026lt; seg.length(); k++)\n          rev +\u003d seg.charAt(seg.length()-k-1);\n\n\n         if(str.contains(tgt.substring(j,i))){\n           min \u003d Math.min(min, dp[j]+1);    \n           if(prevMin \u0026gt; min){\n            prevMin \u003d min;\n            index[i] \u003d j;\n            item[i] \u003d (str.indexOf(tgt.substring(j,i))+1)+ \u0026quot; \u0026quot;+ (str.indexOf(tgt.substring(j,i))+(i-j));\n           }\n         }\n         else if(str.contains(rev)){\n           min \u003d Math.min(min, dp[j]+1);\n           if(prevMin \u0026gt; min){\n            prevMin \u003d min;\n            index[i] \u003d j;\n            item[i] \u003d (str.indexOf(rev)+(i-j))+\u0026quot; \u0026quot;+(str.indexOf(rev)+1);\n           }\n         }       \n\n      }\n      if(min \u003d\u003d 99999)\n         dp[i] \u003d -1; \n      else\n         dp[i] \u003d min;\n  } \n  System.out.println(dp[tgt.length()]);\n  if(dp[tgt.length()]!\u003d -1){\n      int c \u003d tgt.length();\n      while( c!\u003d 0){\n         sol[inc++]\u003ditem[c];\n         c \u003d index[c];\n      }\n      for(int i \u003d inc-1; i \u0026gt;\u003d 0; i--){\n         System.out.println(sol[i]);\n     }\n\n  }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e}\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/div\u003e","tags":[]}}