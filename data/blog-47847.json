{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1476784265,"rating":75,"authorHandle":"underSpirit","modificationTimeSeconds":1476784265,"id":47847,"title":"\u003cp\u003eA Sad Story of std::map and Getting TLE!\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"http://www.cplusplus.com/reference/map/map/\"\u003e\u003cstrong\u003estd::map\u003c/strong\u003e\u003c/a\u003e is a commonly used C++ container in problem solving. But careless use of \u003ccode\u003emap\u003c/code\u003e can cause \u003ccode\u003eTime Limit Exceeded\u003c/code\u003e in some cases.\u003c/p\u003e\u003cp\u003eSee \u003ccode\u003eExample 1\u003c/code\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int N \u003d 1e6;\nmap\u0026lt;int, int\u0026gt;mp;\nint main() {\n    for ( int i \u003d 1; i \u0026lt;\u003d N; i++ ) mp[i]++;\n    clock_t t \u003d clock();\n    for ( int i \u003d 1; i \u0026lt;\u003d N; i++ ) {\n        if ( mp.find ( i ) !\u003d mp.end() ) {\n            // found\n        }\n    }\n    t \u003d clock() - t;\n    printf ( \u0026quot;Time 1: %lf\\n\u0026quot;, ( double ) t / CLOCKS_PER_SEC );\n    t \u003d clock();\n    for ( int i \u003d 1; i \u0026lt;\u003d N; i++ ) {\n        if ( mp[i] ) {\n            // found\n        }\n    }\n    t \u003d clock() - t;\n    printf ( \u0026quot;Time 2: %lf\\n\u0026quot;, ( double ) t / CLOCKS_PER_SEC );\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn my computer \u003ccode\u003eTime 1: 0.420439\u003c/code\u003e and \u003ccode\u003eTime 2: 0.420225\u003c/code\u003e. \u003cstrong\u003eThey are almost same!\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eNow, \u003ccode\u003eExample 2\u003c/code\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int N \u003d 1e6;\nmap\u0026lt;int, int\u0026gt;mp;\nint main() {\n//    for ( int i \u003d 1; i \u0026lt;\u003d N; i++ ) mp[i]++;\n    clock_t t \u003d clock();\n    for ( int i \u003d 1; i \u0026lt;\u003d N; i++ ) {\n        if ( mp.find ( i ) !\u003d mp.end() ) {\n            // found\n        }\n    }\n    t \u003d clock() - t;\n    printf ( \u0026quot;Time 1: %lf\\n\u0026quot;, ( double ) t / CLOCKS_PER_SEC );\n    printf ( \u0026quot;Size 1: %d\\n\u0026quot;, ( int ) mp.size() );\n    t \u003d clock();\n    for ( int i \u003d 1; i \u0026lt;\u003d N; i++ ) {\n        if ( mp[i] ) {\n            // found\n        }\n    }\n    t \u003d clock() - t;\n    printf ( \u0026quot;Time 2: %lf\\n\u0026quot;, ( double ) t / CLOCKS_PER_SEC );\n    printf ( \u0026quot;Size 2: %d\\n\u0026quot;, ( int ) mp.size() );\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003eTime 1:  0.055969\u003c/code\u003e and \u003ccode\u003eTime 2: 0.779736\u003c/code\u003e. \u003cstrong\u003eHere, \u003ccode\u003eTime 2\u003c/code\u003e is almost \u003ccode\u003e15 times greater\u003c/code\u003e than \u003ccode\u003eTime 1\u003c/code\u003e.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eNow, what\u0027s the difference?\u003c/p\u003e\u003cp\u003eIn \u003ccode\u003eExample 1\u003c/code\u003e we checked \u003ccode\u003eN\u003c/code\u003e numbers where they were mapped and caused no time difference. But, in \u003ccode\u003eExample 2\u003c/code\u003e \u003ccode\u003eN\u003c/code\u003e numbers weren\u0027t mapped and caused a huge time difference. What\u0027s the reason behind this effect?\u003c/p\u003e\u003cp\u003eWhen we use \u003ca href\u003d\"http://www.cplusplus.com/reference/map/map/find/\"\u003estd::map::find\u003c/a\u003e it searches the container for an element with a key equivalent to k and returns an iterator to it if found, otherwise it returns an iterator to \u003ccode\u003emap::end\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eBut, on the other hand using \u003ca\u003estd::map::operator\u003c/a\u003e : if k matches the key of an element in the container, the function returns a reference to its mapped value. If k does not match the key of any element in the container, the function \u003cstrong\u003einserts a new element with that key\u003c/strong\u003e and returns a reference to its mapped value.\u003c/p\u003e\u003cp\u003eSo, in \u003ccode\u003eExample 2\u003c/code\u003e every time we are using \u003ccode\u003emp[i]\u003c/code\u003e, we are not only checking the existence of \u003ccode\u003ei\u003c/code\u003e but also mapping it with a value (more formally with \u003ccode\u003e0\u003c/code\u003e).\u003c/p\u003e\u003cp\u003eIn \u003ccode\u003eExample 2\u003c/code\u003e we edited couple of extra lines to proof the above statements. This lines will show the size of the map after performing this operations.\u003c/p\u003e\u003cp\u003eWe get \u003ccode\u003eSize 1: 0\u003c/code\u003e and \u003ccode\u003eSize 2: 1000000\u003c/code\u003e. Look at \u003ccode\u003eSize 2\u003c/code\u003e, isn\u0027t it exactly \u003ccode\u003eN (number of values)\u003c/code\u003e?\u003c/p\u003e\u003cp\u003eFinally, we come to real time experience. Solve this problem, \u003ca href\u003d\"/contest/732/problem/E\" title\u003d\"Codeforces Round 377 (Div. 2)\"\u003e732E - Sockets\u003c/a\u003e from \u003ca href\u003d\"/contest/732\" title\u003d\"Codeforces Round 377 (Div. 2)\"\u003eCodeforces Round #377 (Div. 2)\u003c/a\u003e with using \u003ccode\u003etwo different techniques of mapping\u003c/code\u003e and you will see the results.\u003c/p\u003e\u003cp\u003eAdvance \u003cstrong\u003eSorry\u003c/strong\u003e for your \u003ccode\u003eTime Limit Exceeded\u003c/code\u003e and \u003cstrong\u003eCongrats\u003c/strong\u003e for \u003ccode\u003eAccepted\u003c/code\u003e.\u003c/p\u003e\u003c/div\u003e","tags":["stl"]}}