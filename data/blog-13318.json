{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1407401549,"rating":0,"authorHandle":"m.radwan","modificationTimeSeconds":1407515053,"id":13318,"title":"\u003cp\u003eWeeks 3-4 writeup\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003ePawn Game\u003c/h4\u003e\u003cp\u003eFirst to solve this problem you need to make sure you understand grundy numbers, if you don\u0027t read it from \u003ca href\u003d\"http://www.gabrielnivasch.org/fun/combinatorial-games/sprague-grundy\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eNow try playing a game with n pairs of pawns, try moving a pawn from the middle you\u0027ll see that a sequence of moves has to follow in order to kill that pawn, and pawns that move in to kill that pawn, in the end the game will be split into two games each of different length.\u003c/p\u003e\u003cp\u003eThis allows us to write a dynamic programming algorithm to calculate grundy number for different values of n, however the algorithm will have a running time of O(n^2)!.\u003c/p\u003e\u003cp\u003eInstead we try to find grundy number for the first say 1000 values of n, then we print out the sequence of losing games, we\u0027ll observe that this sequence is cyclic, now using this we can tell whether a state is a wining or losing state in O(1).\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://pastebin.com/hAKT1xRq\"\u003ehttp://pastebin.com/hAKT1xRq\u003c/a\u003e\u003c/p\u003e\u003ch4\u003ePerfect Lodging\u003c/h4\u003e\u003cp\u003eAn undirected graph has to be constructed from the given directed graph where two nodes are connected if each of them can stay with the other. The problem then becomes direct maximum matching on a general graph, an easy way to tell whether there\u0027s a perfect matching or not it is to use \u003ca href\u003d\"http://e-maxx.ru/algo/tutte_matrix\"\u003etutte\u0027s matrix\u003c/a\u003e.\u003c/p\u003e\u003ch4\u003eMinimal cut matrix\u003c/h4\u003e\u003cp\u003eFirst observe that for any triangle a, b, c we\u0027ll have mc(a, b) equals mc(a, c) or mc(a, b) equals mc(b, c) or mc(a, c) equals mc(b, c) in other words the triangle has to be isosceles. Further more each of the pair of equal sides is less than or equal the third side, it\u0027s easy to prove this by contradiction (i.e assume not and then show that we can obtain a smaller cut for any of the pairs).\u003c/p\u003e\u003cp\u003eUsing only this observation we can tell whether we can or not find the graph, but how do we find one graph that gives the answer?\u003c/p\u003e\u003cp\u003eFor this problem, I followed the guess and check method to find the solution, it\u0027s usually a good idea to assume a simple solution when you don\u0027t know what to do and try to see whether it works or not.\u003c/p\u003e\u003cp\u003eThe first thing to try is one random spanning tree, it\u0027s obvious that this won\u0027t work, one triangle is enough to prove that.\u003c/p\u003e\u003cp\u003eWhat about another tree ? since min cut in a tree as the min edge, how about trying out max spanning trees ?\u003c/p\u003e\u003cp\u003eIt turned out that maximum spanning tree is the correct answer, but how do we prove that ?\u003c/p\u003e\u003cp\u003eWe need to make use of the properties of the problem AND the properties of the maximum spanning tree.\u003c/p\u003e\u003cp\u003eLet\u0027s take a look at the path between any two nodes (A, B) in the maximum spanning tree, we need to prove that smallest edge in this path is at least as large as the direct edge between (A, B) in the min cut graph, and this is easy to prove by contradiction since if the direct edge was heavier than some edge we can do a replacement and get better solution.\u003c/p\u003e\u003cp\u003eNow we need to prove that the smallest edge in this path is equal to the direct edge between (A, B), proof is done by induction.\u003c/p\u003e\u003cp\u003eIf the path contains only 3 nodes then by the isosceles triangle property this is correct.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/9b/75/9b75d3a697688d296b0d2ecc0a81c5cccb831b2d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eOtherwise let\u0027s take a look at triangle A, B, C where C is the next node to A on the path in max spanning tree. if AB \u003d AC then we\u0027re done and the smallest edge in the path is equal to AB, otherwise then AC is larger than AB and thus BC is equal to AB, thus the problem reduces to proving path between C, B has lightest edge equal BC (or AC) so by induction this works!.\u003c/p\u003e\u003ch4\u003eWormtongues\u0027 mind\u003c/h4\u003e\u003cp\u003eSo for just an x we know that the variable is uniformly distributed between 0, 1 with expected value 0.5.\u003c/p\u003e\u003cp\u003eNow the problem is given two random variables X, Y how do we calculate the expected value of max(X, Y) ? OR more specifically given the pdf for X, Y can we calculate the pdf of max(X, Y) ?\u003c/p\u003e\u003cp\u003eFirst observe that Pr{max(X, Y)≤K} \u003d Pr{X ≤ K} * Pr{Y≤K}, this means that the cpdf of max(X, Y) is equal to the multiplication of the cpdf of X and Y, using cpdf we can differentiate it to get the pdf.\u003c/p\u003e\u003cp\u003eAlso observe that Pr{min(X, Y)≤K} \u003d 1 — (1-Pr{X≤K}) * (1-Pr{Y≤K}), so we can get pdf of min(X, Y) similar to above.\u003c/p\u003e\u003cp\u003eSo now given the cdf of X, Y we can compute the cdf of min(X, Y) or max(X, Y) and then compute the pdf from cdf, using the pdf we can find the expected value by integrating (x * pdf) Using those we can solve the problem, all the above pdfs are polynomial so you might need to implement a polynomial class.\u003c/p\u003e\u003cp\u003eIf you don\u0027t know about pdf and cdf you MUST read here \u003ca href\u003d\"http://en.wikipedia.org/wiki/Cumulative_distribution_function\"\u003ehttp://en.wikipedia.org/wiki/Cumulative_distribution_function\u003c/a\u003e \u003ca href\u003d\"http://en.wikipedia.org/wiki/Probability_density_function\"\u003ehttp://en.wikipedia.org/wiki/Probability_density_function\u003c/a\u003e\u003c/p\u003e\u003ch4\u003eDivisibility\u003c/h4\u003e\u003cp\u003eRead it \u003ca href\u003d\"https://solveit.quora.com/Problem-Divisibility\"\u003ehere\u003c/a\u003e\u003c/p\u003e\u003ch4\u003eColor the tree\u003c/h4\u003e\u003cp\u003eLet\u0027s first try to solve a simpler problem which is coloring a rooted tree, respecting isomorphism of course.\u003c/p\u003e\u003cp\u003eLet\u0027s solve the problem recursively, i.e calculate the number of ways to color each child, also let\u0027s calculate a label for each child such that label(i) \u003d\u003d label(j) if subtrees rooted at i, j are isomeprhic, and obviously if label(i) \u003d\u003d label(j) thus number of ways to color subtree rooted at i is equal to number of ways to color subtree rooted at j.\u003c/p\u003e\u003cp\u003elet freq[k] is number of ways label k exists in the children of the root, let ways[k] is number of ways to color label k, to color a tree then we have to color the root and then for each child we have to choose a coloring but we have to do it in such a way that children having the same label doesn\u0027t get the same coloring more than once (i.e color A with color 0 and color B with color 1, then do the reverse), we have to choose using combinations with repetitions i.e S(ways[k], freq[k]) this way we will avoid colorings that doesn\u0027t respect isomorphism. One way is to try each pair of nodes as roots and test isomerphy, however this is exhaustive.\u003c/p\u003e\u003cp\u003eFrom last two weeks we already know how to tell if two rooted trees are isomorphic, but what if they were not rooted ?\u003c/p\u003e\u003cp\u003eOne nice property in trees is that a tree has exactly one center (the middle node in the diameter of an odd length), or two centers (the middle pair of nodes). Thus to tell if two trees are isomorphic we have to only try out the centers as roots.\u003c/p\u003e\u003cp\u003eNow let\u0027s assume the tree has only a single center, thus to count the number of ways to color that tree we can root this tree at the center and count the number of ways to color a rooted tree (ways which respect isomorphism).\u003c/p\u003e\u003cp\u003eIf the tree is bicentric we root at one of the centers and count the number of ways to color a rooted tree, however this still does not respect isomorphism for unrooted tree for example this tree:-\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ea---b---c---d\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ewhen we root it will become\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e     b\n    / \\\n   a   c\n        \\\n         d\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eand the coloring\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e0---1---0---1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ewhich is the same as\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e1---0---1---0\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ewill be counted twice.\u003c/p\u003e\u003cp\u003eA neat way to fix this, is to avoid having bicentric trees, i.e add a single node in the center this way we will have a single center tree which we know already that the rooted tree coloring algorithm colors correctly.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://pastebin.com/9diyg1ZZ\"\u003ehttp://pastebin.com/9diyg1ZZ\u003c/a\u003e\u003c/p\u003e\u003ch4\u003eSweets\u003c/h4\u003e\u003cp\u003eBetter described in the preview of looking for a challenge book \u003ca href\u003d\"http://www.lookingforachallengethebook.com/\"\u003ehttp://www.lookingforachallengethebook.com/\u003c/a\u003e\u003c/p\u003e\u003ch4\u003eSum\u003c/h4\u003e\u003cp\u003eSo we want to tell if we can find positive integer x\u0027s such that\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e * \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e + \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e * \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + ... + \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e * \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e\u003c/center\u003e\u003cp\u003eThe problem suggests a number theoretic solution (extended euclid maybe ?), however NO!, we already know that this problem is NPComplete and so we have to think alternatively.\u003c/p\u003e\u003cp\u003elet\u0027s play little bit with the equation above\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e - (\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e * \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + ... + \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e * \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e) \u003d \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e * \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e\u003c/center\u003e\u003cp\u003ethis means that the left hand side has to be divisible by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e, also \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e * \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + ... + \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e * \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e has to be less or equal \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow the problem becomes a shortest path problem we want to find the smallest value of \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e * \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + ... + \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e * \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e that is when subtracted from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e makes the answer divisible by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e, if such a value is less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e then the answer is TAK otherwise the answer is NIE, and yeah I speak polish.\u003c/p\u003e\u003cp\u003eSo we construct a graph with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e nodes, where being at node i means that the current value leaves remainder i when divided by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e, we start at node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u003ci\u003emod\u003c/i\u003e \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e and each time we take an edge \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e we decrease the value of the mod by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, and add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to the distance travelled so far.\u003c/p\u003e\u003cp\u003eCode: \u003ca href\u003d\"http://pastebin.com/pa4pDzuA\"\u003ehttp://pastebin.com/pa4pDzuA\u003c/a\u003e\u003c/p\u003e\u003ch4\u003eCryptography\u003c/h4\u003e\u003cp\u003ePlace holder\u003c/p\u003e\u003ch4\u003eImportant roads\u003c/h4\u003e\u003cp\u003ePlace holder\u003c/p\u003e\u003ch4\u003eDivisible substrings\u003c/h4\u003e\u003cp\u003eA dynamic programming problem, for each non terminal i we calculate the following suff[i][k] \u003d how many suffixes mod n have value k.\u003cbr /\u003e pref[i][k][l] \u003d how many prefixes mod n have value k, and length q where \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/sup\u003e \u003ci\u003emod\u003c/i\u003e \u003ci\u003en\u003c/i\u003e \u003d \u003ci\u003el\u003c/i\u003e\u003c/span\u003e.\u003cbr /\u003e using those we can count the number of substrings that are divisible by n. \u003c/p\u003e\u003ch4\u003eChip installation\u003c/h4\u003e\u003cp\u003eA Direct 2-sat problem, I only included it because of strong test data and solution recovery, if you don\u0027t know how to do it read it at emaxx algo.\u003c/p\u003e\u003ch4\u003eBarricades\u003c/h4\u003e\u003cp\u003eBetter described in the preview of looking for a challenge book \u003ca href\u003d\"http://www.lookingforachallengethebook.com/\"\u003ehttp://www.lookingforachallengethebook.com/\u003c/a\u003e\u003c/p\u003e\u003ch4\u003eCode feat\u003c/h4\u003e\u003cp\u003eThe problem strongly suggests that we will use Chinese remainder theorem in the solution, the straight forward method in the beginning seems like 100^9, however it\u0027s not, as we know the chinese remainder theorem states that there\u0027s a one to one correspondence between \u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eXmodM\u003c/i\u003e\u003c/span\u003e\u003c/center\u003e\u003cp\u003eand\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eXmodm\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e\u003c/center\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eXmodm\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e\u003c/center\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e...\u003c/span\u003e\u003c/center\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eXmodm\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e\u003c/center\u003e\u003cp\u003ewhen \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egcd\u003c/i\u003e(\u003ci\u003em\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003em\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e) \u003d 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e * \u003ci\u003em\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e * ... * \u003ci\u003em\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eM\u003c/i\u003e\u003c/span\u003e and M here is at most 2^31 thus we will never reach 100^9.. Better but still not enough, how about if the number was at most sqrt(2^31) would we be able to solve the problem ? obviously yes, can we apply meet in the middle here ?\u003c/p\u003e\u003cp\u003eLet\u0027s partition the moduli into two sets, and generate all possible values for each set (i.e calculate a partial summation for the chinese remainder theorem Sum(xi * (M/mi * (M/mi)^-1 mod mi)) mod M)\u003c/p\u003e\u003cp\u003ewe should now have two arrays (A, B) each of length approx. around sqrt(2^31) we sort those arrays, we want for each value in A calculate top 20 values matching with these value i.e (A[i] + B[j]) mod M is as minimum as possible.\u003c/p\u003e\u003cp\u003eWhen we add A[i] to B[j] there is two possibilities, the first possibility is that we don\u0027t cycle i.e don\u0027t exceed M, if so we have then to choose the smallest values of B[j] i.e B[0], B[1]..., the other possibility is that we cycle but we have to observe that if we will cycle we will cycle at most once, singe A[i] \u0026lt; M, B[j] \u0026lt; M, thus we should choose the smallest j that would make A[i] + B[j] ≥ M, and the one next to it, and so on.\u003c/p\u003e\u003cp\u003eFinnally one last thing we will observe here that the running time is O(max(A.length, B.length) * log(max(A.length, B.length)), in order to pass the time limit we have to partition the moduli into A, B in a way that minimizes this function this can be easily by trying all possibilities.\u003c/p\u003e\u003ch4\u003eRest of the problems\u003c/h4\u003e\u003cp\u003ePlease check their editorial on topcoder, or codejam.\u003c/p\u003e\u003c/div\u003e","tags":[]}}