{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1466350194,"rating":18,"authorHandle":"I_love_Hoang_Yen","modificationTimeSeconds":1466437898,"id":45537,"title":"\u003cp\u003eKMP\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eVideo:\u003c/h1\u003e\u003cp\u003e\u003ca href\u003d\"https://www.youtube.com/watch?v\u003dTTjAC1cr2sk\"\u003eYoutube link\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eBài Toán\u003c/h1\u003e\u003cp\u003eCho 2 xâu T (to) và S (small). Tìm tất cả các lần xuất hiện của xâu S trong xâu T.\u003c/p\u003e\u003cp\u003eVí dụ:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eT \u003d abcabcabc\nS \u003d abc\n\n--\u0026gt; res \u003d [1-3, 4-6, 7-9]\n\nT \u003d aaaaa\nS \u003d aa\n--\u0026gt; res \u003d [1-2, 2-3, 3-4, 4-5]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eChú ý:\u003c/p\u003e \u003cul\u003e   \u003cli\u003ecác lần xuất hiện của S có thể đè lên nhau.\u003c/li\u003e   \u003cli\u003eỞ đây mình đánh số mảng từ 1, do khi đánh số từ 1 thì chỉ số i cũng chính là độ dài từ đầu xâu đến vị trí i, nên tránh nhầm lẫn. Thông thường khi code mình thêm ký tự trống vào đầu xâu để đánh số từ 1.\u003c/li\u003e \u003c/ul\u003e\u003ch1\u003eBrute force\u003c/h1\u003e \u003cul\u003e   \u003cli\u003eĐặt \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLS\u003c/i\u003e \u003d \u003ci\u003elen\u003c/i\u003e(\u003ci\u003eS\u003c/i\u003e)\u003c/span\u003e là độ dài xâu S, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLT\u003c/i\u003e \u003d \u003ci\u003elen\u003c/i\u003e(\u003ci\u003eT\u003c/i\u003e)\u003c/span\u003e là độ dài xâu T.\u003c/li\u003e   \u003cli\u003eTa dễ dàng có thuật toán trâu bò với độ phức tạp \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eLS\u003c/i\u003e * \u003ci\u003eLT\u003c/i\u003e)\u003c/span\u003e như sau:   \u003cul\u003e     \u003cli\u003eLần lượt kiểm tra các đoạn gồm \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLS\u003c/i\u003e\u003c/span\u003e ký tự liên tiếp trên xâu \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e xem có khớp với xâu \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e không.\u003c/li\u003e   \u003c/ul\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eVí dụ:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eT \u003d \u0026quot;abcabc\u0026quot;\nS \u003d \u0026quot;abc\u0026quot;\n\n// --\u0026gt; ta check 4 phát: (mỗi phát mất độ dài xâu S)\n\n// Phát 1 check đoạn 1-3\n// Phát 2 check đoạn 2-4\n// Phát 3 check đoạn 3-5\n// Phát 4 check đoạn 4-6\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRõ ràng ta thấy phát nào cũng phải check mất tối đa \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLS\u003c/i\u003e\u003c/span\u003e phép so sánh nên bị lợn.\u003c/p\u003e \u003cul\u003e   \u003cli\u003eChú ý rằng nếu ký tự đầu tiên đã khác nhau thì ta chỉ mất 1 lần kiểm tra, thấy khác nhau và ko cần kiểm tra nữa\u003c/li\u003e   \u003cli\u003eNếu ở 1 lượt check mà khớp được nhiều ký tự, thì ở lượt check sau ta đã có thêm 1 số thông tin, và không cần check lại từ đầu. Bản chất của KMP là tận dụng những thông tin ở lượt check trước để giảm độ phức tạp.\u003c/li\u003e \u003c/ul\u003e\u003ch1\u003eMảng Next\u003c/h1\u003e\u003cp\u003eTrong KMP, khái niệm quan trọng nhất là mảng next. Mảng next được xây dựng trên xâu \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e, và cho ta 1 số thông tin về xâu S, để khi tìm xâu S trong xâu T, ta có thể nhảy cóc 1 số phép so sánh.\u003c/p\u003e\u003cp\u003eĐịnh nghĩa:\u003c/p\u003e\u003cp\u003eĐặt \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e1..\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e là xâu gồm các ký tự \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e1..\u003ci\u003eS\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enext\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e \u003d độ dài của substring dài nhất của \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e1..\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, ngắn hơn \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e1..\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, mà vừa là tiền tố, vừa là hậu tố của \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e1..\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eVí dụ:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eS \u003d abcabc\nnext \u003d 0 0 0 1 2 3\n\nS \u003d aaaaa\nnext \u003d 0 1 2 3 4\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eĐể tính mảng next, ta quy hoạch động như sau:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor(int i \u003d 1; i \u0026lt;\u003d LS; ++i) {\n    if (i \u003d\u003d 1) {\n        next[i] \u003d 0; // S[1..1] --\u0026gt; không có xâu nào vừa là tiền tố vừa là hậu tố.\n    }\n    else {\n        int j \u003d next[i-1];\n        while (j \u0026gt;\u003d 1 \u0026amp;\u0026amp; s[i] !\u003d s[j+1]) j \u003d next[j];\n        if (s[i] \u003d\u003d s[j+1]) ++j;\n        next[i] \u003d j;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eViệc tính mảng next này là \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e. Chứng minh:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eMỗi lần, j tăng lên tối đa 1 đơn vị. Như vậy tổng số lần tăng j không quá \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eMỗi lần \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e \u003d \u003ci\u003enext\u003c/i\u003e(\u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e thì j giảm đi. Như vậy j cũng chỉ có thể giảm tối đa \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eNhư vậy độ phức tạp là O(N).\u003c/li\u003e \u003c/ul\u003e\u003ch1\u003eKMP\u003c/h1\u003e\u003cp\u003eSau khi có mảng next, ta nhận thấy là việc tìm các lần xuất hiện của S trong T cũng gần giống như việc tính mảng next:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e1 lần xuất hiện của S trong T tương đương với 1 prefix dài LS của S là 1 hậu tố của T1..j. Từ đó, ta thấy rằng việc code KMP giống hệt như tính mảng next:\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003eint j \u003d 0; // j \u003d số ký tự khớp\nfor(int i \u003d 1; i \u0026lt;\u003d LT; ++i) {\n    while (j \u0026gt;\u003d 1 \u0026amp;\u0026amp; t[i] !\u003d s[j+1]) j \u003d next[j];\n    if (t[i] \u003d\u003d s[j+1]) ++j;\n\n    if (j \u003d\u003d LS) {\n        // found match: i - LS + 1 --\u0026gt; i\n        j \u003d next[j] // cái này là kĩ năng cài đặt, để tránh lượt sau so sánh với s[j+1] thì bị lợn.\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}