{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1467692711,"rating":6,"authorHandle":"hiddentesla","modificationTimeSeconds":1467692711,"id":45889,"title":"\u003cp\u003eproving a greedy algorithm\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eshort problem statement:\u003c/p\u003e\u003cp\u003egiven N and K (2 \u0026lt;\u003d N,K \u0026lt;\u003d 8) and an array consisting of N distinct elements; in one move you can pick a block of K elements in the array and reverse the order, for example: if N \u003d 5 and K \u003d 3 and the array is [4 5 1 2 3], in one move you can make the array [1 5 4 2 3] or [4 2 1 5 3] or [4 5 3 2 1]. how many minimum number of moves is required to make the array sorted in ascending order?, if impossible, print -1.\u003c/p\u003e\u003cp\u003ei cant give a link to the problem, because its in my native languange\u0027s, so i thought of a greedy algorithm:\u003c/p\u003e\u003cp\u003efor each i, find the i\u0027th smallest element and perform BFS until that element is in the i\u0027th position\u003c/p\u003e\u003cp\u003emy implementation: \u003ca href\u003d\"https://ideone.com/3x2vwP\"\u003ehttps://ideone.com/3x2vwP\u003c/a\u003e\u003c/p\u003e\u003cp\u003ehowever, it seems that this greedy algorithm do not always work, but im having troubles finding a counter case, can someone provide me one?\u003c/p\u003e\u003cp\u003enote: since the constraints are very low, i did a full frontal BFS and got AC: \u003ca href\u003d\"https://ideone.com/SYJklC\"\u003ehttps://ideone.com/SYJklC\u003c/a\u003e . but im still curious...\u003c/p\u003e\u003c/div\u003e","tags":["bfs","greedy"]}}