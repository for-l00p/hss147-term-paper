{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1517824803,"rating":17,"authorHandle":"KokiYmgch","modificationTimeSeconds":1517824803,"id":57559,"title":"\u003cp\u003eAtcoder Petrozavodsk Contest 001 I. Simple APSP Problem\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eAtcoder Petrozavodsk Contest was held last Sunday, and I found \u0027problem I\u0027 really interesting. Let me share this problem and the way to get to the answer.\u003c/p\u003e\u003cp\u003eThis is written in Japanese too: \u003ca href\u003d\"http://www.learning-algorithms.com/entry/2018/02/05/160601\"\u003ehttp://www.learning-algorithms.com/entry/2018/02/05/160601\u003c/a\u003e\u003c/p\u003e\u003cp\u003eProblem: \u003ca href\u003d\"https://beta.atcoder.jp/contests/apc001/tasks/apc001_i\"\u003ehttps://beta.atcoder.jp/contests/apc001/tasks/apc001_i\u003c/a\u003e\u003c/p\u003e\u003cp\u003eSummary: There\u0027s an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eH\u003c/i\u003e\u003c/span\u003e × \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003c/span\u003e grid, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e squares of the grids are colored black, while the others white. Find the sum of the minimum distances of all the pairs of white squares. The distance here, is defined as the minimum steps by which you can move to the left, right, up, or down direction, and can\u0027t move to the black square. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eH\u003c/i\u003e, \u003ci\u003eW\u003c/i\u003e ≤ 1000000,  \u003ci\u003en\u003c/i\u003e ≤ 30\u003c/span\u003e\u003c/p\u003e\u003cp\u003eIf you have possibly, possibly, read my article on Hirschberg\u0027s Algorithm, this problem is not super difficult for you. A close idea is actually used.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/blog/entry/57512\"\u003ehttp://codeforces.com/blog/entry/57512\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst of all, let me vertically divide the grid into two grids, and consider the minimum distance between the two white squares, one of which is in the left grid, while the other is in the right grid. If the \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e columns nearest to the division are all colored white, \u003cstrong\u003egiven that this path is the minimum path, there must be a position which the path goes through exactly once.\u003c/strong\u003e This means that you can calculate the number of times that all the paths which go through this division, independently, and then contract the \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e columns into \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e column. The value is the product of the numbers of white squares in each grid.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/bb/5f/bb5f55bae808408ec04f291d84a2698427246e30.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eYou can make the grid smaller and smaller by repeating this process, and thanks to the restriction, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≤ 30\u003c/span\u003e, the grid is going to be very small \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e × \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e grid.\u003c/p\u003e\u003cp\u003eNow, you can do simple \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eBFS\u003c/i\u003e\u003c/span\u003e in this new grid, but wait, you need to check the weight of each grid.\u003c/p\u003e\u003cp\u003eSuppose you contract the following grid:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/c7/b4/c7b4c67c574752b7be10c483915cd816ba9a207d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eOf course you need to check how many squares are actually hidden in each grid! Thus, the weight of each grid is going to be like this:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/4c/89/4c891fa496fbeb401654682db6f1566ff1e37155.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThis is easily calculated by seeing columns and rows independently.\u003c/p\u003e\u003cp\u003eOn the contracted grid, the minimum distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e between a white square \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e(weight \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e) and another white square \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e(weight \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e) is, the minimum distance between all the squares included in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and all the squares included in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e, before the contraction, therefore, you need to calculate the sum of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e * \u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e * \u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e for all the pairs in the contracted grid. This works effectively enough, in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e)\u003c/span\u003e. If you counted all the paths twice, be careful not to forget to halve the value. Finally, the sum of this value and the pre-calculated value is the answer to this problem.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;functional\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;queue\u0026gt;\nusing namespace std;\n\nconst int MOD \u003d 1e9 + 7;\n\nstruct state { int y, x, step; };\nstatic const int dx[] \u003d {1, 0, -1, 0}, dy[] \u003d {0, 1, 0, -1};\n\nint main() {\n        long long h, w;\n        scanf(\u0026quot;%lld %lld\u0026quot;, \u0026amp;h, \u0026amp;w);\n        int n;\n        scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n        vector\u0026lt;int\u0026gt; w_cnt(w, 0), h_cnt(h, 0);\n        vector\u0026lt;bool\u0026gt; w_exist(w, false), h_exist(h, false);\n        vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; black;\n        for (int i \u003d 0; i \u0026lt; n; i ++) {\n                int y, x;\n                scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;y, \u0026amp;x);\n                w_cnt[x] ++;\n                h_cnt[y] ++;\n                w_exist[x] \u003d true;\n                h_exist[y] \u003d true;\n                black.emplace_back(x, y);\n        }\n        for (int i \u003d 1; i \u0026lt; w; i ++) w_cnt[i] +\u003d w_cnt[i - 1];\n        for (int i \u003d 1; i \u0026lt; h; i ++) h_cnt[i] +\u003d h_cnt[i - 1];\n        long long ans \u003d 0;\n        //precalc\n        for (int i \u003d 0; i \u0026lt; w - 1; i ++) {\n                if (!w_exist[i] \u0026amp;\u0026amp; !w_exist[i + 1]) {\n                        long long left \u003d (long long) (i + 1) * h % MOD - w_cnt[i];\n                        long long right \u003d (long long) (w - (i + 1)) * h % MOD - (n - w_cnt[i]);\n                        ans +\u003d left * right;\n                        ans %\u003d MOD;\n                }\n        }\n        for (int i \u003d 0; i \u0026lt; h - 1; i ++) {\n                if (!h_exist[i] \u0026amp;\u0026amp; !h_exist[i + 1]) {\n                        long long left \u003d (long long) (i + 1) * w % MOD - h_cnt[i];\n                        long long right \u003d (long long) (h - (i + 1)) * w % MOD - (n - h_cnt[i]);\n                        ans +\u003d left * right;\n                        ans %\u003d MOD;\n                }\n        }\n        //compress\n        map\u0026lt;int, int\u0026gt; newx, newy;\n        vector\u0026lt;pair\u0026lt;long long, bool\u0026gt;\u0026gt; widths, heights; //(length, is_white)\n        {\n                int cnt \u003d 0;\n                for (int i \u003d 0; i \u0026lt; w; i ++) {\n                        if (!w_exist[i]) {\n                                cnt ++;\n                        } else {\n                                if (cnt) {\n                                        widths.emplace_back(cnt, true);\n                                        cnt \u003d 0;\n                                }\n                                newx[i] \u003d (int) widths.size();\n                                widths.emplace_back(1, false);\n                        }\n                }\n                if (cnt) widths.emplace_back(cnt, true);\n        }\n        {\n                int cnt \u003d 0;\n                for (int i \u003d 0; i \u0026lt; h; i ++) {\n                        if (!h_exist[i]) {\n                                cnt ++;\n                        } else {\n                                if (cnt) {\n                                        heights.emplace_back(cnt, true);\n                                        cnt \u003d 0;\n                                }\n                                newy[i] \u003d (int) heights.size();\n                                heights.emplace_back(1, false);\n                        }\n                }\n                if (cnt) heights.emplace_back(cnt, true);\n        }\n        //re-write the grid\n        int neww \u003d (int) widths.size();\n        int newh \u003d (int) heights.size();\n        vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; s(newh, vector\u0026lt;long long\u0026gt; (neww, 1)); //-1 when it\u0027s black, weight when it\u0027s white\n        for (auto b : black) {\n                s[newy[b.second]][newx[b.first]] \u003d -1;\n        }\n        for (int i \u003d 0; i \u0026lt; newh; i ++) {\n                for (int j \u003d 0; j \u0026lt; neww; j ++) {\n                        if (heights[i].second || widths[j].second) {\n                                s[i][j] \u003d heights[i].first * widths[j].first % MOD;\n                        }\n                }\n        }\n        for (int i \u003d 0; i \u0026lt; newh; i ++) {\n                for (int j \u003d 0; j \u0026lt; neww; j ++) {\n                        cerr \u0026lt;\u0026lt; s[i][j] \u0026lt;\u0026lt; \u0027 \u0027;\n                }\n                cerr \u0026lt;\u0026lt; endl;\n        }\n        //BFS\n        long long sum \u003d 0;\n        for (int sy \u003d 0; sy \u0026lt; newh; sy ++) {\n                for (int sx \u003d 0; sx \u0026lt; neww; sx ++) {\n                        if (s[sy][sx] \u003d\u003d -1) continue;\n                        long long res \u003d s[sy][sx];\n                        vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; used(newh, vector\u0026lt;bool\u0026gt;(neww, false));\n                        queue\u0026lt;state\u0026gt; q;\n                        q.push({sy, sx, 0});\n                        used[sy][sx] \u003d true;\n                        while (!q.empty()) {\n                                state p \u003d q.front(); q.pop();\n                                if (p.y !\u003d sy || p.x !\u003d sx) {\n                                        assert(s[p.y][p.x] !\u003d -1);\n                                        sum +\u003d (long long) p.step * res % MOD * s[p.y][p.x] % MOD;\n                                        sum %\u003d MOD;\n                                }\n                                for (int d \u003d 0; d \u0026lt; 4; d ++) {\n                                        int xx \u003d p.x + dx[d], yy \u003d p.y + dy[d];\n                                        if (xx \u0026lt; 0 || xx \u0026gt;\u003d neww || yy \u0026lt; 0 || yy \u0026gt;\u003d newh) continue;\n                                        if (used[yy][xx] || s[yy][xx] \u003d\u003d -1) continue;\n                                        used[yy][xx] \u003d true;\n                                        q.push({yy, xx, p.step + 1});\n                                }\n                        }\n                }\n        }\n        sum *\u003d (MOD + 1) / 2;\n        sum %\u003d MOD;\n        ans +\u003d sum;\n        ans %\u003d MOD;\n        printf(\u0026quot;%lld\\n\u0026quot;, ans);\n        return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["atcoder"]}}