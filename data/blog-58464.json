{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1521478365,"rating":0,"authorHandle":"laderlappen","modificationTimeSeconds":1523407252,"id":58464,"title":"\u003cp\u003eDynamic Programming — Basic Techniques\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eDynamic Programming — Basic Techniques\u003c/h1\u003e\u003cp\u003eIn competitive programming, it is very common such situations that you want to solve a problem by solving some subproblems of it. The divide-and-conquer is essentially this idea. Actually, humans are very used to this concept: Imagine that you have some task to do, but this task requires some subtasks to be solved. You have to solve them first and then conclude your main task afterwards.\u003c/p\u003e\u003cp\u003eLet me give you first some simple task: I\u0027ll give you a non-negative integer N, and then I\u0027ll ask the value of the N-th term of the Fibonacci\u0027s sequence (If you don\u0027t remember what it is, it\u0027s the sequence defined by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e \u003d 0,  \u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u003d 1,  \u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eN\u003c/i\u003e - 1\u003c/sub\u003e + \u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eN\u003c/i\u003e - 2\u003c/sub\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eIf you don\u0027t care about complexity, we can just solve it recursively:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint fib(int n) {\n    if(n \u0026lt;\u003d 1) return n;\n    return fib(n-1) + fib(n-2);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe diagram below shows the recursivity for this task:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/71/81/7181e8f70850ddcee20867c2967468eefd320a13.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eCan you see that there are lots of terms that are calculated lots of times? Actually the way I solved it above has exponential complexity. What I want to reach with this is the following: Many times when you use recursivity to solve some subproblems, you may have the problem of computing lots of cases lots of times. We can do it better than that.\u003c/p\u003e\u003cp\u003eThat\u0027s the purpose of Dynamic Programming. You try to avoid these recalculations. There are two ways to do it: We call them \u003cstrong\u003eMemoization\u003c/strong\u003e (or \u003cem\u003eTop-Down\u003c/em\u003e) and \u003cstrong\u003eTabulation\u003c/strong\u003e (or \u003cem\u003eBottom-Up\u003c/em\u003e)\u003c/p\u003e\u003ch2\u003eMemoization and Tabulation\u003c/h2\u003e\u003cp\u003eIn that fibonacci example, we could just solve our complexity problem by using this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint f[N]; // Set f[i] to -1 for every i\nint fib(int n) {\n    if(~f[n]) return f[n]; // if f[n] !\u003d -1, then just return the value of f[n]\n                           // because it\u0027s already been calculated.\n\n    if(n \u0026lt;\u003d 1) return f[n] \u003d n;\n    return fib(n-1) + fib(n-2);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo, if we call some term that has already been calculated, then we can just return the value instead of computing it all again! We are \u0026quot;remembering\u0026quot; the values using extra memory. Because of this \u0026quot;memory\u0026quot; property, we call this approach \u003cstrong\u003eMemoization\u003c/strong\u003e (from latin \u0026quot;memorandum\u0026quot;) or \u003cem\u003eTop-Down\u003c/em\u003e. We just remove the \u0027r\u0027 from \u0026quot;Memorization\u0026quot; to make this word special for Computer Science.\u003c/p\u003e\u003cp\u003eAlso, you can choose to ignore that first approach and say: \u0026quot;Well, I\u0027m just going to store all the elements of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e in an array and compute them one by one from the first to the last one\u0026quot;. Yeah, that\u0027s another approach and it\u0027s actually very similar:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint f[N]; // Set f[i] to -1 for every i\n\nf[0] \u003d 0, f[1] \u003d 1;\nfor(int i\u003d2; i\u0026lt;\u003dn; i++) {\n    f[i] \u003d f[i-1] + f[i-2];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEven though the two approaches solve the problem in fact, can you see that they\u0027re kinda different? The first one gets the term using recursivity (like you ask the subproblems in a \u003cem\u003eTop-Down\u003c/em\u003e order), and the second builds the sequence from bottom until it reaches the term (you\u0027re using the subproblems to build the problem in a \u003cem\u003eBottom-Up\u003c/em\u003e order). This second approach looks like creating a table (in this case, an array) to get the answer. That\u0027s why the name of this approach is \u003cstrong\u003eTabulation\u003c/strong\u003e, or \u003cem\u003eBottom-Up\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eSo, what should I use for solving problems? Sometimes it\u0027s easier to model the solution using memoization, sometimes it\u0027s not. Actually it\u0027s really important to know how to use them properly. I can tell you that because of low-level terms the tabulation is faster (less overhead of recursive calls, cache-friendly, etc).\u003c/p\u003e\u003ch2\u003eApplications\u003c/h2\u003e\u003ch3\u003eLongest Common Subsequence (LCS)\u003c/h3\u003e\u003cp\u003eLet me give you a problem: Imagine that you have two sequences \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e \u003d {\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e}\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e \u003d {\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e, ..., \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e}\u003c/span\u003e. I ask you to compute the length of the longest common subsequence of them. \u003c/p\u003e\u003cp\u003eJust to remind you, we call that a subsequence of a sequence appears in the same relative order, but not necessarily contiguously. For example: \u0026quot;1, 2, 3\u0026quot; and \u0026quot;1, 4, 2\u0026quot; are subsequences of \u0026quot;1, 4, 2, 5, 6, 3\u0026quot;.\u003c/p\u003e\u003cp\u003eSo, let\u0027s have some examples here:\u003c/p\u003e\u003cp\u003eLCS of \u003cstrong\u003e\u0026quot;1, 2, 1, 2, 3, 3, 4\u0026quot;\u003c/strong\u003e and \u003cstrong\u003e\u0026quot;1, 2, 1, 2\u0026quot;\u003c/strong\u003e is \u003cstrong\u003e4\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eLCS of \u003cstrong\u003e\u0026quot;1, 2, 1, 2, 3, 3, 4\u0026quot;\u003c/strong\u003e and \u003cstrong\u003e\u0026quot;1, 3, 5, 4\u0026quot;\u003c/strong\u003e is \u003cstrong\u003e3\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eLCS of \u003cstrong\u003e\u0026quot;1, 2, 1, 2, 3, 3, 4\u0026quot;\u003c/strong\u003e and \u003cstrong\u003e\u0026quot;2, 3, 1\u0026quot;\u003c/strong\u003e is \u003cstrong\u003e2\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eOne of the ideas you can get is looking at the last element of the two sequences. If they\u0027re equal, then the answer is \u003cspan class\u003d\"tex-span\"\u003e1 + \u003ci\u003eLCS\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1...\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e, \u003ci\u003eB\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1...\u003ci\u003em\u003c/i\u003e - 1\u003c/sub\u003e)\u003c/span\u003e, i.e. the answer is the lcs of their prefixes without the last terms and +1 because of this term. If not, then you can \u0026quot;discard\u0026quot; one of these two last terms and check the remaining sequences, the answer in this case will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(\u003ci\u003eLCS\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1...\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eB\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1...\u003ci\u003em\u003c/i\u003e - 1\u003c/sub\u003e), \u003ci\u003eLCS\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1...\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e, \u003ci\u003eB\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1...\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e. Since we got a recurrence here, we just need to keep these states in memory so we can get the answer.\u003c/p\u003e\u003cp\u003eThe recurrence is:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e][\u003ci\u003em\u003c/i\u003e] \u003d 1 +  \u003ci\u003edp\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e - 1][\u003ci\u003em\u003c/i\u003e - 1],  \u003ci\u003eifa\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e] \u003d \u003ci\u003eb\u003c/i\u003e[\u003ci\u003em\u003c/i\u003e]\u003c/span\u003e \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e][\u003ci\u003em\u003c/i\u003e] \u003d \u003ci\u003emax\u003c/i\u003e( \u003ci\u003edp\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e - 1][\u003ci\u003em\u003c/i\u003e], \u003ci\u003edp\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e][\u003ci\u003em\u003c/i\u003e - 1] )),  \u003ci\u003eotherwise\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eUsing memoization:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint dp[N][N], a[N], b[N];\nint lcs(int n, int m) {\n    if(~dp[n][m]) return dp[n][m];\n    if(n \u003d\u003d 0 or m \u003d\u003d 0) return dp[n][m] \u003d 0;\n\n    if(a[n] \u003d\u003d b[m]) return dp[n][m] \u003d 1 + lcs(n-1, m-1);\n    else return dp[n][m] \u003d max(lcs(n-1, m), lcs(n, m-1));\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eLongest Increasing Subsequence (LIS)\u003c/h3\u003e\u003cp\u003eThe Longest Increasing Subsequence (LIS) is kinda similar: Given a sequence \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e \u003d {\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e}\u003c/span\u003e, I want you to give the length of the longest subsequence that is increasing. Subsequence means the same as in LCS problem, and by increasing we are saying that the terms are in ascending order (if the subsequence is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e \u003d {\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e}\u003c/span\u003e we have that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e \u0026lt; \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/dc/3a/dc3aaa46592fbc7467073c367e9efc7c78b2a3f0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f5/ff/f5ff552dad34d2818eab6aa7159831e49d583954.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e).\u003c/p\u003e\u003ch4\u003eO(N²)\u003c/h4\u003e\u003cp\u003eThis approach reveals why it\u0027s somehow similar to LCS: Let B be the sorted sequence of A. Can we say that the answer is the LCS of A and B?\u003c/p\u003e\u003cp\u003eActually not. We\u0027re almost there: Let me give you this example: If A is \u003cstrong\u003e\u0026quot;1, 2, 2, 3, 4, 3\u0026quot;\u003c/strong\u003e, then the length of the LIS of A is 4 (We can have the subsequence \u0026quot;1, 2, 3, 4\u0026quot;, for example), but then B is \u003cstrong\u003e\u0026quot;1, 2, 2, 3, 3, 4\u0026quot;\u003c/strong\u003e, and the length of the LCS of A and B is 5 (The subsequence \u0026quot;1, 2, 2, 3, 4\u0026quot; is one of the LCS, for example). The difference here is that we\u0027re computing the length of the Longest \u003cstrong\u003eNon-decreasing\u003c/strong\u003e Subsequence.\u003c/p\u003e\u003cp\u003eTo solve this issue, we need to deal with repeated terms. A way to handle this is to keep a second term with the indexes of the terms, so you can sort by increasing first and decreasing second.\u003c/p\u003e\u003cp\u003eAn example of code:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// A and B are, in this case, array of pairs.\nfor(int i\u003d0; i\u0026lt;n; i++) {\n    a[i].second \u003d b[i].second \u003d i;\n    b[i].first \u003d a[i].first;\n}\nsort(b, b+n, [](ii i, ii j){ return i.first \u003d\u003d j.first ? i.second \u0026gt; j.second : i.first \u0026lt; j.first; });\n// Call LCS\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnother (and simpler) way to solve it is sorting and make the terms unique. (Just call sort() and unique())\u003c/p\u003e\u003cp\u003eNow I ask you: Can we do it better?\u003c/p\u003e\u003ch4\u003eO(NlogN)\u003c/h4\u003e\u003cp\u003eOf course.\u003c/p\u003e\u003cp\u003eWe can use the property that the sequence is increasing to make a better approach. We will keep an array M[] in memory such that M[i] is the smallest element that can be the last term of a increasing subsequence of i elements. Having this array we can update its values iterating through the array.\u003c/p\u003e\u003cp\u003eLet me give you an example: What\u0027s the length of the LIS of \u003cstrong\u003e\u0026quot;1, 2, 4, 3, 9, 1, 6, 8\u0026quot;\u003c/strong\u003e ?\u003c/p\u003e\u003cp\u003eLet\u0027s do it step by step:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eFirst element: A[0] \u003d 1.\u003c/strong\u003e\u003cbr /\u003eIncreasing subsequence of 1 element: \u003cstrong\u003e1\u003c/strong\u003e.\u003cbr /\u003eM \u003d {1}\u003c/p\u003e\u003cp\u003eSecond element: A[1] \u003d 2.\u003cbr /\u003eIncreasing subsequence of 1 element: \u003cstrong\u003e1\u003c/strong\u003e.\u003cbr /\u003eIncreasing subsequence of 2 elements: 1, \u003cstrong\u003e2\u003c/strong\u003e.\u003cbr /\u003eM \u003d {1, 2}\u003c/p\u003e\u003cp\u003eThird element: A[2] \u003d 4.\u003cbr /\u003eIncreasing subsequence of 1 element: \u003cstrong\u003e1\u003c/strong\u003e.\u003cbr /\u003eIncreasing subsequence of 2 elements: 1, \u003cstrong\u003e2\u003c/strong\u003e.\u003cbr /\u003eIncreasing subsequence of 3 elements: 1, 2, \u003cstrong\u003e4\u003c/strong\u003e.\u003cbr /\u003eM \u003d {1, 2, 4}\u003c/p\u003e\u003cp\u003eFourth element: A[3] \u003d 3.\u003cbr /\u003eIncreasing subsequence of 1 element: \u003cstrong\u003e1\u003c/strong\u003e.\u003cbr /\u003eIncreasing subsequence of 2 elements: 1, \u003cstrong\u003e2\u003c/strong\u003e.\u003cbr /\u003eIncreasing subsequence of 3 elements: 1, 2, \u003cstrong\u003e3\u003c/strong\u003e.\u003cbr /\u003e\u003cs\u003eIncreasing subsequence of 3 elements: 1, 2, \u003cstrong\u003e4\u003c/strong\u003e.\u003c/s\u003e\u003cbr /\u003eM \u003d {1, 2, 3}\u003c/p\u003e\u003cp\u003eFifth element: A[4] \u003d 9.\u003cbr /\u003eIncreasing subsequence of 1 element: \u003cstrong\u003e1\u003c/strong\u003e.\u003cbr /\u003eIncreasing subsequence of 2 elements: 1, \u003cstrong\u003e2\u003c/strong\u003e.\u003cbr /\u003eIncreasing subsequence of 3 elements: 1, 2, \u003cstrong\u003e3\u003c/strong\u003e.\u003cbr /\u003eIncreasing subsequence of 4 elements: 1, 2, 3, \u003cstrong\u003e9\u003c/strong\u003e.\u003cbr /\u003eM \u003d {1, 2, 3, 9}\u003c/p\u003e\u003cp\u003eSixth element: A[5] \u003d 1.\u003cbr /\u003eIncreasing subsequence of 1 element: \u003cstrong\u003e1\u003c/strong\u003e.\u003cbr /\u003e\u003cs\u003eIncreasing subsequence of 1 element: \u003cstrong\u003e1\u003c/strong\u003e.\u003c/s\u003e\u003cbr /\u003eIncreasing subsequence of 2 elements: 1, \u003cstrong\u003e2\u003c/strong\u003e.\u003cbr /\u003eIncreasing subsequence of 3 elements: 1, 2, \u003cstrong\u003e3\u003c/strong\u003e.\u003cbr /\u003eIncreasing subsequence of 4 elements: 1, 2, 3, \u003cstrong\u003e9\u003c/strong\u003e.\u003cbr /\u003eM \u003d {1, 2, 3, 9}\u003c/p\u003e\u003cp\u003eActually this step didn\u0027t change anything, but in fact it doesn\u0027t matter if we change it here or not.\u003c/p\u003e\u003cp\u003eSeventh element: A[6] \u003d 6.\u003cbr /\u003eIncreasing subsequence of 1 element: \u003cstrong\u003e1\u003c/strong\u003e.\u003cbr /\u003eIncreasing subsequence of 2 elements: 1, \u003cstrong\u003e2\u003c/strong\u003e.\u003cbr /\u003eIncreasing subsequence of 3 elements: 1, 2, \u003cstrong\u003e3\u003c/strong\u003e.\u003cbr /\u003eIncreasing subsequence of 4 elements: 1, 2, 3, \u003cstrong\u003e6\u003c/strong\u003e.\u003cbr /\u003e\u003cs\u003eIncreasing subsequence of 4 elements: 1, 2, 3, \u003cstrong\u003e9\u003c/strong\u003e.\u003c/s\u003e\u003cbr /\u003eM \u003d {1, 2, 3, 6}\u003c/p\u003e\u003cp\u003eEigth element: A[7] \u003d 8.\u003cbr /\u003eIncreasing subsequence of 1 element: \u003cstrong\u003e1\u003c/strong\u003e.\u003cbr /\u003eIncreasing subsequence of 2 elements: 1, \u003cstrong\u003e2\u003c/strong\u003e.\u003cbr /\u003eIncreasing subsequence of 3 elements: 1, 2, \u003cstrong\u003e3\u003c/strong\u003e.\u003cbr /\u003eIncreasing subsequence of 4 elements: 1, 2, 3, \u003cstrong\u003e6\u003c/strong\u003e.\u003cbr /\u003eIncreasing subsequence of 5 elements: 1, 2, 3, 6, \u003cstrong\u003e8\u003c/strong\u003e.\u003cbr /\u003eM \u003d {1, 2, 3, 6, 8}\u003c/p\u003e\u003cp\u003eAs you can see, the length of the LIS is 5.\u003c/p\u003e\u003cp\u003eOne important fact here is, as we realized in the example, we always look for the best length to put the element. I mean, we look for the longest subsequence such that the element can be a \u003cstrong\u003ebetter last element\u003c/strong\u003e. You may notice that, because of our insertion rules, M is necessarily increasing. Using this, we can find the position to insert an element by finding the lower_bound of the array.\u003c/p\u003e\u003cp\u003eAn example of code using tabulation is:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint dp[N]; // Make sure that it\u0027s set to large numbers at first\nint lis(vector\u0026lt;int\u0026gt; \u0026amp;v) {\n    int l \u003d 0, n \u003d v.size();\n    for(int i\u003d0; i\u0026lt;n; i++) {\n        int p \u003d lower_bound(dp, dp+l, v[i]) - dp;\n        dp[p] \u003d v[i]; l \u003d max(l, p+1);       \n    }\n    return l;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eEdit Distance\u003c/h3\u003e\u003cp\u003eAnother example: Suppose you have two strings A and B, and you can perform three kinds of operations on them:\u003c/p\u003e \u003col\u003e   \u003cli\u003eInsert a character in one of the strings\u003c/li\u003e   \u003cli\u003eErase a character in one of the strings\u003c/li\u003e   \u003cli\u003eReplace a character in one of the strings to any other character.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eThe problem is: What is the minimal number of operations that I need to do to turn A into B, or vice-versa?\u003c/p\u003e\u003cp\u003eFor example:\u003cbr /\u003eIf A \u003d \u0026quot;laderlappen\u0026quot; and B \u003d \u0026quot;laderlapen\u0026quot;, the answer is 1. Just erase one of the p\u0027s in A or insert one more p in B.\u003cbr /\u003eIf A \u003d \u0026quot;laderlappen\u0026quot; and B \u003d \u0026quot;ladd\u0026quot;, the answer is 8. Replace the first \u0027e\u0027 to \u0027d\u0027 and erase all the rest.\u003cbr /\u003eIf A \u003d \u0026quot;laded\u0026quot; and B \u003d \u0026quot;led\u0026quot;, the answer is 2. Erase the \u0027a\u0027 and the first \u0027d\u0027.\u003c/p\u003e\u003cp\u003eFirst of all, you may have already noticed that, in optimal strategy, inserting an element in A is used to build a character in A that will correspond to some character in B, which is the same as erasing that element in B. So we can still find the minimal answer using only erases and replaces.\u003c/p\u003e\u003cp\u003eSince it doesn\u0027t matter in what order we use the operations, We can perform them from the right to the left.\u003c/p\u003e\u003cp\u003eImagine that A has n elements, and B has m elements.\u003cbr /\u003e- If the last elements of A and B are equal, we can just ignore them and solve for the rest of the strings, calling the subproblem that A has n-1 elements and B has m-1 elements.\u003cbr /\u003e- If they\u0027re different, we need to turn one into another, using the operations remove or replace:\u003cbr /\u003e — If we remove the element from A, we\u0027re in the subproblem that A has n-1 elements and B has m elements.\u003cbr /\u003e — If we remove from B, we\u0027re in the subproblem that A has n elements and B has m-1 elements.\u003cbr /\u003e — If we replace one of them into the other (it doesn\u0027t matter what will be replaced), we\u0027re in the subproblem that A has n-1 elements and B has m-1 elements.\u003c/p\u003e\u003cp\u003eSo the recurrence is: \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e][\u003ci\u003em\u003c/i\u003e] \u003d \u003ci\u003edp\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e - 1][\u003ci\u003em\u003c/i\u003e - 1],  \u003ci\u003eif\u003c/i\u003e \u003ci\u003ea\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e] \u003d \u003ci\u003eb\u003c/i\u003e[\u003ci\u003em\u003c/i\u003e]\u003c/span\u003e \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e][\u003ci\u003em\u003c/i\u003e] \u003d 1 + \u003ci\u003emin\u003c/i\u003e{ \u003ci\u003edp\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e - 1][\u003ci\u003em\u003c/i\u003e],  \u003ci\u003edp\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e - 1][\u003ci\u003em\u003c/i\u003e - 1],  \u003ci\u003edp\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e][\u003ci\u003em\u003c/i\u003e - 1] },  \u003ci\u003eotherwise\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003ePutting this idea into code and using memoization, we have:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint dp[N][N]; // Set initially to -1 to use memoization properly\nstring a, b;\n\n// Edit Distance: 0-indexed.\nint edist(int n, int m) {\n    if(~dp[n][m]) return dp[n][m]; // Memoization\n    if(n \u003d\u003d 0 or m \u003d\u003d 0) return dp[n][m] \u003d max(n, m);\n    if(a[n-1] \u003d\u003d b[m-1]) return dp[n][m] \u003d edist[n-1][m-1];\n    else {\n        int rema \u003d edist(n-1, m);\n        int remb \u003d edist(n, m-1);\n        int repl \u003d edist(n-1, m-1);\n        return dp[n][m] \u003d 1 + min({rema, remb, repl}); // C++11.\n        // You can use min(rema, min(remb, repl)) too.\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eKnapsack\u003c/h2\u003e\u003cp\u003eThis problem is amazing. At first I had only the classical problem (0-1) in my mind, and I didn\u0027t think that there would be so many variations of it. Here I\u0027ll just talk about the classical problem (0-1 Knapsack) and let \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/naumazeredo\" title\u003d\"Expert naumazeredo\"\u003enaumazeredo\u003c/a\u003e take care of the variations of it in a future not so distant.\u003c/p\u003e\u003cp\u003eThe problem: Suppose you have N items, the i-th one has a weight w[i] and a value v[i]. You have a Knapsack that has weight capacity M. I ask you what is the largest sum of values we can carry in the Knapsack.\u003c/p\u003e\u003cp\u003eYou may ask why Greedy approaches doesn\u0027t work here. It\u0027s not that hard to give counter examples for these kind of approaches, and maybe thinking about some greedies will be a great mess.\u003c/p\u003e\u003cp\u003eLet\u0027s see if we can find some Dynamic Programming here: It turns out that, if we have a non-empty subset S of items and a knapsack with capacity T, we can take one of the items in this subset (Call it P, let\u0027s suppose it\u0027s the p-th element) and then the best answer for this subset is the answer for the subset \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e - {\u003ci\u003eP\u003c/i\u003e}\u003c/span\u003e with capacity T (if we doesn\u0027t take P into the knapsack) or v[p] + the answer for the subset \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e - {\u003ci\u003eP\u003c/i\u003e}\u003c/span\u003e with capacity T — w[p] (if we take it).\u003c/p\u003e\u003cp\u003eSo we can find a dynamic programming using two states: 1. \u003cstrong\u003et\u003c/strong\u003e, which means the capacity of the knapsack is T 2. \u003cstrong\u003ei\u003c/strong\u003e, which means we\u0027re considering just the first I elements\u003c/p\u003e\u003cp\u003eAnd the recurrence is:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003et\u003c/i\u003e] \u003d \u003ci\u003emax\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e - 1][\u003ci\u003et\u003c/i\u003e],  \u003ci\u003ev\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]  +  \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e - 1][\u003ci\u003et\u003c/i\u003e - \u003ci\u003ew\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]])\u003c/span\u003e\u003c/p\u003e\u003cp\u003ei.e if we take the i-th element in the knapsack or not. Here is some example of code using tabulation:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint dp[N][M]; // n \u003d number of elements, t \u003d capacity of the knapsack\nint w[N], v[N]; // weight and value, respectively.\n\nfor(int i\u003d0; i\u0026lt;n; i++) {\n    for(int j\u003d0; j\u0026lt;\u003dt; j++) {\n        if(i \u003d\u003d 0) dp[i][j] \u003d (w[i] \u0026lt;\u003d j ? v[i] : 0);\n        else {\n            dp[i][j] \u003d dp[i-1][j];\n            if(w[i] \u0026lt;\u003d j) {\n                dp[i][j] \u003d max(dp[i][j], v[i] + dp[i-1][j-w[i]]);\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}