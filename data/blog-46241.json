{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1469328156,"rating":0,"authorHandle":"ayushexel","modificationTimeSeconds":1469341818,"id":46241,"title":"\u003cp\u003eQuery regrading SPOJ MBALL \u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eproblem link : \u003ca href\u003d\"http://www.spoj.com/problems/MBALL/\"\u003ehttp://www.spoj.com/problems/MBALL/\u003c/a\u003e\u003c/p\u003e\u003cp\u003emy solution : \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;memory.h\u0026gt;\nusing namespace std;\n\nlong long dp[100002][6];\n\nlong long solve(long long b,long long c){\nif(b\u003d\u003d0)\nreturn 1;\nif(b\u0026lt;0||c\u003d\u003d5)\nreturn 0;\nif(dp[b][c]!\u003d-1){\nreturn dp[b][c];\n}\nlong long ret \u003d 0;\nif(c\u0026lt;\u003d0){\nfor(long long i\u003d2;i\u0026lt;\u003db;i+\u003d2)\nret +\u003d solve(b-i,1);\n}\n\nif(c\u0026lt;\u003d1){\nfor(long long i\u003d3;i\u0026lt;\u003db;i+\u003d3)\nret +\u003d solve(b-i,2);\n}\n\nif(c\u0026lt;\u003d2){\nfor(long long i\u003d6;i\u0026lt;\u003db;i+\u003d6){\nret +\u003d solve(b-i,3);\n}\n}\n\nif(c\u0026lt;\u003d3){\nfor(long long i\u003d7;i\u0026lt;\u003db;i+\u003d7){\nret +\u003d solve(b-i,4);\n}\n}\n\nif(c\u0026lt;\u003d4){\nfor(long long i\u003d8;i\u0026lt;\u003db;i+\u003d8){\nret +\u003d solve(b-i,5);\n}\n}\n\nreturn dp[b][c] \u003d ret;\n}\n\nint main()\n{\nint n;\ncin\u0026gt;\u0026gt;n;\nmemset(dp,-1,sizeof(dp));\nwhile(n--){\n\nint s;\ncin\u0026gt;\u0026gt;s;\ncout \u0026lt;\u0026lt; solve(s,0) \u0026lt;\u0026lt; endl;\n}\nreturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe code is working fine but on submitting i\u0027m getting \u0026quot;time limit exceeded\u0026quot; error . I don\u0027t want to use iterative approach . So, how can the time limit be reduced without using iterative DP ?\u003c/p\u003e\u003c/div\u003e","tags":["#algorithms","dynamic programming","recursion","spoj"]}}