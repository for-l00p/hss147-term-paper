{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1432980945,"rating":156,"authorHandle":"misof","modificationTimeSeconds":1432986213,"id":18222,"title":"\u003cp\u003eYandex Algo 2015 (cancelled) round 2 editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello :)\u003c/p\u003e\u003cp\u003eI was the writer for the Round 2. I\u0027m very sad that the contest platform failed and you couldn\u0027t do your best solving them -- for me it\u0027s also sad as my work on the problems is now wasted. Hopefully you liked the problems themselves.\u003c/p\u003e\u003cp\u003eHere are the problem statements:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eA \u003ca href\u003d\"http://pastebin.com/raw.php?i\u003dU8SfbSL8\"\u003ehttp://pastebin.com/raw.php?i\u003dU8SfbSL8\u003c/a\u003e\u003c/li\u003e   \u003cli\u003eB \u003ca href\u003d\"http://pastebin.com/raw.php?i\u003dbAi07eMm\"\u003ehttp://pastebin.com/raw.php?i\u003dbAi07eMm\u003c/a\u003e\u003c/li\u003e   \u003cli\u003eC \u003ca href\u003d\"http://pastebin.com/raw.php?i\u003dR72vqKkk\"\u003ehttp://pastebin.com/raw.php?i\u003dR72vqKkk\u003c/a\u003e\u003c/li\u003e   \u003cli\u003eD \u003ca href\u003d\"http://pastebin.com/raw.php?i\u003dAr5CmJ8j\"\u003ehttp://pastebin.com/raw.php?i\u003dAr5CmJ8j\u003c/a\u003e\u003c/li\u003e   \u003cli\u003eE \u003ca href\u003d\"http://pastebin.com/raw.php?i\u003dwiCtb0ab\"\u003ehttp://pastebin.com/raw.php?i\u003dwiCtb0ab\u003c/a\u003e\u003c/li\u003e   \u003cli\u003eF \u003ca href\u003d\"http://pastebin.com/raw.php?i\u003diaMnb9cs\"\u003ehttp://pastebin.com/raw.php?i\u003diaMnb9cs\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eAnd below are brief solution ideas. Ask if anything is unclear.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eA (ascending the stairs)\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eDynamic programming in O(n).\u003c/p\u003e\u003cp\u003eLet W[x] be the number of ways to climb the first x steps of the stairs. (We will call that \u0026quot;state x\u0026quot;.)\u003c/p\u003e\u003cp\u003eW[n] is the answer we want.\u003c/p\u003e\u003cp\u003eFor each x, let y be the lowest state that we can go directly from state y to state x -- i.e., the sum H[y]+...+H[x-1] is still \u0026lt;\u003d m. Then W[x] is simply the sum of W[y] through W[x-1].\u003c/p\u003e\u003cp\u003eUsing two pointers, we can find the right y for each x in linear time. We can also maintain the sum of the Ws that corresponds to the current y and x.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eB (back to the start)\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eCompress the coordinates. Then, realize that the optimal curve never has to pass through a corner of the unit square grid (we can always go around it on either side -- if the corner is available, so are the four sides that meet there). Thus we can turn this continuous problem into a discrete one and solve it using BFS. Consider the unit squares around the curve. Build a graph where two unit squares are adjacent iff they share a side and the curve doesn\u0027t use that side. Then, start the BFS from all four unit squares adjacent to the start and check whether you can reach at least one of the four squares adjacent to the end.\u003c/p\u003e\u003cp\u003eGenerating good test data for this is a lot of fun :)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eC (candy game)\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThis is known as mis√®re NIM. Each color represents a pile in the game of NIM, and the number of candies of that color is the size of the pile.\u003c/p\u003e\u003cp\u003eThe optimal strategy is the same as in the classical NIM: the losing positions are precisely those where the xor of pile sizes is zero. But there is one exception: if all pile sizes are 0 or 1, it is reversed: the ones with an odd number of 1s are losing.\u003c/p\u003e\u003cp\u003eHere is a proof: For situations where the largest pile is 1 it is obvious. In all situations where the largest pile has more than 1 token, the player who has the winning strategy in classical NIM can follow the same strategy in this NIM. This player must be the one who will eventually make the move that will lead into a situation with all pile sizes 0 or 1. And at this moment, the player may choose the opposite: if the winning move in classical NIM was to decrease the current pile to 0 she will decrease it to 1 and vice versa.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eD (divisibility from last digits)\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eObviously, we have to look at the k-th digit (zero-based index from the right) if and only if 10^k is not a multiple of d. Hence, we are looking for the smallest k such that d divides 10^k. This is only possible if d is of the form 2^a * 5^b, and the answer is max(a,b). Note that a can be at most 59. (Some solutions probably failed because they tried too few values for a, instead of simply dividing d by 2 while it still goes.)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eE (exactly divisible by sum of largest digits)\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe standard first trick is to write the answer as solve(b+1)-solve(a) where solve(x) counts all solutions in [100,x).\u003c/p\u003e\u003cp\u003eTo implement solve(x), use three cycles to run through all possibilities for the three largest digits, and then count all numbers with those three largest digits. (I used two cases: I separately count those with fewer than x digits and then for each prefix of x I count those that are smaller than x in the last digit of the prefix. For example, if x is \u0026quot;1234567\u0026quot;, one of the subproblems will be to count all numbers of the form \u0026quot;12341..\u0026quot;.)\u003c/p\u003e\u003cp\u003eThe core of the solution is a memoized recursive function go(a,b,c,found,rem,left) that generates the number from the left to the right. It has the following arguments:\u003c/p\u003e \u003cul\u003e   \u003cli\u003ea,b,c are the three largest digits, with a\u0026gt;\u003db\u0026gt;\u003dc. E.g., a,b,c \u003d 9,7,7\u003c/li\u003e   \u003cli\u003efound is a bitmask stating which of them I\u0027ve already used. E.g., found\u003d5 means that a,c already appeared but b didn\u0027t.\u003c/li\u003e   \u003cli\u003ethe number I have generated so far gives the remainder rem when divided by a+b+c\u003c/li\u003e   \u003cli\u003eleft is the number of digits I still have to generate\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eNote that once I fixed a,b,c I can maintain the remainder modulo a+b+c while generating the number, and I also know that all digits other than a,b,c must be less than or equal to c.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eF (fractions)\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe simplest O(n log^2 n) algorithm by Patrascu and Patrascu, described \u003ca href\u003d\"http://people.csail.mit.edu/mip/papers/farey/farey.pdf\"\u003ein this paper\u003c/a\u003e, should be sufficient. (There are faster known algorithms but I didn\u0027t want to make the problem too hard.)\u003c/p\u003e\u003c/div\u003e","tags":["yandex","yandex.algorithm","editorial"]}}