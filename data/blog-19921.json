{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1440273944,"rating":14,"authorHandle":"arlanawesome","modificationTimeSeconds":1440347728,"id":19921,"title":"\u003cp\u003eПерсистентное декартово дерево по неявному ключу\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eЗдравствуйте, У меня возникла проблема я когда прочитал и понял как использовать персистентное декартого дерево спотокнулся над одной проблемы. Мы знаем что с помощью персистентной декарткой мы мoжем скопировать отрезок в другой часть массива. Но именно эту операцию я не понял как сделать, и не где не нашел где об этом было рассказано. В простом декартово дерево моя идея заключалась в том что, надо копировать все дерево а потом вырезать отрезак которе мы хотим скопировать у первого дерево, а отрезок где мы хотим вставить наш скопированный отрезок у второго дерево. И потом эти отрезки swap. оставляем второе дерево, а первый больше не нужен. помогите пожалуйста, зарание спасибо! \u003c/p\u003e\u003cp\u003eВот реализация персистентной дерамиды! Oно работает!\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstdio\u0026gt;\n#include\u0026lt;string\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n#include\u0026lt;cmath\u0026gt;\n#include\u0026lt;vector\u0026gt;\nusing namespace std;\nstruct Node {\n    long long int val;\n    int cnt;\n    long long int sum;\n    int link;\n    Node *l; Node *r;\n    Node() {\n        link \u003d 0;\n        val \u003d 0;\n        cnt \u003d 0;\n        sum \u003d 0;\n        l \u003d r \u003d 0;\n    }\n    Node(long long int va) {\n        val \u003d va;\n        cnt \u003d 1;\n        sum \u003d va;\n        link \u003d 0;\n        l \u003d r \u003d 0;\n    }\n    Node(Node *t) {\n        if (t \u003d\u003d 0) {\n            return;\n        }\n        val \u003d t -\u0026gt; val;\n        cnt \u003d t -\u0026gt; cnt;\n        sum \u003d t -\u0026gt; sum;\n        link \u003d 0;\n        l \u003d t -\u0026gt; l;\n        r \u003d t -\u0026gt; r;\n    }\n};\nint N;\nlong long int X1, A, B, M;\nint K;\nvoid AddLink(Node *t) {\n    if (t \u003d\u003d 0) {\n        return;\n    }\n    t -\u0026gt; link++;\n}\nvoid DelNode(Node *t) {\n    if (t \u003d\u003d 0) {\n        return;\n    }\n    t -\u0026gt; link--;\n    if (t -\u0026gt; link \u0026lt;\u003d 0) {\n        DelNode(t -\u0026gt; l);\n        DelNode(t -\u0026gt; r);\n        delete t;\n    }\n}\nint cntt(Node *t) {\n    if (t \u003d\u003d 0) {\n        return 0;\n    }\n    return t -\u0026gt; cnt;\n}\nlong long int ssum(Node *t) {\n    if (t \u003d\u003d 0) {\n        return 0;\n    }\n    return t -\u0026gt; sum;\n}\nvoid update(Node *t) {\n    if (t !\u003d 0) {\n        t -\u0026gt; cnt \u003d cntt(t -\u0026gt; r) + cntt(t -\u0026gt; l) + 1;\n        t -\u0026gt; sum \u003d ssum(t -\u0026gt; r) + ssum(t -\u0026gt; l) + t -\u0026gt; val;\n    }\n}\nNode *merge_t(Node *L, Node *R) {\n    Node *ptrn \u003d 0;\n    if (L \u003d\u003d 0) {\n        ptrn \u003d new Node(R);\n        AddLink(ptrn -\u0026gt; l);\n        AddLink(ptrn -\u0026gt; r);\n        return ptrn;\n    }\n    if (R \u003d\u003d 0) {\n        ptrn \u003d new Node(L);\n        AddLink(ptrn -\u0026gt; l);\n        AddLink(ptrn -\u0026gt; r);\n        return ptrn;\n    }\n    if ((rand() % (L -\u0026gt; cnt + R -\u0026gt; cnt)) \u0026gt; R -\u0026gt; cnt) {\n        ptrn \u003d new Node(L);\n        ptrn -\u0026gt; r \u003d merge_t(ptrn -\u0026gt; r, R);\n        AddLink(ptrn -\u0026gt; l);\n        AddLink(ptrn -\u0026gt; r);\n        update(ptrn);\n        return ptrn;\n    } else {\n        ptrn \u003d new Node(R);\n        ptrn -\u0026gt; l \u003d merge_t(L, ptrn -\u0026gt; l);\n        AddLink(ptrn -\u0026gt; l);\n        AddLink(ptrn -\u0026gt; r);\n        update(ptrn);\n        return ptrn;\n    }\n}\nvoid split_t(Node *t, int x, Node *\u0026amp;L, Node *\u0026amp;R) {\n    if (t \u003d\u003d 0) {\n        L \u003d R \u003d 0;\n        return;\n    }\n    Node *cur \u003d new Node(t);\n    int indexx \u003d cntt(t -\u0026gt; l) + 1;\n    if (indexx \u0026lt;\u003d x) {\n        split_t(cur -\u0026gt; r, x - indexx, cur -\u0026gt; r, R);\n        AddLink(cur -\u0026gt; l);\n        AddLink(cur -\u0026gt; r);\n        L \u003d cur;\n    } else {\n        split_t(cur -\u0026gt; l, x, L, cur -\u0026gt; l);\n        AddLink(cur -\u0026gt; l);\n        AddLink(cur -\u0026gt; r);\n        R \u003d cur;\n    }\n    update(L);\n    update(R);\n}\nvoid printt(Node *t) {\n    if (t \u003d\u003d 0) {\n        return;\n    }\n    printt(t -\u0026gt; l);\n    printf(\u0026quot;%lld \u0026quot;, t -\u0026gt; val);\n    //cout \u0026lt;\u0026lt; t -\u0026gt; val \u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt; t -\u0026gt; link \u0026lt;\u0026lt; endl;\n    printt(t -\u0026gt; r);\n}\nint main() {\n    //freopen(\u0026quot;meneger.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n    //freopen(\u0026quot;meneger.out\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n    string s;\n    Node *t \u003d 0;\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;N);\n    scanf(\u0026quot;%lld %lld %lld %lld\u0026quot;, \u0026amp;X1, \u0026amp;A, \u0026amp;B, \u0026amp;M);\n    for (int i \u003d 0; i \u0026lt; N; i++) {\n        Node *tt;\n        Node *nt;\n        if (i \u003d\u003d 0) {\n            tt \u003d new Node(X1);\n            nt \u003d merge_t(t, tt);\n            DelNode(t);\n            DelNode(tt);\n            t \u003d nt;\n        } else {\n            X1 \u003d (A * X1 + B) % M;\n            tt \u003d new Node(X1);\n            nt \u003d merge_t(t, tt);\n            DelNode(t);\n            DelNode(tt);\n            t \u003d nt;\n        }\n    }\n    //printt(t);\n    //cout \u0026lt;\u0026lt; endl;\n    int a, b, w;\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;K);\n    for (int i \u003d 0; i \u0026lt; K; i++) {\n        cin \u0026gt;\u0026gt; s;\n        if (s \u003d\u003d \u0026quot;cpy\u0026quot;) {\n            scanf(\u0026quot;%d %d %d\u0026quot;, \u0026amp;a, \u0026amp;b, \u0026amp;w);\n            a--; b--;\n            Node *left \u003d 0;\n            Node *right \u003d 0;\n            Node *lleft \u003d 0;\n            Node *rright \u003d 0;\n            Node *lr \u003d 0;\n            Node *sr \u003d 0;\n            Node *nt;\n            split_t(t, a, left, right);\n            DelNode(left);\n            sr \u003d right;\n            split_t(right, w, left, right);\n            DelNode(sr);\n            DelNode(right);\n            sr \u003d 0;\n\n            split_t(t, b, lleft, rright);\n            lr \u003d lleft;\n            sr \u003d rright;\n            split_t(rright, w, lleft, rright);\n            DelNode(lleft);\n            DelNode(sr);\n            Node *tnt;\n            nt \u003d merge_t(lr, left);\n            tnt \u003d nt;\n            nt \u003d merge_t(nt, rright);\n            DelNode(lr);\n            DelNode(left);\n            DelNode(rright);\n            DelNode(tnt);\n            DelNode(t);\n            t \u003d nt;\n        } else if (s \u003d\u003d \u0026quot;sum\u0026quot;) {\n            scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;a, \u0026amp;b);\n            a--;\n            b -\u003d a;\n            Node *left;\n            Node *right;\n            Node *sr;\n            split_t(t, a, left, right);\n            DelNode(left);\n            sr \u003d right;\n            split_t(right, b, left, right);\n            DelNode(sr);\n            DelNode(right);\n            printf(\u0026quot;%lld\\n\u0026quot;, left -\u0026gt; sum);\n            DelNode(left);\n        } else if (s \u003d\u003d \u0026quot;out\u0026quot;) {\n            scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;a, \u0026amp;b);\n            a--;\n            b -\u003d a;\n            Node *left;\n            Node *right;\n            Node *sr;\n            split_t(t, a, left, right);\n            DelNode(left);\n            sr \u003d right;\n            split_t(right, b, left, right);\n            DelNode(sr);\n            DelNode(right);\n            printt(left);\n            printf(\u0026quot;\\n\u0026quot;);\n            DelNode(left);\n        }\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}