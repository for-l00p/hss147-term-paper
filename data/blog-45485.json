{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1466156082,"rating":90,"authorHandle":"fnf47","modificationTimeSeconds":1466250402,"id":45485,"title":"\u003cp\u003e2D Range Minimum Query in O(1)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003e2D Range minimum Query in \u0026lt;O(n*m*logn*logm),O(1)\u0026gt;\u003c/strong\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eI solved \u003ca href\u003d\"https://www.codechef.com/problems/CHSQARR\"\u003eTHIS\u003c/a\u003e problem from \u0026quot;codechef June16 long challenge\u0026quot; by extending the \u0026quot; 1D RMQ sparse table method\u0026quot; to 2D version which finds maximum value in a submatrix in O(1) after O(n*m*logn*logm) preprocessing time.\u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e\u003ch3\u003e1D RMQ \u0026lt;O(n*logn),O(1)\u0026gt; \u003cbr /\u003e\u003c/h3\u003e\u003cp\u003e\u003cem\u003eProblem: Given an array[n] and Q queries. Each query asks for minimum in range x to y where 0\u003d\u0026lt;x\u0026lt;\u003dy\u0026lt;n\u003c/em\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003ePreprocess : O(n*logn)\u003c/em\u003e \u003cbr /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e For(i\u003d0;i\u0026lt;n;i++)            \n   table[ 0 ][ i ]\u003darray[ i ]         //building base\n\n For(j\u003d1;j\u0026lt;\u003dlog(n);j++)\n   For(i\u003d0;i+2^(j-1)\u0026lt;n;i++)          \n     table[ j ][ i ] \u003d min ( table[ j-1 ][ i ], table[ j-1 ][ i+2^(j-1) ] )  //use previously computed\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ewe created a sparse table[ 1+logn ][ n ] \u003cbr /\u003e \u003cstrong\u003etable[ j ][ i ] contains the minimum value in range i to i-1 + 2^j inclusive\u003c/strong\u003e\u003cbr /\u003e Each range is a power of 2. First we build base of the table. Then for each range we split it into 2 equal parts for which value is already calculated. This way table is build in O(n*logn). \u003c/p\u003e\u003cp\u003e\u003cem\u003eQuery(x,y) : O(1)\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e     len\u003dy-x+1\n     k\u003dlog2(len)\n     return min(table[ k ][ x ],table[ k ][ y+1-2^k ])   // ranges may overlap\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eQuery is then simply splitting the range in 2 parts each of which is a power of 2 and then using the pre-computed value from table. The 2 partitioned Ranges may overlap.\u003cbr /\u003e\u003cbr /\u003eI found \u003ca href\u003d\"https://www.youtube.com/watch?v\u003dc5O7E_PDO4U\"\u003eTHIS\u003c/a\u003e video which explains it in detail \u003cbr /\u003e This was 1D RMQ. Now lets extend this concept to solve 2D RMQ\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e\u003ch3\u003e2D RMQ \u0026lt;O(n*m*logn*logm),O(1)\u0026gt; \u003cbr /\u003e\u003c/h3\u003e\u003cp\u003e\u003cem\u003eProblem:Given a matrix[n][m] and Q queries. Each query asks for minimum in submatrix[ (x1,y1), (x2,y2) ]\u003c/em\u003e \u003cbr /\u003e  \u003cem\u003ex1,y1 is the top left-most point and x2,y2 is bottom right-most point of the submatrix.Assume 0-based indexing\u003c/em\u003e  \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003ePreprocess : O(n*m*logn*logm)\u003c/em\u003e \u003cbr /\u003e\u003c/p\u003e \u003cul\u003e   \u003cli\u003ewe create a table[ 1+logn ][ n ][ 1+logm ][ m ] \u003cbr /\u003e\u003c/li\u003e   \u003cli\u003eEach box of the table[ 1+logn ][ n ] is a sparse table of size [ 1+logm ][ m ]\u003cbr /\u003e\u003c/li\u003e   \u003cli\u003eLet us see what table[ jr ][ ir ][ jc ][ ic ] actually contains: \u003cbr /\u003e  It contains the minimum element from column ic to ic-1+2^jc of all rows from ir to ir-1+2^jr\u003cbr /\u003e  In other words, it contain the \u003cstrong\u003eminimum element in the submatrix [ (ir,ic), (ir-1+2^jr , ic-1+2^jc) ]\u003c/strong\u003e \u003cbr /\u003e  where submatrix [ (x1,y1),(x2,y2) ] denotes the submatrix with x1,y1 as its top left-most and x2,y2 as its bottom right-most point.\u003c/li\u003e   \u003cli\u003eNow you can easily conclude that, table[ 0 ][ ir ][ jc ][ ic ] is nothing but the 1D RMQ table if we take our array as row ir  \u003cbr /\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eNow,lets see how to code it\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eAt First,for each row ir, we compute table[ 0 ][ ir ][ jc ][ ic ] ,the same as we did in 1D version. \u003cbr /\u003e Taking each row as an array and then computing its sparse table in same fashion as in 1D RMQ. \u003cbr /\u003e \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eFor(ir\u003d0;ir\u0026lt;n;ir++)\n{\n  For(ic\u003d0;ic\u0026lt;m;ic++)\n    table[ 0 ][ ir ][ 0 ][ ic ] \u003d Matrix[ ir ][ ic ];\n       \n  For(jc\u003d1;jc\u0026lt;\u003dlog2(m);jc++)\n    For(ic\u003d0;ic+2^(jc-1)\u0026lt;m;ic++)\n     table[0 ][ir ][jc ][ic ] \u003d min(table[0 ][ir ][jc-1 ][ic ],table[0 ][ir ][ jc-1 ][ ic+2^(jc-1) ])\n}        \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe above step is nothing but computing the sparse table for each row. \u003cbr /\u003e The complexity for one row is O(m*logm) and so for all rows O(n*m*logm). \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eNow,we will use this base to build the entire table. \u003cbr /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eFor(jr\u003d1;jr\u0026lt;\u003dlog(n);jr++)\n  For(ir\u003d0;ir\u0026lt;n;ir++)\n    For(jc\u003d0;jc\u0026lt;\u003dlog(m);jc++)\n      For(ic\u003d0;ic\u0026lt;m;ic++)\n        table[jr ][ir ][jc ][ic ] \u003d min(table[jr-1 ][ir ][jc ][ic ],table[jr-1 ][ir+2^(jr-1) ][jc ][ic ])  \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIts not very difficult to understand this,just go through each line of the above code and try to visualise.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eClearly,the above step is O(n*m*logn*logm) \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eQuery(x1,y1,x2,y2) : O(1)\u003c/em\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eWe have to find the minimum in submatrix [(x1,y1),(x2,y2)] \u003cbr /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    lenx\u003dx2-x1+1\n    kx\u003dlog2(lenx)\n    leny\u003dy2-y1+1\n    ky\u003dlog2(leny)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFirst we will query on n\u003cbr /\u003e we have to query from row x1 to row x2. \u003cbr /\u003e But we have only computed for the range which are powers of 2 so we will divide in into two range \u003cbr /\u003e each of which is a power of 2. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003ex1 to x1-1+2^kx .....(say range R1) \u003cbr /\u003e  x2+1-2^kx to x2 .....(say range R2) \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eThe partition may overlap but that\u0027s not the problem here as we have to find the min/max only.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eNow for each of the above two ranges R1 and R2, we have to query in column y1 to y2. \u003cbr /\u003e For this we will do the same range partition as we did above, i.e. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003ey1 to y1-1+2^ky ......(say range C1) \u003cbr /\u003e  y2+1-2^ky to y2 ......(say range C2) \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eso query is simply 3 lines of code,\u003cbr /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e  min_R1 \u003d min ( table[kx ][x1 ][ky ][y1 ] , table[kx ][x1 ][ky ][ y2+1-2^ky ] ) \n  min_R2 \u003d min ( table[kx ][x2+1-2^kx ][ky ][y1 ], table[kx ][x2+1-2^kx ][ky ][y2+1-2^ky ] )\n  return min ( min_R1, min_R2 )\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDone.\u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eWe can also use 2D segment tree to solve 2D RMQ in \u0026lt;O(n*m), O(logn*logm)\u0026gt;. It has a special benefit that we can also do update in O(logn*logm). We will see that in next blog.\u003cbr /\u003e \u003c/p\u003e\u003cp\u003e1D RMQ \u003ca href\u003d\"https://www.youtube.com/watch?v\u003dc5O7E_PDO4U\"\u003eVideo\u003c/a\u003e \u003cbr /\u003e 1D RMQ \u003ca href\u003d\"http://www.spoj.com/problems/RPLN/\"\u003eproblem\u003c/a\u003e //use fats I/O \u003cbr /\u003e\u003cbr /\u003e 2D RMQ problems\u003cbr /\u003e \u003ca href\u003d\"https://www.codechef.com/JUNE16/problems/CHSQARR/\"\u003eproblem1\u003c/a\u003e // 2D segtree gives TLE in last subtask\u003cbr /\u003e \u003ca href\u003d\"//codeforces.com/contest/15/problem/D\"\u003eproblem2\u003c/a\u003e \u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e\u003c/div\u003e","tags":["rmq","sparse table"]}}