{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1422904048,"rating":156,"authorHandle":"cgy4ever","modificationTimeSeconds":1423435409,"id":16173,"title":"\u003cp\u003eCodeforces Round #290 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eUpdate 1\u003c/strong\u003e : here are the reference solutions for this contest:\u003c/p\u003e \u003col\u003e   \u003cli\u003eDiv2-A: \u003ca href\u003d\"http://ideone.com/JP1Ksj\"\u003ehttp://ideone.com/JP1Ksj\u003c/a\u003e\u003c/li\u003e   \u003cli\u003eDIv2-B: \u003ca href\u003d\"http://ideone.com/udz3bN\"\u003ehttp://ideone.com/udz3bN\u003c/a\u003e\u003c/li\u003e   \u003cli\u003eDiv2-C / Div1-A: \u003ca href\u003d\"http://ideone.com/KVobNb\"\u003ehttp://ideone.com/KVobNb\u003c/a\u003e\u003c/li\u003e   \u003cli\u003eDiv2-D / Div1-B: \u003ca href\u003d\"http://ideone.com/7MQqOm\"\u003ehttp://ideone.com/7MQqOm\u003c/a\u003e\u003c/li\u003e   \u003cli\u003eDiv2-E / Div1-C: \u003ca href\u003d\"http://ideone.com/z3FsU2\"\u003ehttp://ideone.com/z3FsU2\u003c/a\u003e\u003c/li\u003e   \u003cli\u003eDiv1-D: \u003ca href\u003d\"http://ideone.com/Y7j21a\"\u003ehttp://ideone.com/Y7j21a\u003c/a\u003e\u003c/li\u003e   \u003cli\u003eDiv1-E: \u003ca href\u003d\"http://ideone.com/Orbacp\"\u003ehttp://ideone.com/Orbacp\u003c/a\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eNote that for Div2-E / Div1-C, it is for the harder version: we need to handle \u00271\u0027 in the cycle.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/510/problem/A\" title\u003d\"Codeforces Round 290 (Div. 2)\"\u003e510A - Fox And Snake\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThere are 2 different ways to solve this kind of task:\u003c/p\u003e\u003cp\u003eFirst one is to simulate the movement of the snake head, and you draw \u0027#\u0027s on the board. The code will look like:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ehead \u003d (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnother way is to do some observation about the result, you can find this pattern:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e(4k+1) / (4k+3) line: \u0026quot;#######\u0026quot;\n(4k+2) line: \u0026quot;.......#\u0026quot;\n(4k+0) line: \u0026quot;#.......\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ca href\u003d\"/contest/510/problem/B\" title\u003d\"Codeforces Round 290 (Div. 2)\"\u003e510B - Fox And Two Dots\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis task is essentially ask if there is a cycle in an undirected graph: treat each cell as a node, and add an edge if two cells are neighborhood and have some color.\u003c/p\u003e\u003cp\u003eThere are lots of ways to do this, for example:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eRun dfs / bfs, if an edge lead you to a visited node, then there must be a cycle.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eFor each connected component, test if \u003cspan class\u003d\"tex-span\"\u003e|#\u003ci\u003eedges\u003c/i\u003e| \u003d |#\u003ci\u003enodes\u003c/i\u003e| - 1\u003c/span\u003e, if not then there must be a cycle.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003e\u003ca href\u003d\"/contest/510/problem/C\" title\u003d\"Codeforces Round 290 (Div. 2)\"\u003e510C - Fox And Names\u003c/a\u003e / \u003ca href\u003d\"/contest/512/problem/A\" title\u003d\"Codeforces Round 290 (Div. 1)\"\u003e512A - Fox And Names\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s first think about what \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u0026lt; \u003ci\u003eT\u003c/i\u003e\u003c/span\u003e can tell us: suppose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u003d \u003ci\u003eabcxyz\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e \u003d \u003ci\u003eabcuv\u003c/i\u003e\u003c/span\u003e. Then we know that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u0026lt; \u003ci\u003eT\u003c/i\u003e\u003c/span\u003e if and only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026lt; \u003ci\u003eu\u003c/i\u003e\u003c/span\u003e by the definition.\u003c/p\u003e\u003cp\u003eSo we can transform the conditions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ename\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u0026lt; \u003ci\u003ename\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ename\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u0026lt; \u003ci\u003ename\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e\u003c/span\u003e ... into the order of letters.\u003c/p\u003e\u003cp\u003eThen the question become: do we have a permutation that satisfy those conditions. It is actually the classic topological order question.\u003c/p\u003e\u003cp\u003eOne trick in this task is that, if we have something like \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exy\u003c/i\u003e \u0026lt; \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e then there is no solution. This is not covered in pretests. :)\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/510/problem/D\" title\u003d\"Codeforces Round 290 (Div. 2)\"\u003e510D - Fox And Jumping\u003c/a\u003e / \u003ca href\u003d\"/contest/512/problem/B\" title\u003d\"Codeforces Round 290 (Div. 1)\"\u003e512B - Fox And Jumping\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis task equals to: what is the minimal sum of costs that we can select k cards, so their GCD is 1.\u003c/p\u003e\u003cp\u003eFirst observation is that: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eGCD\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e) \u003d 1\u003c/span\u003e means that for any prime \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e, there exist i such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is not dividable by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e. So we only care about what prime factors a number contain. (So for example, 12 -\u0026gt; {2, 3}, 6 -\u0026gt; {2, 3}, 9 -\u0026gt; {3]})\u003c/p\u003e\u003cp\u003eThe second observation is: If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e then it has at most 9 prime factors.\u003c/p\u003e\u003cp\u003eSo after we select one number, we only care about these 9 or less primes. Then this problem equals to set covering problem (SCP), it can be done by mask DP. It can run in about O(2^9 * n^2).\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/510/problem/E\" title\u003d\"Codeforces Round 290 (Div. 2)\"\u003e510E - Fox And Dinner\u003c/a\u003e / \u003ca href\u003d\"/contest/512/problem/C\" title\u003d\"Codeforces Round 290 (Div. 1)\"\u003e512C - Fox And Dinner\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst finding is: if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e is a prime, then one of them is an odd number, another is an even number. (that\u0027s why we set \u003cspan class\u003d\"tex-span\"\u003e2 ≤ \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e)\u003c/p\u003e\u003cp\u003eThen we could find: every odd number have exactly 2 even number as neighborhood, and every even number have exactly 2 odd number as neighborhood. And that means we need \u003cspan class\u003d\"tex-span\"\u003e|#\u003ci\u003eeven\u003c/i\u003e| \u003d |#\u003ci\u003eodd\u003c/i\u003e|\u003c/span\u003e to have a solution.\u003c/p\u003e\u003cp\u003eSo it looks like bipartite graph matching, but every element matched 2 elements. And in fact it can be handled by maxflow: For each odd number, we add a node on the left side and link it from source with capacity equals to 2, and for each even number, we add a node on the right side and link it to sink with capacity equals to 2. And if sum of two numbers is a prime number, we link them with capacity equals to 1.\u003c/p\u003e\u003cp\u003eThen we solve the max flow, it have solution if and only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emaxflow\u003c/i\u003e \u003d 2 * |#\u003ci\u003eeven\u003c/i\u003e|\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe can construct the answer(cycles) from the matches.\u003c/p\u003e\u003cp\u003eNote: Actually this task is still solvable if we allow \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 1\u003c/span\u003e. But you need some clever way to deal with it. We think it is too hard so we removed this case. What do you think about this decision?\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/512/problem/D\" title\u003d\"Codeforces Round 290 (Div. 1)\"\u003e512D - Fox And Travelling\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe could find that some nodes cannot be visited. And more specific, if one node is in a cycle then it cannot be visited. So what about the structure of nodes that we can visit?\u003c/p\u003e\u003cp\u003eLet\u0027s first find a way to get all nodes that could be visited. We can deal with this by something like biconnected decomposition, but that is not easy to implement. In fact we can use this simple method: each time we pick one node that have at most 1 neighborhood and delete it. Repeat this process until we can\u0027t do it anymore.\u003c/p\u003e\u003cp\u003eWe could find these nodes are actually belonging to these 2 kinds: 1. A tree. 2. Rooted tree. (that means, the root is attached to a cycle)\u003c/p\u003e\u003cp\u003eThe rooted tree case is simple: we can solve it by tree DP. The state will be dp[i][j] \u003d the way to remove j nodes in the subtree rooted at i.\u003c/p\u003e\u003cp\u003eThen how to solve the unrooted tree case? The way to deal with that is to transform it into rooted case. We have 2 solution:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eWe select one unvisited node as the root by some rules: for example, we select one with minimal index. Then we just need to modify the DP a bit to adjust this additional condition.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eWe could find if the tree has n nodes and we visit k nodes in the end, then there will be max(1, n-k) ways to choose the root. That means if we choose every node as the root and sum up them, we will count this case exactly max(1, n-k) times. So we just do the rooted DP for from node n times, and divide max(1, n-k) for ans[k].\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eThe overall complicity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e)\u003c/span\u003e, and it can be optimize into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e if you like.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/512/problem/E\" title\u003d\"Codeforces Round 290 (Div. 1)\"\u003e512E - Fox And Polygon\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTriangulation of polygon is something hard to think about. So the first key observation is that, we can transform this task into operations on rooted trees!\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"http://puu.sh/e4tiX/db64342636.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eOne Triangulation of polygon can be mapping to one rooted tree. And the flip operation can be mapping to the rotation of trees. (It is the operation we used to balance our BST) You can find the mapping from above picture. The red lines indicate the edge that will be flipped and the nodes we rotated.\u003c/p\u003e\u003cp\u003eThen we should find a standard shape of the tree, and solve this task: how to rotate any tree into this standard shape?\u003c/p\u003e\u003cp\u003eMy solution is to choose the balanced tree as standard shape. The way to do that is this: find the node that the index is the middle number, rotate it to the top(that what we did for splay tree), and do the same thing for each subtree.\u003c/p\u003e\u003cp\u003eIt is easy to see it could work in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlogn\u003c/i\u003e)\u003c/span\u003e steps.\u003c/p\u003e\u003c/div\u003e","tags":[]}}