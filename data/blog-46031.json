{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1468522276,"rating":80,"authorHandle":"DarthPrince","modificationTimeSeconds":1470374338,"id":46031,"title":"\u003cp\u003eCodeforces Round #362 (Editorial)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"https://gitlab.com/amirmd76/cf-round-362/tree/master\"\u003eHere\u003c/a\u003e is git repository to solutions of problems of this contest.\u003c/p\u003e\u003ch3\u003eDiv.2 A\u003c/h3\u003e\u003cp\u003eYou should check two cases for YES:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003ci\u003emod\u003c/i\u003e \u003ci\u003es\u003c/i\u003e \u003d \u003ci\u003et\u003c/i\u003e \u003ci\u003emod\u003c/i\u003e \u003ci\u003es\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e ≤ \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003ci\u003emod\u003c/i\u003e \u003ci\u003es\u003c/i\u003e \u003d (\u003ci\u003et\u003c/i\u003e + 1) \u003ci\u003emod\u003c/i\u003e \u003ci\u003es\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e + 1 \u0026lt; \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/93/3d/933d8760a8101df7fa17164e09d03edfc2485f32.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/54/24/54240e3a8722dc1ae212174011a891f19cdf0c20.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://gitlab.com/amirmd76/cf-round-362/tree/master/2A\"\u003eCodes\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eDiv.2 B\u003c/h3\u003e\u003cp\u003eNothing special, right? just find the position of letters \u003ccode\u003e.\u003c/code\u003e and \u003ccode\u003ee\u003c/code\u003e with string searching methods (like \u003ccode\u003e.find\u003c/code\u003e) and do the rest.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/a5/30/a530301dad42b444069695e3d60cce1e1e66084e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d6/2e/d62e2a32a67492a176690a6a7c26f5a68aa2a122.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://gitlab.com/amirmd76/cf-round-362/tree/master/2B\"\u003eCodes\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eA\u003c/h3\u003e\u003cp\u003eDo what problem wants from you. The only thing is to find the path between the two vertices (or LCA) in the tree. You can do this in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/8a/7c8a1a97fd8aabbe4fd7f3354332b862b0bdb8ca.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e since the height of the tree is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/8a/7c8a1a97fd8aabbe4fd7f3354332b862b0bdb8ca.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. You can keep edge weights in a map and get/set the value whenever you want. Here\u0027s a code for LCA:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eLCA(v, u):\n        while v !\u003d u:\n                if depth[v] \u0026lt; depth[u]:\n                        swap(v, u)\n                v \u003d v/2        // v/2 is parent of vertex v\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/f4/ad/f4ad3539e5f7195eec245aedb021982c41e11e80.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/23/1a/231a7daa275d9fb5feff0c9df410a7acb86a43ed.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://gitlab.com/amirmd76/cf-round-362/tree/master/A\"\u003eCodes\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eB\u003c/h3\u003e\u003cp\u003eFirst of all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estarting\u003c/i\u003e_\u003ci\u003etime\u003c/i\u003e\u003c/span\u003e of a vertex is the number of \u003ccode\u003edfs\u003c/code\u003e calls before the \u003ccode\u003edfs\u003c/code\u003e call of this vertex plus 1. Now suppose we want to find the answer for vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. For any vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e that is not in subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and is not an ancestor \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, denote vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e such that:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e ≠ \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is an ancestor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e but not \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e is an ancestor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e but not \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e share the same direct parent; That is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epar\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] \u003d \u003ci\u003epar\u003c/i\u003e[\u003ci\u003ey\u003c/i\u003e]\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/18/dd/18dd7f9f42993675904e772f15da7b7eeb453511.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThe probability that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e occurs sooner than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003echildren\u003c/i\u003e[\u003ci\u003epar\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e]]\u003c/span\u003e after shuffling is \u003cspan class\u003d\"tex-span\"\u003e0.5\u003c/span\u003e. So the probability that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estarting\u003c/i\u003e_\u003ci\u003etime\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e] \u0026lt; \u003ci\u003estarting\u003c/i\u003e_\u003ci\u003etime\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e0.5\u003c/span\u003e. Also We know if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is ancestor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e this probability is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and if it\u0027s in subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e the probability is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. That\u0027s why answer for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is equal to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d5/b9/d5b901d55cf3abbc0832ea68dbe8ecf7269c26f4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edepth\u003c/i\u003e\u003c/span\u003e is 1-based and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esub\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e is the number of vertices in subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e including \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e itself). Because \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003esub\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e] - \u003ci\u003eh\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e is the number of vertices like the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e (not in subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and not an ancestor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eThus answer is always either an integer or an integer and a half.\u003c/p\u003e\u003cp\u003eTime complexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d6/2e/d62e2a32a67492a176690a6a7c26f5a68aa2a122.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://gitlab.com/amirmd76/cf-round-362/tree/master/B\"\u003eCodes\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eC\u003c/h3\u003e\u003cp\u003eIt gets tricky when the problem statement says \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e should be coprimes. A wise coder in this situation thinks of a formula to make sure this happens.\u003c/p\u003e\u003cp\u003eFirst of all let\u0027s solve the problem if we only want to find the fraction \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7b/21/7b213bbd1427432d309400301100bfaa85bd959f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Suppose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e is answer for swapping the cups \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e times. It\u0027s obvious that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[1] \u003d 0\u003c/span\u003e. For \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026gt; 0\u003c/span\u003e, obviously the desired cup shouldn\u0027t be in the middle in \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e - 1) - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e swap and with this condition the probability that after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e swap comes to the middle is \u003cspan class\u003d\"tex-span\"\u003e0.5\u003c/span\u003e. That\u0027s why \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cb/65/cb65ec81bfb92a04a629a0f83973fba2e70dfe33.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/7d/c3/7dc3471ea64089121e69d2eac8526fcdf02dd6fe.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eSome people may use matrix to find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e using this dp (using pair of ints instead of floating point) but there\u0027s a risk that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e are not coprimes, but fortunately or unfortunately they will be.\u003c/p\u003e\u003cp\u003eUsing some algebra you can prove that:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eif \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is even then \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b6/9a/b69a6f3835a9c9e73bd5b98590523ab8713a9ddd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e \u003d 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eif \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is odd then \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/be/45/be4532ce339f1dd9c0b463f195dcdab43708e1a6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e \u003d 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eYou can confirm that in both cases \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e are coprimes (since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is odd and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e is a power of 2).\u003c/p\u003e\u003cp\u003eThe only thing left to handle is to find \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e (or \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e) and parity. Finding parity is super easy. Also \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e \u003d 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e × \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e × ... × \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/sup\u003e \u003d (...((2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sup\u003e)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sup\u003e)\u003csup class\u003d\"upper-index\"\u003e\u003c/sup\u003e...)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/sup\u003e\u003c/span\u003e. So it can be calculated using binary exponential. Also dividing can be done using Fermat\u0027s little theorem. \u003c/p\u003e\u003cp\u003eTime complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eklg\u003c/i\u003e(\u003ci\u003eMAX\u003c/i\u003e_\u003ci\u003eA\u003c/i\u003e))\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://gitlab.com/amirmd76/cf-round-362/tree/master/C\"\u003eCodes\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eD\u003c/h3\u003e\u003cp\u003eBuild the prefix automaton of these strings (Aho-Corasick). In this automaton every state denotes a string which is prefix of one of given strings (and when we feed characters to it the current state is always the longest of these prefixes that is a suffix of the current string we have fed to it). Building this DFA can be done in various ways (fast and slow).\u003c/p\u003e\u003cp\u003eSuppose these automaton has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e states (\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c3/4a/c34a3e458e62e7c148ada27b2f65197d34afd66b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e) and state \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e has edges outgoing to states in vector \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eneigh\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e (if we define our DFA as a directed graph). Suppose state number \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e is the initial state (denoting an empty string). \u003c/p\u003e\u003cp\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e was smaller we could use dp: suppose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e][\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e is the maximum score of all strings with length equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e ending in state \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e of our DFA when fed into it.\u003c/p\u003e\u003cp\u003eIt\u0027s easy to show that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[0][1] \u003d 0\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[1][\u003ci\u003ev\u003c/i\u003e] ≤ \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003edp\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e + 1][\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eneigh\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e and calculating dps can be done using this (here \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is sum of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e of all strings that are a suffix of string related to state \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/b6/1e/b61edbae0d0ee2e6926c8926ae1470c0cd996ad5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eNow that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e is large, let\u0027s use matrix exponential to calculate the dp. Now dp is not an array, but a column matrix. Finding a matrix to update the dp is not hard. Also we need to reform \u003ccode\u003e+\u003c/code\u003e and \u003ccode\u003e*\u003c/code\u003e operations. In matrix multiplying we should use \u003ccode\u003e+\u003c/code\u003e instead of \u003ccode\u003e*\u003c/code\u003e and \u003ccode\u003emax\u003c/code\u003e instead of \u003ccode\u003e+\u003c/code\u003e in normal multiplication. \u003c/p\u003e\u003cp\u003eTime complexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bb/1f/bb1f9c4c4f107c44d915b9ddfd319ac0322fa416.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://gitlab.com/amirmd76/cf-round-362/tree/master/D\"\u003eCodes\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eE\u003c/h3\u003e\u003cp\u003eFirst of all, for each query of 1st type we can assume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d 1\u003c/span\u003e (because we can perform this query \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e times, it doesn\u0027t differ).\u003c/p\u003e\u003cp\u003eConsider this problem: there are only queries of type 1.\u003c/p\u003e\u003cp\u003eFor solving this problem we can use heavy-light decomposition. If for a vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e of the tree we denote \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e as the weight of the lightest girl in it (\u003cspan class\u003d\"tex-span\"\u003e∞\u003c/span\u003e in case there is no girl in it), for each chain in HLD we need to perform two type of queries:\u003c/p\u003e \u003col\u003e   \u003cli\u003eGet weight of the lightest girl in a substring (consecutive subsequence) of this chain (a subchain).\u003c/li\u003e   \u003cli\u003eDelete the lightest girl in vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e. As the result only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e changes. We can find this value after changing in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/54/24/54240e3a8722dc1ae212174011a891f19cdf0c20.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e if we have the sorted vector of girls\u0027 weights for each vertex (and then we pop the last element from it and then current last element is the lightest girl, \u003cspan class\u003d\"tex-span\"\u003e∞\u003c/span\u003e in case it becomes empty).\u003c/li\u003e \u003c/ol\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/84/9f/849f6fb9cdf0cdaf4523ca930cc2adade04264f6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThis can be done using a classic segment tree. In each node we only need a pair of integers: weight of lightest girl in interval of this node and the vertex she lives in (a \u003ccode\u003epair\u0026lt;int, int\u0026gt;\u003c/code\u003e).\u003c/p\u003e\u003cp\u003eThis works for this version of the problem. But for the original version we need an additional query type:\u003c/p\u003e\u003cp\u003e\u003cem\u003e3.\u003c/em\u003e Increase weight of girls in a substring (consecutive subsequence) of this chain (a subchain) by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThis can be done using the previous segment tree plus lazy propagation (an additional value in each node, type 3 queries to pass to children).\u003c/p\u003e\u003cp\u003eNow consider the original problem. Consider an specific chain: after each query of the first type on of the following happens to this chain:\u003c/p\u003e \u003col\u003e   \u003cli\u003eNothing.\u003c/li\u003e   \u003cli\u003eOnly an interval (subchain) is effected.\u003c/li\u003e   \u003cli\u003eWhole chain is effected.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eWhen case 2 happens, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e (query argument) belongs to this chain. And this can be done using the 3rd query of chains when we are processing a 2nd type query (effect the chain \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e belongs to).\u003c/p\u003e\u003cp\u003eWhen case 3 happens, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is an ancestor of the topmost vertex in this chain. So when processing 1st type query, we need to know sum of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e for all 2nd type queries that their \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is an ancestor of topmost chain in current chain we\u0027re checking. This can be done using a single segment/Fenwick tree (using starting-finishing time trick to convert tree to array).\u003c/p\u003e\u003cp\u003eSo for each query of 1st type, we will check all chains on the path to find the lightest girl and delete her.\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e1/f7/e1f7ccdbe5cd37f83e2418a0e71d9115ea0494e5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://gitlab.com/amirmd76/cf-round-362/tree/master/E\"\u003eCodes\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eF\u003c/h3\u003e\u003cp\u003eIn the first thoughts you see that there\u0027s definitely a binary search needed (on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e). Only problem is checking if there are such two points fulfilling conditions with radius \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFor each edge, we can shift it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e units inside the polygon (parallel to this edge). The only points that can see the line coinciding the line on this edge are inside the half-plane on one side of this shifted line (side containing this edge). So problem is to partition these half-planes in two parts such that intersection of half-planes in each partition and the polygon (another \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e half-planes) is not empty. There are several algorithms for this propose:\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/82/21/82215655c5f6c0bcbd4404cb5eda06940276e78a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e Algorithm:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/35/d9/35d968ab034fcb6ac8590927aefc1663d9c337a6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eIt\u0027s obvious that if intersection of some half-planes is not empty, then there\u0027s at least on point inside this intersection that is intersection of two of these lines (lines denoting these half-planes). The easiest algorithm is to pick any intersection of these \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003en\u003c/i\u003e\u003c/span\u003e lines (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e shifted half-planes and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e edges of the polygon) like \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e that lies inside the polygon, delete any half-plane containing this point (intersection of deleted half-planes and polygon is not empty because it contains at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e) and check if the intersection of half-planes left and polygon is not empty (of course this part needs sorting half-planes and adds an additional \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e\u003c/span\u003e but we can sort the lines initially and use something like counting sort in this step).\u003c/p\u003e\u003cp\u003eWell, constant factor in this problem is too big and this algorithm will not fit into time limit. But this algorithm will be used to prove the faster algorithm:\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/17/45/17457d8e7535a42392edd92b0750b88a4fe20959.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e Algorithm:\u003c/p\u003e\u003cp\u003eIn the previous algorithm we checked if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e can be in intersection of one part. Here\u0027s the thing:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eLemma 1:\u003c/strong\u003e If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is inside intersection of two half-planes (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is not necessarily intersection of their lines) related to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e edge (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u0026lt; \u003ci\u003er\u003c/i\u003e\u003c/span\u003e) and two conditions below are fulfilled, then there\u0027s no partitioning that in it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is inside intersection of a part (and polygon):\u003c/p\u003e \u003col\u003e   \u003cli\u003eAt least one of the half-planes related to an edge with index between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e exists that doesn\u0027t contain \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eAt least one of the half-planes related to an edge with index greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e or less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e exists that doesn\u0027t contain \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eBecause if these two lines exist, they should be in the other part that doesn\u0027t contain \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and if they are, intersection of them and polygon will be empty(proof is easy, homework assignment ;)).\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/3f/aa/3faad8ab2af0ea0e3553586d2fa4f06c623bd972.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThis proves that if such partitioning is available that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is in intersection of one of them, then it belongs to an interval of edges(cyclic interval) and the rest are also an interval (so intersection of both intervals with polygon should be non-empty). Thus, we don\u0027t need \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e anymore. We only need intervals! \u003c/p\u003e\u003cp\u003eResult is, if such partitioning exists, there are integers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003el\u003c/i\u003e ≤ \u003ci\u003er\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e) such that intersection of half-planes related to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e, \u003ci\u003el\u003c/i\u003e + 1, ..., \u003ci\u003er\u003c/i\u003e\u003c/span\u003e and polygon and also intersection of half-planes related to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e + 1, \u003ci\u003er\u003c/i\u003e + 2, ..., \u003ci\u003en\u003c/i\u003e, 1, 2, ..., \u003ci\u003el\u003c/i\u003e - 1\u003c/span\u003e and polygon are both non-empty.\u003c/p\u003e\u003cp\u003eThis still gives an \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/82/21/82215655c5f6c0bcbd4404cb5eda06940276e78a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e algorithm (checking every interval). But this lemma comes handy here:\u003c/p\u003e\u003cp\u003eWe call an interval(cyclic) good if intersection of lines related to them and polygon is non-empty.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eLemma 2:\u003c/strong\u003e If an interval is good, then every subinterval of this interval is also good.\u003c/p\u003e\u003cp\u003eProof is obvious.\u003c/p\u003e\u003cp\u003eThat gives and idea: \u003c/p\u003e\u003cp\u003eDenote \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003einterval\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e is a set of integers such that:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e ≤ \u003ci\u003er\u003c/i\u003e\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003einterval\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e) \u003d {\u003ci\u003el\u003c/i\u003e, \u003ci\u003el\u003c/i\u003e + 1, ..., \u003ci\u003er\u003c/i\u003e}\u003c/span\u003e\u003c/li\u003e   \u003cli\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e ≤ \u003ci\u003er\u003c/i\u003e\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003einterval\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e) \u003d {\u003ci\u003er\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e + 1, ..., \u003ci\u003en\u003c/i\u003e, 1, ..., \u003ci\u003el\u003c/i\u003e}\u003c/span\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e(In other words it\u0027s a cyclic interval)\u003c/p\u003e\u003cp\u003eAlso \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eMOD\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e is:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e iff \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eMOD\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e - \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e iff \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026gt; \u003ci\u003en\u003c/i\u003e\u003c/span\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e(In other words it\u0027s modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e for 1-based)\u003c/p\u003e\u003cp\u003eThe only thing that matters for us for every \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e, is maximum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003einterval\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003eMOD\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e + \u003ci\u003elen\u003c/i\u003e))\u003c/span\u003e is good (because then all its subintervals are good).\u003c/p\u003e\u003cp\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is maximum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003einterval\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003eMOD\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e + \u003ci\u003elen\u003c/i\u003e))\u003c/span\u003e is good, we can use 2-pointer to find values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eLemma 3:\u003c/strong\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eMOD\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e + 1)\u003c/sub\u003e ≥ \u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - 1\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eProof is obvious in result of \u003cem\u003elemma 2\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eHere\u0027s a pseudo code:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003echeck(r):\n        len \u003d 0\n        for i \u003d 1 to n:\n                while len \u0026lt; n and good(i, MOD(i+len)):        // good(l, r) returns true iff interval(l, r) is good\n                        len \u003d len + 1\n                if len \u003d\u003d 0:\n                        return false        // Obviously\n                if len \u003d\u003d n:\n                        return true        // Barney and Lyanna can both stay in the same position\n                l[i] \u003d len\n        for i \u003d 1 to n:\n                if l[i] + l[MOD(i+l[i])] \u0026gt;\u003d n:\n                        return true\n        return false\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egood\u003c/i\u003e\u003c/span\u003e function can be implemented to work in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d6/2e/d62e2a32a67492a176690a6a7c26f5a68aa2a122.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (with sorting as said before). And 2-pointer makes the calls to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egood\u003c/i\u003e\u003c/span\u003e to be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d6/2e/d62e2a32a67492a176690a6a7c26f5a68aa2a122.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eSo the total complexity to check an specific \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/17/45/17457d8e7535a42392edd92b0750b88a4fe20959.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d0/d1/d0d13c043a6e4ca6c0332727cf133b4a3ffe4e7b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://gitlab.com/amirmd76/cf-round-362/tree/master/F\"\u003eCodes\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFeel free to comment and ask your questions.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/5a/8c/5a8c24d1bf2b5c35b499ea7cd6b7b65af12705c2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003c/div\u003e","tags":["codeforces","round","362","editorial"]}}