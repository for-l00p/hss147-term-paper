{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1457946748,"rating":0,"authorHandle":"Fcdkbear","modificationTimeSeconds":1457962396,"id":43787,"title":"\u003cp\u003eРазбор VNTU Special Training 17\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eЗадача А\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗадачу можно решать следующим образом. Построим таой граф. Каждой ячейке соответствует вершина графа, каждому ребру — переход между ячейками. Запустим dfs/bfs из вершины 1. Посмотрим, или посетили мы вершину t. Если посетили — ответ YES, иначе ответ NO.\u003c/p\u003e\u003cp\u003eСложность алгоритма O(N)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача B\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eПостроим такой граф. Каждому сотруднику соответсвует вершина графа. Между двумя вершинами есть невзвешенное ориентированное ребро от вершины-непосредственного руководителя к вершине-подчиненному. Давайте для каждого сотрудника, у которого нет начальников, запустим dfs, который посчитает, сколько у него подчиненных. Среди всех этих значений выберем максимум (назовем это число d). Утверждается, что это и есть ответ на задачу.\u003c/p\u003e\u003cp\u003eДавайте докажем этот факт. \u003c/p\u003e\u003cp\u003eСначала докажем, что ответ не может быть меньше d. Так как наша величина равна d, выходит что в графе есть цепочка длины d. (то есть, есть последовательность из d людей a[1], a[2] ... a[d], таких, что a[1] — непосредственный руководитель a[2], a[2] — непосредственный руководитель a[3], ... , a[d — 1] — непосредственный руководитель a[d]). Если наше количество групп меньше чем d, то какие-то два сотрудника из этой цепочки гарантированно окажутся в одной группе, что противоречит условию.\u003c/p\u003e\u003cp\u003eТеперь докажем, что мы можем разбить людей ровно на d групп. Давайте для каждого сотрудника посчитаем расстояние до такого его руководителя, у которого руководителей нет (то есть до начала его цепочки). Всех людей с расстоянием 0 кинем в первую группу, с расстоянием 1 — во вторую группу, ..., с расстоянием d — 1 — в d-ую. Таким образом люди из одной цепочки гарантированно будут в одной группе. Значит, разбиение ровно на d групп возможно, и d является ответом.\u003c/p\u003e\u003cp\u003eСложность алгоритма O(N)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача С\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗаметим, что порядок перестановок, который описан в условии — это лексикографический порядок (тот самый, по которому слова сортируются в словарях). Нам выгодно минимизировать число на первой позиции, если таких вариантов несколько — то минимизировать число на второй позиции и т.д.\u003c/p\u003e\u003cp\u003eДавайте посмотрим на таблицу A как на таблицу смежности такого графа. Пусть позиции в перестановке соответствует вершина графа, а ребро соответсвует возможности обмена между этими двумя позициями.\u003c/p\u003e\u003cp\u003eНайдем в этом графе все компоненты связности и будем решать задачу для каждой компоненты независимо (действительно, числа в разных компонентах никак не влияют друг на друга). Итак, у нас есть очередная компонента, для которой мы знаем множество позиций и множество чисел, которые на этих позициях стоят. Заметим, что серией обменов мы можем поменять местами числа на двух любых позициях каждой компоненты. Так давайте самое маленькое число в компоненте поставим на позицию с самым маленьким индексом, второе по величине число — на позицию со вторым по величине индексом и так далее. \u003c/p\u003e\u003cp\u003eТак поступим для всех компонент связности, и таким образом найдем ответ.\u003c/p\u003e\u003cp\u003eСложность алгоритма \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача D\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eДавайте сведем задачу к графовой.\u003c/p\u003e\u003cp\u003eЗаметим, что если число на дисплее больше либо равно чем m — умножать на 2 его уже не выгодно. Значит, на дисплее никогда не будет числа, которое больше либо равно 2m (кроме случая, когда n\u0026gt;\u003d2m).\u003c/p\u003e\u003cp\u003eПостроим такой граф: числу на дисплее соответсвутет вершина графа. Ориентированным ребрам веса 1 соответствуют переходы между числами (то есть, от вершины a есть переходы к a — 1 и к 2*a). В таком графе при помощи bfs найдем кратчайшее расстояние от n к m. Оно и будет ответом на задачу.\u003c/p\u003e\u003cp\u003eСложность алгоритма — O(n+m).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача E\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗадачка не на графы :) Давайте мысленно раскрасим нашу доску в шахматном порядке. Будем ставить белую фигурку на белую клеточку, а черную — на черную клеточку. Таким образом, мы выполним все условия задачи.\u003c/p\u003e\u003cp\u003eСложность алгоритма — O(n*m)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача F\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eДавайте построим такой граф. Каждому сотруднику соответствует вершина. Между двумя сотрудниками есть ребро тогда и только тогда, если они общаются на одном языке. Заметим, что сотрудники из одной компоненты связности могут общаться между собой, а из разных — не могут. \u003c/p\u003e\u003cp\u003eТеперь у нас есть два случая:\u003c/p\u003e\u003cp\u003e1) Никто из сотрудников не знает хотя бы 1 язык (все не знают ничего). Тогда, очевидно, ответ — количество сотрудников (все учат какой-то один язык)\u003c/p\u003e\u003cp\u003e2) Кто-то знает хотя бы один язык. Пусть k — количество компонент связности в описанном выше графе. Тогда ответ равен k — 1. Почему это так? Выберем какую-то кмпоненту связности, в которой сотрудники знают хотя бы один какой-то язык, и заставим по одному человеку из остальных компонент выучить именно этот язык. Также легко видеть, что более оптимального ответа тут не достичь.\u003c/p\u003e\u003cp\u003eСложность алгоритма — O(n*m) либо \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003ci\u003em\u003c/i\u003e)\u003c/span\u003e в зависимости от реализации\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача G\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eДавайте посчитаем количество свободных клеточек, пусть оно равно s. Тогда давайте решим задачу наоборот: не будем искать k клеток, куда можно поставить стены, а найдем s-k клеток, образующих одну компоненту связности, а в остальные k поставим стены. Сделать это можно обычным dfs/bfs, запущенным из любой свободной клетки.\u003c/p\u003e\u003cp\u003eСложность алгоритма O(n*m)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача H\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eПостроим такой граф. Каждому сугробу соотвествует вершина. Между сугробами есть ребро, если у них равна координата x, либо если у них равна координата y. Тогда в пределах одной компоненты мы можем попасть от любого сугроба к любому другому, между сугробами из разных компонент перемещатся вообще не можем. \u003c/p\u003e\u003cp\u003eТеперь утверждается, что ответ, как и в задаче F, равен k — 1, k — количество компонент связности. Корректность этого утверждения следует из самого построения. Рассмотрим две какие-то компоненты, пусть в них есть сугробы (x1, y1) и (x2, y2) соответственно. Построим сугроб (x1, y2) и таким образом соединим эти две компоненты в одну. Легко видеть, что таких операций мы сделаем ровно k — 1.\u003c/p\u003e\u003cp\u003eСложность алгоритма — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача I\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eНесложная задача, которую почему-то никто не решил.\u003c/p\u003e\u003cp\u003eПостроим граф, в которому корпусу соответсвует вершина, между корпусами есть ребро, если их соединяет труба. Запустим dfs из тех корпусов, в которые не входит ни одна труба и при этом из них выходит хотя бы 1 труба. Каждому такому корпусу соответствует ровно 1 корпус, в который входит труба, но из которого ничего не выходит. В нашем dfs будем считать минимальный диаметр на пути между этими корпусами. Именно эти два корпуса и посчитанный диаметр войдут в ответ.\u003c/p\u003e\u003cp\u003eСложность алгоритма — O(n)\u003c/p\u003e\u003c/div\u003e","tags":[]}}