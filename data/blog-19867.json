{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1440021435,"rating":17,"authorHandle":"Musin","modificationTimeSeconds":1440073376,"id":19867,"title":"\u003cp\u003eПочему я полюбил сортировку подсчётом\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eРешил я как-то на ночь порешать пару задач из архива и наткнулся вот на такое чудо: \u003ca href\u003d\"/contest/439/problem/B\" title\u003d\"Codeforces Round 251 (Div. 2)\"\u003e439B - Devu, the Dumb Guy\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЧитаю задачу и думаю, что она делает на месте задачи B? Разве можно придумать задачу проще этой, засунуть её в тот же контест и поставить на место задачи А? Видимо можно, не знаю. Я решил сначала написать решение этой задачи чтобы убедиться, что я правильно её понял.\u003c/p\u003e\u003cp\u003eПервый раз я написал задачу на интах и в конце заменил инты на лонги. Получил WA на 8 тесте. Так как я не привык сразу же лезть в детали посылки и смотреть, что за тест такой сломал моё решение, сначала я поковырялся в своём коде и только после того, как не нашёл ничего неверного, полез смотреть детали посылки. И что я там вижу? Каким-то странным образом отправилось решение на интах и получилось переполнение. Ладно, едем дальше.\u003c/p\u003e\u003cp\u003eВторой раз я отправил решение на лонгах и наблюдал, как стремительно растёт циферка в надписи \u003cem\u003eВыполняется на тесте \u003cstrong\u003ex\u003c/strong\u003e\u003c/em\u003e Увы, но я получил TL на тесте 29. Было обидно, вот честно. Опять же я полез в свой код, только уже искать не баг, а пути оптимизации. Решил вместо \u003cem\u003eArrays.sort()\u003c/em\u003e, который примитивы сортирует quicksort\u0027ом, написать сортировку подсчётом, благо в худшем случае я потрачу на \u003cstrong\u003eN\u003c/strong\u003e памяти больше и ускорю сортировку примерно в \u003cstrong\u003elog N\u003c/strong\u003e раз (напомню, \u003cstrong\u003e1 \u0026lt;\u003d N \u0026lt;\u003d 10^5\u003c/strong\u003e, \u003cstrong\u003e0 \u0026lt;\u003d log N \u0026lt; 17\u003c/strong\u003e).\u003c/p\u003e\u003cp\u003eИ что на этот раз? Решение отработало \u003cstrong\u003eболее чем в 10 раз быстрее\u003c/strong\u003e, чем с \u003cem\u003eArrays.sort()\u003c/em\u003e. Всё дело, конечно, в асимптотике \u003cstrong\u003eO(N^2)\u003c/strong\u003e при сортировке quicksort\u0027ом в худшем случае.\u003c/p\u003e\u003cp\u003eЕсли так прикинуть, на яве тоже должно всё решаться на уровне библиотечных алгоритмов. Замена массива \u003cem\u003eint[]\u003c/em\u003e на \u003cem\u003eList\u0026lt;Integer\u0026gt;\u003c/em\u003e это подтвердила. Ведь \u003cem\u003eCollections.sort()\u003c/em\u003e, применяемый для листов, использует алгоритм сортировки слиянием (или, что чаще случается, TimSort\u0027ом). Использовав такой подход, я замедлил своё решение примерно в 1.5-2 раза, но избавился от сортировки подсчётом.\u003c/p\u003e\u003cp\u003eА теперь давайте вспомним, что в Java 8 есть такая замечательная вещь как \u003cem\u003eStream API\u003c/em\u003e. Использовав её в этой задаче, мы можем ввести данные, отсортировать их и собрать в один список. Также в \u003cem\u003eStream API\u003c/em\u003e есть версия стрима, которая работает с лонгами, тем самым хранит в себе не ссылки, а примитивы, к тому же обладает рядом дополнительных методов. К слову, такая версия сортирует лонги методом быстрой сортировки (в то время как объектный стрим сортирует так же, как \u003cem\u003eCollections.sort()\u003c/em\u003e), и мы можем наблюдать, как решение ломается (или чинится) из-за того, что мы всего лишь поменяли местами две строки:\u003cbr /\u003e \u003cem\u003eboxed()\u003c/em\u003e — запаковывает стрим примитивов в объектный (LongStream -\u0026gt; Stream\u0026lt;Long\u0026gt;)\u003cbr /\u003e \u003cem\u003esorted()\u003c/em\u003e — собственно, сортирует стрим\u003c/p\u003e\u003cp\u003eДумаю, нулевая версия, основанная на интах, никому не будет интересна, вот все последующие версии:\u003cbr /\u003e Array TL: \u003ca href\u003d\"/contest/439/submission/12608743\" title\u003d\"Submission 12608743 by Musin\"\u003e12608743\u003c/a\u003e\u003cbr /\u003e Array AC: \u003ca href\u003d\"/contest/439/submission/12608824\" title\u003d\"Submission 12608824 by Musin\"\u003e12608824\u003c/a\u003e\u003cbr /\u003e Stream TL: \u003ca href\u003d\"/contest/439/submission/12609313\" title\u003d\"Submission 12609313 by Musin\"\u003e12609313\u003c/a\u003e\u003cbr /\u003e Stream AC: \u003ca href\u003d\"/contest/439/submission/12609319\" title\u003d\"Submission 12609319 by Musin\"\u003e12609319\u003c/a\u003e\u003c/p\u003e\u003cp\u003eВерсия автора (C++): \u003ca href\u003d\"/contest/439/submission/6814439\" title\u003d\"Submission 6814439 by PraveenDhinwa\"\u003e6814439\u003c/a\u003e\u003cbr /\u003e Он использовал \u003cem\u003estd::sort\u003c/em\u003e. Практически полный аналог моего первого решения.\u003c/p\u003e\u003cp\u003eЧто я вынес из этого и хочу сказать вам:\u003c/p\u003e\u003cp\u003eЕсли у вас есть риск влететь в ТЛ и в коде есть сортировка, при этом у вас есть запас по памяти и эту сортировку можно выполнить методом сортировки подсчётом, используйте его. Вы съедите немного больше памяти, но зато будете уверены, что если ваш алгоритм не заходит, значит дело, скорее всего, не в сортировке. Да и это к тому же сортировка за \u003cstrong\u003eO(N + макс. значение N)\u003c/strong\u003e без единого сравнения.\u003c/p\u003e\u003cp\u003eВсем, кто дочитал, спасибо. \u003d)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD 1:\u003c/strong\u003e Как правильно заметил \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Gassa\" title\u003d\"International master Gassa\"\u003eGassa\u003c/a\u003e, вывод получился не совсем такой, какой я собирался вынести в начале написания этой статьи, поэтому добавлю:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eПроблема: в Java встроенная сортировка примитивных типов может работать за квадрат.\u003c/li\u003e   \u003cli\u003eСтандартное решение: использовать сортировку объектов за \u003cstrong\u003eO(N log N)\u003c/strong\u003e.\u003c/li\u003e   \u003cli\u003eПредлагаемое решение: использовать сортировку подсчётом там, где это будет быстрее. (Кстати, в очень многих задачах)\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eТакже аналогичное обсуждение, оказывается, было здесь: \u003ca href\u003d\"//codeforces.com/blog/entry/12833\"\u003elink\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["java","сортировка","anti-quicksort"]}}