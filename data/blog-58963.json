{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1523939219,"rating":0,"authorHandle":"Silence_for_Melody","modificationTimeSeconds":1523942199,"id":58963,"title":"\u003cp\u003eHelp with Google Code Jam 2018 Round 1A Problem C\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi Codeforces.\u003c/p\u003e\u003cp\u003eOn friday I participated in the round 1A of the GCJ but I could not pass the third problem. Even the easy set test. Here are my two codes. \u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://codejam.withgoogle.com/2018/challenges/0000000000007883/dashboard/000000000002fff7\"\u003ePROBLEM\u003c/a\u003e\u003c/p\u003e\u003cp\u003eEasy case \u003ca href\u003d\"https://pastebin.com/5cn3vj2D\"\u003eLINK\u003c/a\u003e. Full case \u003ca href\u003d\"https://pastebin.com/mWxGHL6f\"\u003eLINK\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eIn the easy one, I just did what the editorial said. However, I got WA repeatedly (15 submissions). \u003c/p\u003e\u003cp\u003eFor the full set, my idea is the following. First rest from P the perimeter of all the rectangles and now I have P\u0027. Now, each rectangle i add to the answer 0 if it is not cut, or a number in range \u003ccode\u003e[ L[i], R[i] ]\u003c/code\u003e where \u003ccode\u003eL[i] \u003d 2 * min (W[i], H[i])\u003c/code\u003e and \u003ccode\u003eR[i] \u003d 2 * hypot (W[i], H[i])\u003c/code\u003e if is cut. The idea is to choose a subset of the rectangles whom will be cut and the sum of additional perimeters must not exceed P\u0027. \u003c/p\u003e\u003cp\u003eNow, each subset j generates an interval \u003ccode\u003e[ L_subset[j], R_subset[j] ]\u003c/code\u003e. However, these intervals will always start (left side value) with at most \u003ccode\u003e250 * 100\u003c/code\u003e (maximum side length and maximum quantity of rectangles). Therefore, I did a DP where \u003ccode\u003eDP[i]\u003c/code\u003e is the maximum right side of an interval for the left side be exactly i. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eStart DP[i] \u003d -INF\nDP[0] \u003d 0\nFOR i in range(0, N):\n\tFOR leftside in range(0,25001)\n\t\tDP[leftside] \u003d max (DP[leftside] , DP[leftside â€“ L[i] ] + R[i] ) \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow, for each \u003ccode\u003eDP[i]\u003c/code\u003e for \u003ccode\u003ei \u0026lt;\u003d P\u0027\u003c/code\u003e I checked if \u003ccode\u003eDP[i] \u0026gt;\u003d P\u0027\u003c/code\u003e, then the answer is P as this could be reached. Otherwise, the answer is \u003ccode\u003emax DP[i]\u003c/code\u003e for \u003ccode\u003ei \u0026lt;\u003d P\u0027\u003c/code\u003e plus the sum of perimeters of all rectangles.\u003c/p\u003e\u003cp\u003eThe complexity of this idea is 100 * 100 * 250. Could give TLE, I don\u0027t know because the system always gave me WA.\u003c/p\u003e\u003cp\u003eI spend all the weekend tring to find out why my codes gave me WA, now I need your help. Many thanks\u003c/p\u003e\u003c/div\u003e","tags":["gcj"]}}