{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1413484822,"rating":45,"authorHandle":"KhaustovPavel","modificationTimeSeconds":1413488419,"id":14307,"title":"\u003cp\u003eCodeforces Round #273 (Div. 2) :: разбор задач\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/478/problem/A\" title\u003d\"Codeforces Round 273 (Div. 2)\"\u003e478A - Начальная ставка\u003c/a\u003e\u003c/p\u003e\u003cp\u003eДля решения задачи важно заметить, что в ходе игры количество монет на столе меняться не может. Суммарное количество монет на столе после того, как сделаны ставки, остается неизменным. Следовательно, разделив суммарное количество монет на столе на количество игроков, можно получить начальную ставку каждого из них. Если разделить без остатка невозможно, то такой итог игры невозможен. Стоит обратить внимание на то, что начальная ставка каждого из игроков должна быть отлична от нуля, следовательно, ноль никогда не может являться ответом.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/478/problem/B\" title\u003d\"Codeforces Round 273 (Div. 2)\"\u003e478B - Случайные команды\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЕсли переформулировать задачу в терминах теории графов, то ее можно сформулировать следующим образом: Имеется граф, состоящий из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e вершин и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e компонент связности. Внутри каждой компоненты связности каждая пара вершин этой компоненты связана ребром. Другими словами, каждая компонента связности является полносвязной. Какое наименьшее и какое наибольшее количество ребер может содержать такой граф? Рассмотрим процесс построения графа из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e вершин и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e компонент связности. Для начала предположим, что каждая из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e компонент содержит ровно одну вершину. Остается распределить оставшиеся \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003em\u003c/i\u003e\u003c/span\u003e вершин так, чтобы минимизировать или максимизировать количество ребер. Заметим, что при добавлении новой вершины в компоненту связности размера \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, количество ребер увеличивается на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e (новая вершина соединяется с каждой из уже существующих одним ребром). Следовательно, для того, чтобы минимизировать количество образованных ребер на каждом шаге, требуется каждый раз добавлять вершину в компоненту связности наименьшего размера. Если действовать согласно такой стратегии, то после распределения вершин по компонентам связности появится \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7d/60/7d60bbe01f5057a0d9549e190026eff2522b1574.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e компонент размера \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5f/90/5f909a71e0d330922ef0872db887f16e37ede8bc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e и \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/14/3a/143ad5585fa7de55cef805fd8323e3133c6fdf18.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e компонент размера \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ee/c3/eec3373ed967f1be9ab323b12b8427bb4f845f61.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Аналогично, для того, чтобы максимизировать количество ребер, на каждом шаге необходимо добавлять очередную вершину в компонентну связности наибольшего размера. Если действовать согласно такой стратегии, то образуется одна компонента связности размера \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003em\u003c/i\u003e + 1\u003c/span\u003e, оставшиеся компоненты связности будут состоять из одной вершины. Зная количество компонент связности и их размеры, можно посчитать общее количество ребер. Для полносвязной компоненты, состоящей из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e вершин, количество ребер равняется \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d7/d0/d7d0dffd4e53ff7df8529af18e4184a1b7a9dd9a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Следует помнить про необходимость использовать 64-битный тип данных для хранения количества ребер, которое квадратично зависит от значения \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/478/problem/C\" title\u003d\"Codeforces Round 273 (Div. 2)\"\u003e478C - Украшение столов\u003c/a\u003e\u003c/p\u003e\u003cp\u003eРассмотрим ситуацию, когда величина \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e, \u003ci\u003eg\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e) - \u003ci\u003emin\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e, \u003ci\u003eg\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e) ≤ 1\u003c/span\u003e, в таком случае, очевидно, ответ равен \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bf/52/bf52f340e07d70cc51ed8ce35f0f4a012027b13f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Мы всегда можем украсить столько столов тремя воздушными шарами разных цветов. Очевидно, что оставшееся количество шаров будет меньше трех и, следовательно, не может быть использовано для украшения стола в любом случае. Все оставшиеся случаи имеет смысл свести к ранее рассмотренному. Если есть один цвет такой, что количество шариков этого цвета больше, чем суммарное количество шариков для оставшихся двух цветов, то всега выгодно украшать стол двумя шарами этого цвета и одним шаром того из оставшихся цветов, которого больше на данный момент. Далее можно разными способами группировать операции и выполнять более одной операции за раз. Другим решением можно назвать тот факт, что ответ будет отличен от \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bf/52/bf52f340e07d70cc51ed8ce35f0f4a012027b13f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, но только тогда, когда \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e, \u003ci\u003eg\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e) ≥ 2·(\u003ci\u003er\u003c/i\u003e + \u003ci\u003eg\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e - \u003ci\u003emax\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e, \u003ci\u003eg\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e))\u003c/span\u003e, в таком случае ответ \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e + \u003ci\u003eg\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e - \u003ci\u003emax\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e, \u003ci\u003eg\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e. В этом случае шарики двух наиболее редких цветов закончатся раньше, чем шарики одного наиболее популярного, если украшать каждый стол с использованием двух шариков наиболее популярного цвета.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/478/problem/D\" title\u003d\"Codeforces Round 273 (Div. 2)\"\u003e478D - Красно-зеленые башни\u003c/a\u003e\u003c/p\u003e\u003cp\u003eДля начала можно заметить, что для того, чтобы построить красно-зеленую башню высоты \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e потребуется \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9e/c6/9ec678ec301e8e22826d1850268f01589fd9ec80.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e кубиков. Следовательно, высота полученной башни для заданных ограничений никогда не превысит \u003cspan class\u003d\"tex-span\"\u003e893\u003c/span\u003e. Эту высоту можно определить заранее, если предположить, что все кубики одного цвета. Попробуйте доказать это самостоятельно. Далее можно решить задачу с использованием динамического программирования. Пусть \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003et\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e — количество способов собрать башню наибольшей высоты, если собрано \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e верхних этажей и остались незадействованными \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e красных кубиков. Среди аргументов функции нет количества оставшихся зеленых кубиков \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003c/span\u003e — его можно однозначно определить из значений \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/2f/79/2f7971cfcc3d53d290f5f42d167bd977d908a570.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e — изначальное количество красных и зеленых кубиков, соответственно. Ну а дальше следует рассмотреть лишь два перехода: пострить \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e + 1\u003c/span\u003e-ый уровень из красных или из зеленых кубиков: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003et\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e) \u003d \u003ci\u003eF\u003c/i\u003e(\u003ci\u003et\u003c/i\u003e + 1, \u003ci\u003er\u003c/i\u003e - \u003ci\u003et\u003c/i\u003e) + \u003ci\u003eF\u003c/i\u003e(\u003ci\u003et\u003c/i\u003e + 1, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e. Очевидно, кешировать данные в массиве размера \u003cspan class\u003d\"tex-span\"\u003e893 × 2·10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e — не лучшая затея. В таком случае можно подсчитывать значения функции для всех значений \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e от \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e, храня в памяти только значения для текущего значения \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e и для предыдущего, от которого оно будет зависеть.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/478/problem/E\" title\u003d\"Codeforces Round 273 (Div. 2)\"\u003e478E - Волнистые числа\u003c/a\u003e\u003c/p\u003e\u003cp\u003eДля решения этой задачи необходимо было заметить, что волнистых чисел на интервале от \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e до \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e7\u003c/sup\u003e\u003c/span\u003e намного меньше, чем \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e7\u003c/sup\u003e\u003c/span\u003e. В таком случае можно решить задачу с использованием подхода meet-in-the-middle. То есть отдельно решить эту задачу для первых семи цифр ответа, и для последних семи цифр ответа. Для этого потребуется отдельно сгенерировать все волнистые числа на интервале от \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e до \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e7\u003c/sup\u003e\u003c/span\u003e, которые начинаются с возрастания двух соседних цифр, и аналогичные волнистые числа, которые начинаются с убывания двух соседних цифр. Дальше для каждой первой половины мы можем посчитать \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — ее остаток от деления на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e и, затем, определить количество подходящих вторых половин, которые должны иметь остаток от деления равный \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f8/58/f85870770811331e7823f243e9feeee559e07b8e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eДля задачи было установлено ограничение времени равное 1.5 сек. На самом деле, если написать решение с подходом meet-in-the-middle достаточно оптимально, то решению потребуется гораздо меньше времени. \u003ca href\u003d\"http://pastebin.com/DKhxef4N\"\u003eПриведенная авторская реализация\u003c/a\u003e (\u003ca href\u003d\"/contest/478/submission/8271836\" title\u003d\"Посылка 8271836 от KhaustovPavel\"\u003e8271836\u003c/a\u003e) умеет решать аналогичную задачу для \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003en\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e16\u003c/sup\u003e\u003c/span\u003e примерно за 2.5 сек.\u003c/p\u003e\u003c/div\u003e","tags":["codeforces round #273","tutorial","273"]}}