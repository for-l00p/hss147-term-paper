{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1497932069,"rating":9,"authorHandle":"akim_","modificationTimeSeconds":1497941651,"id":52766,"title":"\u003cp\u003eDay 1. Advanced Level. Summer Camp 2017. Разбор задач\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eЗадача A (\u003ca href\u003d\"/group/AqlYxpxSfD/contest/585/problem/D\" title\u003d\"Codeforces Round 325 (Div. 1)\"\u003e585D - Lizard Era: Beginning\u003c/a\u003e)\u003c/h3\u003e\u003cp\u003eДля решения этой задачи воспользуемся приемом \u003cstrong\u003emeet-in-the-middle\u003c/strong\u003e. А именно переберем для первых \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e / 2\u003c/span\u003e (первая половина) заданий с какими спутницами главный герой будет путешествовать. Пусть при этом симпатия первой спутницы оказалась равна \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, второй — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, а третьей \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e. Пусть существует способ выбрать спутниц для последующих \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e / 2\u003c/span\u003e (вторая половина) заданий так и пусть симпатии при этом будут равны \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u0027,  \u003ci\u003eb\u003c/i\u003e\u0027,  \u003ci\u003ec\u003c/i\u003e\u0027\u003c/span\u003e. Тогда, чтобы по всем заданиям суммы симпатий были одинаковы необходимо и достаточно, чтобы \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e  -  \u003ci\u003eb\u003c/i\u003e  \u003d  \u003ci\u003eb\u003c/i\u003e\u0027  -  \u003ci\u003ea\u003c/i\u003e\u0027\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e  -  \u003ci\u003ec\u003c/i\u003e  \u003d  \u003ci\u003ec\u003c/i\u003e\u0027  -  \u003ci\u003eb\u003c/i\u003e\u0027\u003c/span\u003e. Теперь для решения задачи достаточно перебрать первую половину и сохранить в некоторой структуре данных тройки чисел \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e  -  \u003ci\u003eb\u003c/i\u003e,  \u003ci\u003eb\u003c/i\u003e  -  \u003ci\u003ec\u003c/i\u003e,  \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e (третье число нужно для максимизации ответа в случае равенства). Далее нужно перебрать вторую половину и найти в структуре данных значения \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u0027  -  \u003ci\u003ea\u003c/i\u003e\u0027,  \u003ci\u003ec\u003c/i\u003e\u0027  -  \u003ci\u003eb\u003c/i\u003e\u0027,  \u003ci\u003em\u003c/i\u003e\u003c/span\u003e, где m — максимальное третье значение которое есть в структуре данных. В качестве структуры данных можно использовать \u003cem\u003emap \u0026lt; pair \u0026lt; int, int \u0026gt; , int \u0026gt;\u003c/em\u003e  в языке C++, первые два числа это значение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e  -  \u003ci\u003eb\u003c/i\u003e,  \u003ci\u003eb\u003c/i\u003e  -  \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e, а третье — максимальное a соответствующее первым двум. Также можно все тройки сложить в один большой массив, отсортировать его и бинарным поиском находить необходимые значения.\u003cbr /\u003eАсимптотическая сложность решения: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(3\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e / 2\u003c/sup\u003e\u003ci\u003elogC\u003c/i\u003e)\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elogC\u003c/i\u003e\u003c/span\u003e — константа, появляющаяся вместе со структурой данных. \u003c/p\u003e\u003ch3\u003eЗадача B (\u003ca href\u003d\"/group/AqlYxpxSfD/contest/100123/problem/A\" title\u003d\"2012-2013 Тренировка СПбГУ B 13 Динамическое программирование по профилю\"\u003e100123A - Симпатичные узоры\u003c/a\u003e)\u003c/h3\u003e\u003cp\u003eВ данной задаче требуется применить динамику по изломанному профилю. Для начала, повернем поле, если количество столбцов меньше, чем количество рядов. Пробежимся по клеткам каждого столбца и переберем их цвет. Заметим, что для проверки корректности нашей закраски нам требуется ровно \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + 1\u003c/span\u003e предыдущих клеток. Значит состоянием динамики у нас будут текущий столбец, маска из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + 1\u003c/span\u003e битов и ряд, в котором мы закрашивали клетку последний раз. Итоговая сложность задачи \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e) + 1\u003c/sup\u003e * \u003ci\u003en\u003c/i\u003e * \u003ci\u003em\u003c/i\u003e\u003c/span\u003e \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eПример реализации:\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#pragma comment(linker, \u0026quot;/stack:20000000\u0026quot;)\n#pragma GCC optimize(\u0026quot;Ofast\u0026quot;)\n#pragma GCC target(\u0026quot;sse,sse2,sse3,sse3,sse4,popcnt,abm,mmx\u0026quot;)\n\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;x86intrin.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\nusing namespace __gnu_pbds;\n// tree\u0026lt;key, mapped \u003d null_type, cmp \u003d less\u0026lt;key\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; name; order_of_key find_by_order\n \nusing namespace std;\n\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define abs(a) ((a) \u0026lt; 0 ? -(a) : (a))\n#define sqr(a) ((a) * (a))\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ninline pair\u0026lt;pair\u0026lt;bool, bool\u0026gt;, pair\u0026lt;string, bool\u0026gt; \u0026gt; useinout();\n\n#ifdef SOL\ndouble starttime;\n#endif\n\nvoid initialization() {\n#ifdef SOL\n\tstarttime \u003d 1000. * clock() / CLOCKS_PER_SEC;\n\tif (useinout().fs.fs)\n\t\tfreopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\tif (useinout().fs.sc)\n\t\tfreopen(\u0026quot;output.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n#else\n\tsrand(__rdtsc());\n\tconst string file \u003d useinout().sc.fs;\n\tif (!file.empty()) {\n\t\tfreopen((file + \u0026quot;.in\u0026quot;).c_str(), \u0026quot;r\u0026quot;, stdin);\n\t\tfreopen((file + \u0026quot;.out\u0026quot;).c_str(), \u0026quot;w\u0026quot;, stdout);\n\t} else\n\tif(useinout().sc.sc) {\n\t\tfreopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t\tfreopen(\u0026quot;output.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\t}\n#endif\n}\n\nint solution();\n\nvoid finish(int exitval) {\n\tfflush(stdout);\n#ifdef SOL\n\tfprintf(stderr, \u0026quot;\\n-----------------\\nexit value: %d\\ntime: %.3lf ms\\n-----------------\\n\u0026quot;, exitval, 1000. * clock() / CLOCKS_PER_SEC - starttime);\n#endif\n}\n\nint main() {\n\tinitialization();\n\tfinish(solution());\n\treturn (0);\n}\n\nconst double eps \u003d 1e-9;\nconst int mod \u003d (int) (1 \u0026lt;\u0026lt; 30) + 1;\nconst double pi \u003d acos(-1.);\nconst int maxn \u003d 100100;\n\nuint dp[1 \u0026lt;\u0026lt; 18][18];\n\nvoid md(uint \u0026amp;u) {\n\tu -\u003d u \u0026lt; mod ? 0 : mod;\n}\n\nint solution() {\n\n\tint n, m;\n\tscanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m);\n\tif(n \u0026gt; m) swap(n, m);\n\n\tif(n \u003d\u003d 1) {\n\t\tuint ans \u003d 1;\n\t\tfor(int i \u003d 0; i \u0026lt; m; i++) {\n\t\t\tans \u003d ans * 2 % mod;\n\t\t}\n\t\tprintf(\u0026quot;%d\u0026quot;, ans);\n\t\treturn(0);\n\t}\n\n\tfor(int i \u003d 0; i \u0026lt; (1 \u0026lt;\u0026lt; (n + 1)); i++) {\n\t\t\tdp[i][0] \u003d 1;\n\t}\n\n\tfor(int i \u003d 1; i \u0026lt; m; i++) {\n\t\tfor(int k \u003d 0; k \u0026lt; n - 1; k++) {\n\t\t\tfor(int j \u003d 0; j \u0026lt; (1 \u0026lt;\u0026lt; (n + 1)); j++) {\n\t\t\t\tmd(dp[(j \u0026gt;\u0026gt; 1) + (0 \u0026lt;\u0026lt; n)][k + 1] +\u003d dp[j][k] * (((j \u0026gt;\u0026gt; 0) \u0026amp; 1) !\u003d 0 || ((j \u0026gt;\u0026gt; 1) \u0026amp; 1) !\u003d 0 || ((j \u0026gt;\u0026gt; n) \u0026amp; 1) !\u003d 0));\n\t\t\t\tmd(dp[(j \u0026gt;\u0026gt; 1) + (1 \u0026lt;\u0026lt; n)][k + 1] +\u003d dp[j][k] * (((j \u0026gt;\u0026gt; 0) \u0026amp; 1) !\u003d 1 || ((j \u0026gt;\u0026gt; 1) \u0026amp; 1) !\u003d 1 || ((j \u0026gt;\u0026gt; n) \u0026amp; 1) !\u003d 1));\n\t\t\t}\n\t\t}\n\t\tfor(int k \u003d 0; k \u0026lt; n - 1; k++) {\n\t\t\tfor(int j \u003d 0; j \u0026lt; (1 \u0026lt;\u0026lt; (n + 1)); j++) {\n\t\t\t\tdp[j][k] \u003d 0;\n\t\t\t}\n\t\t}\n\t\tfor(int j \u003d 0; j \u0026lt; (1 \u0026lt;\u0026lt; (n + 1)); j++) {\n\t\t\tmd(dp[(j \u0026gt;\u0026gt; 1) + (0 \u0026lt;\u0026lt; n)][0] +\u003d dp[j][n - 1]);\n\t\t\tmd(dp[(j \u0026gt;\u0026gt; 1) + (1 \u0026lt;\u0026lt; n)][0] +\u003d dp[j][n - 1]);\n\t\t}\n\t\tfor(int j \u003d 0; j \u0026lt; (1 \u0026lt;\u0026lt; (n + 1)); j++) {\n\t\t\tdp[j][n - 1] \u003d 0;\n\t\t}\n\t}\n\n\tuint ans \u003d 0;\n\tfor(int i \u003d 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); i++) {\n\t\tmd(ans +\u003d dp[i][0]);\n\t}\n\n\tprintf(\u0026quot;%d\u0026quot;, ans);\n\n\treturn (0);\n}\n\ninline pair\u0026lt;pair\u0026lt;bool, bool\u0026gt;, pair\u0026lt;string, bool\u0026gt; \u0026gt; useinout() {\n\treturn (mp(mp(0, 0), mp(\u0026quot;m3\u0026quot;, 0)));\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003eЗадача C (\u003ca href\u003d\"/group/AqlYxpxSfD/contest/100123/problem/E\" title\u003d\"2012-2013 Тренировка СПбГУ B 13 Динамическое программирование по профилю\"\u003e100123E - Подарок Пятачку\u003c/a\u003e)\u003c/h3\u003e\u003cp\u003eДля решения этой задачи нужно написать обычную динамику по профилю. Переберем маски, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e2\u003c/span\u003e отвечающие за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e столбцы соответственно. Тогда \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1][\u003ci\u003em\u003c/i\u003e2] +  \u003d \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003em\u003c/i\u003e1]\u003c/span\u003e, если все квадратики \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003ex\u003c/i\u003e2\u003c/span\u003e в этих масках являются хорошими. Для ускорения решения предподсчитаем для всех масок \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e2\u003c/span\u003e, можно ли ставить их возле. Ответ — сумма массива \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e]\u003c/span\u003e.\u003cbr /\u003eАсимптотическая сложность: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003em\u003c/i\u003e * 2\u003c/sup\u003e * \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003ch3\u003eЗадача D (\u003ca href\u003d\"/group/AqlYxpxSfD/contest/100123/problem/I\" title\u003d\"2012-2013 Тренировка СПбГУ B 13 Динамическое программирование по профилю\"\u003e100123I - Палатка\u003c/a\u003e)\u003c/h3\u003e\u003cp\u003eВ этой задаче требовалось заметить, что если мы ложим спальное место не параллельно стороне, равной росту человека, то нам прийдется положить так еще \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e спальных, они будут образовывать квадрат. Значит мы можем написать простую динамику: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e - 1] + \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e - \u003ci\u003em\u003c/i\u003e]\u003c/span\u003e\u003cbr /\u003eАсимптотика: O(n)\u003c/p\u003e\u003ch3\u003eЗадача E (\u003ca href\u003d\"/group/AqlYxpxSfD/contest/525/problem/E\" title\u003d\"Codeforces Round 297 (Div. 2)\"\u003e525E - Аня и кубики\u003c/a\u003e)\u003c/h3\u003e\u003cp\u003eДля решения данной задачи воспользуемся методом \u003cstrong\u003emeet-in-the-middle\u003c/strong\u003e. Отсортируем заданный массив по возрастанию и разобьем пополам. В первой половине оставим первые \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e  /  2\u003c/span\u003e элементов, во второй все остальные. Переберем все подмаски всех масок элементов из первой половины. То есть переберем какие кубики из первой половины мы возьмем и на какие из них наклеим восклицательные знаки. Таким образом мы переберем все возможные суммы, которые мы можем набрать с помощью кубиков из первой половины. Пусть для текущей подмаски мы наберем сумму \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esumlf\u003c/i\u003e\u003c/span\u003e, используя \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etlf\u003c/i\u003e\u003c/span\u003e восклицательных знаков. Для хранения всех сумм используем ассоциативные массивы \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e  \u0026lt;  \u003ci\u003elonglong\u003c/i\u003e  \u0026gt;  \u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e + 1]\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e — количество восклицательных знаков, которое у нас есть изначально. Тогда для текущей подмаски нужно сделать \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003etlf\u003c/i\u003e][\u003ci\u003esumlf\u003c/i\u003e] +  + \u003c/span\u003e. После этого, аналогичным образом, переберем все подмаски всех масок элементов из правой части. Пусть для текущей подмаски сумма равна \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esumrg\u003c/i\u003e\u003c/span\u003e, а количество использованных восклицательных знаков \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etrg\u003c/i\u003e\u003c/span\u003e. Тогда в левой части нам нужно набрать сумму \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003es\u003c/i\u003e  -  \u003ci\u003esumrg\u003c/i\u003e)\u003c/span\u003e, используя не более \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e  -  \u003ci\u003etrg\u003c/i\u003e)\u003c/span\u003e восклицательных знаков, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e — сумма, которую необходимо набрать по условию задачи. Тогда переберем сколько восклицательных знаков будем использовать в левой части (пусть это будем переменная \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecur\u003c/i\u003e\u003c/span\u003e) и прибавим к ответу \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ecur\u003c/i\u003e][\u003ci\u003es\u003c/i\u003e  -  \u003ci\u003esumrg\u003c/i\u003e]\u003c/span\u003e. Для ускорения работы программы можно сначала проверить есть ли такой элемент в нашем массиве, то есть только если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ecur\u003c/i\u003e].\u003ci\u003ecount\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e  -  \u003ci\u003esumrg\u003c/i\u003e)  \u003d  \u003ci\u003etrue\u003c/i\u003e\u003c/span\u003e увеличивать ответ. Для перебираемых подмасок можно отсекать перебор по текущей сумме для подмаски и по количеству восклицательных знаков для текущей подмаски. Также понятно, что не имеет смысле наклеивать восклицательные знаки на кубики на которых написаны числа большие \u003cspan class\u003d\"tex-span\"\u003e18\u003c/span\u003e, так как \u003cspan class\u003d\"tex-span\"\u003e19!\u003c/span\u003e точно больше чем \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e16\u003c/sup\u003e\u003c/span\u003e, что по условию является верхним ограничением для s. Асимптотика решения — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(3\u003csup class\u003d\"upper-index\"\u003e((\u003ci\u003en\u003c/i\u003e  +  1)  /  2)\u003c/sup\u003e  *  \u003ci\u003elog\u003c/i\u003e(\u003ci\u003emaxcnt\u003c/i\u003e)  *  \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e — количество кубиков, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emaxcnt\u003c/i\u003e\u003c/span\u003e — максимальный размер ассоциативного массива, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e — количество восклицательных знаков.\u003c/p\u003e\u003c/div\u003e","tags":[]}}