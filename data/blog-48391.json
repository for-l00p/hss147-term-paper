{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1479213884,"rating":1,"authorHandle":"Slamur","modificationTimeSeconds":1479213928,"id":48391,"title":"\u003cp\u003eОценка времени работы и памяти\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eЧасто написать программу, считающую ответ на задачу, не так уж и сложно. Намного сложнее оказывается написать программу, считающую ответ, которая укладывается в ограничения по времени работы (Time Limit) и по используемой памяти (Memory Limit).\u003c/p\u003e\u003cp\u003eДавайте научимся оценивать время и память, необходимые вашему алгоритму для решения задачи. \u003cbr /\u003e\u003c/p\u003e\u003ch4\u003eВременная оценка.\u003c/h4\u003e\u003cp\u003eСамый частый способ оценки времени работы вашей программы — оценка количества простых операций. В настоящее время используется приблизительная оценка, что за 1 секунду выполняется порядка 10^8 операций.\u003c/p\u003e\u003cp\u003eНас не интересует точное количество операций, нас интересует лишь порядок. В идеале порядок количества операций должен быть на 1-2 порядка меньше максимума — тогда вам не придется думать о более точной оценке, и так будет понятно, что работает быстро. С другой стороны очевидно, что если программа выполняет порядка 10^10 операций, то в секунду она не уложится никак, да и в 2 секунды тоже) (здесь и далее мы будем рассматривать только работу на тестах, на которых программа выполняется максимально возможное время — оценка по худшему случаю).\u003c/p\u003e\u003cp\u003eОбозначим за T(N) — количество операций алгоритма, который принимает на вход вектор параметров N — N1, N2, ..., NK. Предположим, что мы также знаем функцию F(N), что T(N) \u0026lt;\u003d F(N) * C для любых N, где C — какая-то независящая от N константа. Введем для такого случая обозначение, что T(N) \u003d O(F(N)) — \u0026quot;O большое\u0026quot;. Данное обозначение взято из высшей математики, а не из головы придумано)\u003c/p\u003e\u003cp\u003eОчевидно, что для одной T(N) существует бесконечно много F(N), что T(N) \u003d O(F(N)). Выберем те функции F1(N), F2(N), ..., FM(N), что \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e1. T(N) \u003d O(F1(N)) \u003d O(F2(N)) \u003d ... \u003d O(FM(N))\n2. F1(N) \u003d O(T(N)), F2(N) \u003d O(T(N)), ..., FM(N) \u003d O(T(N)).\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПример:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eT(N) \u003d 3 * N^2 - 2. \nF1(N) \u003d 5 * N^2, F2(N) \u003d N^2 / 2, F3(N) \u003d N^2 - N, ...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗаметим, что эти функции будут отличаться только линейными коэффициентами при слагаемых. Выберем среди данных функций F(N), такую что линейные коэффициенты при слагаемых старших порядков будут равны 1, при остальных — 0. Для примера выше подходящей функцией будет F(N) \u003d N^2: \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e- (3 * N^2 - 2) \u003d O(N^2);\n- (N^2) \u003d O(3 * N^2 - 2);\n- Коэффициент при слагаемом старшего порядка N^2 \u003d 1.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНазовем такую функцию F(N) асимптотикой алгоритма с количеством операций T(N). Теперь, чтобы оценить время работы программу, нам достаточно оценить ее асимптотику и, подставив в нее значения параметров на макс. тесте, выяснить порядок максимального числа операций.\u003c/p\u003e\u003cp\u003eРассмотрим асимптотики, с помощью комбинации которых можно задать асимптотику практически любой программы:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e1. O(1) - простейшая операция - +, *, обращение по индексу к массиву и так далее - вообще не зависит от N.\n2. O(logN) - логарифм от N. Растет очень медленно. Основание логарифма не пишут, так как log_a(b) \u003d log_c(b) / log_c(a), где 1 / log_c(a) - константа, не зависящая от b.\n3. O(N^k) - полиномиальная зависимость.\n4. O(a^N) - экспоненциальная зависимость. Здесь число a имеет значение, так как при переходе от a^n к b^n появляется коэффициент (a / b) ^ n, зависящий от n.\n5. O(N!) - факториал от N - очень быстро растет, но и решения с такой асимптотикой бывают.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eРаспишем частные случаи асимптотик и примерные значения N, при которых такая асимптотика еще позволит вам уложиться в 1 секунду:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e1. O(1) - любое N;\n2. O(logN) - любое N, влезающее в стандартные типы данных - слишком медленно растет :D\n3. O(N^(1 / 2)), O(N^(1 / 3)) - квадратный и кубический корни из N - растет медленно, но растет - 10^15-10^16 для квадратного корня и 10^18 для кубического;\n4. O(N) - \u0026quot;линия\u0026quot; - 10^7 - 10^8;\n5. O(N * logN) - \u0026quot;Н лог Н\u0026quot; - 10^5 - 10^6 (зависит от основания логарифма и опущенной константы).\n6. O(N * sqrt(N)) - 10^5.\n7. O(N^2) - \u0026quot;квадрат\u0026quot; - 10^4;\n8. O(N^3) - \u0026quot;куб\u0026quot; - 300 - 500;\n9. O(2^N), O(N * 2^N) - 20 - 24 (при 23-24 на грани).\n10. O(3^N) - примерно 14-16.\n11. O(1.5 ^ N) - 1.5 - приближение числа (1 + sqrt(5)) / 2 - это скорость роста значений чисел Фибоначчи.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eРассмотрим несколько частных примеров вычисления асимптотики:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e1. Последовательное выполнение алгоритмов.\n\n    function T(N) {\n       F(N);\n       G(N);\n    }  \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ таком случае асимптотика T(N) будет равна O(F(N)) \u003d O(G(N)) \u003d O(F(N) + G(N)).\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e2. Циклическое выполнение какого-либо алгоритма.\n\n    for (int i \u003d 0; i \u0026lt; M; ++i) {\n       F(N);\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПроводя аналогии с предыдущим примером, здесь мы M раз выполняем алгоритм с асимптотикой O(F(N)), итого O(M) * O(F(N)) \u003d O(M * F(N)).\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e3. Циклическое уменьшение/увеличение величины в A раз.\n\n    function F(N) {\n       result \u003d 0;\n       while (N \u0026gt; 0) {\n         N /\u003d A;\n       }\n\n       return result;\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗдесь result будет равно минимальной степени A, при которой A^(result — 1) \u0026lt; N \u0026lt;\u003d A^(result), откуда result \u003d log_A(N) и асимптотика F(N) \u003d O(result) \u003d O(logN).\u003c/p\u003e\u003cp\u003eДля закрепления материала предлагаю вам придумать алгоритмы решения следующих задач и оценить их асимптотику:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e1. Найти сумму элементов массива A длины N.\n2. Найти максимум, минимум в массиве A длины N, найти и максимум, и минимум одновременно.\n3. Найти количества цифр в числе.\n4. Найти точку M - центр отрезка AB по координатам точек A и B.\n5. Найти индекс строки матрицы A размера NxM с минимальной суммой.\n6. Сравнить лексикографически (в алфавитном порядке) две строки S1 и S2.\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003eОценка памяти.\u003c/h4\u003e\u003cp\u003eКоличество памяти, используемой программой, оценить попроще — достаточно оценить общую память, занятую всеми значениями, используемыми в вашей программе. В основном, много значений хранится в \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e- Многомерных массивах\n- В структурах, где элемент хранит ссылку на несколько других элементов структуры.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОценивается для них одинаково — оценивается максимальное число элементов в массиве/структуре и умножается на размер элемента в байтах.\u003c/p\u003e\u003cp\u003eПример:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint[][][] a \u003d new int[n][m][];\nfor (int i \u003d 0; i \u0026lt; n; ++i) {\n    for (int j \u003d 0; j \u0026lt; m; ++j) {\n       a[i][j] \u003d new int[j+1];\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ таком случае в массив занимает N * (1 + 2 + ... + M) * sizeof(int) \u003d N * M * (M + 1) / 2 * sizeof(int) \u003d O(N * M^2 * sizeof(int)) памяти.\u003c/p\u003e\u003c/div\u003e","tags":["самара","асимптотика"]}}