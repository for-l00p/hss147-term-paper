{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1503849609,"rating":2,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1503849609,"id":54097,"title":"\u003cp\u003eNotes on Codeforces Beta Round #72, A, B, C, D, E\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/84/problem/A\" title\u003d\"Codeforces Beta Round 72 (Div. 2 Only)\"\u003e84A - Toy Army\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe strict proof seems to be a little complicated as far as I consider, however an intuitive understanding suggests that the answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + \u003ci\u003en\u003c/i\u003e / 2\u003c/span\u003e, and it is accpeted...\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/84/problem/B\" title\u003d\"Codeforces Beta Round 72 (Div. 2 Only)\"\u003e84B - Magical Array\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe must find out all the intervals that consist of the same integers. For an interval with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e integers, the number of reasonable subsequences is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/80/09/80098e6d7c47fd08aceb4ac18a910ecf38e42031.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Thus, we can adopt two pointers to find out all the target intervals, and calculate the answer.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/84/problem/C\" title\u003d\"Codeforces Beta Round 72 (Div. 2 Only)\"\u003e84C - Biathlon\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAs it has been guaranteed that no two circles intersect with each other, the given point can only fall into at most one particular circle (one special case is that two circles touch each other at the given point). Thus, we first sort the circles in an increasing order of their X-coordinates, and find out two circles between which the give point falls (check the X-coordinate of the given point as well, and a special case is that the given point falls at one of two ends of all the circles), which can be achieved by using binary search. \u003c/p\u003e\u003cp\u003eThen, the final step is to check which circle it falls inside, or completely outside all the circles.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/84/problem/D\" title\u003d\"Codeforces Beta Round 72 (Div. 2 Only)\"\u003e84D - Doctor\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe basic idea is still binary search. We use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e]\u003c/span\u003e to denote the given array. We use binary search to find out the maximum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e so that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c5/27/c527baa961fa52b96837dc7c414faf953a872ccd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Moreover, we compute \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e - \u003ci\u003eS\u003c/i\u003e\u003c/span\u003e as the remainder. Then, any \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e that is not larger than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e should be firstly eliminated. Next we enumerate the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e - \u003ci\u003eS\u003c/i\u003e\u003c/span\u003e survived \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e in the natural order while decreasing them by one, and eliminate those \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] ≤ \u003ci\u003eT\u003c/i\u003e\u003c/span\u003e again. Finally, we start from the current position and output the survived indices one by one, by shifting to the right in a circular manner.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/84/problem/E\" title\u003d\"Codeforces Beta Round 72 (Div. 2 Only)\"\u003e84E - Track\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI spent about three hours modifying the algorithm to avoid the time limit....The most impressive modification I used is scaling the constant from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d6/ce/d6ce1e1600c17176768f69bdf4b232a12ee53602.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. This is the first time that I realized what an important role that a constant can play.\u003c/p\u003e\u003cp\u003eThe general idea is to generate all the feasible patterns of maps and find out the one with the minimum distance and order. For instance, if letter \u0027a\u0027 and \u0027b\u0027 can be used, then we will obtain a map where we can move to positions of \u0027a\u0027 and \u0027b\u0027 while the other ones can not be used. With this equivalent map, we can implement BFS from the starting position until the terminating position is reached. During this process, we update the distance and also the minimum order if necessary.\u003c/p\u003e\u003cp\u003eAs \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e can take values up to \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e, we may have to check as many as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e26\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e\u003c/span\u003e patterns for the worst case. It turns out that this will lead to TLE. Therefore, we have to further reduce the complexity. Instead of beginning from the starting position, we can begin from every one of the four positions that can be reached from the starting position. Each time we select one position, we have determined one letter that must be used and thus the number of feasible patterns is reduced to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e25\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003c/span\u003e, which is supposed to satisfy the time limit as I consider. \u003c/p\u003e\u003cp\u003eHowever, I made a mistake that the number of generated patterns is in fact \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e25\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003c/span\u003e rather than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e25\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003c/span\u003e. As these two values only differ by a constant of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d6/ce/d6ce1e1600c17176768f69bdf4b232a12ee53602.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, I did not realize (or believe) that such a constant matters so much. After I correct the mistake, it passed... What a fascinating problem!!\u003c/p\u003e\u003c/div\u003e","tags":[]}}