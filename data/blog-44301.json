{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1460379326,"rating":58,"authorHandle":"zscoder","modificationTimeSeconds":1460534533,"id":44301,"title":"\u003cp\u003eCodechef April Challenge 2016 Brief Solutions\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e1. COLOR\u003c/h2\u003e\u003cp\u003eThis problem is trivial. Note that we want the resulting string to be monochromatic and thus we can just choose the color with maximal occurences and change the remaining letters into the color.\u003c/p\u003e\u003ch2\u003e2. CHBLLNS\u003c/h2\u003e\u003cp\u003eThis problem is also trivial. For each color, we take \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e balls, or if there\u0027re less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e balls, take all the balls. Currently, there are at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e balls for each color. Then, take one more ball. By pigeonhole principle, there exists \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e balls of same color. So, this is our answer.\u003c/p\u003e\u003ch2\u003e3. CHEFPATH\u003c/h2\u003e\u003cp\u003eThis problem is not hard. WLOG, assume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≤ \u003ci\u003em\u003c/i\u003e\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 1\u003c/span\u003e, then the task is possible if and only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e \u003d 2\u003c/span\u003e for obvious reasons. Otherwise, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e\u003c/span\u003e are both odd, then coloring the board in a checkerboard fashion can show that no such path exist. If one of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e\u003c/span\u003e is even, then such path exists. (it\u0027s not hard to construct such path)\u003c/p\u003e\u003ch2\u003e4. BIPIN3\u003c/h2\u003e\u003cp\u003eIn fact, the answer is the same for any tree. For the root vertex we can select \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e possible colors. For each children, note that we can select any color except the color of the parent vertex, so there\u0027re \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e choices. So, in total there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e·(\u003ci\u003en\u003c/i\u003e - 1)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e possible colorings. To evaluate this value, we use modular exponentiation.\u003c/p\u003e\u003ch2\u003e5. FIBQ\u003c/h2\u003e\u003cp\u003eThe idea of this problem is to convert the sum in matrix language. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e be the matrix[\\begin{bmatrix} 1 \u0026amp; 1 \\ 1 \u0026amp; 0 \\end{bmatrix} ]\u003c/p\u003e\u003cp\u003eAdditionally, let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eI\u003c/i\u003e\u003c/span\u003e be the identity matrix. Then, our desired answer will be the top right element of \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eT\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/sup\u003e + \u003ci\u003eI\u003c/i\u003e)(\u003ci\u003eT\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e + 1\u003c/sub\u003e\u003c/sup\u003e + \u003ci\u003eI\u003c/i\u003e)...(\u003ci\u003eT\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/sup\u003e + \u003ci\u003eI\u003c/i\u003e)\u003c/span\u003e. Now, to support the update queries, just use a segment tree. The segment tree from \u003ca href\u003d\"//codeforces.com/blog/entry/18051\"\u003ethis link\u003c/a\u003e is perfect for the job.\u003c/p\u003e\u003ch2\u003e6. DEVGOSTR\u003c/h2\u003e\u003cp\u003eDespite it\u0027s appearance, this problem is actually very simple. For \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e \u003d 1\u003c/span\u003e, there is at most \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e possible string, namely the string consisting of all `a\u0027s. The background of this problem is Van der Waerden\u0027s Theorem. According to the Wikipedia page, the maximal length of a good string for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e \u003d 2\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e8\u003c/span\u003e and the maximal length for a good string for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e \u003d 3\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e26\u003c/span\u003e. Now, for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e \u003d 2\u003c/span\u003e we can brute force all possible strings. However, for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e \u003d 3\u003c/span\u003e we need to brute force more cleverly. The key is to note that if a string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e is not good then appending any letter to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e will not make it good. So, we just need to attempt to append letters to good strings. This pruning will easily AC the problem.\u003c/p\u003e\u003ch2\u003e7. AMAEXPER\u003c/h2\u003e\u003cp\u003eCall a point that minimizes the answer for a subtree rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e the king of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e. If there are mutiple kings choose the one closer to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e. The problem revolves around an important lemma :\u003c/p\u003e\u003cp\u003eLemma : For the subtree rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e, consider all children of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e be the children such that the distance from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e to the furthest node in the subtree rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e is the longest. If there are multiple \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e is the king. Otherwise, either \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e is the king of the node in the subtree rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e is the king.\u003c/p\u003e\u003cp\u003eSketch of proof : Suppose not, then the maximal distance from some other vertex will be the distance from that node to root + the distance from root to the furthest node in the subtree rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e, so choosing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e is more optimal.\u003c/p\u003e\u003cp\u003eThus, for we can actually divide the tree into chains. A chain starts from some vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and we keep going down to the children \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e. For each node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e, we store the distance to root, the maximal distance from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e to any vertex in its subtree, as well as the maximal distance IF we don\u0027t go down to children \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e. (this distance is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e has only \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e children) Now, for each chain, we start from the bottom. We also maintain a king counter starting from the bottom. At first, the answer for the bottom node is the maximal distance stored for that node. Then, as we go up to the top of the chain, note that the possible places for the king is on the chain and will not go below the king for the node below. Thus, we can update the king counter in a sliding window like fashion. How do we find the answer for each node? This value can be calculated in terms of the numbers stored on each node, and using an RMQ we can find the desired answer. The details for this will not be included here.\u003c/p\u003e\u003ch2\u003e8. FURGRAPH\u003c/h2\u003e\u003cp\u003eThe key observation for this problem is the following : Instead of weighing the edges, for each edge with weight \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e, we increase \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e to the endpoints of the edge (note that for self-loops the vertex will be added twice). Then, the difference of score of Mario and Luigi is just the difference of the sum of weights on the vertices they have chosen, divided by \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e. Why? If an edge has its endpoints picked by Mario (or Luigi), then Mario (or Luigi)\u0027s score will increase by \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e. If each person pick one of the endpoints, then the difference of score is unchanged, as desired. Now, Mario and Luigi\u0027s strategy is obvious : They will choose the vertex with maximal possible weight at the time, so letting \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ≤ \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e ≤ ... ≤ \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the weights of the vertices in sorted order, the answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 2\u003c/sub\u003e... + ( - 1)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sup\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, i.e. the alternating sum of weights in sorted order.\u003c/p\u003e\u003cp\u003eUsing this observation alone can easily give us Subtask \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e. We can naively store the vertex weights in a map and update as neccesary. For each query, just loop through the map and calculate the alternating sum.\u003c/p\u003e\u003cp\u003eSubtask \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e requires more optimization. We will use sqrt-decomposition with an order statistic tree to store the vertex weights in sorted order. Note that for each update, we\u0027re cyclicly shifting the values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, for some \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e\u003c/span\u003e which can be found from our order statistic tree. Then, we update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ew\u003c/i\u003e\u003c/span\u003e. To efficiently perform these queries, we divide the array (of vertex weights) into \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/5c/4e5c9f371024ad4e1f5b0f2dfeb967ffe7cb5f4e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e parts of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/5c/4e5c9f371024ad4e1f5b0f2dfeb967ffe7cb5f4e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e elements each. We start from element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e. For each block we store a deque containing the elements, the sum of elements (we store the elements as negative if we want to subtract the value when calculating the alternating sum for convenience), and the sign of the elements in the block. We iterate through the elements and perform the neccesary updates until we reach the end of block. Then, for updating entire blocks, we perform the neccesary updates on the values, negate the sign, and since we\u0027re using deque we can pop front and push back the desired element (namely the next element). Then, when we reach the block containing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e, we iterate naively again. The total complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c9/5f/c95f6ffc1a5ddb83df4ba566c99ba123061ff07a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. My solution with this algorithm ACs the problem.\u003c/p\u003e\u003ch2\u003e9. CHNBGMT\u003c/h2\u003e\u003cp\u003eUnfortunately, I only get the first \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e subtasks to this problem.\u003c/p\u003e\u003cp\u003eThis problem is similar to \u003ca href\u003d\"//codeforces.com/problemset/problem/38/D\"\u003ethis\u003c/a\u003e, except it\u0027s harder. The solution for that problem uses Lindstrom-Gessel-Viennot Lemma. We can apply that lemma to this problem as well. \u003c/p\u003e\u003cp\u003eYou can see how to apply the lemma from the old CF problem. Now, the problem reduces to finding the number of ways to go from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e ≤ 2\u003c/span\u003e, and finding the determinant of the resulting \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e matrix. \u003c/p\u003e\u003cp\u003eFor subtasks \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e are small so we can find these values using a simple dp. In particular, we can use something like \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e] \u003d \u003c/span\u003e number of ways to get to \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e passing through exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e carrots. Since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e, \u003ci\u003eN\u003c/i\u003e ≤ 60\u003c/span\u003e, this solution can easily pass.\u003c/p\u003e\u003cp\u003eFor subtask \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e, \u003ci\u003eM\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e. However, we are given that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e \u003d 0\u003c/span\u003e. For \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e \u003d 2\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e \u003d 2\u003c/span\u003e the answer can be calculated manually. So, from now onwards, we assume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e, \u003ci\u003eN\u003c/i\u003e ≥ 3\u003c/span\u003e. Then finding the values is equivalent to computing binomial coefficients. (The details are trivial). So, all it remains is to know how to compute binomial coefficients mod \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eMOD\u003c/i\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eMOD\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e is not guaranteed to be a prime.\u003c/p\u003e\u003cp\u003eFirstly, the obvious step is to factor \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eMOD\u003c/i\u003e\u003c/span\u003e into its prime factors. Thus, we can compute the answer mod all the prime powers that are factors of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eMOD\u003c/i\u003e\u003c/span\u003e and combine the results with Chinese Remainder Theorem. How do we find the result mod \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e? This is trivial. We just need to store \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e of the numbers and the remainder of the number mod \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e when we divide out all factors of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e. Now, compute modular inverse mod \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e assuming that the value is not divisible by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e can be done using Euler\u0027s Theorem the same way we find modular inverse mod \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eI would like to know how to get the other subtasks where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e \u0026gt; 0\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e","tags":[]}}