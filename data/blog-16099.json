{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1422541837,"rating":81,"authorHandle":"darkshadows","modificationTimeSeconds":1423908147,"id":16099,"title":"\u003cp\u003eCodeCraft\u002715 IIIT Hyderabad Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100589/problem/A\" title\u003d\"2015 CodeCraft IIIT Hyderabad Replay\"\u003e100589A - Queries on the Tree\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eGiven a rooted tree(at node 1) of \u003cstrong\u003eN\u003c/strong\u003e nodes,you have to handle a total of \u003cstrong\u003eQ\u003c/strong\u003e operations of type:\u003cbr /\u003e\u003cstrong\u003e1 U L X\u003c/strong\u003e: Increase coins by \u003cstrong\u003eX\u003c/strong\u003e of all nodes at a distance of \u003cstrong\u003eL\u003c/strong\u003e from root.\u003cbr /\u003e\u003cstrong\u003e2 X\u003c/strong\u003e: Report sum of all coins in subtree rooted at \u003cstrong\u003eX\u003c/strong\u003e.\u003cbr /\u003e\u003cstrong\u003eN\u003c/strong\u003e \u0026lt;\u003d 10\u003csup\u003e5\u003c/sup\u003e \u003cstrong\u003eQ\u003c/strong\u003e \u0026lt;\u003d 10\u003csup\u003e4\u003c/sup\u003e\u003c/p\u003e\u003ch4\u003eDifficulty:\u003c/h4\u003e\u003cp\u003eMedium-Hard\u003c/p\u003e\u003ch4\u003eExplanation:\u003c/h4\u003e\u003cp\u003eThis approach uses a very specific technique of maintaining a buffer of update queries and updating the whole tree once buffer size exceeds a constant limit(we maintain this limit as sqrt(M)).\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ebuffer\u003d[]\nq\u003dinput\nwhile q--:\n     query \u003d input()\n     if query\u003d\u003dupdate:\n          buffer.add(query)\n     else:\n          //say query is “2 X”\n          //the answer that has been already calculated for node X\n          prevans\u003d ans(X)\n          for i\u003d0 to buffer.size():\n               //add to prevans the effect of buffer[i]\n               //let’s say buffer[i]\u003d”1 U L Y”\n               //if buffer[i] affected K nodes in subtree of X\n               //we add to prevans: K*Y\n               //so, we need to count how many nodes of subtree X\n               //are at a level L, we’ll show later how to handle this\n          print prevans\n\n     if buffer.size() \u0026gt; sqrtM:\n          //update the whole tree and precalculate answer of all nodes\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo, we need to look at two things:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eGiven \u003cstrong\u003eX\u003c/strong\u003e and \u003cstrong\u003eL\u003c/strong\u003e count how many nodes in subtree of \u003cstrong\u003eX\u003c/strong\u003e are at a level \u003cstrong\u003eL\u003c/strong\u003e(this level is measured from root).\u003cbr /\u003eFor this we first DFS transform our tree such that all nodes in a subtree lie in contiguous range after new mapping(according to DFS). And then we maintain for each level an array which stores the new indexes of all nodes that are at that level.\u003cbr /\u003eFor example, a vector \u003cstrong\u003elevel[L]\u003c/strong\u003e stores all new indexes of nodes that are at level \u003cstrong\u003eL\u003c/strong\u003e. These vectors can easily be made in \u003cstrong\u003eO(N)\u003c/strong\u003e by a DFS.\u003cbr /\u003eNow, for a query “Given X and L count how many nodes in subtree of X are at a level L”, we know the range of new indexes of all nodes in subtree of \u003cstrong\u003eX\u003c/strong\u003e(say the range is \u003cstrong\u003eS\u003c/strong\u003e to \u003cstrong\u003eR\u003c/strong\u003e), we just have to count number of values in vector \u003cstrong\u003elevel[L]\u003c/strong\u003e that lie in range \u003cstrong\u003e[S,R]\u003c/strong\u003e, which can be done in \u003cstrong\u003eO(log N)\u003c/strong\u003e worst case.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eGiven at-most sqrt(M) queries of type “L X”,(which denote update \u003cstrong\u003eX\u003c/strong\u003e at all nodes at level \u003cstrong\u003eL\u003c/strong\u003e), we have to update the whole tree.\u003cbr /\u003eWe traverse over all queries and mark in a \u003cstrong\u003ecount\u003c/strong\u003e array(**count[i]** contains the total coins to be updated at level \u003cstrong\u003ei\u003c/strong\u003e). Now, while doing a DFS of tree we can easily update the \u003cstrong\u003ecurrent_sum\u003c/strong\u003e on each node. And then to pre calculate answers for each node we do one more DFS.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eSo, we don’t update our tree more than \u003cstrong\u003esqrt(M)\u003c/strong\u003e times and each update takes \u003cstrong\u003eO(N)\u003c/strong\u003e. Also, for print queries we don’t process more than \u003cstrong\u003esqrt(M)*log(N)\u003c/strong\u003e worst case. So, a loose upper bound on total complexity will be \u003cstrong\u003eO(N * sqrt(M) * log N)\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eMany problems can be solved by this specific technique of making buffers of queries. For example this problem: \u003ca href\u003d\"/contest/447/problem/E\" title\u003d\"Codeforces Round FF (Div. 2)\"\u003e447E - DZY Loves Fibonacci Numbers\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100589/problem/B\" title\u003d\"2015 CodeCraft IIIT Hyderabad Replay\"\u003e100589B - Count Palindromes\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eTo find the number of palindromes which appear between two instants of time when seen on a digital clock. Upto 10\u003csup\u003e5\u003c/sup\u003e queries.\u003c/p\u003e\u003ch4\u003eDifficulty:\u003c/h4\u003e\u003cp\u003eEasy\u003c/p\u003e\u003ch4\u003eExplanation:\u003c/h4\u003e\u003cp\u003eThe number of distinct strings which one can see are 86400(from 00:00:00 to 23:59:59). Answering each query, would take \u003cstrong\u003eO(86400 * 6)\u003c/strong\u003e in the worst case. And there are 10\u003csup\u003e5\u003c/sup\u003e queries.\u003cbr /\u003eSo, we can initially pre process for all possible times.\u003cbr /\u003eLet the time is \u003cstrong\u003eab:cd:ef\u003c/strong\u003e then converting it to seconds \u003cstrong\u003es \u003d ab*24*60 + cd*60 + ef\u003c/strong\u003e.\u003cbr /\u003eAs 1 hour \u003d 60 minutes and 1 minute \u003d 60 seconds. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eX[s]\u003c/strong\u003e denotes if s is a palindrome or not.\u003cbr /\u003eNow we maintain a prefix sum array so as to answer all queries in O(1). \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eMX \u003d 86400 + 1\nfor i in xrange(0, MX) :\n        mem[i] \u003d 0\nmem[0] \u003d 1\nfor i in xrange(1, MX) :\n         val \u003d conv(i)\n         mem[i] \u003d mem[i - 1]\n         if Palin(val) :\n                mem[i] +\u003d 1\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLet \u003cstrong\u003emem[i]\u003c/strong\u003e denote the number of palindromes from 0 till \u003cstrong\u003ei\u003c/strong\u003e.\u003cbr /\u003e\u003cstrong\u003econv\u003c/strong\u003e is a function which converts a number \u003cstrong\u003ex\u003c/strong\u003e to string of length 6. Appends leading zeroes till the size is 6. Palin is a function which returns True or False depending on whether the given string is a palindrome or not. \u003c/p\u003e\u003cp\u003eNow for each query, we convert the given time to seconds. Let the converted times into seconds be \u003cstrong\u003ea\u003c/strong\u003e, \u003cstrong\u003eb\u003c/strong\u003e. The number of palindromes between \u003cstrong\u003ea\u003c/strong\u003e and \u003cstrong\u003eb\u003c/strong\u003e are\u003cbr /\u003emem[b] : if a \u003d 0\u003cbr /\u003emem[b]-mem[a-1] : else \u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100589/problem/C\" title\u003d\"2015 CodeCraft IIIT Hyderabad Replay\"\u003e100589C - Find P\u0027th Number\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eGiven \u003cstrong\u003eN\u003c/strong\u003e and \u003cstrong\u003eP\u003c/strong\u003e, Either all even or all odd numbers have been removed from set \u003cstrong\u003e[1, 2, 3 ... N]\u003c/strong\u003e, find the \u003cstrong\u003eP\u003c/strong\u003eth smallest remaining number.\u003cbr /\u003e\u003cstrong\u003eN \u0026lt;\u003d 10\u003csup\u003e9\u003c/sup\u003e\u003c/strong\u003e\u003c/p\u003e\u003ch4\u003eDifficulty:\u003c/h4\u003e\u003cp\u003eCakewalk\u003c/p\u003e\u003ch4\u003eQuick Explanation:\u003c/h4\u003e\u003cp\u003eAnswer is either \u003cstrong\u003e2 * P\u003c/strong\u003e(if all odd are removed) or \u003cstrong\u003e2 * P — 1\u003c/strong\u003e(if all even are required, one less than in other case because instead of 2 we report 1, 3 instead of 4 and so on).\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100589/problem/D\" title\u003d\"2015 CodeCraft IIIT Hyderabad Replay\"\u003e100589D - Desolation of Smaug\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eNote : Since there are \u003cstrong\u003eN\u003c/strong\u003e nodes and \u003cstrong\u003eN\u003c/strong\u003e edges in the graph, the graph would be like a tree containing a single cycle (because a tree with \u003cstrong\u003eN\u003c/strong\u003e nodes has \u003cstrong\u003eN-1\u003c/strong\u003e edges. On adding an edge in the tree , wherever we might add the edge, we shall always get a single cycle in the graph) . Imagine the given graph as a cycle with a tree hanging down at each node. This is a special property of a graph with \u003cstrong\u003eN\u003c/strong\u003e nodes and \u003cstrong\u003eN\u003c/strong\u003e edges which must be exploited to answer the queries in sublinear time. \u003c/p\u003e\u003ch4\u003eExplanation\u003c/h4\u003e\u003cp\u003eOnce again we have many interesting things to observe in this question . Lets start by analyzing each part one by one. \u003c/p\u003e\u003cp\u003eFirst, What does the question ask us to do?\u003cbr /\u003eThe problem statement is short and precise . Frodo needs to escape from Smaug. Given the initial positions of both and the destination of Frodo along with the velocities of both, print \u003cstrong\u003eYES\u003c/strong\u003e or \u003cstrong\u003eNO\u003c/strong\u003e depending on whether Frodo can escape or not. Sounds easy, a simple dijkstra once from Frodo and once from Smaug would get us the answer. But, then comes the interesting part, \u003cstrong\u003eQ\u003c/strong\u003e queries where \u003cstrong\u003eQmax\u003c/strong\u003e \u003d 10\u003csup\u003e5\u003c/sup\u003e. Following the Dijkstra approach for each query will be \u003cstrong\u003eO(Q * N logN)\u003c/strong\u003e which undoubtedly would fetch us TLE.\u003c/p\u003e\u003cp\u003eSo what to do?\u003cbr /\u003eSeeing the constraints, it is clear that we need to do some linear pre-processing on the given graph such that we can answer each query in sublinear time.\u003cbr /\u003eBut before directly jumping to the implementation and seeing how to achieve the task of answering the queries in sublinear time, let us first do a theoretical analysis of the problem to completely understand what we need to do and then we shall focus on how to do it. \u003c/p\u003e\u003ch4\u003eTheoretical Analysis\u003c/h4\u003e\u003cp\u003eAs explained in the note above, we need to imagine the given graph as a cycle with a tree (possibly with only a single node, the root) hanging down at each node in the cycle. (See diagram on below).\u003cbr /\u003e\u003cimg height\u003d\"40%\" src\u003d\"/predownloaded/7f/fd/7ffd8e71c76ac202d1f1ef8f120dceb2c9ce053a.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" width\u003d\"40%\" /\u003e\u003c/p\u003e\u003cp\u003eNow, let’s analyze the various possible cases based on the parameters which vary in each query, i.e. \u003cstrong\u003eVf, Vs, St, Ds, S\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCase 1: Vs \u0026gt;\u003d Vf\u003c/strong\u003e\u003cbr /\u003eWe just need to check who reaches the destination(**Ds**) first, Frodo or Smaug because if Smaug can catch Frodo at some node on the way to destination , he can definitely catch him at the Destination . Hence \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eIf(Dist(St,Ds) * Vs\u0026lt; Dist(S,Ds)*Vf)  //Or Dist(St,Ds)/Vf \u0026lt; Dist(S,Ds)/Vs\n     print \u0026quot;YES\u0026quot;;\nelse\n     print \u0026quot;NO\u0026quot;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eCase 2: Vs \u0026lt; Vf\u003c/strong\u003e\u003cbr /\u003eIn this case , if Frodo escapes/ gains lead over Smaug at any node, Smaug cannot catch him and Frodo is gone forever . To better understand this, let us visualize the various possible cases that arise based on different locations of \u003cstrong\u003eSt, Ds, S\u003c/strong\u003e. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSub-Case 1\u003c/strong\u003e : All Three \u003cstrong\u003eSt, Ds, S\u003c/strong\u003e lie in the same tree and \u003cstrong\u003eS\u003c/strong\u003e lies within the subtree rooted at \u003cstrong\u003eLCA(St, DS)\u003c/strong\u003e. \u003c/p\u003e\u003cp\u003e\u003cimg height\u003d\"40%\" src\u003d\"/predownloaded/b6/1a/b61a7b91a2dd0431b3b0c6a401cf5f24d46a29d1.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" width\u003d\"40%\" /\u003e\u003c/p\u003e\u003cp\u003eAs shown in the diagram, if Frodo escapes Smaug at node 7, i.e. Frodo reaches before Smaug at node 7, he can safely reach Dt else he will surely get caught by Smaug at node 7.\u003cbr /\u003eIn general, we compare the reaching time’s of Frodo and Smaug at the \u003cstrong\u003emin(LCA(St,S),LCA(S,Dt))\u003c/strong\u003e.\u003cbr /\u003ewhere \u003cstrong\u003emin()\u003c/strong\u003e represents the lower one(the one with greater level down the root) of the two because in each case, one of the above two will always be equal to \u003cstrong\u003eLCA(St,Dt)\u003c/strong\u003e. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSub-Case 2\u003c/strong\u003e : Both \u003cstrong\u003eSt, Ds\u003c/strong\u003e lie in the same tree and \u003cstrong\u003eS\u003c/strong\u003e lies outside the subtree rooted at \u003cstrong\u003eLCA(St, DS)\u003c/strong\u003e. \u003c/p\u003e\u003cp\u003e\u003cimg height\u003d\"40%\" src\u003d\"/predownloaded/f4/fe/f4fee43d79bd0569392c6bf8ad2b773c6d5c9fda.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" width\u003d\"40%\" /\u003e\u003c/p\u003e\u003cp\u003e\u003cimg height\u003d\"40%\" src\u003d\"/predownloaded/35/02/35021dbe281fcaf24788e182567649d3319bfdb1.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" width\u003d\"40%\" /\u003e\u003c/p\u003e\u003cp\u003eWe just need to compare the reaching time of Frodo and Smaug at the \u003cstrong\u003eLCA(St,Dt)\u003c/strong\u003e s.t. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eif(reachingTime[Frodo][LCA(ST,DT] \u0026lt; reachingTime[Smaug][LCA(St,Dt])\n     printf \u0026quot;YES\u0026quot;\nelse\n     printf \u0026quot;NO\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eSub-Case 3\u003c/strong\u003e : One of \u003cstrong\u003eSt\u003c/strong\u003e or \u003cstrong\u003eDt\u003c/strong\u003e and \u003cstrong\u003eS\u003c/strong\u003e lie in the same tree and the remaining lies in another tree. \u003c/p\u003e\u003cp\u003e\u003cimg height\u003d\"40%\" src\u003d\"/predownloaded/c9/a8/c9a822c27f6a0d37229e40f0bb6b2feb3a2128f0.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" width\u003d\"40%\" /\u003e\u003c/p\u003e\u003cp\u003e\u003cimg height\u003d\"40%\" src\u003d\"/predownloaded/56/64/5664798055c67fca3bcc2e6201305970cf194266.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" width\u003d\"40%\" /\u003e\u003c/p\u003e\u003cp\u003eWe compare the reaching time of Frodo and Smaug at the \u003cstrong\u003eLCA(St,S)\u003c/strong\u003e or \u003cstrong\u003eLCA(Dt,S)\u003c/strong\u003e depending on which of \u003cstrong\u003eSt\u003c/strong\u003e or \u003cstrong\u003eDt\u003c/strong\u003e is in the same tree as that of \u003cstrong\u003eS\u003c/strong\u003e. If Frodo can reach this node before Smaug, he can reach the destination otherwise he will surely get caught.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSub-Case 4\u003c/strong\u003e : All three \u003cstrong\u003eSt\u003c/strong\u003e, \u003cstrong\u003eDt\u003c/strong\u003e, \u003cstrong\u003eS\u003c/strong\u003e lie in different Trees. \u003c/p\u003e\u003cp\u003e\u003cimg height\u003d\"40%\" src\u003d\"/predownloaded/3a/5b/3a5b6a15d9fbf979bce189396ed75beca4609400.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" width\u003d\"40%\" /\u003e\u003c/p\u003e\u003cp\u003eIn this case,\u003cbr /\u003eFirst of all, Check whether Frodo can reach the root of his Tree before Smaug. If he can\u0027t then no matter what, he will surely get caught at the root of his tree because he definitely needs to pass through that node in order to reach the destination. \u003c/p\u003e\u003cp\u003eIf the Smaug cannot catch Frodo at the root of Frodo\u0027s tree, we will check whether Frodo can cross the root of Tree of \u003cstrong\u003eS\u003c/strong\u003e before Smaug reaches there and if he can, he shall surely escape. \u003c/p\u003e\u003cp\u003eIf Smaug can catch Frodo at the root of \u003cstrong\u003eS\u003c/strong\u003e, we’ll compare the time taken by Frodo to reach the root of tree of \u003cstrong\u003eDt\u003c/strong\u003e along the path not involving root of tree of \u003cstrong\u003eS\u003c/strong\u003e and the shortest time taken by Smaug to reach the root of \u003cstrong\u003eDt\u003c/strong\u003e.\u003cbr /\u003eIf time taken by Frodo is less than that of Smaug, Frodo shall escape or else he will get caught. \u003c/p\u003e\u003ch4\u003eHow to Implement?\u003c/h4\u003e\u003cp\u003eWell, If you’re still alive and reading this editorial, Congratulations because we’ve reached the final part. :P \u003c/p\u003e\u003cp\u003eIn the above Theoretical analysis, we made use of two functions :\u003cbr /\u003e\u003cstrong\u003eLCA(A,B)\u003c/strong\u003e : Returns us the Lowest Common Ancestor of two nodes \u003cstrong\u003eA\u003c/strong\u003e and \u003cstrong\u003eB\u003c/strong\u003e in the same tree.\u003cbr /\u003e\u003cstrong\u003eDist(A,B)\u003c/strong\u003e : Returns us the distance between any two nodes \u003cstrong\u003eA\u003c/strong\u003e and \u003cstrong\u003eB\u003c/strong\u003e in the whole graph (not necessarily in the same subtree).\u003cbr /\u003eTo handle the \u003cstrong\u003eSub-Case 4\u003c/strong\u003e under \u003cstrong\u003eCase 2\u003c/strong\u003e, we would need to maintain the prefix sum of the path along the cycle because for the cycle, we need to analyze both the clockwise and anticlockwise paths for Frodo depending on conditions mentioned above. \u003c/p\u003e\u003cp\u003eWe’ll need shortest distance between any two nodes in the graph in logarithmic time.\u003cbr /\u003eShortest distance between any two nodes in the graph:\u003cbr /\u003eFor answer these types of queries, first we understand that given graph has a single cycle ie. trees are hanging from nodes in cycle.\u003cbr /\u003eSo, first we detect the cycle* and then for each tree hanging at a cycle node we build the \u003ca\u003eLCA DP table\u003c/a\u003e so that we can handle LCA queries in logarithmic time. \u003c/p\u003e\u003cp\u003eAlso, for each such tree we pre-calculate that distance from root node(ie. cycle node) to tree node.\u003cbr /\u003eWe can do this by a linear order DFS. Let’s call such array \u003cstrong\u003edist_root\u003c/strong\u003e. \u003c/p\u003e\u003cp\u003e*For detecting cycle two methods are:\u003cbr /\u003e1. Store indegree of all nodes first and keep removing all nodes from set \u003cstrong\u003e[1,2,..N]\u003c/strong\u003e if indegree of node is 1(ie. keep removing leaf nodes). If indegree of any neighbor reduces to 1, remove it. All remaining nodes will be in cycle. We can easily do this using queue in a similar way to BFS. \u003c/p\u003e \u003col\u003e   \u003cli\u003eDo a DFS and whenever detect a back edge, all vertices currently in recursion stack are cycle nodes.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eNow, for distance between node \u003cstrong\u003eu\u003c/strong\u003e and \u003cstrong\u003ev\u003c/strong\u003e, there are two case:\u003cbr /\u003e\u003cstrong\u003eu\u003c/strong\u003e and \u003cstrong\u003ev\u003c/strong\u003e are in same tree(tree that hangs by a cycle node):\u003cbr /\u003eShortest distance is \u003cstrong\u003edist_root[u] + dist_root[u] — dist_root[lca(u,v)]\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eu\u003c/strong\u003e and \u003cstrong\u003ev\u003c/strong\u003e are in different trees(trees that hangs by two distinct cycle nodes):\u003cbr /\u003eShortest distance is \u003cstrong\u003edist_root[u] + dist_root[u] + min-distance(root[u], root[v])\u003c/strong\u003e.\u003cbr /\u003eSo, we need to find minimum distance between any two nodes in cycle. First let’s say we map all cycle nodes(say total of \u003cstrong\u003eK\u003c/strong\u003e) values 1 to \u003cstrong\u003eK\u003c/strong\u003e. Now we pre-calculate a prefix sum array of array \u003cstrong\u003eA\u003c/strong\u003e where \u003cstrong\u003eA[i]\u003c/strong\u003e stores distance between node 1 and node \u003cstrong\u003ei\u003c/strong\u003e(if we travel by clockwise direction).\u003c/p\u003e\u003cp\u003eNow, for min distance between \u003cstrong\u003ea\u003c/strong\u003e and \u003cstrong\u003eb\u003c/strong\u003e(two cycle nodes):\u003cbr /\u003eLet’s say \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eK \u003d total length of cycle       \n//assuming mapping[a] \u0026gt; mapping[b]\nM \u003d prefix_sum[a] - prefix_sum[b]\nmin distance \u003d min(M, K-M)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo, we can handle overall min distance queries in worst case \u003cstrong\u003eO(log N)\u003c/strong\u003e.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100589/problem/E\" title\u003d\"2015 CodeCraft IIIT Hyderabad Replay\"\u003e100589E - Count Distinct Sets\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSee the doc: \u003ca href\u003d\"https://docs.google.com/document/d/1-znOOxmNIhcUQNiW8uOQpKUNzFiN2PCt6uY-6nLjIDU/edit?usp\u003dsharing\"\u003ehttps://docs.google.com/document/d/1-znOOxmNIhcUQNiW8uOQpKUNzFiN2PCt6uY-6nLjIDU/edit?usp\u003dsharing\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100589/problem/F\" title\u003d\"2015 CodeCraft IIIT Hyderabad Replay\"\u003e100589F - Count Ways\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eGiven a grid of size \u003cstrong\u003eN\u003c/strong\u003e x \u003cstrong\u003eM\u003c/strong\u003e, where \u003cstrong\u003eK\u003c/strong\u003e given cells are blocked. Find number of ways to reach (N, M) from (1, 1) if you can move right or down.\u003cbr /\u003e\u003cstrong\u003eN, M\u003c/strong\u003e \u0026lt;\u003d 10\u003csup\u003e5\u003c/sup\u003e \u003cstrong\u003eK\u003c/strong\u003e \u0026lt;\u003d 10\u003csup\u003e3\u003c/sup\u003e\u003c/p\u003e\u003ch4\u003eDifficulty:\u003c/h4\u003e\u003cp\u003eMedium-Hard\u003c/p\u003e\u003ch4\u003eExplanation:\u003c/h4\u003e\u003cp\u003eFirst a basic formula, number of ways to reach \u003cstrong\u003e(x2, y2)\u003c/strong\u003e from \u003cstrong\u003e(x1, y1)\u003c/strong\u003e if \u003cstrong\u003ex2 \u0026gt;\u003d x1\u003c/strong\u003e and \u003cstrong\u003ey2 \u0026gt;\u003d y1\u003c/strong\u003e:\u003cbr /\u003eLet \u003cstrong\u003ex \u003d x2-x1-1 and y \u003d y2-y1-1\u003c/strong\u003e\u003cbr /\u003eNumber of ways \u003cstrong\u003eF(x1, y1, x2, y2) \u003d (x+y)!/(x!y!)\u003c/strong\u003e where \u003cstrong\u003en!\u003c/strong\u003e denotes \u003cstrong\u003en\u003c/strong\u003e factorial.\u003c/p\u003e\u003cp\u003eNow, an interesting observation is that if I block a cell at \u003cstrong\u003e(i, j)\u003c/strong\u003e all cells with their respective coordinates greater than or equal to \u003cstrong\u003ei\u003c/strong\u003e and \u003cstrong\u003ej\u003c/strong\u003e will be affected by it(ie. number of ways to reach them will be changed).\u003c/p\u003e\u003cp\u003eLet\u0027s say our set \u003cstrong\u003eS \u003d {all blocked cells + cell(N, M)}\u003c/strong\u003e. I now sort \u003cstrong\u003eS\u003c/strong\u003e on increasing basis of \u003cstrong\u003ex\u003c/strong\u003e coordinate and then increasing on \u003cstrong\u003ey\u003c/strong\u003e. Also I maintin an array \u003cstrong\u003eans\u003c/strong\u003e where \u003cstrong\u003eans[i]\u003c/strong\u003e denotes number of ways to reach cell at index \u003cstrong\u003ei\u003c/strong\u003e in \u003cstrong\u003esorted(S)\u003c/strong\u003e.\u003cbr /\u003eIntially \u003cstrong\u003eans[i] \u003d F(1, 1, S[i].x, S[i].y)\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eNow, I traverse the \u003cstrong\u003esorted(S)\u003c/strong\u003e in increasing order and updating the number of ways for all the cells that it affects.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor i\u003d0 to S.size()-2:\n    for j\u003di+1 to S.size()-1:\n        if S[j].x\u0026lt;S[i].x or S[j].y\u0026lt;S[i].y:  //cell j not affected\n            continue\n\n        //ans[i] stores current number of ways to reach that cell\n        //now all paths from cell (1,1) to cell j are blocked\n        //so we subtract (number of ways to reach i * number of paths from i to j)\n        ans[j] -\u003d ans[i]*F(S[i].x, S[i].y, S[j].x, S[j].y)\n\nprint ans[S.size()-1]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhile making a decrement at \u003cstrong\u003eans[j]\u003c/strong\u003e due to blocked cell \u003cstrong\u003ei\u003c/strong\u003e we ignore that there are some other blocked cells in between them(note that we are mutliplying with \u003cstrong\u003eF(S[i].x, S[i].y, S[j].x, S[j].y)\u003c/strong\u003e). We ignore them because \u003cstrong\u003eans[i]\u003c/strong\u003e is currently storing valid paths to reach \u003cstrong\u003e(S[i].x, S[i].y)\u003c/strong\u003e and all possible paths now that pass through it are blocked. So we subtract each possible comibination from \u003cstrong\u003eans[j]\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eComplexity: \u003cstrong\u003eO(K\u003csup\u003e2\u003c/sup\u003e)\u003c/strong\u003e.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100589/problem/G\" title\u003d\"2015 CodeCraft IIIT Hyderabad Replay\"\u003e100589G - Count Permutations\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eGiven \u003cstrong\u003eN\u003c/strong\u003e(\u0026lt;\u003d 15), \u003cstrong\u003eK\u003c/strong\u003e (\u0026lt;\u003d N) count in how many permutations of \u003cstrong\u003e[1,2,..N]\u003c/strong\u003e no two adjacent elements differ by more than \u003cstrong\u003eK\u003c/strong\u003e. \u003c/p\u003e\u003ch4\u003eDifficulty:\u003c/h4\u003e\u003cp\u003eEasy-Medium\u003c/p\u003e\u003ch4\u003eQuick Explanation:\u003c/h4\u003e\u003cp\u003eMaintain a DP of \u003cstrong\u003emask\u003c/strong\u003e and \u003cstrong\u003elast_used\u003c/strong\u003e, where \u003cstrong\u003emask\u003c/strong\u003e denotes the number of elements already used and \u003cstrong\u003elast_used\u003c/strong\u003e denotes the value of number that was just used before current index.\u003c/p\u003e\u003ch4\u003eExplanation:\u003c/h4\u003e\u003cp\u003eNaive solution would be \u003cstrong\u003eO(N+1 factorial)\u003c/strong\u003e. But we can use dynamic programming here and try to reduce complexity. But considering that in a permutation each number from 1 to \u003cstrong\u003eN\u003c/strong\u003e is used only once, we can’t keep a generalized DP state like “number of permutations of length \u003cstrong\u003ei\u003c/strong\u003e ending in \u003cstrong\u003ej\u003c/strong\u003e”, because it doesn’t store information about what numbers we have used.\u003c/p\u003e\u003cp\u003eSo, we use bitmasks. Bitmask is basically a \u003cstrong\u003eN\u003c/strong\u003e bit binary number expressed as a decimal. If \u003cstrong\u003ei\u003c/strong\u003e’th bit in mask is marked we assume that we have already used number \u003cstrong\u003ei\u003c/strong\u003e somewhere and it is not available for use anymore.\u003c/p\u003e\u003cp\u003eNow, let’s try to form our solution. For placing a number at a certain position, we should know which number was placed before it(because we’ll compare their absolute difference). So in our state we keep two things: \u003cstrong\u003emask\u003c/strong\u003e and \u003cstrong\u003elast_used\u003c/strong\u003e, where \u003cstrong\u003elast_used\u003c/strong\u003e denotes the number that was used just before current position.\u003c/p\u003e\u003cp\u003eSo, let’s denote by \u003cstrong\u003eDP(mask, last_used)\u003c/strong\u003e the number of permutations of numbers marked in \u003cstrong\u003emask\u003c/strong\u003e and ending in \u003cstrong\u003elast_used\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eLet’s form recurrences now.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eDP(last_used, mask):\n     ret\u003d0\n     for all i unmarked in mask:\n          //we try to place number i at current position\n          if abs(i-last_used) \u0026lt;\u003d K:\n          //last_used is now i\n          //we pass new mask by setting i’th bit in it\n          ret +\u003d DP(i, mask|(1\u0026lt;\u0026lt;i))\n     return ret\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo, we use DP with memoization. So our complexity is number of states multiplied with transition cost.\u003cbr /\u003eSo total worst case complexity will be: \u003cstrong\u003eO(N\u003csup\u003e2\u003c/sup\u003e * 2\u003csup\u003eN\u003c/sup\u003e)\u003c/strong\u003e.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100589/problem/H\" title\u003d\"2015 CodeCraft IIIT Hyderabad Replay\"\u003e100589H - Count Subarrays\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eGiven an array \u003cstrong\u003eA\u003csub\u003e1\u003c/sub\u003e, A\u003csub\u003e2\u003c/sub\u003e ... A\u003csub\u003eN\u003c/sub\u003e\u003c/strong\u003e and \u003cstrong\u003eK\u003c/strong\u003e count how many subarrays have inversion count greater than or equal to \u003cstrong\u003eK\u003c/strong\u003e.\u003cbr /\u003e\u003cstrong\u003eN\u003c/strong\u003e \u0026lt;\u003d 10\u003csup\u003e5\u003c/sup\u003e\u003cbr /\u003e\u003cstrong\u003eK \u0026lt;\u003d N*(N-1)/2\u003c/strong\u003e \u003c/p\u003e\u003ch4\u003eDifficulty:\u003c/h4\u003e\u003cp\u003eMedium\u003c/p\u003e\u003ch4\u003eQuick Explanation:\u003c/h4\u003e\u003cp\u003eMaintain two pointers( \u003cstrong\u003ept1\u003c/strong\u003e and \u003cstrong\u003ept2\u003c/strong\u003e) and increase \u003cstrong\u003ept2\u003c/strong\u003e until inversions in subarray \u003cstrong\u003e[pt1, pt2]\u003c/strong\u003e are less than \u003cstrong\u003eK\u003c/strong\u003e. Now all the subarrays \u003cstrong\u003e[pt1, i]\u003c/strong\u003e have inversion count \u003cstrong\u003e\u0026gt; K-1\u003c/strong\u003e where \u003cstrong\u003ei \u0026gt; pt2-1\u003c/strong\u003e.\u003cbr /\u003eNow, we increase \u003cstrong\u003ept1\u003c/strong\u003e until inversion count in subarray \u003cstrong\u003e[pt1, pt2]\u003c/strong\u003e is greater than or equal to \u003cstrong\u003eK\u003c/strong\u003e.\u003cbr /\u003eAnd we repeat the above process until we reach end of our array.\u003cbr /\u003eInversion count can be handled easily using BIT.\u003cbr /\u003eSee detailed explanation for more clarity. \u003c/p\u003e\u003ch4\u003eExplanation:\u003c/h4\u003e\u003cp\u003eThe most important property to be observed it that if there are \u003cstrong\u003eP\u003c/strong\u003e inversions in subarray \u003cstrong\u003e[S, E]\u003c/strong\u003e, the inversions in subarray \u003cstrong\u003e[S, E+1]\u003c/strong\u003e will be greater than or equal to \u003cstrong\u003eP\u003c/strong\u003e, because the value at index \u003cstrong\u003eE+1\u003c/strong\u003e may contribute some inversions. How many inversions exactly will it contribute? It will be equal to number of elements that are greater than \u003cstrong\u003eA\u003csub\u003eE+1\u003c/sub\u003e\u003c/strong\u003e in range \u003cstrong\u003e[S, E]\u003c/strong\u003e. \u003c/p\u003e\u003cp\u003eSo, for each index \u003cstrong\u003ei\u003c/strong\u003e, if we get the smallest \u003cstrong\u003ej\u003c/strong\u003e(let’s call such a value \u003cstrong\u003ethreshold(i)\u003c/strong\u003e), such that inversions in subarray \u003cstrong\u003e[i, j]\u003c/strong\u003e is greater than or equal to \u003cstrong\u003eK\u003c/strong\u003e, we know that all subarrays \u003cstrong\u003e[i, k]\u003c/strong\u003e are valid(where \u003cstrong\u003ek \u0026gt;\u003d j\u003c/strong\u003e). So, our aim is to get this smallest \u003cstrong\u003ej\u003c/strong\u003e for each \u003cstrong\u003ei\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eLet’s say we are index \u003cstrong\u003ei\u003c/strong\u003e (pt1) initially are we have found the respective \u003cstrong\u003ej\u003c/strong\u003e (pt2) for it.\u003cbr /\u003eWe know that \u003cstrong\u003eInvCount[i, j] \u0026gt;\u003d K\u003c/strong\u003e and\u003cbr /\u003e\u003cstrong\u003eInvCount[i, j-1] \u0026lt; K\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eIf I increase \u003cstrong\u003ei\u003c/strong\u003e by 1 now, I know that inversion count is going to reduce. After reduction if inversion count is still greater than or equal to \u003cstrong\u003eK\u003c/strong\u003e, we know that threshold for \u003cstrong\u003ei+1\u003c/strong\u003e remains same because we know \u003cstrong\u003eInvCount[i, j-1] \u0026lt; K\u003c/strong\u003e, therefore \u003cstrong\u003eInvCount[i+1, j-1] \u0026lt; K\u003c/strong\u003e is also valid. \u003c/p\u003e\u003cp\u003eNow we keep increasing \u003cstrong\u003ept1\u003c/strong\u003e until inversion count is not less than \u003cstrong\u003eK\u003c/strong\u003e. Once we reach such an index, for this index we need to find it’s threshold, so we start increasing the \u003cstrong\u003ept2\u003c/strong\u003e until we reach threshold of \u003cstrong\u003ept1\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eNow, we need to handle two operations. Let’s say we have right now inversion count for range \u003cstrong\u003e[L, R]\u003c/strong\u003e, we need inversion count for \u003cstrong\u003e[L, R+1]\u003c/strong\u003e quickly and similarly for \u003cstrong\u003e[L+1, R]\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eSo, we use a BIT here. Let’s say in a BIT we have marked all values in range \u003cstrong\u003e[L, R]\u003c/strong\u003e. To get inversion count for \u003cstrong\u003e[L, R+1]\u003c/strong\u003e, we need to count how many values in range \u003cstrong\u003e[L, R]\u003c/strong\u003e are greater than \u003cstrong\u003eA\u003csub\u003eR+1\u003c/sub\u003e\u003c/strong\u003e, which can be easily found by BIT(since all elements in range \u003cstrong\u003e[L, R]\u003c/strong\u003e are marked in BIT). Once we get new inversion count we also mark the value \u003cstrong\u003eA\u003csub\u003eR+1\u003c/sub\u003e\u003c/strong\u003e in BIT.\u003c/p\u003e\u003cp\u003eSimilarly for \u003cstrong\u003e[L+1, R]\u003c/strong\u003e, we count how many values in BIT are less than \u003cstrong\u003eA\u003csub\u003eL\u003c/sub\u003e\u003c/strong\u003e. This count will be reduced from the current inversion count. Also, we unmark **A\u003csub\u003eL\u003c/sub\u003e from the BIT.\u003c/p\u003e\u003cp\u003eBut since all values \u003cstrong\u003eA\u003csub\u003ei\u003c/sub\u003e\u003c/strong\u003e are up to 10\u003csup\u003e9\u003c/sup\u003e and we only need to compare their greater and lesser(exact values doesn’t matter), we use coordinate compression(ie. map larger values to smaller distinct values). After this we can easily mark any \u003cstrong\u003eA\u003csub\u003ei\u003c/sub\u003e\u003c/strong\u003e in the BIT.\u003c/p\u003e\u003cp\u003ePseudo code:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eBIT:\n    getsum(i)   //returns sum of of elements with index \u0026lt;\u003di\n    update(i,val)   //updates val at index i\n\nA\u003dinput\nrank[i] \u003d rank of A[i] in sorted(A[i])\n\npt1 \u003d pt2 \u003d 0\nBIT.update(1,rank);\n\ncur_inv \u003d 0 //inversions of current subarray denoted by [pt1, pt2]\nans \u003d 0\n\nwhile pt1\u0026lt;N:\n    //we increase pt2 until current inversions \u0026lt;K\n    while cur_inv\u0026lt;K and pt2\u0026lt;N\n        pt2 ++\n        //inversion increment due to addition of A[pt1]\n        //increment \u003d number of elements greater in BIT less than A[pt1]\n        inv +\u003d r + 1 - BIT.getsum(A[pt1])\n        //add A[pt2] to BIT\n        BIT.update(A[pt2], 1);\n\n    //all subarrays [pt1, x] are valid, where N \u0026gt; x \u0026gt;\u003d pt2\n    ans +\u003d N-pt2\n\n    //remove A[pt1] from BIT and reflect the change in cur_inv\n    // and increment pt1\n    BIT.update(A[pt1], -1)\n    inv -\u003d BIT.getsum(A[pt1] - 1)\n    pt1++\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnother way would be to use segtree/trie for queries like \u0026quot;find number of elements in range L to R which are less than K\u0026quot;.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100589/problem/I\" title\u003d\"2015 CodeCraft IIIT Hyderabad Replay\"\u003e100589I - Laughing Out Loud\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eGiven a string \u003cstrong\u003eS\u003c/strong\u003e, you have to find out the number of length 3 sub-sequences which are equivalent to \u003cstrong\u003eLOL\u003c/strong\u003e. \u003cstrong\u003e|S|\u003c/strong\u003e \u0026lt;\u003d 10\u003csup\u003e5\u003c/sup\u003e\u003c/p\u003e\u003cp\u003eDifficulty : Easy\u003c/p\u003e\u003cp\u003eExplanation : Subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. \u003c/p\u003e\u003cp\u003eAssume initial string to be \u003cstrong\u003eS\u003c/strong\u003e. If we take a boolean string \u003cstrong\u003eX\u003c/strong\u003e of length \u003cstrong\u003elen(S) (\u003d n)\u003c/strong\u003e. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eif we want to include i\u0027th element of S as part of subsequence : X[i] \u003d 1 \nelse: X[i] \u003d 0\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNumber of different strings \u003cstrong\u003eX\u003c/strong\u003e is equivalent to the number of subsequences.\u003cbr /\u003eWe have a \u003cstrong\u003ey\u003c/strong\u003e bit string of 0’s and 1’s.\u003cbr /\u003eLet \u003cstrong\u003eS \u003d “ABA”\u003c/strong\u003e, then \u003cstrong\u003en \u003d 3\u003c/strong\u003e and all the y bit strings are as follows\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e000\t‘’(None, empty string)\n001\t‘A’\n010\t’B’\n011\t‘BA’\n100\t‘A’\n101\t‘AA’\n110\t‘AB’\n111\t’ABA’\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo, for a sequence of length \u003cstrong\u003en\u003c/strong\u003e, \u003cstrong\u003e2\u003csup\u003en\u003c/sup\u003e\u003c/strong\u003e subsequences are possible. Finding all the subsequences would time out. \u003c/p\u003e\u003cp\u003eAs we know that we only have to find the subsequences of length 3(LOL). A naive code for checking if \u003cstrong\u003eS[i] \u003d ‘L’, S[j] \u003d ‘O’, S[k] \u003d ‘L’\u003c/strong\u003e subject to the condition that \u003cstrong\u003e1 \u0026lt;\u003d i \u0026lt; j \u0026lt; k \u0026lt;\u003d n\u003c/strong\u003e. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eans \u003d 0\nfor i in xrange(1, n+1) :\n     if S[i] \u003d\u003d ‘L’ :\n          for j in xrange(i+1, n+1) :\n               if S[j] \u003d\u003d ‘O’ :\n               for k in xrange(j+1, n+1) : #1\n                    if S[k] \u003d\u003d ‘L’ :       #2\n                         ans +\u003d 1          #3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eComplexity of the above code is \u003cstrong\u003eO(n\u003csup\u003e3\u003c/sup\u003e)\u003c/strong\u003e which would time out.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor i in xrange(1, n+1) :\n     suf[i] \u003d 0\nif S[1] \u003d\u003d ‘L’ :\n     suf[1] \u003d 1\nfor i in xrange(2, n+1) :\n     suf[i] \u003d suf[i-1]\n     if S[i] \u003d\u003d ‘L’ :\n          suf[i] +\u003d 1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSuppose we maintain a suffix-sum array which tells us the number of L’s after index \u003cstrong\u003ei\u003c/strong\u003e till \u003cstrong\u003en\u003c/strong\u003e. As we just to have to find if \u003cstrong\u003eS[i]\u003c/strong\u003e \u003d\u003d ‘L’ , \u003cstrong\u003eS[j]\u003c/strong\u003e \u003d\u003d ‘O’ and we know the number of \u003cstrong\u003ek \u0026gt; j\u003c/strong\u003e and \u003cstrong\u003ek \u0026lt;\u003d n\u003c/strong\u003e is \u003cstrong\u003esuf[j+1]\u003c/strong\u003e. For finding answer we replace #1, #2, #3 by \u003cstrong\u003eans +\u003d suf[j+1]\u003c/strong\u003e. We can reduce the complexity to \u003cstrong\u003eO(n\u003csup\u003e2\u003c/sup\u003e)\u003c/strong\u003e, which would also timeout.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor i in xrange(1, n+1) :\n     pre[i] \u003d 0\nif S[n] \u003d\u003d ‘L’ :\n     pre[n] \u003d 1\nfor(i \u003d n-1; i \u0026gt;\u003d 1; i -\u003d 1) :\n     pre[i] \u003d pre[i+1]\n     if S[i] \u003d\u003d ‘L’ :\n          pre[i] +\u003d 1\t\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSimilarly maintaining another prefix-sum array which tells the number of L’s from 0 to index \u003cstrong\u003ei\u003c/strong\u003e. If we know that \u003cstrong\u003eS[j]\u003c/strong\u003e \u003d\u003d ‘O’, then \u003cstrong\u003epre[i-1]\u003c/strong\u003e tells us the number of L’s before \u003cstrong\u003ej\u003c/strong\u003e and \u003cstrong\u003esuf[j+1]\u003c/strong\u003e tells us the number of L’s after \u003cstrong\u003ej\u003c/strong\u003e. Answer is the summation of product of \u003cstrong\u003esuf[j+1] * pre[j-1]\u003c/strong\u003e such that \u003cstrong\u003eS[j]\u003c/strong\u003e \u003d\u003d ‘O’.\u003cbr /\u003eComplexity of this would be \u003cstrong\u003eO(n)\u003c/strong\u003e with a space of \u003cstrong\u003eO(n)\u003c/strong\u003e, which fits the time limit. \u003c/p\u003e\u003cp\u003eIf we consider a string of length (10\u003csup\u003e5\u003c/sup\u003e) such that all the characters are L except the middle character which is O, then the product would not fit in a 32-bit integer data type. But would fit in a 64-bit integer data type. Maximum possible answer would be of the order 10\u003csup\u003e12\u003c/sup\u003e.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100589/problem/J\" title\u003d\"2015 CodeCraft IIIT Hyderabad Replay\"\u003e100589J - Three Sorted Arrays\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eThe points to note in the problem are:\u003cbr /\u003e1. The arrays are sorted.\u003cbr /\u003e2. We need to find all triplets such that \u003cstrong\u003ei ≤ j ≤ k\u003c/strong\u003e and \u003cstrong\u003eA[i] ≤ B[j] ≤ C[k]\u003c/strong\u003e. \u003c/p\u003e\u003cp\u003eIn worst case the number of triplets will be in order of \u003cstrong\u003eO(P*Q*R)\u003c/strong\u003e, hence brute force solution won’t work.\u003c/p\u003e\u003cp\u003eThere are two approaches to solve this problem.\u003c/p\u003e\u003ch4\u003eBinary Search:\u003c/h4\u003e\u003cp\u003eReducing the problem to finding \u003cstrong\u003ej ≤ k\u003c/strong\u003e and \u003cstrong\u003eB[j] ≤ C[k]\u003c/strong\u003e. This can easily be done using binary search, for each \u003cstrong\u003eB[j]\u003c/strong\u003e we need to find the index of \u003cstrong\u003eC[k]\u003c/strong\u003e which is just smaller than \u003cstrong\u003eB[j]\u003c/strong\u003e, (say index is \u003cstrong\u003eL\u003c/strong\u003e) all the values, present in the index greater than \u003cstrong\u003eL\u003c/strong\u003e, will be greater than \u003cstrong\u003eB[j]\u003c/strong\u003e, hence the number of values greater than \u003cstrong\u003eB[j]\u003c/strong\u003e are \u003cstrong\u003eQ-i\u003c/strong\u003e (assuming 1-based indexing).\u003cbr /\u003eThe computation time will be \u003cstrong\u003eQ(log(R)\u003c/strong\u003e) (for each element we have to do a binary search).\u003c/p\u003e\u003cp\u003eThe problem extends to finding \u003cstrong\u003ei ≤ j ≤ k\u003c/strong\u003e and \u003cstrong\u003eA[i] ≤ B[j] ≤ C[k]\u003c/strong\u003e. We have already found out \u003cstrong\u003ej ≤ k\u003c/strong\u003e and \u003cstrong\u003eB[j] ≤ C[k]\u003c/strong\u003e.\u003cbr /\u003eFor every \u003cstrong\u003eA[i]\u003c/strong\u003e we need to find out the index of \u003cstrong\u003eB[j]\u003c/strong\u003e which is just smaller than \u003cstrong\u003eA[i]\u003c/strong\u003e(say it’s \u003cstrong\u003eM\u003c/strong\u003e) all the values, present in the index greater than \u003cstrong\u003eM\u003c/strong\u003e, will be greater than \u003cstrong\u003eA[i]\u003c/strong\u003e but we also need to find it’s corresponding value in \u003cstrong\u003eC[k]\u003c/strong\u003e, hence a postfix sum array of the values \u003cstrong\u003ej \u0026lt;\u003d k\u003c/strong\u003e and \u003cstrong\u003eB[j] ≤ C[k]\u003c/strong\u003e can be used. The example will help in better understanding.\u003cbr /\u003eThe overall complexity of the algorithm is \u003cstrong\u003eO(P(logQ) + Q(logR))\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eExample:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eA \u003d [1, 5, 6]\nB \u003d [3, 7, 8]\nC \u003d [2, 4, 9]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFirst find the count of all \u003cstrong\u003ej \u0026lt;\u003d k\u003c/strong\u003e such that \u003cstrong\u003eB[j] ≤ C[k]\u003c/strong\u003e and store it in an array. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003et1 \u003d [2,1,1]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003econvert it into postfix-sum array\u003c/p\u003e \u003cpre\u003e\u003ccode\u003et1_new \u003d [4,2,1]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow for every \u003cstrong\u003eA[i]\u003c/strong\u003e we need to find out the index of \u003cstrong\u003eB[j]\u003c/strong\u003e(say \u003cstrong\u003ex\u003c/strong\u003e) which is just greater than \u003cstrong\u003eA[i]\u003c/strong\u003e and \u003cstrong\u003ex \u0026gt;\u003d i\u003c/strong\u003e. The corresponding values would look like. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003et2 \u003d [1, 2, 3] (Array has 1-based indexing).  \n\u003c/code\u003e\u003c/pre\u003e \u003col\u003e   \u003cli\u003eThe value just greater than 1 is 3(at index 1) in \u003cstrong\u003eB[]\u003c/strong\u003e.\u003c/li\u003e   \u003cli\u003eThe value just greater than 5 is 7(at index 2) in \u003cstrong\u003eB[]\u003c/strong\u003e.\u003c/li\u003e   \u003cli\u003eThe value just greater than 6 is 8(at index 3) in \u003cstrong\u003eB[]\u003c/strong\u003e.\u003cbr /\u003eAll the values greater than these indexes will be added in the final answer.(hence the postfix-sum array has to be maintained).\u003c/li\u003e \u003c/ol\u003e \u003cpre\u003e\u003ccode\u003eThe final answer is:\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eans \u003d (t1[1]+t1[2]+t1[3])+(t1[2]+t1[3])+(t1[3])  \u003d t1_new[0+1]+t1_new[1+1]+t1_new[1+1] \u003d 4+2+1 \u003d 7 ~~~~~\u003c/p\u003e\u003ch5\u003e2-pointer search\u003c/h5\u003e\u003cp\u003e2-pointer search just reduces the complexity of finding the index of \u003cstrong\u003eC[k]\u003c/strong\u003e which is just smaller than \u003cstrong\u003eB[j]\u003c/strong\u003e from \u003cstrong\u003eO(n logn)\u003c/strong\u003e to \u003cstrong\u003eO(n)\u003c/strong\u003e. The approach is very intuitive and can be directly used to find the number of values which are larger than \u003cstrong\u003eB[j]\u003c/strong\u003e in \u003cstrong\u003eC[k]\u003c/strong\u003e such that \u003cstrong\u003ej \u0026lt;\u003d k\u003c/strong\u003e directly.\u003cbr /\u003eConsidering an example: \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eB \u003d [1, 4, 5]\nC \u003d [2, 3, 6]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLet there be two pointers fixed at \u003cstrong\u003ej\u003dQ\u003c/strong\u003e and \u003cstrong\u003ek\u003dR\u003c/strong\u003e.\u003cbr /\u003eMove the pointers such that whenever:\u003cbr /\u003e1. \u003cstrong\u003eB[j] ≤ C[k]\u003c/strong\u003e.\u003cbr /\u003ekeep on decrementing \u003cstrong\u003ek\u003c/strong\u003e till \u003cstrong\u003eB[j]\u0026gt;C[k]\u003c/strong\u003e. The difference of \u003cstrong\u003eR\u003c/strong\u003e and present \u003cstrong\u003ek (\u003dR-k)\u003c/strong\u003e is the number of values which are larger than \u003cstrong\u003eB[j]\u003c/strong\u003e in \u003cstrong\u003eC[k]\u003c/strong\u003e such that \u003cstrong\u003ej \u0026lt;\u003d k\u003c/strong\u003e.\u003cbr /\u003e2. \u003cstrong\u003eB[j] \u0026gt; C[k]\u003c/strong\u003e\u003cbr /\u003ekeep on decrementing \u003cstrong\u003ej\u003c/strong\u003e till \u003cstrong\u003eB[j] ≤ C[k]\u003c/strong\u003e. \u003c/p\u003e\u003cp\u003eThe same approach will be used to calculate \u003cstrong\u003ei \u0026lt;\u003d j \u0026lt;\u003d k\u003c/strong\u003e such that \u003cstrong\u003eA[i] ≤ B[j] ≤ C[k]\u003c/strong\u003e using a postfix sum array as described in method 1.\u003c/p\u003e\u003cp\u003eComplexity: \u003cstrong\u003eO(P+Q+R)\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSolution: \u003ca href\u003d\"http://goo.gl/N4qy6Z\"\u003ehttp://goo.gl/N4qy6Z\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLinks: \u003ca href\u003d\"http://www.geeksforgeeks.org/find-a-triplet-that-sum-to-a-given-value/\"\u003ehttp://www.geeksforgeeks.org/find-a-triplet-that-sum-to-a-given-value/\u003c/a\u003e\u003cbr /\u003e\u003ca href\u003d\"http://leetcode.com/2010/04/finding-all-unique-triplets-that-sums.html\"\u003ehttp://leetcode.com/2010/04/finding-all-unique-triplets-that-sums.html\u003c/a\u003e\u003cbr /\u003e\u003ca href\u003d\"http://www.quora.com/Given-an-array-S-of-n-integers-are-there-elements-a-b-c-in-S-such-that-a-+-b-+-c-0-Find-all-unique-triplets-in-the-array-which-gives-the-sum-of-zero/answer/Raziman-Thottungal-Valapu\"\u003ehttp://www.quora.com/Given-an-array-S-of-n-integers-are-there-elements-a-b-c-in-S-such-that-a-+-b-+-c-0-Find-all-unique-triplets-in-the-array-which-gives-the-sum-of-zero/answer/Raziman-Thottungal-Valapu\u003c/a\u003e\u003cbr /\u003e\u003ca href\u003d\"http://stackoverflow.com/questions/3815116/given-two-arrays-a-and-b-find-all-pairs-of-elements-a1-b1-such-that-a1-belong\"\u003ehttp://stackoverflow.com/questions/3815116/given-two-arrays-a-and-b-find-all-pairs-of-elements-a1-b1-such-that-a1-belong\u003c/a\u003e \u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://www.geeksforgeeks.org/count-pairs-difference-equal-k/\"\u003ehttp://www.geeksforgeeks.org/count-pairs-difference-equal-k/\u003c/a\u003e\u003cbr /\u003e-----------------------------------------------------------------------------------\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/gym/100589/problem/K\" title\u003d\"2015 CodeCraft IIIT Hyderabad Replay\"\u003e100589K - Police Catching Thief\u003c/a\u003e\u003c/h2\u003e\u003ch4\u003eBasic Idea\u003c/h4\u003e\u003cp\u003eApply Multi-Source Dijkstra twice : First taking the \u003cstrong\u003eK\u003c/strong\u003e policemen\u0027s initial position as source and second taking the \u003cstrong\u003eQ\u003c/strong\u003e special nodes with power-ups, as source. This would get us the shortest time in which Police can reach any node in the graph in shortest time with or without using the power-up.\u003cbr /\u003eApply a third Dijkstra using the initial position of Thief as source and just check if at any node the police can catch the thief (reach the node before or at equal time as thief) or not.\u003c/p\u003e\u003ch4\u003eNote\u003c/h4\u003e\u003cp\u003eThe above approach works for a more general question when \u003cstrong\u003eV\u003csub\u003et\u003c/sub\u003e\u003c/strong\u003e and \u003cstrong\u003eV\u003csub\u003ep\u003c/sub\u003e\u003c/strong\u003e need not be equal to 1 . Since in the above question \u003cstrong\u003eV\u003csub\u003et\u003c/sub\u003e\u003c/strong\u003e \u003d \u003cstrong\u003eV\u003csub\u003ep\u003c/sub\u003e\u003c/strong\u003e \u003d 1 (to make the question simpler). For Thief , we can just check who reaches the final destination first, the police or thief because if the police can catch the thief on the way, it can definitely reach the destination before or at equal time as that of thief since \u003cstrong\u003eV\u003csub\u003ep\u003c/sub\u003e\u003c/strong\u003e \u0026gt;\u003d \u003cstrong\u003eV\u003csub\u003et\u003c/sub\u003e\u003c/strong\u003e always in this case.\u003cbr /\u003e(The proof of this is left to readers and also why it won’t work if \u003cstrong\u003eV\u003csub\u003ep\u003c/sub\u003e\u003c/strong\u003e \u0026lt; \u003cstrong\u003eV\u003csub\u003et\u003c/sub\u003e\u003c/strong\u003e).\u003c/p\u003e\u003ch4\u003eExplanation\u003c/h4\u003e\u003cp\u003eThere are many interesting things to note in this question. Lets analyze the question from the basics. \u003c/p\u003e\u003cp\u003eFirst , What does the question ask us to do? The Police needs to catch the thief. But the power-up makes the process interesting. Although it’s specifically mentioned that only single power-up is available for use, but the thief doesn’t know which policeman will avail which power up to increase his speed and we need to print the shortest time in which thief can escape regardless of whatever path the police might take. Therefore, when asked if the thief can escape or not, we can safely assume that the police will take the best possible combination of special node and power up to catch the thief. That is, for each node, we need to know the shortest time in which police can reach that node with or without taking the power up. This assumption doesn’t violate the fact that we have only a single power-up because suppose for some node “x”\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ereachingTimeOfPolice[x] \u0026lt;\u003d reachingTimeOfThief[x]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen, in such a case , the police can catch the thief at node \u003cstrong\u003ex\u003c/strong\u003e. This means that one of the \u003cstrong\u003eK\u003c/strong\u003e different Policemens can reach node ”x“ before the thief and can catch him there with or without using the power-up depending on the position of node \u003cstrong\u003ex\u003c/strong\u003e. Therefore, the thief cannot be sure of reaching his destination using this path because a single policeman using only a single power-up (or maybe even without it) can catch him.\u003cbr /\u003eTherefore, in short, we need to find the shortest time in which police (i.e any of the \u003cstrong\u003eK\u003c/strong\u003e different policemen) can reach any node (or only the destination in this case. See the NOTE) with or without using the power-up (whichever takes the shorter time). Once we have this information with us, we can simply check if the police reaches any node (or only the destination in this case) before thief and if this is the case, the thief cannot take that path. Like this, check for every node and just print the shortest time taken by the thief to reach the destination along such a path where no police can catch the thief at any node.\u003c/p\u003e\u003cp\u003eSecond, How to do it?\u003cbr /\u003eA single multi-source Dijkstra taking the \u003cstrong\u003eK\u003c/strong\u003e different police-men’s initial positions as the source would give us the shortest time in which the police (i.e. any one of the \u003cstrong\u003eK\u003c/strong\u003e different policemen) can reach any node in the shortest time without taking the power-up. Next apply another multi-source Dijkstra using the \u003cstrong\u003eQ\u003c/strong\u003e different special nodes as source and this time, make sure to put :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estartTimeOfSpecialNode[i] \u003d policeTimeWithoutPowerUp[SpecialNode[i]];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAfter the second Dijkstra,\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epoliceTime[i] \u003d min(policeTimeWithoutPowerUp[i], policeTimeWithPowerUp[i]);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNext, apply a third Dijkstra for thief and add a condition that :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eif(thiefTime[i]\u0026lt;policeTime[i])\n     Only Then explore its neighbours\nelse\n     thiefTime[i] \u003d INF\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe above condition is for the general case. For this specific question just check \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eif(thiefTime[Destination]\u0026lt;policeTime[Destination])\n     Print thiefTime[Destination]\n     else\n          print -1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["iiith","codecraft","tutorial"]}}