{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1493471181,"rating":36,"authorHandle":"RussianCodeCup","modificationTimeSeconds":1493471230,"id":51773,"title":"\u003cp\u003eRussian Code Cup 2017 — Third Qualification Round Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eA. Spreadsheets\u003c/h2\u003e\u003cp\u003eLet us subtract 1 from \u003ci\u003ek\u003c/i\u003e, now the columns are numbered from 0.\u003c/p\u003e\u003cp\u003eLet us first find out how many characters are there in the name of the column. To do it let us subtract powers of 26 from \u003ci\u003ek\u003c/i\u003e, one by one, until the current power is greater than the remaining number \u003ci\u003ek\u003c/i\u003e\u0027.\u003c/p\u003e\u003cp\u003eNow the name of the column is \u003ci\u003ek\u003c/i\u003e\u0027 in 26-based notation where characters A–Z are used as digits, prepended with leading A-s to the required length. You can either convert it using standard library function (in this case you must replace digits 0–9, A–P that will be used by the required digits), or implement a textbook algorithm of conversion to another base.\u003c/p\u003e\u003cp\u003eFinal note: a day before the round one of the testers pointed out that CF Beta 1 Round problem B was similar to this one. After a discussion, taking into account that CF1 round was long ago, the problem is actually easier than CF1B problem, and we had no well prepared and easy enough replacement problem, we decided to keep the problem.\u003c/p\u003e\u003ch2\u003eB. Mortal Combat\u003c/h2\u003e \u003cp\u003eLet us count how many hit points the boss loses if attacked by the \u003ci\u003ei\u003c/i\u003e-th hero: \u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e·⌈ \u003ci\u003eh\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e / \u003ci\u003eA\u003c/i\u003e⌉. Sort heroes by non-increasing of \u003ci\u003ep\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e and send them to attack the boss in this order.\u003c/p\u003e\u003ch2\u003eC. A Bit Palindromic Numbers\u003c/h2\u003e \u003cp\u003eLet us find out how to count a bit palindromic numbers among the first \u003ci\u003en\u003c/i\u003e positive integers. Now to solve the problem for the range from \u003ci\u003el\u003c/i\u003e to \u003ci\u003er\u003c/i\u003e we count the number of a bit palindromic numbers among first \u003ci\u003er\u003c/i\u003e, among the first \u003ci\u003el\u003c/i\u003e - 1, and subtract the latter from the former.\u003c/p\u003e\u003cp\u003eAll numbers from 1 to 9 are a bit palindromic, so if \u003ci\u003en\u003c/i\u003e ≤ 9 the answer is \u003ci\u003en\u003c/i\u003e. Otherwise let us add 9 to the answer and count a bit palindromic numbers from 10 to \u003ci\u003en\u003c/i\u003e. Let us consider ten integers from 10\u003ci\u003ek\u003c/i\u003e to 10\u003ci\u003ek\u003c/i\u003e + 9, where \u003ci\u003ek\u003c/i\u003e ≠ 0. Only one of them is a bit palindromic, the one that has the same first digit as \u003ci\u003ek\u003c/i\u003e. So there is one a bit palindromic number from 10 to 19, one from 20 to 29, and so on.\u003c/p\u003e\u003cp\u003eLet \u003ci\u003en\u003c/i\u003e \u003d 10\u003ci\u003ek\u003c/i\u003e + \u003ci\u003ed\u003c/i\u003e, where 0 ≤ \u003ci\u003ed\u003c/i\u003e ≤ 9. So if \u003ci\u003ed\u003c/i\u003e is greater or equal to the first digit of \u003ci\u003ek\u003c/i\u003e, there are \u003ci\u003ek\u003c/i\u003e a bit palindromic numbers from 10 to \u003ci\u003en\u003c/i\u003e, if it is less then the first digit of \u003ci\u003ek\u003c/i\u003e, there are \u003ci\u003ek\u003c/i\u003e - 1 such numbers.\u003c/p\u003e\u003ch2\u003eD. Tree and Polynomials\u003c/h2\u003e \u003cp\u003eLet us walk through the key ideas of the solution.\u003c/p\u003e\u003cp\u003eFirst, notice that6 you can solve problem independently for the two types of the queries. That is because operations don\u0027t depend on the values in the vertices.\u003c/p\u003e\u003cp\u003eSecond idea is the following. Instead of storing particular values in the vertices, let us store polynomial that must be evaluated from it depth to get the value.\u003c/p\u003e\u003cp\u003eWe cannot process queries directly, considering all vertices affected by a query, and adding the query polynomial to the polynomial in the vertex: that would take \u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e·\u003ci\u003ek\u003c/i\u003e) which is too slow. Let us use lazy propagation then.\u003c/p\u003e\u003cp\u003eFor the queries of the first type we need to add a polynomial \u003ci\u003eq\u003c/i\u003e(\u003ci\u003et\u003c/i\u003e) to each vertex in a subtree of \u003ci\u003ev\u003c/i\u003e. Let us just store information about that: for each vertex \u003ci\u003ev\u003c/i\u003e let us store \u003ci\u003epush\u003c/i\u003e1[\u003ci\u003ev\u003c/i\u003e] that has the sum of all polynomials that affected the vertex \u003ci\u003ev\u003c/i\u003e in queries of the first type.\u003c/p\u003e\u003cp\u003eSimultaneously let us store the sum of all affecting queries of the second type as a polynomial \u003ci\u003epush\u003c/i\u003e2[\u003ci\u003ev\u003c/i\u003e] for each vertex \u003ci\u003ev\u003c/i\u003e. \u003c/p\u003e\u003cp\u003eNow denote as \u003ci\u003esum\u003c/i\u003e1[\u003ci\u003eu\u003c/i\u003e] the sum of all polynomials that affect vertex \u003ci\u003eu\u003c/i\u003e in queries of the first type.\u003c/p\u003e\u003cp\u003eTo calculate \u003ci\u003esum\u003c/i\u003e1[\u003ci\u003eu\u003c/i\u003e] let us run DFS from the root, and keep track of a polynomial \u003ci\u003ecur\u003c/i\u003e. Entering the vertex \u003ci\u003ev\u003c/i\u003e add \u003ci\u003epush\u003c/i\u003e1[\u003ci\u003ev\u003c/i\u003e] to \u003ci\u003ecur\u003c/i\u003e, leaving \u003ci\u003ev\u003c/i\u003e subtract it back. When we have entered the vertex \u003ci\u003eu\u003c/i\u003e, assign \u003ci\u003esum\u003c/i\u003e1[\u003ci\u003eu\u003c/i\u003e] \u003d \u003ci\u003ecur\u003c/i\u003e.\u003c/p\u003e\u003cp\u003eSimilarly, denote as \u003ci\u003esum\u003c/i\u003e2[\u003ci\u003eu\u003c/i\u003e] the sum of all polynomials that affect the vertex \u003ci\u003eu\u003c/i\u003e in queries of the second type.\u003c/p\u003e\u003cp\u003eTo calculate \u003ci\u003esum\u003c/i\u003e2[\u003ci\u003eu\u003c/i\u003e] also use DFS, sum2[u] is equal to the sum of values \u003ci\u003esum\u003c/i\u003e2[\u003ci\u003ev\u003c/i\u003e] for all children of \u003ci\u003eu\u003c/i\u003e, and the value \u003ci\u003epush\u003c/i\u003e2[\u003ci\u003eu\u003c/i\u003e].\u003c/p\u003e\u003cp\u003eAfter we have calculated polynomials \u003ci\u003esum\u003c/i\u003e1[\u003ci\u003eu\u003c/i\u003e] and \u003ci\u003esum\u003c/i\u003e2[\u003ci\u003eu\u003c/i\u003e] for each vertex, evaluate them on \u003ci\u003ed\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e] and add the results, that is the answer for that vertex.\u003c/p\u003e\u003cp\u003eTime and memory are both \u003ci\u003eO\u003c/i\u003e(\u003ci\u003enk\u003c/i\u003e).\u003c/p\u003e\u003ch2\u003eE. Nice Report\u003c/h2\u003e \u003cp\u003eLet\u0027s solve one additional problem before proceeding to the main one. You are given a sequence (\u003ci\u003ea\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e) of some objects and somebody asks you to find out how many different objects are presented in this sequence. However, some restrictions apply to the ways you are allowed to process given data:\u003c/p\u003e\u003col\u003e \u003cli\u003e once the object \u003ci\u003ea\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e is read, it\u0027s lost forever: the next read will return \u003ci\u003ea\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e and there is no way to obtain \u003ci\u003ea\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e again; \u003c/li\u003e\u003cli\u003e you can only use \u003ci\u003eO\u003c/i\u003e(1) additional memory \u003c/li\u003e\u003c/ol\u003e\u003cp\u003eTo solve this subproblem we will use the fact that expected value of minimum of \u003ci\u003em\u003c/i\u003e value uniformly distributed over segment [0;1] is 1 / (\u003ci\u003em\u003c/i\u003e + 1). \u003c/p\u003e\u003cp\u003eConsider a hash function \u003ci\u003eh\u003c/i\u003e: \u003ci\u003eA\u003c/i\u003e → [0;1] which transforms objects \u003ci\u003ea\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e to some number from [0;1]. Define \u003ci\u003eM\u003c/i\u003e as \u003ci\u003eM\u003c/i\u003e \u003d \u003ci\u003emin\u003c/i\u003e {\u003ci\u003eh\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e), \u003ci\u003eh\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e), ..., \u003ci\u003eh\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e)}. This value can be transformed to the problem solution as 1 / \u003ci\u003eM\u003c/i\u003e - 1. However, we could run out of luck and end up in the situation where some \u003ci\u003eh\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e) is too small and spoils the answer too much. To deal with it, we can average the answer over several runs with different hash functions \u003ci\u003eh\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e, \u003ci\u003eh\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e, ..., \u003ci\u003eh\u003c/i\u003e\u003csub\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e for some fixed \u003ci\u003ek\u003c/i\u003e.\u003c/p\u003e\u003cp\u003eFirst, let\u0027s solve the case of acyclic graph. Any acyclic graph has topological sort: vertices order that respects edge directions: only edges from latter vertices to earlier ones exist. Let\u0027s label each vertex with some random number uniformly distributed over [0;1]. Topological sort existence allows us to calculate the minimal reachable label \u003ci\u003eM\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e for each vertex by some kind of dynamic programming. After this calculation, we can approximate the number of reachable vertices from \u003ci\u003ei\u003c/i\u003e as 1 / \u003ci\u003eM\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - 1. Again, we need to average results from several iterations to improve answer precision.\u003c/p\u003e\u003cp\u003eBut given graph can contain cycles. To create an acyclic graph we can build the graph condensation by compressing strongly connectivity components. In the condensed graph each vertex \u003ci\u003ei\u003c/i\u003e corresponds to \u003ci\u003ew\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e vertices in the original graph. To finally solve the problem we\u0027ll change vertex labeling phase a bit: a simple random label becames minimal value from \u003ci\u003ew\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e random value from [0;1] rolls.\u003c/p\u003e\u003cp\u003eA curious reader can find more information related to this problem by reading an article \u0026quot;Size-Estimation Framework with Applications to Transitive Closure and Reachability\u0026quot; located at \u003ca href\u003d\"http://cohenwang.com/edith/Papers/tcest.pdf?ccid\u003d56193028c843774483746d25ed6914e9\"\u003e\u003c/a\u003e\u003ca\u003ehttp://cohenwang.com/edith/Papers/tcest.pdf\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e","tags":[]}}