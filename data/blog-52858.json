{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1498264628,"rating":0,"authorHandle":"SAeed","modificationTimeSeconds":1498264628,"id":52858,"title":"\u003cp\u003eSPU Contest #14\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e \u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214317/problem/Blue\"\u003eBlue — Functions again\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eDP\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eWe can solve this problem with a DP array using the following dimensions:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003ei\u003c/code\u003e indicating the current position.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003eopened\u003c/code\u003e indicating whether or not we have started picking elements or we are still leaving them.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ccode\u003eminus\u003c/code\u003e If you noticed the \u003ccode\u003e-1\u003c/code\u003e indicated in the equation, you will know that the first pair of number is multiplied by \u003ccode\u003e1\u003c/code\u003e thus their sign doesn\u0027t change, then the second pair is multiplied by \u003ccode\u003e-1\u003c/code\u003e changing it\u0027s sign, and so on.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eOur moves depend on the value of \u003ccode\u003eopen\u003c/code\u003e variable:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eIf we haven\u0027t started picking elements yet, then we have 2 choices. We either continue to the next position without starting picking elements, or we start picking elements and move to the next position.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf we have already started picking elements then we have also two choices. We either stop picking elements and make no further calls for the next position, or we can keep picking elements and move to the next position\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#define _CRT_SECURE_NO_WARNINGS\n#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint n;\nll a[100100];\nint vis[100100][2][2];\nll memo[100100][2][2];\n\nll dp(int i, int opened, int minus){\n\tif (i \u003d\u003d n) return -1e18;\n\n\tll \u0026amp;ret \u003d memo[i][opened][minus];\n\tif (vis[i][opened][minus]) return ret;\n\tvis[i][opened][minus] \u003d 1;\n\n\tif (opened){\n\t\tll mult \u003d abs(a[i] - a[i - 1]);\n\t\tif (minus) mult *\u003d -1;\n\t\tret \u003d mult;\n\t\tret \u003d max(ret, mult + dp(i + 1, 1, 1 - minus));\n\t}\n\telse{\n\t\tret \u003d dp(i + 1, 0, 0);\n\t\tret \u003d max(ret, dp(i + 1, 1, 0));\n\t}\n\treturn ret;\n}\n\nint main(){\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\t\n\tcin \u0026gt;\u0026gt; n;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i];\n\tcout \u0026lt;\u0026lt; dp(0, 0, 0) \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214317/problem/Green\"\u003eGreen — Martian Dollar\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eBrute Force\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eTry each pair of days to buy the bourles in the first, and sell them in the second.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n^2)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#define _CRT_SECURE_NO_WARNINGS\n#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nll a[100100];\n\nint main(){\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\t\n\tll n, money; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; money;\n\tfor (int i \u003d 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i];\n\tll ans \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\tfor (int j \u003d i; j \u0026lt; n; j++){\n\t\t\tll buy \u003d money / a[i];\n\t\t\tll sell \u003d buy * a[j];\n\t\t\tll remainingMoney \u003d money % a[i];\n\t\t\tans \u003d max(ans, sell + remainingMoney);\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214317/problem/Purple\"\u003ePurple — Planets\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eDijekstra\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eObserve that when we visit some planet, the best strategy is to arrive as early as we can and then wait for the nearest free moment of time to move further. Hence this problem can be solved with the Dijkstra\u0027s algorithm by slightly altering the definition of a shortest distance. When we process a planet (meaning that we already know the minimum time needed to reach it), we need to check the array of arrival times for this planet and find the first moment of time in which we can leave this planet — this will be the distance that we will be adding to outgoing paths from this planet. It\u0027s clear that we will traverse each array of arrival times no more than once. Additionally, one must pay attention to these cases: when a traveller arrives to planet 1 at time 0 (then Jack has to wait) and when a traveller arrives to planet n at the same time as Jack (then Jack needs not to wait).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n log(n))\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#define _CRT_SECURE_NO_WARNINGS\n#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nvector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; G[100100];\nvector\u0026lt;int\u0026gt; arrive[100100];\nll dist[100100];\n\nint main(){\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\t\n\tint n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tfor (int i \u003d 0; i \u0026lt; m; i++){\n\t\tint a, b, w; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; w;\n\t\tG[a].push_back(make_pair(b, w));\n\t\tG[b].push_back(make_pair(a, w));\n\t}\n\tfor (int i \u003d 1; i \u0026lt;\u003d n; i++){\n\t\tint k; cin \u0026gt;\u0026gt; k;\n\t\twhile (k--){\n\t\t\tint t; cin \u0026gt;\u0026gt; t;\n\t\t\tarrive[i].push_back(t);\n\t\t}\n\t}\n\n\tfor (int i \u003d 1; i \u0026lt;\u003d n; i++) dist[i] \u003d 1e18;\n\tpriority_queue\u0026lt;pair\u0026lt;ll, int\u0026gt;, vector\u0026lt;pair\u0026lt;ll, int\u0026gt; \u0026gt;, greater\u0026lt;pair\u0026lt;ll, int\u0026gt; \u0026gt; \u0026gt; q;\n\tq.push(make_pair(0, 1));\n\tdist[1] \u003d 0;\n\twhile (!q.empty()){\n\t\tll w \u003d q.top().first, node \u003d q.top().second; q.pop();\n\n\t\tif (dist[node] \u0026lt; w) continue;\n\t\tfor (int i \u003d 0; i \u0026lt; arrive[node].size(); i++) if (arrive[node][i] \u003d\u003d w) w++;\n\n\t\tfor (int i \u003d 0; i \u0026lt; G[node].size(); i++){\n\t\t\tll edge \u003d G[node][i].second;\n\t\t\tint nxt \u003d G[node][i].first;\n\t\t\tif (dist[nxt] \u0026lt; w + edge) continue;\n\t\t\tdist[nxt] \u003d w + edge;\n\t\t\tq.push(make_pair(dist[nxt], nxt));\n\t\t}\n\t}\n\n\tif (dist[n] \u003d\u003d 1e18) dist[n] \u003d -1;\n\tcout \u0026lt;\u0026lt; dist[n] \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214317/problem/Red\"\u003eRed — Magical Array\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eCombinatorics\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eWe can divide our array into parts, where each part contains the same elements. Now in how many ways can we divide a part into a sub-array? It\u0027s the same question as in how many ways can we choose 2 locations out of the range to be the start of the sub-array, and the end of the sub-array? suppose the length of a range is \u003ccode\u003eN\u003c/code\u003e, then the answer for this range is:\u003c/p\u003e\u003cp\u003e\u003ccode\u003eC(N, 2) \u003d (N * (N + 1)) / 2\u003c/code\u003e where \u003ccode\u003eC\u003c/code\u003e is known as \u0026quot;Tawafeek\u0026quot;\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#define _CRT_SECURE_NO_WARNINGS\n#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\t\n\tint n; cin \u0026gt;\u0026gt; n;\n\tint lasti \u003d 1e9 + 1;\n\tll cnt \u003d 0, ans \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\tint a; cin \u0026gt;\u0026gt; a;\n\t\tif (a \u003d\u003d lasti) cnt++;\n\t\telse{\n\t\t\tans +\u003d (cnt * (cnt + 1)) / 2;\n\t\t\tcnt \u003d 1;\n\t\t}\n\t\tlasti \u003d a;\n\t}\n\tans +\u003d (cnt * (cnt + 1)) / 2;\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214317/problem/Yellow\"\u003eYellow — Life Without Zeros\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eImplementation\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eAll you need to do is what is exactly said in the problem statement. Calculate \u003ccode\u003ec \u003d a + b\u003c/code\u003e, then remove all zeros from \u003ccode\u003ea\u003c/code\u003e, \u003ccode\u003eb\u003c/code\u003e and \u003ccode\u003ec\u003c/code\u003e, and check if the equation is still correct. You only need to know how to write a simple code that removes zeros from a given number.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(number of digits of (a) or (b))\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#define _CRT_SECURE_NO_WARNINGS\n#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nll getNonZero(ll n){\n\tvector\u0026lt;int\u0026gt; digits;\n\twhile (n){\n\t\tint digit \u003d n % 10;\n\t\tif (digit !\u003d 0) digits.push_back(digit);\n\t\tn /\u003d 10;\n\t}\n\treverse(digits.begin(), digits.end());\n\tll ret \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; digits.size(); i++) ret \u003d ret * 10 + digits[i];\n\treturn ret;\n}\n\nint main(){\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\t\n\tll a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\tll c \u003d a + b;\n\ta \u003d getNonZero(a);\n\tb \u003d getNonZero(b);\n\tc \u003d getNonZero(c);\n\tif (a + b \u003d\u003d c) cout \u0026lt;\u0026lt; \u0026quot;YES\u0026quot; \u0026lt;\u0026lt; endl;\n\telse cout \u0026lt;\u0026lt; \u0026quot;NO\u0026quot; \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}