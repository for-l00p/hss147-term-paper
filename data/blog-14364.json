{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1413828177,"rating":0,"authorHandle":"Enchom","modificationTimeSeconds":1417016067,"id":14364,"title":"\u003cp\u003ePolly Training #3 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003e\u003cstrong\u003eA. Queens\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eЗадачата е стандартна и много известна. Ако имате желанието да чиитвате, \u003ca href\u003d\"http://oeis.org/A000170/list\"\u003eотговорите ги има в интернет сметнати до N\u003d26\u003c/a\u003e. За да решите задачата обаче се очакваше да напишете свестен бектракинг. Всъщност цялата идея на задачата е да ви научи как да си правите бектракинга и как да следите скоростта му. В повечето задачи с бектракинг без мемоизации сложността е експоненциална, следователно след като напишете нещо и искате да го пуснете да смята, не е добра идея да го пуснете директно за N\u003d17 примерно. Първо е добре да предположите скоростта му. Ако примерно N\u003d14 работи за 1сек, а N\u003d15 за 10сек, добро предположение е, че N\u003d16 ще работи за около 100сек, а N\u003d17 за около 1000сек. Това е далеч от точно, но заради експоненциалният характер на бектракинга често е полезно. \u003c/p\u003e\u003cp\u003eНека да споменем и конкретно задачата. Изискваше се константно да проверяваме дали диагонал/ред/колона са заети, и константно да ги маркираме/демаркираме. Това е лесно чрез bool-еви масиви. При клетка с кординати (x,y) реда се кодира от x, колоната от y, единият диагонал от x+y, а другият от x-y. За да държите x-y като индекс на bool-ев масив е полезен offset около 20, който не би забавил бързодействието.\u003c/p\u003e\u003cp\u003eСлед като имате bool-евите масиви, бактракинг по редовете е добра техника. Това доведе авторското решение до 30 минути за N\u003d17. Добра оптимизация сваляща времето двойно е да забележите, че всички разположения започващи със царица на първи ред в клетки 1~N/2 са колкото и тези на слагане на царица в клетки N/2~N (за четно N). Следователно можем да съкратим двойно случаите които проверяваме. Това лесно се разширява и за нечетно N като игнорираме средната клетка.\u003c/p\u003e\u003cp\u003eТова доведе до решение за 15 минути на N\u003d17.\u003c/p\u003e\u003cp\u003eЗадачата е много интересна и има място за ужасно много на вид оптимизации. Все пак, сметнато е до N\u003d26 със отговор 22 317 699 616 364 044 (22 билиарда) , а решение по-добро от оптимизирано изчерпване не е известно.\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003eB. War\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003e\u003cstrong\u003eКлючово наблюдение\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eКакво е важно да забележим в задачата? Нека описваме i-тата стъпка с (SXi,SYi). Това ще значи че сме се придвижили със SXi по X-кординатата и със SYi по Y-кординатата. Тогава следва, че искаме да намерим всички решения, за които:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eИмаме (SX1,SY1); (SX2,SY2); ... (SXk,SYk).\nИ са изпълнение условията:\nSX1+SX2+SX3+...+SXk \u003d X\nSY1+SY2+SY3+...+SYk \u003d Y\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКакво се забелязва? В условията имаме разделеност между X и Y. Тоест нищо не ги обвързва по никакъв начин. Следва, че можем да разделим задачата на две. По колко начина можем да направим сума X, и по колко начина сума Y с по точно K неотрицателни числа по-малки от , след което да умножим отговорите.\u003c/p\u003e\u003cp\u003eРазбиването на число на суми лесно се реализира с динамично програмиране:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eF[i][j] \u003d по колко начина можем да направим i като сума на j числа\nF[i][j] +\u003d F[i-k][j-1] за 0\u0026lt;\u003dk\u0026lt;\u003dlimit; k\u0026lt;\u003di, като limit е съответната максимално стъпка\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТова може да бъде смятано за O(N^2) използвайки префиксни суми.\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003eC. World Domination\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eЗадачата е от IOI решена от 64 човека. Задачата не е много трудна ако се досетиш за правилният метод, което е трудната част. Макар плъзгащи прозорция да изглежда като интуитивна идея, решението всъщност се базира на \u003cstrong\u003eдвоично търсене\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eНека сме фиксирали отговор \u003cstrong\u003eK\u003c/strong\u003e. Трябва да можем да кажем дали оптималният е по-голям или по-малък от K. Нека преработим таблицата. Всяко число по-голямо от K ще е 1, равното на K ще е 0, а по малките -1. Лесно се вижда, че ако сумата на таблица е положителна — отговора е по-голям от K, ако е отрицателна — по-малък, и ако е 0 — значи отговора е K. От това лесно можем да видим дали има таблица с по-малък отговор от K и можем да решим кой край на двуичното да преместим.\u003c/p\u003e\u003cp\u003eРешението е със сложност O(N*M*log).\u003c/p\u003e\u003c/div\u003e","tags":[]}}