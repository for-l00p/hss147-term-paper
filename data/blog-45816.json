{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1467371522,"rating":1,"authorHandle":"aostankov","modificationTimeSeconds":1467628661,"id":45816,"title":"\u003cp\u003eДень 4. Минимальный остов.\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eЗадача A. Lomsat gelral.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eНазвание этой задачи является анаграммой к Small to large. И это не спроста :-) Авторское решение по этой задаче использует классическую технику пересчета множеств на дереве. Простейшим решением этой задачи является следующее: давайте для каждой вершины поддерживать один map\u0026lt;int, int\u0026gt; — для каждого цвета, сколько раз он встречается, один set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; — пары количество повторений и цвет, и число sum являющееся суммой самых частых символов. Для того, чтобы посчитать эти величины для вершины v нужно сначала посчитать их для всех сыновей, а потом просто сливать эти значения. Такой подход правильный, но медленный (сложность получится O(n2logn)). Но давайте немного улучшим это решение, каждый раз когда нам надо склеить 2 map-а a и b, будем клеить меньший из них (просто итерируясь по нему) к большему (это и есть small to large). Давайте теперь рассмотрим цвет какой-нибудь вершины: каждый раз, когда он будет перекидываться из одного map-а в другой размер другого будет как минимум вдвое больше. Таким образом, это цвет поперебрасывается не более logn раз. Каждой перебрасывание делается за O(logn). Просуммировав это по всем вершинам получаем сложность O(nlog2n).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача B. День объединения.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВ задаче было дано n точек на плоскости и нужно было построить по ним минимальный остов. Это простая задача на алгоритм Прима за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e, который был рассмотрен на последней лекции. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача D. Минимальное остовное дерево по каждому ребру.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВ задаче требовалось для каждого ребра найти вес минимального остовного дерева такого, что данное ребро обязательно в него входит. Для начала построим минимальный остов. Очевидно, что для ребер, которые уже в MST, ответ будет равен весу MST. Посмотрим, что происходит с минимальным остовом, если у нас появляется ребро, которого нет в MST. При добавлении такого ребра в дереве образуется цикл и это уже не дерево. Чтобы дерево вновь стало деревом нам надо разорвать цикл, то есть удалить одно ребро и удалить его так, чтобы вес дерева был минимальным из возможных. Да, выгодней всего было бы удалить новое ребро, но мы этого не можем сделать, значит нам надо найти максимальное по всему ребро в цикле и удалить его, тогда ответом будет сумма_MST + вес_нового_ребра — вес_удаленного_ребра. Посмотрим, из чего состоит цикл в дереве при добавлении нового ребра. Если мы добавляем ребро (u, v), то цикл будет содержать ребро (u, v), а также ребра на пути (v, lca(u v)) и (u, lca(u, v)). То есть мы можем найти максимальное число, записанное на ребрах (u, lca(u, v)) и (v, lca(u, v)), это делается аналогично технике двоичного подъема.\u003c/p\u003e\u003c/div\u003e","tags":[]}}