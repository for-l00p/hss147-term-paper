{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1506708713,"rating":2,"authorHandle":"Siriuslight","modificationTimeSeconds":1506708713,"id":54843,"title":"\u003cp\u003eTwo types of DFS ???\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI have seen two implentation of DFS that people generally use. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003ebool visit[N];\nint par[N];\nvector\u0026lt;int\u0026gt; g[N];\nvoid dfs1(int v)\n{\n    visit[v] \u003d true;\n    for(auto child : g[v])\n    {\n         if(!visit[child])\n              dfs1(child);\n    }\n\n}\n\nvoid dfs2(int v, int p)\n{\n    par[v] \u003d p;\n    for(auto child : g[v])\n    {\n          if(child \u003d\u003d par[v])\n                continue;\n          dfs(child,v);\n    }\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhat is the difference between these two implementations? Is the second implementation only used when we need parent or some other cases also. I always maintain visit array, but some people don\u0027t does it affect. I think it should cause infinite recursion but it doesn\u0027t.\u003c/p\u003e\u003cp\u003eCan someone please explain it in details.\u003c/p\u003e\u003c/div\u003e","tags":[]}}