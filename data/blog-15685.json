{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1420847562,"rating":144,"authorHandle":"burunduk3","modificationTimeSeconds":1420885713,"id":15685,"title":"\u003cp\u003eПерсистентная очередь и её друзья\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003eПривет\u003c/h4\u003e\u003cp\u003eНекоторое время назад я наткнулся на персистентные структуры данных и, в частности, на \u003ca href\u003d\"http://neerc.ifmo.ru/wiki/index.php?title\u003d%D0%9F%D0%B5%D1%80%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BD%D1%82%D0%BD%D0%B0%D1%8F_%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C\"\u003eописание персистентной очереди на вики-конспектах ИТМО\u003c/a\u003e. Всё бы хорошо, только как-то сложновато: чтобы реализовать одну маленькую очередь используется пять (в другом варианте — шесть) стеков.\u003c/p\u003e\u003cp\u003eКратно напомню историю проблемы, уложусь всего в четыре стека и заодно немного расскажу про персистентность вообще .\u003c/p\u003e\u003ch4\u003eПерсистентность\u003c/h4\u003e\u003cp\u003eПерсистентность для структуры данных — возможность хранить несколько версий сразу. Другими словами, каждая изменяющая операция (например, у структуры данных «стек» есть операции \u003cstrong\u003epush\u003c/strong\u003e и \u003cstrong\u003epop\u003c/strong\u003e) не меняет саму структуру, а возвращает новую стуктуру данных (обычно в виде ссылки на новую версию), в которой хранится то, что должно было появиться в старой после этой операции. Это эквивалентно тому, что можно (быстро) скопировать структуру данных целиком, а потом уже выполнять всякие операции.\u003c/p\u003e\u003cp\u003eОдна из самых простых для персистенизации структур данных — это вышеупомянутый стек. Персистентый стек — это дерево, в котором в каждой вершине хранится элемент данных и ссылка на следующий (в сторону корня). Версия стека — просто ссылка на одну из вершин. Корень дерева соответствует пустому стеку. Удаление из стека — это переход к следующей вершине по ссылке, добавление — подвешивание новой вершины.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 1\" src\u003d\"/predownloaded/08/cd/08cdc28bd627c24dd065ae0fabcf13a4ab42116e.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eНа рисунке показан пример персистентного стека до и после операции \u003ccode\u003eθ \u003d push (δ, 78)\u003c/code\u003e. Греческими буквами обозначены версии стека, например, версии \u003cstrong\u003eη\u003c/strong\u003e соответствует стек с элементами \u003ccode\u003e34, 12, 55, 26\u003c/code\u003e, а \u003cstrong\u003eα\u003c/strong\u003e — пустой стек. В процессе работы со стеком могут появляться новые вершины, но старые не будут ни исчезать, ни изменяться, в этом и есть смысл персистентности.\u003c/p\u003e\u003cp\u003eАналогичным образом можно персистенизировать и другие структуры данных, которые представляются в виде небольших структурок с ациклическими связями: двоичные деревья, дерево отрезков в варианте реализации сверху вниз. В случае двоичных деревьев обычно при запросе появляется не одна новая вершина, а сразу несколько, потому что надо создать новые версии для вершин, которые были затронуты и для тех, у которых были затронуты какие-либо потомки.\u003c/p\u003e\u003cp\u003eЛовкость лап и дерево отрезков позволяют придумать структуру данных «персистентный массив» с операциями «увеличить длину массива на один» и «изменить элемент», однако каждая такая операция будет выполняться за \u003ccode\u003eO(log)\u003c/code\u003e (логарифм длины массива). Поскольку любую структуру данных можно представить как изменение каких-то значений на массиве, то казалось бы, любую структуру данных можно персистенизировать с добавлением лишнего \u003ccode\u003eO(log)\u003c/code\u003e в асимптотике. Однако не всё так просто (впрочем, это позволяет из очереди на массиве сделать персистеную очередь с \u003ccode\u003eO(log)\u003c/code\u003e на операцию).\u003c/p\u003e\u003ch4\u003eПерсистентная очередь\u003c/h4\u003e\u003cp\u003eКак известно, очередь легко реализовать с помощью двух стеков: из одного забираем элементы, в другой кладём, при необходимости берём и перекидываем все элементы из второго в первый. Заменив оба стека на персистентные получается персистентная очередь, так зачем в статье на вики-конспектах сложности с шестью стеками? Дело в том, что можно реализовать очередь через два стека, это даст оценку \u003ccode\u003eO(1)\u003c/code\u003e на операцию, но эта оценка — амортизированная. А персистенизация, к сожалению, не сохраняет амортизированные оценки.\u003c/p\u003e\u003cp\u003eДействительно, пусть у очереди версии \u003cstrong\u003eξ\u003c/strong\u003e первый стек был пуст, и при следующей операции \u003cstrong\u003eget\u003c/strong\u003e (здесь и далее я буду называть операцию «положить элемент в очередь» как \u003cstrong\u003eput\u003c/strong\u003e, «взять из очереди» — \u003cstrong\u003eget\u003c/strong\u003e) придётся перекидывать элементы за \u003ccode\u003eO(n)\u003c/code\u003e, где \u003cstrong\u003en\u003c/strong\u003e — количество этих элементов. В обычной очереди эта операция бы выполнилась, и следующие \u003cstrong\u003en\u003c/strong\u003e операций \u003cstrong\u003eget\u003c/strong\u003e будут выполняться легко и непринуждённо за чистую единицу. Но в персистентном случае от очереди могут потребовать что-то ещё сделать сделать с сохранённой версией \u003cstrong\u003eξ\u003c/strong\u003e — и \u003cem\u003eкаждая\u003c/em\u003e такая операция будет выполняться за \u003ccode\u003eO(n)\u003c/code\u003e. Неуспех.\u003c/p\u003e\u003cp\u003eСобственно, нагромождения с пятью–шестью стеками и нужны чтобы построить очередь, которая с одной стороны основана на стеках, с другой — выполняет операции за истинную \u003ccode\u003eO(1)\u003c/code\u003e, а не за амортизированную, то есть пытается перекидывать элементы из второго стека в первый заранее, по одному, через несколько вспомогательных. Такая очередь уже легко персистенизируется. Но я начал с того, что пять (тем более шесть) стеков — это сложновато и сейчас попробую обойтись четырьмя.\u003c/p\u003e\u003ch4\u003eЧетыре стека\u003c/h4\u003e\u003cp\u003eПервый стек ( \u003cstrong\u003emain\u003c/strong\u003e ) будет хранить просто все элементы, которые когда-либо добавлялись в очередь. Операция \u003cstrong\u003eput\u003c/strong\u003e будет добавлять элемент в \u003cstrong\u003emain\u003c/strong\u003e (а потом пересчитывать какие-нибудь счётчики и делать \u003cem\u003eнечто\u003c/em\u003e).\u003c/p\u003e\u003cp\u003eВторой стек ( \u003cstrong\u003ehelp\u003c/strong\u003e ) будет хранить некоторые актульные элементы в обратном порядке, так чтобы из него всегда можно было брать элементы для операции \u003cstrong\u003eget\u003c/strong\u003e. То есть, операция \u003cstrong\u003eget\u003c/strong\u003e будет брать элемент из \u003cstrong\u003ehelp\u003c/strong\u003e (и тоже пересчитывать и делать \u003cem\u003eнечто\u003c/em\u003e).\u003c/p\u003e\u003cp\u003eЧтобы не случилось так, что элементы брать неоткуда, нужен ещё один стек ( \u003cstrong\u003ehelp2\u003c/strong\u003e ). В нём будут некоторые элементы очереди, он будет расти и когда \u003cstrong\u003ehelp\u003c/strong\u003e закончится (или раньше) придёт на замену.\u003c/p\u003e\u003cp\u003eЧтобы выращивать стек \u003cstrong\u003ehelp2\u003c/strong\u003e нужна (внимание) персистентная копия стека \u003cstrong\u003emain\u003c/strong\u003e, из которой мы будет брать элементы и перекидывать элементы в \u003cstrong\u003ehelp2\u003c/strong\u003e. Эта копия у меня называется \u003cstrong\u003emain2\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eВыглядит это всё примерно так:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 2\" src\u003d\"/predownloaded/2b/01/2b01f66900ccd51fed714733206a445ff64233df.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eДействие, которое я назвал \u003cem\u003eнечто\u003c/em\u003e — это и есть насыщение стека \u003cstrong\u003ehelp2\u003c/strong\u003e и именно для этого надо хранить пару счётчиков. Достаточно знать количество элементов в очереди (пусть будет называться \u003cstrong\u003emain_size\u003c/strong\u003e, хотя на самом деле в \u003cstrong\u003emain\u003c/strong\u003e хранятся ещё и устаревшие элементы) и количество элементов, которые осталось перекинуть во вспомогательный стек (соответственно, \u003cstrong\u003emain2_size\u003c/strong\u003e). Операция \u003cstrong\u003eput\u003c/strong\u003e делает \u003ccode\u003emain_size++\u003c/code\u003e и не трогает \u003cstrong\u003emain2_size\u003c/strong\u003e, операция \u003cstrong\u003eget\u003c/strong\u003e делает \u003ccode\u003emain_size--, main2_size--\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eНу а \u003cem\u003eнечто\u003c/em\u003e стало быть должно делать следующее:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eЕсли \u003ccode\u003emain2_size \u0026gt; 0\u003c/code\u003e, то переместить один элемент из \u003cstrong\u003emain2\u003c/strong\u003e в \u003cstrong\u003ehelp2\u003c/strong\u003e и \u003ccode\u003emain2_size--\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eЕсли \u003ccode\u003emain2_size \u003d\u003d 0\u003c/code\u003e, то заменить \u003cstrong\u003ehelp\u003c/strong\u003e на \u003cstrong\u003ehelp2\u003c/strong\u003e, а \u003cstrong\u003ehelp2\u003c/strong\u003e и \u003cstrong\u003emain2\u003c/strong\u003e заменить на пустые стеки\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eЕсли \u003cstrong\u003ehelp2\u003c/strong\u003e пуст, то скопировать \u003cstrong\u003emain\u003c/strong\u003e в \u003cstrong\u003emain2\u003c/strong\u003e (за \u003ccode\u003eO(1)\u003c/code\u003e, персистентный стек это как нельзя кстати поддерживает) и проставить \u003ccode\u003emain2_size \u003d main_size\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eЕщё следует доказать, что не будет ситуации, когда очередь не пуста, а стек \u003cstrong\u003ehelp\u003c/strong\u003e пуст, но я оставлю это читателю. У себя \u003ca href\u003d\"https://vk.com/wall18465_4370\"\u003eВКонтакте\u003c/a\u003e я выкладывал \u003ca href\u003d\"http://pastebin.com/2Md0JtxJ\"\u003eкод\u003c/a\u003e, который у меня получился на эту тему.\u003c/p\u003e\u003ch4\u003eМинусы\u003c/h4\u003e\u003cp\u003eЯ знаю два минуса такой реализации по сравнению с пятью стеками, которые есть на вики-конспектах. Оба они возникли из-за того, что в стеке \u003cstrong\u003emain\u003c/strong\u003e хранятся вообще все элементы, которые добавляли в очередь, а не только те, которые остались в очереди на текущий момент.\u003c/p\u003e\u003cp\u003eПервый минус — это использование памяти. Если извне есть информация, что использовать надо не все версии, а только какие-то конкретные, то можно собирать мусор и экономить память. У меня же старые элементы так и будут висеть в хвосте \u003cstrong\u003emain\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eВторой минус заключается в том, что сложнее прикрутить какую-нибудь дополнительную возможность, например, подсчёт минимума на текущих элементах очереди. Это возможно, но понадобится ещё парочка вспомогательных стеков.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eP.S.\u003c/strong\u003e Слова «персистенизация» вроде бы нет в русском языке, так что мне самому интересно, как ещё можно назвать «построение по структуре данных её персистентного варианта».\u003c/p\u003e\u003c/div\u003e","tags":["персистентность","структруры данных"]}}