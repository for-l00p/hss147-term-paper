{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1438234852,"rating":0,"authorHandle":"DedMaxim","modificationTimeSeconds":1438317459,"id":19506,"title":"\u003cp\u003eТеория. Суммы на префиксе и их друзья.\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eСуммами на префиксах для массива \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d {\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e}\u003c/span\u003e называется такой массив \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e \u003d {\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e}\u003c/span\u003e, что \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6d/5b/6d5b548888444d38e78699b272db562be09b775b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Вычисление такого массива производится следующим образом :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ed[0] \u003d 0;\nfor (int i \u003d 1; i \u0026lt;\u003d n; i++) \n     d[i] \u003d d[i - 1] + a[i];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКлассическим применением такой структуры является вычисление суммы чисел массива на отрезке. Задача ставится следующим образом. Требуется отвечать на запросы вида \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b9/b9/b9b90ff970763bebf2342a1a4dd0642c5da2d5d8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Решение \u0026quot;в лоб\u0026quot; (пробегаться циклом по отрезку на каждый запрос, считая сумму) работает за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003emn\u003c/i\u003e)\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e — количество запросов, так как в худшем случае нам придётся пробегаться по всему массиву. Воспользуемся следующей идеей. Посчитаем массив префиксных сумм. Рассмотрим элемент \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. В этой ячейке записана сумма всех элементов исходного массива от \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e - 1\u003c/sub\u003e + (\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e + 1\u003c/sub\u003e + ... + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e) \u003d (\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e - 1\u003c/sub\u003e) + \u003ci\u003esum\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e) \u003d \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e - 1\u003c/sub\u003e + \u003ci\u003esum\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e. Из этого следует, что \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e) \u003d \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e. Тогда ответ на один запрос получается за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint sum(int l, int r) {\n     return d[r] - d[l - 1];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКроме суммы чисел можно считать так же и произведение. Заметим однако, что минимум или максимум на отрезке нельзя посчитать с помощью префиксной структуры (убедитесь в этом сами). Таким образом можно решать задачи вида : посчитать количество \u0026quot;особых\u0026quot; элементов. Например, посчитать количество символов, которые являются буквами, в строке.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid precalc() {\n    d[0] \u003d 0;\n    for (int i \u003d 1; i \u0026lt;\u003d n; i++) // будем считать, что нумерация с единицы\n         d[i] \u003d d[i - 1] + isAlpha(s[i]); // возвращает 1, если s[i] - буква, и 0, в противном случае.\n}\n\nint cnt(int l, int r) {\n     return d[r] - d[l - 1];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКроме того, можно посчитать и такую вещь : для каждого элемента сказать сколько за ним подряд идущих возрастающих элементов (образующих возрастающую последовательность). Например, для массива \u003cspan class\u003d\"tex-span\"\u003e{1, 2, 4, 2, 3}\u003c/span\u003e ответ выглядит так — \u003cspan class\u003d\"tex-span\"\u003e{1, 2, 3, 1, 2}\u003c/span\u003e. Приведём код, по которому всё станет ясно :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ememset(d, 1, n * sizeof d[0]); //заполняем массив d единичками. \nfor (int i \u003d 2; i \u0026lt;\u003d n; i++) {\n    if (a[i] \u0026gt; a[i - 1]) \n        d[i] +\u003d d[i - 1];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eМы изначально заполняем массив единичками, так как каждое число уже является возрастающей последовательностью. Аналогичные рассуждения можно провести и если нам нужно найти наибольшее количество элементов справа, что они образуют возрастающую последовательность. Это можно сделать, если на перевёрнутом исходном массиве выполнить предыдущую задачу, но для убывающей последовательности. С точки зрения реализации удобно не переворачивать массив, а начать заполнение массива \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e с конца. \u003c/p\u003e\u003cp\u003eОчень известна следующая задача : требуется найти такой отрезок \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e массива \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, что есть один ровно такой элемент, что все числа и слева, и справа на отрезке меньше его. Решение будет следующим. Посчитаем для каждого элемента, количество элементов слева, образующих с ним возрастающую последовательность (назовём этот массив \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eup\u003c/i\u003e\u003c/span\u003e), и количество элементов справа, образующих с ним убывающую последовательность (этот массив \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edown\u003c/i\u003e\u003c/span\u003e). Тогда ответом будет максимум, по всем суммам \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eup\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] + \u003ci\u003edown\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] + 1\u003c/span\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eup[0] \u003d 0;\nfor (int i \u003d 1; i \u0026lt;\u003d n; i++) // нумерация с единицы\n    if (a[i] \u0026gt; a[i - 1]) \n       up[i] \u003d up[i - 1] + 1;\ndown[n + 1] \u003d 0;\nfor (int i \u003d n; i \u0026gt; 0; i--) {\n   if (a[i] \u0026gt; a[i + 1])\n       down[i] \u003d down[i + 1] + 1;\n}\nfor (int i \u003d 1; i \u0026lt;\u003d n; i++) {\n    ans \u003d max(ans, down[i] + up[i] + 1);\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eСамоочевидно, что такая структура потребляет O(n) памяти и тратит O(1) времени в среднем на каждый запрос.\u003c/p\u003e\u003c/div\u003e","tags":[]}}