{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1518361994,"rating":3,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1518361994,"id":57696,"title":"\u003cp\u003eNotes on Codeforces Beta Round #117, Div2- B, C (query square root decomposition), D, E\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/182/problem/B\" title\u003d\"Codeforces Round 117 (Div. 2)\"\u003e182B - Vasya\u0027s Calendar\u003c/a\u003e\u003c/p\u003e\u003cp\u003eStraightforward implementation.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/182/problem/C\" title\u003d\"Codeforces Round 117 (Div. 2)\"\u003e182C - Optimal Sum\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet us first try to find some “insight” to this problem. Suppose that the optimal set of positions at which we should reverse the sign of the integer, is \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e. One can observe that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ≤ \u003ci\u003elen\u003c/i\u003e\u003c/span\u003e must hold, i.e., the leftmost and rightmost reversed positions must fall into some interval of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e. The reason is that there must exist one (maybe multiple) interval of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e that gives the optimal answer, and thus any reversed position that falls out of this interval makes no sense. Therefore, it is safe to modify \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e, \u003ci\u003elen\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eAnother observation is that if we are going to reverse \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e signs, we will either reverse \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e negative integers or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e positive integers. The reason is obvious since a positive integer and a negative integer “cancel” each other. Moreover, we must select the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e integers with the maximum absolute values and reverse them.\u003c/p\u003e\u003cp\u003eBased on the above arguments, we can simply enumerate every interval of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e (like a sliding window), and try to obtain a larger value by reversing not more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e signs. For simplicity, we only consider reversing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e maximum negative integers (“maximum” means maximum absolute value), since reversing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e maximum positive integers is similar.\u003c/p\u003e\u003cp\u003eWe can treat every interval of length equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e as a query. By using “query square root decomposition”, the complexity can be reduced to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e1.5\u003c/sup\u003e)\u003c/span\u003e from trivial \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e. There are a large number of materials talking about this on the internet.\u003c/p\u003e\u003cp\u003eThe left work is how to store and update the maximum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e integers. I read some of the accepted codes and learned the following technique. We maintain two “set”s \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emaxk\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecandidatek\u003c/i\u003e\u003c/span\u003e. The first one stores the maximum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e integers while the second stores the other integers that are not the maximum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e ones but belong to the current interval. Whenever the sliding window is moved one step further, we should deal with inserting and deleting elements in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emaxk\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecandidatek\u003c/i\u003e\u003c/span\u003e. One should carefully deal with the details involved here.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/182/problem/D\" title\u003d\"Codeforces Round 117 (Div. 2)\"\u003e182D - Common Divisors\u003c/a\u003e\u003c/p\u003e\u003cp\u003eRecall that even for integer up to \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e, the number of its divisors is only about several hundreds. Therefore, we can calculate all the divisors for each string length in previous, and check which divisors are “string divisor”s. Next, we find the longest common prefix string of the two strings, and denote the length as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e. Finally, we find all the common “string divisor”s that is not larger than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/182/problem/E\" title\u003d\"Codeforces Round 117 (Div. 2)\"\u003e182E - Wooden Fence\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe extend each board to two new boards if it is not a square, by swapping its length and width, while they still have the same “index” (it is required that no neighboring boards should have the same index). In other words, we create two new boards but eliminate the old one. Then, we use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e to denote the number of ways to build a fence of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e and the last board has index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. As you may see, the idea is dp but we compute it in a forward manner. From \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e, we should find out all the feasible boards that can be built next to the board with index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, and then move to some \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e + \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e]]\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e is the length of board \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e","tags":[]}}