{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1505239497,"rating":4,"authorHandle":"Vendetta.","modificationTimeSeconds":1505239497,"id":54494,"title":"\u003cp\u003eTutorial : VIII Samara Regional Intercollegiate Programming Contest\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eA. Did he drop any good loot?\u003c/h3\u003e\u003cp\u003eIt\u0027s a modification of knapsack problem. Add the third dimension of size 3: how many artifacts have been activated.\u003c/p\u003e\u003cp\u003eA tricky case where the total weight used goes below 0 (starting with weight \u003ccode\u003em\u003c/code\u003e and subtract when you take items), in traditional knapsack it\u0027s an invalid state \u003ccode\u003ereturn -inf\u003c/code\u003e, but here since the max weight can be increased by activating artifacts, you may later on activate an artifact that lets you carry more weight.\u003c/p\u003e\u003cp\u003eThis can be solved by increasing the size of weight dimension by \u003ccode\u003eOFFSET \u003d 200\u003c/code\u003e (adding max of 100 for both activated artifacts), and starting from weight \u003ccode\u003em + OFFSET\u003c/code\u003e instead of \u003ccode\u003em\u003c/code\u003e. And the base case where \u003ccode\u003ei \u003d\u003d n\u003c/code\u003e is \u003ccode\u003ereturn -inf\u003c/code\u003e if the remaining weight available is below \u003ccode\u003eOFFSET\u003c/code\u003e (which means it’s below 0), otherwise \u003ccode\u003ereturn 0\u003c/code\u003e as it’s a valid base case.\u003c/p\u003e\u003cp\u003eComplexity: \u003ccode\u003eO(n*m)\u003c/code\u003e, solution: \u003ca href\u003d\"https://ideone.com/BKnwPQ\"\u003ehttps://ideone.com/BKnwPQ\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eB. Far Manager\u003c/h3\u003e\u003cp\u003eThere are three possible ways, which has to be calculated with formulas as distances are too big to loop over them, otherwise a BFS solution could have worked:\u003c/p\u003e\u003cp\u003e1) Go Right to the file column then Down to file row.\u003c/p\u003e\u003cp\u003e2) Go Right to one column after the file column then Up to the file row.\u003c/p\u003e\u003cp\u003e3) Go Right to the last column then one Right (end of file) then Left to file column then Up/Down to file row.\u003c/p\u003e\u003cp\u003eComplexity: \u003ccode\u003eO(1)\u003c/code\u003e, solution: \u003ca href\u003d\"https://ideone.com/hkkOHY\"\u003ehttps://ideone.com/hkkOHY\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eC. Modern Art\u003c/h3\u003e\u003cp\u003eProblem setter hint: “Consider the relations between segments\u0027 ends :) The most beautiful problem here.”\u003c/p\u003e\u003ch3\u003eD. Unfair Game\u003c/h3\u003e\u003cp\u003eThe idea is to find a way to distribute the numbers so that if player 1 chooses any dice, there’s another dice that has a probability \u003ccode\u003eP \u0026gt; 0.5\u003c/code\u003e of winning against it.\u003c/p\u003e\u003cp\u003eIn order to check on the probability of dice A winning against dice B, we can loop on each pair of numbers in those 2 dice and count how many of them \u003ccode\u003eAi \u0026gt; Bi\u003c/code\u003e, lets call this count \u003ccode\u003eC\u003c/code\u003e, then the probability \u003ccode\u003eP \u003d C / (n^2)\u003c/code\u003e, where \u003ccode\u003en^2\u003c/code\u003e Is the total number of pairs.\u003c/p\u003e\u003cp\u003eThere are probably many greedy ways to get those 3 dice, I’ll explain one of them: Consider the three dice at the beginning like this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eDice 1:  1,    2,     3,   … …  n.\nDice 2:  n,   n+1,   n+2,  … … 2n.\nDice 3: 2n+1, 2n+2,  2n+3, … … 3n.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow what we will do is try to swap between the first number in dice 1 and last number in dice 3:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eDice 1: 3n,    2,     3,   … …  n.\nDice 2:  n,   n+1,   n+2,  … … 2n.\nDice 3: 2n+1, 2n+2,  2n+3, … …  1.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow check (as explained above) if for each dice there’s another dice that has a higher winning probability. If it’s not an answer swap the second element in the first dice and the element before the last element in the third dice then do another check: Second swap:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eDice 1: 3n,  3n-1,    3,   … …  n.\nDice 2:  n,   n+1,   n+2,  … … 2n.\nDice 3: 2n+1, 2n+2,  2n+3, … 2, 1.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eand so on..\u003c/p\u003e\u003cp\u003eBy testing the solution above for all numbers from 1 to 1000, the answer for each one was YES except for 1, 2 \u0026amp; 4 gave no solutions found.. by writing a brute force solution for those 3 cases (try all permutations for example) you will find a solution for 4 and no solutions for 1 \u0026amp; 2 which you can handle in your code as a special cases.\u003c/p\u003e\u003cp\u003eThe complexity of the solution is \u003ccode\u003eO(n^3)\u003c/code\u003e which is too much for \u003ccode\u003en \u003d 1000\u003c/code\u003e, but also by testing the code, it will find answers without too many iterations and swaps, thus stops and gives fast run time.\u003c/p\u003e\u003cp\u003eThe solutions seems reasonable because we give the middle values to dice 2 and try to distribute the rest among the other 2 dice each giving them both big and small values.. this way we try to even the number of winning pairs in each pair of dice.\u003c/p\u003e\u003cp\u003eComplexity: \u003ccode\u003eO(n^3)\u003c/code\u003e, solution: \u003ca href\u003d\"https://ideone.com/gVaHqS\"\u003ehttps://ideone.com/gVaHqS\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eE. SuperHyperMarket\u003c/h3\u003e\u003cp\u003ePut \u003ccode\u003eK\u003c/code\u003e cash desks in a priority queue where the top has the cash desk with lowest value of \u003ccode\u003eX \u003d Ci * P\u003c/code\u003e as explained in the statement, and for each person add him to the cash desk at the top of the priority queue and re-add the cash desk with the new values.\u003c/p\u003e\u003cp\u003eComplexity: \u003ccode\u003eO(n log n)\u003c/code\u003e, solution: \u003ca href\u003d\"https://ideone.com/xftKgX\"\u003ehttps://ideone.com/xftKgX\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eF. The Berland Championship\u003c/h3\u003e\u003cp\u003eIterate over three people, Building a graph from the 3 people and the problems (edges from each person to each problem he can solve with capacity of 1 and the person himself having max capacity of the max number of problems he can solve) using a max flow algorithm, it will find the max number of problems they can solve together.\u003c/p\u003e\u003cp\u003eComplexity is \u003ccode\u003eO(n^3 * v^2 * e)\u003c/code\u003e (Max flow is always faster than it looks especially when using dinic), \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Hasan0540\" title\u003d\"Candidate Master Hasan0540\"\u003eHasan0540\u003c/a\u003e\u0027s solution: \u003ca href\u003d\"https://ideone.com/50z8TN\"\u003ehttps://ideone.com/50z8TN\u003c/a\u003e\u003c/p\u003e\u003cp\u003eProblem setter hint for another solution: “Iterate over three people, then use the fact is that there are only 7 types of problems, and the problems of the same type can be merged.”\u003c/p\u003e\u003ch3\u003eG. The Lost Graph\u003c/h3\u003e\u003cp\u003eJust a simple emulation with stack.\u003c/p\u003e\u003ch3\u003eH. Noisy Lecture\u003c/h3\u003e\u003cp\u003eThe best way to initiate the noise is the moment when the teacher finishes to remember the most difficult sentence. Thus the answer is \u003ccode\u003eK * MX + sum(Ci)\u003c/code\u003e where \u003ccode\u003eMX\u003c/code\u003e is the time of the sentence with highest remembering time.\u003c/p\u003e\u003cp\u003eComplexity: \u003ccode\u003eO(N)\u003c/code\u003e, solution: \u003ca href\u003d\"https://ideone.com/J1nEJH\"\u003ehttps://ideone.com/J1nEJH\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eI. Goat in the Field\u003c/h3\u003e\u003cp\u003eFor each shepherd, firstly move perpendicularly to the goat\u0027s trajectory, then move towards her (at this point there are 2 cases, either the goat is moving toward to shepherd or away from him).\u003c/p\u003e\u003cp\u003eComplexity: \u003ccode\u003eO(n)\u003c/code\u003e, solution: \u003ca href\u003d\"https://ideone.com/1ohd9F\"\u003ehttps://ideone.com/1ohd9F\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eJ. Ticket Booking\u003c/h3\u003e\u003cp\u003eFor this problem, we basically want to split the \u003ccode\u003eN\u003c/code\u003e students into the minimum number of contiguous segments such that each segment\u0027s size is less than or equal to \u003ccode\u003eK\u003c/code\u003e, and for each two consecutive students in a group, their preferred seats come directly after each other in the list of free seats.\u003c/p\u003e\u003cp\u003eWe can notice that the following simple greedy algorithm can be proven for this problem: For each student, if we can join him with a previous group such that its size doesn\u0027t exceed \u003ccode\u003eK\u003c/code\u003e and his preferred seat comes right after the last one in the last group, we\u0027ll join him with that group instead of making a new one.\u003c/p\u003e\u003cp\u003eFor applying it, we will use a simple two pointers solution to check if the rules apply for consecutive students, where: if the size of the last group is less than K and we can join the current student with them we will do so. Otherwise, we will start a new group starting with the current student.\u003c/p\u003e\u003cp\u003eComplexity: \u003ccode\u003eO(N+M)\u003c/code\u003e, solution: \u003ca href\u003d\"https://ideone.com/88pdFe\"\u003ehttps://ideone.com/88pdFe\u003c/a\u003e\u003c/p\u003e\u003cp\u003e(Explanation and solution credit to \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Light\" title\u003d\"Candidate Master Light\"\u003eLight\u003c/a\u003e)\u003c/p\u003e\u003ch3\u003eK. Team Rating\u003c/h3\u003e\u003cp\u003eSince \u003ccode\u003ex + y \u003d 1\u003c/code\u003e and \u003ccode\u003ex\u003c/code\u003e \u0026amp; \u003ccode\u003ey\u003c/code\u003e are positives then \u003ccode\u003ey \u003d 1 – x\u003c/code\u003e and \u003ccode\u003e0 \u0026lt;\u003d x, y \u0026lt;\u003d 1\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eNow let’s find the values of x that satisfies for every 2 consecutive teams, where team 1 has ratings a1 \u0026amp; b1, team 2 has ratings a2 \u0026amp; b2.\u003c/p\u003e\u003cp\u003eTo do this each pair must satisfy the equation: \u003ccode\u003ex*a1 + y*b1 \u0026lt;\u003d x*a2 + y*b2\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eBut \u003ccode\u003ey \u003d 1-x\u003c/code\u003e so: \u003ccode\u003ex*a1 + (1-x)*b1 \u0026lt;\u003d x*a2 + (1-x)*b2\u003c/code\u003e\u003c/p\u003e\u003cp\u003ethen final form by taking \u003ccode\u003ex\u003c/code\u003e aside:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ex \u0026lt;\u003d (b2 - b1) / (a1 - b1 - a2 + b2)  if (a1 - b1 - a2 + b2) \u0026lt; 0\nx \u0026gt;\u003d (b2 - b1) / (a1 - b1 - a2 + b2)  if (a1 - b1 - a2 + b2) \u0026gt; 0\n???????????????????????????????????   if (a1 - b1 - a2 + b2) \u003d 0\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow at the start the values of \u003ccode\u003ex\u003c/code\u003e can be in interval \u003ccode\u003e[0, 1]\u003c/code\u003e, while looping over each pair of teams we can enclose the interval according to the equations above and it gets smaller and smaller, if at the end the interval length goes below 0 then there is no answer, otherwise any of the values from the final interval can be chosen as a solution so the answer is Yes.\u003c/p\u003e\u003cp\u003eSome tricky cases where \u003ccode\u003e(a1 - b1 - a2 + b2) \u003d 0\u003c/code\u003e :)\u003c/p\u003e\u003cp\u003eComplexity: \u003ccode\u003eO(n)\u003c/code\u003e, solution: \u003ca href\u003d\"https://ideone.com/qSVfpu\"\u003ehttps://ideone.com/qSVfpu\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eL. Hanoi Towers and the Progress\u003c/h3\u003e\u003cp\u003eCan be solved using Fibonacci + Matrix exponentiation.\u003c/p\u003e\u003cp\u003eRead this comment for more details: \u003ca href\u003d\"//codeforces.com/blog/entry/18306?#comment-233757\"\u003ehttp://codeforces.com/blog/entry/18306?#comment-233757\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eM. The Fifth Season\u003c/h3\u003e\u003cp\u003eFirst of all, all optimal ways to play and win the game has the same number of moves because no matter where you start and what choices you have, to play optimally in games, if you are at a Winning position you must move to a Losing position, and if you are at a Losing position you can only move to a Winning position.\u003c/p\u003e\u003cp\u003eTo make sure it’s true that all optimal ways are the same length follow this example:\u003c/p\u003e\u003cp\u003eWe have 15 coins and the plays can choose from 3 to 5 coins, the winning and losing positions are as follow:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eCoins:      0    1    2    3    4    5    6    7    8    9    10    11    12    13    14    15    16     17 …\nPosition:   L    L    L    W    W    W    W    W    L    L    L     W     W     W     W     W     L      L  …\nAnswer:     0    0    0    1    1    1    1    1    2    2    2     3     3     3     3     3     4      4  …\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe optimal moves will always move the players from a Winning segment to a Losing segment.\u003c/p\u003e\u003cp\u003eSo the answer will be the number of different winning segments + the number of losing segments between 0 \u0026amp; n\u003c/p\u003e\u003cp\u003eThis can be calculated by \u003ccode\u003en / (a+b) * 2\u003c/code\u003e… if \u003ccode\u003en % (a+b) \u0026gt;\u003d a\u003c/code\u003e then add 1 to the answer.\u003c/p\u003e\u003cp\u003eComplexity: \u003ccode\u003eO(q)\u003c/code\u003e, solution: \u003ca href\u003d\"https://ideone.com/rngtDQ\"\u003ehttps://ideone.com/rngtDQ\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}