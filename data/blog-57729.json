{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1518479433,"rating":415,"authorHandle":"Igorjan94","modificationTimeSeconds":1519053304,"id":57729,"title":"\u003cp\u003eC++17, competitive programming edition\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eC++17 is now \u003ca href\u003d\"//codeforces.com/blog/entry/57646\"\u003eavailable\u003c/a\u003e on codeforces, community \u003ca href\u003d\"//codeforces.com/blog/entry/15643?#comment-413401\"\u003ewants\u003c/a\u003e new edition of \u003ca href\u003d\"//codeforces.com/blog/entry/15643\"\u003eC++ tricks\u003c/a\u003e by \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Swift\" title\u003d\"Candidate Master Swift\"\u003eSwift\u003c/a\u003e, so, let\u0027s start!\u003cbr /\u003eDisclaimer: I have done only few examples of new features, which in my opinion are related to competitive programming. Feel free to comment and provide more real-world examples or ask to elaborate some features with more examples or explanations.\u003c/p\u003e\u003ch3\u003eFold expressions\u003c/h3\u003e \u003cul\u003e   \u003cli\u003eI think that everybody knows, what reduce or fold means, but a c++11 example:\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;int\u0026gt; v \u003d {1, 3, 5, 7};\nint res \u003d accumulate(v.begin(), v.end(), 0, [](int a, int b) { return a + b; });\ncout \u0026lt;\u0026lt; res; // 16\n\u003c/code\u003e\u003c/pre\u003e \u003cul\u003e   \u003cli\u003eIn C++17 there is also folding support for a template parameters list. It has the following syntax:\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003e(pack op ...)\n(... op pack)\n(pack op ... op init)\n(init op ... op pack)\n\u003c/code\u003e\u003c/pre\u003e \u003cul\u003e   \u003cli\u003eFor example, implement a template function that takes a variable number of parameters and calculates their sum. Before C++17 we cannot do this without explicit first argument:\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003e//C++14\nauto Sum()\n{\n    return 0;\n}\n\ntemplate\u0026lt;typename Arg, typename... Args\u0026gt;\nauto Sum(Arg first, Args... rest)\n{\n    return first + Sum(rest...);\n}\n\ncout \u0026lt;\u0026lt; Sum(1, 2, 3, 4, 5); // 15\n\u003c/code\u003e\u003c/pre\u003e \u003cpre\u003e\u003ccode\u003e//C++17\ntemplate\u0026lt;typename... Args\u0026gt;\nauto Func(Args... args)\n{\n    return (args + ...);\n}\n\ncout \u0026lt;\u0026lt; Func(1, 2, 3, 4, 5); // 15\n\u003c/code\u003e\u003c/pre\u003e \u003cul\u003e   \u003cli\u003eThis is useful, when we use comma as \u003ccode\u003eop\u003c/code\u003e:\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003e// C++17\ntemplate\u0026lt;typename T, typename... Args\u0026gt;\nvoid pushToVector(vector\u0026lt;T\u0026gt;\u0026amp; v, Args\u0026amp;\u0026amp;... args)\n{\n    (v.push_back(forward\u0026lt;Args\u0026gt;(args)), ...);\n    //This code is expanded into a sequence of expressions separated by commas as follows:\n    //  v.push_back(forward\u0026lt;Args_1\u0026gt;(arg1)),\n    //  v.push_back(forward\u0026lt;Args_2\u0026gt;(arg2)),\n    //  ....\n}\n\nvector\u0026lt;int\u0026gt; v;\npushToVector(v, 1, 4, 5, 8);\n\u003c/code\u003e\u003c/pre\u003e \u003cul\u003e   \u003cli\u003eAnd my favourite example:\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003e//C++17\ntemplate\u0026lt;typename... Args\u0026gt;\nvoid readln(Args\u0026amp;... args)\n{\n    ((cin \u0026gt;\u0026gt; args), ...);\n}\n\ntemplate\u0026lt;typename... Args\u0026gt;\nvoid writeln(Args... args)\n{\n    ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026quot; \u0026quot;), ...);\n}\n\nint x;\ndouble y;\nreadln(x, y); // enter 100 500.1234\nwriteln(x, \u0026quot;some string\u0026quot;, y); // 100 some string 500.1234\n\u003c/code\u003e\u003c/pre\u003e \u003cul\u003e   \u003cli\u003e\u003cstrong\u003eNote\u003c/strong\u003e: brackets are meaningfull\u003c/li\u003e \u003c/ul\u003e\u003ch3\u003eClass template argument deduction\u003c/h3\u003e \u003cpre\u003e\u003ccode\u003etemplate\u0026lt;typename T\u0026gt;\nstruct point\n{\n    T x;\n    T y;\n    point(T x, T y) : x(x), y(y) {}\n};\n\n//C++11\npair\u0026lt;int, double\u0026gt; p1 \u003d {14, 17.0}\npoint\u0026lt;int\u0026gt; u \u003d {1, 2};\n\n//C++17\npair p2 \u003d {14, 17.0}\npoint v \u003d {1, 2};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf struct is complex, there is a possibility to write deduction guides ourselves, for instance:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate\u0026lt;typename T, typename U\u0026gt;\nstruct S\n{\n    T first;\n    U second;\n};\n\n// My deduction guide\ntemplate\u0026lt;typename T, typename U\u0026gt;\nS(const T \u0026amp;first, const U \u0026amp;second) -\u0026gt; S\u0026lt;T, U\u0026gt;;\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: the compiler is able to create deduction guide automatically from a constructor, but in this example, the structure S has no constructor, so, we define deduction guide manually.\u003c/p\u003e\u003ch3\u003e\u003ccode\u003e*this\u003c/code\u003e capture in lambda expressions\u003c/h3\u003e\u003cp\u003eI don\u0027t think this is useful in CP, but who knows:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estruct someClass\n{\n    int x \u003d 0;\n\n    void f() const\n    {\n        cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0027\\n\u0027;\n    }\n\n    void g()\n    {\n        x++;\n    }\n\n    // C++14\n    void func()\n    {\n        auto lambda1 \u003d [self \u003d *this]() { self.f(); };\n        auto lambda2 \u003d [self \u003d *this]() mutable { self.g(); };\n        lambda1();\n        lambda2();\n    }\n\n    // C++17\n    void funcNew()\n    {\n        auto lambda1 \u003d [*this]() { f(); };\n        auto lambda2 \u003d [*this]() mutable { g(); };\n        lambda1();\n        lambda2();\n    }\n};\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ca href\u003d\"https://arne-mertz.de/2017/10/mutable/\"\u003eArticle\u003c/a\u003e about \u003ccode\u003emutable\u003c/code\u003e keyword.\u003c/p\u003e\u003ch3\u003eStructured bindings\u003c/h3\u003e \u003cul\u003e   \u003cli\u003eThe most useful syntax sugar for decomposition of objects.\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003etemplate\u0026lt;typename T\u0026gt;\nstruct point\n{\n    T x;\n    T y;\n    point(T x, T y) : x(x), y(y) {}\n};\n\nvector\u0026lt;point\u0026lt;int\u0026gt;\u0026gt; points \u003d {{0, 0}, {1, 0}, {1, 1}, {1, 0}};\n//C++11\nfor (auto\u0026amp; point : points)\n{\n    int x, y;\n    tie(x, y) \u003d point;\n    //...Some compex logic with x and y\n}\n\n//C++17\nfor (auto\u0026amp; [x, y] : points)\n{\n    //...Some compex logic with x and y\n}\n\u003c/code\u003e\u003c/pre\u003e \u003cul\u003e   \u003cli\u003eIterating over map:\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003emap\u0026lt;int, string\u0026gt; m;\nfor (auto [key, value] : m)\n    cout \u0026lt;\u0026lt; \u0026quot;key: \u0026quot; \u0026lt;\u0026lt; key \u0026lt;\u0026lt; \u0027\\n\u0027 \u0026lt;\u0026lt; \u0026quot;value: \u0026quot; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0027\\n\u0027;\n\u003c/code\u003e\u003c/pre\u003e \u003cul\u003e   \u003cli\u003eA good example of usage is problem \u003ca href\u003d\"/contest/938/problem/D\" title\u003d\"Educational Codeforces Round 38 (Rated for Div. 2)\"\u003e938D - Buy a Ticket\u003c/a\u003e. Code with structured bindings (Dijkstra algo) is much more readable and understandable: compare \u003ca href\u003d\"/contest/938/submission/35474147\" title\u003d\"Submission 35474147 by Igorjan94\"\u003e35474147\u003c/a\u003e and \u003ca href\u003d\"/contest/938/submission/35346635\" title\u003d\"Submission 35346635 by dotorya\"\u003e35346635\u003c/a\u003e.\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003ewhile (!q.empty())\n{\n    auto [dist, u] \u003d *q.begin();\n    q.erase(q.begin());\n    used[u] \u003d true;\n    for (auto\u0026amp; [w, v] : g[u])\n        if (!used[v] \u0026amp;\u0026amp; d[v] \u0026gt; dist + 2 * w)\n            q.erase({d[v], v}),\n            d[v] \u003d dist + 2 * w,\n            q.insert({d[v], v});\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eInitializer in \u003ccode\u003eif\u003c/code\u003e and \u003ccode\u003eswitch\u003c/code\u003e\u003c/h3\u003e \u003cpre\u003e\u003ccode\u003eset\u0026lt;int\u0026gt; s;\n\nif (auto [iter, ok] \u003d s.insert(42); ok)\n{\n    //...\n}\nelse\n{\n    //`ok` and `iter` are available here\n}\n//But not here\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eNew attributes\u003c/h3\u003e \u003cul\u003e   \u003cli\u003e\u003ccode\u003e[[fallthrough]]\u003c/code\u003e attribute indicates that the break operator inside a case block is missing intentionally:\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003eint requests, type;\ncin \u0026gt;\u0026gt; requests;\nfor (int q \u003d 0; q \u0026lt; requests; ++q)\n    switch (cin \u0026gt;\u0026gt; type; type) //Initializer in switch\n    {\n        case 1:\n            int l, r;\n            cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r;\n            //proceed request of first type\n            break;\n        case 2:\n            [[fallthrough]];\n            //Compiler warning will be supressed\n        case 3:\n            int value;\n            cin \u0026gt;\u0026gt; value;\n            //Proceed requests of second and third types.\n    }\n\u003c/code\u003e\u003c/pre\u003e \u003cul\u003e   \u003cli\u003e\u003ccode\u003e[[nodiscard]]\u003c/code\u003e attribute is used to indicate that the return value of the function should not be ignored and can be also applied to data types.\u003c/li\u003e \u003c/ul\u003e\u003ch3\u003estd::optional\u003c/h3\u003e \u003cpre\u003e\u003ccode\u003eoptional\u0026lt;int\u0026gt; findPath(graph g, int from, int to)\n{\n    //Find path from `from` to `to`\n    if (d[to] !\u003d INF)\n        return d[to];\n    return {}\n}\n\n//We can check if value exists\nif (auto dist \u003d findPath(...); dist.hasValue())\n    cout \u0026lt;\u0026lt; dist.value(); //And get it\nelse\n    cout \u0026lt;\u0026lt; -1;\n\n//Or use defaultValue if value is not set\ncout \u0026lt;\u0026lt; findPath(...).value_or(-1); //Prints distance if path exists and -1 otherwise\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eNon-constant string::data\u003c/h3\u003e\u003cp\u003eFor C-lovers:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estring str \u003d \u0026quot;hello\u0026quot;;\nchar *p \u003d str.data();\np[0] \u003d \u0027H\u0027;\ncout \u0026lt;\u0026lt; str; // Hello\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eFree functions std::size, std::data and std::empty\u003c/h3\u003e\u003cp\u003eIn addition to the already existing free functions std::begin, std::end and others, some new free functions appeared, such as: std::size, std::data and std::empty:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;int\u0026gt; v \u003d { 3, 2, 5, 1, 7, 6 };\n\nsize_t sz \u003d size(v);\nbool empty \u003d empty(v);\nauto ptr \u003d data(v);\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003estd::clamp\u003c/h3\u003e\u003cp\u003eReturns \u003ccode\u003ex\u003c/code\u003e if it is in the interval \u003ccode\u003e[low, high]\u003c/code\u003e or, otherwise, the nearest value:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ecout \u0026lt;\u0026lt; clamp(7, 0,  10); //7\ncout \u0026lt;\u0026lt; clamp(7, 0,  5);  //5\ncout \u0026lt;\u0026lt; clamp(7, 10, 50); //10\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI think that it is convenient function, but it\u0027ll be difficult to call it in mind during contest :)\u003c/p\u003e\u003ch3\u003eGCD and LCM!\u003c/h3\u003e \u003cpre\u003e\u003ccode\u003ecout \u0026lt;\u0026lt; gcd(24, 60); // 12\ncout \u0026lt;\u0026lt; lcm(8, 10);  // 40\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eThe return value from \u003ccode\u003eemplace_back\u003c/code\u003e\u003c/h3\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;int\u0026gt; v \u003d { 1, 2, 3 };\n\nauto \u0026amp;r \u003d v.emplace_back(10);\nr \u003d 42;\n//v now contains {1, 2, 3, 42}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003estd::map functions:\u003c/h3\u003e \u003cul\u003e   \u003cli\u003eExtract (and even change key!!!)\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003emap\u0026lt;int, string\u0026gt; myMap{ { 1, \u0026quot;Gennady\u0026quot; }, { 2, \u0026quot;Petr\u0026quot; }, { 3, \u0026quot;Makoto\u0026quot; } };\nauto node \u003d myMap.extract(2);\nnode.key() \u003d 42;\nmyMap.insert(move(node));\n\n// myMap: {{1, \u0026quot;Gennady\u0026quot;}, {42, \u0026quot;Petr\u0026quot;}, {3, \u0026quot;Makoto\u0026quot;}};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: Extract is the only way to change a key of a map element without reallocation\u003c/p\u003e\u003cp\u003eComplexity:\u003cbr /\u003eextract(key): \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c8/66/c866e70b5875095de99ad700f943dbe7ed528b12.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003ca href\u003d\"http://en.cppreference.com/w/cpp/container/map/extract\"\u003edoc\u003c/a\u003e\u003cbr /\u003eextract(iterator): \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e amortized \u003ca href\u003d\"http://en.cppreference.com/w/cpp/container/map/extract\"\u003edoc\u003c/a\u003e\u003c/p\u003e \u003cul\u003e   \u003cli\u003eMerge\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003emap\u0026lt;int, string\u0026gt; m1{ { 1, \u0026quot;aa\u0026quot; }, { 2, \u0026quot;bb\u0026quot; }, { 3, \u0026quot;cc\u0026quot; } }; \nmap\u0026lt;int, string\u0026gt; m2{ { 4, \u0026quot;dd\u0026quot; }, { 5, \u0026quot;ee\u0026quot; }, { 6, \u0026quot;ff\u0026quot; } };\nm1.merge(m2);\n// m1: { {1, \u0026quot;aa\u0026quot;}, {2, \u0026quot;bb\u0026quot;}, {3, \u0026quot;cc\u0026quot;}, {4, \u0026quot;dd\u0026quot;}, {5, \u0026quot;ee\u0026quot;}, {6, \u0026quot;ff\u0026quot;} }\n// m2: {}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCompexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/44/15/44159a97211509254b77ce5622d77dc699a64fd8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003ca href\u003d\"http://en.cppreference.com/w/cpp/container/map/merge\"\u003edoc\u003c/a\u003e\u003c/p\u003e \u003cul\u003e   \u003cli\u003eTo figure out if the insert or update occurred, we had to first look for the element, and then apply the operator[]. Now we had insert_or_assign:\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003emap\u0026lt;int, string\u0026gt; m;\nm.emplace(1, \u0026quot;aaa\u0026quot;);\nm.emplace(2, \u0026quot;bbb\u0026quot;);\nm.emplace(3, \u0026quot;ccc\u0026quot;);\n\nauto [it1, inserted1] \u003d m.insert_or_assign(3, \u0026quot;ddd\u0026quot;);\ncout \u0026lt;\u0026lt; inserted1; // 0\n\nauto [it2, inserted2] \u003d m.insert_or_assign(4, \u0026quot;eee\u0026quot;);\ncout \u0026lt;\u0026lt; inserted2; // 1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eComplexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c8/66/c866e70b5875095de99ad700f943dbe7ed528b12.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003ca href\u003d\"http://en.cppreference.com/w/cpp/container/map/emplace\"\u003edoc\u003c/a\u003e\u003c/p\u003e\u003ch3\u003eMore rigorous evaluation order of expressions\u003c/h3\u003e\u003cp\u003eAnd in general c++17 introduces new rules, defining more strictly the evaluation order of expressions:\u003c/p\u003e \u003cul\u003e   \u003cli\u003ePostfix expressions are evaluated from left to right (including function calls and access to objects members)\u003c/li\u003e   \u003cli\u003eAssignment expressions are evaluated from right to left.\u003c/li\u003e   \u003cli\u003eOperands of operators \u0026lt;\u0026lt; and \u0026gt;\u0026gt; are evaluated from left to right.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThus, as it is mentioned in the proposal for the standard, in the following expressions a is now guaranteed to be evaluated first, then b, then c:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ea.b\na-\u0026gt;b\na-\u0026gt;*b\na(b1, b2, b3)\nb @\u003d a\na[b]\na \u0026lt;\u0026lt; b \u0026lt;\u0026lt; c\na \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: the evaluation order between b1, b2, b3 is still not defined.\u003c/p\u003e\u003cp\u003eP.S.: All materials are adopted with my examples from \u003ca href\u003d\"https://www.viva64.com/en/b/0533\"\u003ehere\u003c/a\u003e\u003cbr /\u003eP.P.S.: I don\u0027t think my english is \u003ca href\u003d\"//codeforces.com/blog/entry/57479?#comment-411601\"\u003epoor\u003c/a\u003e, but please PM me about grammar or other mistakes to make this article better!\u003c/p\u003e\u003c/div\u003e","tags":["c++","c++14","c++17"]}}