{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1525641235,"rating":84,"authorHandle":"ATSTNG","modificationTimeSeconds":1525645488,"id":59305,"title":"\u003cp\u003eFenwick tree: initialization in O(N)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi, CodeForces.\u003c/p\u003e\u003cp\u003eRecently I decided to take a closer look at data structure called Fenwick tree or binary indexed tree.\u003c/p\u003e\u003cp\u003e\u003cem\u003eIn this blogpost I will only consider Fenwick tree for sum, but everything stated there can be easily generalized for any associative, commutative and inversable operation.\u003c/em\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSome implementation\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eI will use 0-indexed Fenwick tree based on vectors (almost as it is implemented there \u003ca href\u003d\"http://e-maxx.ru/algo/fenwick_tree\"\u003ee-maxx.ru\u003c/a\u003e)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;int\u0026gt; fenwick;\n\nvoid init_empty(int size_) {\n    fenwick.assign(size_, 0);\n}\n\nint sum(int r) {\n    int res \u003d 0;\n\n    while (r \u0026gt;\u003d 0) {\n        res +\u003d fenwick[r];\n        r \u003d (r \u0026amp; (r+1)) - 1;\n    }\n\n    return res;\n}\n\nint sum(int l, int r) {\n    return sum(r) - sum(l-1);\n}\n\nvoid inc(int i, int delta) {\n    while (i \u0026lt; fenwick.size()) {\n        fenwick[i] +\u003d delta;\n        i |\u003d i+1;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eAfter reading articles about it on \u003ca href\u003d\"http://e-maxx.ru/algo/fenwick_tree\"\u003ee-maxx.ru\u003c/a\u003e and \u003ca href\u003d\"https://neerc.ifmo.ru/wiki/index.php?title\u003dДерево_Фенвика\"\u003eneerc.ifmo.ru\u003c/a\u003e and asking friends I\u0027ve got interested by this moment. Both articles (and my friends) use this algorithm to initialize Fenwick tree on given array:\u003c/p\u003e \u003col\u003e   \u003cli\u003eFenwick tree for array of zeros is array of zeros, we will take it as a basis\u003c/li\u003e   \u003cli\u003eWe will use tree queries to replace all elements of array with elements we need\u003c/li\u003e \u003c/ol\u003e \u003cpre\u003e\u003ccode\u003evoid init_vector_classic (vector\u0026lt;int\u0026gt; a) {\n    init_empty(a.size());\n\n    for (int i \u003d 0; i \u0026lt; a.size(); i++) inc(i, a[i]);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis will work in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e * \u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e is length of given array. \u003c/p\u003e\u003cp\u003eCan we do it faster? Definitely can!\u003c/p\u003e\u003cp\u003eBy definition of the Fenwick tree each tree element is the sum of continious segment of initial array. Considering that we have no queries to change elements in initialization process, we can use prefix sums to calculate elements of our Fenwick tree. This will require \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e preprocessing, but will allow to calculate tree elements in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e. So initialization asymptotic improves to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e) + \u003ci\u003eO\u003c/i\u003e(1) * \u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e) \u003d \u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid init_vector_linear_prefix (vector\u0026lt;int\u0026gt; a) {\n    init_empty(a.size());\n\n    vector\u0026lt;int\u0026gt; prefix_sum;\n    prefix_sum.assign(a.size(), 0);\n    prefix_sum[0] \u003d a[0];\n    for (int i \u003d 1; i \u0026lt; a.size(); i++) prefix_sum[i] \u003d prefix_sum[i-1] + a[i];\n\n    for (int i \u003d 0; i \u0026lt; a.size(); i++) {\n        int lower_i \u003d (i \u0026amp; (i+1)) - 1;\n        fenwick[i] \u003d prefix_sum[i] - (lower_i \u0026gt;\u003d 0 ? prefix_sum[lower_i] : 0);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut in this implementation we get additional \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e memory to store additional array.\u003c/p\u003e\u003cp\u003eCan we avoid this? Yes, we can!\u003c/p\u003e\u003cp\u003eWe can notice that to initialize \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efenwick\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e we only require such elements of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eprefix\u003c/i\u003e_\u003ci\u003esum\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e ≤ \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. This allows to use only one array and, starting from the end, change each element from prefix sum to Fenwick tree element.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/58/f0/58f0a8fb16f9b8cca794ce53b40fe8ef13eafcb0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid init_vector_linear (vector\u0026lt;int\u0026gt; a) {\n    init_empty(a.size());\n\n    fenwick[0] \u003d a[0];\n    for (int i \u003d 1; i \u0026lt; a.size(); i++) fenwick[i] \u003d fenwick[i-1] + a[i];\n\n    for (int i \u003d a.size()-1; i \u0026gt; 0; i--) {\n        int lower_i \u003d (i \u0026amp; (i+1)) - 1;\n        if (lower_i \u0026gt;\u003d 0) fenwick[i] -\u003d fenwick[lower_i];\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis way we can improve initialization time of Fenwick tree to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e using \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e additional memory.\u003c/p\u003e\u003cp\u003eOf course, in most of the problems amount of queries is not much less than the size of Fenwick tree, so improving initialization time will not improve final asymptotic of your solution. But this optimization gives as ability to improve constant of the part of your solution, that works with Fenwick tree (or trees) with just a few lines of code.\u003c/p\u003e\u003cp\u003eWhat do you think about this and how do you initialize your Fenwick trees?\u003c/p\u003e\u003c/div\u003e","tags":[]}}