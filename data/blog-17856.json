{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1431484798,"rating":68,"authorHandle":"zxqfl","modificationTimeSeconds":1431518531,"id":17856,"title":"\u003cp\u003eSRM 659 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThis was my first SRM, and I would like to thank \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/rng_58\" title\u003d\"International Grandmaster rng_58\"\u003erng_58\u003c/a\u003e (algorithm coordinator + tester), KADR (tester), \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/misof\" title\u003d\"Candidate Master misof\"\u003emisof\u003c/a\u003e (language reviewer) and \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/dreamoon\" title\u003d\"Grandmaster dreamoon\"\u003edreamoon\u003c/a\u003e (author of Div1 medium) for their invaluable help.\u003c/p\u003e\u003cp\u003eI will try to keep this short, since the TC editorial writers are much better at writing explanations.\u003c/p\u003e\u003ch2\u003eDiv2 Easy -- FilipTheFrog\u003c/h2\u003e\u003cp\u003eThe simplest solution is to perform \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e iterations. Each iteration, look for a pair \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e such that island \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is reachable and \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003epositions\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] - \u003ci\u003epositions\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]| ≤ \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. Mark island \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e as visited. The complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e. It works because each iteration increases the answer by at least \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e assuming it hasn\u0027t already been found, so after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e iterations your answer is guaranteed to be correct.\u003c/p\u003e\u003ch2\u003eDiv2 Medium -- PublicTransit\u003c/h2\u003e\u003cp\u003eYou can fix each possibility for the teleporter and then test every pair of cells to find the longest distance. You can calculate it as follows: if the teleporter cells are at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, then the distance between cells \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e is the minimum of the following:\u003c/p\u003e \u003cul\u003e   \u003cli\u003edist(x, y)\u003c/li\u003e   \u003cli\u003edist(x, a) + dist(b, y)\u003c/li\u003e   \u003cli\u003edist(x, b) + dist(a, y)\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThe complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eR\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e\u003ci\u003eC\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e)\u003c/span\u003e. I think you can improve it to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eR\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003ci\u003eC\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e by observing that if one booth is at \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003er\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e)\u003c/span\u003e, the other booth should be at \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eR\u003c/i\u003e - \u003ci\u003er\u003c/i\u003e + 1, \u003ci\u003ec\u003c/i\u003e)\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003er\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e - \u003ci\u003ec\u003c/i\u003e + 1)\u003c/span\u003e. I\u0027m not actually sure if that\u0027s true, though. Maybe it\u0027s wrong. Can anyone prove/disprove it?\u003c/p\u003e\u003ch2\u003eDiv2 Hard -- ApplesAndOrangesHard\u003c/h2\u003e\u003cp\u003eFirst, read the editorial for the easy version below.\u003c/p\u003e\u003cp\u003eWe will use the same greedy algorithm, but we can\u0027t process every fruit directly. Let\u0027s think about the optimal answer if \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0b/34/0b34efeca796f7fa368b04d8f8d31e3720b6a187.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e weren\u0027t included. We could have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efloor\u003c/i\u003e(\u003ci\u003eK\u003c/i\u003e / 2)\u003c/span\u003e apples, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eceil\u003c/i\u003e(\u003ci\u003eK\u003c/i\u003e / 2)\u003c/span\u003e oranges, repeated until we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e fruits.\u003c/p\u003e\u003cp\u003eWhen we are forced to add an apple, we should disrupt this pattern as little as possible. Let\u0027s sort \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0b/34/0b34efeca796f7fa368b04d8f8d31e3720b6a187.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and keep a \u0027window\u0027 of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e. Initially, the window\u0027s first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e / 2\u003c/span\u003e elements are apples and the rest are oranges, and it represents the range of fruits \u003cspan class\u003d\"tex-span\"\u003e[1, \u003ci\u003eK\u003c/i\u003e]\u003c/span\u003e. When you move to the next element of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0b/34/0b34efeca796f7fa368b04d8f8d31e3720b6a187.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, cycle the window forward so that fruit number \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/b7/7cb73a09504c7fbb1c37a268413dc559d4a2f766.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is at the end of the window. Then, pick the the apple with the greatest index, and move it to the end of the array. You have to ensure you don\u0027t pick an apple that is immovable because of a previous value in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0b/34/0b34efeca796f7fa368b04d8f8d31e3720b6a187.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. The complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f5/b0/f5b01f00574b9688896b7a8f5a4e133d737b5943.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eYou can also solve it when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e, but it\u0027s more trouble than it\u0027s worth.\u003c/p\u003e\u003ch2\u003eDiv1 Easy -- ApplesAndOrangesEasy\u003c/h2\u003e\u003cp\u003eThe algorithm is greedy: for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, try to make the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th fruit an apple. If it contradicts the information you have, make it an orange instead. It works because making a fruit an apple affects the next \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e - 1\u003c/span\u003e choices, so you want to make the earliest possible fruit an apple -- that way, it becomes unimportant sooner.\u003c/p\u003e\u003cp\u003eNaive complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNK\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e; you can improve it to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNK\u003c/i\u003e)\u003c/span\u003e by using a queue or prefix sum array or clever loop.\u003c/p\u003e\u003ch2\u003eDiv1 Medium -- CampLunch\u003c/h2\u003e\u003cp\u003e(Problem and editorial by \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/dreamoon\" title\u003d\"Grandmaster dreamoon\"\u003edreamoon\u003c/a\u003e.)\u003c/p\u003e\u003cp\u003eIf all permutation in each element of a are same, this problem just a normal Tiling problem such as \u003ca href\u003d\"http://uva.onlinejudge.org/index.php?option\u003donlinejudge\u0026amp;page\u003dshow_problem\u0026amp;problem\u003d2245\"\u003eUVa11270\u003c/a\u003e. (Before solve this SRM med problem, you may need to know how to solve UVa11270 with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e * 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e firstly.)\u003c/p\u003e\u003cp\u003eThe main difference of this problem with UVa11270 is a student can seat in different place in consecutive two days. It cause we cannot only reserve dp status for next \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e seats from current seat (this kind of problem method have the status dp[row][column][the occuppied status of next \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e grids]). Then, how can we resolve this situation?\u003c/p\u003e\u003cp\u003eHere provides two method to resolve it by change dp status:\u003c/p\u003e\u003cp\u003e(1) Change dp status to dp[row][i-th student][the status of having plan or not of next \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e (day, student)].\u003c/p\u003e\u003cp\u003eYou can imagine it as all student seat in alphabetical order, and plan 2 of lunch represent some pair of student can get double lunch in some day. By this way, you only reserved status of at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e student in dp proccess.\u003c/p\u003e\u003cp\u003e(2) Change dp status to dp[row][column][the status of having plan or not of next \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e (day,student)].\u003c/p\u003e\u003cp\u003eIn detail, the next \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e (day,student) means students that have larger column number of this row in the same day and other students in next day. I think it\u0027s more difficult to imagine than previous method.\u003c/p\u003e\u003cp\u003eIronically, the two methods are not provided by myself, these solution are provided by two tester. I solve it in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e * \u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e originally. The story tell us: if you can find a good status of dp, it make your dp life better.\u003c/p\u003e\u003ch2\u003eDiv1 Hard\u003c/h2\u003e\u003cp\u003eFix the first teleporter at A. Now do a DFS from A. Suppose we\u0027re currently visiting B. Each node N on the path from A to B has a precomputed \u0027hanging value\u0027, the length of the longest path starting from N which doesn\u0027t get closer to A or B. Number the nodes on the path from \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e (A) to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e - 1\u003c/span\u003e (B), where the path has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e nodes. When moving between nodes at positions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e on the path (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u0026gt; \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e), we can take a direct route (length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e) or an indirect route (length \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eS\u003c/i\u003e - 1) - \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e). Note that the length of the direct route is fixed, while the indirect route gets 1 minute longer with each step of DFS.\u003c/p\u003e\u003cp\u003eIn the DFS transition, we add a node to the path. We will process this node to obtain an integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLIM\u003c/i\u003e\u003c/span\u003e, meaning that the new node enforces the constraint that we can\u0027t continue the DFS in a direction away from A and B for more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLIM\u003c/i\u003e\u003c/span\u003e steps.\u003c/p\u003e\u003cp\u003eHow do we process the node? Suppose the node has hanging value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e and position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e. We want to select a node on the path with value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e such that:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eThe direct path is infeasible: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u0026gt; \u003ci\u003eX\u003c/i\u003e\u003c/span\u003e. Rearranging, we want \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e - \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u0026gt; \u003ci\u003eX\u003c/i\u003e - \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eThe limiting factor (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLIM\u003c/i\u003e \u003d \u003ci\u003eX\u003c/i\u003e - ((\u003ci\u003eS\u003c/i\u003e - 1) - \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e) is minimal. Rearranging, we want to maximize \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eBy converting candidate nodes \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003c/span\u003e to diagonal coordinates \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e - \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e), it reduces to dynamic RMQ and we can solve it with a persistent segment tree. The complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/25/bc/25bcbe785c420d64f48d42a3ccb0602bfb848c9e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003c/div\u003e","tags":["topcoder","srm659"]}}