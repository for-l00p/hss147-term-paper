{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1403599283,"rating":-1,"authorHandle":"ALEXKIRNAS","modificationTimeSeconds":1403601579,"id":12813,"title":"\u003cp\u003eИзучение set \u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eВсем доброго времени суток! Недавно изучил алгоритм Дейкстры и его реализацию с помощью контейнера set. Но для того чтобы он (алгоритм) работал верно нужно было держать в контейнере данные типу pair что уменьшало скорость работы, поэтому я решил написать к контейнеру компаратор:\u003c/p\u003e\u003cp\u003estruct cmp {  bool operator()(int a, int b) const { return d[a] \u0026lt; d[b];} };\u003c/p\u003e\u003cp\u003eздесь массив d[] хранит кратчайшее расстояние к вершине i;\u003c/p\u003e\u003cp\u003eКогда я попробовал добавить в контейнер число b, такое что d[a]\u003d\u003dd[b] и a!\u003db, то ничего не произошло (то есть нужное число не добавилось в контейнер а релаксация вершины прошла) и как последствие неверная работа алгоритма :(\u003c/p\u003e\u003cp\u003eВозможно ли как-то это исправить (обойти проблему), или придется пользоваться контейнером с pair? Можно ли это реализовать с помощью других встроенных структур данных?\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eP.S.\u003c/strong\u003e: За ранние всем спасибо :)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD:\u003c/strong\u003e Проблема решена, но вопрос реализации с помощью других структур остается открыт. \u003c/p\u003e\u003c/div\u003e","tags":["set","task","problem"]}}