{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1492269959,"rating":-22,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1492270137,"id":51586,"title":"\u003cp\u003eSolutions to Google Code Jam 2017 Round1A-- Problem A, B\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA. Alphabet Cake\u003c/p\u003e\u003cp\u003eI solved this problem by first filling the array row by row, and then column by column.\u003c/p\u003e\u003cp\u003eFor each row, at first I enumerate from the first element to the last one until I find an element that is not \u0027?\u0027, and then break the loop. If such an element that is not \u0027?\u0027 does not exist, it means that this row consists of only \u0027?\u0027. Such a row is skipped, however do not worry since it will be implemented later. Now suppose that we have found such an element which is not \u0027?\u0027 and denote it as a variable x (char x;). Then, I enumerate from the first element again, and \u003c/p\u003e\u003cp\u003e1) when a \u0027?\u0027 is met, just replace it with x; \u003c/p\u003e\u003cp\u003e2) when x is met (note that x must be the first letter that is met, since I immediately break the loop when the first element that is not \u0027?\u0027 is found), do nothing (or replace it with x, which achieves the same result); \u003c/p\u003e\u003cp\u003e3) when a letter different from x is met, just update x with this letter, and go to step 1).\u003c/p\u003e\u003cp\u003eAfter the above operations, for instance, ???A??B??CD? will be changed into AAAAAABBBCDD. However, it can not cover the case where some row consists of only \u0027?\u0027, and thus we repeat the above operations again column by column, i.e., the three steps are exactly the same but the enumeration is implemented in a column.\u003c/p\u003e\u003cp\u003eFor instance, \u003c/p\u003e\u003cp\u003e???A??B??CD?\u003c/p\u003e\u003cp\u003e????????????\u003c/p\u003e\u003cp\u003eE????F???GHI\u003c/p\u003e\u003cp\u003ewill be first changed into\u003c/p\u003e\u003cp\u003eAAAAAABBBCDD\u003c/p\u003e\u003cp\u003e????????????\u003c/p\u003e\u003cp\u003eEEEEEFFFFGHI\u003c/p\u003e\u003cp\u003ethen \u003c/p\u003e\u003cp\u003eAAAAAABBBCDD\u003c/p\u003e\u003cp\u003eAAAAAABBBCDD\u003c/p\u003e\u003cp\u003eEEEEEFFFFGHI\u003c/p\u003e\u003cp\u003eB. Ratatouille\u003c/p\u003e\u003cp\u003eWell, this is a tough problem for me. At first, I could not figure out how to solve large input so I wrote a special version for small input. It was about 15 minutes before the end that I finally realized how to deal with N\u0026gt;2...\u003c/p\u003e\u003cp\u003eAt first, we should consider under what conditions that two packages corresponding to different ingredients can be used to constitute a kit (or can be paired). For some given two packages, we denote the quantity they contain as Q1 and Q2, while the number of corresponding ingredients are R1 and R2. If we want to use Q1, we must find some integer K1 that satisfies R1*0.9*K1\u0026lt;\u003dQ1\u0026lt;\u003dR1*1.1*K1, and similarly R2*0.9*K2\u0026lt;\u003dQ2\u0026lt;\u003dR2*1.1*K2 if we want to use Q2. Therefore, if both Q1 and Q2 can be used as a kit, there must be at least one common integer K that satisfies K1\u003dK\u003dK2. Moreover, it is not necessary to find out such a precise K since we can find out the intervals that K1 and K2 falls into, respectively, and then check whether the two intervals intersect with each other or not. If they intersect with each other, it means that at least one common integer K\u003dK1\u003dK2 can be found. According to R1*0.9*K1\u0026lt;\u003dQ1\u0026lt;\u003dR1*1.1*K1, we have Q1/(1.1*R1)\u003d\u0026lt;K1\u0026lt;\u003dQ1/(0.9*R1). Note that the \u0026quot;double division\u0026quot; should be avoided since otherwise you might get stuck in \u0026quot;precision problem\u0026quot;. We can multiply both denominator and nominator by 10, which gives (10*Q1)/(11*R1)\u0026lt;\u003dK1\u0026lt;\u003d(10*Q1)/(9*R1). Then, as K1 is an integer, we can use \u0026quot;integer division\u0026quot; to obtain the lower bound (inclusive) as (10*Q1)/(11*R1)+((10*Q1)%(11*R1)!\u003d0), and the upper bound (inclusive) as (10*Q1)/(9*R1), where the \u0027/\u0027 is \u0026quot;integer division\u0026quot;. Therefore, we can check whether the intervals [(10*Q1)/(11*R1)+((10*Q1)%(11*R1)!\u003d0), (10*Q1)/(9*R1)] and [(10*Q2)/(11*R2)+((10*Q2)%(11*R2)!\u003d0), (10*Q2)/(9*R2)] intersect with each other or not.\u003c/p\u003e\u003cp\u003eThen, suppose that there are only two ingredients, and we consider how the corresponding packages can be \u0026quot;paired\u0026quot; to achieve the maximum number of pairs (or kits). We adopt a greedy idea. We adopt an array Q[N][P] (specifically N\u003d2), where Q[i][j] denotes the quantity of the j-th package corresponding to the i-th ingredient. We first sort the packages in an increasing order of their quantities for each ingredient, i.e., Q[i][0]\u0026lt;\u003dQ[i][1]\u0026lt;\u003d...Q[i][P-1]. Then, we enumerate from the first package to the last one for the 0-th ingredient (a simple example will be shown later). For each enumerated package Q[0][j1], we enumerate from the first package to the last one for the 1-th ingredient, and find out the first one Q[1][j2] that can be paired with Q[0][j1]. Then, we break the loop for Q[1][j2] and go back to the loop for Q[0][j1]. However, for this time, when we deal with Q[0][j1+1], we should start from Q[1][j2+1] but not Q[1][0]. The correctness of such greedy idea can be proved but omitted here. Here is a simple example. Suppose that we have\u003c/p\u003e\u003cp\u003eQ[0][0], Q[0][1], Q[0][2], Q[0][3]\u003c/p\u003e\u003cp\u003eQ[1][0], Q[1][1], Q[1][2], Q[1][3]\u003c/p\u003e\u003cp\u003eWe first deal with Q[0][0], and try from Q[1][0] to Q[1][3] one by one, and assume that Q[1][1] is the first one which can be \u0026quot;paired\u0026quot; with Q[0][0]. Then, we deal with Q[0][1], and try from Q[1][2] to Q[1][3], and assume that Q[1][3] is \u0026quot;paired\u0026quot; with Q[0][1]. Then, for Q[0][2] and Q[0][3], they cannot be \u0026quot;paired\u0026quot;. \u003c/p\u003e\u003cp\u003eFinally, I introduced a \u0026quot;flag\u0026quot; array to denote whether a package has been selected to be \u0026quot;paired\u0026quot; with some other package or not, i.e., flag[N][P] where flag[i][j]\u003d0 means that the j-th package corresponding to the i-th ingredient is not \u0026quot;paired\u0026quot; while flag[i][j]\u003d1 means that it is \u0026quot;paired\u0026quot; with some package corresponding to the (i+1)-th ingredient. With such a \u0026quot;flag\u0026quot;, I can deal with N\u0026gt;3 case. For Q[N][P], I enumerate from N-2 to 0, and for each Q[i][j1], I use the above greedy idea to find out which Q[i+1][j2] can be \u0026quot;paired\u0026quot; with Q[i][j1]. The \u0027can be \u0026quot;paired\u0026quot;\u0027 condition is: Q[i+1][j2] intersects with Q[i][j1] (recall the intervals mentioned above) and flag[i+1][j2]\u003d\u003d1. Specifically, the row of flag[N-1][ ] is initialized with all \u0026quot;1\u0026quot; values. When Q[i][j1] is \u0026quot;paired\u0026quot;, I update flag[i][j1]\u003d1. Here is a simple example:\u003c/p\u003e\u003cp\u003eQ[0][0], Q[0][1], Q[0][2], Q[0][3]\u003c/p\u003e\u003cp\u003eQ[1][0], Q[1][1], Q[1][2], Q[1][3]\u003c/p\u003e\u003cp\u003eQ[2][0], Q[2][1], Q[2][2], Q[2][3]\u003c/p\u003e\u003cp\u003ewith flag as\u003c/p\u003e\u003cp\u003e0, 0, 0, 0\u003c/p\u003e\u003cp\u003e0, 0, 0, 0\u003c/p\u003e\u003cp\u003e1, 1, 1, 1\u003c/p\u003e\u003cp\u003eWe first deal with the 1-th row and 2-th row. For Q[1][0], we try from Q[2][0] to Q[2][3] and find Q[2][1] \u0026quot;paired\u0026quot; with Q[1][0], then flag is changed into\u003c/p\u003e\u003cp\u003e0, 0, 0, 0\u003c/p\u003e\u003cp\u003e1, 0, 0, 0\u003c/p\u003e\u003cp\u003e1, 1, 1, 1\u003c/p\u003e\u003cp\u003eFor Q[1][1], we try from Q[2][2] to Q[2][3] and find no Q[2][] \u0026quot;paired\u0026quot; with Q[1][1], then nothing is doen.\u003c/p\u003e\u003cp\u003eFor Q[1][2], we try from Q[2][2] to Q[2][3] and find no Q[2][3] \u0026quot;paired\u0026quot; with Q[1][2], then the flag is changed into\u003c/p\u003e\u003cp\u003e0, 0, 0, 0\u003c/p\u003e\u003cp\u003e1, 0, 1, 0\u003c/p\u003e\u003cp\u003e1, 1, 1, 1\u003c/p\u003e\u003cp\u003eFor Q[1][3], it cannot be \u0026quot;paired\u0026quot;. Then, we deal with Q[0][0], and try from Q[1][0] to Q[1][3] but note that Q[1][1] and Q[1][3] must be skipped since flag[1][1]\u003dflag[1][3]\u003d0. Assume that Q[0][0] is not \u0026quot;paired\u0026quot;, and then we move on to Q[0][1], and try from Q[1][0] to Q[1][3] (Q[1][1] and Q[1][3] are skipped), and suppose that Q[1][2] is \u0026quot;paired\u0026quot;, then the flag is changed into\u003c/p\u003e\u003cp\u003e0, 1, 0, 0\u003c/p\u003e\u003cp\u003e1, 0, 1, 0\u003c/p\u003e\u003cp\u003e1, 1, 1, 1\u003c/p\u003e\u003cp\u003eFor Q[0][2] to Q[0][3], they cannot be \u0026quot;paired\u0026quot;. \u003c/p\u003e\u003cp\u003eThe answer is just the number of \u0026quot;1\u0026quot; in the 0-th row of flag, i.e., 0+1+0+0\u003d1. I think this is similar to the idea of dynamic programming. To constitue as many kits as possible, the packages corresponding to the last row (ingredient) Q[N-1][ ] must be \u0026quot;paired\u0026quot; with some other ones. Thus, we start from Q[N-2][ ] and Q[N-1][ ], and try to find out as many \u0026quot;pairs\u0026quot; as possible. Then, we deal with Q[N-3][ ] and Q[N-2][ ], but the \u0026quot;pairs\u0026quot; must be made based on the \u0026quot;pairs\u0026quot; already exist in Q[N-2][ ], which is indicated by flag[N-2][ ]. The last row flag[N-1][ ] is initialized with all \u0026quot;1\u0026quot; since for Q[N-2][ ], any Q[N-1][ ] can be selected without any restriction. This implies that the number of \u0026quot;1\u0026quot; in flag[0][ ] is just the maximum number of kits (pairs). Finally, I deal with N\u003d1 as a special case.\u003c/p\u003e\u003c/div\u003e","tags":[]}}