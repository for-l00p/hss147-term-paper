{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1492867613,"rating":2,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1492867613,"id":51669,"title":"\u003cp\u003eSolutions to Codeforces Beta Round #37, A, B, C (Prefix Code--Coding Theory, Information Theory)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA. Towers\u003c/p\u003e\u003cp\u003eAs the range of N is from 1 to 1000, we can adopt a \u0026quot;hash table\u0026quot; to record how many times an integer appears. Then, to find the height of the largest tower, it is sufficient to find the integer that has appeared for the most times, and the times it appears is just the answer. The total number of towers is just the number of distinguishing integers.\u003c/p\u003e\u003cp\u003eB. Computer Game\u003c/p\u003e\u003cp\u003eThis is really a tricky problem. We should use several variables to record and update \u0026quot;states\u0026quot;, which include:\u003c/p\u003e\u003cp\u003e1) The current health point of the boss at each second, denoted as Cur_HP;\u003c/p\u003e\u003cp\u003e2) The accumulated damage that has been cast on the boss for each second, denoted as Damage.\u003c/p\u003e\u003cp\u003eWith the above variables, we can simulate what happens from the zero second to some T-th second (the value of T will be discussed later). At each second, we first calculate Cur_HP-Damgae, and if the result is negative or zero, we can immediately terminate the simulation since the boss has been defeated. On the contrary, we increase Cur_HP-Damgae by the regeneration rate and obtain the updated health point of the boss; however we should remember that the updated health point cannot be larger than the initial amount of health. Then, we enumerate the scrolls and find out the one that satisfies the following conditions: it has not been used; it can be used according to the given rules; it can lead to the largest damage. Then, we update the value of variable Damage, and move on to the next second. \u003c/p\u003e\u003cp\u003eFinally, we consider up to what time is sufficient to implement the above simulation, i.e., what value should T have, since if T is too small we may not get the right result while otherwise may lead to a Time Limited Error. The initial amount of health point of the boss is at most 1000, and if Damage becomes larger than the regeneration rate by only 1 at the 1000-th second, then it takes another 1000 seconds to defeat the boss. Therefore, the simulation should be implemented for at least 2000 seconds, and we had better set it to 3000 seconds, just in case.\u003c/p\u003e\u003cp\u003eC. Old Berland Language\u003c/p\u003e\u003cp\u003eThis is a problem about prefix code, which is often related to the uniquely decodable codes in Coding Theory, or Information Theory.\u003c/p\u003e\u003cp\u003eA well known method is to establish a binary tree, whose left branch and right branch denote 0 and 1, respectively. For any node, we can obtain a code sequence consisting of 0 and 1 by walking along the branches from the root node to the current one. Whenever we obtain a code sequence, we should cut off all the child nodes rooted at the current node to guarantee the \u0026quot;prefix code\u0026quot; property. \u003c/p\u003e\u003cp\u003eHowever, for this problem, the above idea perhaps cannot be directly applied since N, which corresponds to the height of the tree, is up to 1000 and thus intractable as far as I consider. In fact, it might not be necessary to explicitly build such a tree, since the total number of each code sequence will not exceed 1000. One straightforward solution is to build a set which only contains a null string \u0026quot;\u0026quot; at first. Then, we enumerate from length-0 to length-1000, and for each length, we first take out the required number of code sequence (if we cannot it means that the answer is \u0026quot;NO\u0026quot;) and then for each unused code sequence, we append \u00270\u0027 and \u00271\u0027 to obtain two new sequences for the next length. \u003c/p\u003e\u003c/div\u003e","tags":[]}}