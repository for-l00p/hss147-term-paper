{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1521343921,"rating":0,"authorHandle":"xzm2001","modificationTimeSeconds":1521343921,"id":58428,"title":"\u003cp\u003eTest Round #3 题解\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e所有题目与题解均来自于互联网\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eA-圆的国度\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003e由于各圆各不相交，对于每个圆只要判断是不是只有一个点在其中即可。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eB-旅馆\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003e小模拟。\u003c/p\u003e\u003cp\u003e因为只需要单个考虑，那只要对于每个询问从n个中找最小的即可。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC-跳房子\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003e显然是一道DP题，然后可以总结为以下几点：\u003c/p\u003e\u003cp\u003e①g的枚举范围很大，可以用二分枚举。\u003c/p\u003e\u003cp\u003e②dp[i]表示在第i个格子上的最大得分，score[i]表示第i个格子上的分值，dis[i]表示第i个格子离出发点的距离，可得到状态转移方程：\u003c/p\u003e\u003cp\u003edp[i]\u003dmax{dp[j]+score[i]}（j\u0026lt;i，max(d-g,1)\u0026lt;\u003ddis[i]-dis[j]\u0026lt;\u003dd+g）\u003c/p\u003e\u003cp\u003e③按上述方法，复杂度依旧到达了n^2lg(M_g)，可以知道，dp[i]是跟距离成正比的，可以用单调队列优化，最后复杂度为O（nlg(M_g)）。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eD-阶乘的和\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003e阶乘有这样的性质:∑(n-1)! \u0026lt;\u003d n!\u003c/p\u003e\u003cp\u003e所以如果有:(i+1)!\u0026gt;n且i!\u0026lt;\u003dn 那么i!必然要用来构造n。\u003c/p\u003e\u003cp\u003e所以暴力即可\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eE-访问\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003e本题是一个搜索题。\u003c/p\u003e\u003cp\u003e(1)搜索前可以用floyd（实际就是一种dp，f[i][j]\u003dmin(f[i][k]+f[k][j])）预处理出任意两点间的最短距离。\u003c/p\u003e\u003cp\u003e(2)搜索前可以进行可能性的判断。\u003c/p\u003e\u003cp\u003e(3)搜索中如果当前访问时间为k，访问顶点为i，假设下一步到达顶点j，如果j的时限比k+time[i][j]小，则说明不能到达j，搜索可终止\u003c/p\u003e\u003cp\u003e(4)搜索中可以判断是否当前搜索可以达到已得出的最优解。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}