{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1471136891,"rating":-10,"authorHandle":"ebanner","modificationTimeSeconds":1471185872,"id":46548,"title":"\u003cp\u003eProblem 313B\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThis post will be a tutorial on \u003ca href\u003d\"/contest/313/problem/B\" title\u003d\"Codeforces Round 186 (Div. 2)\"\u003e313B - Ilya and Queries\u003c/a\u003e, as well as some general python I/O optimizations that provided me with enough of a speedup to have my solution finish in the allotted time.\u003c/p\u003e\u003ch4\u003eSolution\u003c/h4\u003e\u003cp\u003eAs an example, consider the input string \u003ccode\u003e#..###\u003c/code\u003e. From it, we create arrays\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ccode\u003eS \u003d [ # . . # # # ]\u003c/code\u003e\u003c/li\u003e   \u003cli\u003e\u003ccode\u003eA \u003d [ 0 1 0 1 1 X ] \u003d [ a_1 a_2 a_3 a_4 a_5 a_6 ]\u003c/code\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003ewhere\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ccode\u003eS\u003c/code\u003e is an array encoding the input string.\u003c/li\u003e   \u003cli\u003e\u003ccode\u003eA[i] \u003d 1\u003c/code\u003e if \u003ccode\u003eS[i] \u003d\u003d S[i+1]\u003c/code\u003e and \u003ccode\u003e0\u003c/code\u003e otherwise (\u003ccode\u003eA[-1]\u003c/code\u003e is undefined).\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eLet \u003ccode\u003ef(l, r)\u003c/code\u003e be a function where \u003ccode\u003ef(l, r) \u003d a_{l} + a_{l+1} + ... + a_{r-1}\u003c/code\u003e. Clearly \u003ccode\u003ef\u003c/code\u003e corresponds to a query in \u003ca href\u003d\"/contest/313/problem/B\" title\u003d\"Codeforces Round 186 (Div. 2)\"\u003e313B - Ilya and Queries\u003c/a\u003e (convince yourself if you don\u0027t see it!).\u003c/p\u003e\u003cp\u003eA naive solution is to compute \u003ccode\u003ef(l, r)\u003c/code\u003e iteratively (i.e. by looping from \u003ccode\u003el\u003c/code\u003e to \u003ccode\u003er-1\u003c/code\u003e). However, the runtime of this algorithm is \u003ccode\u003eO(nm) \u003d O(n^2)\u003c/code\u003e as \u003ccode\u003e0 \u0026lt;\u003d m \u0026lt;\u003d n\u003c/code\u003e. Hence, in the worst case we will do \u003ccode\u003e(10^5)^2 \u003d 10^10\u003c/code\u003e operations as \u003ccode\u003e0 \u0026lt;\u003d n \u0026lt;\u003d 10^5\u003c/code\u003e, which is too large a number for the allotted time. Hence we need to do better.\u003c/p\u003e\u003cp\u003eOne idea is to pre-compute \u003ccode\u003ef(l, r)\u003c/code\u003e for \u003ccode\u003e0 \u0026lt;\u003d l \u0026lt; r \u0026lt;\u003d n\u003c/code\u003e so we can look up the answer for any \u003ccode\u003e(l, r)\u003c/code\u003e pair. However, it turns out this table has \u003ccode\u003e10^10\u003c/code\u003e elements in it, so it won\u0027t do. But the general idea of pre-computing is good so we explore it further.\u003c/p\u003e\u003cp\u003eIt turns out that instead of pre-computing every possible \u003ccode\u003ef(l, r)\u003c/code\u003e pair, we can pre-compute a smaller number of values which we will then be able to use to very quickly to compute any \u003ccode\u003ef(l, r)\u003c/code\u003e pair we want. Consider the following function \u003ccode\u003eF(r)\u003c/code\u003e, where \u003ccode\u003eF(r) \u003d a_1 + a_2 + ... + a_{r-1}\u003c/code\u003e. The key observation is that \u003ccode\u003ef(l, r) \u003d F(r) - F(l)\u003c/code\u003e. To see, this consider \u003ccode\u003ef(2, 5)\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ef(2, 5) \u003d       a_2 + a_3 + a_4 \n        \u003d a_1 + a_2 + a_3 + a_4\n        - a_1\n        \u003d F(5)\n        - F(2).\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHence all that remains is to compute \u003ccode\u003eF(r)\u003c/code\u003e for \u003ccode\u003e0 \u0026lt;\u003d r \u0026lt;\u003d n\u003c/code\u003e. Note that this cuts the runtime down by a factor of \u003ccode\u003em\u003c/code\u003e to \u003ccode\u003eO(n*1) \u003d O(n)\u003c/code\u003e as \u003ccode\u003eF(l)\u003c/code\u003e and \u003ccode\u003eF(r)\u003c/code\u003e are constant-time lookups.\u003c/p\u003e\u003ch4\u003eI/O Optimizations\u003c/h4\u003e\u003cp\u003eEven with this optimization, my python solution was still exceeding the time limit. After profiling my code, I discovered I/O was the bottleneck. I replaced\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor _ in range(m):\n    l, r \u003d [int(num) for num in raw_input().split()]\n    print A[r] - A[l]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ewith\u003c/p\u003e \u003cpre\u003e\u003ccode\u003elines \u003d sys.stdin.readlines()\ninputs \u003d [[int(num)-1 for num in line.split()] for line in lines]\noutputs \u003d [str(SA[r]-SA[l]) for l, r in inputs]\nprint \u0027\\n\u0027.join(outputs)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEliminating the repeated calls to \u003ccode\u003eraw_input()\u003c/code\u003e and \u003ccode\u003eprint\u003c/code\u003e gave me a substantial speedup which was fast enough to have my solution finish within the allotted time!\u003c/p\u003e\u003c/div\u003e","tags":[]}}