{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1439037829,"rating":29,"authorHandle":"ashish1610","modificationTimeSeconds":1439060119,"id":19653,"title":"\u003cp\u003eProcon 2015 Editorials\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eLittle Red Riding Hood and Candy Factory\u003c/h3\u003e\u003cp\u003eThe problem basically asks to check if the integer is even or odd. As integer is very large you can check if last digit is even or odd to decide the ans. If the integer is even than the ans is \u003cb\u003eYES\u003c/b\u003e else ans is \u003cb\u003eNO\u003c/b\u003e \u003c/p\u003e\u003ch3\u003eLittle Red Riding Hood and Convolutions\u003c/h3\u003e\u003cbr /\u003e Convolution(L) \u003d L1*L2*L3*L4 + L2*L3*L4*L5 + ........\u003cbr /\u003e Since only allowed values for L[i] is 1 or -1, we can say that the number of terms (L\u003csub\u003ei\u003c/sub\u003e*L\u003csub\u003ej\u003c/sub\u003e*L\u003csub\u003ek\u003c/sub\u003e*L\u003csub\u003el\u003c/sub\u003e) which evaluates to -1 are equal to number of terms which evaluates to 1. So, if we negate the given list the number of terms which evaluates to -1 or 1 doesn\u0027t change and we get another list L\u0027 whose Convolution(L\u0027) \u003d 0 \u003ch3\u003eAn Unfair Fair Game\u003c/h3\u003e\u003cbr /\u003e Greedy, O(k):\u003cbr /\u003e Lets start with simple greedy solution. Given n, subtract k, k-1, k-2 from n till the residue of number is between 0 to k. If the residue is non-zero, add the remaining number to the answer set, and report (k — the cardinality of the answer set).\u003cbr /\u003e Optimizing greedy to just count the cardinality, O(log(k)):\u003cbr /\u003e Observe that the numbers we are subtracting form a simple AP, {k, k-1, …, k-x}. The sum of this is S(x): k*(k+1)/2 — (k-x-1)*(k-x)/2. This is a strictly decreasing function in the range x \u003d [1, k]. We can do binary search to find the first non-negative value of S(x). Let this value occur at x \u003d z, answer is (k — (z + (s(z) \u003d\u003d 0))).\u003cbr /\u003e Expected complexity : O(log(k)) \u003ch3\u003eGraph Sum\u003c/h3\u003e\u003cbr /\u003e We have to support two queries, add a value to a vertex and print the subtree sum.\u003cbr /\u003e Finding the value:\u003cbr /\u003e \u003cul\u003e  \u003cli\u003eif m is odd then no. of ways to form m by 2 and 4 is zero.\u003c/li\u003e  \u003cli\u003eif m is even then no. of ways is equal to the no. of ways of forming m/2(let say R \u003d m/2) by 1 and 2.\u003cbr /\u003e  which is actually SIGMA(i \u003d 0 to R-1) ((R-i-1) Choose (i)) which is fibonacci number Fib(R)\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eTaking last 5 digits is nothing but mod operation with 10\u003csup\u003e5\u003c/sup\u003e. Fib(R) repeats after 150000 when we take mod with 10\u003csup\u003e5\u003c/sup\u003e.\u003cbr /\u003e Now add the (no. of ways) * m to every vertex in path from v to vertex 1(root). Use HLD to perform the query.\u003cbr /\u003e Expected Complexity : O(N*log\u003csup\u003e2\u003c/sup\u003e(N))\u003cbr /\u003e HLD Tutorial : \u003ca href\u003d\"http://blog.anudeep2011.com/heavy-light-decomposition\"\u003eTutorial\u003c/a\u003e\u003cbr /\u003e Alternate way to solve the problem : \u003ca href\u003d\"//codeforces.com/blog/entry/19653?#comment-244666\"\u003egrikukan\u0027s solution\u003c/a\u003e \u003c/p\u003e\u003ch3\u003eCode Land\u003c/h3\u003e\u003cbr /\u003e The problem statement reduces to this:\u003cbr /\u003e Given an undirected weighted graph and information of weights of every edge. Remove one bridge and add another such that the weight of the graph is maximized.\u003cbr /\u003e Lets see what the brute force solution for this will be. Lets try adding every edge and removing minimum weight bridge corresponding to that edge. The complexity of this solution will be O(n\u003csup\u003e3\u003c/sup\u003e).\u003cbr /\u003e Lets see how we can optimize this code.\u003cbr /\u003e Claim 1: Every bridge of the graph will be in ST.\u003cbr /\u003e Proof : Let say tree T is a ST of graph but there is an edge e (x, y) which is not in this ST. Now, as e is not in ST than there is no way to go from x to y (By definition of bridge. The bridge is the only way to reach y from x). That means ST is not connected and hence is not ST, Therefore every bridge of the graph has to be in the ST.\u003cbr /\u003e Now, we have a ST which contains all the nodes and all the bridges. Lets find the minimum weight bridge between every pair of nodes (n1, n2). Since, now we have a tree there is only one path from any one node to another, we can find this minimum weight bridge between every pair of nodes by doing n dfs.\u003cbr /\u003e Now, lets try out our original solution. Since, now we know the minimum weight bridge for every pair of node we can do the same solution in O(n\u003csup\u003e2\u003c/sup\u003e).\u003cbr /\u003e Final running time : O(n\u003csup\u003e2\u003c/sup\u003e)\u003cbr /\u003e \u003ch3\u003eRange Query\u003c/h3\u003e\u003cbr /\u003e To solve this problem we will use MO\u0027s algorithm. If we have sorted our queries with MO\u0027s. We can than use range query and range update data structures to solve the problem. For any add or remove we need to update [A[i] — k, A[i] + K] and correspondingly we will add and subtract cnt of range [A[i] — k, A[i] + k] from our ans.\u003cbr /\u003e We need to use BIT rather than Segment tree (I tried with both and there was a huge difference between time taken to generate ans by both codes. I think the reason for this was recursion but not sure. If anyone know the exact reason please comment.).\u003cbr /\u003e Expected complexity : O(n*sqrt(n)*log(n))\u003cbr /\u003e Sources for MO\u0027s algorithm : \u003ca href\u003d\"http://blog.anudeep2011.com/mos-algorithm/\"\u003eTutorial\u003c/a\u003e\u003cbr /\u003e\u003cp\u003eIf you find any issues with the editorials let us know. Thanks for participating. :)\u003c/p\u003e\u003c/div\u003e","tags":["esya","prosort","iiitd","editorials"]}}