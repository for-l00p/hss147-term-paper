{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1515468216,"rating":0,"authorHandle":"zhenghaishu","modificationTimeSeconds":1515468363,"id":56996,"title":"\u003cp\u003eCodeforces Round #456 Div.2 B. New Year\u0027s Eve\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eProblem\u003c/h1\u003e\u003cp\u003ecodeforces.com/contest/912/problem/B\u003c/p\u003e\u003ch1\u003eAnalysis\u003c/h1\u003e\u003cp\u003eYou can choose k or less than k integers from 1~n, calculate maximum xor result (1) k \u003d 1, You can only choose one integer, so you choose n and get the maximum xor result n (2) k \u0026gt; 1, whatever k is, such as k \u003d 2, or k \u003d 3, ......, or k \u003d n, if n has x bits as binary code, the maximum xor result must be 2 ^ x — 1\u003c/p\u003e\u003cp\u003e本题是求从1~n个数中取小于或等于k个数（比如n \u003d 4, k \u003d 3表示从1~4中取1个数或2个数或3个数），对这些数进行异或求和，求最大的异或求和值。 （1）k \u003d 1时，即从1~n个数中1个数，那么最大的数自然是n。结果为n （2）k \u0026gt; 1时，假如n以二进制表示是x位数，则结果必为\u003ccode\u003e2 ^ x - 1\u003c/code\u003e\u003c/p\u003e\u003ch3\u003eExample 1\u003c/h3\u003e\u003cp\u003en \u003d 4, k \u003d 2 choose 4 and 3, maximum \u003d 4 xor 3 \u003d 7 可以取4和3这两个数，最大异或结果 \u003d 4 xor 3 \u003d 7 \u003d \u003ccode\u003e2 ^ 3 - 1\u003c/code\u003e\u003c/p\u003e\u003ch3\u003eExample 2\u003c/h3\u003e\u003cp\u003en \u003d 4, k \u003d 3 Choose two numbers, 4 and 3. Or choose three numbers, 4, 1 and 2. maximum \u003d 4 xor 3 \u003d 4 xor 1 xor 2 \u003d 7 可以取4和3这两个数，也可以取4、1、2这三个数。 最大异或结果 \u003d 4 xor 3 \u003d 4 xor 1 xor 2 \u003d 7\u003c/p\u003e\u003ch3\u003eExample 3\u003c/h3\u003e\u003cp\u003en \u003d 4, k \u003d 4 Choose two numbers, 4 and 3. Or choose three numbers, 4, 1 and 2. maximum \u003d 7 You can not choose all for numbers, because 4 xor 1 xor 2 xor 3 xor 4 \u003d 3, which is not the maximum result. 可以取4和3，也可以取4、1、2。最大异或结果为7。 但不能取4、1、2、3。因为4 xor 1 xor 2 xor 3 xor 4 \u003d 3，不是最大的结果。\u003c/p\u003e\u003ch3\u003eExample 4\u003c/h3\u003e\u003cp\u003en \u003d 6, k \u003d 6 Just choose 1 and 6, maximum \u003d 6 xor 1 \u003d 7 只要在1~6中取6和1两个数就行了，6 xor 1 \u003d 7 \u003c/p\u003e\u003ch1\u003eCode\u003c/h1\u003e\u003ch3\u003ePython2\u003c/h3\u003e \u003cpre\u003e\u003ccode\u003eimport sys\n\nn, k \u003d map(int, raw_input().split())\n\nif 1 \u003d\u003d k:\n    print n\n    sys.exit(0)\n\nres \u003d 1\nwhile res \u0026lt; n:\n    res \u003d res * 2 + 1\n\nprint res\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eC Language\u003c/h3\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdint.h\u0026gt;\n\nint main(void)\n{\n    int64_t n, k;\n    scanf(\u0026quot;%I64d %I64d\u0026quot;, \u0026amp;n, \u0026amp;k);\n    \n    if (1 \u003d\u003d k) \n\t{\n        printf(\u0026quot;%I64d\\n\u0026quot;, n);\n        \n        return 0;\n    }\n    \n    int bit \u003d 0;\n    for (; n \u0026gt;\u0026gt; bit; bit++);\n    printf(\u0026quot;%d\u0026quot;, n);\n    printf(\u0026quot;%d\u0026quot;, bit);\n    \n    printf(\u0026quot;%I64d\\n\u0026quot;, (1LL \u0026lt;\u0026lt; bit) - 1);\n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}