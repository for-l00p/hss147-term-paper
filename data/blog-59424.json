{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1526196935,"rating":0,"authorHandle":"rasalghul","modificationTimeSeconds":1526196935,"id":59424,"title":"\u003cp\u003eNeed help with approach: Job Scheduling problem\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eGiven N processes with Arrival times and Processing times, calculate and print minimum number of CPUs required if maximum allowed Turnaround time for each process is 10 units.\u003c/p\u003e\u003cp\u003eTurnaround time \u003d Waiting time in queue + Processing time\u003c/p\u003e\u003cp\u003eEach processor has its own processing queue. Processes cannot be preempted.\u003c/p\u003e\u003cp\u003eMaximum number of CPUs allowed is 5. If more than 5 required, then print -1.\u003c/p\u003e\u003cp\u003eExample:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eTask Arrival_time Processing_time\nT1   2            7\nT2   3            5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAns: 2\u003c/p\u003e\u003cp\u003eI was thinking of a greedy approach initially (which turned out to be wrong) based on the following observations (which might be wrong)\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eA process which with earlier arrival time should always get scheduled earlier than a process with later arrival time — no benefit in scheduling it later\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIt is always better to schedule a process on a CPU with longer queue (as long as the Turnaround time condition is met), reason being, we will have a free resource available earlier, i.e. tightest fit match — Eg: [Arrival time, Processing time] If we have CPU1 queue to be [0,2][2,5] and CPU2 [0,3], if a job [3,4] comes in, schedule it on CPU1. We will have a free resource (CPU2) — available earlier — i.e. from 3 onwards, but if we schedule on CPU2, then we only have free resource (CPU1) from 5 onwards.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eApproach:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e- At each arrival time, sort jobs based on Processing time.\n- Maintain a decreasing load list of CPUs (i.e. CPU with highest load is first on the list)\n- Allocate jobs to CPUs in the given order, highest processing time job to first possible busiest CPU, reorder CPUs if necessary after allocating, if cannot allocate to existing CPUs, create new CPU (if \u0026lt;\u003d 5) and allocate job to it\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThough this might work well in an online setting (i.e. when we don\u0027t know the all the jobs and times in advance), it is suboptimal when we know that information. Eg:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eTask Arrival_time Processing_time\nT1   0            3\nT2   0            3\nT3   3            8\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe approach outlined would schedule T1 and T2 on CPU1, and when T3 arrives, it gets scheduled on CPU2 (which gets created). If we\u0027d known that we would need CPU2, we could\u0027ve as well scheduled T2 on CPU1, which is better.\u003c/p\u003e\u003cp\u003eHence, I realized that I may not be utilizing the \u0026lt;\u003d5 CPU part of the question. Now I think the approach should be to try a solution with 1 CPU first, if not possible, then with 2 CPUs,.. Now for each arrival time, sort jobs in ascending order of processing time and allocate it in that order to the free-est CPU — i.e. least turnaround time — from amongst the k CPUs where k \u003d 1 to begin with, 2 if solution with k\u003d1 is not possible and so on.\u003c/p\u003e\u003cp\u003eIf this too is wrong, what could be the right approach to this problem?\u003c/p\u003e\u003c/div\u003e","tags":["greedy","job scheduling","#adhoc","#interview"]}}