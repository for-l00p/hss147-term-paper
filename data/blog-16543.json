{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1424522149,"rating":3,"authorHandle":"Fcdkbear","modificationTimeSeconds":1424522149,"id":16543,"title":"\u003cp\u003eКраткий разбор тренировки 21.02.2015\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eЗадача А:\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eОсновные идеи\u003c/p\u003e\u003cp\u003e1) Всегда выгодно делать наше число длины ровно n\u003c/p\u003e\u003cp\u003e2) Всегда выгодно делать первые разряды как можно больше.\u003c/p\u003e\u003cp\u003e3) Если n*9\u0026gt;a — ответ равен -1\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача B\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eРисуем и понимаем, что ответ всегда равен такому:\u003c/p\u003e\u003cp\u003e123451234512345...\u003c/p\u003e\u003cp\u003e451234512345123...\u003c/p\u003e\u003cp\u003e234512345123451...\u003c/p\u003e\u003cp\u003e512345123451234...\u003c/p\u003e\u003cp\u003eТо есть i-ая строчка получается из (i-1)-ой путем циклического сдвига влево на 3.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача С\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eОтсортируем точки сначала по x, а при равенстве по y. Соединим первую в порядке сортировки точку со второй, третью с четвертой и так далее. Можно убедиться, что в таком случае пересечений не будет, а наш ответ — максимально возможный.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача D\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eПростая динамика. Пусть мы стоим на позиции p. Переберем отрезок людей, которые войдут с нами в нашу группу. Убедимся, что он невозрастающий либо неубывающий, и если это так — рекурсивно вызовемся от человека, который следует сразу за нашей группой. Сложность решения квадратичная, однако она легко опимизируется до линейной (путем использования частичных сумм)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача E\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eПросто переберем x от 1 до 3 и посмотрим, сколько из них являются корнями уравнения. Если корень единственный — выведем его, иначе выведем -1.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача F\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eПереберем двоичным поиском ответ. Проверим, или этот ответ нам подходит. Как это сделать? Пробежимся по всем ячейкам забора и посмотрим, сколько нам нужно добавить деталей, чтобы высота забора стала равна текущему перебираемому значению. Если в сумме мы добавили не более k деталей — ответ нам подходит и можно попробовать большие значения, иначе- меньшие.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача G\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eТут проще код написать, чем что-то обьяснять :) b[2] \u003d a[0];\u003c/p\u003e\u003cp\u003eb[0]\u003db[1]\u003d0;\u003c/p\u003e\u003cp\u003efor (int i\u003d3; i\u0026lt;\u003dn+1; ++i)\u003c/p\u003e\u003cp\u003e{\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eb[i] \u003d a[i-2]-b[i-1]-b[i-2];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e}\u003c/p\u003e\u003cp\u003eЕсли честно — не знаю, как доказать, что все числа не превзойдут 1000000000, но тем не менее — это так\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача H\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗаметим, что наибольшее количество раз всегда входит строка длины 1 (какая-то буква). Из этого можно понять, что длина ответа не превосходит 26. Действительно — если его длина больше 26, значит какая-то буква встречается в нем два раза, а значит, за счет того, что строки не пересекаются, наш ответ не оптимален.\u003c/p\u003e\u003cp\u003eТеперь решение тривиально — переберем длину строки (например, бинарным поиском), и посмотрим на все вхождения всех строк заданной длины. После этого найдем максимальное количество вхождений непересекающихся одинаковых строк. Если это количество равно количеству вхождений наиболее часто встречающейся буквы — текущая длина может быть ответом, иначе не может.\u003c/p\u003e\u003cp\u003eЗадача I\u003c/p\u003e\u003cp\u003eСамая тяжелая задача контеста.\u003c/p\u003e\u003cp\u003eДавайте решать задачу так: будем пытаться строить новое дерево, описанное в условии. Тогда если мы его построим — ответ восстановить несложно- для каждой вершины он равен ключу, записанному в правом сыне этой вершины.\u003c/p\u003e\u003cp\u003eНапишем рекурсивную функцию, которая будет решать нашу задачу для поддерева, а так же говорить, какоме максимальное число было испльзовано в поддереве. Мы будем пытаться делать это значение минимальным\u003c/p\u003e\u003cp\u003eВ нашей рекурсии будем поддерживать такие величины:\u003c/p\u003e\u003cp\u003e1) Номер вершины (v)\u003c/p\u003e\u003cp\u003e2) Номер ее предка (p)\u003c/p\u003e\u003cp\u003e3) В каком интервале может лежать ключ вершины в новом дереве ([cl; cr])\u003c/p\u003e\u003cp\u003e4) В каком интервале могут лежать все ключи этого поддерева нового дерева. ([ltree; rtree])\u003c/p\u003e\u003cp\u003e5) Правда ли, что текущая вершина — чей-то правый сын (если да — тогда ее ключ является значением для ее предка; эта информация нужна для простого восстановления ответа)\u003c/p\u003e\u003cp\u003eТогда наш алгоритм следующий:\u003c/p\u003e\u003cp\u003e1) Если мы пришли в лист — вернем cl.\u003c/p\u003e\u003cp\u003e2) Рекурсивно вызовемся от левого сына. Если для него не удалось найти ответ — ответа не существует.\u003c/p\u003e\u003cp\u003e3) Пердположим, что ответ для левого сына существует, и максимальное значение, использованное в левом поддереве нового дерева равно cur. Тогда в текущей вершине нового дерева ключ должен быть больше cur.\u003c/p\u003e\u003cp\u003e4) Рекурсивно вызовемся от правого сына и вернем ответ от него (внимательно пересчитав все парамеры)\u003c/p\u003e\u003cp\u003eЕсли на любом этапе выяснилось, что мы пришли в невозможную ситуацию (cl \u0026gt; cr; ltree \u0026gt; rtree; пересечение [cl; cr] с [ltree;tree] равно пустому множеству и так далее) — решения не существует.\u003c/p\u003e\u003c/div\u003e","tags":["тренировка","разбор"]}}