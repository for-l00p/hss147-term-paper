{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1434226277,"rating":64,"authorHandle":"GlebsHP","modificationTimeSeconds":1434991476,"id":18538,"title":"\u003cp\u003eYandex Algorithm Round 2.2 problems analysis\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eGood evening Codeforces, let me briefly describe solutions for all problems of today\u0027s morning yandex algorithm round. Thanks everyone who participated, I apologize for making problems a bit too tough and viscous for a 100 minutes contest. Anyway, I hope everyone found something interesting. \u003c/p\u003e\u003cp\u003eI would like to thank \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/lperovskaya\" title\u003d\"Эксперт lperovskaya\"\u003elperovskaya\u003c/a\u003e for organising this competition and managing Yandex.contest, \u003ca class\u003d\"rated-user user-black\" href\u003d\"/profile/snarknews\" title\u003d\"Не в рейтинге, snarknews\"\u003esnarknews\u003c/a\u003e and \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/sergeifedorov\" title\u003d\"Международный мастер sergeifedorov\"\u003esergeifedorov\u003c/a\u003e for their help with the problemset, \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/endagorion\" title\u003d\"Международный гроссмейстер endagorion\"\u003eendagorion\u003c/a\u003e, \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/PavelKunyavskiy\" title\u003d\"Международный гроссмейстер PavelKunyavskiy\"\u003ePavelKunyavskiy\u003c/a\u003e, \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/AleX\" title\u003d\"Гроссмейстер AleX\"\u003eAleX\u003c/a\u003e, \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/glebushka98\" title\u003d\"Кандидат в мастера glebushka98\"\u003eglebushka98\u003c/a\u003e, \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/gustokashin\" title\u003d\"Эксперт gustokashin\"\u003egustokashin\u003c/a\u003e, \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/map\" title\u003d\"Международный мастер map\"\u003emap\u003c/a\u003e and \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/boris\" title\u003d\"Эксперт boris\"\u003eboris\u003c/a\u003e for testing. Special thanks to \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/gassa\" title\u003d\"Кандидат в мастера gassa\"\u003egassa\u003c/a\u003e and my girlfriend Marina Kruglikova for fixing mistakes and disambiguations in English and Russian statements.\u003c/p\u003e\u003cp\u003eLet\u0027s get it started.\u003c/p\u003e\u003ch3\u003eProblem A. Odysseus Sails Home.\u003c/h3\u003e\u003cp\u003eThere is no tricky idea behind this problem: one just needs to check if the vector \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e can be represented as a convex combination of vectors \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e. One of the easiest approaches for the general case is to try all pairs of wind vectors and check if the target vector lies inside the cone they form. However, the devil is in the details. One shouldn\u0027t forget to:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eCheck if it\u0027s possible to get to Ithaca using only one wind direction;\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eSpecial if for case \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/sub\u003e) \u003d (\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e;\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIgnore wind vectors \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e) \u003d (0, 0)\u003c/span\u003e;\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eAvoid usage of doubles — everything fits in long long.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eTime complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e solution also exists.\u003c/p\u003e\u003ch3\u003eProblem B. Chariot Racing.\u003c/h3\u003e\u003cp\u003eFor the fixed value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e \u003d \u003ci\u003econst\u003c/i\u003e\u003c/span\u003e we can easily calculate the intersection of all segments (chariots) as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(0, \u003ci\u003emin\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e * \u003ci\u003et\u003c/i\u003e) - \u003ci\u003emax\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e * \u003ci\u003et\u003c/i\u003e))\u003c/span\u003e. The problem was to find maximum for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e ≥ 0\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eBoth \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e * \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e * \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e are convex functions. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e * \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e is concave upward, because it\u0027s derivative only decreases, as faster chariots overtake slower one. Similar \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e * \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e is convex down. This means function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e * \u003ci\u003et\u003c/i\u003e) - \u003ci\u003emax\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e * \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e is concave upward, and this, in turn is sufficient condition for applying ternary search.\u003c/p\u003e\u003cp\u003eTernary search is enough to solve the problem, but the solution which does binary search on derivative is faster and more stable. We need to find the maximum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e such that the chariot \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e with minimum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e * \u003ci\u003et\u003c/i\u003e\u003c/span\u003e goes faster then the chariot \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e with maximum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e * \u003ci\u003et\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe only special case (for some solutions only) was \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTime complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e·\u003ci\u003elogMaxC\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003eProblem C. Equality and Roads.\u003c/h3\u003e\u003cp\u003eFirst check if the graph is connected. If no, print \u0026lt;\u0026lt;\\t{NO}\u0026gt;\u0026gt; for all queries.\u003c/p\u003e\u003cp\u003eFor connected graph count the number of connected components if only 0-edges are allowed (denote it as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e) and the number of connected components if only 1-edges are allowed (denote it as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e). Then, for the given \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e it\u0027s possible to construct the desired span if and only if condition \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e - 1 ≤ \u003ci\u003ex\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e holds.\u003c/p\u003e\u003cp\u003eLets proof the above statement. It\u0027s pretty obvious that this condition is necessary, but the sufficiensy isn\u0027t that clear. In my opinion, the easiest way is to present the algorithm. It consists of five steps:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eCreate DSU, add all 1-edges.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eAdd all 0-edges, remember which of them caused joins. There will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e - 1\u003c/span\u003e such edges. \u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eClear the DSU, add all 0-edges remembered on step 2.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eAdd 0-edges until there are exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e of them in the current span.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eAdd 1-edges until the graphs becomes connected. That will always happen because of the step 1 and 2.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eTime complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003eProblem D. Sequences of Triangles.\u003c/h3\u003e\u003cp\u003eThanks to \u003ca class\u003d\"rated-user user-black\" href\u003d\"/profile/snarknews\" title\u003d\"Не в рейтинге, snarknews\"\u003esnarknews\u003c/a\u003e — the author and developer of this problem.\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e be the longest sequence that ends on the triangle with the hypotenuse of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. If we generate all Pithagorean triples with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e ≤ \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e the dynamic programming approach will be the one that is easy to implement here. \u003c/p\u003e\u003cp\u003eExhaustive description of the generation process and Euclid\u0027s formula could be found \u003ca href\u003d\"https://en.wikipedia.org/wiki/Pythagorean_triple\"\u003ehere\u003c/a\u003e, I would like to skip copying it to analysis.\u003c/p\u003e\u003ch3\u003eProblem E. Strong Squad.\u003c/h3\u003e\u003cp\u003eThanks to \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/sergeifedorov\" title\u003d\"Международный мастер sergeifedorov\"\u003esergeifedorov\u003c/a\u003e — the author of this problem.\u003c/p\u003e\u003cp\u003ePerimeter \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is equal to \u003cspan class\u003d\"tex-span\"\u003e2·(\u003ci\u003eh\u003c/i\u003e + \u003ci\u003ew\u003c/i\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e is the number of rows and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e is the number of columns in the resulting rectangle. Build a bipartite graph on rows and columns where there is an edge connecting row \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to column \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e if and only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esoldier\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e) \u003d 0\u003c/span\u003e. What we should find now is the maximum independent set, such that in both set of rows and set of columns there is a least one vertex chosen (we are not allowed to choose rectangles \u003cspan class\u003d\"tex-span\"\u003e0 × \u003ci\u003em\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e × 0\u003c/span\u003e). \u003c/p\u003e\u003cp\u003eThe [well-known fact](\u003ca\u003ehttps://en.wikipedia.org/wiki/K%C3%B6nig%27s_theorem_(graph_theory)\u003c/a\u003e) (yes, just say that the fact is well-known if you don\u0027t want to proove it) is that the size of the maximum independent subset in bipartite graph is equal to \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eV\u003c/i\u003e| + |\u003ci\u003eU\u003c/i\u003e| - ν(\u003ci\u003eG\u003c/i\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003eν(\u003ci\u003eG\u003c/i\u003e)\u003c/span\u003e stands for the maximum matching. To meet the condition that there should be at least one vertex chosen in both parts we should:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eTry all the available pairs;\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eExclude vertices already connected to chosen pair;\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eFind maximum matching.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eTime complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003enm\u003c/i\u003e)\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e·\u003ci\u003emin\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e))\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e)\u003c/span\u003e for the worst case \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d \u003ci\u003em\u003c/i\u003e\u003c/span\u003e. Is reduced to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e4.5\u003c/sup\u003e)\u003c/span\u003e by using Dinic\u0027s algorithm.\u003c/p\u003e\u003cp\u003eAbout Time Limit: though for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d \u003ci\u003em\u003c/i\u003e \u003d 100\u003c/span\u003e the number of operations will be about \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e·10\u003csup class\u003d\"upper-index\"\u003e10\u003c/sup\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e seems to be pretty small. We can show that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/74/8d/748d6e0bf971b9e48c0338eb1325a66df2b2e27f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e comes from the fact that the worst case is then only half of the cells is filled with zeroes. Also at least \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/06/47/06479cd23d60c92802b763b2307abea3d29db615.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e comes from the Kuhn\u0027s algorithm itself. The actual timing for the most straightforward Kuhn was about 2.5 from 5 seconds TL. Any optimisations sped it up to less than 1 second.\u003c/p\u003e\u003ch3\u003eProblem F. Lexicographically Smallest String.\u003c/h3\u003e\u003cp\u003eWe want to pick up two indices and revert corresponding substring to make the resulting string as small as possible. To start with let\u0027s reduce a degree of freedom from 2 to 1.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eStatement 1.\u003c/strong\u003e If we represent string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u003d \u003ci\u003ec\u003c/i\u003e + \u003ci\u003eS\u003c/i\u003e\u0027\u003c/span\u003e and character \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e is not greater than any character in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u0027\u003c/span\u003e, than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAnswer\u003c/i\u003e(\u003ci\u003eS\u003c/i\u003e) \u003d \u003ci\u003ec\u003c/i\u003e + \u003ci\u003eAnswer\u003c/i\u003e(\u003ci\u003eS\u003c/i\u003e\u0027)\u003c/span\u003e. Otherwise, the answer always reverts some prefix.\u003c/p\u003e\u003cp\u003eProof. Assume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAnswer\u003c/i\u003e(\u003ci\u003eS\u003c/i\u003e) \u0026lt; \u003ci\u003ec\u003c/i\u003e + \u003ci\u003eAnswer\u003c/i\u003e(\u003ci\u003eS\u003c/i\u003e\u0027)\u003c/span\u003e, that means we should revert some prefix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e, i.e. some substring \u003cspan class\u003d\"tex-span\"\u003e(1, \u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e. If we revert substring \u003cspan class\u003d\"tex-span\"\u003e(2, \u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e, the length of the prefix that consists of only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e will increase, and the result will become lexicographically smaller. Assumption is incorrect. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e is greater than some character os \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u0027\u003c/span\u003e it\u0027s obvious we should revert some prefix that ends at position with the smallest possible character.\u003c/p\u003e\u003cp\u003eNow we need to solve the following task: revert some prefix of the string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e to make it as small as possible. First, we need to take a look at string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e and it\u0027s suffixes. We will call two suffixes \u003cem\u003estrongly comparable\u003c/em\u003e if none of them is a prefix of another. Similary, we will say that one suffix is \u003cem\u003estrongly lesser\u003c/em\u003e or \u003cem\u003estrongly greater\u003c/em\u003e than another, if they are strongly comparable and the corresponding inequality holds for classiс comparison.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eStatement 2.\u003c/strong\u003e If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u003d \u003ci\u003eA\u003c/i\u003e + \u003ci\u003eB\u003c/i\u003e \u003d \u003ci\u003eC\u003c/i\u003e + \u003ci\u003eD\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e is strictly lesser than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e + \u003ci\u003eB\u003c/i\u003e\u003c/span\u003e is stricly lesser than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e + \u003ci\u003eD\u003c/i\u003e\u003c/span\u003e. Proof: obvious.\u003c/p\u003e\u003cp\u003eFrom statement 2 it follows that we should only consider suffixes of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e that are greater than any other suffix they are strictly comparable to. From definition of strict comparison it comes out all the remaining suffixes are prefixes of the longest one remaining. We can try to revert them all and choose the best, but this may be too slow. \u003c/p\u003e\u003cp\u003eFrom the string theory and prefix-function algorithm we know, that if the longest suffix of the string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u0027\u003c/span\u003e that is equal to it\u0027s prefix has length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u0027 \u003d \u003ci\u003ew\u003c/i\u003e + \u003ci\u003ew\u003c/i\u003e + ... + \u003ci\u003ew\u003c/i\u003e + \u003ci\u003ew\u003c/i\u003e\u0027\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u0027\u003c/span\u003e is prefix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e has length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003el\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eStatement 3.\u003c/strong\u003e If we present the longest suffix \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u0027\u003c/span\u003e that is not majorated by any other suffix in the above form, than the set of other not majorated suffixes will be equal to the set of suffixes of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u0027\u003c/span\u003e that have the form \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e + \u003ci\u003ew\u003c/i\u003e + ... + \u003ci\u003ew\u003c/i\u003e + \u003ci\u003ew\u003c/i\u003e\u0027\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eProof. If the string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e is not prime, than there exists some suffix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u0027\u003c/span\u003e of length more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - |\u003ci\u003ew\u003c/i\u003e|\u003c/span\u003e that is not striclty lesser than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u0027\u003c/span\u003e, but this contradicts to the way we found \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e. That means the string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e is prime and only suffixes of form \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e + \u003ci\u003ew\u003c/i\u003e + ... + \u003ci\u003ew\u003c/i\u003e + \u003ci\u003ew\u003c/i\u003e\u0027\u003c/span\u003e are not strictly comparable to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u0027\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eStatement 4.\u003c/strong\u003e If \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eA\u003c/i\u003e| \u003d |\u003ci\u003eB\u003c/i\u003e|\u003c/span\u003e then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e + \u003ci\u003eA\u003c/i\u003e + \u003ci\u003eC\u003c/i\u003e \u0026lt; \u003ci\u003eA\u003c/i\u003e + \u003ci\u003eC\u003c/i\u003e + \u003ci\u003eB\u003c/i\u003e \u0026lt; \u003ci\u003eC\u003c/i\u003e + \u003ci\u003eB\u003c/i\u003e + \u003ci\u003eB\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e + \u003ci\u003eA\u003c/i\u003e + \u003ci\u003eC\u003c/i\u003e \u0026gt; \u003ci\u003eA\u003c/i\u003e + \u003ci\u003eC\u003c/i\u003e + \u003ci\u003eB\u003c/i\u003e \u0026gt; \u003ci\u003eC\u003c/i\u003e + \u003ci\u003eB\u003c/i\u003e + \u003ci\u003eB\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e + \u003ci\u003eA\u003c/i\u003e + \u003ci\u003eC\u003c/i\u003e \u003d \u003ci\u003eA\u003c/i\u003e + \u003ci\u003eC\u003c/i\u003e + \u003ci\u003eB\u003c/i\u003e \u003d \u003ci\u003eC\u003c/i\u003e + \u003ci\u003eB\u003c/i\u003e + \u003ci\u003eB\u003c/i\u003e\u003c/span\u003e for any string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eProof. Compare strings \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e + \u003ci\u003eC\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e + \u003ci\u003eB\u003c/i\u003e\u003c/span\u003e. The result of this comparison will determine the case, as we could always change \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e + \u003ci\u003eC\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e + \u003ci\u003eB\u003c/i\u003e\u003c/span\u003e or vice versa.\u003c/p\u003e\u003cp\u003eApplying the statement 4 to the case where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e \u003d \u003ci\u003ew\u003c/i\u003e\u0027, \u003ci\u003eA\u003c/i\u003e \u003d \u003ci\u003ew\u003c/i\u003e, \u003ci\u003eB\u003c/i\u003e \u003d \u003ci\u003ew\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e we conclude that we should only try to revert the longest and the shorest prefix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e such that corresponding suffixes of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e are not strongly greater than any other suffix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTo find those suffixes of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e one should perform Duval\u0027s algorithm to find Lindon decomposition of the string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. We are interested in the last prime string in the decomposition and the last pre-prime string in algorithm\u0027s workflow (or the last prime for the string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e + #\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e#\u003c/span\u003e is some character striclty smaller than any other character in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e as was mentioned in comments by \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Al.Cash\" title\u003d\"Гроссмейстер Al.Cash\"\u003eAl.Cash\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eTime complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003eS\u003c/i\u003e|)\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e","tags":["yandex.algorithm","analysis"]}}