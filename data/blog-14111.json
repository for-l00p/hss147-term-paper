{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1412419264,"rating":48,"authorHandle":"Aksenov239","modificationTimeSeconds":1412433070,"id":14111,"title":"\u003cp\u003eRussian Code Cup 2014 Final — Разбор задач\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eUPD:\u003c/strong\u003eТакже специально для финала мы выпустили \u003ca href\u003d\"http://www.youtube.com/playlist?list\u003dPLyQCF5K78w9_QRbUZHLsEeEe9RhJLu6ib\"\u003eвидео-разбор\u003c/a\u003e.\u003c/p\u003e \u003cdiv\u003e    \u003ch2\u003eЗадача A. Игра\u003c/h2\u003e     \u003cb\u003eИдея:\u003c/b\u003e Анна Малова\u003cbr /\u003e     \u003cb\u003eРеализация:\u003c/b\u003e Анна Малова\u003cbr /\u003e     \u003cb\u003eРазбор:\u003c/b\u003e Анна Малова\u003cbr /\u003e     \u003cp\u003e      Рассмотрим двудольный граф — первая команда, вторая команда. На ребре написано, какими подсказками владеет участник второй команды, которые еще не знает участник первой, то есть разность множеств подсказок участников.     Оставим только те ребра, на которых записано одно число. Среди таких ребер оставим только те, на которых записано только одно число.      \u003c/p\u003e     \u003cp\u003e     Используя построенный граф, составим другой двудольный граф: вершинами первой доли являются участники первой команды, вершины второй доли — те подсказки, которые еще неизвестны первой команде.     Между двумя вершинами есть ребро, если было ребро в предыдущем двудольном графе, выходящее из той же вершины, на котором была записана эта информация.     Если в полученном графе найдётся максимальное паросочетание, значит, первая команда может выиграть. Иначе, первая команда выиграть не может.     \u003c/p\u003e     \u003cp\u003e     Чтобы уложиться в заданные ограничения по времени, для нахождения разности множеств, нужно использовать битсет. Кроме этого, перед запуском алгоритма Куна для поиска максимального паросочетания,     нужно сравнить размеры долей, если размер доли с подсказками превышает размер доли участников, то сразу выдается ответ 2. Без этой проверки, решение не укладывается в ограничения по времени.     \u003c/p\u003e     \u003ch2\u003eЗадача B. Покраска здания.\u003c/h2\u003e     \u003cb\u003eИдея:\u003c/b\u003e Виталий Аксёнов.\u003cbr /\u003e     \u003cb\u003eРеализация:\u003c/b\u003e Николай Ведерников.\u003cbr /\u003e     \u003cb\u003eРазбор:\u003c/b\u003e Николай Ведерников.\u003cbr /\u003e     \u003cp\u003e      В задаче требовалось покрасить полоску в два цвета. Мы умеем красить любой подотрезок в какой-то цвет.       Требовалось посчитать количество способов раскрасить полоску за минимальное число покрасок.     \u003c/p\u003e     \u003cp\u003e      В данной задаче есть два случая: концы полоски покрашены в один цвет или в разные. Рассмотрим первый случай.     \u003c/p\u003e     \u003cp\u003e      Концы покрашены в один цвет, значит, всего отрезков 2\u003ci\u003ek\u003c/i\u003e + 1.       Покажем сколько минимум покрасок надо. Рассмотрим конечную раскраску полоски, если последним отрезком мы покрасили отрезок в середине,      то общее количество отрезков увеличилось на два (мы разбили какой-то отрезок на два и добавили новый). Таким способом мы можем извлечь       \u003ci\u003ek\u003c/i\u003e отрезков и в конце останется 1. Итого мы потратили \u003ci\u003ek\u003c/i\u003e + 1 ходов. Если в какой-то момент мы взяли отрезок не из середины, а с края,      мы потратим больше ходов, чем надо.     \u003c/p\u003e     \u003cp\u003e      Теперь посчитаем количество способов. Рассмотрим конечную раскраску и последним ходом мы красили отрезок в середине, тогда количество способов      выбрать этот отрезок равно общему число отрезков минус крайние, итого 2\u003ci\u003ek\u003c/i\u003e — 1. Тем самым мы свели задачу к задаче меньшего размером.      Продолжая таким способом, мы получим итоговый ответ (2\u003ci\u003ek\u003c/i\u003e — 1) · (2\u003ci\u003ek\u003c/i\u003e — 3) · ... · 3 · 1, что равно (2\u003ci\u003ek\u003c/i\u003e — 1)!!.      \u003c/p\u003e          \u003cp\u003e      Рассмотрим случай, в котором концы покрашены в разные цвета, тогда всего отрезков 2\u003ci\u003ek\u003c/i\u003e.      Рассмотрим конечную раскраску полоски. Пусть в начале мы \u003ci\u003el\u003c/i\u003e раз извлекали отрезки из середины, а потом извлекли отрезок с краю. Тогда мы       потратили \u003ci\u003el\u003c/i\u003e + 1 и у нас осталось 2\u003ci\u003ek\u003c/i\u003e-2\u003ci\u003el\u003c/i\u003e-1 отрезоков, причём концы оказались одинакового цвета. По предыдущим рассуждениям мы не сможем раскрасить это      быстрее, чем за \u003ci\u003ek\u003c/i\u003e-\u003ci\u003el\u003c/i\u003e. Итого: \u003ci\u003ek\u003c/i\u003e+1 ходов* Кроме того, отсюда следуют факт, что мы первым ходом красим, отрезок с одного из концов.     \u003c/p\u003e          \u003cp\u003e      Теперь посчитаем количество способов. Назовём первый отрезок черным.      Пусть первым ходом мы покрасили отрезок с левого края. Переберем докуда он покрасит, а всё что справа от него надо будет покрасить в белый, по нашим рассуждениям.      Заметим, что теперь у нас получились две предыдущие задачи, у которых концы покрашены в один цвет. Пусть в левом отрезке \u003ci\u003el\u003c/i\u003e черных отрезков, тогда      ответ на этом отрезке будет ((2\u003ci\u003el\u003c/i\u003e — 1) — 2)!!, а на правом ((2\u003ci\u003ek\u003c/i\u003e — (2\u003ci\u003el\u003c/i\u003e — 1)) — 2 )!!. Кроме того, мы можем можем красить отрезки из левой половины и       из правой в любом порядке. То есть произведение отрезков надо ещё умножить на \u003ci\u003echoose\u003c/i\u003e (\u003ci\u003el\u003c/i\u003e — 1, \u003ci\u003ek\u003c/i\u003e),       так как мы уже один отрезок покрасили, значит нам осталось сделать ещё \u003ci\u003ek\u003c/i\u003e покрасок, а в левой осталось сделать \u003ci\u003el\u003c/i\u003e — 1 покрасок. Кроме того, первый отрезок       мы могли красить и дальше, потому что мы поверх всё равно покрасим правым отрезком. А таких вариантов равно длина правой части.      Итого, для фиксированого числа \u003ci\u003el\u003c/i\u003e ответ будет равен ((\u003ci\u003el\u003c/i\u003e — 3)!!) · ((2\u003ci\u003ek\u003c/i\u003e — 2\u003ci\u003el\u003c/i\u003e -1)!!) · \u003ci\u003echoose\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e — 1, \u003ci\u003ek\u003c/i\u003e) · (suff_len\u003csub\u003el\u003c/sub\u003e).      Таким образом переберем \u003ci\u003el\u003c/i\u003e и просуммируем. Аналогично посчитаем для другого конца.      \u003c/p\u003e     \u003cp\u003e         Если предподсчитать факториалы и обратные факториалы по модулю, то для одного \u003ci\u003el\u003c/i\u003e мы сможем отвечать за \u003ci\u003eO\u003c/i\u003e(1).          Итоговое время работы — \u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e).     \u003c/p\u003e                                   \u003ch2\u003eЗадача C. Задача о рюкзаке\u003c/h2\u003e     \u003cb\u003eИдея:\u003c/b\u003e Борис Минаев\u003cbr /\u003e     \u003cb\u003eРеализация:\u003c/b\u003e Артем Васильев\u003cbr /\u003e     \u003cb\u003eРазбор:\u003c/b\u003e Артем Васильев\u003cbr /\u003e     \u003cp\u003e      В данной задаче требуется найти такой тест для задачи о рюкзаке, что количество способов набрать вес \u003ci\u003eW\u003c/i\u003e делится на число \u003ci\u003eM\u003c/i\u003e.     \u003c/p\u003e     \u003cp\u003e      Далее будем считать \u003ci\u003eW\u003c/i\u003e равным 500.      Основная конструкция авторского решения основывается на генерации такого набора \u003ci\u003en\u003c/i\u003e вещей небольшого веса так, чтобы их сумма была меньше      \u003ci\u003eW\u003c/i\u003e/2. Подсчитаем для этого набора количество способов набрать подмножество вещей с суммарным весом \u003ci\u003ek\u003c/i\u003e для всех \u003ci\u003ek\u003c/i\u003e от 0 до \u003ci\u003eW\u003c/i\u003e/2      и обозначим это число за \u003ci\u003ec\u003csub\u003ek\u003c/sub\u003e\u003c/i\u003e. Потребуем, чтобы для нашего набора любое число от 1 до 10\u003csup\u003e18\u003c/sup\u003e представлялось как сумма не более,      чем 200 — \u003ci\u003en\u003c/i\u003e чисел \u003ci\u003ec\u003csub\u003ek\u003c/sub\u003e\u003c/i\u003e.     \u003c/p\u003e     \u003cp\u003e      Предположим, что существует такой набор вещей, чтобы для каждого \u003ci\u003ex\u003c/i\u003e было такое \u003ci\u003ek\u003c/i\u003e,       что \u003ci\u003ec\u003csub\u003ek\u003c/sub\u003e\u003c/i\u003e \u003d 2\u003ci\u003e\u003csup\u003ex\u003c/sup\u003e\u003c/i\u003e, то такое свойство было бы очевидно: для каждого \u003ci\u003ex\u003c/i\u003e, если двоичная запись \u003ci\u003eM\u003c/i\u003e содержит      единицу на позиции \u003ci\u003ex\u003c/i\u003e, мы добавим вещь с весом \u003ci\u003eW\u003c/i\u003e — \u003ci\u003ex\u003c/i\u003e в наш набор. Поскольку сумма вещей, добавленных до этого шага, была меньше \u003ci\u003eW\u003c/i\u003e/2,      то легко видеть, что количество способов получить вес \u003ci\u003eW\u003c/i\u003e равно \u003ci\u003eM\u003c/i\u003e.       Заметим, что такой процесс можно описать следующим жадным алгоритмом: пока \u003ci\u003eM\u003c/i\u003e больше нуля, мы находим максимальное \u003ci\u003ec\u003csub\u003ek\u003c/sub\u003e\u003c/i\u003e ≤ \u003ci\u003eM\u003c/i\u003e,      добавляем вещь с весом \u003ci\u003eW\u003c/i\u003e — \u003ci\u003ek\u003c/i\u003e и вычитаем из \u003ci\u003eM\u003c/i\u003e число \u003ci\u003ec\u003csub\u003ek\u003c/sub\u003e\u003c/i\u003e.     \u003c/p\u003e     \u003cp\u003e      К сожалению, такой набор вещей получить трудно, поэтому необходимо придумать какой-то другой набор вещей, обладающий тем свойством, что вышеописанный жадный алгоритм      находит решение для любого  \u003ci\u003eM\u003c/i\u003e. Для этого возьмем набор вещей со случайным небольшим весом и суммой меньше \u003ci\u003eW\u003c/i\u003e/2.       Можно проверить и убедиться, что если мы выберем наш набор таким образом и посчитаем для него числа \u003ci\u003ec\u003csub\u003ek\u003c/sub\u003e\u003c/i\u003e, то жадный алгоритм с большой вероятностью      вернет корректное разбиение любого числа \u003ci\u003eM\u003c/i\u003e на слагаемые \u003ci\u003ec\u003csub\u003ek\u003c/sub\u003e\u003c/i\u003e. Таким образом можно построить набор вещей, удовлетворяющий этому свойству, и с помощью      жадного алгоритма добавить вещей таким образом, чтобы количество способов собрать \u003ci\u003eW\u003c/i\u003e стало равным 0 по модулю \u003ci\u003eM\u003c/i\u003e.     \u003c/p\u003e                                   \u003ch2\u003eЗадача D. Организация сети.\u003c/h2\u003e     \u003cb\u003eИдея:\u003c/b\u003e Борис Минаев \u003cbr /\u003e     \u003cb\u003eРеализация:\u003c/b\u003e Андрей Комаров \u003cbr /\u003e     \u003cb\u003eРазбор:\u003c/b\u003e Андрей Комаров \u003cbr /\u003e          \u003cp\u003e       В задаче было дано дерево и требовалось пометить минимально       возможное число вершин так, чтобы вектора расстояний от каждой       вершины до выбранных были различны.     \u003c/p\u003e          \u003cp\u003e       Рассмотрим отдельно случай, когда заданное дерево является       \u003ci\u003eцепочкой\u003c/i\u003e: вершины можно упорядочить так, что первая связана       только со второй, последняя только с предпоследней, а остальные       только с двумя соседями. Если дерево является цепочкой, то,       очевидно, в качестве ответа можно взять один из концов этой цепочки:       все вершины будут удалены от него на различные расстояния.     \u003c/p\u003e          \u003cp\u003e       Иначе, в дереве есть вершина степени больше двух. Подвесим дерево       за эту вершину. Посчитаем следующую динамику для каждого поддерева:       минимальное число меток, которое необходимо поставить в этом       поддереве, чтобы вектора расстояний для каждой пары вершин этого       поддерева были различны, при условии, что где-то выше корня       поддерева есть хотя бы одна помеченная вершина. Назовём значение       этой динамики \u003ci\u003emin↑\u003c/i\u003e. Заметим, что это не совсем то, что       нужно посчитать в задаче, но это совпадёт с задачей, если убрать       ограничение на существование выше корня помеченной вершины. Назовём       эту динамику \u003ci\u003emin\u003c/i\u003e. Заметим,       что \u003ci\u003emin↑\u003c/i\u003e ≤ \u003ci\u003emin\u003c/i\u003e. Значит, если мы       сможем предъявить ответ размера ровно \u003ci\u003emin↑\u003c/i\u003e, то это будет       ответом на задачу. Решим задачу в два       этапа — сначала посчитаем значения \u003ci\u003emin↑\u003c/i\u003e,       а затем получим ответ такого размера.     \u003c/p\u003e          \u003cp\u003e       Пусть мы хотим посчитать \u003ci\u003emin↑\u003c/i\u003e для какой-то       вершины \u003ci\u003ev\u003c/i\u003e. Посчитаем эти значения для её поддеревьев.       Получили, что в некоторых из них есть хотя бы одна метка, а в       остальных меток нет. Пусть количество поддеревьев, в которых меток нет, равно \u003ci\u003ek\u003c/i\u003e. Тогда       в ответ для \u003ci\u003ev\u003c/i\u003e нужно добавить хотя       бы \u003ci\u003ek\u003c/i\u003e − 1 помеченную вершину (по одной в       каждое непомеченное поддерево, кроме одного). Пусть мы добавили       меньше. Тогда осталось хотя бы два непомеченных поддерева. Тогда       корни этих поддеревьев будут неразличимы: в их поддеревьях       помеченных вершин нет, а до всех остальных расстояния одинаковы.       Теперь покажем, что этих добавлений хватит. Рассмотрим любые две       вершины из разных поддеревьев. Они могут быть либо на одинаковой,       либо на разной глубине. Пусть они на разной глубине. Тогда       расстояния от них до предполагаемой помеченной вершины над корнем       различны (различны длины путей до корня). Пусть они на одинаковой       глубине. Тогда, по построению, хотя бы в одном из поддеревьев, в       которых эти вершины лежат, есть помеченная вершина. Тогда расстояния       до неё от этих двух выбранных вершин будут различны: от той, из       чьего поддерева выбранна помеченная вершина, расстояние будет       меньше.      \u003c/p\u003e          \u003cp\u003e       Построим теперь ответ размера \u003ci\u003emin↑\u003c/i\u003e. У выбранного нами       корня хотя бы три ребёнка. Значит, по построению \u003ci\u003emin↑\u003c/i\u003e,       хотя бы в двух поддеревьях корня есть помеченная вершина. Значит,       для каждого поддерева есть помеченная вершина вне этого поддерева.       Возьмём её в качестве требуемой \u003ci\u003emin↑\u003c/i\u003e помеченной вершины       выше. Тогда ответом будет являться объединение ответов \u003ci\u003emin↑\u003c/i\u003e для всех       детей корня.     \u003c/p\u003e          \u003cp\u003e       Все рассмотренные операции можно сделать с помощью одного обхода в       глубину. Значит, итоговое время       работы — \u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e).     \u003c/p\u003e          \u003ch2\u003eЗадача E. Булево дерево\u003c/h2\u003e     \u003cb\u003eИдея:\u003c/b\u003e Борис Минаев\u003cbr /\u003e     \u003cb\u003eРеализация:\u003c/b\u003e Демид Кучеренко\u003cbr /\u003e     \u003cb\u003eРазбор:\u003c/b\u003e Виталик Аксёнов\u003cbr /\u003e     \u003cp\u003e      Для начала сведём нашу задачу к задаче об одной переменной. Заведём по дереву на каждую переменную, в которых в изначальном состоянии будут находиться корень изначального дерева и ссылка на него.     Ссылка в дереве у нас всегда будет указывать на вершину, в чьём поддереве мы сейчас находимся.     Обойдём наше дерево обходом в глубину. Если мы заходим в вершину, в которой выставлена какая-то переменная, то мы создаём у вершины в соответствующем дереве нового ребёнка и переставляем ссылку на него.     Если мы выходим из вершины, то мы переставляем ссылку в соответствующем дереве на её предка     Мы сжали деревья. Нужно ещё не забыть хранить в каждой вершине количество листьев в её поддереве     \u003c/p\u003e     \u003cp\u003e     Мы теперь будем решать задачу на дереве для одной переменной. Будем обрабатывать все запросы на данную переменную последовательно. Нам нужно уметь делать две вещи:     \u003c/p\u003e\u003cul\u003e     \u003cli\u003eна сколько листьев влияет только эта вершина\u003c/li\u003e     \u003cli\u003eнайти ближайшего предка, в котором выставлено какое-то значение для данной переменной.\u003c/li\u003e     \u003c/ul\u003e     Если мы реализуем это, обрабатывать запрос не очень сложно:     \u003cul\u003e     \u003cli\u003eнаходим количество листьев, на которые влияет эта вершина — \u003ci\u003ex\u003c/i\u003e;\u003c/li\u003e     \u003cli\u003eнаходим ближайшего предка, в котором выставлено какое-то значение для данной переменной — \u003ci\u003ep\u003c/i\u003e;\u003c/li\u003e     \u003cli\u003eесли в \u003ci\u003ep\u003c/i\u003e такое же значение, что и в нашей вершине, то количество не меняется;\u003c/li\u003e     \u003cli\u003eесли в \u003ci\u003ep\u003c/i\u003e другое значение, нежели в нашей вершине, то количество меняется на \u003ci\u003ex\u003c/i\u003e;\u003c/li\u003e     \u003cli\u003eесли \u003ci\u003ep\u003c/i\u003e не существует, то количество меняется на \u003ci\u003ex\u003c/i\u003e* то количество “неизвестных” листьев уменьшается на \u003ci\u003ex\u003c/i\u003e;\u003c/li\u003e     \u003cli\u003eв \u003ci\u003ep\u003c/i\u003e нужно уменьшить количество влияемых листьев на \u003ci\u003ex\u003c/i\u003e\u003c/li\u003e     \u003c/ul\u003e          \u003cp\u003e     Чтобы реализовать запросы нужно развернуть дерево в дерево отрезков, где можно делать запрос на поддереве.     Тогда запросы первого вида очень легко обрабатывать с помощью суммы в поддереве.     Для поиска правильного предка сделаем следующее: когда делаем запрос в вершину, мы прибавляем ко всем вершинам в поддереве, кроме неё,     единицу, то есть говорим, что они покрыты ещё одной вершиной. Тогда чтобы найти предка, мы будем искать двоичным подъёмом первую позицию,     в которой значение отличается на единицу — она и будет искомым предком.     \u003c/p\u003e     \u003cp\u003e     Итоговое время работы: \u003ci\u003eO\u003c/i\u003e(\u003ci\u003em\u003c/i\u003elog\u003csup\u003e2\u003c/sup\u003e\u003ci\u003en\u003c/i\u003e), где \u003ci\u003en\u003c/i\u003e — размер дерева, \u003ci\u003em\u003c/i\u003e — количество запросов.     \u003c/p\u003e     \u003ch2\u003eЗадача F. Робот.\u003c/h2\u003e     \u003cb\u003eИдея:\u003c/b\u003e Борис Минаев \u003cbr /\u003e     \u003cb\u003eРеализация:\u003c/b\u003e Борис Минаев \u003cbr /\u003e     \u003cb\u003eРазбор:\u003c/b\u003e Борис Минаев \u003cbr /\u003e     \u003cp\u003e       В задаче необходимо было посчитать количество клеток, которые достижимы из первой строки поля.        Основная сложность заключается в том, что размеры каждой стороны поля могут достигать       10\u003csup\u003e9\u003c/sup\u003e клеток.     \u003c/p\u003e          \u003cp\u003e       Во-первых, из-за того, что робот совершает ходы по диагонали, удобно отдельно        рассматривать клетки разной чётности. Робот может достичь все клетки первой строки       поля. Будем увеличивать \u003ci\u003ey\u003c/i\u003e и пересчитывать достижимые клетки. Удобнее всего        хранить множество достижимых клеток для строки в виде объединения непересекающихся        отрезков. Тогда можно легко пересчитывать множество при переходе к следующей строке.       А именно, к каждому отрезку добавится по одной клетке с каждой стороны. Некоторые отрезки,       возможно, объединятся в один, а некоторые пересекутся с границами поля или преградами.      \u003c/p\u003e       \u003cp\u003e       Научимся эффективно изменять это множество отрезков. Лучше всего хранить его в структуре       данных, которая позволяет за \u003ci\u003eO\u003c/i\u003e(log\u003ci\u003en\u003c/i\u003e) находить отрезок, который        пересекает заданную координату. Дополнительно, у каждого отрезка будем хранить информацию        о том, может ли отрезок увеличится влево и вправо. Давайте аккуратно рассмотрим все        события, которые могут происходить:     \u003c/p\u003e     \u003cp\u003e       \u003c/p\u003e\u003cul\u003e       \u003cli\u003e         Два отрезка объединились. Это самый простой случай. Необходимо просто объединить их в         структуре данных.       \u003c/li\u003e       \u003cli\u003e         Отрезок расширился до такой степени, что пересекся с краем поля или преградой. Тогда         необходимо поставить пометку в описании отрезка, что он не может больше расти в некоторую сторону.       \u003c/li\u003e       \u003cli\u003e         Началась преграда. Необходимо рассмотреть все отрезки, которые пересекаются с          преградой. Некоторые из них нужно полностью удалить, некоторые обрезать, а некоторые         разделить на две части. Также необходимо создать события, которые произойдут, когда         соседние отрезки разрастутся настолько, что пересекут текущую преграду.       \u003c/li\u003e       \u003cli\u003e         Преграда закончилась. Необходимо найти два соседних отрезка и поставить им пометку         о том, что они могут расти в направлении прямоугольника. Также необходимо добавить         событие, которое должно произойти между соседями. Например, если два соседа являются         отрезками, то они могут в некоторый момент объединиться. Если один из них отрезок, а         другой — преграда, то они могут пересечься. В остальных случаях ничего добавлять не надо.       \u003c/li\u003e       \u003c/ul\u003e          \u003cp\u003e       Также заметим, что все отрезки необходимо хранить лениво. То есть изменять их размер,       а также пересчитывать общее количество достижимых клеток, необходимо только тогда, когда        происходит некоторое событие, которое затрагивает данный отрезок.     \u003c/p\u003e     \u003cp\u003e       Время работы решения — \u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e log (\u003ci\u003en\u003c/i\u003e)),        где \u003ci\u003en\u003c/i\u003e — общее число преград.      \u003c/p\u003e  \u003c/div\u003e\u003c/div\u003e","tags":["rcc2014","final"]}}