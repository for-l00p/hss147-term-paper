{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1498178344,"rating":0,"authorHandle":"SAeed","modificationTimeSeconds":1498178642,"id":52835,"title":"\u003cp\u003eSPU Contest #12\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e \u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214236/problem/Blue\"\u003eBlue — The Text Splitting\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eAdHoc\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThis problem is solved exactly the same way that \u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214145/problem/Purple\"\u003ethis\u003c/a\u003e is solved. The only change here is that this idea is applied to a string\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\n\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\n\t\n\tint n, p, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p \u0026gt;\u0026gt; q;\n\tstring s; cin \u0026gt;\u0026gt; s;\n\tint x \u003d -1, y \u003d -1;\n\tfor (int i \u003d 0; i * p \u0026lt;\u003d n; i++){\n\t\tint j \u003d n - i * p;\n\t\tif (j % q \u003d\u003d 0){\n\t\t\tx \u003d i, y \u003d j / q;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (x \u003d\u003d -1) return cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl, 0;\n\tcout \u0026lt;\u0026lt; x + y \u0026lt;\u0026lt; endl;\n\tfor (int k \u003d 0; k \u0026lt; n; k++){\n\t\tif (x){\n\t\t\tfor (int i \u003d 0; i \u0026lt; p; i++) cout \u0026lt;\u0026lt; s[k], k++;\n\t\t\tk--;\n\t\t\tx--;\n\t\t\tcout \u0026lt;\u0026lt; endl;\n\t\t}\n\t\telse{\n\t\t\tfor (int i \u003d 0; i \u0026lt; q; i++) cout \u0026lt;\u0026lt; s[k], k++;\n\t\t\tk--;\n\t\t\tcout \u0026lt;\u0026lt; endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214236/problem/Green\"\u003eGreen — Learning Languages\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eDFS\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eIf we created a graph, where each node represents either a language or a person. Each connected component means that the group a people within this connected component can talk to each other (directly or through a number of translators). What do we need to do? we need to make all the people all to talk to each other. We will just make someone from the first component learn a language from the second component, and someone from the second component to learn a language from the third component, and so on. So, the answer is the number of connected components — 1.\u003c/p\u003e\u003cp\u003eHowever, one special case is that of no one knows any languages the answer is \u003ccode\u003en\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n + m)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nvector\u0026lt;int\u0026gt; G[222];\nint shift \u003d 111;\nint vis[222];\nvoid dfs(int node){\n\tvis[node] \u003d 1;\n\tfor (int i \u003d 0; i \u0026lt; G[node].size(); i++){\n\t\tint nxt \u003d G[node][i];\n\t\tif (vis[nxt]) continue;\n\t\tdfs(nxt);\n\t}\n}\n\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\t\n\tint n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tint noLanguages \u003d 1;\n\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\tint k; cin \u0026gt;\u0026gt; k;\n\t\tfor (int j \u003d 0; j \u0026lt; k; j++){\n\t\t\tnoLanguages \u003d 0;\n\t\t\tint a; cin \u0026gt;\u0026gt; a;\n\t\t\tG[i].push_back(a + shift);\n\t\t\tG[a + shift].push_back(i);\n\t\t}\n\t}\n\tif (noLanguages) return cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl, 0;\n\tint ans \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\tif (vis[i]) continue;\n\t\tans++;\n\t\tdfs(i);\n\t}\n\tcout \u0026lt;\u0026lt; ans - 1 \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214236/problem/Purple\"\u003ePurple — Again Twenty Five!\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eBrute Force\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eAny power of 25 ends with 25 !!\u003c/p\u003e\u003cp\u003eOr if you didn\u0027t notice this observation you can simply the \u003ccode\u003epower\u003c/code\u003e function I gave you with \u003ccode\u003eMOD \u003d 100\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(1)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\t\n\tcout \u0026lt;\u0026lt; 25 \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214236/problem/Red\"\u003eRed — Robot Sequence\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eBrute Force\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSince the length of the string is at most 200, we can solve this problem with a simple brute force solution where we just check every substring.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(n)\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\t\n\tint n; cin \u0026gt;\u0026gt; n;\n\tstring s; cin \u0026gt;\u0026gt; s;\n\tint ans \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\tint upDown \u003d 0, leftRight \u003d 0;\n\t\tfor (int j \u003d i; j \u0026lt; n; j++){\n\t\t\tif (s[j] \u003d\u003d \u0027U\u0027) upDown++;\n\t\t\telse if (s[j] \u003d\u003d \u0027D\u0027) upDown--;\n\t\t\telse if (s[j] \u003d\u003d \u0027L\u0027) leftRight++;\n\t\t\telse leftRight--;\n\t\t\tif (upDown \u003d\u003d 0 \u0026amp;\u0026amp; leftRight \u003d\u003d 0) ans++;\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/group/jinQE9BhKP/contest/214236/problem/Yellow\"\u003eYellow — XOR Equation\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eDP\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe number of binary digits of 10^12 is actually only 40. Create the following DP solution:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDP[\u003c/strong\u003e current bit \u003cstrong\u003e][\u003c/strong\u003e do we have a carry from the sum operation or not \u003cstrong\u003e]\u003c/strong\u003e\u003c/p\u003e\u003cp\u003ein each step try to put a zero or one for each of the bits, and check whether these bits form the given bit on XOR and SUM.\u003c/p\u003e\u003cp\u003eSince both numbers must be positive we will need to add 2 more variables to our state, which represent whether the first number is already greater than zero, and whether the second number is already greater than zero, so our DP solution becomes like the following:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDP[\u003c/strong\u003e current bit \u003cstrong\u003e][\u003c/strong\u003e do we have a carry from the sum operation or not \u003cstrong\u003e][\u003c/strong\u003e is the first number greater than zero \u003cstrong\u003e][\u003c/strong\u003e is the second number greater than zero \u003cstrong\u003e]\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComplexity: O(Log(s))\u003c/strong\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nll memo[50][2][2][2];\nll x, s;\nvector\u0026lt;int\u0026gt; XOR;\nvector\u0026lt;int\u0026gt; SUM;\nll dp(ll i, int carry, int greaterThanZero1, int greaterThanZero2){\n\tif (i \u003d\u003d 50) return (carry \u003d\u003d 0 \u0026amp;\u0026amp; greaterThanZero1 \u0026amp;\u0026amp; greaterThanZero2);\n\n\tll \u0026amp;ret \u003d memo[i][carry][greaterThanZero1][greaterThanZero2];\n\tif (ret !\u003d -1) return ret;\n\n\tret \u003d 0;\n\tfor (int c1 \u003d 0; c1 \u0026lt;\u003d 1; c1++) for (int c2 \u003d 0; c2 \u0026lt;\u003d 1; c2++){\n\t\tif (c1 ^ c2 !\u003d XOR[i]) continue;\n\t\tif ((c1 + c2 + carry) % 2 !\u003d SUM[i]) continue;\n\n\t\tint newCarry \u003d (c1 + c2 + carry) / 2;\n\t\tret +\u003d dp(i + 1, newCarry, greaterThanZero1 || (c1 \u0026gt; 0), greaterThanZero2 || (c2 \u0026gt; 0));\n\t}\n\treturn ret;\n}\n\nint main() {\n\t//freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t//freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\tios::sync_with_stdio(0);\n\t\n\tcin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; x;\n\twhile (s) SUM.push_back(s % 2), s /\u003d 2;\n\twhile (x) XOR.push_back(x % 2), x /\u003d 2;\n\twhile (SUM.size() \u0026lt; 50) SUM.push_back(0);\n\twhile (XOR.size() \u0026lt; 50) XOR.push_back(0);\n\n\tmemset(memo, -1, sizeof memo);\n\tcout \u0026lt;\u0026lt; dp(0, 0, 0, 0) \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}