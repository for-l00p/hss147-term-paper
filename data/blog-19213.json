{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1436896311,"rating":-5,"authorHandle":"Karan2116","modificationTimeSeconds":1436896311,"id":19213,"title":"\u003cp\u003eProblem MCHEF : July Long Challenge Codechef\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI was trying the following question. \u003ca href\u003d\"http://www.codechef.com/JULY15/problems/MCHEF\"\u003eMchef codechef\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI was using the following approach :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n/*\n1 data     first.first\n2 type     first.second\n3 other    second.first\n4 cost     second.second\n*/\nint knapSack(long long int W, long long int wt[], long long int val[], long long int n)\n{\n   long long int i, w;\n   long long int K[n+1][W+1];\n \n   // Build table K[][] in bottom up manner\n   for (i \u003d 0; i \u0026lt;\u003d n; i++)\n   {\n       for (w \u003d 0; w \u0026lt;\u003d W; w++)\n       {\n           if (i\u003d\u003d0 || w\u003d\u003d0)\n               K[i][w] \u003d 0;\n           else if (wt[i-1] \u0026lt;\u003d w)\n                 K[i][w] \u003d max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]);\n           else\n                 K[i][w] \u003d K[i-1][w];\n       }\n   }\n \n   return K[n][W];\n}\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tvector\u0026lt;pair\u0026lt;long long, long long\u0026gt; \u0026gt; v;\n\tvector\u0026lt;pair\u0026lt;pair\u0026lt;long long,long long\u0026gt;,pair\u0026lt;long long,long long\u0026gt; \u0026gt; \u0026gt; u;\n\tmap\u0026lt;pair\u0026lt;long long, long long\u0026gt;, long long\u0026gt; m1;\n\tlong long t, n, k, m, sum, i, x, l, r, c;\n\tcin \u0026gt;\u0026gt; t;\n\twhile (t--)\n\t{\n\t\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; m;\n\t\tsum \u003d 0;\n\t\tfor (i \u003d 0;i \u0026lt; n;i++)\n\t\t{\n\t\t\tcin \u0026gt;\u0026gt; x;\n\t\t\tsum \u003d sum + x;\n\t\t\tif (x \u0026lt; 0)\n\t\t\t{\n\t\t\t\tv.push_back(make_pair(-1 * x, i + 1));\n\t\t\t}\n\t\t}\n\t\tsort(v.rbegin(), v.rend());\n\t\tfor (i \u003d 0;i \u0026lt; m;i++)\n\t\t{\n\t\t\tcin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; c;\n\t\t\tm1[make_pair(l, r)] \u003d c;\n\t\t}\n\t\tlong long int wt[100000], val[100000], z;\n        pair\u0026lt;pair\u0026lt;long long,long long\u0026gt;,pair\u0026lt;long long,long long\u0026gt; \u0026gt; temp;\n\t\t//DO THE SWEEP-LINE PARADIGM\n        for(i\u003d0;i\u0026lt;v.size();i++)\n        {\n            (temp.first).first\u003dv[i].second;\n            (temp.first).second\u003d0;        // we put a 0 type for point , -1 for left, 1 for right\n            (temp.second).first\u003d-1;\n            (temp.second).second\u003dv[i].first;       // cost contains value for points, and cost for intervals\n            u.push_back(temp);\n        }\n        for(map\u0026lt;pair\u0026lt;long long, long long\u0026gt;, long long\u0026gt; ::iterator it\u003dm1.begin();it!\u003dm1.end();it++)\n        {\n            (temp.first).first\u003d(it-\u0026gt;first).first;\n            (temp.second).first\u003d(it-\u0026gt;first).second;\n            (temp.first).second\u003d-1;\n            (temp.second).second\u003d(it-\u0026gt;second);\n            u.push_back(temp);  //pushing left part of interval\n \n            (temp.second).first\u003d(it-\u0026gt;first).first;\n            (temp.first).first\u003d(it-\u0026gt;first).second;\n            (temp.first).second\u003d1;\n            (temp.second).second\u003d(it-\u0026gt;second);\n            u.push_back(temp);     //pushing right part of interval\n        }\n        set\u0026lt;pair\u0026lt;long long,pair\u0026lt;long long,long long\u0026gt; \u0026gt; \u0026gt; s;\n        pair\u0026lt;long long,pair\u0026lt;long long,long long\u0026gt; \u0026gt; temps;\n        sort(u.begin(),u.end());\n        z\u003d0;\n        for(i\u003d0;i\u0026lt;u.size();i++)\n        {\n            if(u[i].first.second\u003d\u003d-1)           //left of interval\n            {\n                temps.first\u003du[i].second.second;\n                temps.second.second\u003du[i].second.first;\n                temps.second.first\u003du[i].first.first;\n                s.insert(temps);\n            }\n            else if(u[i].first.second\u003d\u003d1)       //right of interval\n            {\n                temps.first\u003du[i].second.second;\n                temps.second.first\u003du[i].second.first;\n                temps.second.second\u003du[i].first.first;\n                s.erase(temps);\n            }\n            else            //point\n            {\n                temps\u003d*(s.begin());\n                val[z]\u003dv[u[i].first.first-1].first;\n                wt[z]\u003dtemps.first;\n                z++;\n            }\n        }\n\t\tlong long int ans \u003d knapSack(k, wt, val, z);\n\t\tcout \u0026lt;\u0026lt; sum + ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n\t\tm1.clear();\n\t\tu.clear();\n\t\tv.clear();\n\t\ts.clear();\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAccording to what i did,I first added the negative of the negative elements. These are the candidates to be removed. Also i stored the indices in a vector of pair. After that tried to use the sweep line technique to find out the intervals in which my candidate points occur. And searched the minimum cost for removing each point. After that we got two arrays wt[] val[] containing value and costs. Now it was the traditional knapsack. I am unable to understand why i got a WA. It would be great if someone can help me out a bit.\u003c/p\u003e\u003c/div\u003e","tags":["codechef","knapsack","dp","interval search"]}}