{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1405511609,"rating":-8,"authorHandle":"Easy_","modificationTimeSeconds":1405511895,"id":13062,"title":"\u003cp\u003eДвоичное дерево (min и max heap)\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eДобрый день, на acmp.ru есть такая задача: \u003ca href\u003d\"http://acmp.ru/index.asp?main\u003dtask\u0026amp;id_task\u003d472\"\u003eПодарки\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЯ пытался решить таким образом:\u003c/p\u003e\u003cp\u003eЕсли входные данные:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e5 10\n4 7 4 3 10\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eСначало сортировал массив по неубыванию,\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e3 4 4 7 10\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eА далее делал так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ewhile(M \u0026gt; 0)\n\t{\n\t\tint t \u003d A[1] - A[0];\n\t\tif(M \u0026gt; t)\n\t\t{\n\t\t\tM -\u003d (t + 1);\n\t\t\tA[0] +\u003d (t + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA[0] +\u003d M;\n\t\t\tM \u003d 0;\n\t\t}\n\t\t\n\t\ti \u003d 0;\n\t\twhile(A[i] \u0026gt; A[i + 1] \u0026amp;\u0026amp; i \u0026lt; N - 1)\n\t\t\tswap(A[i], A[i + 1]), i++;\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eА\u003c/strong\u003e — отсортированный массив\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eN\u003c/strong\u003e — кол. элементов массива\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eM\u003c/strong\u003e — кол. конфет\u003c/p\u003e\u003cp\u003eНадеюсь по алгоритму, идея решения ясна.. В конце работы алгоритма первый элемент массива и будет ответом.\u003c/p\u003e\u003cp\u003eНо такое решени не эффективное на больших входных данных и получаю TL на 10 тесте.\u003c/p\u003e\u003cp\u003eТеперь хочу попробовать решить через двоичные деревья, т.к. это у меня работает за O(N) \u003c/p\u003e \u003cpre\u003e\u003ccode\u003ewhile(A[i] \u0026gt; A[i + 1] \u0026amp;\u0026amp; i \u0026lt; N - 1)\n\t\t\tswap(A[i], A[i + 1]), i++;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eА если сделать через min heap, то будет за O(log N).\u003c/p\u003e\u003cp\u003eУ меня возникло 2 вопроса:\u003c/p\u003e\u003cp\u003e1) Как можно реализовать этот min heap самому, что бы там были методы добавления, и удаления корневого элемента? Если у кого есть пример, буду благодарен. В сети не нашел хороших примеров, а сам реализовал совсем не правильно.\u003c/p\u003e\u003cp\u003e2) Как тоже самое сделать через priority_queue? Проблема в том, что по умолчанию этот контейнер в С++ в корневом элементе хранит максимальный элемент, т.е. max heap. А мне нужно наоборот.\u003c/p\u003e\u003cp\u003eЯ в справочнике читал, что там ему можно параметр передавать компатор(не знаю как правильно называется). В сети нашел несколько примеров, только там этот \u0026quot;компатор\u0026quot; был классом у которого много разных методов и перегруженных операторов. Тупо copy/paste не стал делать, хотел бы разобраться что и зачем.\u003c/p\u003e\u003cp\u003eЕсли кто знает, подкажите пожалуйста как сделать так, что бы в этом контейнере сортировка была по неубыванию.\u003c/p\u003e\u003cp\u003eБуду благодарен.\u003c/p\u003e\u003c/div\u003e","tags":[]}}