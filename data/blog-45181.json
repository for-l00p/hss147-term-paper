{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1464806349,"rating":99,"authorHandle":"Wild_Hamster","modificationTimeSeconds":1464810576,"id":45181,"title":"\u003cp\u003eCodeforces Round #355 (Div. 2) Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/677/problem/A\" title\u003d\"Codeforces Round 355 (Div. 2)\"\u003e677A - Vanya and Fence\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFor each friend we can check, if his height is more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e. If it is, then his width is \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e, else \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eComplexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\nusing namespace std;\ntypedef long long ll;\nll i,n,h,ans,x;\nint main()\n{\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; h;\n\tans \u003d n;\n\tfor (i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tcin \u0026gt;\u0026gt; x;\n\t\tans +\u003d (x\u0026gt;h);\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\treturn 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/677/problem/B\" title\u003d\"Codeforces Round 355 (Div. 2)\"\u003e677B - Vanya and Food Processor\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe solution, that does same thing, as in the problem statement will fail with TL, because if the height of each piece of potato will be \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e and smashing speed will be \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, then for each piece we will do \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e operations. \u003c/p\u003e\u003cp\u003eWith each new piece of potato \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e we will smash the potato till \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eMOD\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, so we will waste \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] / \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e seconds on it. If we can not put this piece of potato after that, we will waste \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e more second to smash everything, that inside, else just put this piece. We will get an answer same as we could get with actions from the statement.\u003c/p\u003e\u003cp\u003eComplexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\nll i,n,h,ans,x,cur_h,k;\nint main()\n{\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; h \u0026gt;\u0026gt; k;\n\tans \u003d 0;\n\tcur_h \u003d 0;\n\tfor (i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tscanf(\u0026quot;%I64d\u0026quot;, \u0026amp;x);\n\t\tif (cur_h + x \u0026lt;\u003d h)\n\t\t   cur_h +\u003d x;\n\t\telse\n\t\t\tans++, cur_h \u003d x;\n\t\tans +\u003d cur_h/k;\n\t\tcur_h %\u003d k;\n\t}\n\tans +\u003d cur_h/k;\n\tcur_h %\u003d k;\n\tans +\u003d (cur_h\u0026gt;0);\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\treturn 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/677/problem/C\" title\u003d\"Codeforces Round 355 (Div. 2)\"\u003e677C - Vanya and Label\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe can transform our word in binary notation, we can do it easily, because \u003cspan class\u003d\"tex-span\"\u003e64 \u003d 2\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e. Move through the bits of this number: if bit is equal to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, then we can have 3 different optinos of this bit in our pair of words: 0\u0026amp;1, 1\u0026amp;0, 0\u0026amp;0, else we can have only one option: 1\u0026amp;1. So the result will be \u003cspan class\u003d\"tex-span\"\u003e3\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003enullbits\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enullbits\u003c/i\u003e\u003c/span\u003e — is amount of zero bits.\u003c/p\u003e\u003cp\u003eComplexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003es\u003c/i\u003e|)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string\u0026gt;\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nll i,j,n,h,ans,x,cur_h,k;\nstring s;\nstring pattern;\nll symbol_val[305];\nint main()\n{\n\tcin \u0026gt;\u0026gt; s;\n\tfor (char i \u003d \u00270\u0027; i \u0026lt;\u003d \u00279\u0027; i++)\n\t\tpattern.push_back(i);\n\tfor (char i \u003d \u0027A\u0027; i \u0026lt;\u003d \u0027Z\u0027; i++)\n\t\tpattern.push_back(i);\n\tfor (char i \u003d \u0027a\u0027; i \u0026lt;\u003d \u0027z\u0027; i++)\n\t\tpattern.push_back(i);\n\tpattern.push_back(\u0027-\u0027);\n\tpattern.push_back(\u0027_\u0027);\n\tfor (i \u003d 0; i \u0026lt; 64; i++)\n\t\tsymbol_val[pattern[i]] \u003d i;\n\tll ans \u003d 1;\n\tfor (i \u003d 0; i \u0026lt; s.size(); i++)\n\t{\n\t\tll x \u003d symbol_val[s[i]];\n\t\tfor (j \u003d 0; j \u0026lt; 6; j++)\n\t\t\tif ((x\u0026amp;(1\u0026lt;\u0026lt;j)) \u003d\u003d 0)\n\t\t\t   ans \u003d (ans*3)%MOD;\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\treturn 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/677/problem/D\" title\u003d\"Codeforces Round 355 (Div. 2)\"\u003e677D - Vanya and Treasure\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe can make dynamic programming \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ecol\u003c/i\u003e][\u003ci\u003erow\u003c/i\u003e]\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ecol\u003c/i\u003e][\u003ci\u003erow\u003c/i\u003e]\u003c/span\u003e is minimal time, that we have waste to open the chest in the cell \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ecol\u003c/i\u003e, \u003ci\u003erow\u003c/i\u003e)\u003c/span\u003e. For the cells of color \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e][\u003ci\u003ey\u003c/i\u003e] \u003d \u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. For each next color \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecolor\u003c/i\u003e\u003c/span\u003e we can look over all cells of color \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecolor\u003c/i\u003e - 1\u003c/span\u003e and all cells of color \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecolor\u003c/i\u003e\u003c/span\u003e, then for each cell of color \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecolor\u003c/i\u003e\u003c/span\u003e with coordinates \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e1, \u003ci\u003ey\u003c/i\u003e1)\u003c/span\u003e and for each cell with color \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecolor\u003c/i\u003e - 1\u003c/span\u003e and coordinates \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e2, \u003ci\u003ey\u003c/i\u003e2)\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e1][\u003ci\u003ey\u003c/i\u003e1] \u003d \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e2][\u003ci\u003ey\u003c/i\u003e2] + \u003ci\u003eabs\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e1 - \u003ci\u003ex\u003c/i\u003e2) + \u003ci\u003eabs\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e1 - \u003ci\u003ey\u003c/i\u003e2)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eBut complexity of this solution is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e·\u003ci\u003em\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e, what is not enough.\u003c/p\u003e\u003cp\u003eWe can do such improvement: let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e]\u003c/span\u003e be the amount of cells of color \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, then when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ecolor\u003c/i\u003e]·\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ecolor\u003c/i\u003e - 1] ≥ \u003ci\u003en\u003c/i\u003e·\u003ci\u003em\u003c/i\u003e\u003c/span\u003e, we can do bfs from cells of color \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecolor\u003c/i\u003e - 1\u003c/span\u003e to cells of color \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecolor\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eThen we will have complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e·\u003ci\u003em\u003c/i\u003e·\u003ci\u003esqrt\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e·\u003ci\u003em\u003c/i\u003e))\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/blog/entry/45181?#comment-297475\"\u003eProof\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#define MOD 1000000007\n#define N 2005\n#define mp make_pair\n#define X first\n#define Y second\nusing namespace std;\ntypedef int ll;\nll i,j,n,h,x,y,cur_h,k,m,p,fx,fy;\nll a[505][505], dp[505][505], d[505][505];\nll dir[4][2] \u003d {{-1,0},{1,0},{0,1},{0,-1}};\nvector\u0026lt;pair\u0026lt;ll,ll\u0026gt; \u0026gt; g[250505];\nvector\u0026lt;pair\u0026lt;ll, pair\u0026lt;ll,ll\u0026gt; \u0026gt; \u0026gt; lst, bfs;\nll Abs(ll x)\n{\n\treturn x\u0026gt;0?x:-x;\n}\nll find_dist(ll x1, ll y1, ll x2, ll y2)\n{\n\treturn Abs(x1-x2) + Abs(y1-y2);\n}\nbool in_range(ll x, ll y)\n{\n\treturn (x \u0026gt;\u003d 0 \u0026amp;\u0026amp; x \u0026lt; y);\n}\nint main()\n{\n\t//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n\t//freopen(\u0026quot;output.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; p;\n\tfor (i \u003d 0; i \u0026lt; n; i++)\n\t\tfor (j \u003d 0; j \u0026lt; m; j++)\n\t\t\tdp[i][j] \u003d (ll)1e+9;\n\tfor (i \u003d 0; i \u0026lt; n; i++)\n\t\tfor (j \u003d 0; j \u0026lt; m; j++)\n\t\t{\n\t\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i][j]);\n\t\t\tg[a[i][j]].push_back(mp(i,j));\n\t\t\tif (a[i][j] \u003d\u003d 1)\n\t\t\t   dp[i][j] \u003d i+j;\n\t\t\tif (a[i][j] \u003d\u003d p)\n\t\t\t   fx \u003d i, fy \u003d j;\n\t\t}\n\tfor (i \u003d 2; i \u0026lt;\u003d p; i++)\n\t{\n\t\tll cur_size \u003d g[i].size();\n\t\tll last_size \u003d g[i-1].size();\n\t\tif (cur_size * last_size \u0026lt;\u003d n * m)\n\t\t{\n\t\t\tfor (j \u003d 0; j \u0026lt; cur_size; j++)\n\t\t\t{\n\t\t\t\tll cur_x \u003d g[i][j].X;\n\t\t\t\tll cur_y \u003d g[i][j].Y;\n\t\t\t\tfor (k \u003d 0; k \u0026lt; last_size; k++)\n\t\t\t\t{\n\t\t\t\t\tll last_x \u003d g[i-1][k].X;\n\t\t\t\t\tll last_y \u003d g[i-1][k].Y;\n\t\t\t\t\tdp[cur_x][cur_y] \u003d min(dp[cur_x][cur_y], dp[last_x][last_y] + find_dist(cur_x,cur_y,last_x,last_y));\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tfor (k \u003d 0; k \u0026lt; n; k++)\n\t\t\t\tfor (j \u003d 0; j \u0026lt; m; j++)\n\t\t\t\t\td[k][j] \u003d -1;\n\t\t\tbfs.clear();\n\t\t\tlst.clear();\n\t\t\tfor (j \u003d 0; j \u0026lt; last_size; j++)\n\t\t\t{\n\t\t\t\tll last_x \u003d g[i-1][j].X;\n\t\t\t\tll last_y \u003d g[i-1][j].Y;\n\t\t\t\tlst.push_back(mp(dp[last_x][last_y], mp(last_x, last_y)));\n\t\t\t}\n\t\t\tsort(lst.begin(), lst.end());\n\t\t\tll pointer \u003d 1;\n\t\t\tj \u003d 0;\n\t\t\tbfs.push_back(lst[0]);\n\t\t\td[lst[0].Y.X][lst[0].Y.Y] \u003d lst[0].X;\n\t\t\twhile (j \u0026lt; bfs.size())\n\t\t\t{\n\t\t\t\tll x \u003d bfs[j].Y.X;\n\t\t\t\tll y \u003d bfs[j].Y.Y;\n\t\t\t\tll val \u003d bfs[j].X;\n\t\t\t\tj++;\n\t\t\t\twhile (pointer \u0026lt; lst.size() \u0026amp;\u0026amp; lst[pointer].X \u0026lt;\u003d val)\n\t\t\t\t\t  bfs.push_back(lst[pointer++]);\n\t\t\t\tfor (k \u003d 0; k \u0026lt; 4; k++)\n\t\t\t\t\tif (in_range(x+dir[k][0], n) \u0026amp;\u0026amp; in_range(y+dir[k][1], m) \u0026amp;\u0026amp; d[x+dir[k][0]][y+dir[k][1]] \u003d\u003d -1)\n\t\t\t\t\t{\n\t\t\t\t\t\td[x+dir[k][0]][y+dir[k][1]] \u003d val+1;\n\t\t\t\t\t\tbfs.push_back(mp(val+1, mp(x+dir[k][0], y+dir[k][1])));\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j \u003d 0; j \u0026lt; cur_size; j++)\n\t\t\t{\n\t\t\t\tll cur_x \u003d g[i][j].X;\n\t\t\t\tll cur_y \u003d g[i][j].Y;\n\t\t\t\tdp[cur_x][cur_y] \u003d d[cur_x][cur_y];\n\t\t\t}\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; dp[fx][fy] \u0026lt;\u0026lt; endl;\n\treturn 0;\n}\n\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eThere also exists solution with 2D segment tree:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#define MOD 1000000007\n#define N 512\n#define mp make_pair\n#define X first\n#define Y second\nusing namespace std;\ntypedef int ll;\nll i,j,n,h,x,y,glob,k,m,p,fx,fy;\nll a[505][505], dp[505][505], d[505][505], t[4][2005][2005];\nll dir[4][2] \u003d {{-1,0},{1,0},{0,1},{0,-1}};\nvector\u0026lt;pair\u0026lt;ll,ll\u0026gt; \u0026gt; g[250505];\nvector\u0026lt;pair\u0026lt;ll, pair\u0026lt;ll,ll\u0026gt; \u0026gt; \u0026gt; lst, bfs;\nll Abs(ll x)\n{\n\treturn x\u0026gt;0?x:-x;\n}\nll find_dist(ll x1, ll y1, ll x2, ll y2)\n{\n\treturn Abs(x1-x2) + Abs(y1-y2);\n}\nbool in_range(ll x, ll y)\n{\n\treturn (x \u0026gt;\u003d 0 \u0026amp;\u0026amp; x \u0026lt; y);\n}\n\nint get (int lx, int rx, int ly, int ry) {\n\trx++;\n\try++;\n\tint res \u003d MOD;\n\tll l \u003d ly, r \u003d ry;\n  for (lx +\u003d N, rx +\u003d N; lx \u0026lt; rx; lx \u0026gt;\u0026gt;\u003d 1, rx \u0026gt;\u0026gt;\u003d 1) {\n  \tif (rx\u0026amp;1)\n  \t{\n  \t\tly \u003d l; ry \u003d r;\n\t    rx--;\n\t    for (ly +\u003d N, ry +\u003d N; ly \u0026lt; ry; ly \u0026gt;\u0026gt;\u003d 1, ry \u0026gt;\u0026gt;\u003d 1) {\n\n\t\t    if (ly\u0026amp;1)\n\t\t    {\n\t\t       res \u003d min(res, t[glob][rx][ly]);\n\t\t       ly++;\n\t\t    }\n\t\t\tif (ry\u0026amp;1)\n\t\t\t{\n\t\t\t    --ry;\n\t\t\t    res \u003d min(res, t[glob][rx][ry]);\n\t\t\t}\n\t\t}\n\t}\n    if (lx\u0026amp;1)\n    {\n    \tly \u003d l; ry \u003d r;\n\t\tfor (ly +\u003d N, ry +\u003d N; ly \u0026lt; ry; ly \u0026gt;\u0026gt;\u003d 1, ry \u0026gt;\u0026gt;\u003d 1) {\n\n\t\t    if (ly\u0026amp;1)\n\t\t    {\n\t\t       res \u003d min(res, t[glob][lx][ly]);\n\t\t       ly++;\n\t\t    }\n\t\t\tif (ry\u0026amp;1)\n\t\t\t{\n\t\t\t    --ry;\n\t\t\t    res \u003d min(res, t[glob][lx][ry]);\n\t\t\t}\n\t\t}\n\t    lx++;\n    }\n  }\n  return res;\n}\n\nvoid update (int x, int y, int val) {\n\tll tmp \u003d y;\n\tt[glob][x+N][tmp+N] \u003d val;\n\tfor (x +\u003d N; x \u0026gt; 1; x \u0026gt;\u0026gt;\u003d 1)\n\t{\n\t\ty \u003d tmp;\n\t\tfor (y +\u003d N; y \u0026gt; 1; y \u0026gt;\u0026gt;\u003d 1)\n\t\t{\n\t\t\tt[glob][x][y\u0026gt;\u0026gt;1] \u003d min(t[glob][x][y], t[glob][x][y^1]);\n\t\t\tt[glob][x\u0026gt;\u0026gt;1][y] \u003d min(t[glob][x][y], t[glob][x^1][y]);\n\t\t}\n\t\tt[glob][x\u0026gt;\u0026gt;1][y] \u003d min(t[glob][x][y], t[glob][x^1][y]);\n\t}\n}\n\n\nint main()\n{\n\t//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n\t//freopen(\u0026quot;output.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; p;\n\tfor (i \u003d 0; i \u0026lt; n; i++)\n\t\tfor (j \u003d 0; j \u0026lt; m; j++)\n\t\t\tdp[i][j] \u003d MOD;\n\tfor (i \u003d 0; i \u0026lt; n; i++)\n\t\tfor (j \u003d 0; j \u0026lt; m; j++)\n\t\t{\n\t\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i][j]);\n\t\t\tg[a[i][j]].push_back(mp(i,j));\n\t\t\tif (a[i][j] \u003d\u003d 1)\n\t\t\t   dp[i][j] \u003d i+j;\n\t\t\tif (a[i][j] \u003d\u003d p)\n\t\t\t   fx \u003d i, fy \u003d j;\n\t\t}\n\tfor (i \u003d 0; i \u0026lt;\u003d N*2; i++)\n\t\tfor (j \u003d 0; j \u0026lt;\u003d N*2; j++)\n\t\t\tfor (k \u003d 0; k \u0026lt; 4; k++)\n\t\t\t\tt[k][i][j] \u003d MOD;\n\t//UR - dp[x2][y2] \u003d dp[x1][y1] + x2-x1+y2-y1 \u003d dp[x1][y1]-x1-y1+(x2+y2)\n\t//UL - dp[x2][y2] \u003d dp[x1][y1] + x2-x1+y1-y2 \u003d dp[x1][y1]-x1+y1+(x2-y2)\n\t//DR - dp[x2][y2] \u003d dp[x1][y1] + x1-x2+y2-y1 \u003d dp[x1][y1]-y1+x1+(y2-x1)\n\t//DL - dp[x2][y2] \u003d dp[x1][y1] + x1-x2+y1-y2 \u003d dp[x1][y1]+x1+y1+(-x2-y2)\n\tfor (i \u003d 2; i \u0026lt;\u003d p; i++)\n\t{\n\t\tll last_sz \u003d g[i-1].size();\n\t\tfor (j \u003d 0; j \u0026lt; last_sz; j++)\n\t\t{\n\t\t\tll x \u003d g[i-1][j].X;\n\t\t\tll y \u003d g[i-1][j].Y;\n\t\t\tglob \u003d 0;\n\t\t\t//cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; get( 0, x, 0, y) \u0026lt;\u0026lt; \u0026quot;g\u0026quot; \u0026lt;\u0026lt; endl;\n\t\t\tupdate(x,y,dp[x][y]-x-y);\n\t\t\t//cout \u0026lt;\u0026lt; get( 0, x, 0, y) \u0026lt;\u0026lt; \u0026quot;f\u0026quot; \u0026lt;\u0026lt; endl;\n\t\t\tglob \u003d 1;\n\t\t\tupdate(x,y,dp[x][y]-x+y);\n\t\t\tglob \u003d 2;\n\t\t\tupdate(x,y,dp[x][y]+x-y);\n\t\t\tglob \u003d 3;\n\t\t\tupdate(x,y,dp[x][y]+x+y);\n\t\t}\n\t\tll cur_sz \u003d g[i].size();\n\t\tfor (j \u003d 0; j \u0026lt; cur_sz; j++)\n\t\t{\n\t\t\tll x \u003d g[i][j].X;\n\t\t\tll y \u003d g[i][j].Y;\n\t\t\tglob \u003d 0;\n\t\t\t//cout \u0026lt;\u0026lt; get( 0, x, 0, y) \u0026lt;\u0026lt; endl;\n\t\t\tdp[x][y] \u003d min(dp[x][y], get( 0, x, 0, y)+x+y);\n\t\t\tglob \u003d 1;\n\t\t\tdp[x][y] \u003d min(dp[x][y], get(0, x, y, m-1)+x-y);\n\t\t\tglob \u003d 2;\n\t\t\tdp[x][y] \u003d min(dp[x][y], get(x, n-1, 0, y)-x+y);\n\t\t\tglob \u003d 3;\n\t\t\tdp[x][y] \u003d min(dp[x][y], get(x, n-1, y, m-1)-x-y);\n\t\t}\n\t\tfor (j \u003d 0; j \u0026lt; last_sz; j++)\n\t\t{\n\t\t\tll x \u003d g[i-1][j].X;\n\t\t\tll y \u003d g[i-1][j].Y;\n\t\t\tglob \u003d 0;\n\t\t\tupdate(x,y,MOD);\n\t\t\tglob \u003d 1;\n\t\t\tupdate(x,y,MOD);\n\t\t\tglob \u003d 2;\n\t\t\tupdate(x,y,MOD);\n\t\t\tglob \u003d 3;\n\t\t\tupdate(x,y,MOD);\n\t\t}\n\t}\n\t/*for (i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tfor (j \u003d 0; j \u0026lt; m; j++)\n\t\t\tcout \u0026lt;\u0026lt; dp[i][j] \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n\t\tcout \u0026lt;\u0026lt; endl;\n\t}*/\n\tcout \u0026lt;\u0026lt; dp[fx][fy] \u0026lt;\u0026lt; endl;\n\treturn 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/677/problem/E\" title\u003d\"Codeforces Round 355 (Div. 2)\"\u003e677E - Vanya and Balloons\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFor each cell \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e take the maximum possible cross with center in this cell, that doesn\u0027t contains zeros. To do it fast, we can make arrays of partial sums for all possible \u003cspan class\u003d\"tex-span\"\u003e8\u003c/span\u003e directions, in which each cell will contain the number of non-zero balloons in each direction. For example, if we want to know, how many non-zero balloons are right to cell \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e, we can create an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e][\u003ci\u003ey\u003c/i\u003e]\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e][\u003ci\u003ey\u003c/i\u003e] \u003d \u003ci\u003ep\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e][\u003ci\u003ey\u003c/i\u003e - 1] + 1\u003c/span\u003e if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e][\u003ci\u003ey\u003c/i\u003e]! \u003d 0\u003c/span\u003e else \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e][\u003ci\u003ey\u003c/i\u003e] \u003d 0\u003c/span\u003e\u003c/p\u003e\u003cp\u003eSo now we can for each cell \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e we can find the maximum size of cross with the centre in this cell, that will not contain zeros.\u003c/p\u003e\u003cp\u003eWe can compare product for crosses with centers in the cells \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e and radius \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e using logarythms. For example, if we need to compare 2 crosses with values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e·\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e·...·\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e·\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e·...·\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, we can compare \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e·\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e·...·\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e·\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e·...·\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e, what will be equivalent to comparing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e) + \u003ci\u003elog\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e) + ... + \u003ci\u003elog\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e) + \u003ci\u003elog\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e) + ... + \u003ci\u003elog\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eWe can also use partial sum arrays to find value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e) + \u003ci\u003elog\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e) + ... + \u003ci\u003elog\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e for each cross, so we can find the product of the values in each cross for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time.\u003c/p\u003e\u003cp\u003eComplexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#define MOD 1000000007\n#define N 2005\nusing namespace std;\ntypedef unsigned int ll;\nll i,j,n,h,x,y,cur_h,k,dir;\nll pre[8][N][N];\ndouble sums[8][N][N],ans,logs[N][N],lg2,lg3;\nll ansx,ansy,anssize,ansdir;\nll total;\nll directions[8][2] \u003d {{-1,-1},{-1,1},{1,-1},{1,1},{1,0},{0,1},{-1,0},{0,-1}};\nchar a[N][N];\nbool in_range(ll x)\n{\n\treturn (x \u0026gt;\u003d 0 \u0026amp;\u0026amp; x \u0026lt; n);\n}\nint main()\n{\n\t//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n\t//freopen(\u0026quot;output.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\n\tlg2 \u003d log(2);\n\tlg3 \u003d log(3);\n\tcin \u0026gt;\u0026gt; n;\n\tfor (i \u003d 0; i \u0026lt; n; i++)\n\t\tscanf(\u0026quot;%s\u0026quot;,a[i]);\n\tfor (i \u003d 0; i \u0026lt; n; i++)\n\t\tfor (j \u003d 0; j \u0026lt; n; j++)\n\t\t\tif (a[i][j] \u003d\u003d \u00273\u0027)\n\t\t\t   logs[i][j] \u003d lg3;\n\t\t\telse if (a[i][j] \u003d\u003d \u00272\u0027)\n\t\t \t\t logs[i][j] \u003d lg2;\n\tfor (dir \u003d 0; dir \u0026lt; 8; dir++)\n\t{\n\t\tfor (i \u003d 0; i \u0026lt; n; i++)\n\t\t\tfor (j \u003d 0; j \u0026lt; n; j++)\n\t\t\t\tif (!in_range(i-directions[dir][0]) || !in_range(j-directions[dir][1]))\n\t\t\t\t{\n\t\t\t\t\tk \u003d 0;\n\t\t\t\t\tll d1 \u003d directions[dir][0], d2 \u003d directions[dir][1];\n\t\t\t\t\tfor (x \u003d i, y \u003d j; in_range(x) \u0026amp;\u0026amp; in_range(y); x +\u003d d1, y +\u003d d2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (a[x][y] !\u003d \u00270\u0027)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t   k++;\n\t\t\t\t\t\t   if (x \u003d\u003d i \u0026amp;\u0026amp; y \u003d\u003d j)\n\t\t\t\t\t\t\t  sums[dir][x][y] \u003d logs[i][j];\n\t\t\t\t\t\t   else\n\t\t\t\t\t\t\t   sums[dir][x][y] \u003d sums[dir][x-d1][y-d2] + logs[x][y];\n\t\t\t   \t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsums[dir][x][y] \u003d 0;\n\t\t\t\t\t\t\tk \u003d 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpre[dir][x][y] \u003d k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\tans \u003d -1;\n\tfor (i \u003d 0; i \u0026lt; n; i++)\n\t\tfor (j \u003d 0; j \u0026lt; n; j++)\n\t\tif (a[i][j] !\u003d \u00270\u0027)\n\t\t{\n\t\t\tll tmp \u003d n+5;\n\t\t\tfor (k \u003d 0; k \u0026lt; 4; k++)\n\t\t\t\ttmp \u003d min(tmp, pre[k][i][j]);\n\t\t\tdouble val \u003d logs[i][j];\n\t\t\tfor (k \u003d 0; k \u0026lt; 4; k++)\n\t\t\t\tval +\u003d sums[k][i+directions[k][0]*(tmp-1)][j+directions[k][1]*(tmp-1)] - sums[k][i][j];\n\t\t\tif (val \u0026gt; ans)\n\t\t\t{\n\t\t\t\tans \u003d val;\n\t\t\t\tansx \u003d i;\n\t\t\t\tansy \u003d j;\n\t\t\t\tanssize \u003d tmp;\n\t\t\t\tansdir \u003d 0;\n\t\t\t}\n\t\t\t\n\t\t\ttmp \u003d n+5;\n\t\t\tfor (k \u003d 4; k \u0026lt; 8; k++)\n\t\t\t\ttmp \u003d min(tmp, pre[k][i][j]);\n\t\t\tval \u003d logs[i][j];\n\t\t\tfor (k \u003d 4; k \u0026lt; 8; k++)\n\t\t\t\tval +\u003d sums[k][i+directions[k][0]*(tmp-1)][j+directions[k][1]*(tmp-1)] - sums[k][i][j];\n\t\t\tif (val \u0026gt; ans)\n\t\t\t{\n\t\t\t\tans \u003d val;\n\t\t\t\tansx \u003d i;\n\t\t\t\tansy \u003d j;\n\t\t\t\tanssize \u003d tmp;\n\t\t\t\tansdir \u003d 4;\n\t\t\t}\n\t\t}\n\ttotal \u003d a[ansx][ansy]-\u00270\u0027;\n\tfor (k \u003d ansdir; k \u0026lt; ansdir+4; k++)\n\t{\n\t\tfor (i \u003d 1; i \u0026lt; anssize; i++)\n\t\t\ttotal \u003d (total*(a[ansx+directions[k][0]*i][ansy+directions[k][1]*i]-\u00270\u0027))%MOD;\n\t}\n\tcout \u0026lt;\u0026lt; total \u0026lt;\u0026lt; endl;\n\treturn 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["editorial","355"]}}