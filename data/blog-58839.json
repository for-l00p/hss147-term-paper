{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1523288742,"rating":-1,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1523288742,"id":58839,"title":"\u003cp\u003eNotes on Codeforces Beta Round #130, Div2-A, B, C, D, E (dfs with timestamp idea)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/208/problem/A\" title\u003d\"Codeforces Round 130 (Div. 2)\"\u003e208A - Дабстеп\u003c/a\u003e\u003c/p\u003e\u003cp\u003eA straightforward string implementation problem.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/208/problem/B\" title\u003d\"Codeforces Round 130 (Div. 2)\"\u003e208B - Пасьянс\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe main idea is dfs with memorization, which can also be viewed as an exhaustive tree search with pruning.\u003c/p\u003e\u003cp\u003eWe can use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ea\u003c/i\u003e][\u003ci\u003eb\u003c/i\u003e][\u003ci\u003ec\u003c/i\u003e][\u003ci\u003ed\u003c/i\u003e]\u003c/span\u003e to denote the state, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e is the number of remaining cards, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e, \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e denote the “results” of the rightmost three cards, i.e., the card\u0027s value and suit. Note that these four dimensions are sufficient to define a state. The reason is that no matter how we reach the state, all the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e - 3\u003c/span\u003e cards except for the current rightmost three ones keep the initial values and suits. Therefore, given \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e, \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e, the remaining cards always lead to the same result. According to the above arguments, we can run dfs to check the final answer, while memorizing the results of intermediate states and directly returning these results if we visit them for multiple times.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/208/problem/C\" title\u003d\"Codeforces Round 130 (Div. 2)\"\u003e208C - Контрольный пункт полиции\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe framework is Floyd algorithm. In conventional Floyd algorithm, we calculate the minimum distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e. As an extra “bonus”, we can also compute the number of different paths which all have the minimum distance as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e. When an intermediate node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is checked to update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][\u003ci\u003ev\u003c/i\u003e] \u0026gt; \u003ci\u003edis\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e] + \u003ci\u003edis\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e, then we set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][\u003ci\u003ev\u003c/i\u003e] \u003d \u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e] × \u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e; if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][\u003ci\u003ev\u003c/i\u003e] \u003d \u003ci\u003edis\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e] + \u003ci\u003edis\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e, then we set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][\u003ci\u003ev\u003c/i\u003e] \u003d \u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][\u003ci\u003ev\u003c/i\u003e] + \u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e] × \u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e. The term \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e] × \u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e means that we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e ways to reach node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e while \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e ways to leave node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, and thus this is a straightforward combination.\u003c/p\u003e\u003cp\u003eFinally, we check all the intermediate nodes except for node-1 and node-n, so that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[1][\u003ci\u003en\u003c/i\u003e] \u003d \u003ci\u003edis\u003c/i\u003e[1][\u003ci\u003ek\u003c/i\u003e] + \u003ci\u003edis\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003en\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e2 × \u003ci\u003ecnt\u003c/i\u003e[1][\u003ci\u003ek\u003c/i\u003e] × \u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003en\u003c/i\u003e] / \u003ci\u003ecnt\u003c/i\u003e[1][\u003ci\u003en\u003c/i\u003e]\u003c/span\u003e has the maximum value. Note that if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d 1\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, the value is always \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[1][1] × \u003ci\u003ecnt\u003c/i\u003e[1][\u003ci\u003en\u003c/i\u003e] / \u003ci\u003ecnt\u003c/i\u003e[1][\u003ci\u003en\u003c/i\u003e] \u003d 1\u003c/span\u003e. For intermediate nodes, we have a coefficient \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e since it is an “intermediate” node and it contributes two edges within every shortest path.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/208/problem/D\" title\u003d\"Codeforces Round 130 (Div. 2)\"\u003e208D - Призы, призы и еще раз призы\u003c/a\u003e\u003c/p\u003e\u003cp\u003eStraightforward implementation.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/208/problem/E\" title\u003d\"Codeforces Round 130 (Div. 2)\"\u003e208E - Братья по крови\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI think this is a very nice problem for one to gain more understanding about what dfs can do.\u003c/p\u003e\u003cp\u003eIf one is familiar with the classical LCA (lowest common ancestor) problem, recall that there is a very clever algorithm which adopts the “timestamp” idea to solve it. For this problem, we implement dfs, and maintain several arrays to store some important “information”. We use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edepth\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e to denote the depth of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e; \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etimestamp\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e to denote the timestamp of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, i.e., the time at which this node is visited during dfs; \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003erevtimestamp\u003c/i\u003e[\u003ci\u003et\u003c/i\u003e]\u003c/span\u003e to denote the node that is visited at time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e; \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elefttimeborder\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003erighttimeborder\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e to denote the earliest and latest timestamp of all the children nodes of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, respectively; \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esamedepth\u003c/i\u003e[\u003ci\u003ed\u003c/i\u003e]\u003c/span\u003e to store all the timestamp of nodes with depth \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNext, we should solve two subproblems. \u003c/p\u003e\u003cp\u003eThe first one is to find the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e-th parent of given node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. Note that the target node must have been included in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esamedepth\u003c/i\u003e[\u003ci\u003edepth\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e] - \u003ci\u003ep\u003c/i\u003e]\u003c/span\u003e, or to be more exact, its timestamp is included there. Moreover, the timestamp of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e-th parent must be the minimum one which is larger than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etimestamp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e. Thus, we can use binary search to find its timestamp and then use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003erevtimestamp\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e to get its node index, denoted as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epu\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe second subproblem is to find the number of nodes which have the same \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e-th parent. These nodes must be included in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esamedepth\u003c/i\u003e[\u003ci\u003edepth\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]]\u003c/span\u003e, and they (their timestamps) must fall into the interval \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003elefttimeborder\u003c/i\u003e[\u003ci\u003epu\u003c/i\u003e], \u003ci\u003erighttimeborder\u003c/i\u003e[\u003ci\u003epu\u003c/i\u003e]]\u003c/span\u003e. Therefore, we can use binary search again to find out the answer.\u003c/p\u003e\u003cp\u003eAs s summary, this is a very excellent problem and it sheds light on the power of dfs and timestamp idea. \u003c/p\u003e\u003c/div\u003e","tags":[]}}