{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1425575733,"rating":11,"authorHandle":"siddharths067","modificationTimeSeconds":1425627854,"id":16797,"title":"\u003cp\u003eIntroduction to One Dimensional Fenwick-Tree And Relative Mapping For Calculating Prefix Sums\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThe Following Introduction to The Fenwick Tree is Intended to be Easy to Understand and Targeted At Newbies , any Suggestion to make it Easier Will be Appreciated I was Introduced to Competitive Programming a Few weeks Ago Precisely Three and One of the First Data Structures i Encountered Was The Fenwick Tree, Its one of The Most Easy to Implement Form of Binary Indexed Trees out There and greatly Helps in Solving Problems With Deal With Statistical Cumulative Frequency of a Class ,  NOTE : Here Class Represents Statistical Interval Range And Not OOP Concept \u003cstrong\u003eFirstly Some of The Basic Concepts Relating To Cumulative Frequency :\u003c/strong\u003e Lets Say I Have to Add Marbles to a Particular Box (From a Range of Boxes ) and Then Report The Query of The Following Type From The Data :\u003c/p\u003e \u003cul\u003e  \u003cli\u003eThe Total Number of Marbles\u003c/li\u003e  \u003cli\u003eThe Total Number of Marbles From Box U to V;\u003c/li\u003e  \u003cli\u003eMarbles in Box U\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eLets Say I Have the Following Data For Four Marble Boxes \u003ctable\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003e\u003cb\u003e Serial Number of Box\u003c/b\u003e\u003c/td\u003e \u003ctd\u003e\u003cb\u003e Number of Marbles in the box\u003c/b\u003e\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e1\u003c/td\u003e \u003ctd\u003e3\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e2\u003c/td\u003e \u003ctd\u003e5\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e3\u003c/td\u003e \u003ctd\u003e3\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e4\u003c/td\u003e \u003ctd\u003e2\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e5\u003c/td\u003e \u003ctd\u003e3\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e6\u003c/td\u003e \u003ctd\u003e2\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e Lets First See How we Would Report The Following Queries From The Above Arrangement of Data : \u003c/p\u003e\u003cul\u003e  \u003cli\u003eReport The Total Number of Marbles : \u003cbr /\u003e1.) Take a variable Total \u003cbr /\u003e2.) Go Through each Box And Then Add The Number of Marbles of it to Total \u003cbr /\u003e3.) Report The Total Number of MarblesI Don\u0027t Think i Need to Tell You This But This Process Has the Time Complexity in Order of Θ( N ) And Has a Space Complexity of  Θ( N+1 )For If you have 2 Boxes It Would be Okay , But That\u0027s Never the Case in Competitive Programming is it ? in your Way Through You are Going to Have to Deal With Sample Input Ranging From Mere 10 To 10^8  To A Massive  \u0026gt;10^18 ( You need Special Techniques to handle These As They Cannot Be Accommodated into A Single Array) And Therefore Here This Arrangement of Data Falls Short .\u003c/li\u003e  \u003cli\u003eTotal Number of Marbles From U to V : \u003cbr /\u003e1.) Start Iterating From U and Keep Track of Number of marbles \u003cbr /\u003e2.) Go Till V \u003cbr /\u003e3.) Report The Total Again This is Also Linear Time And Takes in Order of Θ(V-U+1), And Like Said Earlier This Can Cross The Time Limit Very Easily and You Might Encounter The Most Dreaded TLE .\u003c/li\u003e  \u003cli\u003eReporting Marble in U Takes Constant Time Θ(1)\u003c/li\u003e \u003c/ul\u003e \u003cbr /\u003e In Basic Statistics you might Recall From 8th Grade That We Use Cumulative Frequencies to Operate on Data Now Let\u0027s Use The Cumulative Frequency Table \u003ctable\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003e\u003cb\u003e Serial Number of Box\u003c/b\u003e\u003c/td\u003e \u003ctd\u003e\u003cb\u003e Number of Marbles in the box\u003c/b\u003e\u003c/td\u003e \u003ctd\u003e\u003cb\u003e Cumulative Frequency \u003c/b\u003e\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e1\u003c/td\u003e \u003ctd\u003e3\u003c/td\u003e \u003ctd\u003e3\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e2\u003c/td\u003e \u003ctd\u003e5\u003c/td\u003e \u003ctd\u003e8 (5+3)\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e3\u003c/td\u003e \u003ctd\u003e3\u003c/td\u003e \u003ctd\u003e11 (8+3)\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e4\u003c/td\u003e \u003ctd\u003e2\u003c/td\u003e \u003ctd\u003e13 (11+2)\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e5\u003c/td\u003e \u003ctd\u003e3\u003c/td\u003e \u003ctd\u003e16 (13+3)\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e6\u003c/td\u003e \u003ctd\u003e2\u003c/td\u003e \u003ctd\u003e18 (16+2)\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e Cumulative Frequency of i th Class is Defined as The Total Sum of The Frequency of The i th Class With The Cumulative Frequency of The i-1 th Class , With The First Class Having the Cumulative Frequency Equal to its Frequency Now Let\u0027s See How we Would Handle Queries on the Basis of The Above Arrangement: \u003cul\u003e  \u003cli\u003eReport The Total Number of Marbles Θ(log n)  Read The Cumulative Frequency of Nth Element\u003c/li\u003e  \u003cli\u003eReport The Number of Marbles Between The Range U and V Read The Cumulative Frequency of  V th Element  Minus U-1 th Element  Θ(Time Taken to Read) in a Fenwick Tree it Takes in Order of A Mere Θ(2* log n), Which By A Large Margin a Way Less Than What we Had Before. Look at The graphic\u003cp\u003e\u003ca href\u003d\"https://binaryindexedindian.files.wordpress.com/2014/12/save.png\"\u003e\u003cimg alt\u003d\"Black Line - N  Blue - Log N\" src\u003d\"/predownloaded/5f/1b/5f1ba17a936b067c65ae82c27edc4b53476eedcd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/a\u003e Black Line — N\u003cbr /\u003eBlue — Log N\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e \u003cbr /\u003e\u003cbr /\u003e As you Would\u0027ve Seen From The Graphic Θ(log n) will Pass Tight Constraints , Whereas Simple Arrangement Won\u0027t And So For Problems That Involve Queries over a Range , We use Fenwick Trees For Prefix Sums . \u003cstrong\u003eIdea or Intuition Behind Fenwick Trees : \u003cem\u003eWhat we Do is We Take The Least Significant Digit  From a Number\u0027s binary Representation For N  by                      Expression N\u0026amp;-N And Use it To Iterate Through The Array , Now This Iteration Depends on Pattern of The Binary Number and Use it as a Map For Iterating Through Array By Adding it to The Index to Move Forward              and Subtracting to Iterate Back.\u003c/em\u003e\u003c/strong\u003e Here is a Textbook Definition From Various Sources : \u003cul\u003e  \u003cli\u003eThe basic rule that the structure works on is that, just like a number can be represented as a sum of some powers of two, so can a cumulative sum be represented as a sum of some partial cumulative sums . (Algorithmist)\u003c/li\u003e \u003c/ul\u003e Suppose we are looking for cumulative frequency of index 13 (for the first 13 elements). In binary notation, 13 is equal to 1101. Accordingly, we will calculate \u003cb\u003ec[1101] \u003d tree[1101] + tree[1100] + tree\u003ca href\u003d\"Topcoder\"\u003e1000\u003c/a\u003e{Note How on every successive iteration one 1 bit is removed from the sequence , That\u0027s the magic of n\u0026amp;-n , try solving it by your hand , Note -n refers to two\u0027s complement }\u003c/b\u003e Here is a Table of Responsibility , That is It Shows How One Could Iterate Through the Array From The Binary Representation of a Particular Index \u003cp\u003e \u003cbr /\u003e Let\u0027s First See how n\u0026amp;-n Works , \u003c/p\u003e\u003col\u003e \u003cli\u003elet N \u003d 13 \u003c/li\u003e\u003cli\u003e The Binary Representation of N is 1101 \u003c/li\u003e\u003cli\u003e The One\u0027s Complement of N is 0010 (NOT Operation,Flipping of Digits) + 1 ,  \u003c/li\u003e\u003cli\u003e Therefore Two\u0027s Complement of N should be \u003cbr /\u003e      !(1101)+1 \u003d 0010 + 1 \u003d 0011; \u003c/li\u003e\u003cli\u003e Consider the Two\u0027s Complement Representation to be M\u003d0011 \u003c/li\u003e\u003cli\u003e Taking N \u0026amp; M (AND operation) we get\u003cbr /\u003e      1101\u003cbr /\u003e     \u0026amp;0011\u003cbr /\u003e      _____\u003cbr /\u003e      \u003cb\u003e0001\u003cb\u003e \u003c/b\u003e\u003c/b\u003e\u003c/li\u003e\u003cli\u003e In a Read Operation We subtract it from N\u0026amp;M from N ,\u003cbr /\u003e      which Leads to 1101(13) — 0001(1) \u003d 1100 , Which Gives the Next Index For The Array Element \u003c/li\u003e\u003cli\u003e Similarly For 1100, Two\u0027s Complement is 0011+1\u003d 0100, And Thu 1100-0100 \u003d 1000\u003cbr /\u003e \u003c/li\u003e\u003cli\u003eNote That in case of 1000 Two\u0027s Complement is 0111+1 \u003d 1000 , Which Leads to Next N being       1000-1000\u003d0000 ,And Here the Binary Tree Indexed by Digits of 13 Ends,       Therefore The Cumulative Frequency of 13 is Stored in 1101,1100 and 1000 , \u003c/li\u003e\u003cli\u003e \u003cb\u003eBinary Indexed Tree is the clever way of storing cumulative frequencies on the basis of the sequence of numbers formed in the process of removal of the Least Significant Digit From The Binary Representation of  a number . Similarly when we update 1000(8), the value gets updated in 1000,1100 and 1101, Try doing it by hand but this time add N\u0026amp;-M to N . \u003c/b\u003e   \u003c/li\u003e\u003c/ol\u003e \u003cp\u003e\u003ca href\u003d\"https://binaryindexedindian.files.wordpress.com/2014/12/bitimg.gif\"\u003e\u003cimg alt\u003d\"From Topcoder\" src\u003d\"/predownloaded/5b/f0/5bf085f17fb770b255601b0d22c26480d8d33ab8.gif\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/a\u003e\u003cbr /\u003e From Topcoder , NOTE :- Perfect Powers of 2 like 1 ,2 ,4 ,8 ,16 . Store The Cumulative Frequency From the Start , unlike Other Indexes Which are Dis-Continuous , Wonder Why ? Write Down the Binary Representation of Powers of 2 and Then Start Removing The Least Significant Digit (1) One by one , and I am Sure you\u0027ll Figure it Out\u003c/p\u003e\u003cp\u003eNote The Reason 0 Doesn\u0027t Link to Other Index is Because 0\u0026amp;-0 is Zero , That is Fenwick Tree only Works on One Indexed Arrays Now The Idea Behind BIT is That we Initialize an Array Of Size  The Serial Number of Classes + 1 (Relative For Negative Indexes and Discontinuous Sets) What we Do is Initially we  Initialize all The Elements a Value of Zero and Use a Function Update to Represent Change in  Cumulative Frequency, Basically We Represent The Cumulative frequency By The Change With Each Input Query , and Update The Value . What we Do is We First Take The Index n and Then extract the Least Significant Digit one  and Iterate Forward Till we are Lesser Than The MAXIMUM Length of The Array \u003cbr /\u003e \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e typedef long long int ll; //lazy kid , Guilty ! \nvoid update( ll n, ll val) { \nfor(;n\u0026lt;\u003dMAXVAL;arr[n]+val,n+\u003dn\u0026amp;-n); // Add The Value in The Index and Move Forward according to //The Binary Pattern \n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSimilarly For Reading The Cumulative Frequency of a Particular Class , we Iterate In backward Direction By Subtracting N\u0026amp;-N From the Index N \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003ell read(ll n) { \nll sum\u003d0; for(;n;sum+\u003darr[n],n-\u003dn\u0026amp;-n); \nreturn sum;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFinding the Frequency in a Range U and V Takes a Function Call \u003c/p\u003e \u003cpre\u003e\u003ccode\u003ereturn read(V)-read(U-1);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd Similarly For Reading The Frequency For a Position There Exists a Faster Method \u003ca href\u003d\"http://community.topcoder.com/tc?module\u003dStatic\u0026amp;d1\u003dtutorials\u0026amp;d2\u003dbinaryIndexedTrees#reada\"\u003eHere \u003c/a\u003e, Otherwise One Can Replace U and V with The Same Index with The Previous Function Call. The Operation Takes  2 * Θ( log n) \u003c/p\u003e\u003ch3\u003eReducing Space Complexity and Optimizing With Relative Mapping :\u003c/h3\u003e Now That Would be all For Implementing The Simple Fenwick Tree However One Might Further optimize it And Help reduce Space Complexity and Length of The Original Array ,By Relatively Mapping It For Example Consider we Have a Set of Values for a Class Defined By S \u003d {1 , 2, 3 ,4 ,10^5} now for representing a Set of Only 5 Elements  we would have to Create an Array With Length 10^5 + 1, And Trust me Not So Good , Rather Than That WE Could Reduce The Space Complexity From Ω( Magnitude of Largest Element +1 ) to Ω(Size of Distinct Elements), \u003cbr /\u003e\u003cbr /\u003e PS: —  and how The Hell Would You Create a Normal BIT For This S \u003d {0, -2, -3 ,-4 ,-10^5,-10^2} For That We Use The Following Algorithm For Number of Classes N , and Two arrays (Vectors)   a ,  And Binary Indexed Tree b is \u003cp\u003e\u003cbr /\u003e  map( N, a, b) temp;  a.clear(); //resize array to 0  b.clear(); //resize array to 0 FOR i \u003d 0 to n: INPUT temp push temp to End of a push temp to End of b \u003c/p\u003e \u003cpre\u003esort( b ) //sort b \n          FOR i \u003d 0 to N \n           replace the i th element with the Position of The First Occurrence of the i th element in Sorted Array B +1 \n            resize b to size of N+ 1\u003c/pre\u003e\u003cp\u003e\u003cbr /\u003e\u003cbr /\u003e Here is a Code to Implement The Above Mapping \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003etypedef long long int ll;\nusing namespace std;\nvoid update(ll n, ll val, vector \u0026amp;b);\nll read(ll n,vector \u0026amp;b);\nll readsingle(ll n,vector \u0026amp;b);\nvoid map(vector \u0026amp;a,vector \u0026amp;b,ll n) /**** RElative Mapping ***/\n{\n    ll temp;\n    a.clear();\n    b.clear();\n    for(ll i\u003d0; i\u0026lt;n; i++)\n    {\n        scanf(\u0026quot;%lld\u0026quot;,\u0026amp;temp);\n        a.push_back(temp);\n        b.push_back(temp);\n    }\n    sort(b.begin(),b.end());\n    for(ll i\u003d0; i\u0026lt;n; i++)\n        *(a.begin()+i) \u003d (lower_bound(b.begin(),b.end(),a[i])-b.begin())+1;\n    b.assign(n+1,0);\n}\nll readsingle(ll n,vector \u0026amp;b)\n{\n    return read(n,b)-read(n-1,b);\n}\nll read(ll n,vector \u0026amp;b)\n{\n    ll sum\u003d0;\n    for(; n; sum+\u003db[n],n-\u003dn\u0026amp;-n);\n    return sum;\n}\nvoid update(ll n, ll val, vector \u0026amp;b)\n{\n    for(; n\u0026lt;\u003db.size(); b[n]+\u003dval,n+\u003dn\u0026amp;-n);\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHope it Helped :) , Will Post one on Two Dimensional as Soon as i Learn it :) Thanks For Reading , Any Suggestions Mention or Mistakes Them Below\u003c/p\u003e\u003c/div\u003e","tags":["bit","fenwick tree","fenwick"]}}