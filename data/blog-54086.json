{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1503823078,"rating":-9,"authorHandle":"police_cheat_codeforces","modificationTimeSeconds":1503823078,"id":54086,"title":"\u003cp\u003eHelp on problem A of kickstart round E\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eMy solution is giving wrong answer on large input file . Please tell me what\u0027s wrong in my code?\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\nusing namespace std;\n#define ll long long\n\nll pwr(ll a,ll b,ll mod) {a%\u003dmod;if(a\u0026lt;0)a+\u003dmod;ll ans\u003d1; while(b) {if(b\u0026amp;1) ans\u003d(ans*a)%mod; a\u003d(a*a)%mod; b/\u003d2; } return ans; }\nll modularInverse(ll a,ll m) {/*reminder: make sure m is prime*/  return pwr(a,m-2,m); }\nconst int MOD\u003d1000000007;\nint dp[301][301];\nint recurse(string s,  int st, int en, ll cumu[], ll pwr[], int hash2){\n    // case if u remove from here\n    if(st \u003d\u003d en)return 1;\n    if(st \u0026gt; en)return MOD;\n    if(dp[st][en] !\u003d -1)return dp[st][en];\n\n\n    int ans \u003d MOD+1;\n    ans \u003d recurse(s, st+1, en, cumu, pwr, hash2) + 1 ;\n    // cout \u0026lt;\u0026lt; en \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; st \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n    for(int len \u003d 2; len \u0026lt;\u003d st; len++){\n        int end \u003d st+len-1;\n        if(end \u0026gt;\u003d s.length())break;\n        ll hash \u003d (cumu[end] - cumu[st-1] + MOD)%MOD;\n        hash \u003d (hash * modularInverse(pwr[st], MOD))%MOD; \n        if(hash \u003d\u003d hash2){\n            ans \u003d min(ans, recurse(s,  st+len, en, cumu, pwr, hash2)+1);\n            continue;   \n        }\n        for(int i \u003d 0; i+len-1 \u0026lt; st; i++){\n            ll hash1;\n            if(i \u003d\u003d 0){\n                hash1 \u003d cumu[i+len-1]%MOD;\n            }\n            else{\n                hash1 \u003d (cumu[i+len-1] - cumu[i-1] + MOD)%MOD;\n                hash1 \u003d (hash1 * modularInverse(pwr[i], MOD))%MOD; \n            }\n            if(hash1 \u003d\u003d hash){\n                // string conc \u003d s.substr(st, len);\n                ans \u003d min(ans, recurse(s,  st+len, en, cumu, pwr, hash1)+2);\n            }\n        }\n    }\n    return dp[st][en] \u003d ans;\n\n}\n\nint main(int argc, char const *argv[])\n{\n    ios::sync_with_stdio(false);    \n    freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n    freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n    int t;\n    cin \u0026gt;\u0026gt; t;\n    int countt \u003d 0;\n    while(t--){\n        countt++;\n\n        string s;\n        cin \u0026gt;\u0026gt; s;\n        for(int i \u003d 0; i \u0026lt; 301; i++){\n            for(int j \u003d 0; j \u0026lt; 301; j++)\n                // for(int k \u003d 0; k \u0026lt; 301; k++)\n                dp[i][j]\u003d -1;\n        }\n        ll cumu[s.length()];\n        ll pwr[s.length()];\n        memset(cumu, 0, sizeof cumu);\n        memset(pwr, 0, sizeof pwr);\n        for(int i \u003d 0; i \u0026lt; s.length(); i++){\n            if(i \u003d\u003d 0)pwr[i] \u003d 1;\n            else {\n                pwr[i] \u003d (pwr[i-1]*31)%MOD;\n            }\n        }\n\n        cumu[0] \u003d 1*(s[0]-\u0027a\u0027);\n    \n        for(int i \u003d 1; i \u0026lt; s.length(); i++){\n            cumu[i] \u003d (cumu[i-1] + pwr[i]*(s[i]-\u0027a\u0027))%MOD;\n        }\n        string s1 \u003d \u0026quot;\u0026quot;;\n        int ans \u003d recurse(s,  0, s.length()-1, cumu, pwr, 0);\n        // if(ans  \u0026gt; 1)ans -\u003d 1;\n        cout \u0026lt;\u0026lt; \u0026quot;Case #\u0026quot; \u0026lt;\u0026lt; countt \u0026lt;\u0026lt; \u0026quot;: \u0026quot; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n\n    }\n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["kickstart"]}}