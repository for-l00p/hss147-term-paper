{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1418857274,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1418857557,"id":15249,"title":"\u003cp\u003eСоздание простого проекта в Eclipse\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cem\u003e(описано на примере Eclipse Luna для Windows, для других версий и ОС могут быть некоторые отличия)\u003c/em\u003e\u003c/p\u003e\u003cp\u003e1. Запускаем интегрированную среду разработки (IDE) Eclipse. При запуске появляется диалоговое окно, предлагающее выбрать рабочую область (Workspace). \u003cbr /\u003e\u003cbr /\u003e Рабочая область позволяет организовывать Ваши проекты, в частности, обеспечивая при их создании одинаковые настройки. Проекты, размещенные в одной рабочей области, отображаются в среде разработки, могут быть открыты и запущены, как только потребуется. Между рабочими областями можно переключаться, но это происходит не мгновенно. Скорее всего, на первое время Вам будет достаточно одной рабочей области. Создайте ее на Вашем диске W (в университетской сети); на Вашем компьютере Вы можете поместить ее там, где Вам удобно. Лучше избегать использования кириллических символов, пробелов и иных спецсимволов при именовании каталогов. \u003cbr /\u003e\u003cbr /\u003e IDE Eclipse обычно предлагает выбрать ту рабочую область, которая использовалась последней. Если Вы уже создавали рабочую область (на W:), достаточно удостовериться, что выбрана именно она. Если же нет (или по каким-либо причинам Вы решили создать новую область), то воспользуйтесь кнопкой \u003cem\u003e\u003cstrong\u003eBrowse\u003c/strong\u003e\u003c/em\u003e в диалоговом окне и с помощью окна \u003cem\u003eОбзор папок\u003c/em\u003e создайте новую папку, которая и станет новой рабочей областью. 2. Если рабочая область уже существует и настроена, этот пункт можно пропустить. Иначе — в пункте горизонтального меню \u003cem\u003eWindow\u003c/em\u003e выберите пункт \u003cem\u003ePreferences\u003c/em\u003e. В открывшемся окне раскройте пункт \u003cem\u003eJava\u003c/em\u003e и выберите \u003cem\u003eInstalled JREs\u003c/em\u003e. \u003cbr /\u003e\u003cbr /\u003e Посмотрите, какая JRE (Java Runtime Environment) установлена как основная (она отмечена галочкой). Если это jdk 1.8 — то ничего делать не нужно, можно закрыть окно настроек. Если же это jre 1.8 — то нужно сделать основной JRE jdk (если не сделать — «неприятности» могут быть самыми разными: например, eclipse сообщит Вам, что ему неизвестен какой-либо класс и т.п.). \u003cbr /\u003e\u003cbr /\u003e Если у Вас стоит jdk или jre с меньшим номером — 1.6, 1.7 — в первую очередь проверьте версию Eclipse. Версию 1.8 поддерживает Eclipse Luna, и крайне желательно, чтобы у Вас стояли именно jdk 1.8 и Eclipse Luna. Это свободно распространяемые продукты, Вы можете скачать jdk отсюда: \u003ca href\u003d\"http://www.oracle.com/technetwork/java/javase/downloads/index.html?ssSourceSiteId\u003docomen\"\u003ehttp://www.oracle.com/technetwork/java/javase/downloads/index.html?ssSourceSiteId\u003docomen\u003c/a\u003e (Вам нужно именно JDK), а Eclipse — отсюда: \u003ca href\u003d\"http://www.eclipse.org/downloads/\"\u003ehttp://www.eclipse.org/downloads/\u003c/a\u003e (вероятно, на данный момент лучший выбор — для Java-разработчиков, дополнительные функции скорее будут помехой). \u003cbr /\u003e\u003cbr /\u003e Если jdk 1.8 отсутствует в списке Installed JREs (но при этом установлена у Вас на компьютере), следует нажать кнопку \u003cem\u003e\u003cstrong\u003eAdd...\u003c/strong\u003e\u003c/em\u003e, в появившемся диалоговом окне выбрать Standard VM (обычно она выбрана по умолчанию) и нажать кнопку \u003cem\u003e\u003cem\u003eNext\u003c/em\u003e\u003c/em\u003e. Затем, в следующем диалоговом окне нажать кнопку \u003cem\u003e\u003cstrong\u003eDirectory...\u003c/strong\u003e\u003c/em\u003e , после чего в окне \u003cem\u003eОбзор папок\u003c/em\u003e найти, где размещена нужная JDK. Скорее всего, путь к ней будет выглядеть примерно так: \u003cbr /\u003e\u003cbr /\u003e \u003ccode\u003eC:\\Program Files\\Java\\jdk1.8.0_25\u003c/code\u003e \u003cbr /\u003e\u003cbr /\u003e Когда jdk 1.8 появится в списке, пометьте ее галочкой. Другие jdk и jre можно (при желании) удалить из списка с помощью кнопки \u003cem\u003e\u003cstrong\u003eRemove\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\u003cp\u003e3. Теперь создадим новый проект: \u003cem\u003eFile | New | Java Project\u003c/em\u003e. В первом диалоговом окне нужно указать имя проекта. Лучше всего, если Вы будете называть проект содержательным именем, начиная с маленькой буквы, и будете использовать при этом только буквы, цифры и символы подчеркивания. Например, \u003ccode\u003eproblem_5_18\u003c/code\u003e, \u003ccode\u003ezadanie_2_4\u003c/code\u003e. \u003cbr /\u003e\u003cbr /\u003e При создании проекта удостоверьтесь, что в пункте \u0027Use an execution environment JRE\u0027 указана именно JavaSE-1.8. В этом окне ничего менять не нужно, нажмите кнопку \u003cem\u003e\u003cstrong\u003eFinish\u003c/strong\u003e\u003c/em\u003e. В результате будет создана структура папок: папка с именем проекта и внутри нее папка \u003ccode\u003esrc\u003c/code\u003e. Также в состав проекта будет включена \u003ccode\u003eJRE System Library (JavaSE-1.8)\u003c/code\u003e. \u003c/p\u003e\u003cp\u003e4. Создадим собственно файл для размещения в нем текста программы. Проще всего это сделать, щелкнув правой клавишей мыши на папке \u003ccode\u003esrc\u003c/code\u003e внутри проекта и в появившемся контекстном меню выбрав \u003cem\u003eNew | Class\u003c/em\u003e. \u003cbr /\u003e\u003cbr /\u003e В открывшемся диалоговом окне будут установлены значения \u003ccode\u003eSource folder\u003c/code\u003e и \u003ccode\u003ePackage\u003c/code\u003e. Менять их не нужно. Ваша задача — указать имя класса в поле \u003ccode\u003eName\u003c/code\u003e. По соглашению имена классов в Java начинаются с заглавной буквы, могут содержать также строчные буквы и символы. Постарайтесь давать классам содержательные названия (например, \u003ccode\u003eChess\u003c/code\u003e или \u003ccode\u003eShakhmaty\u003c/code\u003e). \u003cbr /\u003e\u003cbr /\u003e Также рекомендуется поставить галочку в пункте \u003ccode\u003epublic static void main(String[] args)\u003c/code\u003e. Конечно, уметь писать заголовок этого метода обязательно нужно, но поначалу можно избегать ошибок таким образом. \u003cbr /\u003e\u003cbr /\u003e Нажмите кнопку \u003cem\u003e\u003cstrong\u003eFinish\u003c/strong\u003e\u003c/em\u003e. В папке \u003ccode\u003esrc\u003c/code\u003e появится значок пакета, а в нем — имя файла. Сам же файл откроется в редакторе среды Eclipse. \u003cbr /\u003e\u003cbr /\u003e Он будет выглядеть приблизительно так: \u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage first;\n\npublic class AplusB {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e5. Представляется, что поначалу лучше придерживаться какой-то «единой архитектуры приложения». Поэтому предлагается делать следующее. Класс, который мы только что создали, будем рассматривать как «оболочку для запуска». А для реализации «логики» напишем отдельный класс. \u003cbr /\u003e\u003cbr /\u003e Сделаем это на примере задачи «сложить два вещественных числа A и B». \u003cbr /\u003e\u003cbr /\u003e Напечатайте в редакторе, отступив строчку после последней закрывающей фигурной скобки, с новой строки \u003ccode\u003eclass ABsumma {\u003c/code\u003e и нажмите \u003cem\u003eEnter\u003c/em\u003e. Eclipse завершит объявление класса закрывающей фигурной скобкой автоматически. У Вас должно получиться следующее (здесь и далее приводится полный текст программы на текущий момент, чтобы Вы могли видеть расположение ее составляющих):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage first;\n\npublic class AplusB {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass ABsumma {\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e6. Каждый класс имеет конструктор. Даже если Вы не напишете конструктор явным образом, он все равно будет — унаследованный от «всеобщего предка» класса Object. Однако конструктор позволяет сделать ряд полезных вещей: установить начальные значения для каких-то переменных, выполнить чтение данных с клавиатуры и т.п. \u003cbr /\u003e\u003cbr /\u003e Можно считать, что конструктор имеет то же имя, что и класс. Но поскольку это метод, он снабжен круглыми скобками. Есть другая точка зрения — что конструктор не имеет имени, но возвращает значение типа класса, в котором он содержится. Она менее популярна, хотя логически выглядит вполне обоснованной. \u003cbr /\u003e\u003cbr /\u003e Напечатайте в новом классе \u003ccode\u003eABsumma () {\u003c/code\u003e и нажмите \u003cem\u003eEnter\u003c/em\u003e. У Вас получится следующее:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage first;\n\npublic class AplusB {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass ABsumma {\n\n\tABsumma() {\n\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e7. В конструкторе мы будем выполнять чтение вещественных переменных \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e. Для этого нам понадобится их объявить. Эти переменные будут использоваться не только в конструкторе, но и в методе, вычисляющем сумму. Поэтому их нужно объявить в классе, а не в конструкторе — тогда они будут доступны всем методам. Объявления можно писать в любом месте класса, но чаще всего это делают либо в начале класса, либо в конце (как показано ниже). \u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage first;\n\npublic class AplusB {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass ABsumma {\n\n\tABsumma() {\n\n\t}\n\n\tdouble a;\n\tdouble b;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e8. А вот чтение данных с клавиатуры мы выполним в конструкторе, поэтому переменная, которая позволит нам это сделать, будет объявлена внутри него (и когда конструктор завершит свою работу, эта переменная также прекратит свое существование). \u003cbr /\u003e\u003cbr /\u003e Для чтения данных с клавиатуры мы воспользуемся классом \u003ccode\u003eScanner\u003c/code\u003e. Сначала мы создадим экземпляр класса \u003ccode\u003eScanner\u003c/code\u003e и передадим ему в качестве параметра \u003ccode\u003eSystem.in\u003c/code\u003e — так называемый стандартный поток ввода (т.е. с клавиатуры). \u003cbr /\u003e\u003cbr /\u003e После этого воспользуемся методом чтения вещественного числа \u003ccode\u003enextDouble()\u003c/code\u003e и прочитаем значения \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e. Мы предполагаем, что тот, кто будет вводить значения, не ошибается, и введет именно два вещественных числа (а не строки, например; конечно, можно предусмотреть и защиту от ошибок, но пока мы этим заниматься не будем). \u003cbr /\u003e\u003cbr /\u003e Еще важный момент связан с локализацией ОС и Вашего приложения. По умолчанию разделитель между целой и дробной частью числа будет распознаваться тот, который установлен в операционной системе. Однако в «мире программирования» обычно используется «англоязычный» вариант разделителя — т. е. десятичная точка. Поэтому перед чтением чисел мы укажем, что хотим использовать региональные настройки US или UK. \u003cbr /\u003e\u003cbr /\u003e По завершении чтения закроем экземпляр класса \u003ccode\u003eScanner\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage first;\n\npublic class AplusB {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass ABsumma {\n\n\tABsumma() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tin.useLocale(Locale.US);\n\t\ta \u003d in.nextDouble();\n\t\tb \u003d in.nextDouble();\n\t\tin.close();\n\t}\n\n\tdouble a;\n\tdouble b;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e9. Теперь напишем метод, складывающий эти два числа. Этот метод будет называться \u003ccode\u003esolve()\u003c/code\u003e и возвращать в качестве результата своей работы сумму чисел \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e — т. е. вещественное число. Поэтому для метода \u003ccode\u003esolve()\u003c/code\u003e мы укажем тип \u003ccode\u003edouble\u003c/code\u003e, а в самом методе нужно будет написать оператор \u003ccode\u003ereturn \u0026lt;имя или значение\u0026gt;\u003c/code\u003e, который, собственно, и вернет значение из метода (по запросу). \u003cbr /\u003e\u003cbr /\u003e В методе \u003ccode\u003esolve()\u003c/code\u003e мы объявим переменную \u003ccode\u003eres\u003c/code\u003e вещественного типа, поместим в нее сумму \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e, после чего вернем ее значение с помощью \u003ccode\u003ereturn\u003c/code\u003e. У Вас получится следующее:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage first;\n\npublic class AplusB {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass ABsumma {\n\n\tABsumma() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tin.useLocale(Locale.US);\n\t\ta \u003d in.nextDouble();\n\t\tb \u003d in.nextDouble();\n\t\tin.close();\n\t}\n\n\tdouble solve() {\n\t\tdouble res \u003d a + b; \n\t\treturn res;\n\t}\n\n\tdouble a;\n\tdouble b;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e10. Теперь напишем метод \u003ccode\u003eprint()\u003c/code\u003e, который будет печатать результат. Этот метод не будет возвращать никакого значения, поэтому его типом будет \u003ccode\u003evoid\u003c/code\u003e (пустой). Для печати мы обратимся к стандартному потоку вывода \u003ccode\u003eSystem.out\u003c/code\u003e (вывод на экран) и его методу \u003ccode\u003eprintln()\u003c/code\u003e (заметим, что метод \u003ccode\u003eprint()\u003c/code\u003e у \u003ccode\u003eSystem.out\u003c/code\u003e отличается от метода \u003ccode\u003eprintln()\u003c/code\u003e тем, что не переводит курсор на следующую строку). \u003cbr /\u003e\u003cbr /\u003e У Вас должно получиться следующее:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage first;\n\npublic class AplusB {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass ABsumma {\n\n\tABsumma() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tin.useLocale(Locale.US);\n\t\ta \u003d in.nextDouble();\n\t\tb \u003d in.nextDouble();\n\t\tin.close();\n\t}\n\n\tdouble solve() {\n\t\tdouble res \u003d a + b; \n\t\treturn res;\n\t}\n\n\tvoid print() {\n\t\tdouble c \u003d solve();\n\t\tSystem.out.println(c);\n\t}\n\n\tdouble a;\n\tdouble b;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗаметим, что допустимо было сразу писать \u003ccode\u003eSystem.out.println(solve())\u003c/code\u003e. \u003c/p\u003e\u003cp\u003e11. Последнее, что мы теперь напишем в нашей программе — это собственно код метода \u003ccode\u003emain()\u003c/code\u003e, который и обеспечит работу нашего класса \u003ccode\u003eABSumma\u003c/code\u003e. Фактически, мы должны создать экземпляр класса \u003ccode\u003eABSumma\u003c/code\u003e, после чего вызвать его метод \u003ccode\u003eprint()\u003c/code\u003e. Метод \u003ccode\u003esolve()\u003c/code\u003e отдельно вызывать не нужно, потому что он вызывается внутри метода \u003ccode\u003eprint()\u003c/code\u003e. Разумеется, в Ваших приложениях могут быть другие методы, которые также будет необходимо вызвать. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage first;\n\npublic class AplusB {\n\n\tpublic static void main(String[] args) {\n\t\tABsumma absum \u003d new ABSumma();\n\t\tabsum.print();\n\t}\n\n}\n\nclass ABsumma {\n\n\tABsumma() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tin.useLocale(Locale.US);\n\t\ta \u003d in.nextDouble();\n\t\tb \u003d in.nextDouble();\n\t\tin.close();\n\t}\n\n\tdouble solve() {\n\t\tdouble res \u003d a + b; \n\t\treturn res;\n\t}\n\n\tvoid print() {\n\t\tdouble c \u003d solve();\n\t\tSystem.out.println(c);\n\t}\n\n\tdouble a;\n\tdouble b;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e12. В меню \u003cem\u003eWindow | Show View\u003c/em\u003e выберите \u003cem\u003eConsole\u003c/em\u003e (внизу будет отображено окно с соответствующим названием). В этом окне Вы будете вводить данные и просматривать полученный результат. \u003cbr /\u003e\u003cbr /\u003e Запустите проект на выполнение (либо кнопка F11 на клавиатуре, либо белая стрелка в зеленом круге на панели инструментов Eclipse). При первом запуске появится окно, в котором будет сообщаться, что некоторые файлы не сохранены. Если Вы поставите галочку в этом окне, файлы всегда будут сохраняться перед запуском. Это стоит сделать :) \u003cbr /\u003e\u003cbr /\u003e Если Вы все сделали правильно, программа внешне себя никак проявлять не будет. Разве что Вы обратите внимание на красный квадратик в окне Console. Введите через пробел два вещественных числа (с разделителем точка), нажмите \u003cem\u003eEnter\u003c/em\u003e и посмотрите на полученный результат. Он должен быть правильным :)\u003c/p\u003e\u003c/div\u003e","tags":["a+b","eclipse","java"]}}