{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1420992265,"rating":608,"authorHandle":"DarthPrince","modificationTimeSeconds":1424260727,"id":15729,"title":"\u003cp\u003eAlgorithm Gym :: Data structures\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eToday I want to introduce you some very very useful data structures.\u003c/p\u003e\u003cp\u003eIn this lecture, we are trying to improve your data structures skills, stay with us and click on \u003cstrong\u003eread more\u003c/strong\u003e. Important data structures :\u003c/p\u003e\u003ch2\u003eTrees\u003c/h2\u003e\u003cp\u003eTrees are one of the most useful data structures.A tree is a connected-acyclic graph.There are too many types of trees, like : rooted trees, weighted trees, directed trees, tries, etc.\u003c/p\u003e\u003ch2\u003ePartial sum\u003c/h2\u003e\u003cp\u003eThere are two types of problems solvable by partial sum.\u003c/p\u003e\u003cp\u003e1.Problems which you are asked to answer some queries about the sum of a part of elements (without modify queries).\u003c/p\u003e\u003cp\u003eSolution of all of this problems are the same. You just need to know how to solve one of them.\u003c/p\u003e\u003cp\u003eExample : You are asked some queries on an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ...\u003ci\u003ea\u003c/i\u003e, \u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Each query give you numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e and you should print \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e + 1\u003c/sub\u003e + ... + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e .\u003c/p\u003e\u003cp\u003eSolution : You need to build another array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e which \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e .\u003c/p\u003e\u003cp\u003e2.Problems which you are asked to perform some queries asking you to modify a part of elements (without printing queries.)\u003c/p\u003e\u003cp\u003eSolution of all of this problems are the same. You just need to know how to solve one of them.\u003c/p\u003e\u003cp\u003eExample : You need to perform some queries on an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ...\u003ci\u003ea\u003c/i\u003e, \u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Each query give you numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003er\u003c/i\u003e\u003c/span\u003e you should increase \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, and then after performing all queries, you should print the whole array.\u003c/p\u003e\u003cp\u003eSolution : You should have another array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e which, all of its members are initially \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, for each query, you should increase \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and decrease \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e .\u003c/p\u003e\u003cp\u003eAn then, for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, starting from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e you should increase \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e. So, final array would be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e .\u003c/p\u003e\u003cp\u003eHard problem of partial sum : \u003ca href\u003d\"/gym/100571/problem/B\"\u003eTroynacci Query\u003c/a\u003e \u003c/p\u003e\u003ch2\u003eDisjoint sets\u003c/h2\u003e\u003cp\u003eDisjoint sets are also useful data structures. Using them is fast and easy. We use theme in many algorithms, like Kruskal\u0027s and Prim\u0027s.\u003c/p\u003e\u003cp\u003eDisjoint sets, or DSU (Disjoint Sets Union) as their name, are sum sets. Imagine we have some boxes and some tools and initially each tool is in one box. Mostly, we are given some queries and ask to merge two boxes or print the members of a box or find which box is some tool in.\u003c/p\u003e\u003cp\u003eFor rest of these, let\u0027s consider that initially there is exactly one tool in a box.That is, we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e tools and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e boxes and initially, tool number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is in box number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFor this propose, we can use so many containers.Like :\u003c/p\u003e\u003ch4\u003eTrees\u003c/h4\u003e\u003cp\u003eTrees are the most useful containers for DSU. For each vertex, we keep it\u0027s parent (and parrent of the root is -1). So, initially are parents are set to -1, and we have queries to find the root of each box(having the root, we can easily find the box\u0027s index) and queries for merging two trees. For better time complexity, every time we want to find the root of each vertex, we set it\u0027s parent to the root for the next queries.And while merging, we always want to minimize the height of the tree, so when we want to merge the boxes, it\u0027s like we put all the tools of the box with fewer tools in the other box.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/31/65/3165fc32c840d79f41985dbc31d03f27cc297c93.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThe best way I\u0027ve seen to code this kind of DSU, is style of \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/bmerry\" title\u003d\"International Grandmaster bmerry\"\u003ebmerry\u003c/a\u003e : (C++)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint root(int v){return par[v] \u0026lt; 0 ? v : (par[v] \u003d root(par[v]));}\nvoid merge(int x,int y){\t//\tx and y are some tools (vertices)\n        if((x \u003d root(x)) \u003d\u003d (y \u003d root(y))     return ;\n\tif(par[y] \u0026lt; par[x])\t// balancing the height of the tree\n\t\tswap(x, y);\n\tpar[x] +\u003d par[y];\n\tpar[y] \u003d x;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn the code above, for each root \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epar\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e equals the negative of number of tools in that box.\u003c/p\u003e\u003ch4\u003eArrays, vectors\u003c/h4\u003e\u003cp\u003eWe keep tools in a vector (or an array) and when we have a query to merge two boxes, we put all the tools of the box with fewer tools in the other box.\u003c/p\u003e\u003cp\u003eThe time complexity is good because for each tool, we take and put it in an other box at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e times (each time the size of the vector will be at least doubled).\u003c/p\u003e\u003cp\u003eSo time complexity would be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e.\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e .\u003c/p\u003e\u003ch4\u003eSets (red-black trees)\u003c/h4\u003e\u003cp\u003eOther way is to keep them in a red-black tree (in C++ it\u0027s \u003ccode\u003eset\u003c/code\u003e). We do exactly like vectors, so time complexity would be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e.\u003ci\u003elog\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e . (One \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e\u003c/span\u003e is for inserting).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblems\u003c/strong\u003e : \u003ca href\u003d\"/group/L1Sf9F4uBt/contest/200499/problem/E\"\u003eHamro and tools\u003c/a\u003e, \u003ca href\u003d\"/gym/100571/problem/F\"\u003eTROY Query\u003c/a\u003e (Join the group \u003ca href\u003d\"/group/L1Sf9F4uBt\"\u003eACM-OI\u003c/a\u003e first)\u003c/p\u003e\u003ch2\u003eTries\u003c/h2\u003e\u003cp\u003eTries are some kind of rooted trees in which each edge has a character on it. Actually, trie is some kind of DFA (Determining Finite Automata). For a bunch of strings, their trie is the smallest rooted tree with a character on each edge and each of these strings can be build by writing down the characters in the path from the root to some node.\u003c/p\u003e\u003cp\u003eIt\u0027s advantage is, LCP (Longest Common Prefix) of two of these strings is the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLCA\u003c/i\u003e\u003c/span\u003e (Lowest Common Ancestor) of their nodes in the trie(a node that we can build the string by writing down the characters in the path from the root to that node).\u003c/p\u003e\u003cp\u003eGenerating the trie :\u003c/p\u003e\u003cp\u003eRoot is vertex number 0 (C++)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint x[MAX_NUMBER_OF_NODES][MAX_ASCII_CODE], next \u003d 1; //initially all numbers in x are -1\nvoid build(string s){\n\tint i \u003d 0, v \u003d 0;\n\twhile(i \u0026lt; s.size()){\n\t\tif(x[v][s[i]] \u003d\u003d -1)\n\t\t\tv \u003d x[v][s[i++]] \u003d next ++;\n\t\telse\n\t\t\tv \u003d x[v][s[i++]];\n\t}\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eProblem\u003c/strong\u003e : \u003ca href\u003d\"/contest/456/problem/D\"\u003eA lot of games\u003c/a\u003e\u003c/p\u003e\u003ch2\u003eSuffix array\u003c/h2\u003e\u003cp\u003eSuffix array is a data structure that helps you sort all the suffixes in lexicography order.\u003c/p\u003e\u003cp\u003eThis array consists of integers, the beginning of suffixes.\u003c/p\u003e\u003cp\u003eThere are two ways to achieve this goal :\u003c/p\u003e\u003cp\u003eOne) Non-deterministic algorithm : Use Robin-Carp and for check if a suffix is lexicographically less than another one, find their \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLCP\u003c/i\u003e\u003c/span\u003e using binary search + hash and then check the next character after their \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLCP\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eCode :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003enamespace HashSuffixArray\n{\n\tconst int\n\t\tMAXN \u003d 1 \u0026lt;\u0026lt; 21;\n\n\ttypedef unsigned long long hash;\n\n\tconst hash BASE \u003d 137;\n\n\tint N;\n\tchar * S;\n\tint sa[MAXN];\n\thash h[MAXN], hPow[MAXN];\n\n\t#define getHash(lo, size) (h[lo] - h[(lo) + (size)] * hPow[size])\n\n\tinline bool sufCmp(int i, int j)\n\t{\n\t\tint lo \u003d 1, hi \u003d min(N - i, N - j);\n\t\twhile (lo \u0026lt;\u003d hi)\n\t\t{\n\t\t\tint mid \u003d (lo + hi) \u0026gt;\u0026gt; 1;\n\t\t\tif (getHash(i, mid) \u003d\u003d getHash(j, mid))\n\t\t\t\tlo \u003d mid + 1;\n\t\t\telse\n\t\t\t\thi \u003d mid - 1;\n\t\t}\n\t\treturn S[i + hi] \u0026lt; S[j + hi];\n\t}\n\n\tvoid buildSA()\n\t{\n\t\tN \u003d strlen(S);\n\t\thPow[0] \u003d 1;\n\t\tfor (int i \u003d 1; i \u0026lt;\u003d N; ++i)\n\t\t\thPow[i] \u003d hPow[i - 1] * BASE;\n\t\th[N] \u003d 0;\n\t\tfor (int i \u003d N - 1; i \u0026gt;\u003d 0; --i)\n\t\t\th[i] \u003d h[i + 1] * BASE + S[i], sa[i] \u003d i;\n\n\t\tstable_sort(sa, sa + N, sufCmp);\n\t}\n\n} // end namespace HashSuffixArray\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTwo) Deterministic algorithm : We sort them \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e(\u003ci\u003eMaxLength\u003c/i\u003e)\u003c/span\u003e steps, in the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e step (counting from \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e), we sort them according to their first \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e characters and put the suffixes whit the same prefix with \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e characters in the same buckets.\u003c/p\u003e\u003cp\u003eCode :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e/*\nSuffix array O(n lg^2 n)\nLCP table O(n)\n*/\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n\nusing namespace std;\n\n#define REP(i, n) for (int i \u003d 0; i \u0026lt; (int)(n); ++i)\n\nnamespace SuffixArray\n{\n\tconst int MAXN \u003d 1 \u0026lt;\u0026lt; 21;\n\tchar * S;\n\tint N, gap;\n\tint sa[MAXN], pos[MAXN], tmp[MAXN], lcp[MAXN];\n\n\tbool sufCmp(int i, int j)\n\t{\n\t\tif (pos[i] !\u003d pos[j])\n\t\t\treturn pos[i] \u0026lt; pos[j];\n\t\ti +\u003d gap;\n\t\tj +\u003d gap;\n\t\treturn (i \u0026lt; N \u0026amp;\u0026amp; j \u0026lt; N) ? pos[i] \u0026lt; pos[j] : i \u0026gt; j;\n\t}\n\n\tvoid buildSA()\n\t{\n\t\tN \u003d strlen(S);\n\t\tREP(i, N) sa[i] \u003d i, pos[i] \u003d S[i];\n\t\tfor (gap \u003d 1;; gap *\u003d 2)\n\t\t{\n\t\t\tsort(sa, sa + N, sufCmp);\n\t\t\tREP(i, N - 1) tmp[i + 1] \u003d tmp[i] + sufCmp(sa[i], sa[i + 1]);\n\t\t\tREP(i, N) pos[sa[i]] \u003d tmp[i];\n\t\t\tif (tmp[N - 1] \u003d\u003d N - 1) break;\n\t\t}\n\t}\n\n\tvoid buildLCP()\n\t{\n\t\tfor (int i \u003d 0, k \u003d 0; i \u0026lt; N; ++i) if (pos[i] !\u003d N - 1)\n\t\t{\n\t\t\tfor (int j \u003d sa[pos[i] + 1]; S[i + k] \u003d\u003d S[j + k];)\n\t\t\t++k;\n\t\t\tlcp[pos[i]] \u003d k;\n\t\t\tif (k)--k;\n\t\t}\n\t}\n} // end namespace SuffixArray\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e(Codes by \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/mukel\" title\u003d\"Expert mukel\"\u003emukel\u003c/a\u003e)\u003c/p\u003e\u003ch2\u003eHeaps\u003c/h2\u003e\u003cp\u003eA heap is a binary rooted tree (a rooted tree that each node has at most 2 children) and each vertex has a value.\u003c/p\u003e\u003cp\u003eHeap property : Heap usually has a property, like the value of each vertex is equal to or greater than the value of its child(ren) (we call this a max heap). We can use heaps in heap sort.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/31/fd/31fd1ddc79071b2a25e1d69686be6857312f0cb5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch2\u003eFibonacci heaps\u003c/h2\u003e\u003cp\u003eA fibonacci heap is a kind of heap with better complexities. We don\u0027t need to know what a fibonacci heap is.C++ already has one, \u003ccode\u003epriority_queue\u003c/code\u003e.\u003c/p\u003e\u003ch2\u003eBinary Search Tree (BST)\u003c/h2\u003e\u003cp\u003eA binary search tree (BST) is a binary rooted tree that every node has a value, and for each node, the value of every node in its left child\u0027s subtree is less than its value and the value of every node in its right child\u0027s subtree is greater than that. Usually we perform some queries on BSTs, like inserting, deleting, asking and ... .\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/1e/59/1e59a444c5f91e9c273813695dad1ae2c611e7be.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eBinary search trees are too useful.\u003c/p\u003e\u003ch2\u003eRed-black trees\u003c/h2\u003e\u003cp\u003eA red-black tree is a kind of BST that after each query, BST will be balanced in such a way that it\u0027s height remains \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eC++ already has a red-black tree inside, \u003ccode\u003eset\u003c/code\u003e .\u003c/p\u003e\u003cp\u003eYou can read about them in C++ references.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/3d/62/3d62ba045affaf36154db2666ab26769ba47ef85.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eUnfortunately, \u003ccode\u003eset\u003c/code\u003e has not any function to find the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e smallest minimum or find the index of an element, bust there is a data structure in C++ with does it in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e(also contains all \u003ccode\u003eset\u003c/code\u003e functions), \u003ccode\u003etree\u003c/code\u003e :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\n#include\u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include\u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\nusing namespace __gnu_pbds;\nusing namespace std;\ntemplate \u0026lt;typename T\u0026gt;\nusing ordered_set \u003d tree\u0026lt;T, null_type, less\u0026lt;T\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt;;\n\nint main(){\n\tordered_set\u0026lt;int\u0026gt;  s;\n\ts.insert(1); \n\ts.insert(3);\n\tcout \u0026lt;\u0026lt; s.order_of_key(2) \u0026lt;\u0026lt; endl; // the number of elements in the s less than 2\n\tcout \u0026lt;\u0026lt; *s.find_by_order(0) \u0026lt;\u0026lt; endl; // print the 0-th smallest number in s(0-based)\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e(Thanks to \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Swift\" title\u003d\"Expert Swift\"\u003eSwift\u003c/a\u003e for syntax \u003ccode\u003eusing\u003c/code\u003e!)\u003c/p\u003e\u003cp\u003eThis works even in C++ 98 !\u003c/p\u003e\u003cp\u003eYou can read more about it, just google \u003ccode\u003esgi STL\u003c/code\u003e.\u003c/p\u003e\u003ch2\u003eSQRT Decomposition\u003c/h2\u003e\u003cp\u003eSuppose we have an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/57/57/5757a312f91a101104cf71f76059189ac5a6cee3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. We partition this array into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e pieces each containing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e elements of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eDoing this, we can do a lot of things in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9a/f4/9af4b06f8f17d32c53609242d0543d6137721ed1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Usually we use them in the problems with modify and ask queries.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblems\u003c/strong\u003e : \u003ca href\u003d\"/problemset/problem/13/E\"\u003eHoles\u003c/a\u003e, \u003ca href\u003d\"/contest/444/problem/C\"\u003eDZY Loves Colors\u003c/a\u003e, RMQ (range minimum query) problem\u003c/p\u003e\u003ch2\u003eSparse Table\u003c/h2\u003e\u003cp\u003eThe main problem that we can solve is RMQ problem, we have an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and some queries. Each query gives you numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e ≤ \u003ci\u003er\u003c/i\u003e\u003c/span\u003e) and you should print the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e + 1\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e .\u003c/p\u003e\u003cp\u003eSolving using Sparse Table : For each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e that \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e and for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e that \u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sup\u003e - 1 ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e, we keep the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sup\u003e - 1\u003c/sub\u003e)\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003est\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e (preprocess) : (code is 0-based)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor(int j \u003d 0;j \u0026lt; MAX_LOG;j++)\n\tfor(int i \u003d 0; i \u0026lt; n;i ++)if(i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt; n)\n\t\tst[i][j] \u003d (j ? min(st[i][j-1], st[i + (1 \u0026lt;\u0026lt; (j-1)) - 1][j-1]): a[i]);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd then for each query, first of all, find the maximum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sup\u003e ≤ \u003ci\u003er\u003c/i\u003e - \u003ci\u003el\u003c/i\u003e + 1\u003c/span\u003e and answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003est\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e][\u003ci\u003ex\u003c/i\u003e], \u003ci\u003est\u003c/i\u003e[\u003ci\u003er\u003c/i\u003e - 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sup\u003e + 1][\u003ci\u003ex\u003c/i\u003e])\u003c/span\u003e .\u003c/p\u003e\u003cp\u003eSo, the main idea of Sparse Table, is to keep the value for each interval of length \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e (for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eYou can use the same idea for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLCA\u003c/i\u003e\u003c/span\u003e problem and so many other problems.\u003c/p\u003e\u003cp\u003eSo preprocess will be in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e.\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e and query will be in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblems\u003c/strong\u003e : \u003ca href\u003d\"/contest/487/problem/B\"\u003eStrip\u003c/a\u003e, \u003ca href\u003d\"/contest/475/problem/D\"\u003eGCDSSQ\u003c/a\u003e, \u003ca href\u003d\"/gym/100570/problem/A\"\u003eLCM Query\u003c/a\u003e .\u003c/p\u003e\u003ch2\u003eHeavy light decomposition\u003c/h2\u003e\u003cp\u003eHeavy light decomposition is a way to partition a tree\u0027s vertices (or edges) in a good way.\u003c/p\u003e\u003cp\u003eIn this kind of decomposition, we have some chains, and each vertex belongs to only one chain.\u003c/p\u003e\u003cp\u003eIf vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is the parent of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e size_of_subtree_of(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e)/2 \u0026lt; size_of_subtree_of(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e), \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e are in a chain and we call the edge \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003euv\u003c/i\u003e\u003c/span\u003e, heavy, otherwise light.\u003c/p\u003e\u003cp\u003eThere is at most one such child for each vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. If we consider the path from any vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e to the root, there will be at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e light edges there (go from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e to the root, every time we see a light edge, size of subtree will be at least doubled). So, the number of chains on the way \u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e .\u003c/p\u003e\u003cp\u003eIn each of these chains, we can contain a container or another data structure like segment tree or etc.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/07/70/07705ddaf2c7328c34266e919af72e037d3a2e41.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem\u003c/strong\u003e : \u003ca href\u003d\"http://usaco.org/index.php?page\u003dviewproblem2\u0026amp;cpid\u003d102\"\u003eGRASS PLANTING\u003c/a\u003e\u003c/p\u003e\u003ch2\u003eFenwick\u003c/h2\u003e\u003cp\u003eSuppose that we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e elements numbered from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFenwick or BIT(Binary Indexed Tree) is a data structure with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e nodes that node number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e has some information about elements in the interval \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e -  \u003ci\u003ei\u003c/i\u003e\u0026amp; - \u003ci\u003ei\u003c/i\u003e, \u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e .\u003c/p\u003e\u003cp\u003eActually, you don\u0027t need to know what each node contains. The only thing you should know, it this (then you can change and convert it) :\u003c/p\u003e\u003cp\u003eWe have an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and all of them are initially \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. We are gives some queries, 1.increase \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eval\u003c/i\u003e\u003c/span\u003e and print \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e .\u003c/p\u003e\u003cp\u003eOnly thing you should know is that how to solve this problem using Fenwick (and then you can change it and solve so many problems).\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/84/7d/847dde9fc9f681f4015162087548faec9970cb32.gif\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eWe perform each query in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e. Code : (1-based)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint fen[MAX_N];\nvoid update(int p,int val){\n\tfor(int i \u003d p;i \u0026lt;\u003d n;i +\u003d i \u0026amp; -i)\n\t\tfen[i] +\u003d val;\n}\nint sum(int p){\n\tint ans \u003d 0;\n\tfor(int i \u003d p;i;i -\u003d i \u0026amp; -i)\n\t\tans +\u003d fen[i];\n\treturn ans;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ePlease note that it should be \u003cstrong\u003e1-based\u003c/strong\u003e. It can\u0027t be done 0-based.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblems\u003c/strong\u003e : \u003ca href\u003d\"http://acm.sgu.ru/problem.php?contest\u003d0\u0026amp;problem\u003d180\"\u003eInversions\u003c/a\u003e, \u003ca href\u003d\"/contest/459/problem/D\"\u003ePashmak and Parmida\u0027s problem\u003c/a\u003e, \u003ca href\u003d\"http://hsin.hr/coci/archive/2008_2009/contest3_tasks.pdf\"\u003eBST\u003c/a\u003e .\u003c/p\u003e\u003ch2\u003eSegment tree\u003c/h2\u003e\u003cp\u003eWe have an array of elements and some queries on intervals. So, we will be glad if we can split this interval to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e intervals that we have actually some information about them.\u003c/p\u003e\u003cp\u003eSegment tree does that for you. Segment tree is a tree that each of it\u0027s nodes belongs to an interval.\u003c/p\u003e\u003cp\u003eRoot of the tree belongs to the interval \u003cspan class\u003d\"tex-span\"\u003e[0, \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e (0-based).\u003c/p\u003e\u003cp\u003eEach node, has 0 or two children. Left and right. If a node\u0027s interval is \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e + 1 ≠ \u003ci\u003er\u003c/i\u003e\u003c/span\u003e, the interval of its children will be \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003emid\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003emid\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e in order where \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f0/12/f012f0aceb04b123e722f7b54391ea2d95722de0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, so the height of this tree will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e .\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/8e/ab/8eab8f368879edb5665c49e85b3f2fb8e3694310.gif\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eEach node has an index, we consider that root has index 1 and the children of a vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e will have indices \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003ex\u003c/i\u003e + 1\u003c/span\u003e in order.\u003c/p\u003e\u003cp\u003eSegment tree is the most useful data structure and every problem solvable by Fenwick is also solvable by Segment tree.\u003c/p\u003e\u003cp\u003eIf the size of the root\u0027s interval is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, segment tree could have up to \u003cspan class\u003d\"tex-span\"\u003e4\u003ci\u003en\u003c/i\u003e\u003c/span\u003e nodes.\u003c/p\u003e\u003cp\u003eTo split an interval to some nodes of this tree, we will act like this : \u003c/p\u003e\u003cp\u003eSuppose that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e is the set of nodes which their union is \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e and no two different nodes in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e have nonempty intersection.\u003c/p\u003e\u003cp\u003eA node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e with interval \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e is in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e if and only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e ≤ \u003ci\u003el\u003c/i\u003e ≤ \u003ci\u003er\u003c/i\u003e ≤ \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e and if it has a parent with interval \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eb\u003c/i\u003e, \u003ci\u003ee\u003c/i\u003e)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026gt; \u003ci\u003el\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e \u0026gt; \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e .\u003c/p\u003e\u003cp\u003eC++ code : \u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;int\u0026gt; s;\nvoid split(int x,int y, int id \u003d 1,int l \u003d 0, int r \u003d n){//\tid is the index of the node\n\tif(x \u0026gt;\u003d r or l \u0026gt;\u003d y)\treturn ;\t// in this case, intersect of [l,r) and [x,y) is empty\n\tif(x \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026lt;\u003d y){\n\t\ts.push_back(id); \n\t\treturn ;\n\t}\n\tint mid \u003d (l+r)/2;\n\tsplit(x,y,id * 2,l,mid);\n\tsplit(x,y,id * 2 + 1,mid,r);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eExample :\u003c/p\u003e\u003cp\u003eWe have an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e queries. There are 2 types of queries.\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u003ci\u003el\u003c/i\u003e \u003ci\u003er\u003c/i\u003e\u003c/span\u003e, Print \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e + 1\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e \u003ci\u003ep\u003c/i\u003e \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, Modify \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, it means \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e .\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eFirst of all we need to build the segment tree, for each node we keep the sum of its interval, for node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e we call it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e, so we should build the initial segment tree.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid build(int id \u003d 1,int l \u003d 0,int r \u003d n){\n\tif(r - l \u0026lt; 2){\t//\tl + 1 \u003d\u003d r\n\t\ts[id] \u003d a[l];\n\t\treturn ;\n\t}\n\tint mid \u003d (l+r)/2;\n\tbuild(id * 2, l, mid);\n\tbuild(id * 2 + 1, mid, r);\n\ts[id] \u003d s[id * 2] + s[id * 2 + 1];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo, before reading the queries, we should call \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebuild\u003c/i\u003e()\u003c/span\u003e .\u003c/p\u003e\u003cp\u003eModify function :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid modify(int p,int x,int id \u003d 1,int l \u003d 0,int r \u003d n){\n\ts[id] +\u003d x - a[p];\n\tif(r - l \u0026lt; 2){\t//\tl \u003d r - 1 \u003d p\n\t\ta[p] \u003d x;\n\t\treturn ;\n\t}\n\tint mid \u003d (l + r)/2;\n\tif(p \u0026lt; mid)\n\t\tmodify(p, x, id * 2, l, mid);\n\telse\n\t\tmodify(p, x, id * 2 + 1, mid, r);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e(We should call \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emodify\u003c/i\u003e(\u003ci\u003ep\u003c/i\u003e,  \u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e)\u003c/p\u003e\u003cp\u003eAsk for sum function :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint sum(int x,int y,int id \u003d 1,int l \u003d 0,int r \u003d n){\n\tif(x \u0026gt;\u003d r or l \u0026gt;\u003d y)\treturn 0;\n\tif(x \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026lt;\u003d y)\treturn s[id];\n\tint mid \u003d (l+r)/2;\n\treturn sum(x, y, id * 2, l, mid) +\n\t       sum(x, y, id * 2 + 1, mid, r);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e(We should call \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e,  \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e)\u003c/p\u003e\u003ch4\u003eLazy propagation\u003c/h4\u003e\u003cp\u003eImagine we have updates on intervals, what should we do ?\u003c/p\u003e\u003cp\u003eExample : \u003c/p\u003e\u003cp\u003eWe have an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e queries. There are 2 types of queries.\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u003ci\u003el\u003c/i\u003e \u003ci\u003er\u003c/i\u003e\u003c/span\u003e, Print \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e + 1\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eI\u003c/i\u003e \u003ci\u003el\u003c/i\u003e \u003ci\u003er\u003c/i\u003e \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e ≤ \u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003er\u003c/i\u003e\u003c/span\u003e, increase \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eWe shouldn\u0027t update all the nodes in this interval, just the maximal ones, then pass it to children when we need. This trick is called \u003cstrong\u003eLazy Propagation\u003c/strong\u003e, so we should have another array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elazy\u003c/i\u003e\u003c/span\u003e (for nodes) which are initially \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e and every time we want to perform increase query, increase \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elazy\u003c/i\u003e[\u003ci\u003eid\u003c/i\u003e]\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eAs above, we also should have an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e for nodes.\u003c/p\u003e\u003cp\u003eSo, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebuild\u003c/i\u003e\u003c/span\u003e function will be same as above. But we need some more functions :\u003c/p\u003e\u003cp\u003eA function to update a node :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid upd(int id,int l,int r,int x){//\tincrease all members in this interval by x\n\tlazy[id] +\u003d x;\n\ts[id] +\u003d (r - l) * x;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eA function to pass the update information to its children :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid shift(int id,int l,int r){//pass update information to the children\n\tint mid \u003d (l+r)/2;\n\tupd(id * 2, l, mid, lazy[id]);\n\tupd(id * 2 + 1, mid, r, lazy[id]);\n\tlazy[id] \u003d 0;// passing is done\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eA function to perform increase queries :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid increase(int x,int y,int v,int id \u003d 1,int l \u003d 0,int r \u003d n){\n\tif(x \u0026gt;\u003d r or l \u0026gt;\u003d y)\treturn ;\n\tif(x \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026lt;\u003d y){\n\t\tupd(id, l, r, v);\n\t\treturn ;\n\t}\n\tshift(id, l, r);\n\tint mid \u003d (l+r)/2;\n\tincrease(x, y, v, id * 2, l, mid);\n\tincrease(x, y, v, id*2+1, mid, r);\n\ts[id] \u003d s[id * 2] + s[id * 2 + 1];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e(We should call \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eincrease\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e \u003ci\u003er\u003c/i\u003e \u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e)\u003c/p\u003e\u003cp\u003eA function to answer to queries asking about the sum :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint sum(int x,int y,int id \u003d 1,int l \u003d 0,int r \u003d n){\n\tif(x \u0026gt;\u003d r or l \u0026gt;\u003d y)\treturn 0;\n\tif(x \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026lt;\u003d y)\treturn s[id];\n\tshift(id, l, r);\n\tint mid \u003d (l+r)/2;\n\treturn sum(x, y, id * 2, l, mid) +\n\t       sum(x, y, id * 2 + 1, mid, r);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e(We should call \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e,  \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblems\u003c/strong\u003e : \u003ca href\u003d\"http://www.spoj.com/problems/GSS1/\"\u003eGSS1\u003c/a\u003e, \u003ca href\u003d\"http://www.spoj.com/problems/GSS3/\"\u003eGSS3\u003c/a\u003e, \u003ca href\u003d\"http://www.spoj.com/problems/MULTQ3\"\u003eMULTQ3\u003c/a\u003e, \u003ca href\u003d\"http://www.spoj.com/problems/DQUERY\"\u003eDQUERY\u003c/a\u003e, \u003ca href\u003d\"http://www.spoj.com/problems/KQUERY\"\u003eKQUERY\u003c/a\u003e, \u003ca href\u003d\"http://www.spoj.com/problems/POSTERS\"\u003ePOSTERS\u003c/a\u003e, \u003ca href\u003d\"http://www.spoj.com/problems/PATULJCI\"\u003ePATULJCI\u003c/a\u003e, \u003ca href\u003d\"/problemset/problem/500/E\"\u003eNew Year Domino\u003c/a\u003e, \u003ca href\u003d\"/problemset/problem/292/E\"\u003eCopying Data\u003c/a\u003e, \u003ca href\u003d\"/problemset/problem/446/C\"\u003eDZY Loves Fibonacci Numbers\u003c/a\u003e, \u003ca href\u003d\"http://www.codechef.com/JAN14/problems/FRBSUM\"\u003eFRBSUM\u003c/a\u003e\u003c/p\u003e\u003ch2\u003ePersistent data structures\u003c/h2\u003e\u003cp\u003eConsider we have some elements, you perform some updates on it and then,and after performing all of them, you want to have the information about the elements, after each update.\u003c/p\u003e\u003cp\u003eFor this propose, you got a data structure and somehow, you save the version of that data structure.\u003c/p\u003e\u003cp\u003eThe most useful data structure for this propose is segment tree, I will explain persistent segment tree and all other data structures (like Fenwick) are like that.\u003c/p\u003e\u003ch4\u003ePersistent segment tree\u003c/h4\u003e\u003cp\u003eExample problem : \u003c/p\u003e\u003cp\u003eWe have an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and at first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e update queries and then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e ask queries which you have to answer online. \u003c/p\u003e\u003cp\u003eEach update query gives you numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and asks you to increase \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e .\u003c/p\u003e\u003cp\u003eEach ask query, gives you three numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e and asks you to print the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e + 1\u003c/sub\u003e + ... + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e after performing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e query.\u003c/p\u003e\u003cp\u003eEach update query, changes the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e nodes in the segment tree, so you should keep rest of nodes (not containing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e) and create \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e new nodes. Totally, you need to have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e.\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e nodes. So, you can not use normal segment\u0027s indexing, you should keep the index of children in the arrays \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIf you update a node, you should assign a new index to its interval (for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e query).\u003c/p\u003e\u003cp\u003eYou should keep an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e[\u003ci\u003eq\u003c/i\u003e]\u003c/span\u003e which gives you the index of the interval of the root ( \u003cspan class\u003d\"tex-span\"\u003e[0, \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e ) after performing each query and a number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eir\u003c/i\u003e \u003d 0\u003c/span\u003e which is its index in the initial segment tree (ans of course, an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[\u003ci\u003eMAX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eNODES\u003c/i\u003e\u003c/sub\u003e]\u003c/span\u003e which is the sum of elements in that node). Also you should have a \u003cem\u003eNEXT_FREE_INDEX \u003d 1\u003c/em\u003e which is always the next free index for a node.\u003c/p\u003e\u003cp\u003eFirst of all, you need to build the initial segment tree :\u003c/p\u003e\u003cp\u003e(In these codes, all arrays and queries are \u003cstrong\u003e0-based\u003c/strong\u003e)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid build(int id \u003d ir,int l \u003d 0,int r \u003d n){\n\tif(r - l \u0026lt; 2){\n\t\ts[id] \u003d a[l];\n\t\treturn ;\n\t}\n\tint mid \u003d (l+r)/2;\n\tL[id] \u003d NEXT_FREE_INDEX ++;\n\tR[id] \u003d NEXT_FREE_INDEX ++;\n\tbuild(L[id], l, mid);\n\tbuild(R[id], mid, r);\n\ts[id] \u003d s[L[id]] + s[R[id]];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e(So, we should call \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebuild\u003c/i\u003e()\u003c/span\u003e )\u003c/p\u003e\u003cp\u003eUpdate function : (its return value, is the index of the interval in the new version of segment tree and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eid\u003c/i\u003e\u003c/span\u003e is the index of old one)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint upd(int p, int v,int id,int l \u003d 0,int r \u003d n){\n\tint ID \u003d  NEXT_FREE_INDEX ++; // index of the node in new version of segment tree\n\tif(r - l \u0026lt; 2){\n\t\ts[ID] \u003d (a[p] +\u003d v);\n\t\treturn ID;\n\t}\n\tint mid \u003d (l+r)/2;\n\tL[ID] \u003d L[id], R[ID] \u003d R[id]; // in case of not updating the interval of left child or right child\n\tif(p \u0026lt; mid)\n\t\tL[ID] \u003d upd(p, v, L[ID], l, mid);\n\telse\n\t\tR[ID] \u003d upd(p, v, R[ID], mid, r);\n\treturn ID;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e(For the first query (with index 0) we should run \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e[0] \u003d \u003ci\u003eupd\u003c/i\u003e(\u003ci\u003ep\u003c/i\u003e,  \u003ci\u003ev\u003c/i\u003e,  \u003ci\u003eir\u003c/i\u003e)\u003c/span\u003e and for the rest of them, for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e query se should run  \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e] \u003d \u003ci\u003eupd\u003c/i\u003e(\u003ci\u003ep\u003c/i\u003e,  \u003ci\u003ev\u003c/i\u003e,  \u003ci\u003eroot\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e - 1])\u003c/span\u003e )\u003c/p\u003e\u003cp\u003eFunction for ask queries :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint sum(int x,int y,int id,int l \u003d 0,int r \u003d n){\n\tif(x \u0026gt;\u003d r or l \u0026gt;\u003d y)\treturn 0;\n\tif(x \u0026lt;\u003d l \u0026amp;\u0026amp; r \u0026lt;\u003d y)\treturn s[id];\n\tint mid \u003d (l+r)/2;\n\treturn sum(x, y, L[id], l, mid) +\n\t       sum(x, y, R[id], mid, r);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e(So, we should print the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e, \u003ci\u003eroot\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e])\u003c/span\u003e )\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblems\u003c/strong\u003e : \u003ca href\u003d\"/problemset/problem/484/E\"\u003eSign on Fence\u003c/a\u003e, \u003ca href\u003d\"http://www.spoj.com/problems/MKTHNUM/\"\u003eMKTHNUM\u003c/a\u003e, \u003ca href\u003d\"http://www.spoj.com/problems/COT/\"\u003eCOT\u003c/a\u003e, \u003ca href\u003d\"/problemset/problem/464/E\"\u003eThe Classic Problem\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["algorithms","data structures","tutorial"]}}