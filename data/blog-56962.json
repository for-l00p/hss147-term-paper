{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1515308006,"rating":0,"authorHandle":"Rafaaaaaaaaaaaam","modificationTimeSeconds":1515308028,"id":56962,"title":"\u003cp\u003eImplementation of string hashing algorithm\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;fstream\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n#include\u0026lt;cstdlib\u0026gt;\n#include\u0026lt;string\u0026gt;\n#include\u0026lt;io.h\u0026gt;\n#include\u0026lt;Windows.h\u0026gt;\nusing namespace std;\nint H0 \u003d 0x6a09e667, H1 \u003d 0xbb67ae85, H2 \u003d 0x3c6ef372, H3 \u003d 0xa54ff53a, H4 \u003d 0x510e527f, H5 \u003d 0x9b05688c, H6 \u003d 0x1f83d9ab, H7 \u003d 0x5be0cd19;\nvoid gethash(string str){\n#define HASH_ROTL(a,b) (((a\u0026gt;\u0026gt;(32-b))\u0026amp;(0x7fffffff\u0026gt;\u0026gt;(31-b)))|(a\u0026lt;\u0026lt;b))\n#define HASH_SR(a,b) ((a\u0026gt;\u0026gt;b)\u0026amp;(0x7fffffff\u0026gt;\u0026gt;(b-1)))\n#define HASH_Ch(x,y,z) ((x\u0026amp;y)^((~x)\u0026amp;z))\n#define HASH_Maj(x,y,z) ((x\u0026amp;y)^(x\u0026amp;z)^(y\u0026amp;z))\n#define HASH_E0(x) (HASH_ROTL(x,30)^HASH_ROTL(x,19)^HASH_ROTL(x,10))\n#define HASH_E1(x) (HASH_ROTL(x,26)^HASH_ROTL(x,21)^HASH_ROTL(x,7))\n#define HASH_O0(x) (HASH_ROTL(x,25)^HASH_ROTL(x,14)^HASH_SR(x,3))\n#define HASH_O1(x) (HASH_ROTL(x,15)^HASH_ROTL(x,13)^HASH_SR(x,10))\n\tint l, i, W[64], T1, T2, A, B, C, D, E, F, G, H;\n\tint K[64] \u003d {0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};\n\tlong long len \u003d str.length();\n\tl \u003d len + ((len \u0026amp; 63) \u0026gt;\u003d 56?128 - (len \u0026amp; 63):64 - (len \u0026amp; 63));\n\tchar* x \u003d new char[l];\n\tfor(i \u003d 0; i \u0026lt; len; i++)x[i + 3 - ((i \u0026amp; 3)\u0026lt;\u0026lt; 1)] \u003d str[i];\n\tfor(x[i + 3 - 2 * (i \u0026amp; 3)] \u003d 128, i++; i \u0026lt; l; i++)x[i + 3 - 2 * (i \u0026amp; 3)] \u003d 0;\n\t*((int*)(x + l - 4)) \u003d len \u0026lt;\u0026lt; 3;\n\t*((int*)(x + l - 8)) \u003d len \u0026gt;\u0026gt; 29;\n\tfor(char* y \u003d x + l; x \u0026lt; y; x +\u003d 64){\n\t\tfor(i \u003d 0; i \u0026lt; 16; W[i] \u003d ((int*)x)[i], i++);\n\t\tfor(i \u003d 16; i \u0026lt; 64; W[i] \u003d (HASH_O1(W[i - 2]) + W[i - 7] + HASH_O0(W[i - 15]) + W[i - 16]), i++);\n\t\tA \u003d H0, B \u003d H1, C \u003d H2, D \u003d H3, E \u003d H4, F \u003d H5, G \u003d H6, H \u003d H7;\n\t\tfor(i \u003d 0; i \u0026lt; 64; i++){\n\t\t\tT1 \u003d H + HASH_E1(E) + HASH_Ch(E, F, G) + K[i] + W[i];\n\t\t\tT2 \u003d HASH_E0(A) + HASH_Maj(A, B, C);\n\t\t\tH \u003d G, G \u003d F, F \u003d E, E \u003d D + T1, D \u003d C, C \u003d B, B \u003d A, A \u003d T1 + T2;\n\t\t}\n\t\tH0 +\u003d A, H1 +\u003d B, H2 +\u003d C, H3 +\u003d D, H4 +\u003d E, H5 +\u003d F, H6 +\u003d G, H7 +\u003d H;\n\t}\n}\nvoid encrypt(string fIn, string fOut, int check, int initial, int power, int modulus){\n\tifstream fin(fIn, ifstream::in|ifstream::binary);\n\tif(!fin){\n\t\tputs(\u0026quot;something wrong.\u0026quot;);\n\t\treturn;\n\t}\n\tofstream fout(fOut, ofstream::out|ofstream::binary);\n\tif(!fout){\n\t\tputs(\u0026quot;something wrong.\u0026quot;);\n\t\treturn;\n\t}\n\tfout.write((const char*)\u0026amp;check, 4);\n\tint a\u003dabs(initial), p\u003dabs(power), m\u003dabs(modulus);\n\twhile(1){\n\t\tchar c\u003dfin.get();\n\t\tif(c\u003d\u003dEOF)break;\n\t\ta\u003d(1ll*a*p+c+388)%m;\n\t\tfout.write((const char*)\u0026amp;a, 4);\n\t}\n\tfin.close();\n\tfout.close();\n\tputs(\u0026quot;everything ok.\u0026quot;);\n}\nvoid decrypt(string fIn, string fOut, int check, int initial, int power, int modulus){\n\tifstream fin(fIn, ifstream::in|ifstream::binary);\n\tif(!fin){\n\t\tputs(\u0026quot;something wrong.\u0026quot;);\n\t\treturn;\n\t}\n\tofstream fout(fOut, ofstream::out|ofstream::binary);\n\tif(!fout){\n\t\tputs(\u0026quot;something wrong.\u0026quot;);\n\t\treturn;\n\t}\n\tint check2;\n\tfin.read((char*)\u0026amp;check2, 4);\n\tif(check2!\u003dcheck){\n\t\tputs(\u0026quot;something wrong.\u0026quot;);\n\t\treturn;\n\t}\n\tint a\u003dabs(initial), b, p\u003dabs(power), m\u003dabs(modulus);\n\twhile(fin.read((char*)\u0026amp;b, 4)){\n\t\ta\u003d((b-1ll*a*p)%m+m)%m-388;\n\t\tfout.write((const char*)\u0026amp;a, 1);\n\t\ta\u003db;\n\t}\n\tfin.close();\n\tfout.close();\n\tputs(\u0026quot;everything ok.\u0026quot;);\n}\nint main(){\n\tstring pwd, fdat, ftxt;\n\tcin\u0026gt;\u0026gt;pwd;\n\tgethash(pwd);\n\tif(H0+0x72d907bc)return 0;\n\tif(~_access(\u0026quot;config.ini\u0026quot;, 4)){\n\t\tfreopen(\u0026quot;config.ini\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t}\n\tcin\u0026gt;\u0026gt;fdat\u0026gt;\u0026gt;ftxt;\n\twstring path \u003d L\u0026quot;c:\\\\Windows\\\\system32\\\\notepad.exe \u0026quot; + wstring(ftxt.begin(),ftxt.end());\n\tdecrypt(fdat, ftxt, H1, H2, H3, H4);\n\tSTARTUPINFO si\u003d{sizeof(si)};\n\tPROCESS_INFORMATION pi;\n\tCreateProcess(0, (LPWSTR)path.c_str(), 0, 0, 0, 0, 0, 0, \u0026amp;si, \u0026amp;pi);\n\tWaitForSingleObject(pi.hProcess, INFINITE);\n\tCloseHandle(pi.hProcess);\n\tencrypt(ftxt, fdat, H1, H2, H3, H4);\n\tremove(ftxt.c_str());\n\tputs(\u0026quot;file remove ok.\u0026quot;);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}