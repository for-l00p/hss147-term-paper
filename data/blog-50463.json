{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1487245777,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1489012531,"id":50463,"title":"\u003cp\u003eОдномерные массивы: принцип \u0026quot;скользящего окна\u0026quot;\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eМетод \u0026quot;скользящего окна\u0026quot; или метод \u0026quot;двух указателей\u0026quot; — достаточно удобная техника, позволяющая эффективно обрабатывать элементы массива. Рассмотрим эту технику на примерах. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPDATE: Примеров теперь два\u003c/strong\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eНас может интересовать некоторая \u0026quot;обобщенная\u0026quot; информация о подотрезках массива. Например, есть массив, в котором ежедневно записывается расход воды (можете предполагать, что это данные, автоматически формируемые счётчиком). Эти записи велись в течение года, а теперь нас интересует максимальный расход за неделю. \u003c/p\u003e\u003cp\u003eПонятно, что мы должны посчитать сумму за каждые семь подряд идущих дней и найти максимум среди таких значений. Также понятно, что после подсчета суммы за первые семь дней последующие вычисления можно вести по принципу \u0026quot;вычтем самый ранний день, учтённый в текущей сумме, и добавим новый\u0026quot;. Можно представить себе, что у нас есть \u0026quot;окно\u0026quot; длиной в семь элементов, которое мы на каждом шаге сдвигаем на один элемент (потому и \u0026quot;скользящее окно\u0026quot;). \u003c/p\u003e\u003cp\u003eРазумеется, у этой техники есть и другие варианты — например, когда длина окна не фиксируется, а может меняться в зависимости от некоторых факторов. \u003c/p\u003e\u003cp\u003eРассмотрим следующую задачу. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача \u0026quot;Курсы\u0026quot;.\u003c/strong\u003e \u003c/p\u003e\u003cp\u003eПетя посещает курсы интенсивного изучения иностранного языка. Каждый день преподаватель выставляет оценку — excellent, good или satisfactory. Ради простоты будем считать, что это 5, 4 и 3 (двоек не бывает по причине высокой заинтересованности учащихся в результате). \u003c/p\u003e\u003cp\u003eПетя хочет похвалиться другу Васе своей успеваемостью. С начала курсов прошло \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e дней, а на экране ноутбука одновременно можно показать оценки за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e подряд идущих дней. Петя хотел бы показать лучшие (с его точки зрения) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e дней — те \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e дней, в течение которых он получил больше всего оценок 5. Если можно выбрать \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e таких дней не единственным способом, Петя хотел бы показать те \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e дней, в течение которых он получил меньше оценок 3. Если и в этом случае можно выбрать \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e дней несколькими способами, подойдёт любой ответ. \u003c/p\u003e\u003cp\u003eВ первой строке входных данных будут содержаться целые числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(1 ≤ \u003ci\u003em\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e ≤ 1000)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eВо второй строке будет содержаться \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e целых чисел (3, 4, 5) через пробел — оценки, полученные Петей в соответствующие дни.\u003c/p\u003e\u003cp\u003eВ качестве ответа выведите в первой строке номер дня, с которого Петя должен начинать показывать свои результаты, а во второй строке — количество пятёрок и троек, которые увидит Вася. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eРешение\u003c/strong\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003epublic class ProblemEngC {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОпишем класс \u003ccode\u003eCourses\u003c/code\u003e, объявив в нём переменные \u003ccode\u003en\u003c/code\u003e, \u003ccode\u003em\u003c/code\u003e и \u003ccode\u003emarks\u003c/code\u003e — массив оценок. Организуем в конструкторе этого класса считывание всех данных со стандартного ввода (как прочитать массив — см., например, п.3 предыдущей записи):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eimport java.util.Scanner;\n\npublic class ProblemEngC {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass Courses {\n\t\n\tCourses() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tm \u003d in.nextInt();\n\t\t\n\t\tmarks \u003d new int[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t\tmarks[i] \u003d in.nextInt();\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tint n;\n\tint m;\n\tint [] marks;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТеперь заметим следующее. Если бы нам было достаточно просто найти максимальное количество оценок 5, которые получил Петя за какие-либо \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e дней — нам было бы достаточно поддерживать их количество при переходе к следующему элементу массива. Однако Петя хотел бы указать начальную позицию, с которой он будет демонстрировать Васе свои успехи. Поэтому заведём дополнительный массив \u003ccode\u003estart\u003c/code\u003e, в котором и будем хранить количество отличных оценок, которые Петя может показать, если начнет показывать именно с позиции \u003ccode\u003estart[i]\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eОднако только этого массива нам всё же недостаточно — ведь Петя хочет показать такие \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e дней, в которые он не просто получил больше всего пятёрок, но в которые (при равном максимально возможном количестве пятёрок) он еще и получил меньше всего троек. Поэтому заведём ещё массив \u003ccode\u003eworst\u003c/code\u003e, в котором будем хранить количество троек, полученных в течение соответствующих \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e дней. \u003c/p\u003e\u003cp\u003eТакже напишем метод \u003ccode\u003eprepare()\u003c/code\u003e, в котором выделим память под массивы \u003ccode\u003estart\u003c/code\u003e и \u003ccode\u003eworst\u003c/code\u003e, а также посчитаем количество пятёрок и троек в первые \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e дней (это будут нулевые элементы указанных массивов):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eimport java.util.Scanner;\n\npublic class ProblemEngC {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass Courses {\n\t\n\tCourses() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tm \u003d in.nextInt();\n\t\t\n\t\tmarks \u003d new int[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t\tmarks[i] \u003d in.nextInt();\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tvoid prepare() {\n\t\tstart \u003d new int[n-m];\n\t\tworst \u003d new int[n-m];\n\t\t\n\t\tfor (int i \u003d 0; i \u0026lt; m; i++){\n\t\t\tswitch(marks[i]) {\n\t\t\tcase 3: worst[0]++; break;\n\t\t\tcase 5: start[0]++; break;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint n;\n\tint m;\n\tint [] marks;\n\t\n\tint[] start;\n\tint[] worst;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТеперь напишем метод solve(), который и реализует логику \u0026quot;скольжения\u0026quot;: проверяем, какой элемент мы убираем из рассмотрения, и при необходимости изменяем значения величин, отвечающих за пятёрки или тройки; затем проверяем добавляемый элемент. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eimport java.util.Scanner;\n\npublic class ProblemEngC {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass Courses {\n\t\n\tCourses() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tm \u003d in.nextInt();\n\t\t\n\t\tmarks \u003d new int[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t\tmarks[i] \u003d in.nextInt();\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tvoid prepare() {\n\t\tstart \u003d new int[n-m+1];\n\t\tworst \u003d new int[n-m+1];\n\t\t\n\t\tfor (int i \u003d 0; i \u0026lt; m; i++){\n\t\t\tswitch(marks[i]) {\n\t\t\tcase 3: worst[0]++; break;\n\t\t\tcase 5: start[0]++; break;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid solve() {\n\t\t\n\t\tfor (int i \u003d m; i \u0026lt; n; i++){\n\t\t\tstart[i-m+1] \u003d start[i-m];\n\t\t\tworst[i-m+1] \u003d worst[i-m];\n\t\t\t\n\t\t\tswitch(marks[i-m]) {\n\t\t\tcase 3: worst[i-m+1]--; break;\n\t\t\tcase 5: start[i-m+1]--; break;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(marks[i]){\n\t\t\tcase 3: worst[i-m+1]++; break;\n\t\t\tcase 5: start[i-m+1]++; break;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\t\n\t}\n\t\n\tint n;\n\tint m;\n\tint [] marks;\n\t\n\tint[] start;\n\tint[] worst;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбратите внимание, что для оценки \u003ccode\u003emarks[i]\u003c/code\u003e мы записываем результат в \u003ccode\u003estart[i-m+1]\u003c/code\u003e и \u003ccode\u003eworst[i-m+1]\u003c/code\u003e: эта оценка будет последней для анализируемых нами \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e дней, а массивы \u003ccode\u003estart\u003c/code\u003e и \u003ccode\u003eworst\u003c/code\u003e хранят количество соответствующих оценок, начиная с некоторого дня \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003esolve()\u003c/code\u003e пока ещё не завершён: ведь теперь нам нужно найти максимальное значение в массиве \u003ccode\u003estart\u003c/code\u003e, а при равных значениях сохранять то, для которого соответствующее значение в массиве \u003ccode\u003eworst\u003c/code\u003e меньше. Номер соответствующего дня будем хранить в переменной \u003ccode\u003etheBestDay\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eДопишем этот фрагмент в метод \u003ccode\u003esolve()\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eimport java.util.Scanner;\n\npublic class ProblemEngC {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass Courses {\n\t\n\tCourses() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tm \u003d in.nextInt();\n\t\t\n\t\tmarks \u003d new int[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t\tmarks[i] \u003d in.nextInt();\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tvoid prepare() {\n\t\tstart \u003d new int[n-m+1];\n\t\tworst \u003d new int[n-m+1];\n\t\t\n\t\tfor (int i \u003d 0; i \u0026lt; m; i++){\n\t\t\tswitch(marks[i]) {\n\t\t\tcase 3: worst[0]++; break;\n\t\t\tcase 5: start[0]++; break;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid solve() {\n\t\t\n\t\tfor (int i \u003d m; i \u0026lt; n; i++){\n\t\t\tstart[i-m+1] \u003d start[i-m];\n\t\t\tworst[i-m+1] \u003d worst[i-m];\n\t\t\t\n\t\t\tswitch(marks[i-m]) {\n\t\t\tcase 3: worst[i-m+1]--; break;\n\t\t\tcase 5: start[i-m+1]--; break;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(marks[i]){\n\t\t\tcase 3: worst[i-m+1]++; break;\n\t\t\tcase 5: start[i-m+1]++; break;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\ttheBestDay \u003d 0; \n\t\t\n\t\tfor (int i \u003d 1; i \u0026lt; n-m+1; i++){\n\t\t\tif (start[i] \u0026gt; start[theBestDay]) {\n\t\t\t\ttheBestDay \u003d i;\n\t\t\t}\n\t\t\telse if (start[i] \u003d\u003d start[theBestDay]){\n\t\t\t\tif (worst[i] \u0026lt; worst[theBestDay]) {\n\t\t\t\t\ttheBestDay \u003d i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tint n;\n\tint m;\n\tint [] marks;\n\t\n\tint[] start;\n\tint[] worst;\n\t\n\tint theBestDay;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВсё, что нам осталось написать в классе \u003ccode\u003eCourses\u003c/code\u003e — это метод \u003ccode\u003eprint\u003c/code\u003e, выводящий ответ. Вероятно, он не нуждается в комментариях, кроме лишь того, что при выводе мы добавляем к номеру дня единицу, чтобы поддержать 1-based нумерацию:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eimport java.util.Scanner;\n\npublic class ProblemEngC {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass Courses {\n\t\n\tCourses() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tm \u003d in.nextInt();\n\t\t\n\t\tmarks \u003d new int[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t\tmarks[i] \u003d in.nextInt();\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tvoid prepare() {\n\t\tstart \u003d new int[n-m+1];\n\t\tworst \u003d new int[n-m+1];\n\t\t\n\t\tfor (int i \u003d 0; i \u0026lt; m; i++){\n\t\t\tswitch(marks[i]) {\n\t\t\tcase 3: worst[0]++; break;\n\t\t\tcase 5: start[0]++; break;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid solve() {\n\t\t\n\t\tfor (int i \u003d m; i \u0026lt; n; i++){\n\t\t\tstart[i-m+1] \u003d start[i-m];\n\t\t\tworst[i-m+1] \u003d worst[i-m];\n\t\t\t\n\t\t\tswitch(marks[i-m]) {\n\t\t\tcase 3: worst[i-m+1]--; break;\n\t\t\tcase 5: start[i-m+1]--; break;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(marks[i]){\n\t\t\tcase 3: worst[i-m+1]++; break;\n\t\t\tcase 5: start[i-m+1]++; break;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\ttheBestDay \u003d 0; \n\t\t\n\t\tfor (int i \u003d 1; i \u0026lt; n-m+1; i++){\n\t\t\tif (start[i] \u0026gt; start[theBestDay]) {\n\t\t\t\ttheBestDay \u003d i;\n\t\t\t}\n\t\t\telse if (start[i] \u003d\u003d start[theBestDay]){\n\t\t\t\tif (worst[i] \u0026lt; worst[theBestDay]) {\n\t\t\t\t\ttheBestDay \u003d i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tvoid print() {\n\t\tSystem.out.println(theBestDay+1);\n\t\tSystem.out.println(start[theBestDay] + \u0026quot; \u0026quot; + worst[theBestDay]);\n\t}\n\t\n\tint n;\n\tint m;\n\tint [] marks;\n\t\n\tint[] start;\n\tint[] worst;\n\t\n\tint theBestDay;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНаконец, запишем код в методе \u003ccode\u003emain()\u003c/code\u003e класса \u003ccode\u003eProblem05\u003c/code\u003e. Итоговый код будет иметь следующий вид:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eimport java.util.Scanner;\n\npublic class ProblemEngC {\n\n\tpublic static void main(String[] args) {\n\t\tCourses courses \u003d new Courses();\n\t\tcourses.prepare();\n\t\tcourses.solve();\n\t\tcourses.print();\n\t}\n\n}\n\nclass Courses {\n\t\n\tCourses() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tm \u003d in.nextInt();\n\t\t\n\t\tmarks \u003d new int[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t\tmarks[i] \u003d in.nextInt();\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tvoid prepare() {\n\t\tstart \u003d new int[n-m+1];\n\t\tworst \u003d new int[n-m+1];\n\t\t\n\t\tfor (int i \u003d 0; i \u0026lt; m; i++){\n\t\t\tswitch(marks[i]) {\n\t\t\tcase 3: worst[0]++; break;\n\t\t\tcase 5: start[0]++; break;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid solve() {\n\t\t\n\t\tfor (int i \u003d m; i \u0026lt; n; i++){\n\t\t\tstart[i-m+1] \u003d start[i-m];\n\t\t\tworst[i-m+1] \u003d worst[i-m];\n\t\t\t\n\t\t\tswitch(marks[i-m]) {\n\t\t\tcase 3: worst[i-m+1]--; break;\n\t\t\tcase 5: start[i-m+1]--; break;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(marks[i]){\n\t\t\tcase 3: worst[i-m+1]++; break;\n\t\t\tcase 5: start[i-m+1]++; break;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\ttheBestDay \u003d 0; \n\t\t\n\t\tfor (int i \u003d 1; i \u0026lt; n-m+1; i++){\n\t\t\tif (start[i] \u0026gt; start[theBestDay]) {\n\t\t\t\ttheBestDay \u003d i;\n\t\t\t}\n\t\t\telse if (start[i] \u003d\u003d start[theBestDay]){\n\t\t\t\tif (worst[i] \u0026lt; worst[theBestDay]) {\n\t\t\t\t\ttheBestDay \u003d i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tvoid print() {\n\t\tSystem.out.println(theBestDay+1);\n\t\tSystem.out.println(start[theBestDay] + \u0026quot; \u0026quot; + worst[theBestDay]);\n\t}\n\t\n\tint n;\n\tint m;\n\tint [] marks;\n\t\n\tint[] start;\n\tint[] worst;\n\t\n\tint theBestDay;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПротестируйте полученное решение на следующих наборах данных:\u003c/p\u003e\u003cp\u003e\u003ccode\u003e 20 7 \u003c/code\u003e \u003cbr /\u003e \u003ccode\u003e 4 3 5 5 3 5 3 3 4 4 4 5 5 4 4 3 4 5 3 5 \u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003e 20 7 \u003c/code\u003e \u003cbr /\u003e \u003ccode\u003e 4 3 5 4 3 5 4 3 5 4 3 5 5 4 4 3 4 5 3 5 \u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003e 20 7 \u003c/code\u003e \u003cbr /\u003e \u003ccode\u003e 4 3 5 5 3 5 3 3 5 4 4 5 5 4 4 3 4 5 3 5 \u003c/code\u003e\u003c/p\u003e\u003cp\u003eПредложите свои тесты.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача \u0026quot;Выставка\u0026quot;\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eНа выставке представлены \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e экспонатов. Они расположены в линию, один за другим. Вася попросил Петю составить ему компанию при посещении выставки. Петя хорошо знает вкусы Васи, поэтому для каждого экспоната \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e может заранее оценить впечатление \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, которое этот экспонат произведёт на Васю (это впечатление может быть и отрицательным). Петя хочет, чтобы у Васи осталось как можно лучшее впечатление от выставки. Ради этого он даже готов уговорить Васю начать осмотр выставки не с самого начала и завершить осмотр не на самом последнем экспонате. Пропускать экспонаты Вася не согласится.\u003c/p\u003e\u003cp\u003eВаша задача — определить, с какого по какой экспонат Вася должен осматривать выставку, чтобы получить максимально возможное суммарное впечатление от выставки. Если задача допускает несколько решений, выведите любое.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eРешение\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eОбсудим, как решать эту задачу. Её главное отличие от предыдущей — мы не можем выдвинуть заранее никаких предположений о количестве экспонатов, которые следует осмотреть Васе. \u003c/p\u003e\u003cp\u003e\u0026quot;Нулевая версия\u0026quot; решения может быть такой. Выберем в качестве стартовой позиции первый экспонат выставки и, двигаясь от него, будем подсчитывать сумму впечатлений (сохраняя максимальное значение и позицию, на которой оно было достигнуто). Затем выберем в качестве стартовой позиции второй экспонат выставки и повторим описанное выше. Далее попробуем стартовать с третьего экспоната...\u003c/p\u003e\u003cp\u003eКак можно оценить, это решение будет иметь сложность \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e — количество экспонатов. Если число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e будет порядка \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e, такое решение будет работать очень долго.\u003c/p\u003e\u003cp\u003eЧтобы сделать решение более быстрым, попробуем себе представить процесс осмотра и накопления впечатлений. \u003c/p\u003e\u003cp\u003eБудем хранить суммарное впечатление Васи в переменной \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, которая сначала равна нулю. Пусть Вася начал осматривать выставку с экспоната \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e. Пусть впечатление от этого экспоната составляет \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sub\u003e\u003c/span\u003e. Вполне понятно, что если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sub\u003e ≤ 0\u003c/span\u003e, то Васе совершенно точно нет смысла начинать с этого экспоната: если он его пропустит, результат (суммарное впечатление) как минимум не ухудшится. Так что будем полагать, что \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sub\u003e \u0026gt; 0\u003c/span\u003e, и суммарное впечатление станет равным этому числу: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eТеперь Вася перейдёт к экспонату \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + 1\u003c/span\u003e. Суммарное впечатление от двух осмотренных экспонатов будет \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + 1\u003c/sub\u003e\u003c/span\u003e. Заметим, что оно может оказаться и меньше, чем предыдущее значение — если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + 1\u003c/sub\u003e \u0026lt; 0\u003c/span\u003e. Однако терпение Васи может быть вознаграждено, если дальше ему попадётся экспонат, для которого окажется, что \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + 1\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + 2\u003c/sub\u003e\u003c/span\u003e будет больше любого из двух предыдущих значений. Это возможно, если предыдущее значение суммы \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e было положительным, а добавление \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + 2\u003c/sub\u003e\u003c/span\u003e \u0026quot;перекрыло\u0026quot; потерю на предыдущем экспонате (например, величины впечатлений были 4, -2, 3; сумма будет 5). \u003c/p\u003e\u003cp\u003eНемного поразмышляв, можем прийти к следующему выводу: если после осмотра нескольких экспонатов сумма впечатлений остается положительной, есть шанс, что \u0026quot;в светлом будущем\u0026quot; она даст дополнительный вклад в максимально возможную сумму впечатлений. Если в какой-то момент сумма впечатлений становится отрицательной, то этот фрагмент экспозиции лучше не осматривать вовсе: общую сумму такое слагаемое может только ухудшить. \u003c/p\u003e\u003cp\u003eТаким образом, в качестве \u0026quot;улучшенной версии\u0026quot; решения можем предложить следующее. Выберем в качестве стартовой позиции первый экспонат выставки и, двигаясь от него, будем подсчитывать сумму впечатлений (сохраняя максимальное значение и позицию, на которой оно было достигнуто). Как только эта сумма перестанет быть положительной, будем прерывать процесс её накопления и переходить к выбору новой стартовой позиции. \u003c/p\u003e\u003cp\u003eЭтот подход избавит нас от части \u0026quot;лишних действий\u0026quot;, но радикальными эти улучшения назвать ещё нельзя: при выборе очередной стартовой позиции мы не используем результаты предыдущих подсчётов. Как это можно сделать? Предположим, что, стартовав с первого экспоната и накапливая сумму впечатлений, в некоторый момент мы получили \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e ≤ 0\u003c/span\u003e. Запомним эту позицию (пусть это некоторое значение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e) и будем изменять накопленную сумму, последовательно \u003cem\u003eвычитая\u003c/em\u003e из неё впечатления от первого, второго и т.д. экспонатов, пока она не станет положительной. Как только это произойдёт, запомним позицию первого экспоната, который остался в сумме (пусть это \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e), после чего продолжим \u0026quot;движение\u0026quot; от \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eДействительно, мы ничего не пропустим. Если мы исключили из рассмотрения первый экспонат, и при этом сумма впечатлений, накопленная при осмотре экспонатов вплоть до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, осталась отрицательной, то это значит, что, стартуя от второго экспоната, мы остановились бы либо на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, либо на более раннем экспонате. Первый экспонат, очевидно, вносил положительный вклад в общую сумму (если бы это было не так, он был бы исключен сразу), поэтому сумма впечатлений на отрезке \u003cspan class\u003d\"tex-span\"\u003e[1..\u003ci\u003ez\u003c/i\u003e ≤ \u003ci\u003ez\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e]\u003c/span\u003e будет больше, чем сумма впечатлений на отрезке \u003cspan class\u003d\"tex-span\"\u003e[2..\u003ci\u003ez\u003c/i\u003e ≤ \u003ci\u003ez\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e]\u003c/span\u003e. Это означает, что мы не будем рассматривать суммы, заведомо меньшие уже вычисленных. Аналогичные рассуждения можно провести и для третьего экспоната, и для всех последующих вплоть до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e - 1\u003c/span\u003e-го. \u003c/p\u003e\u003cp\u003eЗафиксировав позицию \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, мы будем двигаться вправо уже от \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e до тех пор, пока сумма впечатлений вновь не перестанет быть положительной, после чего запомним эту позицию \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e и найдём новую позицию \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e в качестве стартовой. \u003c/p\u003e\u003cp\u003eКак несложно видеть, при таком подходе мы не более чем дважды пройдём по каждому элементу последовательности экспонатов (а это улучшает сложность решения до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e). \u003c/p\u003e\u003cp\u003eПриведём фрагмент псевдокода, который выполняет описанные действия. Обратите внимание — мы не \u0026quot;избавляемся\u0026quot; от нулевых сумм (это можно сделать, но решение получится чуть более длинным). Ответом будет отрезок \u003ccode\u003e[bestStart, bestFinish)\u003c/code\u003e (или, что то же самое, \u003ccode\u003e[bestStart, bestFinish-1]\u003c/code\u003e). Если впечатления от всех экспонатов будут отрицательными, лучшим выходом будет не осматривать их вовсе (и отрезка-ответа не существует; этот случай при выводе ответа надо рассматривать отдельно).\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003ebestStart \u003d 0;\nbestFinish \u003d 0;\n\nbestSum \u003d 0;\n\nstart \u003d 0;\nfinish \u003d 0;\n\nsum \u003d 0;\n\nwhile ((start \u0026lt; n) \u0026amp;\u0026amp; (finish \u0026lt; n)) {\n    if (sum \u0026gt;\u003d 0) {\n        sum \u003d sum + a[finish];\n        finish++;\n\n        if (sum \u0026gt; bestSum) {\n            bestSum \u003d sum;\n            bestStart \u003d start;\n            bestFinish \u003d finish;\n        }\n    }\n    else { // sum \u0026lt; 0\n        sum \u003d sum - a[start];\n        start++;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбратите внимание: на каждой итерации цикла мы выполняем только одно действие: либо увеличиваем \u003ccode\u003efinish\u003c/code\u003e, либо увеличиваем \u003ccode\u003estart\u003c/code\u003e, соответствующим образом изменяя сумму. Если сумма на некотором шаге имеет неотрицательное значение, мы её не только накапливаем, но и сравниваем с \u003ccode\u003ebestSum\u003c/code\u003e. Дополнительно контролировать, сравниваем ли мы с \u003ccode\u003ebestSum\u003c/code\u003e положительное число, нет необходимости: начальным значением \u003ccode\u003ebestSum\u003c/code\u003e является \u003ccode\u003e0\u003c/code\u003e, поэтому проблем не возникнет.\u003c/p\u003e\u003ch4\u003eЗадачи для решения в аудитории и дома:\u003c/h4\u003e\u003cp\u003e\u003cem\u003e(Напоминание: при сдаче задачи в тестирующую систему не забудьте закомментировать строку с \u003ccode\u003epackage\u003c/code\u003e, если у вас такая есть)\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/40HeBOdG5d/contest/100898\"\u003eТренировочное соревнование (одномерные массивы — 2)\u003c/a\u003e \u003c/p\u003e\u003cp\u003eА также задачи с acm.timus.ru\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1370\"\u003e1370 Волшебник\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1021\"\u003e1021 Таинство суммы\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1998\"\u003e1998 Старый падаван\u003c/a\u003e\u003c/p\u003e\u003cp\u003eНебольшие подсказки:\u003c/p\u003e\u003cp\u003eВ задаче 1021 следует воспользоваться тем фактом, что оба массива упорядочены.\u003c/p\u003e\u003cp\u003eЗадача 1998, вероятно, заметно сложнее двух предыдущих задач.\u003c/p\u003e\u003c/div\u003e","tags":["java","arrays"]}}