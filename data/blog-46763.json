{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1472109880,"rating":79,"authorHandle":"Kostroma","modificationTimeSeconds":1472806096,"id":46763,"title":"\u003cp\u003eCodeforces Aim Tech Round 3 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"709A\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eint main() {\n  int n, b, d;\n  std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; b \u0026gt;\u0026gt; d;\n\n  int current_size \u003d 0;\n  int result \u003d 0;\n  int x;\n  for (; n \u0026gt; 0; --n) {\n    std::cin \u0026gt;\u0026gt; x;\n    if (x \u0026gt; b) {\n      continue;\n    }\n    current_size +\u003d x;\n    if (current_size \u0026gt; d) {\n      ++result;\n      current_size \u003d 0;\n    }\n  }\n\n  std::cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"709B\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003econst int MAXN \u003d 100000;\n\nint x[MAXN];\n\nint main() {\n  int n, A;\n  scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;n, \u0026amp;A);\n  if (n \u003d\u003d 1) {\n    printf(\u0026quot;0\\n\u0026quot;);\n    return 0;\n  }\n  for (int i \u003d 0; i \u0026lt; n; i++) {\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;x[i]);\n  }\n  int first_max \u003d -2e6;\n  int second_max \u003d -2e6;\n  int first_min \u003d 2e6;\n  int second_min \u003d 2e6;\n\n  for (int i \u003d 0; i \u0026lt; n; i++) {\n    if (x[i] \u0026gt; second_max) {\n      second_max \u003d x[i];\n      if (second_max \u0026gt; first_max) {\n        swap(second_max, first_max);\n      }\n    }\n    if (x[i] \u0026lt; second_min) {\n      second_min \u003d x[i];\n      if (second_min \u0026lt; first_min) {\n        swap(second_min, first_min);\n      }\n    }\n  }\n  printf(\u0026quot;%d\\n\u0026quot;, min(first_max - second_min + min(abs(A - first_max), abs(A - second_min)),\n                     second_max - first_min + min(abs(A - second_max), abs(A - first_min))));\n\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"708A\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003evoid solve() {\n  string s;\n  cin \u0026gt;\u0026gt; s;\n  for (int i \u003d 0; i \u0026lt; s.length(); ++i) {\n    if (s[i] \u003d\u003d \u0027a\u0027) {\n      continue;\n    }\n    int j \u003d i + 1;\n    while (j \u0026lt; s.length() \u0026amp;\u0026amp; s[j] !\u003d \u0027a\u0027) {\n      ++j;\n    }\n    for (int r \u003d i; r \u0026lt; j; ++r) {\n      --s[r];\n    }\n    cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n    return;\n  }\n\n  s.back() \u003d \u0027z\u0027;\n  cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"708B\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003evoid imp() {\n  cout \u0026lt;\u0026lt; \u0026quot;Impossible\\n\u0026quot;;\n  exit(0);\n}\n\nll invtriange(ll x) {\n  ll l \u003d 1, r \u003d 1000000;\n  while (r - l \u0026gt; 1) {\n    ll m \u003d (l + r) / 2;\n    if (m * (m - 1) / 2 \u0026gt; x) r \u003d m;\n    else l \u003d m;\n  }\n  if (l * (l - 1) / 2 !\u003d x) {\n    imp();\n  }\n  return l;\n}\n\nint main() {\n  vvl a(2, vl(2));\n  for (int i \u003d 0; i \u0026lt; 2; ++i) for (int j \u003d 0; j \u0026lt; 2; ++j) {\n    cin \u0026gt;\u0026gt; a[i][j];\n  }\n  if (a[0][0] + a[0][1] + a[1][0] + a[1][1] \u003d\u003d 0) {\n    cout \u0026lt;\u0026lt; \u0026quot;0\\n\u0026quot;;\n    return 0;\n  }\n  ll c0 \u003d invtriange(a[0][0]);\n  ll c1 \u003d invtriange(a[1][1]);\n  if (a[0][0] \u003d\u003d 0 || a[1][1] \u003d\u003d 0) {\n    if (a[0][1] + a[1][0] \u003d\u003d 0) {\n      if (c0 \u003d\u003d 1) c0 \u003d 0;\n      if (c1 \u003d\u003d 1) c1 \u003d 0;\n      cout \u0026lt;\u0026lt; string(c0, \u00270\u0027) \u0026lt;\u0026lt; string(c1, \u00271\u0027);\n      return 0;\n    }\n  }\n  if (c0 * c1 !\u003d a[0][1] + a[1][0]) {\n    imp();\n  }\n  string s(c0 + c1, \u00270\u0027);\n  for (int i \u003d 0; i \u0026lt; s.size(); ++i) {\n    if (c0 \u003d\u003d 0 || a[0][1] \u0026lt; c1) {\n      s[i] \u003d \u00271\u0027;\n      a[1][0] -\u003d c0;\n      --c1;\n    } else {\n      a[0][1] -\u003d c1;\n      --c0;\n    }\n  }\n  cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl;\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"708C\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eint n;\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g;\nvector\u0026lt;int\u0026gt; cnt;\n\nint min_mx \u003d 1e9;\nint center \u003d -1;\n\nvoid dfs(int v, int p) {\n\tcnt[v] \u003d 1;\n\tint mx \u003d 0;\n\tfor (int to : g[v]) {\n\t\tif (to \u003d\u003d p) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v);\n\t\tcnt[v] +\u003d cnt[to];\n\t\tmx \u003d max(mx, cnt[to]);\n\t}\n\tmx \u003d max(mx, n - cnt[v]);\n\tif (mx \u0026lt; min_mx) {\n\t\tmin_mx \u003d mx;\n\t\tcenter \u003d v;\n\t}\n}\n\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; subtrees;\nvector\u0026lt;int\u0026gt; ans;\n\nvoid dfs1(int v, int p, int sum_other, int prev) {\n\tif (sum_other \u0026lt;\u003d n / 2) {\n\t\tans[v] \u003d 1;\n\t}\n\tfor (int i \u003d 0; i \u0026lt; 2 \u0026amp;\u0026amp; i \u0026lt; subtrees.size(); ++i) {\n\t\tif (subtrees[i].second \u003d\u003d prev) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (n - cnt[v] - subtrees[i].first \u0026lt;\u003d n / 2) {\n\t\t\tans[v] \u003d 1;\n\t\t}\n\t}\n\tfor (int to : g[v]) {\n\t\tif (to \u003d\u003d p) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs1(to, v, sum_other, prev);\n\t}\n}\n\nvoid solve() {\n\tcin \u0026gt;\u0026gt; n;\n\tg.resize(n);\n\tcnt.assign(n, 0);\n\tfor (int i \u003d 1; i \u0026lt; n; ++i) {\n\t\tint a, b;\n\t\tcin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\t\t--a; --b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tdfs(0, 0);\n\n\tassert(center !\u003d -1);\n\tans.assign(n, 0);\n\tans[center] \u003d 1;\n\tdfs(center, center);\n\tint sum_all \u003d 0;\n\tfor (int to : g[center]) {\n\t\tsubtrees.emplace_back(cnt[to], to);\n\t\tsum_all +\u003d cnt[to];\n\t}\n\tsort(all(subtrees));\n\treverse(all(subtrees));\n\n\tfor (int to : g[center]) {\n\t\tdfs1(to, center, n - cnt[to], to);\n\t}\n\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) {\n\t\tcout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0027 \u0027;\n\t}\n\tcout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"708D\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eclass FixFlow {\npublic:\n\tvoid solve(std::istream\u0026amp; in, std::ostream\u0026amp; out) {\n\t\tint n, m;\n\t\tin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\t\tint s \u003d n;\n\t\tint t \u003d n + 1;\n\t\tMinCostFlow\u0026lt;int, int\u0026gt; flow(n + 2);\n\t\tvector\u0026lt;int\u0026gt; balance(n);\n\t\tint INF \u003d 1000000000;\n\t\tflow.addEdge((size_t) (n - 1), 0, INF, 0);\n\n\n\t\tint defaultAnswer \u003d 0;\n\t\tfor (int i: range(m)) {\n\t\t\tint a, b, c, f;\n\t\t\tin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; f;\n\t\t\t--a, --b;\n\t\t\tbalance[a] +\u003d f;\n\t\t\tbalance[b] -\u003d f;\n\t\t\tif (f \u0026lt;\u003d c) {\n\t\t\t\tflow.addEdge(a, b, c - f, 1);\n\t\t\t\tflow.addEdge(a, b, INF, 2);\n\t\t\t\tflow.addEdge(b, a, f, 1);\n\t\t\t} else {\n\t\t\t\t// f \u0026gt; c\n\t\t\t\tdefaultAnswer +\u003d f - c;\n\t\t\t\tflow.addEdge(a, b, INF, 2);\n\t\t\t\tflow.addEdge(b, a, f - c, 0);\n\t\t\t\tflow.addEdge(b, a, c, 1);\n\t\t\t}\n\t\t}\n\n\t\tint sumB \u003d 0;\n\t\tfor (int i: range(n)) {\n\t\t\tif (balance[i] \u0026gt; 0) {\n\t\t\t\tflow.addEdge(i, t, balance[i], 0);\n\t\t\t\tsumB +\u003d balance[i];\n\t\t\t} else {\n\t\t\t\tflow.addEdge(s, i, -balance[i], 0);\n\t\t\t}\n\t\t}\n\n\t\tauto res \u003d flow.findFlow(s, t, MinCostMaxFlowStrategy());\n\t\tassert(res.flow \u003d\u003d sumB);\n\t\tout \u0026lt;\u0026lt; res.cost + defaultAnswer \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n\t}\n};\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"708E\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eclass MAI {\npublic:\n\tvoid solve(std::istream\u0026amp; in, std::ostream\u0026amp; out) {\n\t\tint N, m;\n\t\tint a, b;\n\t\tint k;\n\t\tin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; m \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; k;\n\t\tusing Z \u003d ZnConst\u0026lt;1000000007\u0026gt;;\n\t\tZ p \u003d Z::valueOf(a) / b;\n\t\tZ q \u003d 1 - p;\n\n\t\t// dp[r\u0027] \u003d sum l \u0026lt; r \u0026lt;\u003d r\u0027 d[l][r]\n\t\tvector\u0026lt;Z\u0026gt; dp(m + 1, Z());\n\t\tdp[m] \u003d 1;\n\n\t\tvector\u0026lt;Z\u0026gt; powersP(k + 1), powersQ(k + 1);\n\t\tpowersP[0] \u003d powersQ[0] \u003d 1;\n\t\tfor (int i: range(k)) {\n\t\t\tpowersP[i + 1] \u003d powersP[i] * p;\n\t\t\tpowersQ[i + 1] \u003d powersQ[i] * q;\n\t\t}\n\n\t\tvector\u0026lt;Z\u0026gt; fact \u003d factorials\u0026lt;Z\u0026gt;(k + 1);\n\t\tvector\u0026lt;Z\u0026gt; invfact \u003d fact;\n\t\tfor (auto\u0026amp; x: invfact) {\n\t\t\tx \u003d 1 / x;\n\t\t}\n\n\t\tauto get_p_one_side \u003d [\u0026amp;](int l) {\n\t\t\tif (l \u0026gt; k) {\n\t\t\t\treturn Z();\n\t\t\t}\n\t\t\treturn powersP[l] * powersQ[k - l] * fact[k] * invfact[l] * invfact[k - l];\n\t\t};\n\n\t\tfor (int iter: range(N)) {\n\t\t\tvector\u0026lt;Z\u0026gt; dp_one(m + 1, Z());\n\t\t\tZ sumPl, sumPlDpl;\n\n\t\t\tfor (int r: inclusiveRange(m)) {\n\t\t\t\t//new_d[l][r] \u003d p[l] * p[n - r] * (have_something - dp[l] - dp[n - r])\n\t\t\t\tZ have_something \u003d dp.back();\n\t\t\t\tdp_one[r] \u003d get_p_one_side(m - r) * (\n\t\t\t\t\t\thave_something * sumPl - sumPlDpl - sumPl * dp[m - r]\n\t\t\t\t);\n\t\t\t\tsumPl +\u003d get_p_one_side(r);\n\t\t\t\tsumPlDpl +\u003d get_p_one_side(r) * dp[r];\n\t\t\t}\n\n\t\t\tfor (int i: range(m)) {\n\t\t\t\tdp_one[i + 1] +\u003d dp_one[i];\n\t\t\t}\n\n\t\t\tdp \u003d move(dp_one);\n\t\t}\n\n\t\tout \u0026lt;\u0026lt; dp.back();\n\t}\n};\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["aimtech","aimtech round 3","editorial"]}}