{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1409997608,"rating":119,"authorHandle":"kien_coi_1997","modificationTimeSeconds":1410277464,"id":13703,"title":"\u003cp\u003eAn efficient way to strengthen up your segment tree.\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI\u0027m going to talking about a coding style in segment tree which I used for a long time. Not only is it more systematically, but it also support more kind of segment tree.\u003c/p\u003e\u003ch2\u003e1. Old style\u003c/h2\u003e\u003cp\u003eAssume that we are making a segment tree support operators assign elements in a range (assign-range L R X) and get max element in a range (max-range L R).\u003c/p\u003e\u003cp\u003eI found a large number of people use the following way to build segment tree:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid lazy_update(int u, int ll, int rr) {\n  if (Lazy[u]\u003d\u003d-1) return; // assume that -1 is unused value\n  if (ll!\u003drr) Lazy[u*2]\u003dLazy[u*2+1]\u003dLazy[u];\n  Max[u]\u003dLazy[u]; Lazy[u]\u003d-1;\n}\n\nvoid assign_range(int u, int ll, int rr, int L, int R, int X) {\n  lazy_update(u, ll, rr); // call a function to lazy-update node u (which operate segment ll..rr)\n  if (ll\u0026gt;R || L\u0026gt;rr) return;\n  if (L\u0026lt;\u003dll \u0026amp;\u0026amp; rr\u0026lt;\u003dR) { \n    Lazy[u]\u003dX; \n    lazy_update(u, ll, rr); \n    return; \n  }\n  assign_range(2*u, ll, (ll+rr)/2, L, R, X);\n  assign_range(2*u+1, (ll+rr)/2+1, rr, L, R, X);\n  Max[u] \u003d max(Max[2*u], Max[2*u+1]);\n}\n\nint max_range(int u, int ll, int rr, int L, int R) {\n  lazy_update(u, ll, rr);\n  if (ll\u0026gt;R || L\u0026gt;rr) return -oo;\n  if (L\u0026lt;\u003dll \u0026amp;\u0026amp; rr\u0026lt;\u003dR) return Max[u];\n  int Max1 \u003d max_range(2*u, ll, (ll+rr)/2, L, R);\n  int Max2 \u003d max_range(2*u+1, (ll+rr)/2+1, rr, L, R);\n  return max(Max1, Max2);\n}\n\nint main(){\n  ...\n  cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R \u0026gt;\u0026gt; X;\n  assign_range(1, 1, n, L, R, X);\n  ...\n  cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R;\n  cout \u0026lt;\u0026lt; max_range(1, 1, n, L, R) \u0026lt;\u0026lt; endl;\n  ...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eThere are some duplicated code which need to be reduce:\u003c/strong\u003e\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ccode\u003eint u, int ll, int rr\u003c/code\u003e : appear in both three function declarations\u003c/li\u003e   \u003cli\u003e\u003ccode\u003elazy_update(u, ll, rr);\u003c/code\u003e : appear in beginning of both two functions\u003c/li\u003e   \u003cli\u003e\u003ccode\u003e(2*u, ll, (ll+rr)/2\u003c/code\u003e and \u003ccode\u003e2*u+1, (ll+rr)/2+1, rr\u003c/code\u003e : they appear four times.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThey will be reduced efficienly in new style.\u003c/p\u003e\u003ch2\u003e2. New style\u003c/h2\u003e\u003cp\u003eForcing people to use a personal style is a bad idea. I share with you this style to give you a suggestion in coding segment tree.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estruct node {\n  int ll, rr, id;\n\n  node(int L, int R, int X) { \n    ll\u003dL, rr\u003dR, id\u003dX; \n    lazy_update(); \n  }\n\n  node left() \n    { return node(ll, (ll+rr)/2, id*2); }\n  node right() \n    { return node((ll+rr)/2+1, rr, id*2+1); }\n\n  void lazy_update() { \n    if (Lazy[id]\u003d\u003d-1) return; // assume that -1 is unused value\n    if (ll!\u003drr) Lazy[id*2]\u003dLazy[id*2+1]\u003dLazy[id];\n    Max[id]\u003dLazy[id]; Lazy[id]\u003d-1;\n  }\n  \n  void assign_range(int L, int R, int X){ // don\u0027t need to call lazy_update() at the beginning\n    if (ll\u0026gt;R || L\u0026gt;rr) return ;\n    if (L\u0026lt;\u003dll \u0026amp;\u0026amp; rr\u0026lt;\u003dR) \n      { Lazy[id]\u003dX; lazy_update(); return ; }\n    left().assign_range(L, R, X); // easier to read\n    right().assign_range(L, R, X);\n    Max[id]\u003dmax(Max[id*2], Max[id*2+1]);\n  }\n  \n  int max_range(int L, int R) {\n    if (ll\u0026gt;R || L\u0026gt;rr) return -oo;\n    if (L\u0026lt;\u003dll \u0026amp;\u0026amp; rr\u0026lt;\u003dR) return Max[id];\n    int Max1 \u003d left().max_range(L, R);\n    int Max2 \u003d right().max_range(L, R);\n    return max(Max1, Max2);\n  }\n};\n\nint main(){\n  ...\n  cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R \u0026gt;\u0026gt; X;\n  node(1, n, 1).assign_range(L, R, X); // easier to read\n  ...\n  node Root(1, n, 1); // use this if we have to write to much node(1, n, 1)\n  cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R;\n  cout \u0026lt;\u0026lt; Root.max_range(L, R) \u0026lt;\u0026lt; endl;\n  ...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLet\u0027s list advantages of new style:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eReduce duplicated code\u003c/li\u003e   \u003cli\u003eAverage lines\u0027 length and functions\u0027 length is reduced.\u003c/li\u003e   \u003cli\u003eEasier to read\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThe more complex problem, the more efficient this new style.\u003c/p\u003e\u003ch2\u003e3. Additionally feature in new style\u003c/h2\u003e\u003cp\u003eAssume that we are facing this problem: \u003c/p\u003e\u003cp\u003eThere is a string \u003cem\u003eS\u003c/em\u003e which contains lowercase letters. Execute following operators on this string:\u003c/p\u003e \u003cul\u003e   \u003cli\u003echeck i j k: Check if S[i..i+k-1] is equal to S[j..j+k-1].\u003c/li\u003e   \u003cli\u003edelete k: Delete k-th element.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eTo solve above problem, we need to build a segment tree which support two operators : \u003ccode\u003ehash-range L R\u003c/code\u003e return hash value of S[L..R], and \u003ccode\u003eremove X\u003c/code\u003e remove X-th element. I called the following structure indexable segment tree. In each node, we maintain hash value and size of this node.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#define long long long\n\nstruct node {\n  int ll, rr, id;\n  node(int L, int X) \n    { ll\u003dL, rr\u003dL+Size[X]-1, id\u003dX; }\n  node left() \n    { return node(ll, id*2); }\n  node right() \n    { return node(ll+Size[id*2], id*2+1); }\n\n  void update() {\n    Hash[id]\u003dsum_hash(Hash[id*2], Hash[id*2+1], Size[id*2+1]);\n    Size[id]\u003dSize[id*2] + Size[id*2+1];\n  }\n  \n  long hash_range(int L, int R) {\n    if (ll\u0026gt;R || L\u0026gt;rr) return 0LL;\n    if (L\u0026lt;\u003dll \u0026amp;\u0026amp; rr\u0026lt;\u003dR) return Hash[id];\n    long Hash1 \u003d left().hash_range(L, R);\n    long Hash2 \u003d right().hash_range(L, R);\n    return sum_hash(Hash1, Hash2, Size[id*2+1]); // easy to implement sum_hash()\n  }\n  \n  void remove(int X){\n    if (ll\u0026gt;X || X\u0026gt;rr) return ;\n    if (ll\u003d\u003drr) { Size[id]\u003d0; Hash[id]\u003d0; return; }\n    right().remove(X); // if call left().remove(X) first and succeeded, ...\n    left().remove(X); // ... we are not allowed to call right().remove(X)\n    update();\n  }\n\n  void build(char a[], int L, int R) { // Note: ll, rr are not valid now but id\n    if (L\u003d\u003dR) \n      { Size[id]\u003d1; Hash[id]\u003da[L]; return ; }\n    left().build(a, L, (L+R)/2);\n    right().build(a, (L+R)/2+1, R);\n    update();\n  }\n};\n\nchar a[N]; // zero-based;\n\nmain(){\n  cin \u0026gt;\u0026gt; a; n\u003dstrlen(a);\n  node(0, 1).build(a, 0, n-1); // initialize segment tree\n  ...\n  cin \u0026gt;\u0026gt; i \u0026gt;\u0026gt; j \u0026gt;\u0026gt; k;\n  long Hash1 \u003d node(0, 1).hash_range(i, i+k-1);\n  long Hash2 \u003d node(0, 1).hash_range(j, j+k-1);\n  cout \u0026lt;\u0026lt; (Hash1 \u003d\u003d Hash2 ? \u0026quot;Yes\u0026quot; : \u0026quot;No\u0026quot;) \u0026lt;\u0026lt; endl;\n  ...\n  cin \u0026gt;\u0026gt; k;\n  node(0, 1).remove(k);\n  ...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn the above code, managed segment of each nodes in segment tree is consecutively changed. And struct node become very flexible and efficient.\u003c/p\u003e\u003cp\u003eIn this example, we are not allowed to use \u003ccode\u003enode Root(0, 1)\u003c/code\u003e because Root content is always change (\u003ccode\u003err\u003c/code\u003e field). If you want to use \u003ccode\u003eRoot\u003c/code\u003e variable, you should update Root after every \u003ccode\u003eremove\u003c/code\u003e query: \u003ccode\u003enode(0, 1).remove(k); Root\u003dnode(0,1);\u003c/code\u003e (and I don\u0027t like this).\u003c/p\u003e\u003ch2\u003e4. Conclusion\u003c/h2\u003e\u003cp\u003eIt is hard to write both long and detailed blog. Therefore, you can comment anything which you didn\u0027t understand well. I will reply (or update this blog if it is necessary).\u003c/p\u003e\u003c/div\u003e","tags":["segment tree"]}}