{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1414460988,"rating":-17,"authorHandle":"simp1eton","modificationTimeSeconds":1414462081,"id":14466,"title":"\u003cp\u003eefficient way to write iterative dfs\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi all,\u003c/p\u003e\u003cp\u003eMay I know if anyone knows an efficient way to write iterative dfs? I am asking this because I am writing a program that has to deal with extremely large rooted trees. Even if I increase the stack limit, I think recursive dfs will be much slower than iterative dfs in this case due to the numerous function calls. Therefore, I implemented an iterative dfs as follows.\u003c/p\u003e\u003cp\u003eNote: the tree is rooted tree (edges point from parent to child), so I do not check if vertices have been visited.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector \u0026lt;int\u0026gt; graph[MAXN];\nstack \u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt; S;\n\nS.push(pair\u0026lt;int,int\u0026gt;(TREE_ROOT,-1));\n\nwhile(!S.empty()) {\n  pair\u0026lt;int,int\u0026gt; cur \u003d S.top();\n  S.pop();\n  cur.second++;\n  // do stuff\n  if (cur.second \u0026lt; graph[cur.first].size()) {\n    S.push(cur);\n    S.push(pair\u0026lt;int,int\u0026gt;(graph[cur.first][cur.second],-1));\n  }\n  else {\n    //do more stuff\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI am not sure if this is the best way to implement what I have. In practice my performance is not that good. Does anyone have a better implementation? My main concern is with speed.\u003c/p\u003e\u003cp\u003eThank you!\u003c/p\u003e\u003c/div\u003e","tags":[]}}