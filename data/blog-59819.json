{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1527989638,"rating":66,"authorHandle":"Vendetta.","modificationTimeSeconds":1528273734,"id":59819,"title":"\u003cp\u003e[Gym] 2018 ACM Amman Collegiate Programming Contest — editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThe tutorials for problems B \u0026amp; E were written by \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/1am\" title\u003d\"Expert 1am\"\u003e1am\u003c/a\u003e, D by \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/The-Legend\" title\u003d\"Candidate Master The-Legend\"\u003eThe-Legend\u003c/a\u003e, F by \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/Qumair\" title\u003d\"Specialist Qumair\"\u003eQumair\u003c/a\u003e, J \u0026amp; K by \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Motarack\" title\u003d\"Master Motarack\"\u003eMotarack\u003c/a\u003e and M by \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/abo_od303\" title\u003d\"Expert abo_od303\"\u003eabo_od303\u003c/a\u003e. Thank you guys for also reviewing the rest of the tutorial!\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/gym/101810/problem/A\"\u003eA. Careful Thief\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eIt’s enough to try all segments of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e that either starts with the start of a range or ends with the end of a range, suppose that the optimal solution is somewhere that starts in some range and ends in some other range (possibly ranges of zeroes), then shifting the segment to one direction will increase the answer, and shifting it in the other direction will decrease it until you reach the boundary of the range, or if both ranges have the same amount of money then shifting will not affect the answer. This can be done using a sorted array of the ranges and for each range that starts with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e we can binary search for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e and to get the result of all the ranges in between we can do a prefix summation for \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + 1) × \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Same process can be done for trying the ends of all ranges. \u003cbr /\u003e \u003cstrong\u003eComplexity per test-case:\u003c/strong\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1b/2d/1b2dbaffb25811fccc6be48782b824c539d4ab87.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nstruct node {\n  int a, b, c;\n  node() {}\n  node(int a, int b, int c):\n    a(a), b(b), c(c) {}\n  bool operator \u0026lt; (const node \u0026amp; n) const {\n    return a \u0026lt; n.a;\n  }\n};\n\nint const N \u003d 1e5 + 10;\nint t, n, x;\nlong long cs[N];\nnode a[N];\n\nint main() {\n  scanf(\u0026quot;%d\u0026quot;, \u0026amp; t);\n  while (t-- !\u003d 0) {\n    scanf(\u0026quot;%d %d\u0026quot;, \u0026amp; n, \u0026amp; x);\n    for (int i \u003d 1; i \u0026lt;\u003d n; ++i)\n      scanf(\u0026quot;%d %d %d\u0026quot;, \u0026amp; a[i].a, \u0026amp; a[i].b, \u0026amp; a[i].c);\n    ++n;\n    a[n] \u003d node(-1, -1, 0);\n    sort(a + 1, a + n + 1);\n    for (int i \u003d 1; i \u0026lt;\u003d n; ++i)\n      cs[i] \u003d 1ll * (a[i].b - a[i].a + 1) * a[i].c + cs[i - 1];\n    long long best \u003d 0;\n    for (int i \u003d 1, nw; i \u0026lt;\u003d n; ++i) {\n      nw \u003d a[i].a + x - 1;\n      int idx \u003d upper_bound(a + 1, a + n + 1, node(nw, 2e9, 2e9)) - a;\n      --idx;\n      if (nw \u0026gt;\u003d a[idx].b)\n        best \u003d max(best, cs[idx] - cs[i - 1]);\n      else\n        best \u003d max(best, cs[idx - 1] - cs[i - 1] + 1ll * (nw - a[idx].a + 1) * a[idx].c);\n    }\n    for (int i \u003d n, nw; i \u0026gt; 0; --i) {\n      nw \u003d max(0, a[i].b - x + 1);\n      int idx \u003d upper_bound(a + 1, a + n + 1, node(nw, 2e9, 2e9)) - a;\n      --idx;\n      if (nw \u0026lt;\u003d a[idx].a)\n        best \u003d max(best, cs[i] - cs[idx - 1]);\n      else\n        best \u003d max(best, cs[i] - cs[idx] + 1ll * (a[idx].b - nw + 1) * a[idx].c);\n    }\n    printf(\u0026quot;%lld\\n\u0026quot;, best);\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/gym/101810/problem/B\"\u003eB. Friends and Cookies\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eThis problem simply requires implementation with basic modulus and division calculations. Please observe the following image: \u003cbr /\u003e \u003c/p\u003e\u003cdiv style\u003d\"text-align: center;\"\u003e\u003cimg src\u003d\"/predownloaded/dd/80/dd80eaf00dfc5891c17d0d5d4e83fb699abfcbcc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/div\u003e The first iteration, Abood will start to give his friends cookies starting from the \u003cspan class\u003d\"tex-span\"\u003e1\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003est\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e friend, till the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eth\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. We can simply loop this, since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is maximum \u003cspan class\u003d\"tex-span\"\u003e1000\u003c/span\u003e. Or add \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to all friends if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e ≥ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. After that, it\u0027s just careful calculations. Decrease \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, and divide what is left by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e. This is because in the iterations after the first one, Abood will give cookies to the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e friends, then to the last \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e friends. So by dividing, I can figure out how much each friend will eat without having to loop \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e times. The only thing left to deal with is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/67/a5/67a5145beb5a4592abfc0cc418430416906ee556.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, the remainder cookies. Depending on whether \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/83/ca/83ca21c44a11cbefc213ccc50599fb4dce5f5281.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is even or not, I can figure out the direction of the last iteration, and where I start giving (either start \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e and move to the left, or start at \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e and move to the right). Using that, I loop accordingly only the remainder until I have no more cookies left. It is possible to loop because we know the remainder will be less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e. I’m too lazy to discuss exact calculations, if anything is unclear please feel free to write in the comments. Oh and don\u0027t forget to clear the array between iterations, and be careful of division by zero when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 1\u003c/span\u003e. \u003cbr /\u003e \u003cstrong\u003eComplexity per test-case:\u003c/strong\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e. \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n#define se second\n#define fi first\n#define pb push_back\nconst int N \u003d 1001;\nll fans[N];\n\nint main() {\n  int t, n;\n  ll x;\n  scanf(\u0026quot;%d\u0026quot;, \u0026amp;t);\n  while (t--) {\n    scanf(\u0026quot;%lld%d\u0026quot;, \u0026amp;x, \u0026amp;n);\n    memset(fans, 0, sizeof fans);\n    if (n \u003d\u003d 1) {\n      cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl;\n      continue;\n    }\n    for (int i \u003d 1; i \u0026lt;\u003d n \u0026amp;\u0026amp; x; i++, x--)\n      fans[i]++;\n    if (x \u0026gt; 0) {\n      ll temp \u003d x / (n - 1), rem \u003d x % (n - 1);\n      if (temp \u0026amp; 1) {\n        fans[1] +\u003d temp / 2 + 1, fans[n] +\u003d temp / 2;\n        for (int i \u003d 2; i \u0026lt; n; i++)\n          fans[i] +\u003d temp;\n        for (int i \u003d 2; i \u0026lt;\u003d n \u0026amp;\u0026amp; rem; i++, rem--)\n          fans[i]++;\n      }\n      else {\n        fans[1] +\u003d temp / 2, fans[n] +\u003d temp / 2;\n        for (int i \u003d 2; i \u0026lt; n; i++)\n          fans[i] +\u003d temp;\n        for (int i \u003d n - 1; i \u0026gt;\u003d 0 \u0026amp;\u0026amp; rem; i--, rem--)\n          fans[i]++;\n      }\n    }\n    for (int i \u003d 1; i \u0026lt;\u003d n; i++) {\n      printf(\u0026quot;%lld\u0026quot;, fans[i]);\n      if (i !\u003d n)\n        printf(\u0026quot; \u0026quot;);\n    }\n    puts(\u0026quot;\u0026quot;);\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/gym/101810/problem/C\"\u003eC. Flip the Bits\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eThe maximal number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e which is less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e, so the number of flipped bits will be exactly the number of different bits between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e which is equal to the number of 1 bits in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e XOR \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e - 1)\u003c/span\u003e. \u003cbr /\u003e \u003cstrong\u003eComplexity per test-case:\u003c/strong\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c8/66/c866e70b5875095de99ad700f943dbe7ed528b12.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n\nint n;\nint main(int argc, char* argv[]) {\n  int t;\n  scanf(\u0026quot;%d\u0026quot;, \u0026amp;t);\n  while (t--) {\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    printf(\u0026quot;%d\\n\u0026quot;, __builtin_popcount(n ^ (n - 1)));\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/gym/101810/problem/D\"\u003eD. Magic Sticks\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eLet us use these terminologies: \u003c/p\u003e \u003cblockquote\u003e   \u003cul\u003e     \u003cli\u003eEach line belong to \u003cspan class\u003d\"tex-span\"\u003e1 × 1\u003c/span\u003e cell we will call it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eedge\u003c/i\u003e\u003c/span\u003e\u003c/li\u003e     \u003cli\u003eEach line parallel to one of the biggest rectangle\u0027s sides \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e × \u003ci\u003em\u003c/i\u003e\u003c/span\u003e and equal to its length we will call it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eline\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003c/ul\u003e \u003c/blockquote\u003e\u003cp\u003eOur solution depends on these two observations about the selected \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eedges\u003c/i\u003e\u003c/span\u003e:\u003c/p\u003e \u003cblockquote\u003e   \u003cul\u003e     \u003cli\u003eThey should be parallel to each others.\u003c/li\u003e     \u003cli\u003eThey should be parallel to the shorter line in the biggest rectangle \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e × \u003ci\u003em\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003c/ul\u003e \u003c/blockquote\u003e\u003cp\u003eAssume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≤ \u003ci\u003em\u003c/i\u003e\u003c/span\u003e (you can otherwise swap the numbers to satisfy that) And the shorter side \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is vertical. \u003cbr /\u003e We have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e + 1\u003c/span\u003e vertical \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elines\u003c/i\u003e\u003c/span\u003e with length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e from each one of them if we take an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eedge\u003c/i\u003e\u003c/span\u003e then we have to not take the one  below or above But how do we select the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eedges\u003c/i\u003e\u003c/span\u003e? \u003cbr /\u003e We should select them alternatively, why? Let us not take two consecutive \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eedges\u003c/i\u003e\u003c/span\u003e then there are two cells that are not covered by at least one \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eedge\u003c/i\u003e\u003c/span\u003e till now so in the next \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eline\u003c/i\u003e\u003c/span\u003e we must take two consecutive \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eedges\u003c/i\u003e\u003c/span\u003e to get these two cells covered by at least one \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eedge\u003c/i\u003e\u003c/span\u003e which will violate the problem\u0027s constraints (edges should not touch). \u003cbr /\u003e Now let us continue with taking the alternative \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eedges\u003c/i\u003e\u003c/span\u003e. One of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elines\u003c/i\u003e\u003c/span\u003e we will take \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/73/9b/739b9429a9201dd1f45cfe83ac918033180c1ded.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eedges\u003c/i\u003e\u003c/span\u003e among \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, the next one \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/28/b4/28b41322bfb41603a14fda8b3e0af95d2ce0bc47.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and so on.. \u003cbr /\u003e You have to notice that we have to start with taking \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/73/9b/739b9429a9201dd1f45cfe83ac918033180c1ded.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e from the first line not \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/28/b4/28b41322bfb41603a14fda8b3e0af95d2ce0bc47.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e since we need to take as much \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/73/9b/739b9429a9201dd1f45cfe83ac918033180c1ded.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e as we can in comparing with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/28/b4/28b41322bfb41603a14fda8b3e0af95d2ce0bc47.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e to minimize the number of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eedges\u003c/i\u003e\u003c/span\u003e in the required group. \u003cbr /\u003e Here\u0027s an example for a \u003cspan class\u003d\"tex-span\"\u003e5 × 6\u003c/span\u003e grid: \u003cbr /\u003e \u003c/p\u003e\u003cdiv style\u003d\"text-align: center;\"\u003e\u003cimg src\u003d\"/predownloaded/92/e9/92e96cf18b53702461a79f7ca91a2f0d31b1bbf5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/div\u003e \u003cstrong\u003eComplexity per test-case:\u003c/strong\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e. \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nlong long n, m, tmp, ans;\nint T;\n\nint main(int argc, char** argv) {\n  cin \u0026gt;\u0026gt; T;\n  while (T--) {\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n    if (n \u0026gt; m)\n      swap(n, m);\n    tmp \u003d m / 2 + 1;\n    ans \u003d tmp * (n / 2) + (m + 1 - tmp) * ((n + 1) / 2);\n    cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/gym/101810/problem/E\"\u003eE. N-Dimensional Grid\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eThere are many different solutions for this problem that can pass, let\u0027s discuss the one where you calculate all pairs and subtract the incorrect ones. For every cell, we need to know how many cells have a manhattan distance of \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e with it. It is clear that these pairs will have the same values for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e dimensions, with only one dimension having a different value by an absolute difference of \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. \u003cbr /\u003e So for every cell, keep fixed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e dimensions, and decrease the value for one dimension by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e will give us one non repeated pair. For each cell, there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e ways to do this. Since number of cells is the product of the sizes of all dimensions in the input, we multiply this product by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e to get the number of pairs. \u003cbr /\u003e Notice that not all these pairs are valid, because we are considering pairs that get matched with a cell with a \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e as one of its values. All we must do now is decrease these invalid pairs. Fix one dimension with a value as \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. The number of valid cells that will be wrongly matched with this invalid one is the product of all dimensions sizes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e except for the one that\u0027s currently fixed. Therefore for each fixed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, decrease the product of all dimension sizes except for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e from our number of pairs. This is our final answer. \u003cbr /\u003e \u003cstrong\u003eComplexity per test-case:\u003c/strong\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n#define se second\n#define fi first\n#define pb push_back\nconst int N \u003d 1e5 + 5, M \u003d 1e9 + 7;\nll v[N], L[N], R[N];\n\nint main() {\n  int t;\n  cin \u0026gt;\u0026gt; t;\n  while (t--) {\n    int n;\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    long long fans \u003d 0, sum \u003d 1;\n    for (int i \u003d 1; i \u0026lt;\u003d n; i++) {\n      scanf(\u0026quot;%lld\u0026quot;, \u0026amp;v[i]);\n      sum \u003d (sum * v[i]) % M;\n    }\n    fans \u003d (sum * n) % M;\n    L[0] \u003d R[n + 1] \u003d 1;\n    for (int i \u003d 1; i \u0026lt;\u003d n; i++) {\n      L[i] \u003d (L[i - 1] * v[i]) % M;\n    }\n    for (int i \u003d n; i \u0026gt; 0; i--) {\n      R[i] \u003d (R[i + 1] * v[i]) % M;\n    }\n    for (int i \u003d 1; i \u0026lt;\u003d n; i++) {\n      long long temp \u003d (L[i - 1] * R[i + 1]) % M;\n      fans \u003d (fans - temp + M) % M;\n    }\n    printf(\u0026quot;%lld\\n\u0026quot;, fans);\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/gym/101810/problem/F\"\u003eF. Minimum Sum of Array\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eLet’s define a frequency array for the original array and a visited array for the values, now for every number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e from 1 to \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e with frequency more than zero (it exists in the array) then loop over the multiples of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, if a multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e say \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e is not visited before then we should change \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is the smallest divisor for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e in the array. \u003cbr /\u003e \u003cstrong\u003eComplexity per test-case:\u003c/strong\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/47/af/47afae6e1033bd719f9c281a9545925f58a63f1f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint const N \u003d 1e6 + 100;\nint const sz \u003d 1e5 + 100;\nint t, n, a[sz], freq[N], vis[N];\n\nlong long summation() {\n  long long sum \u003d 0;\n  for (int i \u003d 1; i \u0026lt; N; ++i) {\n    if (freq[i]) {\n      for (int j \u003d i; j \u0026lt; N; j +\u003d i)\n        if (freq[j] \u0026amp;\u0026amp; !vis[j])\n          sum +\u003d 1ll * freq[j] * i, vis[j] \u003d 1;\n    }\n  }\n  return sum;\n}\n\nint main() {\n  scanf(\u0026quot;%d\u0026quot;, \u0026amp;t);\n  while (t--) {\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    for (int i \u003d 0; i \u0026lt; n; ++i) {\n      scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]);\n      ++freq[a[i]];\n    }\n\n    printf(\u0026quot;%lld\\n\u0026quot;, summation());\n    for (int i \u003d 0; i \u0026lt; n; ++i)\n      freq[a[i]] \u003d vis[a[i]] \u003d 0;\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/gym/101810/problem/G\"\u003eG. Power of String\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eNotice that the position of the characters doesn\u0027t matter because, for example, if you have character \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003c/span\u003e repeated \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ech\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e times then no matter what their positions are in the string they will add the same value which is equal to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c1/7d/c17d1a76dc792faa7d8749317720a197d48f63c1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, So we are only interested in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ech\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. \u003cbr /\u003e Suppose that we have determined what characters we will change, then all of them should be changed to the same character \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, and any other equal characters \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003c/span\u003e should all be changed into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e or none, except for one character \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e that we can change part of it, check the proof below. \u003cbr /\u003e Now if we will fix \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e, we can calculate knapsack-like DP on all other characters (we know that we will change either all or none of all equal characters). \u003cbr /\u003e \u003cstrong\u003eComplexity per test-case:\u003c/strong\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eK\u003c/i\u003e × \u003ci\u003eA\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e for iterating over (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e), and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eK\u003c/i\u003e × \u003ci\u003eA\u003c/i\u003e)\u003c/span\u003e for knapsack) where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e is equal to the number of different characters in the string which is 26.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProof\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eLet\u0027s say we increased the frequency of two characters \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e, and let\u0027s say we increased the frequency of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, let\u0027s define \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e(\u003ci\u003ei\u003c/i\u003e) \u003d \u003c/span\u003e weight of adding \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e instances of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e similarly. \u003cbr /\u003e Now let\u0027s say we want to add one instance of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e1\u003c/span\u003e and remove one instance of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e2\u003c/span\u003e, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e(\u003ci\u003ea\u003c/i\u003e + 1) - \u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e(\u003ci\u003ea\u003c/i\u003e) \u0026gt; \u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(\u003ci\u003eb\u003c/i\u003e) - \u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(\u003ci\u003eb\u003c/i\u003e - 1)\u003c/span\u003e then our operation will increase the total weight, also since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e(\u003ci\u003ea\u003c/i\u003e + 2) - \u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e(\u003ci\u003ea\u003c/i\u003e + 1) \u0026gt; \u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e(\u003ci\u003ea\u003c/i\u003e + 1) - \u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e(\u003ci\u003ea\u003c/i\u003e) \u0026gt; \u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(\u003ci\u003eb\u003c/i\u003e) - \u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(\u003ci\u003eb\u003c/i\u003e - 1) \u0026gt; \u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(\u003ci\u003eb\u003c/i\u003e - 1) - \u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(\u003ci\u003eb\u003c/i\u003e - 2)\u003c/span\u003e, we can keep adding a single instance of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e1\u003c/span\u003e and removing a single instance of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e2\u003c/span\u003e, increasing the weight each time until \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e \u003d 0\u003c/span\u003e. \u003cbr /\u003e Now if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e(\u003ci\u003ea\u003c/i\u003e + 1) - \u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e(\u003ci\u003ea\u003c/i\u003e) \u0026lt; \u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(\u003ci\u003eb\u003c/i\u003e) - \u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(\u003ci\u003eb\u003c/i\u003e - 1)\u003c/span\u003e then similarly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(\u003ci\u003eb\u003c/i\u003e + 1) - \u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(\u003ci\u003eb\u003c/i\u003e) \u0026gt; \u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e(\u003ci\u003ea\u003c/i\u003e) - \u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e(\u003ci\u003ea\u003c/i\u003e - 1)\u003c/span\u003e, so we add instances of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e and remove instances of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e instead. \u003cbr /\u003e That proofs that it\u0027s always optimal to increase the frequency of only a single character, and similarly assume that we have taken \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e such that there are still characters left of both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e, then from above we can see that it\u0027s optimal to either take all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e or all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ech\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e instead of some of both proofing that we should decrease the frequency of some characters to 0 expect for at most one character where we don’t have enough \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e to take all of it. \u003cbr /\u003e Written by \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Motarack\" title\u003d\"Master Motarack\"\u003eMotarack\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\nconst int N \u003d 5000 + 5, M \u003d 26;\nint freq[M], n, k, from, to;\nll dp[N][M], res;\nchar st[100000 + 5];\n\nll find(int f, int ch) {\n  return f * (f - 1LL) / 2 * (ch + \u0027a\u0027);\n}\n\nll calc(int ch, int rem) {\n  if (ch \u003d\u003d from || ch \u003d\u003d to)\n    return calc(ch + 1, rem);\n  if (ch \u003d\u003d 26) {\n    int t \u003d min(rem, freq[from]);\n    rem -\u003d t;\n    return find(freq[from] - t, from) + find(freq[to] + (k - rem), to);\n  }\n  ll\u0026amp; ret \u003d dp[rem][ch];\n  if (ret !\u003d -1)\n    return ret;\n  ret \u003d find(freq[ch], ch) + calc(ch + 1, rem);\n  if (rem - freq[ch] \u0026gt;\u003d 0)\n    ret \u003d max(ret, calc(ch + 1, rem - freq[ch]));\n  return ret;\n}\n\nint main(int argc, char* argv[]) {\n  int t;\n  scanf(\u0026quot;%d\u0026quot;, \u0026amp;t);\n  while (t--) {\n    scanf(\u0026quot;%d%d%s\u0026quot;, \u0026amp;n, \u0026amp;k, st);\n    memset(freq, 0, sizeof freq);\n    for (int i \u003d 0; i \u0026lt; n; ++i)\n      ++freq[st[i] - \u0027a\u0027];\n    res \u003d 0;\n    for (int c1 \u003d \u0027a\u0027; c1 \u0026lt;\u003d \u0027z\u0027; ++c1)\n      for (int c2 \u003d \u0027a\u0027; c2 \u0026lt;\u003d \u0027z\u0027; ++c2) {\n        if (c1 \u003d\u003d c2)\n          continue;\n        memset(dp, -1, sizeof dp);\n        to \u003d c1 - \u0027a\u0027;\n        from \u003d c2 - \u0027a\u0027;\n        res \u003d max(res, calc(0, k));\n      }\n    printf(\u0026quot;%lld\\n\u0026quot;, res);\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/gym/101810/problem/H\"\u003eH. Making Friends\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eFind the maximum value for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2 × \u003ci\u003en\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026lt; 2 × \u003ci\u003en\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e - 1\u003c/span\u003e. \u003cbr /\u003e \u003cstrong\u003eComplexity per test-case:\u003c/strong\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int N \u003d 1000;\nint n, h[N + N], res;\nint main(int argc, char* argv[]) {\n  int t;\n  scanf(\u0026quot;%d\u0026quot;, \u0026amp;t);\n  while (t--) {\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    n +\u003d n;\n    for (int i \u003d 0; i \u0026lt; n; ++i)\n      scanf(\u0026quot;%d\u0026quot;, h + i);\n    res \u003d 0;\n    for (int i \u003d 0; i \u0026lt; n; ++i)\n      res \u003d max(res, h[i] + h[n - i - 1]);\n    printf(\u0026quot;%d\\n\u0026quot;, res);\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/gym/101810/problem/I\"\u003eI. Split the Number\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eThe minimum difference is either 0 or 1, splitting \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e equally over the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e parts giving each part \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/69/51/6951e99a0b5a0cacfe610466e592126e9defa3bd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, now we have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/68/22/6822c41bcb2306df2549347e41059d2e69930526.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e as left-over which is less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, we can split them over the last \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/68/22/6822c41bcb2306df2549347e41059d2e69930526.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e parts. note that if \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/69/51/6951e99a0b5a0cacfe610466e592126e9defa3bd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e equals 0 then there is no strictly positive solution so print \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e. \u003cbr /\u003e \u003cstrong\u003eComplexity per test-case:\u003c/strong\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint T, x, n, d, mod;\n\nint main(int argc, char** argv) {\n  cin \u0026gt;\u0026gt; T;\n  while (T--) {\n    scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;x, \u0026amp;n);\n    d \u003d x / n;\n    if (d \u003d\u003d 0) {\n      puts(\u0026quot;-1\u0026quot;);\n      continue;\n    }\n    mod \u003d x % n;\n    printf(\u0026quot;%d\u0026quot;, d);\n    for (int i \u003d 1; i + mod \u0026lt; n; ++i)\n      printf(\u0026quot; %d\u0026quot;, d);\n    for (int i \u003d 0; i \u0026lt; mod; ++i)\n      printf(\u0026quot; %d\u0026quot;, d + 1);\n    puts(\u0026quot;\u0026quot;);\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/gym/101810/problem/J\"\u003eJ. T-Shirts Dilemma\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003eth bit of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e correspondingly, and let\u0027s iterate from the most significant bit to the least significant bit, and each time check the following:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 0\u003c/span\u003e then we can take the segment segment \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e]\u003c/span\u003e as their cost will be less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 0\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 1\u003c/span\u003e then we can\u0027t take any number as the cost of every number is greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 0\u003c/span\u003e we don\u0027t have enough information so we go to the next bit.\u003c/li\u003e   \u003cli\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 1\u003c/span\u003e we don\u0027t have enough information here either, so we set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e and go to the next bit (note that flipping the bits won\u0027t affect the answer because the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eOR\u003c/i\u003e\u003c/span\u003e of any set of numbers before and after the flipping will remain the same expect for the flipped bit, but that bit is the same for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and all numbers in \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e]\u003c/span\u003e, so it doesn\u0027t matter).\u003c/li\u003e   \u003cli\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 0\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 1\u003c/span\u003e then we can\u0027t include any number with it\u0027s \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003eth bit \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e \u003d \u003c/span\u003enumber with all bits after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003eth bit \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, and rest of bits \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, then the answer for \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e equals answer for \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e, so we replace \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e and go to the next bit.\u003c/li\u003e   \u003cli\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 0\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 1\u003c/span\u003e, if all the bits to the right of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003eth bit in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e are \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003es then we can take the segment \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e]\u003c/span\u003e as our answer, else let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e \u003d \u003c/span\u003enumber with all bits after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003eth bit \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, and rest of bits \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, then we can either take the segment \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ea\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e]\u003c/span\u003e as an answer or take the answer of the problem \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ec\u003c/i\u003e + 1, \u003ci\u003eb\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e with setting the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003eth bit for all the numbers to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e (note that we don\u0027t benefit by taking the answer of the problem \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ec\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e because \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e OR \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ec\u003c/i\u003e + 1)\u003c/span\u003e is already larger than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e), we take the max of those two as our answer.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eCases where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 0\u003c/span\u003e are impossible because all the bits to the left of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003eth bit are always \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e ≥ \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. See the code below for better understanding of how the algorithm works. \u003cbr /\u003e \u003cstrong\u003eComplexity per test-case:\u003c/strong\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/66/6c/666cc239bd9595b8818555e063d8d8b69ad0cda0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define ll long long\n\nll go(ll a, ll b, ll v, int i \u003d 59) {\n  if (i \u003d\u003d -1)\n    return 1;\n  bool ai \u003d a \u0026gt;\u0026gt; i \u0026amp; 1, bi \u003d b \u0026gt;\u0026gt; i \u0026amp; 1, vi \u003d v \u0026gt;\u0026gt; i \u0026amp; 1;\n  if (vi \u0026amp;\u0026amp; !ai \u0026amp;\u0026amp; !bi)\n    return b - a + 1;\n  if (!vi \u0026amp;\u0026amp; ai \u0026amp;\u0026amp; bi)\n    return 0;\n  if (!vi \u0026amp;\u0026amp; !ai \u0026amp;\u0026amp; !bi)\n    return go(a, b, v, i - 1);\n  if (vi \u0026amp;\u0026amp; ai \u0026amp;\u0026amp; bi)\n    return go(a \u0026amp; ~(1ll \u0026lt;\u0026lt; i), b \u0026amp; ~(1ll \u0026lt;\u0026lt; i), v \u0026amp; ~(1ll \u0026lt;\u0026lt; i), i - 1);\n  if (!vi \u0026amp;\u0026amp; !ai \u0026amp;\u0026amp; bi)\n    return go(a, (1ll \u0026lt;\u0026lt; i) - 1, v, i - 1);\n  if (v \u003d\u003d (1ll \u0026lt;\u0026lt; (i + 1)) - 1)\n    return b - a + 1;\n  ll c \u003d (1ll \u0026lt;\u0026lt; i) - 1;\n  return max(c - a + 1, go((c + 1) \u0026amp; ~(1ll \u0026lt;\u0026lt; i), b \u0026amp; ~(1ll \u0026lt;\u0026lt; i), v \u0026amp; ~(1ll \u0026lt;\u0026lt; i), i - 1));\n}\n\nint main() {\n  int t;\n  scanf(\u0026quot;%d\u0026quot;, \u0026amp;t);\n  while (t--) {\n    ll a, b, v;\n    scanf(\u0026quot;%lld%lld%lld\u0026quot;, \u0026amp;a, \u0026amp;b, \u0026amp;v);\n    printf(\u0026quot;%lld\\n\u0026quot;, go(a, b, v));\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/gym/101810/problem/K\"\u003eK. League of Demacia\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eLet\u0027s say that \u003cspan class\u003d\"tex-span\"\u003eθ\u003c/span\u003e is the angle in which Lux will rotate clockwise, and an optimal \u003cspan class\u003d\"tex-span\"\u003eθ\u003c/span\u003e is an angle which will kill the maximum number of soldiers, notice that there could be an infinite amount of optimal \u003cspan class\u003d\"tex-span\"\u003eθ\u003c/span\u003es, but at least one of them will have a soldier intersecting with either the left border of the laser or the left half of the laser\u0027s base (the line intersecting with the point (0,0) and having length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e), note that this is true because if we take any optimal \u003cspan class\u003d\"tex-span\"\u003eθ\u003c/span\u003e we can keep increasing \u003cspan class\u003d\"tex-span\"\u003eθ\u003c/span\u003e until such soldier appears. \u003cbr /\u003e Now let\u0027s for each soldier figure out if he can be the chosen one, this can be done by calculating the corresponding \u003cspan class\u003d\"tex-span\"\u003eθ\u003c/span\u003e and counting the number of dead soldiers for such a \u003cspan class\u003d\"tex-span\"\u003eθ\u003c/span\u003e. \u003cbr /\u003e let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e be the distance of the soldier to the point \u003cspan class\u003d\"tex-span\"\u003e(0, 0)\u003c/span\u003e, if \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a1/46/a14695593cff94f7414bdba2b63e86884a95bfc4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e the soldier will intersect with the base, otherwise he will intersect with the left border (imaging a circle at \u003cspan class\u003d\"tex-span\"\u003e(0, 0)\u003c/span\u003e with radius \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/90/bd/90bdb954474fda1618cedd63f8d0e9c90e0a685e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e). \u003cbr /\u003e Let \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/71/c8/71c8df9bc8d963261af9dc6ca6f60682ea5b52e2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e be vector that resembles the left side of the base and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/11/08/1108ba51e0fc940add02041f1b73be508a66f051.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e be a vector from \u003cspan class\u003d\"tex-span\"\u003e(0, 0)\u003c/span\u003e to our soldier, if \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a1/46/a14695593cff94f7414bdba2b63e86884a95bfc4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e then \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/50/8b/508bdbaaa789ffef179615c6279e3e26f5409030.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (in terms of direction), else we can get \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/71/c8/71c8df9bc8d963261af9dc6ca6f60682ea5b52e2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e by rotating \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/11/08/1108ba51e0fc940add02041f1b73be508a66f051.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e by \u003cspan class\u003d\"tex-span\"\u003eθ \u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e counter clockwise, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c3/8e/c38e9de93232be36bf8e1d65ba3df573aaa0a943.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003cbr /\u003e \u003c/p\u003e\u003cdiv style\u003d\"text-align: center;\"\u003e\u003cimg src\u003d\"/predownloaded/d8/b0/d8b0c46959fb53d1ce743e1e0a79acc91726aabb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/div\u003e A soldier is dead if he\u0027s to the right of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/71/c8/71c8df9bc8d963261af9dc6ca6f60682ea5b52e2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (can be checked using cross product) and he\u0027s inside the laser beam (|\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/77/5c/775c81a480de2cededa4891f4ca725d88d1fe249.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e after normalizing \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/71/c8/71c8df9bc8d963261af9dc6ca6f60682ea5b52e2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, if it\u0027s not clear read more about the dot product as this is a classical usage of it). \u003cbr /\u003e \u003cstrong\u003eComplexity per test-case:\u003c/strong\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e. \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n#define f(i, x, n) for (int i \u003d x; i \u0026lt; (int)(n); ++i)\n\nint const N \u003d 1000;\ndouble const eps \u003d 1e-7;\n\nstruct V {\n  double x, y;\n  V() {}\n  void sc() { scanf(\u0026quot;%lf%lf\u0026quot;, \u0026amp;x, \u0026amp;y); }\n  V(double a, double b) : x(a), y(b) { }\n  V operator+(V o) { return V(x + o.x, y + o.y); }\n  V operator-(V o) { return V(x - o.x, y - o.y); }\n  double L() { return sqrt(x * x + y * y); }\n  V N() {\n    double l \u003d L();\n    return V(x / l, y / l);\n  }\n  V rot(double th) { return V(x * cos(th) - y * sin(th), x * sin(th) + y * cos(th)); }\n  V operator*(double z) { return V(x * z, y * z); }\n  double operator*(V o) { return x * o.x + y * o.y; }\n  double operator|(V o) { return x * o.y - o.x * y; }\n  void pr() { printf(\u0026quot;%lf %lf\\n\u0026quot;, x, y); }\n} p[N];\n\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n\nint main() {\n  int t;\n  cin \u0026gt;\u0026gt; t;\n  while (t--) {\n    bool dn \u003d false;\n    int n, m;\n    double z;\n    scanf(\u0026quot;%d%d%lf\u0026quot;, \u0026amp;n, \u0026amp;m, \u0026amp;z);\n    z /\u003d 2.0;\n    f(i, 0, n) p[i].sc();\n    f(i, 0, n) {\n      V dv \u003d p[i];\n      double l \u003d dv.L();\n      V c;\n      if (l \u0026lt;\u003d z)\n        c \u003d dv.N();\n      else {\n        double th \u003d acos(z / l);\n        c \u003d dv.rot(th).N();\n      }\n      int ins \u003d 1;\n      f(j, 0, n) if (i !\u003d j) {\n        V d \u003d p[j];\n        double t \u003d abs(d * c);\n        if (t - eps \u0026lt;\u003d z \u0026amp;\u0026amp; (d | c) \u0026gt; -eps)\n          ++ins;\n      }\n      if (ins \u0026gt;\u003d m) {\n        printf(\u0026quot;Yes\\n\u0026quot;);\n        dn \u003d true;\n        break;\n      }\n    }\n    if (!dn)\n      printf(\u0026quot;No\\n\u0026quot;);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/gym/101810/problem/L\"\u003eL. Lazy Teacher\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eThe problem can be solved using Dynamic Programming, the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eDP\u003c/i\u003e\u003c/span\u003e state is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e][\u003ci\u003ep\u003c/i\u003e1][\u003ci\u003ep\u003c/i\u003e2][\u003ci\u003ep\u003c/i\u003e3][\u003ci\u003ep\u003c/i\u003e4][\u003ci\u003ep\u003c/i\u003e5]\u003c/span\u003e which \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e means at the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eth\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e row and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eth\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e column and the colors of the last 5 cells are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e is the earliest one and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e5\u003c/sub\u003e\u003c/span\u003e is the latest one, that is because only the last 5 cells colored will affect the result if we move column by column making sure no two adjacent cells have the same color. \u003cbr /\u003e Now \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e values can reach \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e each, but some different coloring patterns have the same result, for example if you have the colors \u003cspan class\u003d\"tex-span\"\u003e5, 9, 5, 2, 1\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e4\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e5\u003c/sub\u003e\u003c/span\u003e the answer for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e][\u003ci\u003ep\u003c/i\u003e1][\u003ci\u003ep\u003c/i\u003e2][\u003ci\u003ep\u003c/i\u003e3][\u003ci\u003ep\u003c/i\u003e4][\u003ci\u003ep\u003c/i\u003e5]\u003c/span\u003e will be the same for the colors \u003cspan class\u003d\"tex-span\"\u003e0, 1, 0, 2, 3\u003c/span\u003e which means mapping the colors to smaller numbers in a smart way will make: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u0026lt; 1, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u0026lt; 2, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e \u0026lt; 3, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e4\u003c/sub\u003e \u0026lt; 4, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e5\u003c/sub\u003e \u0026lt; 5\u003c/span\u003e while giving the same result, this way we only need to try colors from \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e, and the rest from \u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e will give the same answer as they will have the same mapping so in the DP we only need to iterate over \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e + 1)\u003c/span\u003e colors. \u003cbr /\u003e \u003cstrong\u003eComplexity per test-case:\u003c/strong\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e × \u003ci\u003eM\u003c/i\u003e × \u003ci\u003eN\u003c/i\u003e!)\u003c/span\u003e, the extra \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e is from the loop inside the DP.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\nconst int N \u003d 10000 + 1, M \u003d 5 + 1, MOD \u003d 1000000007;\nint dp[M][N][2][3][4][5];\nint n, m, k, lim;\n\nint p[5], vl[6];\nvoid fix() {\n  memset(vl, 0, sizeof vl);\n  for (int i \u003d 0, idx \u003d 1; i \u0026lt; 5; ++i) {\n    if (vl[p[i]] !\u003d 0)\n      p[i] \u003d vl[p[i]] - 1;\n    else\n      vl[p[i]] \u003d idx, p[i] \u003d idx++ - 1;\n  }\n}\n\nint calc(int i, int j, int p2, int p3, int p4, int p5) {\n  if (i \u003d\u003d n)\n    return calc(0, j + 1, p2, p3, p4, p5);\n  if (j \u003d\u003d m)\n    return 1;\n  int\u0026amp; ret \u003d dp[i][j][p2][p3][p4][p5];\n  if (ret !\u003d -1)\n    return ret;\n  ret \u003d 0;\n  int lft \u003d (n \u003d\u003d 5 ? 0 : (n \u003d\u003d 4 ? p2 : (n \u003d\u003d 3 ? p3 : (n \u003d\u003d 2 ? p4 : p5))));\n  for (int val \u003d 0; val \u0026lt; lim; ++val) {\n    if (val \u003d\u003d lft \u0026amp;\u0026amp; j !\u003d 0)\n      continue;\n    if (val \u003d\u003d p5 \u0026amp;\u0026amp; i !\u003d 0)\n      continue;\n    p[0] \u003d p2, p[1] \u003d p3, p[2] \u003d p4, p[3] \u003d p5, p[4] \u003d val;\n    fix();\n    ret \u003d (ret + (val \u003d\u003d 5 ? k - 5LL : 1LL) * calc(i + 1, j, p[1], p[2], p[3], p[4])) % MOD;\n  }\n  return ret;\n}\n\nint main(int argc, char* argv[]) {\n  int t;\n  scanf(\u0026quot;%d\u0026quot;, \u0026amp;t);\n  while (t--) {\n    scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;n, \u0026amp;m, \u0026amp;k);\n    lim \u003d min(k, 6);\n    for (int i \u003d 0; i \u0026lt; n; ++i)\n      for (int j \u003d 0; j \u0026lt; m; ++j)\n        memset(dp[i][j], -1, sizeof dp[i][j]);\n    printf(\u0026quot;%d\\n\u0026quot;, calc(0, 0, 0, 0, 0, 0));\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/gym/101810/problem/M\"\u003eM.Greedy Pirate\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eIt\u0027s obvious that we need to traverse the maximum number of edges. Let\u0027s denote \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e as the starting node and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e as the finishing node, the only edges that we can not traverse are the edges on the path directed from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, so we need to calculate the sum of coins on this path and then subtract it from the total number of coins on all edges. Calculating the sum of coins on a path can be done easily by finding the lowest common ancestor(LCA) of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, the answer will be: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecost\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e(\u003ci\u003eu\u003c/i\u003e) - \u003ci\u003ecost\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e(\u003ci\u003elca\u003c/i\u003e) + \u003ci\u003ecost\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(\u003ci\u003ev\u003c/i\u003e) - \u003ci\u003ecost\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(\u003ci\u003elca\u003c/i\u003e)\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecost\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e is the cost of the directed path from the root to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecost\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e is the cost of the directed path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to the root which can be pre-calculated with a DFS. \u003cbr /\u003e \u003cstrong\u003eComplexity per test-case:\u003c/strong\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e9/82/e9824f6612c4b83669d669fe6fd4d9e558305dfd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\ntypedef pair\u0026lt;int, int\u0026gt; pp;\nint const N \u003d 1e5 + 10, oo \u003d 1e9;\nint mod \u003d oo + 7;\nll const OO \u003d 1e18;\nint t, n, q;\nvector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; from_root, dp;\nvector\u0026lt;int\u0026gt; dep;\nvector\u0026lt;vector\u0026lt;pair\u0026lt;int, pp\u0026gt; \u0026gt; \u0026gt; adj;\n\nvoid dfs(int u, int p \u003d 0, ll cs1 \u003d 0, ll cs2 \u003d 0) {\n  from_root[0][u] \u003d cs1;\n  from_root[1][u] \u003d cs2;\n  dp[u][0] \u003d p;\n  for (auto v : adj[u]) {\n    if (v.first \u003d\u003d p)\n      continue;\n    int a \u003d v.second.first, b \u003d v.second.second;\n    dep[v.first] \u003d dep[u] + 1;\n    dfs(v.first, u, cs1 + a, cs2 + b);\n  }\n}\n\nint lca(int a, int b) {\n  if (dep[a] \u0026gt; dep[b])\n    swap(a, b);\n  for (int i \u003d 18; i \u0026gt; -1; i--)\n    if (dep[b] - (1 \u0026lt;\u0026lt; i) \u0026gt;\u003d dep[a])\n      b \u003d dp[b][i];\n  if (b \u003d\u003d a)\n    return a;\n  for (int i \u003d 18; i \u0026gt; -1; i--) {\n    if (dp[a][i] !\u003d dp[b][i]) {\n      a \u003d dp[a][i];\n      b \u003d dp[b][i];\n    }\n  }\n  return dp[a][0];\n}\n\nint main() {\n  scanf(\u0026quot;%d\u0026quot;, \u0026amp;t);\n  while (t--) {\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    dp \u003d vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;(n + 1, vector\u0026lt;int\u0026gt;(19));\n    from_root \u003d vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;(2, vector\u0026lt;int\u0026gt;(n + 1));\n    dep \u003d vector\u0026lt;int\u0026gt;(n + 1);\n    adj \u003d vector\u0026lt;vector\u0026lt;pair\u0026lt;int, pp\u0026gt; \u0026gt; \u0026gt;(n + 1);\n    ll sumAll \u003d 0;\n    for (int i \u003d 0; i \u0026lt; n - 1; i++) {\n      int u, v, a, b;\n      scanf(\u0026quot;%d%d%d%d\u0026quot;, \u0026amp;u, \u0026amp;v, \u0026amp;a, \u0026amp;b);\n      adj[u].push_back({ v, { a, b } });\n      adj[v].push_back({ u, { b, a } });\n      sumAll +\u003d a + b;\n    }\n    dfs(1);\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;q);\n    for (int j \u003d 1; j \u0026lt; 19; j++)\n      for (int i \u003d 1; i \u0026lt;\u003d n; i++)\n        if (dp[i][j - 1])\n          dp[i][j] \u003d dp[dp[i][j - 1]][j - 1];\n    while (q--) {\n      int u, v;\n      scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;u, \u0026amp;v);\n      int lc \u003d lca(u, v);\n      printf(\u0026quot;%lld\\n\u0026quot;, sumAll - from_root[1][v] + from_root[1][lc] - from_root[0][u] + from_root[0][lc]);\n    }\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}