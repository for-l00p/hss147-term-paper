{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1527877307,"rating":6,"authorHandle":"ghost_shedow","modificationTimeSeconds":1527877307,"id":59797,"title":"\u003cp\u003eC(n,r)%P where p is prime , using lucas theorem \u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI found the following code on quora that computes C(n,r)%p using lucas theorem .\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eC++ code ::\n#define LL long long\nvector\u0026lt;LL\u0026gt; Fact;\nvector\u0026lt;LL\u0026gt; Invfact;\nvector\u0026lt;LL\u0026gt; Inv;\n \n//Preprocessing factorial and its inverses in O(p) time.\nvoid compute(int P)\n{\n\tFact.clear();\n\tInvfact.clear();\n\tFact.resize(P);\n\tInvfact.resize(P);\n\tInv.clear();\n    Inv.resize(P);\n        \n\tFact[0]\u003dFact[1]\u003d1;\n\tInvfact[0]\u003dInvfact[1]\u003d1;\n\tInv[0]\u003d1;\n    Inv[1]\u003d1;\n\t\n\tfor(int i\u003d2;i\u0026lt;P;i++)\n\t{\n\t\tFact[i]\u003d(Fact[i-1]*i)%P;\n\t\tInv[i]\u003d((P-P/i)*Inv[P%i])%P;  //.................... I am unable to understand this line .\n\t}\n}\n \n//Computes C(N,R) modulo P in O(log(n)) time.\nLL Lucas(LL N,LL R,int P)\n{\n\tif(R\u0026lt;0||R\u0026gt;N)\n\t{\n\t\treturn 0;\n\t}\n\t\n\tif(R\u003d\u003d0||R\u003d\u003dN)\n\t{\n\t\treturn 1;\n\t}\n\t\n\tif(N\u0026gt;\u003dP)\n\t{\n\t\treturn (Lucas(N/P,R/P,P)*Lucas(N%P,R%P,P))%P;\n\t}\n\t\n\treturn (Fact[N]*(Invfact[N-R]*Invfact[R])%P)%P;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI have implemented lucas theorem . For finding inverse I used Fermat\u0027s little theorem . I am not geting how inv[i] is being calculated in function compute(). Someone please explain it to me . Thanks . \u003c/p\u003e\u003c/div\u003e","tags":["lucas theorem","modular inverse","#combinatorics","#number theory"]}}