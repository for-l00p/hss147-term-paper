{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1515875607,"rating":145,"authorHandle":"burunduk3","modificationTimeSeconds":1515964285,"id":57104,"title":"\u003cp\u003eАлгоритм Монтгомери: (A × B) % N\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eВступление\u003c/h1\u003e\u003cp\u003eНедавно мне рассказали про некое «преобразование Монтгомери», которое якобы сводит вычисления по произвольному модулю к вычислениям по модулю \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. Звучит интересно: во всяких вычислениях по простому модулю самое долгое место — как раз взятие по модулю после каждой операции. Но как именно преобразование работает, не рассказали. Повезло, что я живу в эпоху интернета и любую интересующую меня тему могу с тем или иным успехом загуглить.  \u003c/p\u003e\u003cp\u003eГугл рассказал, что штука называется «алгоритм Монтгомери», описана на \u003ca href\u003d\"https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9C%D0%BE%D0%BD%D1%82%D0%B3%D0%BE%D0%BC%D0%B5%D1%80%D0%B8\"\u003eвикипедии\u003c/a\u003e и итмошных \u003ca href\u003d\"https://neerc.ifmo.ru/wiki/index.php?title\u003d%D0%A3%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE_%D0%9C%D0%BE%D0%BD%D1%82%D0%B3%D0%BE%D0%BC%D0%B5%D1%80%D0%B8\"\u003eвики-конспектах\u003c/a\u003e. Оба описания мне не очень понравились, потому что (хоть и объясняют, что делать) показывают гипноформулу, которая магическим образом решает нашу проблему. На вики-конспектах есть ссылка на англоязычную статью, в которой хотя бы пояснено, почему формула работает. Впрочем, пока я с этим всем разбирался, выяснил ещё пару интересных моментов, так что всем привет и поехали.\u003c/p\u003e\u003ch1\u003eО чём речь\u003c/h1\u003e\u003cp\u003eЗадача перед нами сегодня простая: умножить два числа по модулю третьего, то есть вычислить \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eA\u003c/i\u003e × \u003ci\u003eB\u003c/i\u003e) % \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e. Вот только делить с остатком мы очень не любим: в целом инструкция деления в компьютерах выполняется не очень быстро, а уж если числа длинные, то не только работает долго, так ещё и писать это нудно и сложно.\u003c/p\u003e\u003ch1\u003eИ что теперь\u003c/h1\u003e\u003cp\u003eФокус, который предложил Монтгомери следующий: давайте возьмём некоторое число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e и будем вычислять не \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eA\u003c/i\u003e × \u003ci\u003eB\u003c/i\u003e) % \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, а \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eA\u003c/i\u003e × \u003ci\u003eB\u003c/i\u003e × \u003ci\u003eR\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e - 1\u003c/sup\u003e) % \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e. Казалось бы, добавилось ещё и деление по модулю, тоже операция не сахар. Однако, при некоторых \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e это почему-то значительно упростит нашу задачу.\u003c/p\u003e\u003cp\u003eВот только чем это нам поможет умножить два числа? Предлагается сначала умножить числа на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e, потом умножить друг с другом, потом умножить на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e - 1\u003c/sup\u003e\u003c/span\u003e. Действительно, перевод \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u0027 \u003d (\u003ci\u003eX\u003c/i\u003e × \u003ci\u003eR\u003c/i\u003e) % \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e переводит сложение в сложение, а умножение — в то самое умножение с делением на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e, которое было обещано раньше: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u0027 × \u003ci\u003eB\u003c/i\u003e\u0027 × \u003ci\u003eR\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e - 1\u003c/sup\u003e \u003d \u003ci\u003eA\u003c/i\u003e × \u003ci\u003eR\u003c/i\u003e × \u003ci\u003eB\u003c/i\u003e × \u003ci\u003eR\u003c/i\u003e × \u003ci\u003eR\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e - 1\u003c/sup\u003e \u003d \u003ci\u003eA\u003c/i\u003e × \u003ci\u003eB\u003c/i\u003e × \u003ci\u003eR\u003c/i\u003e \u003d (\u003ci\u003eA\u003c/i\u003e × \u003ci\u003eB\u003c/i\u003e)\u0027\u003c/span\u003e. Википедия такое \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u0027\u003c/span\u003e называет \u003cem\u003en-остатком\u003c/em\u003e числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eОставим пока в стороне вопрос о том, как быстро переводить числа туда-сюда и разберёмся, как же делить на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e по модулю \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003ch1\u003eГипноформула\u003c/h1\u003e\u003cp\u003eТа самая, которая написана везде и считает что-то полезное. (Я немного наврал в ней, но скоро исправлюсь.)\u003c/p\u003e\u003cp\u003e \u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/03/13/03131b6fd5864f138939afbd012fad3fb2ee20b9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eОбратите внимание, что в правой части обычное, целочисленное деление на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e, никакого деления по модулю. Интересно, в какую сторону округлять? Ещё появился какой-то непонятный \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u0027\u003c/span\u003e, что это вообще такое?\u003c/p\u003e\u003cp\u003eНа самом деле, формула не так уж и странна, как кажется на первый взгляд. Многие посетители сайта \u003ca href\u003d\"codeforces.com\"\u003ecodeforces.com\u003c/a\u003e иногда решают задачи по спортивному программированию, в некоторых таких задачах надо выдать ответ по модулю \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e + 7\u003c/span\u003e, а порой в промежуточных вычислениях приходится делить на два. Как же разделить число на два по модулю \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e + 7\u003c/span\u003e? Если число чётное, то взять и разделить, к нечётному прибавить \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e + 7\u003c/span\u003e (получится чётное) и тоже разделить.\u003c/p\u003e\u003cp\u003eВ гипноформуле такой же фокус, просто обобщённый. Мы к числу \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e прибавим \u003cem\u003eнечто\u003c/em\u003e, умноженное на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e (остаток по модулю не изменился) и поделим на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e. Если мы подберём \u003cem\u003eнечто\u003c/em\u003e так, чтобы деление на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e произошло без остатка (вот и ответ на вопрос про округление), то получим почти правильный ответ.\u003c/p\u003e\u003ch2\u003eГде взять нечто\u003c/h2\u003e\u003cp\u003eНа самом деле, у этой формулы есть брат-близнец. Нам нужно вести одновременное вычисление по двум разным модулям — ровно это было в \u003ca href\u003d\"http://e-maxx.ru/algo/chinese_theorem\"\u003eКТО\u003c/a\u003e. Пришла пора выяснить, что такое \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u0027\u003c/span\u003e. Википедия и конспекты предлагают брать его из формулы \u003cstrike\u003e\u003cspan class\u003d\"tex-span\"\u003e1 \u003d \u003ci\u003eN\u003c/i\u003e × \u003ci\u003eN\u003c/i\u003e\u0027 + \u003ci\u003eR\u003c/i\u003e × \u003ci\u003eR\u003c/i\u003e\u0027\u003c/span\u003e\u003c/strike\u003e \u003cspan class\u003d\"tex-span\"\u003e1 \u003d \u003ci\u003eR\u003c/i\u003e × \u003ci\u003eR\u003c/i\u003e\u0027 - \u003ci\u003eN\u003c/i\u003e × \u003ci\u003eN\u003c/i\u003e\u0027\u003c/span\u003e, то есть из расширенного алгоритма Евклида для \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e. Идея хорошая, но для понимания мне было проще считать, что \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u0027 \u003d ( - \u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e - 1\u003c/sup\u003e) % \u003ci\u003eR\u003c/i\u003e\u003c/span\u003e (эквивалентность этих двух \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u0027\u003c/span\u003e остаётся читателю в качестве упражнения). То есть, числитель гипноформулы, вычисленный по модулю \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e выглядит как \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e + \u003ci\u003eT\u003c/i\u003e × ( - \u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e - 1\u003c/sup\u003e × \u003ci\u003eN\u003c/i\u003e) \u003d \u003ci\u003eT\u003c/i\u003e - \u003ci\u003eT\u003c/i\u003e × 1 \u003d 0\u003c/span\u003e. И правда, делится на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e. Кстати, это даёт нам первое ограничение на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e: оно должно быть взаимно просто с \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003ch2\u003eГде я соврал\u003c/h2\u003e\u003cp\u003eПо формуле получилось, что мы вычислили правильный ответ по модулю \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e. Может быть, получилось и правда нужное нам число. А может быть, с добавлением \u003cspan class\u003d\"tex-span\"\u003e15763 × \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, и теперь всё равно придётся брать по модулю. С тем же успехом можно было просто вычислить \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e × \u003ci\u003eB\u003c/i\u003e\u003c/span\u003e и сказать «это ответ, держите». Но не совсем.\u003c/p\u003e\u003cp\u003eДавайте оценим что получилось, считая, скажем, что \u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003eT\u003c/i\u003e \u0026lt; \u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e (как это обычно и бывает после умножения двух чисел). Как известно, \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eT\u003c/i\u003e × \u003ci\u003eN\u003c/i\u003e\u0027) % \u003ci\u003eR\u003c/i\u003e \u0026lt; \u003ci\u003eR\u003c/i\u003e\u003c/span\u003e. Остаток по модулю вообще всегда меньше модуля. Числитель в формуле меньше, чем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e + \u003ci\u003eN\u003c/i\u003e × \u003ci\u003eR\u003c/i\u003e\u003c/span\u003e, а его потом ещё и на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e поделят. Уже видно, что если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e \u0026gt; \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, то результат будет меньше \u003cspan class\u003d\"tex-span\"\u003e2 × \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e. То есть после применения гипноформулы, конечно, надо ещё взять по модулю, но это «взятие» — одно сравнение и, возможно, одно вычитание. На вики-конспектах так и написано: \u003ccode\u003eif (u \u0026gt;\u003d n) return u — n;\u003c/code\u003e\u003c/p\u003e\u003cp\u003eС помощью нехитрого \u003cstrong\u003eif\u003c/strong\u003e\u0027а мы починили формулу, получили правильный ответ и второе ограничение на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e: оно должно быть больше, чем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003ch2\u003eШило на мыло\u003c/h2\u003e\u003cp\u003eВзятие остатка по модулю \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e заменилось на деление на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e, и ещё взятие остатка по модулю \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e в числителе формулы. Где же польза, если мы всего лишь одно деление заменили двумя другими? Фокус в том, что мы сами выбираем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e и можем подобрать такое, делить на которое — одно удовольствие. Степень двойки, например. Или, если у нас длинная арифметика с каким-то основанием, то степень этого основания. Тогда остатки по модулю и деления превратятся в сдвиги и выкидывание лишних цифр.\u003c/p\u003e\u003ch1\u003eПодведём итог\u003c/h1\u003e\u003cp\u003eПолучилось, что аккуратно выбрав \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e (например, минимальное \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e \u0026gt; \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e) мы научились без деления вычислять \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eA\u003c/i\u003e × \u003ci\u003eB\u003c/i\u003e × \u003ci\u003eR\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e - 1\u003c/sup\u003e) % \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e. Для этого нам надо заранее вычислить \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u0027\u003c/span\u003e — один раз для каждого модуля. Ещё нам может пригодиться \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eR\u003c/i\u003e % \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, и, кажется (на самом деле нет), \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e - 1\u003c/sup\u003e % \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e. Зато на самом деле ещё понадобится \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e % \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e (впрочем, не всегда).\u003c/p\u003e\u003cp\u003eДальше вики-конспекты утверждают, что для умножения это не очень полезно (наглая ложь — см. ниже), зато полезно для возведения в степень. И правда, при возведении в степень нам надо один раз перейти от числа к его n-остатку, уже его возвести в степень, по полученному n-остатку ответа вычислить настоящее значение ответа. Честное деление для перевода туда-сюда использовалось всего дважды, а вот умножения внутри возведения в степень все быстренькие, монтгомериевые.\u003c/p\u003e\u003cp\u003eЕщё лучше дела обстоят, например, с тестом Миллера—Рабина, проверкой числа на простоту. Напомню, там надо было:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eРазложить \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e - 1 \u003d \u003ci\u003eU\u003c/i\u003e × 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e\u003c/li\u003e   \u003cli\u003eСгенерировать случайное число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e. (Кому оно надо? Сгенерируем сразу n-остаток.)\u003c/li\u003e   \u003cli\u003eВозвести его в степень \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eU\u003c/i\u003e\u003c/span\u003e. (Получим n-остаток возведённого, переводить в обычные числа лень.)\u003c/li\u003e   \u003cli\u003eСравнить с единицей. (Упс. Ну ладно, сравним с n-остатком единицы, то есть с \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.)\u003c/li\u003e   \u003cli\u003eВозводить в квадрат, попутно сравнивая с \u003cstrong\u003e1\u003c/strong\u003e и \u003cstrong\u003e-1\u003c/strong\u003e. (Ну вы поняли, продолжаем держаться в n-остатках, сравниваем с \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e - \u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e).\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eТо есть, в некоторых случаях вообще не приходится переводить числа в n-остатки и обратно. Впрочем, так ли это сложно?\u003c/p\u003e\u003cp\u003eСкажем, по n-остатку \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u0027\u003c/span\u003e надо вычислить обычный \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e \u003d (\u003ci\u003eX\u003c/i\u003e\u0027 × \u003ci\u003eR\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e - 1\u003c/sup\u003e) % \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e. Надо ли брать по модулю? Конечно, нет. И умножать ничего не надо, и даже вычислять \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e - 1\u003c/sup\u003e % \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e — лишнее. Потому что делить на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e по модулю \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e — ровно то, что делает гипноформула, надо просто применить её ещё один раз к результату.\u003c/p\u003e\u003cp\u003eС переводом числа в его n-остаток сложнее, но не сильно. Здесь-то и пригодится предподсчитанный \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e % \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, ведь \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eX\u003c/i\u003e × \u003ci\u003eR\u003c/i\u003e) \u003d (\u003ci\u003eX\u003c/i\u003e × \u003ci\u003eR\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e × \u003ci\u003eR\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e - 1\u003c/sup\u003e)\u003c/span\u003e, а это мы уже умеем считать по гипноформуле. То есть, в переводе чисел к n-остаткам и обратно тоже не нужно взятие остатка по модулю, достаточно применить умножение Монтгомери ещё пару раз.\u003c/p\u003e\u003ch1\u003eВот и сказочке конец\u003c/h1\u003e\u003cp\u003eА кто слушал — может ещё почитать, \u003ca href\u003d\"https://pastebin.com/M7bsnqnx\"\u003eкак я простые числа ищу\u003c/a\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e$ cat primes.in \n100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000\n$ g++ -Ofast -Wall -Wextra -Werror -o primes -x c++ primes.c++\n$ time ./primes \u0026lt; primes.in 2\u0026gt; /dev/null\n36\n\nreal    0m1.233s\nuser    0m1.230s\nsys     0m0.003s\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["арифметика","модуль","умножение"]}}