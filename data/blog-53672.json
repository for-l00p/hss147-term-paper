{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1501838371,"rating":-28,"authorHandle":"liaoyulei","modificationTimeSeconds":1501838460,"id":53672,"title":"\u003cp\u003e最近公共祖先（#425 div2 D）\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e最近公共祖先（LCA）采用倍增算法，father[x][y]存点x的第2^y层祖先，father[x][0]为x的父节点，\u003ccode\u003efather[x][y]\u003dfather[father[x][y-1]][y-1]\u003c/code\u003e,查询公共祖先时，先将两点上调至同一层，之后再同时往上逼近，注意理解代码。 计算树中两点距离时，可以先算出两点的lca，距离满足\u003ccode\u003edepth[x]+depth[y]-2*depth[lca(x,y)]\u003c/code\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;stdio.h\u0026gt;\nint depth[100005],father[100005][25],lg[100005];\nint getdep(int x){\n    if(x\u003d\u003d1){\n        return 0;\n    }\n    if(depth[x]){\n        return depth[x];\n    }\n    return getdep(father[x][0])+1;\n}\nvoid init(int n){\n    int i,j,e\u003d2;\n    for(i\u003d2;i\u0026lt;\u003dn;++i){\n        lg[i]\u003dlg[i-1];\n        if(i\u003d\u003de){\n            ++lg[i];\n            e\u0026lt;\u0026lt;\u003d1;\n        }\n    }\n    for(i\u003d2;i\u0026lt;\u003dn;++i){\n        scanf(\u0026quot;%d\u0026quot;,father[i]);\n    }\n    for(j\u003d1;j\u0026lt;20;++j){\n        for(i\u003d1;i\u0026lt;\u003dn;++i){\n            father[i][j]\u003dfather[father[i][j-1]][j-1];\n        }\n    }\n    for(i\u003d2;i\u0026lt;\u003dn;++i){\n        depth[i]\u003dgetdep(i);\n    }\n}\nint lca(int x,int y){\n    int i;\n    if(depth[x]\u0026lt;depth[y]){\n        x^\u003dy;\n        y^\u003dx;\n        x^\u003dy;\n    }\n    while(depth[x]\u0026gt;depth[y]){\n        x\u003dfather[x][lg[depth[x]-depth[y]]];\n    }\n    if(x\u003d\u003dy){\n        return x;\n    }\n    for(i\u003dlg[depth[x]];i\u0026gt;\u003d0;--i){\n        if(father[x][i]!\u003dfather[y][i]){\n            x\u003dfather[x][i];\n            y\u003dfather[y][i];\n        }\n    }\n    return father[x][0];\n}\nint length(int x,int y){\n    return depth[x]+depth[y]-2*depth[lca(x,y)];\n}\nint main(){\n    int n,q,k,a,b,c,tmp,ans;\n    scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;q);\n    init(n);\n    while(q--){\n        k\u003d1,ans\u003d0;\n        scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;a,\u0026amp;b,\u0026amp;c);\n        tmp\u003dlca(a,b);\n        if(depth[tmp]\u0026gt;depth[k]){\n            k\u003dtmp;\n        }\n        tmp\u003dlca(a,c);\n        if(depth[tmp]\u0026gt;depth[k]){\n            k\u003dtmp;\n        }\n        tmp\u003dlca(b,c);\n        if(depth[tmp]\u0026gt;depth[k]){\n            k\u003dtmp;\n        }\n        tmp\u003dlength(k,a);\n        if(tmp\u0026gt;ans){\n            ans\u003dtmp;\n        }\n        tmp\u003dlength(k,b);\n        if(tmp\u0026gt;ans){\n            ans\u003dtmp;\n        }\n        tmp\u003dlength(k,c);\n        if(tmp\u0026gt;ans){\n            ans\u003dtmp;\n        }\n        printf(\u0026quot;%d\\n\u0026quot;,ans+1);\n    }\n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["#algorithms","lca"]}}