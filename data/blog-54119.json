{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1503923881,"rating":0,"authorHandle":"Light","modificationTimeSeconds":1503923881,"id":54119,"title":"\u003cp\u003eWeek 5 Discussion\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello everyone! I hope you\u0027re doing well.\u003c/p\u003e\u003cp\u003eFor this week we\u0027ve mainly solved problems using what we call \u0026quot;Brute Force\u0026quot;, in which we find a good way of trying all the possible solutions for a problem and choosing the best one. This method should \u003cstrong\u003ealways\u003c/strong\u003e be the first thing you try to use in any problem, but then if it\u0027s too much or can\u0027t be done this way you either try to make some improvements on it (as we did), or try finding another way of solving the problem.\u003c/p\u003e\u003cp\u003eBefore talking about the problems we discussed, I would like to talk about the problem I gave you the week before (Cut Ribbon). \u003ca href\u003d\"//codeforces.com/problemset/problem/189/A\"\u003ehttp://codeforces.com/problemset/problem/189/A\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe can notice that the length of the ribbon is only 4000 which is relatively small, so our solution would pass if it had around O(n^2) complexity or less. As we learned, lets try finding a Brute Force solution. Lets make 3 loops trying all possible number of pieces we take of length A, B, and C.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor(int i\u003d0; i\u0026lt;\u003dN/A; ++i){\n\tfor(int j\u003d0; j\u0026lt;\u003dN/B; ++j){\n\t\tfor(int k\u003d0; k\u0026lt;\u003dN/C; ++k){\n\n\t\t\t\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis means that, we will try taking \u003cem\u003ei\u003c/em\u003e pieces of length A, \u003cem\u003ej\u003c/em\u003e pieces of length B, and \u003cem\u003ek\u003c/em\u003e pieces of length C (we will try taking from 0 pieces till N/X pieces because that\u0027s the maximum we can take for a piece of length X).\u003c/p\u003e\u003cp\u003eSo, now if we check inside the loop if this combination of pieces works, we will have tried all possible solutions and we will surely get the correct answer. As follows:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint best\u003d-1;\nfor(int i\u003d0; i\u0026lt;\u003dN/A; ++i){\n\tfor(int j\u003d0; j\u0026lt;\u003dN/B; ++j){\n\t\tfor(int k\u003d0; k\u0026lt;\u003dN/C; ++k){\n\t\t\tif(i*A + j*B + k*C \u003d\u003dn)\n\t\t\t\tbest\u003dmax(best, i+j+k);\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis solution is 100% correct, but the only problem we have is that the complexity of it is O(n^3) which is off limits. Now we will try to find a way to reduce the complexity, we can notice that if we take X length for pieces of size A, and Y length for pieces of size B, then the length left for pieces of size C is N-X-Y. So we can use that to remove the most inner loop and check if the length left is dividable by length C.\u003c/p\u003e\u003cp\u003eSo we will have our code reduced to the following:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint best\u003d-1;\nfor(int i\u003d0; i\u0026lt;\u003dN/A; ++i){\n\tfor(int j\u003d0; j\u0026lt;\u003dN/B; ++j){\n\t\tif(i*A + j*B \u0026lt;\u003d N){\n\t\t\tint left\u003dN-i*A-j*B;\n\t\t\tif(left%C\u003d\u003d0){\n\t\t\t\tint k\u003dleft/C;\n\t\t\t\tbest\u003dmax(best, i+j+k);\n\t\t\t}\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn which, this code is only O(n^2) and gives us the correct answer.\u003c/p\u003e \u003chr /\u003e\u003cp\u003eThe first problem we discussed yesterday was UVA — Division ( \u003ca href\u003d\"https://uva.onlinejudge.org/index.php?option\u003donlinejudge\u0026amp;page\u003dshow_problem\u0026amp;problem\u003d666\"\u003ehttps://uva.onlinejudge.org/index.php?option\u003donlinejudge\u0026amp;page\u003dshow_problem\u0026amp;problem\u003d666\u003c/a\u003e ) — if UVA links don\u0027t open, try opening it in Incognito mode.\u003c/p\u003e\u003cp\u003eThe problem wanted us — given N — to find the number of pairs of number A,B such that both A and B consist of 5 digits each, all the digits in both numbers are distinct (so from 0 to 9), and A/B\u003dN.\u003c/p\u003e\u003cp\u003eOur first solution was to try looping through all 5 digit numbers for A, and all 5 digit numbers for B and check if they satisfy the rules, but we saw that the complexity of this solution is 10^10 which is too much.\u003c/p\u003e\u003cp\u003eThen we noticed from the given rule that if we have our number B, then the corresponding number A can easily be found by using this equation A\u003dN*B (same equation given in the problem).\u003c/p\u003e\u003cp\u003eSo instead of looping on both numbers, we can now loop only on B and find the corresponding A, only thing left is checking if the digits are distinct and they\u0027re both 5 digits (implementation problems).\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\nconst int N \u003d 100000 + 10;\nconst int M \u003d 1000000007;\nconst double PI \u003d atan(1) * 4;\nconst int oo \u003d 1000000000;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef vector\u0026lt;vi\u0026gt; vvi;\ntypedef pair\u0026lt;int, int\u0026gt; ii;\n#define pb push_back \n#define all(c) (c).begin(),(c).end()\nint n;\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t#endif\n\tcin\u0026gt;\u0026gt;n;\n\twhile(n){\n\t\tint ans\u003d0;\n\t\tvector\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt; v;\n\t\tfor(int b\u003d1234; b\u0026lt;\u003d98765/n; ++b){\n\t\t\tint a\u003db*n;\n\t\t\tbool can\u003dtrue;\n\t\t\tint x\u003da, y\u003db;\n\t\t\tbool arr[10]\u003d{};\n\t\t\tif(x\u0026lt;10000)\n\t\t\t\tarr[0]\u003dtrue;\n\t\t\twhile(x){\n\t\t\t\tint d\u003dx%10;\n\t\t\t\tif(arr[d]\u003d\u003dtrue)\n\t\t\t\t\tcan\u003dfalse;\n\t\t\t\tarr[d]\u003dtrue;\n\t\t\t\tx/\u003d10;\n\t\t\t}\n\t\t\tif(y\u0026lt;10000){\n\t\t\t\tif(arr[0]\u003d\u003dtrue)\n\t\t\t\t\tcan\u003dfalse;\n\t\t\t\tarr[0]\u003dtrue;\n\t\t\t}\n\t\t\twhile(y){\n\t\t\t\tint d\u003dy%10;\n\t\t\t\tif(arr[d]\u003d\u003dtrue)\n\t\t\t\t\tcan\u003dfalse;\n\t\t\t\tarr[d]\u003dtrue;\n\t\t\t\ty/\u003d10;\n\t\t\t}\n\t\t\tif(can\u003d\u003dtrue){\n\t\t\t\tv.push_back(make_pair(a,b));\n\t\t\t\t++ans;\n\t\t\t}\n\t\t}\n\t\tif(ans\u003d\u003d0)\n\t\t\tprintf(\u0026quot;There are no solutions for %d.\\n\u0026quot;, n);\n\t\tfor(int i\u003d0; i\u0026lt;ans; ++i)\n\t\t\tprintf(\u0026quot;%05d / %05d \u003d %d\\n\u0026quot;, v[i].first, v[i].second, n);\n\t\tcin\u0026gt;\u0026gt;n;\n\t\tif(n)\n\t\t\tcout\u0026lt;\u0026lt;endl;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003chr /\u003e\u003cp\u003eSecond problem was UVA — Simple Equations ( \u003ca href\u003d\"https://uva.onlinejudge.org/index.php?option\u003donlinejudge\u0026amp;page\u003dshow_problem\u0026amp;problem\u003d2612\"\u003ehttps://uva.onlinejudge.org/index.php?option\u003donlinejudge\u0026amp;page\u003dshow_problem\u0026amp;problem\u003d2612\u003c/a\u003e ).\u003c/p\u003e\u003cp\u003eThis problem was as follows:\u003c/p\u003e\u003cp\u003eGiven 3 integers A, B, C (1 \u0026lt;\u003d A,B,C \u0026lt;\u003d 10000). Find 3 distinct integers X,Y,Z such that:\u003c/p\u003e\u003cp\u003eX+Y+Z\u003dA\u003c/p\u003e\u003cp\u003eX*Y*Z\u003dB\u003c/p\u003e\u003cp\u003eX^2+Y^2+Z^2\u003dC\u003c/p\u003e\u003cp\u003eNow, the first Brute Force solution that comes to mind is to try all combinations of X, Y, Z (notice they can be negative!) from -10000 till 10000 each, that would surely give the correct answer but the complexity of it is 10^12 which is way off limits.\u003c/p\u003e\u003cp\u003eBut looking at the formulas more closely, from the 3rd formula, we can see that since C is at most 10000 then none of the numbers from X,Y,Z can be bigger than square root of 10000 (which is |100|), since if there\u0027s at least one of them bigger than 100, lets say 101, then 101^2\u003d10201 which is surely bigger than C.\u003c/p\u003e\u003cp\u003eSo knowing this, we can instead of trying all the numbers from -10000 till 10000, we can reduce it to only trying numbers from -100 till 100, this would give us the complexity of 200^3 which is 8*10^6 which is AC.\u003c/p\u003e\u003cp\u003eBut we can also use the first equation to reduce the complexity further! If we only loop on X and Y, then Z can be found by using that formula simply: Z\u003dA-X-Y (first formula).\u003c/p\u003e\u003cp\u003eSo now we have reduced the complexity to 200^2 which is much faster than what we had at the beginning. Now only thing left is to check if the 3 rules apply to the numbers we have, and pick the best one according to the problem.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\nconst int N \u003d 100000 + 10;\nconst int M \u003d 1000000007;\nconst double PI \u003d atan(1) * 4;\nconst int oo \u003d 1000000000;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef vector\u0026lt;vi\u0026gt; vvi;\ntypedef pair\u0026lt;int, int\u0026gt; ii;\n#define pb push_back \n#define all(c) (c).begin(),(c).end()\n\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t#endif\n\tint T;\n\tcin\u0026gt;\u0026gt;T;\n\twhile(T--){\n\t\tint A,B,C;\n\t\tcin\u0026gt;\u0026gt;A\u0026gt;\u0026gt;B\u0026gt;\u0026gt;C;\n\t\tbool found\u003dfalse;\n\t\tfor(int x\u003d-100; x\u0026lt;101\u0026amp;\u0026amp;!found; ++x){\n\t\t\tfor(int y\u003d-100; y\u0026lt;101\u0026amp;\u0026amp;!found; ++y){\n\t\t\t\tint z\u003dA-x-y;\n\t\t\t\tif(x\u003d\u003dy || x\u003d\u003dz || y\u003d\u003dz)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(x*y*z\u003d\u003dB \u0026amp;\u0026amp; x*x+y*y+z*z\u003d\u003dC){\n\t\t\t\t\tprintf(\u0026quot;%d %d %d\\n\u0026quot;, x, y ,z);\n\t\t\t\t\tfound\u003dtrue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!found)\n\t\t\tprintf(\u0026quot;No solution.\\n\u0026quot;);\n\t}\n\t\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003chr /\u003e\u003cp\u003eThen the last problem we discussed was Two TVs ( \u003ca href\u003d\"//codeforces.com/problemset/problem/845/C\"\u003ehttp://codeforces.com/problemset/problem/845/C\u003c/a\u003e ).\u003c/p\u003e\u003cp\u003eThis problem gave us the start and end times of N shows, and wanted to us to see if we can watch all these shows using only 2 TVs. We could see that if we could find the maximum number of shows being held at one point of time, we can do the following check: if this number is more than 2, then obviously we can\u0027t watch them all only using 2 TVs, otherwise we can!\u003c/p\u003e\u003cp\u003eSo the first solution we got was to make a frequency array and add 1 from each show\u0027s start till it\u0027s end, and then checking for the maximum frequency. This solution was correct but since the times were at most 1e9, we can\u0027t loop through that for each show, and we can\u0027t even make a frequency array that big (the size of it would be around 1GB of memory!).\u003c/p\u003e\u003cp\u003eSo instead, we decided to make a smarter move, and only check the times of the \u003cstrong\u003eEvents\u003c/strong\u003e that happen (either: A program started, or A program ended). So in this way we could calculate the maximum frequency correctly, while only iterating through the events which are about 4*10^5 and that would give us AC.\u003c/p\u003e\u003cp\u003eThe method we used for moving on events is called Two Pointers, in which we added all starts of shows into a vector, and ending into another. After sorting them, we could now move only using the minimum of the two vectors (since that happened before in time). You can see the code for more clarification.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\nconst int N \u003d 100000 + 10;\nconst int M \u003d 1000000007;\nconst double PI \u003d atan(1) * 4;\nconst int oo \u003d 1000000000;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef vector\u0026lt;vi\u0026gt; vvi;\ntypedef pair\u0026lt;int, int\u0026gt; ii;\n#define pb push_back \n#define all(c) (c).begin(),(c).end()\nint n;\nvector\u0026lt;int\u0026gt; start, ed;\nint main(){\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\t#endif\n\tcin\u0026gt;\u0026gt;n;\n\tfor(int a,b,i\u003d0; i\u0026lt;n; ++i){\n\t\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;a,\u0026amp;b);\n\t\tstart.push_back(a);\n\t\ted.push_back(b);\n\t}\n\tsort(start.begin(), start.end());\n\tsort(ed.begin(), ed.end());\n\tint i\u003d0, j\u003d0, fr\u003d0;\n\twhile(i\u0026lt;n || j\u0026lt;n){\n\t\tif(i\u003d\u003dn){\n\t\t\t--fr;\n\t\t\t++j;\n\t\t}else if(j\u003d\u003dn){\n\t\t\t++fr;\n\t\t\t++i;\n\t\t}else if(start[i]\u0026lt;\u003ded[j]){\n\t\t\t++fr;\n\t\t\t++i;\n\t\t}else{\n\t\t\t--fr;\n\t\t\t++j;\n\t\t}\n\t\tif(fr\u0026gt;2){\n\t\t\tcout\u0026lt;\u0026lt;\u0026quot;NO\\n\u0026quot;;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout\u0026lt;\u0026lt;\u0026quot;YES\\n\u0026quot;;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003chr /\u003e\u003cp\u003eAnd that was it all! As you know there will be no Codability next week since there\u0027s Eid, so work hard and have fun! Happy Eid :D\u003c/p\u003e\u003c/div\u003e","tags":[]}}