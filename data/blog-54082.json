{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1503783191,"rating":19,"authorHandle":"madn","modificationTimeSeconds":1503784945,"id":54082,"title":"\u003cp\u003eOnline algorithm for counting inversions in range\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI\u0027ve been recently thinking about this problem:\u003c/p\u003e\u003cp\u003eGiven array of n integers and q queries( l, r pairs ). For each query you need to count number of inversions( i, j pairs such that i \u0026lt; j and a[i] \u0026gt; a[j] ) in subarray from l to r. And you have to answer the queries online(you\u0027re not given all queries beforehand). \u003c/p\u003e\u003cp\u003eI was able to come up with a solution that i\u0027d describe below, but I\u0027d like to know if it\u0027s possible to solve the problem with better complexity.\u003c/p\u003e\u003cp\u003eSo, my solution:\u003c/p\u003e\u003cp\u003e1) preprocessing\u003c/p\u003e\u003cp\u003eLet\u0027s divide our array into sqrt(n) blocks, each sized sqrt(n), and merge-sort elements inside each, counting number of inversions in it. Then, for each pair of blocks, count number of inversions such that first element lies within first block and second lies within second block. We can do this using binary search, because each block is sorted already. After that, for each sqrt-block-range( [l, r] range such that l is a left border of one block and r is a right border of other block ) we\u0027d find number of inversions in it by summing precalculated values( inversions in each block and inversions in pairs of blocks). There are around n pairs and ranges so we can do all preprocessing in O(n * sqrt(n) * log(n)). We also need to build merge-sort tree on the array for queries.\u003c/p\u003e\u003cp\u003e2) queries\u003c/p\u003e\u003cp\u003eWe already know answer for sqrt-block-range that lies within query range. Then we just need to count inversions that include elements outside sqrt-block-range. There no more than 2 * sqrt of such elements, so we can do this with binary search in merge-sort tree in O(sqrt(n) * log^2(n)), or in O(sqrt(n) * log(n)) with partial cascading.\u003c/p\u003e\u003cp\u003eOverall complexity: O((n + q) * sqrt(n) * log(n)) with partial cascading.\u003c/p\u003e\u003cp\u003eSo what are your thoughts, can it be solved faster?\u003c/p\u003e\u003cp\u003eP.S. Sorry for my poor English.\u003c/p\u003e\u003c/div\u003e","tags":["inversions","queries","sqrt-decomposition","data structures"]}}