{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1513176967,"rating":3,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1513176967,"id":56327,"title":"\u003cp\u003eNotes on Codeforces Beta Round #100, A, B, C(range compression), D\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/140/problem/A\" title\u003d\"Codeforces Round 100\"\u003e140A - New Year Table\u003c/a\u003e\u003c/p\u003e\u003cp\u003eOne should take care of the precision problem. We need an angle \u003cspan class\u003d\"tex-span\"\u003eθ\u003c/span\u003e to “include” a circle with radius \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e, where \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ad/92/ad927b357c85d0401ca1d11ab6a2cfa910550b20.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Thus, we can have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/84/f9/84f9f3282447d705c25f56534421811a7fa35864.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e small circles, which is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/de/6f/de6fe6a0d858d72b75a43d53f045155214f66cab.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. To avoid wrong answer caused by precision, we can implement \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e ≤ \u003ci\u003ey\u003c/i\u003e + ε\u003c/span\u003e instrad of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e ≤ \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/140/problem/B\" title\u003d\"Codeforces Round 100\"\u003e140B - New Year Cards\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIn fact, we only need fill a table, where the entry in row \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and column \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e denotes the card that is given to the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e-th person after the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th card is obtained. A simple observation is that when the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th card is obtained, we should first find out the one with the maximum preference, and denote its index as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e. It is obvious that this card should be given to every person except for the one with index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e. For him, we should give the card with the second maxumum preference. Thus, it is sufficient to find out the cards with the first and second maximum preference, and fill the table with them.\u003c/p\u003e\u003cp\u003eMoreover, we should also keep updating the best card that each person can obtain. To calculate this result, we should first convert the preference sequence of each person into a “rank” sequence, which tells the rank of each card in the preference sequence.\u003c/p\u003e\u003cp\u003eOnce completing the above implementation, we can find out the answer for each person column by column. For each column, we can start from bottom to top, and once we find that the entry in the current row is equal to the best card, we can store the row index as the answer and immediately skip to the next column.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/140/problem/C\" title\u003d\"Codeforces Round 100\"\u003e140C - New Year Snowmen\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe optimal strategy is that we keep updating the number of different sizes, and always select the three balls that have the maximum numbers. Well, I did not figure out the proof...\u003c/p\u003e\u003cp\u003eThe above idea can be simply implemented by using a priority queue. However, the data should be compressed in previous since the given range is too large.\u003c/p\u003e\u003cp\u003eI have learned a very neat and general method. For an array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e]\u003c/span\u003e, we first copy all the elements to another array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e]\u003c/span\u003e as a backup. Then, we sort \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e]\u003c/span\u003e in an increasing order, and set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e \u003d \u003ci\u003eunique\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003ea\u003c/i\u003e + \u003ci\u003en\u003c/i\u003e) - \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, after which \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e will be equal to the total number of unique elememts (“unique” can be found in STL of C++). Finally, we implement \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eid\u003c/i\u003e \u003d \u003ci\u003elower\u003c/i\u003e_\u003ci\u003ebound\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003ea\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e])\u003c/span\u003e for every \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e (“lower_bound” also belongs to STL of C++). After the above steps, in fact we have already mapped \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e to a smaller number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eid\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/140/problem/D\" title\u003d\"Codeforces Round 100\"\u003e140D - New Year Contest\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThere exists a greedy solution.\u003c/p\u003e\u003cp\u003eWe sort the given sequence in an increasing order. Then, we keep updating the prefix sum and the current problem can be successfully submitted as long as the corresponding prefix sum does not exceed 720. For each problem with a prefix sum that is not larger than 360, its penalty time is zero; otherwise, it contributes a penalty time which is equal to the difference between 360 and the corresponding prefix sum.\u003c/p\u003e\u003cp\u003eThe greedy solution can be proved by a standard scheme, which can be found in many books.\u003c/p\u003e\u003c/div\u003e","tags":[]}}