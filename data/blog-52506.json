{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1497073146,"rating":-26,"authorHandle":"tsaebeht","modificationTimeSeconds":1497123317,"id":52506,"title":"\u003cp\u003eSpanner sum heuristic \u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThere seems to be some confusion reagarding this post being copied from stackexchange, but let me tell you that was my friend who posted it from his fake account without my knowledge, but now i need help genuinely, please provide input if you can.\u003c/p\u003e\u003cp\u003eI am currently working on a \u003cstrong\u003eheuristic\u003c/strong\u003e for a problem called the \u003cem\u003eSpanner Sum Problem(NP problem)\u003c/em\u003e. I\u0027ll try and incorporate all the relevant information here, in the blog post so we can have the best of ideas and inputs from your side!\u003c/p\u003e\u003cp\u003eProblem Statement: To find a spanning tree of a graph such that the shortest distances between all node pairs of chord edges related to that spanning tree are as low as possible (related problem statement is: to minimise the edges while keeping the connectivity b/w the nodes as good as possible)\u003c/p\u003e\u003cp\u003eref:(An edge of a spanning tree is called a branch; an edge in the graph that is not in the spanning tree is called a chord.)\u003c/p\u003e\u003cp\u003eLet\u0027s assume we have a Regular Un-Directed Graph \u003cstrong\u003eG\u003c/strong\u003e with \u003cstrong\u003eE\u003c/strong\u003e edges and \u003cstrong\u003eV\u003c/strong\u003e vertices. Let\u0027s take an image for reference:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"normal graph\" src\u003d\"/predownloaded/77/24/77249ed496f9fb49a93617b79ad47bd0b7aeb775.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003ein the above graph, let\u0027s \u003cem\u003ecount the cost to traverse from one vertex of a chord(according to the spanning tree obtained) to another vertex of that chord\u003c/em\u003e. Here for chord AB, \u003cstrong\u003eA\u003c/strong\u003e to \u003cstrong\u003eB\u003c/strong\u003e takes one edge \u003cstrong\u003eAB\u003c/strong\u003e, We can easily observe the rest.\u003c/p\u003e\u003cp\u003eNow say we convert this graph into some(just for demonstration) Spanning Tree. Let\u0027s say the resulting spanning tree looks something like this:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/f5/04/f504221c053aff77eaaad2a70cefd1c6bad952a4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eNow we notice that the number of edges to be traversed to reach from \u003cstrong\u003eA\u003c/strong\u003e to \u003cstrong\u003eB\u003c/strong\u003e(which is a chord), has changed from 1 earlier to 2 now. Same is the case for the pair \u003cstrong\u003eE\u003c/strong\u003e to \u003cstrong\u003eD\u003c/strong\u003e and \u003cstrong\u003eB\u003c/strong\u003e to \u003cstrong\u003eC\u003c/strong\u003e where the distance to go from one of these vertices to other has increased. This increase in distance has to be minimised while having as fewer edges as possible(basically a spanning tree), as simple as that.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eLet us define the (Minimum) Spanner Sum Problem as follows\u003c/strong\u003e\u003c/p\u003e\u003ch4\u003e\u003cem\u003eFor a spanning tree T of G, the spanner-sum is defined by ζ s (T, G) \u003d ∑dT (u, v) where (u, v) ∈ E(G) \\ E(T) and dT (u, v) denotes the distance between u and v in T. Then, the minimum spanner-sum of G is defined as ζ s (G) \u003d minζ s (T, G) where the minimum is taken over all spanning trees T of G.\u003c/em\u003e\u003c/h4\u003e\u003cp\u003e\u003cem\u003eIn more layman terms, the spanner sum problem deals with the issue of converting a graph to a tree, removing edges which yield a spanning tree which minimises distances b/w pairs of vertices, trying to keep the distance the same as in the original graph and the spanner sum is the sum of the distances related to all the chords(for some spanning tree) of the graph\u003c/em\u003e\u003c/p\u003e \u003chr /\u003e\u003cp\u003eWe came up with the following heuristic to convert a graph into a spanning tree having minimum spanner sum:\u003c/p\u003e\u003ch3\u003eAlgorithm\u003c/h3\u003e \u003cul\u003e   \u003cli\u003e\u003ch4\u003eBegin by finding the smallest cycles and remove one of the edges of that cycle, basically breaking the cycle and going one step nearer to spanning tree. The reason behind finding the smallest cycle first is to have minimum impact on the spanner sum, bcoz when we disconnect an edge from this cycle, the cost added up in the spanner sum for this particular removed edge(chord) would be the length of the cycle found — 1.\u003c/h4\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eLet me illustrate with an elementary isolated example. Take 2 cycles, one of length 3 and other of length 5: \u003cimg alt\u003d\" \" src\u003d\"/predownloaded/3c/90/3c90a61b5f51fa0c695b9e5163096c4026c48470.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eIf we remove edge \u003cstrong\u003eAB\u003c/strong\u003e, then the distance between \u003cstrong\u003eA\u003c/strong\u003e and \u003cstrong\u003eB\u003c/strong\u003e increases from \u003cstrong\u003e1\u003c/strong\u003e(**AB** itself) to \u003cstrong\u003e2\u003c/strong\u003e ( \u003cstrong\u003eAC\u003c/strong\u003e -\u0026gt; \u003cstrong\u003eCB\u003c/strong\u003e ). In the second case, when we remove edge \u003cstrong\u003eAE\u003c/strong\u003e, the distance from \u003cstrong\u003eA\u003c/strong\u003e to \u003cstrong\u003eE\u003c/strong\u003e increases from \u003cstrong\u003e1\u003c/strong\u003e (when \u003cstrong\u003eAE\u003c/strong\u003e was present) to \u003cstrong\u003e4\u003c/strong\u003e ( \u003cstrong\u003eAB\u003c/strong\u003e -\u0026gt; \u003cstrong\u003eBC\u003c/strong\u003e -\u0026gt; \u003cstrong\u003eCD\u003c/strong\u003e -\u0026gt; \u003cstrong\u003eDE\u003c/strong\u003e )\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ch4\u003eNow that we have a cycle, what edge of the cycle to remove?\u003c/h4\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eNow here is where we have made \u003cem\u003elogical\u003c/em\u003e(subjective, nonetheless) presumption. It would be great if someone would provide some mathematical backing for the below as we can\u0027t seem to think of a way to do so.\u003c/p\u003e\u003cp\u003e\u003cem\u003e\u003cstrong\u003eRemove the edge where the sum of the degrees of both its vertices is minimum compared to all the other edges in the cycle\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\u003cp\u003eNow let\u0027s think why we would do so. When you have an edge who\u0027s vertices have the least degree, that would mean that this edge is a junction that is connecting \u003cem\u003eLESSER\u003c/em\u003e number of places to a lesser number of place, right? If you have an edge who\u0027s vertices have a high degree, that would mean that there are several incoming paths to vertex one and are outgoing from vertex 2. If we were to remove this edge, it would have a greater impact of the connectivity of the graph so we wouldn\u0027t want to remove it. This is why we would choose the edge whose sum of degree of vertices is minimum.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ch4\u003eNext Step — Mark the rest of the edges of this cycle and don\u0027t remove them if encountered in future cycles, basically these have been fixed as a part of the segment tree that we are going to get finally.\u003c/h4\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eNow when you disconnect an edge from a cycle, you \u003cem\u003emark\u003c/em\u003e all the other edges in the cycle. The reason to do this is as follows. Suppose that you encounter one of these edges you encountered in the smaller cycle as a part of a bigger cycle later on and decide to remove one of these. If you were to do so, you would reduce/disturb the connectivity of the smaller cycle edges you had processed before. This would essentially result in your previous calculations being rendered useless.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ch4\u003eIncrementally calculate the spanner sum\u003c/h4\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThe spanner sum is initialised as 0. Now having removed an Edge represented by endpoints \u003cstrong\u003eV1\u003c/strong\u003e and \u003cstrong\u003eV2\u003c/strong\u003e, the new length of path b/w v1 and v2 is \u003cstrong\u003elength of cycle-1\u003c/strong\u003e. So we have \u003cstrong\u003elength of cycle-1\u003c/strong\u003e added to the spanner sum.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ch4\u003eRepeat until \u003cstrong\u003eV-1\u003c/strong\u003e Edges remain in t*emphasized text*he graph.\u003c/h4\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThis is the basic procedure that needs to be repeated until \u003cstrong\u003eV\u003c/strong\u003e — 1** edges exist in the graph. That means that we\u0027ve formed out spanning tree.\u003c/p\u003e \u003chr /\u003e\u003ch4\u003eWorking out an example\u003c/h4\u003e\u003cp\u003eHere\u0027s an image where I\u0027ve worked out an example I\u0027ll be explaining below \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/4d/f3/4df304209ebdc31fbdbf4cdf54a4b6064c1a3302.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eWe first with start with the smallest cycles, here of size 3. All the cycles considered are circled in GREEN which indicates the order they were processed in. Cycles of same size my be processed in any order. We check the sum of degrees of vertices of an edge (marked over each edge in PURPLE) and remove the one with the least sum(removed edge marked in RED) as described in the algorithm. If there are multiple edges with the same sum, break the tie arbitrarily. Then, we mark the remaining edges of the cycle in BLUE which will form a part of the spanning tree and cannot be considered for removal if they form a part of a larger cycle later on. Simply repeat this procedure until only \u003cstrong\u003eV — 1\u003c/strong\u003e edges remain in the graph and stop. \u003c/p\u003e \u003chr /\u003e\u003ch3\u003eImplementation Notes\u003c/h3\u003e\u003cp\u003eTo find the Smallest cycles, we use an \u003ca href\u003d\"https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search\"\u003eIterative Deepening DFS\u003c/a\u003e where we start with smallest depth, depth 3, to find all the smallest cycles. Once all the cycles of length 3 are over, we increase the depth to 4, 5 and so on. \u003c/p\u003e\u003cp\u003eOnce we encounter a cycle, we check the vertex degrees for each edge of the cycle, remove the one with the minimum degree sum, increment the spanner sum with length of cycle — 1 and continue.\u003c/p\u003e\u003cp\u003eWe have attempted a sort of buggy but readable implementation. It runs on certain testcases, on some it goes into an infinite loop but we have made a fair attempt and are working on correcting the code as you are reading this :)\u003c/p\u003e\u003cp\u003eHere it is \u003ca href\u003d\"http://ideone.com/KDztVn\"\u003ehttp://ideone.com/KDztVn\u003c/a\u003e\u003c/p\u003e \u003chr /\u003e\u003ch3\u003eThoughts and Help Required!\u003c/h3\u003e\u003cp\u003eThis problem is an NP problem as far as we know, and we\u0027ve come up with this particular heuristic algorithm. However, we can\u0027t provide any mathematical backing for our choice of removal edges.\u003c/p\u003e\u003cp\u003eWe have done a few tests where we removed the edges with the \u003cem\u003emaximum\u003c/em\u003e sum of vertex degrees instead of \u003cem\u003eminimum\u003c/em\u003e as we are doing here, and the spanner sum we got in the end was much higher than this algorithm proposed. So we are inclined to believe that this greedy approach of ours seems to work out, in a heuristic sense, by showing that removal of the other extreme edge, the one with max sum of vertex degrees is not yielding a good result.\u003c/p\u003e\u003cp\u003eWe\u0027re looking from some interesting inputs from your side, proposed improvements or maybe a completely new algorithm itself. We would be highly grateful if anyone of you could provide us direction with a mathematical proof that sort of proves in theory that this algorithm works. \u003c/p\u003e\u003cp\u003eThanks for the read and looking forward to constructive discussion in the comments. Kindly feel free to point out any mistakes in the post or wherever additional explanation is required!\u003c/p\u003e\u003c/div\u003e","tags":[]}}