{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1426726938,"rating":55,"authorHandle":"Zlobober","modificationTimeSeconds":1426780713,"id":17020,"title":"\u003cp\u003eCodeforces Round #296 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003e\u003ca href\u003d\"/contest/527/problem/A\" title\u003d\"Codeforces Round 296 (Div. 2)\"\u003e527A - Playing with Paper\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eIt’s easy to see that described process is equivalent to the following loop:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ewhile a \u0026gt; 0 and b \u0026gt; 0:\n    if a ⩾ b:\n         a \u003d a - b\n    else:\n         b \u003d b - a\n    ans \u003d ans + 1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut such naive approach will obviously lead to verdict TLE, since it makes ~\u003cspan class\u003d\"tex-span\"\u003e10, 2015 - 03 - 19\u003csup class\u003d\"upper-index\"\u003e12\u003c/sup\u003e\u003c/span\u003e operations even on the third sample test. The key idea is to replace repeating subtraction operations with integer division operations. This leads to the logarithmic-time solution that looks similar to the Euclid algorithm:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ewhile a \u0026gt; 0 and b \u0026gt; 0:\n    if a ⩾ b:\n        ans \u003d ans + a div b\n        a \u003d a mod b\n    else:\n        ans \u003d ans + b div a\n        b \u003d b mod a\n\u003c/code\u003e\u003c/pre\u003e\u003ch1\u003e\u003ca href\u003d\"/contest/527/problem/B\" title\u003d\"Codeforces Round 296 (Div. 2)\"\u003e527B - Error Correct System\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eThe first observation is that the new Hamming distance may not be less than the old one minus two, since we change only two characters. So the task is to actually determine, if we can attain decrease by two, one or can’t attain decrease at all.\u003c/p\u003e\u003cp\u003eThe decrease by two is possible if there are two positions with the same two letters in two strings but that appear in different order (like “double” \u0026lt;-\u0026gt; “bundle”).\u003c/p\u003e\u003cp\u003eIf there are no such positions, then we just need to check that we may decrease the distance. This can be done by just “fixing” the character that stands on the wrong position, like in “permanent” \u0026lt;-\u0026gt; “pergament” (here n stands in wrong pair with m, and there is also unmatched m, so we may fix this position).\u003c/p\u003e\u003cp\u003eOtherwise, the answer is to keep everything as it is. Implementation can be done by keeping for each pair (x, y) of symbols position where such pair appears in S and T and then by carefully checking the conditions above.\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"/contest/528/problem/A\" title\u003d\"Codeforces Round 296 (Div. 1)\"\u003e528A - Glass Carving\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eObviously the largest glass piece at any moment is the one that is product of the largest horizontal segment by the largest vertical segment. One of the possible solutions is to carefully implement what described in the statement and keep all horizontal segments and all vertical segments in priority queue or std::set, or some logarithmic data structure. This solution works in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c4/ca/c4ca5d5917911e7fc49596aeeaa04fd550fd37ce.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eBut there is also a nice linear solution if we answer all queries in reverse order. Suppose segments are not cutting, but merging. In this case we may keep the horizontal and vertical cut lines in double-linked lists and track the current maximum (that can only increase and become equal to the newly-merged segment each time). This solution works in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e + \u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"/contest/528/problem/B\" title\u003d\"Codeforces Round 296 (Div. 1)\"\u003e528B - Clique Problem\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eOne may think that this task is about graph theory, but it after some investigation and several equivalent changes in task statement it can be reduced to the well-known greedy problem. \u003c/p\u003e\u003cp\u003eInitially you have that points may lie together in a set if they are not too close, i. e. \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e| ≥ \u003ci\u003ew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. This is obviously equivalent to the following condition. Let’s consider interval of radius \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e with center in point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and call this interval to be the interval of point i. Then the statement actually says that no two such intervals should be intersecting.\u003c/p\u003e\u003cp\u003eThis task is well-known and can be solved greedily after sorting segments in ascending order of right endpoint:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eSort segments S in ascending order of S.x + S.w\n\nlast \u003d 0\nans \u003d 1\nfor i \u003d 1..n - 1:\n    if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n        last \u003d i\n        ans \u003d ans + 1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt’s easy to prove that this solution is correct. Among all ways to choose first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e segments, the best way is the one that minimizes x-coordinate of the right endpoint of the last segment (since it restricts us in the least possible way). \u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"/contest/528/problem/C\" title\u003d\"Codeforces Round 296 (Div. 1)\"\u003e528C - Data Center Drama\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eProblem legend asks you to add minimum number of edges to the given connected undirected graph (possibly, with loops and duplicating edges) and choose direction for its edges so that both the incoming and outgoing degrees of all vertices are even.\u003c/p\u003e\u003cp\u003eFirst idea is that the resulting graph before we choose the direction (but after we added some edges) will contain Euler circuit, since all degrees are even. That’s almost what we need: if we have an Euler circuit that contains even number of edges, we may direct them like following: a \u0026lt;- b -\u0026gt; c \u0026lt;- d -\u0026gt; e … It’s easy to see that each vertex appearance in this cycle adds 2 to its ingoing or outgoing degree, so the resulting degrees will be even.\u003c/p\u003e\u003cp\u003eBut if the Euler circuit is odd (meaning that there is odd number of edges in the graph), we must add some extra edge to the graph before we continue, the easiest way is to add a loop from vertex 0 to itself, since it doesn’t affect the Euler tour, but now tour length is even, so everything is ok.\u003c/p\u003e\u003cp\u003eNow we should think how to add edges optimally. It’s easy to see that the optimal way is to first fix all odd degrees of vertices (i. e. combine all odd vertices by pairs and put an edge in each pair), and then, possibly, add an extra loop as described above. The last part is to actually find an Euler circuit, and to print the answer.\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"/contest/528/problem/D\" title\u003d\"Codeforces Round 296 (Div. 1)\"\u003e528D - Fuzzy Search\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eThere were issues with this task. Intended constraints were actually \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e ≤ 500000\u003c/span\u003e, and the intended solution was using Fast Fourier Transformation, that leads to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d3/60/d360673650496e2e48c748d5a66e50aad12863e5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e running time. But unfortunately the statement contained wrong constraints, so we reduced input size during the tour. Nevertheless, we will add the harder version of this task and you will be able to submit it shortly.\u003c/p\u003e\u003cp\u003eKey idea is to reduce this task to a polynomial multiplication. Let’s solve the task in following manner. For each position i of the S for each character c from “ATGC” we will calculate match(c, i) that is equal to the number of c characters that have matching symbol in S if we put string T in position i. Then the criteria for us to have an occurrence at position i is that match(A, i) + match(T, i) + match(G, i) + match(C, i) \u003d\u003d |T| (that means exactly that each character from T being put at position i has a corresponding character in S).\u003c/p\u003e\u003cp\u003eNow let’s find out how to calculate match(c, i). Let’s keep only c characters and “not c” characters in both strings and denote them by 1 and 0 respectively. Let’s also spread each 1 in string S by the distance k to the left and to the right. For example, k \u003d 1 for the sample string AGCAATTCAT and the character A corresponding bit vector will be 111110111, and for the character C it will be 0111001110. This bitvector can be calculated in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e by putting two events “+1” and “-1” in string S in positions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e for each \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e in original string S and then sweeping from left to right over the string S and processing those events.\u003c/p\u003e\u003cp\u003eNow our task is reduced to searching all positions where the bitvector T is the submask of the bitvector S. In constraints \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e ≤ 200000\u003c/span\u003e this can be done by using bitsets in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003em\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e - \u003ci\u003em\u003c/i\u003e) / 32)\u003c/span\u003e. Nevertheless, this task can be seen as calculation of polynomials S and reversed(T) product. We will keep this as an exercise for those who decide to submit the harder version of this task.\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"/contest/528/problem/E\" title\u003d\"Codeforces Round 296 (Div. 1)\"\u003e528E - Triangles 3000\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eLet’s draw a bounding box that contains all intersection points. Let’s fix a triangle and consider three angles shown on the picture. Calculate area of intersection of those area with the bounding box and call this area to be the “area of an angle”. Then it’s easy to see, that those three angles are complement to the triangle itself in the bounding box, i. e. triangle area is bounding box area minus three angle areas.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/d1/3f/d13f4fe22d8c16446b2bbceb11eea27bd8590039.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThis leads us to the idea how to solve this task by carefully calculating for each possible formed angle on the plane, how much times does it appear in total answer if we sum all values like \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eS\u003c/i\u003e - \u003ci\u003eangle\u003c/i\u003e_\u003ci\u003earea\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e) - \u003ci\u003eangle\u003c/i\u003e_\u003ci\u003earea\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e) - \u003ci\u003eangle\u003c/i\u003e_\u003ci\u003earea\u003c/i\u003e(\u003ci\u003ec\u003c/i\u003e, \u003ci\u003ea\u003c/i\u003e))\u003c/span\u003e over all triples \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e)\u003c/span\u003e of lines.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/53/09/530974a1084fbc7a4a0553da6171922f6d459aff.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eActually, the angle is considered as many times, as many lines there are that intersect both sides of its right adjacent angle. So, our task is reduced to calculate for each angle on plane how much lines intersect its sides (i. e. its rays).\u003c/p\u003e\u003cp\u003eThis can be done in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/72/30/7230f4eaf59a69a03c16cd0bc0dada6b3daaf9c0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e by fixing the first side of the angle and then adding lines in ascending order of polar angle, and then by keeping the number of lines that intersect the base line to the left and that intersect the base line to the right. Key idea is that the exact of four angles formed by the pair of lines \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e that is crossed by some third line c, can be determined by two numbers: its polar angle alpha and its crossing with a coordinate x. Further details are shown on the picture below.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/c9/2c/c92c71af8816b28fcbd18f1a3889ae33140e270d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThere is also a nice short \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e solution from \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/enot.1.10\" title\u003d\"Grandmaster enot.1.10\"\u003eenot.1.10\u003c/a\u003e \u003ca href\u003d\"http://codeforces.ru/contest/528/submission/10319347\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e","tags":[]}}