{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1424202835,"rating":132,"authorHandle":"dreamoon","modificationTimeSeconds":1426011330,"id":16468,"title":"\u003cp\u003eCodeforces Round #292 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThanks to \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/johnathan79717\" title\u003d\"Master johnathan79717\"\u003ejohnathan79717\u003c/a\u003e fo polish my words.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/515/A\"\u003e515-A Drazil and Date\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eIf Drazil chooses the shortest path from (0,0) to (a,b), it takes \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003ea\u003c/i\u003e| + |\u003ci\u003eb\u003c/i\u003e|\u003c/span\u003e steps.\u003c/p\u003e\u003cp\u003eSo we know that all numbers less than \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003ea\u003c/i\u003e| + |\u003ci\u003eb\u003c/i\u003e|\u003c/span\u003e are impossible to be the number of steps that Drazil took.\u003c/p\u003e\u003cp\u003eNow consider when the number of steps is not less than \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003ea\u003c/i\u003e| + |\u003ci\u003eb\u003c/i\u003e|\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWhen Drazil arrives at \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e, he can take two more steps such as \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e -\u0026gt; \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e + 1)\u003c/span\u003e -\u0026gt; \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e to remain at the same position.\u003c/p\u003e\u003cp\u003eSo we know that for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e ≥ |\u003ci\u003ea\u003c/i\u003e| + |\u003ci\u003eb\u003c/i\u003e|\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003es\u003c/i\u003e - (|\u003ci\u003ea\u003c/i\u003e| + |\u003ci\u003eb\u003c/i\u003e|))%2 \u003d 0\u003c/span\u003e, there exists a way for Drazil to get to \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e in exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e steps.\u003c/p\u003e\u003cp\u003eThe last part we should prove is that it\u0027s impossible for Drazil to arrive at (a,b) in exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e steps when \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003es\u003c/i\u003e - (|\u003ci\u003ea\u003c/i\u003e| + |\u003ci\u003eb\u003c/i\u003e|))%2 \u003d 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe can color all positions \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e)%2 \u003d 0\u003c/span\u003e as white and color other points as black.\u003c/p\u003e\u003cp\u003eAfter each step, the color of the position you\u0027re at always changes.\u003c/p\u003e\u003cp\u003eSo we know that it\u0027s impossible for Drazil to get to \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e in odd/even steps if the color of \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e is white/black.\u003c/p\u003e\u003cp\u003eConclusion: If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e ≥ |\u003ci\u003ea\u003c/i\u003e| + |\u003ci\u003eb\u003c/i\u003e|\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003es\u003c/i\u003e - (|\u003ci\u003ea\u003c/i\u003e| + |\u003ci\u003eb\u003c/i\u003e|))%2 \u003d 0\u003c/span\u003e print \u0026quot;Yes\u0026quot;, Otherwise print \u0026quot;No\u0026quot;.\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/515/submission/9906268\"\u003eauthor\u0027s code\u003c/a\u003e\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/515/B\"\u003e515-B Drazil and His Happy Friends\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eYou may notice that Drazil invites his friends periodically, and the period of invitation patterns is at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e * \u003ci\u003em\u003c/i\u003e\u003c/span\u003e (because there are only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e * \u003ci\u003em\u003c/i\u003e\u003c/span\u003e possible pairs of boys and girls).\u003c/p\u003e\u003cp\u003eSo if no one changes from unhappy to happy in consecutive \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e * \u003ci\u003em\u003c/i\u003e\u003c/span\u003e days, there won\u0027t be any changes anymore since then.\u003c/p\u003e\u003cp\u003eWe can simulate the process of having dinner until there are no status changes in consecutive \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e * \u003ci\u003em\u003c/i\u003e\u003c/span\u003e days.\u003c/p\u003e\u003cp\u003eBecause there are only n+m people, it\u0027s easy to prove the simulation requires O(\u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e) * \u003ci\u003en\u003c/i\u003e * \u003ci\u003em\u003c/i\u003e\u003c/span\u003e) days.\u003c/p\u003e\u003cp\u003eBut in fact, the simulation takes only O(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e * \u003ci\u003em\u003c/i\u003e\u003c/span\u003e) days.(More accurately, the bound is \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003emin\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e) + 1) * (\u003ci\u003emax\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e) - 1)\u003c/span\u003e )\u003c/p\u003e\u003cp\u003eWhat happens? You can do some experiments by yourself. \u003d) (you can suppose that only one person is happy in the beginning.)\u003c/p\u003e\u003cp\u003eIn fact, this problem can be solved in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003c/span\u003e be the greatest common divisor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e. If the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th person is happy, then all people with number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e satisfying \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5d/29/5d29f0891599c6727311e8dbfe2b7c853c20b03d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e will become happy some day because of this person.\u003c/p\u003e\u003cp\u003eSo for each \u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003eg\u003c/i\u003e - 1\u003c/span\u003e, we only need to check if there exists at least one person whose number mod \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and is happy.\u003c/p\u003e\u003cp\u003eIf it exists for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, the answer is \u0027Yes\u0027, otherwise the answer is \u0027No\u0027.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/515/submission/9906294\"\u003eauthor\u0027s code\u003c/a\u003e\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/515/C\"\u003e515-C Drazil and Factorial\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eConclusion first:\u003c/p\u003e\u003cp\u003eFirst, we transform each digit of the original number as follows:\u003c/p\u003e\u003cp\u003e0, 1 -\u0026gt; empty\u003c/p\u003e\u003cp\u003e2 -\u0026gt; 2\u003c/p\u003e\u003cp\u003e3 -\u0026gt; 3\u003c/p\u003e\u003cp\u003e4 -\u0026gt; 322\u003c/p\u003e\u003cp\u003e5 -\u0026gt; 5\u003c/p\u003e\u003cp\u003e6 -\u0026gt; 53\u003c/p\u003e\u003cp\u003e7 -\u0026gt; 7\u003c/p\u003e\u003cp\u003e8 -\u0026gt; 7222\u003c/p\u003e\u003cp\u003e9 -\u0026gt; 7332\u003c/p\u003e\u003cp\u003eThen, sort all digits in decreasing order as a new number, then it will be the answer.\u003c/p\u003e\u003cp\u003eProof:\u003c/p\u003e\u003cp\u003eWe can observe that our answer won\u0027t contain digits 4,6,8,9, because we can always transform digits 4,6,8,9 to more digits as in the conclusion, and it makes the number larger.\u003c/p\u003e\u003cp\u003eThen, how can we make sure that the result is the largest after this transformation?\u003c/p\u003e\u003cp\u003eWe can prove the following lemma:\u003c/p\u003e\u003cp\u003eFor any positive integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, if it can be written as the form \u003cspan class\u003d\"tex-span\"\u003e(2!)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sup\u003e * (3!)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e\u003c/sup\u003e * (5!)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e5\u003c/sub\u003e\u003c/sup\u003e * (7!)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e7\u003c/sub\u003e\u003c/sup\u003e\u003c/span\u003e, there will be only one unique way.\u003c/p\u003e\u003cp\u003eSuppose that there exists two ways to write down x in this form, we can assume that the two ways are \u003cspan class\u003d\"tex-span\"\u003e(2!)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sup\u003e * (3!)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e\u003c/sup\u003e * (5!)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e5\u003c/sub\u003e\u003c/sup\u003e * (7!)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e7\u003c/sub\u003e\u003c/sup\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(2!)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sup\u003e * (3!)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e\u003c/sup\u003e * (5!)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e5\u003c/sub\u003e\u003c/sup\u003e * (7!)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e7\u003c/sub\u003e\u003c/sup\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe find the largest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≠ \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, Then we know there exists at least one prime number whose factor is different in the two ways.\u003c/p\u003e\u003cp\u003eBut according to the Fundamental Theorem of Arithmetic, there is only one prime factorization of each integer. So we get a contradiction.\u003c/p\u003e\u003cp\u003eAfter getting the result, we don\u0027t need to worry about other numbers being larger than ours.\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/515/submission/9906310\"\u003eauthor\u0027s code\u003c/a\u003e\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/515/D\"\u003e515-D Drazil and Tiles\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eAgain we give conclusion first: \u003c/p\u003e\u003cp\u003eFirst, view each cell as a vertex and connect two adjacent cells by an edge.\u003c/p\u003e\u003cp\u003eThen, build a queue and push all vertices of degree 1 in it.\u003c/p\u003e\u003cp\u003eFinally, in each iteration, we pop a vertex from the queue until the queue is empty. If the vertex is used, go to the next iteration. Otherwise, we put a tile on the vertex and its adjacent vertex, and erase these two vertices from the graph. If it yields a new vertex with degree 1, push it into the queue.\u003c/p\u003e\u003cp\u003eWhen the queue is empty, if there are still some cells not covered by any tiles, the answer will be \u0026quot;Not unique.\u0026quot;\u003c/p\u003e\u003cp\u003eIt\u0027s easy to understand that if we can put tiles on all cells by the above steps, the result is correct. But how about the remaining cases?\u003c/p\u003e\u003cp\u003eWe will prove that when the degrees of all vertices are at least two, the solution is never unique.\u003c/p\u003e\u003cp\u003eSuppose there is at least one solution.\u003c/p\u003e\u003cp\u003eAccording to this solution, we can color those edges covered by tiles as black and color other edges as white.\u003c/p\u003e\u003cp\u003eWe can always find a cycle without any adjacent edges having the same colors. (I\u0027ll leave it as an exercise. You should notice that the graph is a bipartite graph first.)\u003c/p\u003e\u003cp\u003eThen we can move the tiles from black edges to white edges.\u003c/p\u003e\u003cp\u003eSo if there is at least one solution, there are in fact at least two solutions.\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/515/submission/9906349\"\u003eauthor\u0027s code\u003c/a\u003e\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/515/E\"\u003e515-E Drazil and Park\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eThere are many methods for this problem. I\u0027ll only explain the one that I used.\u003c/p\u003e\u003cp\u003eLet\u0027s split a circle at some point (for example between 1 and n) and draw a picture twice (i. e. 1 2 3 ... n 1 2 3 ... n), thus changing the problem from a circle to a line.\u003c/p\u003e\u003cp\u003eRemember that if two trees Drazil chooses are x and y, the energy he consumes is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e + 1\u003c/sub\u003e + ... + \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e - 1\u003c/sub\u003e + 2 * (\u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow rewrite this formula to \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e - 1\u003c/sub\u003e + 2 * \u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e) + (2 * \u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e - (\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e - 1\u003c/sub\u003e))\u003c/span\u003e\u003c/p\u003e\u003cp\u003eDenote \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/sub\u003e + 2 * \u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and denote \u003cspan class\u003d\"tex-span\"\u003e(2 * \u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e - (\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/sub\u003e))\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eWhen a query about range \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e]\u003c/span\u003e comes (The range \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e]\u003c/span\u003e is where Drazil can choose, but not the range where the children are playing), it\u0027s equivalent to querying the maximum value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e are in \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e \u0026lt; \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eAnother important thing is that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e always bigger than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e \u0026lt; \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSo we can almost solve the problem just by finding the maximum value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e by RMQ separately and sum them up.\u003c/p\u003e\u003cp\u003eHowever, there is a special case: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e \u003d \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, but we can handle it by making RMQ find the two maximum values.\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/515/submission/9906364\"\u003eauthor\u0027s code\u003c/a\u003e (implement with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c8/05/c805314abb420ae4f45d637127f40de84093a2b8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e)\u003c/p\u003e\u003cp\u003eMore information about RMQ: \u003ca href\u003d\"http://community.topcoder.com/tc?module\u003dStatic\u0026amp;d1\u003dtutorials\u0026amp;d2\u003dlowestCommonAncestor#Sparse_Table_%28ST%29_algorithm\"\u003eeditorial\u003c/a\u003e from Topcoder\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/516/D\"\u003e516-D Drazil and Morning Exercise\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eWe can use dfs twice to get the farthest distance from each node to any leaves (detail omitted here), and denote the longest distance from the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th node to any leaves as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThen we choose a node with minimum value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e as the root. We will find that for any node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e isn\u0027t greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e for any node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e in the subtree of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNext, we solve the problem when there\u0027s only one query of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. In all valid groups of nodes, where node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is the nearest to the root, obviously we can choose all nodes with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e into the group. Now we want to enumerate all nodes as the nearest node to the root. We denote the group of nodes generated from node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe can do it in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e using dfs only once. (if the length of every edge is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, we can do it in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e)\u003c/p\u003e\u003cp\u003eImagine that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e will almost be as same as the union of all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e where node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e is a child of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, but some nodes which are too far from node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e are kicked out. Each node will be kicked out from the groups we considered at most once in the whole process. Now we want to know when it happens. We solve it as follows: When we do dfs, we reserve a stack to record which nodes we have visited and still need to come back to. Yes, it\u0027s just like the implementation of recursive functions. Then we can just use binary search to find the node in the stack that when we go back to it, the current node will be kicked out (the closest node with \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e| ≥ \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eSo the time complexity of the above algorithm is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/df/e9/dfe94ff4088bfaa426690aeed18959e9018d2d43.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eNow we provide another algorithm with O(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eqn\u003c/i\u003eα(\u003ci\u003en\u003c/i\u003e) + \u003ci\u003enlog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e) by union find. (Thanks \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Shik\" title\u003d\"Grandmaster Shik\"\u003eShik\u003c/a\u003e for providing this method.)\u003c/p\u003e\u003cp\u003eFirst, sort all nodes by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThen for each query, consider each node one by one from larger \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e\u0027s to smaller \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e\u0027s.\u003c/p\u003e\u003cp\u003eAt the beginning, set each node as a group of its own. We also need to record how many nodes each group contains.\u003c/p\u003e\u003cp\u003eWhen handling a node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, union all groups of itself and its children. At the same time, for each node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u0026gt; \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e, we minus \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e from the record of how many nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e\u0027s group has.\u003c/p\u003e\u003cp\u003eBy doing these, we can get the number of nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e\u0027s subtree with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u0026lt;  \u003d \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. That\u0027s exactly what we want to know in the last algorithm.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/516/submission/9906402\"\u003eauthor\u0027s code\u003c/a\u003e (implement with O(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eqn\u003c/i\u003eα(\u003ci\u003en\u003c/i\u003e) + \u003ci\u003enlog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e))\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/516/E\"\u003e516-E Drazil and His Happy Friends\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eSimplifying this question, suppose that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e are coprime. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e are not coprime and the gcd of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003c/span\u003e, then we can divide all people into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003c/span\u003e groups by the values of their id mod \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003c/span\u003e and find the maximum answer between them. Obviously, If there is at least one group of friends which are all unhappy in the beginning, the answer is -1.\u003c/p\u003e\u003cp\u003eNow we determine the last one becoming happy, for boys and girls separately.\u003c/p\u003e\u003cp\u003eIn fact, there\u0027s an easy way to explain this problem — finding the shortest path! View all friends as points, and add another point as the source. For all friends, we will view the distance from the source as the time becoming happy. And define two types of edges.\u003c/p\u003e\u003cp\u003e(1)\u003c/p\u003e\u003cp\u003eThere is a fact: If a girl \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e become happy in time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e, then the girl \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e + \u003ci\u003en\u003c/i\u003e)%\u003ci\u003em\u003c/i\u003e\u003c/span\u003e will become happy in time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e + \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. So we can build a directed edge from point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e + \u003ci\u003en\u003c/i\u003e)%\u003ci\u003em\u003c/i\u003e\u003c/span\u003e with length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Similar for boys.\u003c/p\u003e\u003cp\u003e(2)\u003c/p\u003e\u003cp\u003eIf the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th boy/girlfriend is happy originally, we can connect it to the source with an edge of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. At the same time, we also connect the source to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e%\u003ci\u003en\u003c/i\u003e\u003c/span\u003e-th boy(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e%\u003ci\u003em\u003c/i\u003e\u003c/span\u003e for girl) with an edge of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. You can imagine that the same gender of friends form a cycle. (eg. the \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e * \u003ci\u003em\u003c/i\u003e)%\u003ci\u003en\u003c/i\u003e\u003c/span\u003e-th boy is connected to the \u003cspan class\u003d\"tex-span\"\u003e((\u003ci\u003ei\u003c/i\u003e + 1) * \u003ci\u003em\u003c/i\u003e)%\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e-th boy for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e from 0 to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e)\u003c/p\u003e\u003cp\u003eWith these two types of edges, we can find that if a friend is unhappy originally, he/she will become happy at the time value which is the length of the shortest path from the source.\u003c/p\u003e\u003cp\u003eThe only question is that there are too many points and edges!\u003c/p\u003e\u003cp\u003eWe can solve this problem by considering only some \u0026quot;important\u0026quot; points.\u003c/p\u003e \u003col\u003e   \u003cli\u003ePoints connected by the second type of edges.\u003c/li\u003e   \u003cli\u003ePoints connected to important points in 1., by the first type of edges.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eAnd we can combine some consecutive edges of the first type to a new edge. The group of edges is the maximal edges that contain deleted points.(These deleted points always form a line).\u003c/p\u003e\u003cp\u003eFinally we find the maximum value of the shortest path from the source to these friends which is unhappy originally in the reduced graph.\u003c/p\u003e\u003cp\u003eTime complexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e6/87/e687b659a8d6afa069db08a4cb3e487d84a77844.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/516/submission/9972091\"\u003eauthor\u0027s code\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}