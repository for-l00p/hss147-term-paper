{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1409917917,"rating":172,"authorHandle":"Endagorion","modificationTimeSeconds":1410184419,"id":13694,"title":"\u003cp\u003eCodeforces Round #265 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI\u0027ll upload my example solutions and will post links to them as soon as it becomes possible.\u003c/p\u003e\u003cp\u003eSome of the problems editorials contain an additional challenge which is apparently harder to comprehend than the original problem. Feel free to share and discuss your ideas in the comments. \u003d)\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/465/problem/A\" title\u003d\"Codeforces Round 265 (Div. 2)\"\u003e465A - inc ARG\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIf we add 1 to a number, its binary representation changes in a simple way: all the least significant \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e\u0027s change to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e\u0027s, and the single following \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e changes to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. It suffices to find the length of largest suffix which contains only \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e\u0027s, suppose its length is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e. Then the answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e + 1\u003c/span\u003e except for the case when all the string consists of \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, when the answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIt is amusing that div1E problem is concerned with addition of 1 to a binary integer as well. \u003d)\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/465/problem/B\" title\u003d\"Codeforces Round 265 (Div. 2)\"\u003e465B - Inbox (100500)\u003c/a\u003e\u003c/p\u003e\u003cp\u003eOptimal strategy is as follows: for every segment of consecutive \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e\u0027s open the first letter in segment, scroll until the last letter in segment, if there are more unread letters left, return to list.\u003c/p\u003e\u003cp\u003eIt is easy to show that we can not do any better: observe the moment we read the last letter from some segment of consecutive \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e\u0027s. There are no adjacent unread letters now, so we either have to scroll to some read letter or return to list of letters, either way we make an operation which does not result in reading an unread letter, so every segment (except for the last) must yield at least one such operation.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/464/problem/A\" title\u003d\"Codeforces Round 265 (Div. 1)\"\u003e464A - No to Palindromes!\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIf string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e contains a non-trivial palindromic substring \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e, then it must contain palindromic substring of length 2 or 3 (for instance, center of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e). Therefore the string is tolerable iff no adjacent symbols or symbols at distance 1 are equal.\u003c/p\u003e\u003cp\u003eNow for the lexicographically next tolerable string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e is greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, so they have common prefix of some size (maybe zero) and the next symbol is greater in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e than in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e. This symbol should be as right as possible to obtain minimal possible \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e. For some position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e we can try to increment \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and ensure it\u0027s not equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 2\u003c/sub\u003e\u003c/span\u003e. If we find some way to do this, the suffix can always be filled correctly if only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e ≥ 3\u003c/span\u003e, as at most two symbols are forbidden at every moment. Every symbol from suffix should be as small as possible not to make conflicts. So, a greedy procedure or some kind of clever brute-force can be implemented to solve the problem in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. Cases \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e \u003d 1\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e are easy, as only strings of length at most 1, and at most 2 respectively fit.\u003c/p\u003e\u003cp\u003eThis is an application on general approach to generate next lexicographical something: try to increment rightmost position so that suffix can be filled up in some way, then fill the suffix in least possible way.\u003c/p\u003e\u003cp\u003eAs pointed out in Russian discussion, this problem is a simplified version of the problem from some previous round: \u003ca href\u003d\"/contest/196/problem/D\" title\u003d\"Codeforces Round 124 (Div. 1)\"\u003e196D - The Next Good String\u003c/a\u003e. We were not aware of this and apologize for the misfortune. Luckily, no copied solutions from that problem were spotted. If you enjoyed this simple version, you may want to try the harder one know. \u003d)\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/464/problem/B\" title\u003d\"Codeforces Round 265 (Div. 1)\"\u003e464B - Restore Cube \u003c/a\u003e\u003c/p\u003e\u003cp\u003eThere are several ways to solve this problem. We\u0027ll describe the most straightforward one: we can generate all possible permutations of coordinates of every point and for every combination check whether given point configuration form a cube. However, number of configurations can go up to \u003cspan class\u003d\"tex-span\"\u003e(3!)\u003csup class\u003d\"upper-index\"\u003e8\u003c/sup\u003e \u0026gt; 10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e, so checking should work quite fast.\u003c/p\u003e\u003cp\u003eOne way to check if the points form a cube is such: find minimal distance between all pairs of points, it should be equal to the side length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e. Every vertex should have exactly three other points at distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e, and all three edges should be pairwise perpendicular. If these condition are met at every point, then configuration is a cube as there is no way to construct another configuration with these properties. This procedure performs roughly \u003cspan class\u003d\"tex-span\"\u003e8\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e operations for every check, which is fast enough. There are even more efficient ways of cube checking exploiting various properties of cube.\u003c/p\u003e\u003cp\u003eThere are various optimizations to ensure you fit into time limit. For instance, applying the same permutation to coordinates of all points keeps every property of the cube, therefore we can fix order of coordinates for one point and permute all other. This single trick speeds up the algorithm 6 times, which allows some less efficient programs to be accepted.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eA challenge\u003c/strong\u003e: apparently, checking may be done as follows: find the length side \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e, then count number of pairs on distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/89/f9/89f970c0fdbf2b04910b752f814660fd0bfb39fb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/da/70/da70dda3362ba03e72a69286836b8ca2b0437483.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. A cube must contain exactly \u003cspan class\u003d\"tex-span\"\u003e12\u003c/span\u003e pairs of first kind, \u003cspan class\u003d\"tex-span\"\u003e12\u003c/span\u003e pairs of second kind and \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e pairs of third kind. Can you prove that this condition is sufficient for configuration to form a cube? Is it true if we allow points to have non-integer coordinates? Can you propose an even easier algorithm for checking?\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/464/problem/C\" title\u003d\"Codeforces Round 265 (Div. 1)\"\u003e464C - Substitutes in Number\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIt is quite diffcult to store the whole string after each query as its length grows exponentially and queries may change it dramatically. The good advice is: if you can\u0027t come up with a solution for a problem, try solving it from the other end. \u003d)\u003c/p\u003e\u003cp\u003eSuppose we know for some sequence of queries that digit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e will turn into string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e for every digit. Then string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e \u003d \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e... \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e will turn into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sub\u003e + ... + \u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e\u003c/span\u003e (+ for concatenation). Denote \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e)\u003c/span\u003e numeric value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e. Then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e)\u003c/span\u003e can be expressed as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e(\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e) + 10\u003csup class\u003d\"upper-index\"\u003e|\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e|\u003c/sup\u003e(\u003ci\u003ev\u003c/i\u003e(\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e\u003c/sub\u003e) + 10\u003csup class\u003d\"upper-index\"\u003e|\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e|\u003c/sup\u003e(...))\u003c/span\u003e. So \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e)\u003c/span\u003e can be computed if we know \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ev\u003c/i\u003e(\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sub\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e|\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sub\u003e|\u003c/sup\u003e\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e. As we need answer modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e + 7\u003c/span\u003e we can store these numbers modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow prepend some new query \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e → \u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to given sequence. How will \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e change? Clearly, for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e ≠ \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e these numbers won\u0027t change, and for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e they can be computed according to the rule above. This recounting is done in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e|)\u003c/span\u003e time. After adding all queries, find answer for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e using the same procedure in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003es\u003c/i\u003e|)\u003c/span\u003e time. Finally, our time complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b8/0e/b80e3d26ffe60e83edb2f35d08a61317e649ccac.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. The code for this problem pretty much consists of the above formula, so implementation is as easy as it gets once you grasp the idea. \u003d)\u003c/p\u003e\u003cp\u003eOptimized simple solutions which just replaced substrings could manage to pass pretests. Sorry for that.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eA challenge\u003c/strong\u003e: this problem has a natural modification when you have to give an answer after each query. Using algorithm described above it can be solved offline in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e time. Can we do better than this? What if we are limited to answer online?\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/464/problem/D\" title\u003d\"Codeforces Round 265 (Div. 1)\"\u003e464D - World of Darkraft - 2\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis problem required some skill at probabilities handling, but other than that it\u0027s quite simple too.\u003c/p\u003e\u003cp\u003eDenote number of earned coins as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e, and number of earned coins from selling items of type \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Clearly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e \u003d \u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + ... + \u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eEX\u003c/i\u003e \u003d \u003ci\u003eEX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + ... + \u003ci\u003eEX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (here \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eEX\u003c/i\u003e\u003c/span\u003e is expectation of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e). As all types have equal probability of appearance, all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e are equal, so \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eEX\u003c/i\u003e \u003d \u003ci\u003ekEX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e. Now to find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eEX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIf we look only at the items of one type, say, 1, items generation looks like this: with probability \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/80/c4/80c4d33e37dd904e0a678e3cf34a07ba339dbe03.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e we get nothing, and with probability \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a5/31/a5319ec7c549e39ea9c941167f1023b5b6172656.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e we get out item with level distributed as usual. Denote \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e expectation of earned money after killing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e monsters if we have an item of level \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e at the start. Clearly, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0, \u003ci\u003et\u003c/i\u003e\u003c/sub\u003e \u003d 0\u003c/span\u003e (we have no opportunity to earn any money), and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/42/37/423711e456b406fa567a332fcaa0b5d0f49d8158.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, which is equal to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6b/5f/6b5fb2bf9f68cb1c5365ae581663335bf64f136d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003d \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a9/13/a913f9a81c8a9ee86fe4500c8252a9c0df7100de.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. To get the answer note that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eEX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u003d \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e, 1\u003c/sub\u003e\u003c/span\u003e. The sad note is that this DP has \u003cspan class\u003d\"tex-span\"\u003eΩ(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e states, which is too much for \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/fe/70/fe705749897d4d1062326eb89dc3f1be99569e2d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eMaybe if we cut off some extremely-low-probability cases we can do better? For instance, it is clear that probability of upgrading an item descreases with its level, so apparently it does not get very high. We know that expected number of tries before first happening of event with probability \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e in a series of similar independent events is \u003cspan class\u003d\"tex-span\"\u003e1 / \u003ci\u003ep\u003c/i\u003e\u003c/span\u003e. Therefore, expected number of monsters we have to kill to get item of level \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/63/16/6316994481afdc2c6ec0a620c1f189808df3525e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. So, in common case our level can get up to about \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/2d/5f/2d5fd8bff067252ef26b612cd355b8eafbf38008.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, which does not exceed \u003cspan class\u003d\"tex-span\"\u003e500\u003c/span\u003e in our limitations. We would want to set such bound \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e that ignoring cases with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e \u0026gt; \u003ci\u003eB\u003c/i\u003e\u003c/span\u003e would not influence our answer too much. That can be done with rigorous bounding of variance of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e and applying some bounding theorem, or with an empirical method: if we increase the bound and the answer doesn\u0027t visibly change, then this bound is fine. It turns out \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e ≥ 700\u003c/span\u003e is good enough for achieving demanded precision. Thus solution with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d1/0b/d10b20036a61c81a267aab9909e5999331abd538.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e complexity is obtained (here we assert that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1a/4c/1a4c409300e8486665a269be83b831f79e80707c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, and constant \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e is buried in the big O).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eA challenge\u003c/strong\u003e: suppose we have the same rules of killing monsters and obtaining items, but now we are free to choose whether to sell a new item or an old one. We act so that to maximize our number of coins in the end. What is the expected number of coins if we act optimally?\u003c/p\u003e\u003cp\u003eNow it is sometimes more profitable to sell a powerful item, but sometimes it isn\u0027t. How fast a solution can you come up with?\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/464/problem/E\" title\u003d\"Codeforces Round 265 (Div. 1)\"\u003e464E - The Classic Problem\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis seems to be a simple graph exercise, but the problem is with enormous weights of paths which we need to count and compare with absolute precision to get Dijkstra working. How do we do that?\u003c/p\u003e\u003cp\u003eThe fact that every edge weight is a power of two gives an idea that we can store binary representation of path value as it doesn\u0027t change much after appending one edge. However, storing representations explicitly for all vertices is too costly: the total number of 1\u0027s in them can reach \u003cspan class\u003d\"tex-span\"\u003eΩ(\u003ci\u003end\u003c/i\u003e)\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e is for maximal \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e), which doesn\u0027t fit into memory even with bit compression woodoo magic.\u003c/p\u003e\u003cp\u003eAn advanced data structure is needed here which is efficient in both time and memory. The good choice is a persistent segment tree storing bit representation. Persistent segment tree is pretty much like the usual segment tree, except that when we want to change the state of some node we instead create a new node with links to children of old node. This way we have some sort of \u0027\u0027version control\u0027\u0027 over tree: every old node is present and available for requests as its subtree can never change. Moreover, all queries are still processed in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time, but can create up to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e new nodes.\u003c/p\u003e\u003cp\u003eWhat queries do we need? Adding \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e to binary number can be implemented as finding nearest most significant \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-th bit, setting it to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and assigning \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e\u0027s to all the positions in between. Usual segment tree with lazy propagation can do it, so persistent tree is able to do it as well.\u003c/p\u003e\u003cp\u003eComparing two numbers can be done as follows: find the most singificant bit which differs in two numbers, then number with \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e in this bit is smaller; if no bits differ, then numbers are clearly equal. That can be done in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e if we store hashes of some sort in every node and perform a parallel binary search on both trees. Time and memory limits were very generous so you could store as many different hashes as you wanted to avoid collisions.\u003c/p\u003e\u003cp\u003eThat concludes the general idea. Now we use this implementation of numbers as a black-box for Dijkstra algorithm. Every operation on numbers is now slowed by a factor of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/77/a6/77a60778c936f161afd97655e2dc0e6bfb5e1b50.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, so our solution has \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/2f/00/2f007e09b4f074fddb2cce6186a46f1e99e39020.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e complexity. However, great caution is needed to achieve a practical solution.\u003c/p\u003e\u003cp\u003eFirst of all, in clueless implementation comparison of two \u0026quot;numbers\u0026quot; may require \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/77/a6/77a60778c936f161afd97655e2dc0e6bfb5e1b50.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e additional memory as we must perform \u0026quot;push\u0026quot; operation as we descend. \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/2f/00/2f007e09b4f074fddb2cce6186a46f1e99e39020.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e memory is too much to fit even in our generous ML. There are plenty of ways to avoid this, for instance, if we want to push the value from node to children, we actually know that the whole segment consists of equal values and can answer the query right away.\u003c/p\u003e\u003cp\u003eI would like to describe a clever trick which optimizes both time and memory greatly and also simplifies implementation. It allows to get rid of lazy propagation completely. Here it comes: initially build two trees containing only \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e\u0027s and only \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e\u0027s respectively. Now suppose we want to assign some value (\u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, for instance) on a segment and some tree node completely lies inside of query segment. Instead of creating a new node with a propagation mark, we can replace the node with corresponding node from tree filled with \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. This way only \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e6/00/e600dc7fe3a99f0c5d1a43df0861ebb6dcfc343e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e new nodes are created on every query (which is impossible to achieve with any kind of propagation which would require at least \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c7/9b/c79bd7cc2e2dd4d43432f8d7cf5f65cba65252d3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e), and also nodes need to store less information and become lighter this way. Also, no \u0026quot;push\u0026quot; procedure is required now.\u003c/p\u003e\u003cp\u003eNo challenges for this problem as it is challenging enough itself. \u003d) Implementing this problem is a great exercise for anyone who wants to become familiar with complicated structures and their applications, so solving it in the archive is advisable.\u003c/p\u003e\u003cp\u003eThat\u0027s pretty much it. If there are still questions, you may ask them in the comments. Thanks for reading!\u003c/p\u003e\u003c/div\u003e","tags":[]}}