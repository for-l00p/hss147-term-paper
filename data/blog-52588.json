{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1497386574,"rating":0,"authorHandle":"colins","modificationTimeSeconds":1497435257,"id":52588,"title":"\u003cp\u003eРазбор 2012-2013 Тренировка СПбГУ B #3\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eТут будет разбор 2012-2013 Тренировка СПбГУ B #3. Если вы уже вдоволь подумали над этими задачами и у вас нет ни одной годной идеи, то тут будет разбор этих задач .\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/ysnvR1E45m/contest/100088/submit/A\"\u003eЗадача A\u003c/a\u003e\u003c/p\u003e\u003cp\u003eДля тех, кто немного знаком с понятием остовного дерева, суть задачи не представляет собой ничего сложного. Нужно найти веса всех ребер, отсортировать их и добавлять в граф, проверяя, чтобы при добавлении очередного ребра не образовался цикл(\u003ccode\u003eСНМ\u003c/code\u003e нам в помощь, как можно догадаться). Основные трудности начинаются, когда пытаешься влезть в установленные временные ограничения. Из советов : \u003ccode\u003elong double\u003c/code\u003e нужен только при формировании ответа, во всех остальных ситуациях сгодятся \u003ccode\u003eint\u003c/code\u003e или \u003ccode\u003esize_t\u003c/code\u003e(не забываем, что типы данных на подобии \u003ccode\u003eint64_t\u003c/code\u003e и прочих жрут непомерно много памяти и времени, если, например, сортировать \u003ccode\u003evector\u0026lt;int64_t\u0026gt; numbers\u003c/code\u003e), а также в помощь приходит использование \u003ccode\u003einline\u003c/code\u003e-функций.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/ysnvR1E45m/contest/100088/submit/B\"\u003eЗадача В\u003c/a\u003e\u003c/p\u003e\u003cp\u003eСуть задачи не сильно отличается от первой, но тут есть дополнительная тонкость. В условии дана непонятная структура(ряды шестиугольников, которые находятся не совсем друг под другом). Методом разглядывания можно заметить, что эту структуру можно изобразить так : прямоугольник \u003ccode\u003en * m\u003c/code\u003e , в котором соседние для клетки \u003ccode\u003e(i, j)\u003c/code\u003e можно искать так: \u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor x in i..i + 1 :\n  for y in j..j + 1 : \n    if x !\u003d i or y !\u003d j\n      add (i, j) - (x, y);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТогда становится гораздо яснее, как для такой структуры описывать возможные \u0026quot;реки\u0026quot;. Клетки же можно занумеровать следующим образом : \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e# :\u003d row + rows * column;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОстальные советы по поводу решения этой задачи остаются такими же : ничего, кроме \u003ccode\u003esize_t\u003c/code\u003e и \u003ccode\u003eint\u003c/code\u003e использовать не имеет смысла, если вам дорого время, которое сервер тратит на исполнение вашей программы. Ну и, ради удобства, можно завести \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eusing Cost \u003d int;\nusing Size \u003d pair\u0026lt;size_t, size_t\u0026gt;;\nusing Parametrs \u003d pair\u0026lt;Cost, Cost\u0026gt;;\nusing Node \u003d size_t;\nusing Edge \u003d pair\u0026lt;Cost, pair\u0026lt;Node, Node\u0026gt;\u0026gt;;\nusing EdgeList \u003d vector\u0026lt;Edge\u0026gt;;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}