{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1480321076,"rating":-23,"authorHandle":"Sarthak_8","modificationTimeSeconds":1480402323,"id":48672,"title":"\u003cp\u003eSPOJ Horrible Queries\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello all. I am solving the problem here \u003ca href\u003d\"http://www.spoj.com/problems/HORRIBLE/\"\u003eSPOJ Horrible Queries\u003c/a\u003e but getting WA. I am solving it using segment tree with lazy propogation. I am not able to figure out the error in my code. It seems, it fails on the edge cases as it is giving negative values on some edge cases. I can\u0027t understand the error in my code? Here\u0027s the code.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n#include \u0026lt;math.h\u0026gt;\nusing namespace std;\nint counter \u003d 0;\n\nvoid update(long long tree[], long long lazy[], int node, int range_start, int range_end, int l, int r, int val)\n{\n    if(lazy[node] !\u003d 0)     //First we check if corresponding node in lazy array is up-to-date or not.\n    {\n        tree[node] +\u003d (range_end - range_start + 1) * lazy[node];       //Update corresponding tree node if lazy[node] not up-to-date.\n        if(range_start !\u003d range_end)        //Also if this is not the leaf node propagate the lazy[node] value to children of current node i.e. lazy[node].\n        {\n            lazy[2*node] +\u003d lazy[node];     //Propagating value to left child\n            lazy[2*node + 1] +\u003d lazy[node];     //Propagating value to right child\n        }\n        lazy[node] \u003d 0;     //Reset the node as it is now updated and values propagated to its children.\n    }\n    if(range_start \u0026gt; range_end or range_start \u0026gt; r or range_end \u0026lt; l)     //No Overlap so just stop and return.\n        return ;\n    if(range_start \u0026gt;\u003d l and range_end \u0026lt;\u003d r)        //Total Overlap.\n    {\n        tree[node] +\u003d (range_end - range_start + 1)*val;\n        if(range_start !\u003d range_end)\n        {\n            lazy[2*node] +\u003d val;\n            lazy[2*node + 1] +\u003d val;\n        }\n        return;\n    }\n    int mid \u003d (range_start + range_end)/2;\n    update(tree, lazy, 2*node, range_start, mid, l, r, val);\n    update(tree, lazy, 2*node + 1, mid + 1, range_end, l, r, val);\n    tree[node] \u003d tree[2*node] + tree[2*node + 1];\n}\n\nlong long query(long long tree[], long long lazy[], int node, int range_start, int range_end, int l, int r)\n{\n    if(range_start \u0026gt; range_end or range_start \u0026gt; r or range_end \u0026lt; l)     //No Overlap.\n        return 0;\n\n    if(lazy[node] !\u003d 0)\n    {\n        if(range_start \u003d\u003d range_end)\n            tree[node] +\u003d lazy[node];\n        else\n        {\n            tree[node] +\u003d (range_end - range_start + 1)*lazy[node];\n            lazy[2*node] \u003d lazy[node];\n            lazy[2*node + 1] \u003d lazy[node];\n        }\n        lazy[node] \u003d 0;\n    }\n\n    if(range_start \u0026gt;\u003d l and range_end \u0026lt;\u003d r)\n        return tree[node];\n    int mid \u003d (range_start + range_end)/2;\n    int p1 \u003d query(tree, lazy, 2*node, range_start, mid, l, r);\n    int p2 \u003d query(tree, lazy, 2*node + 1, mid + 1, range_end, l, r);\n    return p1+p2;\n}\n\nint main()\n{\n    int t;\n    cin\u0026gt;\u0026gt;t;\n    while(t--)\n    {\n        long long n, c, height, max_size, i, x, p, q, v, node, range_start, range_end, l, r;\n        cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;c;\n        cout\u0026lt;\u0026lt;\u0026quot;1\\n\u0026quot;;\n        long long tree[5*n], lazy[5*n];\n        cout\u0026lt;\u0026lt;\u0026quot;2\\n\u0026quot;;\n        for(long long i \u003d 0 ; i \u0026lt; 4*n ; i++)\n        {\n            tree[i] \u003d 0;\n            lazy[i] \u003d 0;\n        }\n        cout\u0026lt;\u0026lt;\u0026quot;3\\n\u0026quot;;\n        for(i \u003d 0 ; i \u0026lt; c ; i++)\n        {\n            cin\u0026gt;\u0026gt;x;\n            if(x \u003d\u003d 0)\n            {\n                cin\u0026gt;\u0026gt;p\u0026gt;\u0026gt;q\u0026gt;\u0026gt;v;\n                update(tree, lazy, 1, 1, n, p, q, v);\n            }\n            else\n            {\n                cin\u0026gt;\u0026gt;p\u0026gt;\u0026gt;q;\n                cout\u0026lt;\u0026lt;query(tree, lazy, 1, 1, n, p ,q)\u0026lt;\u0026lt;\u0026quot;\\n\u0026quot;;\n            }\n        }\n        delete(tree);\n        delete(lazy);\n    }\n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["spoj","horrible queries"]}}