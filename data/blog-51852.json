{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1493991602,"rating":0,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1493991602,"id":51852,"title":"\u003cp\u003eSolutions to Codeforces Beta Round #40, A, B(prefix idea), C, D, E(Turan\u0027s theorem)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA. Translation\u003c/p\u003e\u003cp\u003eThis is a simple problem. If the two strings have different length, then the answer must be \u0026quot;NO\u0026quot;; otherwise, we just reverse one of the strings and compare whether they are exactly the same or not.\u003c/p\u003e\u003cp\u003eB. Martian Dollar\u003c/p\u003e\u003cp\u003eA straightforward solution is to first enumerate the days when to sell, and for the i-th day, enumerate all days from the first one to the i-th one and find out the j-th day when one can buy with the cheapest price, where 1\u003d\u0026lt;j\u0026lt;\u003di. Then, the money will be b%a[j]+b/a[j]*a[i], where \u0026quot;x/y\u0026quot; means \u0026quot;integer division\u0026quot;. Finally, we output the maximum value as the answer. This solution has complexity O(N^2). However, we can further reduce it to O(N). The idea is to build another array p[N], where p[i] denotes the minimum value of a[0],a[1],...,a[i]. p[0] is initialized as p[0]\u003da[0], while p[i] can be computed as p[i]\u003dmin(a[i],p[i-1]), which takes O(N) complexity. Thus, if we sell on the i-th day, the money will be b%a[i]+b/p[i]*a[i], and the maximum one is just the answer. The total complexity will be O(N).\u003c/p\u003e\u003cp\u003eC. Email address\u003c/p\u003e\u003cp\u003eA feasible solution consists of the following steps:\u003c/p\u003e\u003cp\u003e1) change all the \u0026quot;dot\u0026quot; into \u0027.\u0027;\u003c/p\u003e\u003cp\u003e2) change all the \u0026quot;at\u0026quot; into \u0027@\u0027;\u003c/p\u003e\u003cp\u003e3) if the first or the last character is \u0027.\u0027, then change it back to \u0026quot;dot\u0026quot;; while if the first or the last character is \u0027@\u0027, change it back to \u0026quot;at\u0026quot; as well;\u003c/p\u003e\u003cp\u003e4) if there exists any other \u0027@\u0027, change all of them back to \u0027at\u0027 except for the first one.\u003c/p\u003e\u003cp\u003eD. Pawn\u003c/p\u003e\u003cp\u003eA nice DP problem for a competitive programming beginner like me.\u003c/p\u003e\u003cp\u003eWe use an array F[n][m][k+1] to implement the DP algorithm, where F[r][c][z] denotes the maximum value one can obtain in the r-th row and c-th column while the remainder divided by k+1 is z. Suppose that another array b[r][c] denotes the number of peas initially given in the r-th row and c-th column. Then, \u003c/p\u003e\u003cp\u003eF[r][c][z]\u003dmax(F[r-1][c-1][z-b[r][c]%(k+1)], F[r-1][c+1][z-b[r][c]%(k+1)]).\u003c/p\u003e\u003cp\u003eRemember to check whether the position (r-1,c-1) or (r-1,c+1) is a reasonable one or not. One should also note that if z-b[r][c]%(k+1) turns out to be a negative integer, modify it as z-b[r][c]%(k+1)+k+1. Once we have completed filling every cell of F[n][m][k+1] with a reasonable value, we can obtain the answer by finding out the maximum one of F[1][c][0], where c\u003d1,2,...,m. Furthermore, we should adopt another array S[n][m][k+1] to store the steps by which we can reach the maximum value. The value of S[r][c][z] can immediately be computed when we update F[r][c][z], i.e., \u003c/p\u003e\u003cp\u003eif F[r-1][c-1][z-b[r][c]%(k+1)]\u0026gt;F[r-1][c+1][z-b[r][c]%(k+1)], then S[r][c][z]\u003dc-1;\u003c/p\u003e\u003cp\u003eif F[r-1][c-1][z-b[r][c]%(k+1)]\u0026lt;\u003dF[r-1][c+1][z-b[r][c]%(k+1)], then S[r][c][z]\u003dc+1.\u003c/p\u003e\u003cp\u003eWhen we trace back the steps, we can start from the first row, i.e., S[1][max_c][0], where max_c denotes the column in which we obtain the answer, and if S[1][max_c][0]\u003dc-1, we move to S[2][max_c-1][0-b[1][max_c]%(k+1)]; otherwise we go to S[2][max_c+1][0-b[1][max_c]%(k+1)]. Similarly, if 0-b[1][max_c]%(k+1)\u0026lt;0, we just modify it by 0-b[1][max_c]%(k+1)+k+1.\u003c/p\u003e\u003cp\u003eE. 3-cycles\u003c/p\u003e\u003cp\u003eA famous problem in graph theory, and the solution is referred to as Turan\u0027s theorem. The original problem investigated by Turan\u0027s theorem is a more general one, which gives n points and asks what is the maximum number of edges one can connect while under the condition that the graph is (r+1)-cycle free. One can search on the internet to find some details about this problem. For this special one, the answer is just (n/2)*(n-n/2) with \u0026quot;/\u0026quot; meaning \u0026quot;integer division\u0026quot;. \u003c/p\u003e\u003c/div\u003e","tags":[]}}