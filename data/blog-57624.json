{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1518095112,"rating":4,"authorHandle":"zscoder","modificationTimeSeconds":1518095442,"id":57624,"title":"\u003cp\u003eBeginner Contest Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eProblem A — M flat\u003c/h3\u003e\u003cp\u003eWe\u0027ll use binary search to find the rabbit. Set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e \u003d 2.5·10\u003csup class\u003d\"upper-index\"\u003e8\u003c/sup\u003e\u003c/span\u003e (there are other values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e that works but this is the value chosen by the official solution).\u003c/p\u003e\u003cp\u003eOn the first move, query the position \u003cspan class\u003d\"tex-span\"\u003e2.5·10\u003csup class\u003d\"upper-index\"\u003e8\u003c/sup\u003e\u003c/span\u003e. The device returns \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e if rabbit is in the range \u003cspan class\u003d\"tex-span\"\u003e[1, 5·10\u003csup class\u003d\"upper-index\"\u003e8\u003c/sup\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e otherwise. (we assume it won\u0027t return \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e from now on as otherwise it\u0027s trivial)\u003c/p\u003e\u003cp\u003eFrom now on, we assume the rabbit is in the range \u003cspan class\u003d\"tex-span\"\u003e[1, 5·10\u003csup class\u003d\"upper-index\"\u003e8\u003c/sup\u003e]\u003c/span\u003e, as the other case is similar.\u003c/p\u003e\u003cp\u003eNow, we do binary search. Assume at some point we know the rabbit must be in the range \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e. (Initially, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d 1, \u003ci\u003er\u003c/i\u003e \u003d 5·10\u003csup class\u003d\"upper-index\"\u003e8\u003c/sup\u003e\u003c/span\u003e)\u003c/p\u003e\u003cp\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d \u003ci\u003er\u003c/i\u003e\u003c/span\u003e, we know the rabbit is at point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and we\u0027re done.\u003c/p\u003e\u003cp\u003eOtherwise, let \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f2/6a/f26a8fe4c0e01b1ea65e16808935e30710e19621.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and we would like to know whether the rabbit is in \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003emid\u003c/i\u003e]\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003emid\u003c/i\u003e + 1, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e. To do so, simply query the point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e + 1 + \u003ci\u003eC\u003c/i\u003e\u003c/span\u003e and if the return value is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e the rabbit must be in \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003emid\u003c/i\u003e + 1, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e and otherwise the rabbit is in \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003emid\u003c/i\u003e]\u003c/span\u003e. Repeat this until \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d \u003ci\u003er\u003c/i\u003e\u003c/span\u003e and we know the rabbit is at position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThis takes a total of at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/17/ec/17ec2702723f91209bed3a016e8dd69bc6a0178d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e steps.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;ll, null_type, less\u0026lt;ll\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;ll\u0026gt;::iterator sit;\ntypedef map\u0026lt;ll,ll\u0026gt;::iterator mit;\n\nconst int N \u003d int(1e9);\nconst int C \u003d int(1e7)*25;\n\nint query(int x)\n{\n\tcout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0027\\n\u0027;\n\tfflush(stdout);\n\tint y; cin\u0026gt;\u0026gt;y; return y;\n}\n\nint main()\n{\n\tint t; cin\u0026gt;\u0026gt;t;\n\twhile(t--)\n\t{\n\t\tcout\u0026lt;\u0026lt;C\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\tfflush(stdout);\n\t\tint tmp \u003d query(C);\n\t\tif(tmp\u003d\u003d2)\n\t\t{\n\t\t\tcontinue;\n\t\t}\t\n\t\tif(tmp\u003d\u003d1) //[1,5e8]\n\t\t{\n\t\t\tll lo \u003d 1; ll hi \u003d C*2;\n\t\t\twhile(lo\u0026lt;\u003dhi)\n\t\t\t{\n\t\t\t\tll mid \u003d (lo+hi)\u0026gt;\u0026gt;1;\n\t\t\t\tif(lo\u003d\u003dhi)\n\t\t\t\t{\n\t\t\t\t\tquery(mid);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint x \u003d query(mid+1+C);\n\t\t\t\tif(x\u003d\u003d2) break;\n\t\t\t\tif(x\u003d\u003d1)\n\t\t\t\t{\n\t\t\t\t\tlo \u003d mid + 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\thi \u003d mid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse //[5e8+1,1e9]\n\t\t{\n\t\t\tll lo \u003d C*2+1; ll hi \u003d C*4;\n\t\t\twhile(lo\u0026lt;\u003dhi)\n\t\t\t{\n\t\t\t\tll mid \u003d (lo+hi)\u0026gt;\u0026gt;1;\n\t\t\t\tif(lo\u003d\u003dhi)\n\t\t\t\t{\n\t\t\t\t\tquery(mid);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint x \u003d query(mid-C);\n\t\t\t\tif(x\u003d\u003d2) break;\n\t\t\t\tif(x\u003d\u003d1)\n\t\t\t\t{\n\t\t\t\t\thi \u003d mid;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlo \u003d mid + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003eProblem B — Over and over\u003c/h3\u003e\u003cp\u003eThe easiest solution is to consider all possible subrectangles, and for each subrectangle check whether it is beautiful individually. The first part takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003ci\u003em\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e time while the second part takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e)\u003c/span\u003e time, so this takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003ci\u003em\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e, which is far too slow to pass.\u003c/p\u003e\u003cp\u003eFrom now on, we\u0027ll use an important fact.\u003c/p\u003e\u003cp\u003eFact : The dimensions of a beautiful subrectangle cannot exceed \u003cspan class\u003d\"tex-span\"\u003e52\u003c/span\u003e (the number of possible colors)\u003c/p\u003e\u003cp\u003eProof : Suppose the number of rows exceed \u003cspan class\u003d\"tex-span\"\u003e52\u003c/span\u003e (the proof is the same for columns), then by pigeonhole principle two cells on the first column have the same color, so the subrectangle cannot be beautiful.\u003c/p\u003e\u003cp\u003eWith this, we can improve our brute force solution to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e·52\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e)\u003c/span\u003e by iterating through only the subrectangles with dimensions \u003cspan class\u003d\"tex-span\"\u003e ≤ 52\u003c/span\u003e. This is unfortunately still too slow.\u003c/p\u003e\u003cp\u003eLet\u0027s iterate through the top left corner \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e of our subrectangle. We iterate through the possible values of the bottom row \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e in ascending order. We want to find the number of integers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e such that the subrectangle with top-left and bottom-right corners \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e, \u003ci\u003el\u003c/i\u003e)\u003c/span\u003e is beautiful. Note that if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e works then all the values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e + 1, ..., \u003ci\u003el\u003c/i\u003e\u003c/span\u003e also works. Thus, we just have to find the maximum integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e that works.\u003c/p\u003e\u003cp\u003eTo do so, start from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e and increase the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e one by one. We maintain the set of integers that has already appeared on the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e-th row (the author\u0027s solution used a long long integer and take advantage of the fact that there\u0027re only \u003cspan class\u003d\"tex-span\"\u003e52\u003c/span\u003e possible colors to store this information where the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th bit of the integer is on iff color \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e has already appeared). The key observation is that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e cannot ever exceed the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e computed in the previous row, i.e. as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e increases the maximum value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e is non-increasing. Thus, to check whether the current subrectangle is beautiful, we only have to check whether the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e-th row consists of distinct integers (as the previous rows has been checked previously for smaller values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e), and also check whether the current column consists of distinct integers.\u003c/p\u003e\u003cp\u003eLet\u0027s try to calculate the time complexity. There are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e)\u003c/span\u003e possible top-left corners. There are at most \u003cspan class\u003d\"tex-span\"\u003e52\u003c/span\u003e values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, and for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e we try at most \u003cspan class\u003d\"tex-span\"\u003e52\u003c/span\u003e values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e. Furthermore, to test each value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e, we need to iterate through the cells in one column of the subrectangle (which has size \u003cspan class\u003d\"tex-span\"\u003e ≤ 52\u003c/span\u003e). Thus, the time complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e·52\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e, which is still too slow.\u003c/p\u003e\u003cp\u003eWe can optimize it by finding a way to check if the current column consists of distinct integers without iterating through the previous cells one by one. We maintain an array of long long \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e[]\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e]\u003c/span\u003e is a long long that denotes the set of colors used in column \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e so far. Now, each check can be done in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e as we can check whether the current color is already part of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e]\u003c/span\u003e and just update the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e]\u003c/span\u003e by adding the color of the current cell to the set. The time complexity is thus reduced to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e·52\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e, which is still not fast enough to pass.\u003c/p\u003e\u003cp\u003eTo get a faster solution, we need to do some precomputation. Let\u0027s denote \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e as the largest index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e such that the squares \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e), (\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e + 1), ..., (\u003ci\u003ei\u003c/i\u003e, \u003ci\u003el\u003c/i\u003e)\u003c/span\u003e are all of different colors and let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e as the largest index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e such that the squares \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e), (\u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003ej\u003c/i\u003e), ..., (\u003ci\u003ei\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e are all of different colors. These values can be computed in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e)\u003c/span\u003e total easily.\u003c/p\u003e\u003cp\u003eWith this values, we can find the answer for each top-left corner faster. Again, fix the top-left corner \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e. Also, we\u0027ll still iterate through the bottom row \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e in increasing order. The idea is that we will start considering the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e + 52\u003c/span\u003e and reduce it by one until we managed to make our current subrectangle beautiful. Then, we increase the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e and since the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e is non-increasing as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e decreases we can start considering the current \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e from the previous \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e. This way, we won\u0027t iterate through the values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e each time and the total number of values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e we consider is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(52)\u003c/span\u003e for the top-left corner \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIt remains to be able to determine whether the subrectangle formed from \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e, \u003ci\u003el\u003c/i\u003e)\u003c/span\u003e is beautiful in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time. This is true if and only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003eR\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e], \u003ci\u003eR\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1][\u003ci\u003ej\u003c/i\u003e], ..., \u003ci\u003eR\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]) ≥ \u003ci\u003el\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003eD\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e], \u003ci\u003eD\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e + 1], ..., \u003ci\u003eD\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003el\u003c/i\u003e]) ≥ \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Unfortunately, iterating through all these numbers is a bit too slow. The idea is that we can precompute the prefix minimums \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003eR\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e], \u003ci\u003eR\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1][\u003ci\u003ej\u003c/i\u003e], ..., \u003ci\u003eR\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e])\u003c/span\u003e for a fixed \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003ek\u003c/i\u003e ≤ \u003ci\u003ei\u003c/i\u003e + 52\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(52)\u003c/span\u003e time and similarly we can precompute the prefix minimums \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003eD\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e], \u003ci\u003eD\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e + 1], ..., \u003ci\u003eD\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003el\u003c/i\u003e])\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e ≤ \u003ci\u003el\u003c/i\u003e ≤ \u003ci\u003ej\u003c/i\u003e + 52\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(52)\u003c/span\u003e time. Now, we can just read the result from the precomputation table in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eO(nm*52*52*52) solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;ll, null_type, less\u0026lt;ll\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;ll\u0026gt;::iterator sit;\ntypedef map\u0026lt;ll,ll\u0026gt;::iterator mit;\n\nint a[2111][2111];\nll B[2111];\n\nint convert(char c)\n{\n\tif(c\u0026gt;\u003d\u0027a\u0027\u0026amp;\u0026amp;c\u0026lt;\u003d\u0027z\u0027) return c-\u0027a\u0027;\n\telse return c-\u0027A\u0027+26;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tfor(int j\u003d0;j\u0026lt;m;j++)\n\t\t{\n\t\t\tchar c; cin\u0026gt;\u0026gt;c; a[i][j] \u003d convert(c);\n\t\t}\n\t}\n\tll ans \u003d 0;\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tfor(int j\u003d0;j\u0026lt;m;j++)\n\t\t{\n\t\t\t//count number of sudoku grids with top-left corner (i,j)\n\t\t\tint ptr \u003d m - 1;\n\t\t\t\n\t\t\tfor(int k\u003di;k\u0026lt;n;k++)\n\t\t\t{\n\t\t\t\tif(ptr\u0026lt;j) break;\n\t\t\t\tll rowbit \u003d 0;\n\t\t\t\tfor(int l\u003dj;l\u0026lt;\u003dptr;l++) \n\t\t\t\t{\n\t\t\t\t\tif(rowbit\u0026amp;(1LL\u0026lt;\u0026lt;(a[k][l])))\n\t\t\t\t\t{\n\t\t\t\t\t\tptr\u003dl-1; break;\n\t\t\t\t\t}\n\t\t\t\t\trowbit|\u003d(1LL\u0026lt;\u0026lt;(a[k][l]));\n\t\t\t\t\tll colbit \u003d 0; bool pos\u003d1;\n\t\t\t\t\tfor(int z\u003di;z\u0026lt;\u003dk;z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(colbit\u0026amp;(1LL\u0026lt;\u0026lt;a[z][l]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpos\u003d0; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolbit|\u003d(1LL\u0026lt;\u0026lt;a[z][l]);\n\t\t\t\t\t}\n\t\t\t\t\tif(!pos)\n\t\t\t\t\t{\n\t\t\t\t\t\tptr\u003dl-1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//[j, ptr] works \n\t\t\t\tans+\u003dptr-j+1;\n\t\t\t}\n\t\t}\n\t}\n\tcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eO(nm*52*52) solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;ll, null_type, less\u0026lt;ll\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;ll\u0026gt;::iterator sit;\ntypedef map\u0026lt;ll,ll\u0026gt;::iterator mit;\n\nint a[2111][2111];\nll B[2111];\n\nint convert(char c)\n{\n\tif(c\u0026gt;\u003d\u0027a\u0027\u0026amp;\u0026amp;c\u0026lt;\u003d\u0027z\u0027) return c-\u0027a\u0027;\n\telse return c-\u0027A\u0027+26;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tfor(int j\u003d0;j\u0026lt;m;j++)\n\t\t{\n\t\t\tchar c; cin\u0026gt;\u0026gt;c; a[i][j]\u003dconvert(c);\n\t\t}\n\t}\n\tll ans \u003d 0;\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tfor(int j\u003d0;j\u0026lt;m;j++)\n\t\t{\n\t\t\t//count number of sudoku grids with top-left corner (i,j)\n\t\t\tint ptr \u003d m - 1;\n\t\t\tfor(int k\u003di;k\u0026lt;n;k++)\n\t\t\t{\n\t\t\t\tif(ptr\u0026lt;j) break;\n\t\t\t\tll rowbit \u003d 0;\n\t\t\t\tfor(int l\u003dj;l\u0026lt;\u003dptr;l++) \n\t\t\t\t{\n\t\t\t\t\tif(rowbit\u0026amp;(1LL\u0026lt;\u0026lt;(a[k][l])))\n\t\t\t\t\t{\n\t\t\t\t\t\tptr\u003dl-1; break;\n\t\t\t\t\t}\n\t\t\t\t\trowbit|\u003d(1LL\u0026lt;\u0026lt;(a[k][l]));\n\t\t\t\t\tif(k\u003d\u003di) B[l] \u003d 0;\n\t\t\t\t\tif(B[l]\u0026amp;(1LL\u0026lt;\u0026lt;a[k][l]))\n\t\t\t\t\t{\n\t\t\t\t\t\tptr\u003dl-1; break;\n\t\t\t\t\t}\n\t\t\t\t\tB[l]|\u003d(1LL\u0026lt;\u0026lt;a[k][l]);\n\t\t\t\t}\n\t\t\t\t//[j, ptr] works \n\t\t\t\tans+\u003dptr-j+1;\n\t\t\t}\n\t\t}\n\t}\n\tcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eO(nm*52) solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;ll, null_type, less\u0026lt;ll\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;ll\u0026gt;::iterator sit;\ntypedef map\u0026lt;ll,ll\u0026gt;::iterator mit;\n\nint a[2111][2111];\nint R[2111][2111];\nint D[2111][2111];\n\nint convert(char c)\n{\n\tif(c\u0026gt;\u003d\u0027a\u0027\u0026amp;\u0026amp;c\u0026lt;\u003d\u0027z\u0027) return c-\u0027a\u0027;\n\telse return c-\u0027A\u0027+26;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tfor(int j\u003d0;j\u0026lt;m;j++)\n\t\t{\n\t\t\tchar c; cin\u0026gt;\u0026gt;c; a[i][j]\u003dconvert(c);\n\t\t}\n\t}\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tll curbit \u003d 0; int ptr \u003d -1;\n\t\tfor(int j \u003d 0; j \u0026lt; m; j++)\n\t\t{\n\t\t\twhile(ptr+1\u0026lt;m\u0026amp;\u0026amp;!(curbit\u0026amp;(1LL\u0026lt;\u0026lt;a[i][ptr+1])))\n\t\t\t{\n\t\t\t\tptr++;\n\t\t\t\tcurbit|\u003d(1LL\u0026lt;\u0026lt;a[i][ptr]);\n\t\t\t}\n\t\t\tR[i][j] \u003d ptr;\n\t\t\tcurbit^\u003d(1LL\u0026lt;\u0026lt;a[i][j]);\n\t\t}\n\t}\n\tfor(int j \u003d 0; j \u0026lt; m; j++)\n\t{\n\t\tint ptr \u003d -1; ll curbit \u003d 0; \n\t\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t\t{\t\t\t\n\t\t\twhile(ptr+1\u0026lt;n\u0026amp;\u0026amp;!(curbit\u0026amp;(1LL\u0026lt;\u0026lt;a[ptr+1][j])))\n\t\t\t{\n\t\t\t\tptr++;\n\t\t\t\tcurbit|\u003d(1LL\u0026lt;\u0026lt;a[ptr][j]);\n\t\t\t}\n\t\t\tD[i][j] \u003d ptr;\n\t\t\tcurbit^\u003d(1LL\u0026lt;\u0026lt;a[i][j]);\n\t\t}\n\t}\n\tll ans \u003d 0;\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tfor(int j\u003d0;j\u0026lt;m;j++)\n\t\t{\n\t\t\tint ptr \u003d min(j+52, m - 1);\n\t\t\tvi vec(53,-1);\n\t\t\tfor(int k\u003dj;k\u0026lt;min(j+53,m);k++)\n\t\t\t{\n\t\t\t\tvec[k-j] \u003d D[i][k];\n\t\t\t\tif(k\u0026gt;j) vec[k-j]\u003dmin(vec[k-j],vec[k-1-j]);\n\t\t\t}\n\t\t\tfor(int k\u003di;k\u0026lt;n;k++)\n\t\t\t{\n\t\t\t\tif(ptr\u0026lt;j) break;\n\t\t\t\twhile(ptr\u0026gt;\u003dj\u0026amp;\u0026amp;(R[k][j]\u0026lt;ptr||vec[ptr-j]\u0026lt;k)) ptr--;\n\t\t\t\tans+\u003dptr-j+1;\n\t\t\t}\n\t\t}\n\t}\n\tcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003eProblem C — No Buts!\u003c/h3\u003e\u003cp\u003eThis is another straightforward binary search problem. \u003c/p\u003e\u003cp\u003eThe first idea might be binary search for each letter from left to right. Suppose we have determined a prefix of the password \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, and that we already know \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e is not the actual password (i.e. the actual password is longer). To find the next letter, we binary search the letters \u0027a\u0027 to \u0027z\u0027. Note that if we ask about the concatenation of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e and the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e-th character of the alphabet, then if the return value is \u0027\u0026gt;\u0027, we know the next letter of our string is at least the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e-th character of the alphabet, otherwise it must be at most the \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ec\u003c/i\u003e - 1)\u003c/span\u003e-th character. With this fact, we can do binary search to find the next letter of the string. It takes \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/01/ec/01ec658e3f9ed95bd5d5d9d475546bc5d00fa1fe.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e moves to find the next letter and we need one extra move to actually query this string so that we can know whether this is already the correct password or there are still more letters. Thus, this brings us to around \u003cspan class\u003d\"tex-span\"\u003e12·6 \u003d 72\u003c/span\u003e queries (which can be optimized slightly but won\u0027t be enough to pass).\u003c/p\u003e\u003cp\u003eConsider the simpler problem when the password is a single integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e inclusive, and we need to guess it. For each guess, the grader will tell us whether the password is higher, lower or equal to our guess. This is just a classic introductory binary search problem and you can use \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d7/e0/d7e0cd9147b62fa93a667008883b90244d53e0d8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e queries to find the password.\u003c/p\u003e\u003cp\u003eIn fact, our current problem can be reduced to this simpler version.\u003c/p\u003e\u003cp\u003eSuppose we have all the valid passwords in sorted order. Label each password by its index in the sorted list of valid passwords (in lexicographical order). Now, our task is equivalent to finding a hidden number from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e with queries that tell us whether our guess is too high, too low or equal.\u003c/p\u003e\u003cp\u003eHowever, there are \u003cspan class\u003d\"tex-span\"\u003e26\u003csup class\u003d\"upper-index\"\u003e1\u003c/sup\u003e + 26\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e + ... + 26\u003csup class\u003d\"upper-index\"\u003e12\u003c/sup\u003e \u003d 99246114928149462 ≈ 10\u003csup class\u003d\"upper-index\"\u003e17\u003c/sup\u003e\u003c/span\u003e possible passwords so storing all of them is out of the question. The trick is that we don\u0027t really need to store all these passwords. All we need to know is that given \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, what is the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e-th smallest valid password in the sorted list. \u003c/p\u003e\u003cp\u003eOur task reduces to finding the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e-th smallest valid password fast.\u003c/p\u003e\u003cp\u003eTo find such string, we start from the first letter and try all possibilities from \u0026quot;a\u0026quot; to \u0026quot;z\u0026quot;. We know that the string must start with \u0026quot;a\u0026quot; if the number of valid passwords (including the empty string) of length \u003cspan class\u003d\"tex-span\"\u003e ≤ 11\u003c/span\u003e is at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e. If this is true, we move on to the next character. Otherwise, we subtract the number of valid passwords (including the empty string) of length \u003cspan class\u003d\"tex-span\"\u003e ≤ 11\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e and repeat the same process with the letter \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot; and so on until eventually we find the value of the current character. You can see the details of this process in the code.\u003c/p\u003e\u003cp\u003eIt is possible to do the binary search in at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/21/5e/215ed1b7b1f2beee5970c6d3caf60614e6eb6594.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e queries (note that it\u0027s floor instead of ceil because when we query for the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e\u003c/span\u003e-th smallest string, depending on the answer we know that our string is in one of the three segments \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003emid\u003c/i\u003e - 1], [\u003ci\u003emid\u003c/i\u003e, \u003ci\u003emid\u003c/i\u003e], [\u003ci\u003emid\u003c/i\u003e + 1, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;ll, null_type, less\u0026lt;ll\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;ll\u0026gt;::iterator sit;\ntypedef map\u0026lt;ll,ll\u0026gt;::iterator mit;\n\nll dp[30];\nconst int SIGMA \u003d 26;\nconst int C \u003d 12;\n\nstring get_at(ll n)\n{\n\tstring cur \u003d \u0026quot;\u0026quot;; ll ans \u003d 0;\n\tfor(int i\u003d0;i\u0026lt;C;i++)\n\t{\n\t\tif(ans\u003d\u003dn) break;\n\t\tans++;\n\t\tint idx\u003d0;\n\t\twhile(ans+dp[C-1-i]\u0026lt;\u003dn)\n\t\t{\n\t\t\tans+\u003ddp[C-1-i];\n\t\t\tidx++;\n\t\t}\n\t\tcur+\u003dchar(\u0027a\u0027+idx);\n\t}\n\treturn cur;\n}\n\nchar query(string s)\n{\n\tcout\u0026lt;\u0026lt;\u0026quot;? \u0026quot;\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0027\\n\u0027;\n\tfflush(stdout);\n\tchar c; cin\u0026gt;\u0026gt;c; return c;\n}\n\nvoid answer(string s)\n{\n\tcout\u0026lt;\u0026lt;\u0026quot;! \u0026quot;\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0027\\n\u0027;\n\tfflush(stdout);\n}\n\nint main()\n{\n\tdp[0] \u003d 1;\n\tfor(int i\u003d1;i\u0026lt;\u003dC;i++)\n\t{\n\t\tdp[i]\u003ddp[i-1]*SIGMA;\n\t}\n\tfor(int i\u003d1;i\u0026lt;\u003dC;i++) dp[i]+\u003ddp[i-1];\n\tint t; cin\u0026gt;\u0026gt;t;\n\tfor(int cc\u003d0;cc\u0026lt;t;cc++)\n\t{\n\t\tll lo \u003d 1; ll hi \u003d dp[C]-1;\n\t\twhile(lo\u0026lt;\u003dhi)\n\t\t{\n\t\t\tll mid\u003d(lo+hi)\u0026gt;\u0026gt;1; string cur \u003d get_at(mid);\n\t\t\tif(lo\u003d\u003dhi)\n\t\t\t{\n\t\t\t\tanswer(cur); break;\n\t\t\t}\t\t\t\n\t\t\tchar c \u003d query(cur);\n\t\t\tif(c\u003d\u003d\u0027\u003d\u0027)\n\t\t\t{\n\t\t\t\tanswer(cur);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(c\u003d\u003d\u0027\u0026gt;\u0027)\n\t\t\t{\n\t\t\t\tlo \u003d mid + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thi \u003d mid - 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003eProblem D — Irony\u003c/h3\u003e\u003cp\u003eThe main idea of this problem is abusing the symmetric strategy.\u003c/p\u003e\u003cp\u003eSuppose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is odd. We let the first player color the central row black. Now, the grid is divided into two equal parts of white squares. Whenever player \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e plays a move in one of the halves, player \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e can always copy the same move in the other half. Thus, player \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e can never run out of moves before player \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e and thus with this strategy player \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e can force a win.\u003c/p\u003e\u003cp\u003eSimilarly, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e is odd, the first player can win by coloring the central column black and using a symmetric strategy.\u003c/p\u003e\u003cp\u003eNow, suppose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e\u003c/span\u003e are both even. Let\u0027s pair up the squares of the chessboard where square \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e is paired with square \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e + 1 - \u003ci\u003ei\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e + 1 - \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e. Now, player \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e has a simple winning strategy. Whenever player \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e colors some squares black, player \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e will reply by coloring the squares that are in the same pair of one of the squares that player \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e just colored. This move is always valid because no two squares of the same pair can be colored in the same move (they lie in different rows and columns), if player \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e colored a segment then player \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e must have colored a segment as well, and also after player \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e\u0027s move, a square is colored black if and only if the other square in its pair is colored black. Thus, player \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e can never run out of moves before player \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and thus player \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e can force a win.\u003c/p\u003e\u003cp\u003eIn other words, every time player \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e plays \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e, player \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e should reply with \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e + 1 - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003en\u003c/i\u003e + 1 - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003em\u003c/i\u003e + 1 - \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003em\u003c/i\u003e + 1 - \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cimg src\u003d\"/predownloaded/6a/ed/6aed019bde6aab119352680c3efdb0ca3b5d9ec0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThis is how the pairing looks like when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 4, \u003ci\u003em\u003c/i\u003e \u003d 6\u003c/span\u003e. Same color denotes squares in the same pair.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;ll, null_type, less\u0026lt;ll\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;ll\u0026gt;::iterator sit;\ntypedef map\u0026lt;ll,ll\u0026gt;::iterator mit;\n\nint main()\n{\n\tint t; cin\u0026gt;\u0026gt;t;\n\twhile(t--)\n\t{\n\t\tint n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\n\t\tif(n%2\u003d\u003d0\u0026amp;\u0026amp;m%2\u003d\u003d0)\n\t\t{\n\t\t\tcout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;\u0027\\n\u0027; fflush(stdout);\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tint x1,x2,y1,y2;\n\t\t\t\tcin\u0026gt;\u0026gt;x1\u0026gt;\u0026gt;x2\u0026gt;\u0026gt;y1\u0026gt;\u0026gt;y2;\n\t\t\t\tif(x1\u0026lt;0) break;\n\t\t\t\tcout\u0026lt;\u0026lt;min(n+1-y1,n+1-x1)\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;min(m+1-y2,m+1-x2)\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;max(n+1-y1,n+1-x1)\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;max(m+1-x2,m+1-y2)\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\t\t\tfflush(stdout);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0027\\n\u0027; fflush(stdout);\n\t\t\tif(n\u0026amp;1)\n\t\t\t{\n\t\t\t\tint half \u003d (n+1)/2;\n\t\t\t\tcout\u0026lt;\u0026lt;half\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;half\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;m\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\t\t\tfflush(stdout);\n\t\t\t\twhile(1)\n\t\t\t\t{\n\t\t\t\t\tint x1,x2,y1,y2;\n\t\t\t\t\tcin\u0026gt;\u0026gt;x1\u0026gt;\u0026gt;x2\u0026gt;\u0026gt;y1\u0026gt;\u0026gt;y2;\n\t\t\t\t\tif(x1\u0026lt;0) break;\n\t\t\t\t\tif(x1\u0026lt;half)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout\u0026lt;\u0026lt;x1+half\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;x2\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;y1+half\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;y2\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\t\t\t\t\tfflush(stdout);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcout\u0026lt;\u0026lt;x1-half\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;x2\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;y1-half\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;y2\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\t\t\t\t\tfflush(stdout);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint half \u003d (m+1)/2;\n\t\t\t\tcout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;half\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;half\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\t\t\tfflush(stdout);\n\t\t\t\twhile(1)\n\t\t\t\t{\n\t\t\t\t\tint x1,x2,y1,y2;\n\t\t\t\t\tcin\u0026gt;\u0026gt;x1\u0026gt;\u0026gt;x2\u0026gt;\u0026gt;y1\u0026gt;\u0026gt;y2;\n\t\t\t\t\tif(x1\u0026lt;0) break;\n\t\t\t\t\tif(x2\u0026lt;half)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout\u0026lt;\u0026lt;x1\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;x2+half\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;y1\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;y2+half\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\t\t\t\t\tfflush(stdout);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcout\u0026lt;\u0026lt;x1\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;x2-half\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;y1\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;y2-half\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\t\t\t\t\tfflush(stdout);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003eProblem E — Kimi ni matsuwaru Mystery\u003c/h3\u003e\u003cp\u003eTo solve this type of problem, first we need to know how to calculate the values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e, \u003ci\u003eB\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e\u003c/span\u003e given a fixed string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e. If we know the type of every person (i.e. there are no question marks), then it\u0027s easy since we can just simulate the entire tournament. It turns out that a similar method allows us to calculate the values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e, \u003ci\u003eB\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Image of the tournament tree\" src\u003d\"/predownloaded/e5/a0/e5a0b8c43984a1e3bfac8ad2076924dec7ef5238.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s construct a tournament tree, where the leaves are the participants of the first round and the parent of two nodes is the winner of the match played between the children. The root is the winner of the tournament.\u003c/p\u003e\u003cp\u003eFor each node of the tree, compute the number of ways to fill the question marks in the subtree so that the resulting player in the node is R, S, and P respectively. For the leaves, if the player is of type R, then the value is \u003cspan class\u003d\"tex-span\"\u003e(1, 0, 0)\u003c/span\u003e. If the player is of type S, the value is \u003cspan class\u003d\"tex-span\"\u003e(0, 1, 0)\u003c/span\u003e. If the player is of type P, the value is \u003cspan class\u003d\"tex-span\"\u003e(0, 0, 1)\u003c/span\u003e. Finally, if the player type is unknown (i.e. a question mark), the value is \u003cspan class\u003d\"tex-span\"\u003e(1, 1, 1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eHow to compute the value of a node \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e given the values of its two childrens \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e. This can be done in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e by noting that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e \u003d (\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)(\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e + \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e) - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, i.e. the number of ways to get a player of type R in this node is the number of ways for both children to be of type S or R and not both of them can be of type S. Similar identities hold for other \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Thus, we can compute the values of all nodes while building the tree (in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e time, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e \u003d 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e is the number of players). Finally, the values in the root of the tree corresponds to the desired \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e, \u003ci\u003eB\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eHere, we need to solve the inverse problem : Given \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e, \u003ci\u003eB\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e\u003c/span\u003e we have to find a string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e such that the tournament tree produced by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e has root \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eA\u003c/i\u003e, \u003ci\u003eB\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e)\u003c/span\u003e. Note that the problem statement states that the string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e can contain at most \u003cspan class\u003d\"tex-span\"\u003e32\u003c/span\u003e characters, i.e. there are at most \u003cspan class\u003d\"tex-span\"\u003e32\u003c/span\u003e players. This number looks small so maybe we can do something about it.\u003c/p\u003e\u003cp\u003eWhat if we try to enumerate all the possible tournaments? Let\u0027s count how many such tournaments are there. There are \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e ways to choose each player (R, S, P, ?), so this means there are \u003cspan class\u003d\"tex-span\"\u003e4\u003csup class\u003d\"upper-index\"\u003e32\u003c/sup\u003e\u003c/span\u003e tournaments with \u003cspan class\u003d\"tex-span\"\u003e32\u003c/span\u003e participants alone, which is way too much to be enumerated.\u003c/p\u003e\u003cp\u003eHowever, if we look closer, the only important thing is actually the value of \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eA\u003c/i\u003e, \u003ci\u003eB\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e)\u003c/span\u003e produced by the tournament. Suddenly, our search space has become much smaller. Let\u0027s start from the \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e tournaments of size \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e each producing a different triple. To generate all distinct triples of size \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e, we take all possible pairs of triples of size \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e and combine them (i.e. concatenate them and calculate the value, which can be done in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e by just combining the two triples like how we compute the value of node with the value of its children). Then, we can use a map that maps a triple to a string to store the possible triples formed from tournaments of size \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e and the tournament that generates the triple. \u003c/p\u003e\u003cp\u003eUsing this method, we find that there are \u003cspan class\u003d\"tex-span\"\u003e23121\u003c/span\u003e possible triples generated from tournaments of size \u003cspan class\u003d\"tex-span\"\u003e16\u003c/span\u003e. Thus, by storing all the triples formed by tournaments of size \u003cspan class\u003d\"tex-span\"\u003e1, 2, 4, 8, 16\u003c/span\u003e as well as the tournament that generated them we can answer the question for a triple \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eA\u003c/i\u003e, \u003ci\u003eB\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e)\u003c/span\u003e if it\u0027s generated from a string of length \u003cspan class\u003d\"tex-span\"\u003e ≤ 16\u003c/span\u003e. However, finding all possible triples from combining two tournaments of size \u003cspan class\u003d\"tex-span\"\u003e32\u003c/span\u003e might take long as we need to try all pairs of triples, and even if we did find all of them in time we don\u0027t really have the memory to store everything. So, how do we know if a triple \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eA\u003c/i\u003e, \u003ci\u003eB\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e)\u003c/span\u003e is produced by a tournament of size \u003cspan class\u003d\"tex-span\"\u003e32\u003c/span\u003e?\u003c/p\u003e\u003cp\u003eA tournament of size \u003cspan class\u003d\"tex-span\"\u003e32\u003c/span\u003e is formed by combining two tournaments of size \u003cspan class\u003d\"tex-span\"\u003e16\u003c/span\u003e. Let\u0027s iterate over all possible triples for the first tournament of size \u003cspan class\u003d\"tex-span\"\u003e16\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e. We need to determine if there exist a triple from a tournament of size \u003cspan class\u003d\"tex-span\"\u003e16\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e such that their combination is \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eA\u003c/i\u003e, \u003ci\u003eB\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe have the equations \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e) + \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e \u003d \u003ci\u003eA\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e) + \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u003d \u003ci\u003eB\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e) + \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u003d \u003ci\u003eC\u003c/i\u003e\u003c/span\u003e. These are just simultaneous equations in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e so we can solve them. However, we need to be careful when some of the elements \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e are \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e and also the fact that the intermediate values might exceed the range of long long.\u003c/p\u003e\u003cp\u003eVerify that if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e ≠ 0, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ≠ 0, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e ≠ 0\u003c/span\u003e, we have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f4/27/f427980104a11e4ce3f2208b4169e507f37c2e6c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and similar identities.\u003c/p\u003e\u003cp\u003eWe can use long double to store the intermediate results and in the end, we try both rounding down and up in case of precision errors for each value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. We check whether our triple \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e by combining it with \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e to see if it produces \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eA\u003c/i\u003e, \u003ci\u003eB\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e)\u003c/span\u003e and also check if it\u0027s among the triples produced by tournaments of size \u003cspan class\u003d\"tex-span\"\u003e16\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSince we only loop through \u003cspan class\u003d\"tex-span\"\u003e23121\u003c/span\u003e triples per query, and for each triple we use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time to check if it works (albeit with a slightly large constant), this is sufficient to pass.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;ll, null_type, less\u0026lt;ll\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;ll\u0026gt;::iterator sit;\ntypedef map\u0026lt;ll,ll\u0026gt;::iterator mit;\n\nstruct node\n{\n\tll a[3];\n};\n\nstruct cmp {\n    bool operator()(const node \u0026amp;a, const node\u0026amp; b) const {\n        if(a.a[0]!\u003db.a[0]) return a.a[0]\u0026lt;b.a[0];\n        if(a.a[1]!\u003db.a[1]) return a.a[1]\u0026lt;b.a[1];\n        return a.a[2]\u0026lt;b.a[2];\n    }\n};\n\nnode combine(node x, node y)\n{\n\tnode z;\n\tfor(int i\u003d0;i\u0026lt;3;i++)\n\t{\n\t\tz.a[i] \u003d (x.a[i]+x.a[(i+1)%3])*(y.a[i]+y.a[(i+1)%3]) - x.a[(i+1)%3]*y.a[(i+1)%3];\n\t}\n\treturn z;\n}\n\nnode create(ll a, ll b, ll c)\n{\n\tnode tmp;\n\ttmp.a[0]\u003da; tmp.a[1]\u003db; tmp.a[2]\u003dc;\n\treturn tmp;\n}\n\nbool equal(node x, node y)\n{\n\tfor(int i\u003d0;i\u0026lt;3;i++) {if(x.a[i]!\u003dy.a[i]){return false;}}\n\treturn true;\n}\n\nmap\u0026lt;node,string,cmp\u0026gt; ma[6];\n\nvoid gen_possibilities()\n{\n\tma[0][create(1,0,0)]\u003d\u0026quot;R\u0026quot;;\n\tma[0][create(0,1,0)]\u003d\u0026quot;S\u0026quot;;\n\tma[0][create(0,0,1)]\u003d\u0026quot;P\u0026quot;;\n\tma[0][create(1,1,1)]\u003d\u0026quot;?\u0026quot;;\n\tfor(int i\u003d1;i\u0026lt;\u003d4;i++)\n\t{\n\t\tfor(auto it \u003d ma[i-1].begin(); it !\u003d ma[i-1].end(); it++)\n\t\t{\n\t\t\tfor(auto it2 \u003d ma[i-1].begin(); it2 !\u003d ma[i-1].end(); it2++)\n\t\t\t{\n\t\t\t\tma[i][combine(it-\u0026gt;fi,it2-\u0026gt;fi)] \u003d it-\u0026gt;se+it2-\u0026gt;se;\n\t\t\t}\n\t\t}\n\t}\n}\n\nset\u0026lt;ll\u0026gt; S;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint t; cin\u0026gt;\u0026gt;t;\n\tgen_possibilities();\n\tll cur \u003d 1;\n\tfor(int i\u003d0;i\u0026lt;\u003d32;i++)\n\t{\n\t\tS.insert(cur); cur*\u003d3;\n\t}\n\twhile(t--)\n\t{\n\t\tnode A;\n\t\tfor(int i\u003d0;i\u0026lt;3;i++) cin\u0026gt;\u0026gt;A.a[i];\n\t\tll sum \u003d A.a[0]+A.a[1]+A.a[2];\n\t\tif(S.find(sum)\u003d\u003dS.end())\n\t\t{\n\t\t\tcout\u0026lt;\u0026lt;\u0026quot;Impossible\\n\u0026quot;; continue;\n\t\t}\n\t\tbool pos\u003d0;\n\t\tfor(int i\u003d0;i\u0026lt;\u003d4;i++)\n\t\t{\n\t\t\tif(ma[i].find(A)!\u003dma[i].end())\n\t\t\t{\n\t\t\t\tcout\u0026lt;\u0026lt;ma[i][A]\u0026lt;\u0026lt;\u0027\\n\u0027; pos\u003d1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(pos) continue;\n\t\tfor(auto it \u003d ma[4].begin(); it !\u003d ma[4].end(); it++)\n\t\t{\n\t\t\tnode cur \u003d it-\u0026gt;fi;\n\t\t\tll sumsmall \u003d cur.a[0]+cur.a[1]+cur.a[2];\n\t\t\tif(sum\u0026lt;sumsmall) continue;\n\t\t\tif(pos) break;\n\t\t\tll bsum \u003d sum/sumsmall;\n\t\t\tif(cur.a[0]!\u003d0\u0026amp;\u0026amp;cur.a[1]!\u003d0\u0026amp;\u0026amp;cur.a[2]!\u003d0)\n\t\t\t{\n\t\t\t\tnode B;\n\t\t\t\tfor(int i\u003d0;i\u0026lt;3;i++)\n\t\t\t\t{\n\t\t\t\t\tld RHS \u003d (ld(A.a[i])/ld(cur.a[i]))*ld(cur.a[(i+1)%3]+cur.a[(i+2)%3]) + (ld(A.a[(i+2)%3])/ld(cur.a[i]+cur.a[(i+2)%3]))*ld(cur.a[(i+1)%3]) - A.a[(i+1)%3];\n\t\t\t\t\tld LHS \u003d (ld(cur.a[i]+cur.a[(i+1)%3])/ld(cur.a[i]))*ld(cur.a[(i+1)%3]+cur.a[(i+2)%3]) + (ld(cur.a[(i+2)%3])/ld(cur.a[i]+cur.a[(i+2)%3]))*ld(cur.a[(i+1)%3]);\n\t\t\t\t\tB.a[i] \u003d floor(RHS/LHS);\n\t\t\t\t}\n\t\t\t\tll sum \u003d B.a[0]+B.a[1]+B.a[2];\n\t\t\t\tfor(ll x \u003d -1; x \u0026lt;\u003d 1; x++)\n\t\t\t\t{\n\t\t\t\t\tfor(ll y \u003d -1; y \u0026lt;\u003d 1; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(ll z \u003d -1; z \u0026lt;\u003d 1; z++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(S.find(sum+x+y+z)!\u003dS.end())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnode tmp \u003d create(B.a[0]+x, B.a[1]+y, B.a[2]+z);\n\t\t\t\t\t\t\t\tif(ma[4].find(tmp)!\u003dma[4].end())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(equal(combine(cur, tmp),A))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tcout\u0026lt;\u0026lt;it-\u0026gt;se+ma[4][tmp]\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\t\t\t\t\t\t\t\t\tpos\u003d1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(pos) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(pos) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(pos) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int i\u003d0;i\u0026lt;3;i++)\n\t\t\t\t{\n\t\t\t\t\tif(cur.a[i]\u003d\u003d0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(cur.a[(i+1)%3]\u003d\u003d0||cur.a[(i+2)%3]\u003d\u003d0) //cannot have 2 0s\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnode B;\n\t\t\t\t\t\t\tB.a[i] \u003d A.a[i]/cur.a[(i+1)%3];\n\t\t\t\t\t\t\tB.a[(i+2)%3] \u003d A.a[(i+2)%3]/cur.a[(i+2)%3] - B.a[i];\n\t\t\t\t\t\t\tB.a[(i+1)%3] \u003d bsum - B.a[i] - B.a[(i+2)%3];\n\t\t\t\t\t\t\tif(equal(combine(cur,B),A))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(ma[4].find(B)!\u003dma[4].end())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcout\u0026lt;\u0026lt;it-\u0026gt;se+ma[4][B]\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\t\t\t\t\t\t\t\tpos\u003d1; break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!pos) cout\u0026lt;\u0026lt;\u0026quot;Impossible\\n\u0026quot;;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003eProblem F — Aimai Moko\u003c/h3\u003e\u003cp\u003eLet\u0027s translate the problem into graph theory. The vertices of the graph are the people and there is an edge from vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e if person \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e likes person \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. Then, we have a directed graph where each vertex has outdegree \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, which is also called a functional graph. We can change the outgoing edge of some nodes and our goal is to minimize the number of edges we change so that the resulting graph is a set of disjoint cycles of size \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFirst, we look at the slow but direct solution. Consider a bipartite graph where the left part \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e consists of vertices denoting the boys and right part \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e consists of vertices denoting the girls. For each boy \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and each girl \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, we connect them with an edge with cost \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e likes each other, \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e doesn\u0027t like each other and \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e otherwise (exactly one of them likes the other). The cost on each edge denotes the minimum number of changes we need to perform to make boy \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and girl \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e like each other. Thus, our task reduces to finding the minimum cost perfect matching of the graph.\u003c/p\u003e\u003cp\u003eThis can be solved with minimum cost maximum flow algorithm. Consider a flow graph where there is a directed edge from the source node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e to all boy vertices with capacity \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and cost \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, there is a directed edge from each boy vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to each girl vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e with capacity \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and cost equal to the cost of the original edge, and finally a directed edge from each girl vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e to the sink \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e with capacity \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and cost \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. However, this approach is way too slow for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 500000\u003c/span\u003e and a linear (or almost linear) time solution is required.\u003c/p\u003e\u003cp\u003eThe key is to look at the edges we \u003cstrong\u003edidn\u0027t\u003c/strong\u003e change. The subgraph formed by the edges we did not change will be a union of several directed edges and length-\u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e cycles (i.e. \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/65/2e/652ed4d57e2765a1e9590fe3e40adb9a9cbd2766.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for some pair of vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e). Once we know which edges we shouldn\u0027t change, it is easy to change all the other edges so that the graph becomes a union of length-\u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e cycles. Thus, now our primary focus is to find the maximum number of edges we can remain and determine which edges we should remain.\u003c/p\u003e\u003cp\u003eHow does our graph originally look like? Obviously, we can deal with each weakly connected component individually, so from now on we\u0027ll assume our graph is weakly connected (i.e. if edges are undirected it\u0027ll be connected). In general, a connected functional graph contains a directed cycle (let\u0027s call the vertices on the directed cycle the cycle vertices) and for each cycle vertex, a directed tree spans from it. Here\u0027s an example of how one looks like (red vertices are the cycle vertices)\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/2b/02/2b02df90818dfbdc7c6fa563b055ed7665fd19f2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eNote that all cycle sizes are even in this case since the graph is bipartite (this is not true in general functional graphs).\u003c/p\u003e\u003cp\u003eLet\u0027s make use of this special shape of the graph. Firstly, let\u0027s investigate how to calculate the answer for a directed tree. In fact, we reverse all the edges in the graph so that the edges go from the root to leaves.\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][0]\u003c/span\u003e denote the maximum number of edges you can choose in the subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e assuming \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is not part of any chosen edge and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][1]\u003c/span\u003e is the same thing except now \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is part of a chosen edge. Let the children of vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][0] \u003d \u003ci\u003emax\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e][0], \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e][1]) + \u003ci\u003emax\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e][0], \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e][1]) + ... + \u003ci\u003emax\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e][0], \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e][1])\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTo compute \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][1]\u003c/span\u003e, we will iterate over all children we choose to pair with node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e. If we pair \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, the number of edges we can choose in the subtree is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e][0], \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e][1]) + \u003ci\u003emax\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e][0], \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e][1]) + ... + \u003ci\u003emax\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e][0], \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e][1]) - \u003ci\u003emax\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e][0], \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e][1]) + \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e][0] + 1 \u003d \u003ci\u003edp\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][0] - \u003ci\u003emax\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e][0], \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e][1]) + \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e][0] + 1\u003c/span\u003e. Thus, we just have to compute the values of \u003cspan class\u003d\"tex-span\"\u003e - \u003ci\u003emax\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e][0], \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e][1]) + \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e][0]\u003c/span\u003e and take the maximum then add it to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][0] + 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThus, for a tree we can calculate the answer in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is the number of vertices in the tree.\u003c/p\u003e\u003cp\u003eFor our current graph, let\u0027s do the same thing for each tree rooted at cycle vertices. Let our cycle vertices be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e][0], \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e][1]\u003c/span\u003e denote the number of edges we can choose from the subtree rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is not used and used in some chosen edge in the subtree respectively. These values can be computed in a total of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time.\u003c/p\u003e\u003cp\u003eNow, the question is which edges should we choose from the cycle itself?\u003c/p\u003e\u003cp\u003eFirstly, if the cycle is of size \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e, we claim that both edges in the cycle must be chosen. Suppose not and one of them is paired with some other vertex. Then, we can choose the cycle edge instead of that edge and still get a solution with total number of chosen edges not less than the previous solution. Thus, if the cycle size is \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e, we must choose both cycle edges and the answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][0] + \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e][0] + 2\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e are the edges of this cycle.\u003c/p\u003e\u003cp\u003eOtherwise, we cannot choose \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e adjacent edges of the cycle. We\u0027ll use dynamic programming to handle this again.\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e denote the maximum number of edges we can choose by considering the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e vertices of the cycle, where vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is still \u0026quot;open\u0026quot; if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e \u003d 1\u003c/span\u003e (i.e. it is still unused by any chosen edge and can be connected to the next vertex of the cycle) and \u0026quot;closed\u0026quot; (i.e. it is used by a chosen edge, which can either be a tree edge or the previous cycle edge), and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d 0\u003c/span\u003e if vertex \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e is open and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d 1\u003c/span\u003e otherwise. The state transitions is quite obvious though we need to be careful. The state \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is needed so that at the end we know whether we can add one extra edge from the last vertex of the cycle to the first vertex of the cycle if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e \u003d \u003ci\u003ek\u003c/i\u003e \u003d 1\u003c/span\u003e. This dp also takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time since \u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003ej\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e ≤ 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFinally, we can reconstruct the solution if the store the parent state of each state for the dp values.\u003c/p\u003e\u003cp\u003eThe overall time complexity is linear, i.e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e, which will pass.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSlow solution (Min Cost Flow)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;ll, null_type, less\u0026lt;ll\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;ll\u0026gt;::iterator sit;\ntypedef map\u0026lt;ll,ll\u0026gt;::iterator mit;\n\nstruct Edge{\n    int u, v;\n    long long cap, cost;\n \n    Edge(int _u, int _v, long long _cap, long long _cost){\n        u \u003d _u; v \u003d _v; cap \u003d _cap; cost \u003d _cost;\n    }\n};\n \nstruct MinCostFlow{\n    int n, s, t;\n    long long flow, cost;\n    vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; graph;\n    vector\u0026lt;Edge\u0026gt; e;\n    vector\u0026lt;long long\u0026gt; dist, potential;\n    vector\u0026lt;int\u0026gt; parent;\n    bool negativeCost;\n \n    MinCostFlow(int _n){\n        // 0-based indexing\n        n \u003d _n;\n        graph.assign(n, vector\u0026lt;int\u0026gt; ());\n        negativeCost \u003d false;\n    }\n \n    void addEdge(int u, int v, long long cap, long long cost, bool directed \u003d true){\n        if(cost \u0026lt; 0)\n            negativeCost \u003d true;\n \n        graph[u].push_back(e.size());\n        e.push_back(Edge(u, v, cap, cost));\n \n        graph[v].push_back(e.size());\n        e.push_back(Edge(v, u, 0, -cost));\n \n        if(!directed)\n            addEdge(v, u, cap, cost, true);\n    }\n \n    pair\u0026lt;long long, long long\u0026gt; getMinCostFlow(int _s, int _t){\n        s \u003d _s; t \u003d _t;\n        flow \u003d 0, cost \u003d 0;\n \n        potential.assign(n, 0);\n        if(negativeCost){\n            // run Bellman-Ford to find starting potential\n            dist.assign(n, 1LL\u0026lt;\u0026lt;62);\n            for(int i \u003d 0, relax \u003d false; i \u0026lt; n \u0026amp;\u0026amp; relax; i++, relax \u003d false){\n                for(int u \u003d 0; u \u0026lt; n; u++){\n                    for(int k \u003d 0; k \u0026lt; graph[u].size(); k++){\n                        int eIdx \u003d graph[u][i];\n                        int v \u003d e[eIdx].v; ll cap \u003d e[eIdx].cap, w \u003d e[eIdx].cost;\n \n                        if(dist[v] \u0026gt; dist[u] + w \u0026amp;\u0026amp; cap \u0026gt; 0){\n                            dist[v] \u003d dist[u] + w;\n                            relax \u003d true;\n            }   }   }   }\n \n            for(int i \u003d 0; i \u0026lt; n; i++){\n                if(dist[i] \u0026lt; (1LL\u0026lt;\u0026lt;62)){\n                    potential[i] \u003d dist[i];\n        }   }   }\n \n        while(dijkstra()){\n            flow +\u003d sendFlow(t, 1LL\u0026lt;\u0026lt;62);\n        }\n \n        return make_pair(flow, cost);\n    }\n \n    bool dijkstra(){\n        parent.assign(n, -1);\n        dist.assign(n, 1LL\u0026lt;\u0026lt;62);\n        priority_queue\u0026lt;ii, vector\u0026lt;ii\u0026gt;, greater\u0026lt;ii\u0026gt; \u0026gt; pq;\n \n        dist[s] \u003d 0;\n        pq.push(ii(0, s));\n \n \n        while(!pq.empty()){\n            int u \u003d pq.top().second;\n            long long d \u003d pq.top().first;\n            pq.pop();\n \n            if(d !\u003d dist[u]) continue;\n \n            for(int i \u003d 0; i \u0026lt; graph[u].size(); i++){\n                int eIdx \u003d graph[u][i];\n                int v \u003d e[eIdx].v; ll cap \u003d e[eIdx].cap;\n                ll w \u003d e[eIdx].cost + potential[u] - potential[v];\n \n                if(dist[u] + w \u0026lt; dist[v] \u0026amp;\u0026amp; cap \u0026gt; 0){\n                    dist[v] \u003d dist[u] + w;\n                    parent[v] \u003d eIdx;\n \n                    pq.push(ii(dist[v], v));\n        }   }   }\n \n        // update potential\n        for(int i \u003d 0; i \u0026lt; n; i++){\n            if(dist[i] \u0026lt; (1LL\u0026lt;\u0026lt;62))\n                potential[i] +\u003d dist[i];\n        }\n \n        return dist[t] !\u003d (1LL\u0026lt;\u0026lt;62);\n    }\n \n    long long sendFlow(int v, long long curFlow){\n        if(parent[v] \u003d\u003d -1)\n            return curFlow;\n        int eIdx \u003d parent[v];\n        int u \u003d e[eIdx].u; ll w \u003d e[eIdx].cost;\n \n        long long f \u003d sendFlow(u, min(curFlow, e[eIdx].cap));\n \n        cost +\u003d f*w;\n        e[eIdx].cap -\u003d f;\n        e[eIdx^1].cap +\u003d f;\n \n        return f;\n    }\n};\n\nint a[1000111];\nint b[1000111];\nint match[1000111];\n\nint main()\n{\n\tint n; scanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tscanf(\u0026quot;%d\u0026quot;,a+i); a[i]--;\n\t}\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tscanf(\u0026quot;%d\u0026quot;,b+i); b[i]--;\n\t}\n\tMinCostFlow mcmf(2*n+5); int s\u003d2*n+3; int e\u003d2*n+4;\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tfor(int j\u003d0;j\u0026lt;n;j++)\n\t\t{\n\t\t\tint cost \u003d 0;\n\t\t\tif(b[j]!\u003di) cost++;\n\t\t\tif(a[i]!\u003dj) cost++;\n\t\t\tmcmf.addEdge(i,j+n,1,cost);\n\t\t}\n\t}\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tmcmf.addEdge(s,i,1,0); mcmf.addEdge(i+n,e,1,0);\n\t}\n\tii flow \u003d mcmf.getMinCostFlow(s,e);\n\tprintf(\u0026quot;%d\\n\u0026quot;, flow.se);\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tfor(int j:mcmf.graph[i])\n\t\t{\n\t\t\tint to \u003d mcmf.e[j].v;\n\t\t\tif(to\u0026gt;\u003dn\u0026amp;\u0026amp;to\u0026lt;2*n\u0026amp;\u0026amp;mcmf.e[j].cap\u003d\u003d0)\n\t\t\t{\n\t\t\t\tmatch[i] \u003d to - n;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tif(a[i]\u003d\u003dmatch[i]) a[i]\u003d-1;\n\t\telse a[i]\u003dmatch[i];\n\t}\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tif(b[match[i]]\u003d\u003di) b[match[i]]\u003d-1;\n\t\telse b[match[i]]\u003di;\n\t}\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tprintf(\u0026quot;%d\u0026quot;,a[i]+1);\n\t\tif(i+1\u0026lt;n) printf(\u0026quot; \u0026quot;);\n\t}\n\tprintf(\u0026quot;\\n\u0026quot;);\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tprintf(\u0026quot;%d\u0026quot;,b[i]+1);\n\t\tif(i+1\u0026lt;n) printf(\u0026quot; \u0026quot;);\n\t}\n\tprintf(\u0026quot;\\n\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eAC Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;ll, null_type, less\u0026lt;ll\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;ll\u0026gt;::iterator sit;\ntypedef map\u0026lt;ll,ll\u0026gt;::iterator mit;\n\nconst int N \u003d 500015;\nint a[N];\nint b[N];\nvi adj[2*N];\nint p[2*N];\nvector\u0026lt;vi\u0026gt; cycles;\nint vis[2*N];\nbool oncycle[2*N];\n\nvoid prep1(int u)\n{\n\tvis[u] \u003d 1;\n\tif(vis[p[u]]\u003d\u003d0) prep1(p[u]);\n\telse\n\t{\n\t\tcycles.back().pb(p[u]); \n\t}\n}\n\nvoid prep2(int u)\n{\n\tcycles.back().pb(u); vis[u]\u003d2; oncycle[u]\u003d1;\n\tif(vis[p[u]]!\u003d2) prep2(p[u]);\n}\n\nvoid clrsamecomponent(int u)\n{\n\tvis[u]\u003d3;\n\tfor(int v:adj[u])\n\t{\n\t\tif(vis[v]\u003d\u003d3) continue;\n\t\tclrsamecomponent(v);\n\t}\n}\n\nint dp[2*N][2];\nint dp2[2*N][2][2];\nint par[2*N];\nbool par2[2*N][2][2];\nbool use[2*N][2][2];\nint match[2*N];\nbool usefinal[2*N];\n\nvoid dfs(int u, int p)\n{\n\tint mn \u003d int(1e9); int idx \u003d -1;\n\tfor(int v:adj[u])\n\t{\n\t\tif(v\u003d\u003dp||oncycle[v]) continue;\n\t\tdfs(v,u);\n\t\tdp[u][0] +\u003d max(dp[v][0], dp[v][1]);\n\t\tif(max(dp[v][0], dp[v][1]) - dp[v][0] \u0026lt; mn)\n\t\t{\n\t\t\tmn\u003dmax(dp[v][0],dp[v][1])-dp[v][0];\n\t\t\tidx\u003dv;\n\t\t}\n\t}\n\tdp[u][1] \u003d -int(1e9);\n\tif(idx!\u003d-1)\n\t{\n\t\tdp[u][1] \u003d dp[u][0] - mn + 1;\n\t}\n\tpar[u] \u003d idx;\n}\n\nvector\u0026lt;ii\u0026gt; couples;\n\nvoid add(int x, int y)\n{\n\tcouples.pb(mp(x,y));\n}\n\nvoid dfs2(int u, int p, int c)\n{\n\tif(c\u003d\u003d1)\n\t{\n\t\tassert(par[u]\u0026gt;\u003d0);\n\t\tadd(u, par[u]);\n\t}\n\tfor(int v:adj[u])\n\t{\n\t\tif(v\u003d\u003dp||oncycle[v]) continue;\n\t\tif(c\u003d\u003d0)\n\t\t{\n\t\t\tint id \u003d 0;\n\t\t\tif(dp[v][1]\u0026gt;dp[v][0]) id\u003d1;\n\t\t\tdfs2(v,u,id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint id \u003d 0;\n\t\t\tif(dp[v][1]\u0026gt;dp[v][0]) id\u003d1;\n\t\t\tif(v\u003d\u003dpar[u]) id\u003d0;\n\t\t\tdfs2(v,u,id);\n\t\t}\n\t}\n}\n\nvoid dpcycle(vi \u0026amp;vec)\n{\n\tif(vec.size()\u003d\u003d2)\n\t{\n\t\tadd(vec[0],vec[1]);\n\t\tdfs2(vec[0],-1,0);\n\t\tdfs2(vec[1],-1,0);\n\t\treturn ;\n\t}\n\tint n\u003dvec.size();\n\tdp2[vec[0]][0][0]\u003d-int(1e9);\n\tif(par[vec[0]] !\u003d -1)\n\t{\n\t\tdp2[vec[0]][0][0] \u003d dp[vec[0]][1];\n\t\tuse[vec[0]][0][0] \u003d 1;\n\t}\n\tdp2[vec[0]][0][1] \u003d -int(1e9);\n\tdp2[vec[0]][1][0] \u003d dp2[vec[0]][1][1] \u003d dp[vec[0]][0];\n\tuse[vec[0]][1][0] \u003d use[vec[0]][1][1] \u003d 0;\n\tfor(int i\u003d1;i\u0026lt;n;i++)\n\t{\n\t\tfor(int k\u003d0;k\u0026lt;2;k++)\n\t\t{\n\t\t\t//dp2[i][0][k]\n\t\t\tdp2[vec[i]][0][k] \u003d -int(1e9);\n\t\t\tif(dp2[vec[i-1]][0][k] + dp[vec[i]][1] \u0026gt; dp2[vec[i]][0][k] \u0026amp;\u0026amp; par[vec[i]] !\u003d -1)\n\t\t\t{\n\t\t\t\tdp2[vec[i]][0][k] \u003d dp2[vec[i-1]][0][k] + dp[vec[i]][1];\n\t\t\t\tpar2[vec[i]][0][k] \u003d 0; use[vec[i]][0][k] \u003d 1;\n\t\t\t}\n\t\t\tif(dp2[vec[i-1]][1][k] + dp[vec[i]][1] \u0026gt; dp2[vec[i]][0][k] \u0026amp;\u0026amp; par[vec[i]] !\u003d -1)\n\t\t\t{\n\t\t\t\tdp2[vec[i]][0][k] \u003d dp2[vec[i-1]][1][k] + dp[vec[i]][1];\n\t\t\t\tpar2[vec[i]][0][k] \u003d 1; use[vec[i]][0][k] \u003d 1;\n\t\t\t}\n\t\t\tif(dp2[vec[i-1]][1][k] + 1 + dp[vec[i]][0] \u0026gt; dp2[vec[i]][0][k] \u0026amp;\u0026amp; !(i \u003d\u003d 1 \u0026amp;\u0026amp; k \u003d\u003d 1))\n\t\t\t{\n\t\t\t\tdp2[vec[i]][0][k] \u003d dp2[vec[i-1]][1][k] + 1 + dp[vec[i]][0];\n\t\t\t\tpar2[vec[i]][0][k] \u003d 1; use[vec[i]][0][k] \u003d 0;\n\t\t\t}\n\t\t\t//dp2[i][1][k]\n\t\t\tdp2[vec[i]][1][k] \u003d dp2[vec[i-1]][0][k] + dp[vec[i]][0]; par2[vec[i]][1][k] \u003d 0;\n\t\t\tif(dp2[vec[i-1]][1][k] + dp[vec[i]][0] \u0026gt; dp2[vec[i]][1][k])\n\t\t\t{\n\t\t\t\tdp2[vec[i]][1][k] \u003d dp2[vec[i-1]][1][k] + dp[vec[i]][0];\n\t\t\t\tpar2[vec[i]][1][k] \u003d 1;\n\t\t\t}\n\t\t\tuse[vec[i]][1][k] \u003d 0;\n\t\t}\n\t}\n\tii bestres \u003d mp(0,0); int ans \u003d -1101;\n\tfor(int i\u003d0;i\u0026lt;2;i++)\n\t{\n\t\tfor(int j\u003d0;j\u0026lt;2;j++)\n\t\t{\n\t\t\tint val\u003ddp2[vec[n-1]][i][j];\n\t\t\tif(i\u003d\u003d1\u0026amp;\u0026amp;j\u003d\u003d1) val++;\n\t\t\tif(val\u0026gt;ans)\n\t\t\t{\n\t\t\t\tans\u003dval; bestres\u003dmp(i,j);\n\t\t\t}\n\t\t}\n\t}\n\tint j \u003d bestres.fi; int k \u003d bestres.se;\n\tint pos \u003d (j\u003d\u003d1\u0026amp;\u0026amp;k\u003d\u003d1?1:0);\n\tfor(int i \u003d n - 1; i \u0026gt;\u003d 0; i--)\n\t{\n\t\tusefinal[vec[i]] \u003d use[vec[i]][j][k];\n\t\tdfs2(vec[i], -1, usefinal[vec[i]]);\n\t\tj \u003d par2[vec[i]][j][k];\n\t}\n\tif(pos)\n\t{\n\t\tadd(vec[n-1],vec[0]); usefinal[vec[n-1]]\u003dusefinal[vec[0]]\u003d1;\n\t\tfor(int i\u003d1;i\u0026lt;\u003dn-2;i++)\n\t\t{\n\t\t\tif(!usefinal[vec[i]]\u0026amp;\u0026amp;!usefinal[vec[i+1]])\n\t\t\t{\n\t\t\t\tadd(vec[i],vec[i+1]);\n\t\t\t\tusefinal[vec[i]]\u003dusefinal[vec[i+1]]\u003d1;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(int i\u003d0;i\u0026lt;n-1;i++)\n\t\t{\n\t\t\tif(!usefinal[vec[i]]\u0026amp;\u0026amp;!usefinal[vec[i+1]])\n\t\t\t{\n\t\t\t\tadd(vec[i],vec[i+1]);\n\t\t\t\tusefinal[vec[i]]\u003dusefinal[vec[i+1]]\u003d1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n; scanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tscanf(\u0026quot;%d\u0026quot;,a+i); a[i]--; adj[a[i]+n].pb(i);\n\t\tp[i] \u003d a[i] + n;\n\t}\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tscanf(\u0026quot;%d\u0026quot;,b+i); b[i]--; adj[b[i]].pb(i+n);\n\t\tp[n + i] \u003d b[i];\n\t}\n\tfor(int i\u003d0;i\u0026lt;2*n;i++)\n\t{\n\t\tif(vis[i]\u003d\u003d0)\n\t\t{\n\t\t\tcycles.pb(vi());\n\t\t\tprep1(i);\n\t\t\tint u \u003d cycles.back().front(); cycles.back().clear();\n\t\t\tprep2(u);\n\t\t\tclrsamecomponent(u);\n\t\t}\n\t}\n\tfor(int i\u003d0;i\u0026lt;cycles.size();i++)\n\t{\n\t\tfor(int v:cycles[i])\n\t\t{\n\t\t\tdfs(v,-1);\n\t\t}\n\t\tdpcycle(cycles[i]);\n\t}\n\t\n\tvi boys,girls;\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i\u003d0;i\u0026lt;couples.size();i++)\n\t{\n\t\tvis[couples[i].fi]\u003d1; vis[couples[i].se]\u003d1;\n\t\tmatch[couples[i].fi]\u003dcouples[i].se; match[couples[i].se]\u003dcouples[i].fi;\n\t}\n\tfor(int i\u003d0;i\u0026lt;2*n;i++)\n\t{\n\t\tif(!vis[i])\n\t\t{\n\t\t\tif(i\u0026lt;n) boys.pb(i);\n\t\t\telse girls.pb(i);\n\t\t}\n\t}\n\tassert(boys.size()\u003d\u003dgirls.size());\n\tfor(int i\u003d0;i\u0026lt;boys.size();i++)\n\t{\n\t\tmatch[boys[i]]\u003dgirls[i]; match[girls[i]]\u003dboys[i];\n\t}\n\tint cnt\u003d0;\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tif(a[i]\u003d\u003dmatch[i]-n) a[i]\u003d-1;\n\t\telse {a[i]\u003dmatch[i]-n; cnt++;}\n\t}\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tif(b[i]\u003d\u003dmatch[i+n]) b[i]\u003d-1;\n\t\telse {b[i]\u003dmatch[i+n]; cnt++;}\n\t}\n\tprintf(\u0026quot;%d\\n\u0026quot;, cnt);\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tprintf(\u0026quot;%d\u0026quot;,a[i]+1);\n\t\tif(i+1\u0026lt;n) printf(\u0026quot; \u0026quot;);\n\t}\n\tprintf(\u0026quot;\\n\u0026quot;);\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tprintf(\u0026quot;%d\u0026quot;,b[i]+1);\n\t\tif(i+1\u0026lt;n) printf(\u0026quot; \u0026quot;);\n\t}\n\tprintf(\u0026quot;\\n\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}