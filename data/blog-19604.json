{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1438803010,"rating":73,"authorHandle":"Vovuh","modificationTimeSeconds":1438973368,"id":19604,"title":"\u003cp\u003eEditorial Codeforces Round #Pi\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/567/problem/A\" title\u003d\"Codeforces Round Pi (Div. 2)\"\u003e567A - Lineland Mail\u003c/a\u003e\u003c/p\u003e\u003cp\u003eOne can notice that the maximum cost of sending a letter from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e\u0027th city is equal to maximum of distances from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e\u0027th city to first city and from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e\u0027th city to last (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(\u003ci\u003eabs\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e), \u003ci\u003eabs\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e)\u003c/span\u003e). On the other hand, the minimum cost of sending a letter will be the minimum of distances between neighboring cities (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/span\u003e\u0027th and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e\u0027th cities), more formally, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003eabs\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e), \u003ci\u003eabs\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e)\u003c/span\u003e. For each city, except the first and the last this formula is correct, but for them formulas are (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eabs\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e)\u003c/span\u003e) and (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eabs\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e)\u003c/span\u003e) respectively.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://gist.github.com/VladimirPetrov/ad0ecbd0e81a578d7797\"\u003eAuthor solution\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/567/problem/B\" title\u003d\"Codeforces Round Pi (Div. 2)\"\u003e567B - Berland National Library\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTo answer the queries correct, we need to know if the person is still in the library. For that purpose we will use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ein\u003c/i\u003e\u003c/span\u003e array of type \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebool\u003c/i\u003e\u003c/span\u003e. Also we will store two variables for the answer and \u0027\u0027current state\u0027\u0027 (it will store the current number of people in the library). Let\u0027s call them \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estate\u003c/i\u003e\u003c/span\u003e respectively.\u003c/p\u003e\u003cp\u003eThus, if we are given query \u003cspan class\u003d\"tex-span\"\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e then we should increase \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estate\u003c/i\u003e\u003c/span\u003e by one, mark that this person entered the library (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ein\u003c/i\u003e[\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e] \u003d \u003ci\u003etrue\u003c/i\u003e\u003c/span\u003e) and try to update the answer (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e \u003d \u003ci\u003emax\u003c/i\u003e(\u003ci\u003eans\u003c/i\u003e, \u003ci\u003estate\u003c/i\u003e)\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eOtherwise we are given \u003cspan class\u003d\"tex-span\"\u003e - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e query. If the person who leaves the library, was in there, we should just decrease \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estate\u003c/i\u003e\u003c/span\u003e by one. Otherwise, if this person was not in the library (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ein\u003c/i\u003e[\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e]\u003c/span\u003e \u003d\u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efalse\u003c/i\u003e\u003c/span\u003e) and leaves now, he entered the library before we started counting. It means we should increase the answer by one anyway. Also one should not forget that it is needed to mark that the person has left the library (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ein\u003c/i\u003e[\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e] \u003d \u003ci\u003efalse\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://gist.github.com/VladimirPetrov/674625f2f04c58b0e01f\"\u003eAuthor solution\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/567/problem/C\" title\u003d\"Codeforces Round Pi (Div. 2)\"\u003e567C - Geometric Progression\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s solve this problem for fixed middle element of progression. This means that if we fix element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e then the progression must consist of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e / \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e·\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e elements. It could not be possible, for example, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is not divisible by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e (\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ae/f6/aef67114ef7c483700f6c65c02b8de0ab0a76f25.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e).\u003c/p\u003e\u003cp\u003eFor fixed middle element one could find the number of sequences by counting how many \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e / \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e elements are placed left from fixed element and how many \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e·\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e are placed right from it, and then multiplying this numbers. To do this, one could use two associative arrays \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, where for each key \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e will be stored count of occurences of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e placed left (or right respectively) from current element. This could be done with map structure.\u003c/p\u003e\u003cp\u003eSum of values calculated as described above will give the answer to the problem.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://gist.github.com/VladimirPetrov/56d8658a4b6fdc10ccdc\"\u003eAuthor solution\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/567/problem/D\" title\u003d\"Codeforces Round Pi (Div. 2)\"\u003e567D - One-Dimensional Battle Ships\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst, we should understand when the game ends. It will happen when on the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e-sized board it will be impossible to place \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e ships of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. For segment with length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e we could count the maximum number of ships with size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e that could be placed on it. Each ship occupies \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + 1\u003c/span\u003e cells, except the last ship. Thus, for segment with length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e the formula will look like \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e5/87/e5872cd1defba236eeb517daa97051ce20cf40c5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (we add \u0026quot;fictive\u0026quot; cell to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/span\u003e cells to consider the last ship cell). This way, for \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e..\u003ci\u003er\u003c/i\u003e]\u003c/span\u003e segment the formula should be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/da/ab/daabfbc41456dfe3fc74f8b0eba284b1893a8abd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. \u003c/p\u003e\u003cp\u003eFor solving the problem we should store all the \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e..\u003ci\u003er\u003c/i\u003e]\u003c/span\u003e segments which has no \u0027\u0027free\u0027\u0027 cells (none of them was shooted). One could use (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estd\u003c/i\u003e: : \u003ci\u003eset\u003c/i\u003e\u003c/span\u003e) for that purpose. This way, before the shooting, there will be only one segment \u003cspan class\u003d\"tex-span\"\u003e[1..\u003ci\u003en\u003c/i\u003e]\u003c/span\u003e. Also we will store current maximum number of ships we could place on a board. Before the shooting it is equal to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a6/c5/a6c5007020e1975d1a655bfaca4a944c86eec25c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eWith every shoot in cell \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e we should find the segment containing shooted cell (let it be \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e..\u003ci\u003er\u003c/i\u003e]\u003c/span\u003e), we should update segment set. First, we should delete \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e..\u003ci\u003er\u003c/i\u003e]\u003c/span\u003e segment. It means we should decrease current maximum number of ships by \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/da/ab/daabfbc41456dfe3fc74f8b0eba284b1893a8abd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and delete it from the set. Next, we need to add segments \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e..\u003ci\u003ex\u003c/i\u003e - 1]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ex\u003c/i\u003e + 1..\u003ci\u003er\u003c/i\u003e]\u003c/span\u003e to the set (they may not be correct, so you may need to add only one segments or do not add segments at all) and update the maximum number of ships properly. We should process shoots one by one, and when the maximum number of ships will become lesser than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, we must output the answer. If that never happen, output \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://gist.github.com/VladimirPetrov/2252707a88b7e2a5bac0\"\u003eAuthor solution\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/567/problem/E\" title\u003d\"Codeforces Round Pi (Div. 2)\"\u003e567E - President and Roads\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAt first, let\u0027s find edges that do not belong to any shortest paths from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e. Let\u0027s find two shortest path arrays \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e2\u003c/span\u003e with any shortest-path-finding algorithm. First array stores shortest path length from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, and the second — from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e. Edge \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e then will be on at least one shortest path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e if and only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e1[\u003ci\u003eu\u003c/i\u003e] + \u003ci\u003ew\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e) + \u003ci\u003ed\u003c/i\u003e2[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e \u003d\u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e1[\u003ci\u003et\u003c/i\u003e]\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLet\u0027s build shortest path graph, leaving only edges described above. If we consider shortest path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e as segment \u003cspan class\u003d\"tex-span\"\u003e[0..\u003ci\u003eD\u003c/i\u003e]\u003c/span\u003e and any edge \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e in shortest path graph as its subsegment \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ed\u003c/i\u003e1[\u003ci\u003eu\u003c/i\u003e]..\u003ci\u003ed\u003c/i\u003e1[\u003ci\u003ev\u003c/i\u003e]]\u003c/span\u003e, then if such subsegment do not share any common point with any other edge subsegment, except its leftest and rightest point (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e1[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e1[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e), this edge belongs to every shortest path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow we could surely answer \u0026quot;YES\u0026quot; to such edges. Next part of the solution are much simple. If edge \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e do not belong to every shortest path, we could try decrease its weight. This edge will belong to every shortest path if and only if its weight will become \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e1[\u003ci\u003et\u003c/i\u003e] - \u003ci\u003ed\u003c/i\u003e1[\u003ci\u003eu\u003c/i\u003e] - \u003ci\u003ed\u003c/i\u003e2[\u003ci\u003ev\u003c/i\u003e] - 1\u003c/span\u003e. So, if this value are strictly positive, we should answer \u0026quot;CAN\u0026quot; considering new edge weight. Otherwise we need to output \u0026quot;NO\u0026quot;.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://gist.github.com/VladimirPetrov/8959714d184aad14c44d\"\u003eAuthor solution\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/567/problem/F\" title\u003d\"Codeforces Round Pi (Div. 2)\"\u003e567F - Mausoleum\u003c/a\u003e\u003c/p\u003e\u003cp\u003eConsider that we are placing blocks by pairs, one pair by one, starting from leftmost and rightmost places. Thus, for example, two blocks of height 1 we could place in positions 1 and 2, 1 and \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, or \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. The segment of unused positions will be changed that way and the next block pairs should be placed on new leftmost and rightmost free places. At last only two positions will be free and we should place two blocks of height \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e on them.\u003c/p\u003e\u003cp\u003eAny correct sequence of blocks could be builded that way. Let\u0027s try to review the requirements consider such way of placing blocks. As soon as we place blocks one by one, the requirements are now only describes the order of placing blocks. For example, requirement \u0027\u00273 \u0026gt;\u003d 5\u0027\u0027 means that we should place block in position 3 only if block in position 5 is already placed (and thus it have lesser height), or we place pair of blocks of same height on them at one moment.\u003c/p\u003e\u003cp\u003eFor counting required number of sequences we will use dynamic programming approach. Let\u0027s count \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e][\u003ci\u003er\u003c/i\u003e]\u003c/span\u003e — the number of ways to place some blocks in the way that only positions at segment \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e..\u003ci\u003er\u003c/i\u003e]\u003c/span\u003e are free. The height of current placed pair of blocks is counted from the segment borders itself (\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5e/46/5e46d94595752fbb0a0d3921dca9236d55d4c9fb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Fix one way of placing current block pair (exclusion is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d  \u003d \u003ci\u003er\u003c/i\u003e + 1\u003c/span\u003e). Now check if such placing meets the requirements. We will consider only requirements that meets one of the current-placing positions. For every \u0026quot;current\u0026quot; position \u0026quot;\u0026lt;\u0026quot; must be true only for free positions (positions in \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e..\u003ci\u003er\u003c/i\u003e]\u003c/span\u003e, which do not equal to current positions), \u0026quot;\u0026gt;\u0026quot; must be true for already-placed positions (out of \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e..\u003ci\u003er\u003c/i\u003e]\u003c/span\u003e) and \u0026quot;\u003d\u0026quot; must be true only for second current position.\u003c/p\u003e\u003cp\u003eThis DP could be easily calculated using \u0026quot;lazy\u0026quot; approach.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://gist.github.com/VladimirPetrov/47252bb8e5af4117da3c\"\u003eAuthor solution\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["codeforces","round","314","pi"]}}