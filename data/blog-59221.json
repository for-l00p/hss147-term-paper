{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1525338050,"rating":6,"authorHandle":"Hyeokshin","modificationTimeSeconds":1525338050,"id":59221,"title":"\u003cp\u003eDFS using adjacency lists much slower than using a C++ vector?\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eTrying to solve \u003ca href\u003d\"//codeforces.com/contest/862/problem/B\"\u003e862B\u003c/a\u003e about the maximum number of edges one can add to a certain tree so that it\u0027s still a bipartite graph. I went with the \u0026quot;let\u0027s code everything ourselves\u0026quot; approach and limited myself to C. Here\u0027s my code.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e    #define _CRT_SECURE_NO_WARNINGS\n     \n    #include \u0026lt;stdio.h\u0026gt;\n    #include \u0026lt;stdlib.h\u0026gt;\n     \n    typedef struct adjNode {\n    \tint v;\n    \tstruct adjNode *next;\n    }adjNode;\n     \n    adjNode **Adj;\n     \n    typedef struct vInfo {\n    \tint visited;\n    \tint parent;\n    \tint set;\n    }vInfo;\n     \n    vInfo *Info;\n    int n;\n    int visited \u003d 0;\n    long long setN[2] \u003d { 1, 0 };\n     \n    void dfs(int u);\n    void insertEdge(int v1, int v2);\n    void initInfo();\n     \n    int main(void) {\n    \tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    \tAdj \u003d calloc((n + 1), sizeof(struct adjNode *));\n    \tInfo \u003d malloc((n + 1) * sizeof(struct vInfo));\n     \n    \tinitInfo();\n    \tint v1, v2;\n    \tfor (size_t i \u003d 1; i \u0026lt; n; i++)\n    \t{\n    \t\tscanf(\u0026quot;%d %d\u0026quot;, \u0026amp;v1, \u0026amp;v2);\n    \t\tinsertEdge(v1, v2);\n    \t}\n     \n    \tdfs(1);\n    \tfinish();\n    }\n     \n    void dfs(int u) {\n    \tInfo[u].visited \u003d 1;\n    \tvisited++;\n     \n    \tfor (adjNode *vAdj \u003d Adj[u]; vAdj !\u003d NULL; vAdj \u003d vAdj-\u0026gt;next)\n    \t{\n    \t\tif (!Info[vAdj-\u0026gt;v].visited)\n    \t\t{\n    \t\t\tInfo[vAdj-\u0026gt;v].parent \u003d u;\n    \t\t\tInfo[vAdj-\u0026gt;v].set \u003d 1 - Info[u].set;\n    \t\t\tsetN[Info[vAdj-\u0026gt;v].set]++;\n    \t\t\tdfs(vAdj-\u0026gt;v);\n    \t\t\tif (visited \u003d\u003d n)\n    \t\t\t{\n    \t\t\t\tfinish();\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n     \n    void insertEdge(int v1, int v2) {\n    \tadjNode *v1v2 \u003d malloc(sizeof(struct adjNode));\n    \tv1v2-\u0026gt;next \u003d NULL;\n    \tv1v2-\u0026gt;v \u003d v2;\n    \tadjNode *v2v1 \u003d malloc(sizeof(struct adjNode));\n    \tv2v1-\u0026gt;next \u003d NULL;\n    \tv2v1-\u0026gt;v \u003d v1;\n     \n    \tadjNode *iter;\n    \tif (Adj[v1] \u003d\u003d NULL)\n    \t\tAdj[v1] \u003d v1v2;\n    \telse {\n    \t\tfor (iter \u003d Adj[v1]; iter-\u0026gt;next !\u003d NULL; iter \u003d iter-\u0026gt;next);\n    \t\titer-\u0026gt;next \u003d v1v2;\n    \t}\n     \n    \tif (Adj[v2] \u003d\u003d NULL)\n    \t\tAdj[v2] \u003d v2v1;\n    \telse {\n    \t\tfor (iter \u003d Adj[v2]; iter-\u0026gt;next !\u003d NULL; iter \u003d iter-\u0026gt;next);\n    \t\titer-\u0026gt;next \u003d v2v1;\n    \t}\n    }\n     \n    void initInfo() {\n    \tfor (size_t i \u003d 1; i \u0026lt;\u003d n; i++)\n    \t{\n    \t\tInfo[i].visited \u003d 0;\n    \t\tInfo[i].parent \u003d -1;\n    \t\tInfo[i].set \u003d 0;\n    \t}\n    }\n     \n    void finish() {\n    \tprintf(\u0026quot;%lld\u0026quot;, setN[0] * setN[1] - (n - 1));\n    \texit(0);\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eI looked at others\u0027 submissions and they used similar approaches but almost all of them used the vector class in C++. My code works fine on most tests including ones with n \u003d 100k, running them in \u0026lt;50 ms, but then there\u0027s a test where one node has loads of edges and it times out at \u0026gt;2000 ms. Why? Even if you use a vector, the amount of recursive calls should still be the same, which should be the limiting factor here in terms of speed, right? Do I have an infinite loop?\u003c/p\u003e\u003c/div\u003e","tags":["dfs","vector","dfs and similar"]}}