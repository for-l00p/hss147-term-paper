{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1470848673,"rating":41,"authorHandle":"JoudZouzou","modificationTimeSeconds":1471262426,"id":46494,"title":"\u003cp\u003e[Gym Contest Editorial] HIAST Collegiate Programming Contest 2016\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eCards\u003c/h2\u003e\u003cp\u003eWe notice that the second box includes only even numbers , because all numbers in it are in the form \u003ccode\u003e2X\u003c/code\u003e \u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eif the number is odd it\u0027s obviously in the first box .\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eif the number \u003ccode\u003eX\u003c/code\u003e is even then \u003ccode\u003eX\u003c/code\u003e and \u003ccode\u003eX/2\u003c/code\u003e will not be in the same box . \u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSo we can keep dividing the number on 2 until we get an odd number which is obviously in the first box, After that we can easily compute the answer depending on how many times we divided the number until it became odd . \u003c/p\u003e\u003cp\u003eTotal Complexity: \u003cstrong\u003eO(log(Q))\u003c/strong\u003e\u003cbr /\u003eProblem by: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/AHMED_GAFER\" title\u003d\"Expert AHMED_GAFER\"\u003eAHMED_GAFER\u003c/a\u003e\u003c/p\u003e\u003ch2\u003eRGB plants\u003c/h2\u003e\u003cp\u003eSince \u003ccode\u003en\u003c/code\u003e is very large, we have to find a fast way to calculate the answer.\u003c/p\u003e\u003cp\u003eWe can notice that after each day, we can calculate the number of each one of the flowers \u003ccode\u003eNew\u003c/code\u003e, based on the number of the flowers on the day before \u003ccode\u003eOld\u003c/code\u003e, like the following:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eThe number of red flowers would be equal to \u003ccode\u003eNewRed \u003d OldRed*1 + OldGreen*4 + OldBlue*7\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThe number of green flowers would be equal to \u003ccode\u003eNewGreen \u003d OldRed*2 + OldGreen*5 + OldBlue*8\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThe number of blue flowers would be equal to \u003ccode\u003eNewBlue \u003d OldRed*3 + OldGreen*6 + OldBlue*9\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThis can be done using fast matrix multiplication, where both base and transition matrices would be of size \u003cstrong\u003e3x3\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eTotal Complexity: \u003cstrong\u003eO(Log(n))\u003c/strong\u003e.\u003cbr /\u003eProblem by: Ali Hasan\u003c/p\u003e\u003ch2\u003eRamzi\u003c/h2\u003e\u003cp\u003eThis is a simple Floyd-Warshall problem. For each edge, store a pair of integers \u003ccode\u003e(walking distance,total distance)\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eFor car roads, \u003ccode\u003ewalking distance \u003d 0,total distance \u003d length of edge\u003c/code\u003e \u003c/p\u003e\u003cp\u003eFor pedestrian roads, \u003ccode\u003ewalking distance \u003d total distance \u003d length of edge\u003c/code\u003e \u003c/p\u003e\u003cp\u003eNow perform Floyd-Warshall on these pairs: \u003c/p\u003e \u003cpre\u003e\u003ccode\u003epair\u0026lt;int, int\u0026gt; operator+(pair\u0026lt;int, int\u0026gt; A, pair\u0026lt;int, int\u0026gt; B) {\n    return make_pair(A.first + B.first, A.second + B.second);\n}\nint n;\npair\u0026lt;int,int\u0026gt; b[1001][1001];\nvoid floyd() {\n    for (int k \u003d 1; k \u0026lt;\u003d n; k++)\n        for (int i \u003d 1; i \u0026lt;\u003d n; i++)\n            for (int j \u003d 1; j \u0026lt;\u003d n; j++)\n                b[i][j] \u003d min(b[i][j], b[i][k] + b[k][j]);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt can also be solved with Dijkstra, but the constraints allow Floyd-Warshall, and it is easier to code.\u003cbr /\u003eTotal Complexity: \u003cstrong\u003eO(n^3)\u003c/strong\u003e (Floyd) or \u003cstrong\u003eO(n*log(n)+m)\u003c/strong\u003e (Dijkstra)\u003cbr /\u003eProblem by: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/muaz-32\" title\u003d\"Expert muaz-32\"\u003emuaz-32\u003c/a\u003e \u003c/p\u003e\u003ch2\u003eMax or Min .. that is the question!\u003c/h2\u003e\u003cp\u003eThe answer is the product of the biggest two numbers :D\u003cbr /\u003eTotal Complexity: \u003cstrong\u003eO(1)\u003c/strong\u003e\u003cbr /\u003eProblem by: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/muaz-32\" title\u003d\"Expert muaz-32\"\u003emuaz-32\u003c/a\u003e \u003c/p\u003e\u003ch2\u003ePlaying with numbers\u003c/h2\u003e\u003ch4\u003eFirst solution\u003c/h4\u003e\u003cp\u003eIf we were asked to find the smallest number by deleting only one number , we will find the first digit which is greater than the digit to the right of it and delete it, or delete the right most digit if there is no such digit. \u003c/p\u003e\u003cp\u003eBy deleting K digits we can repeat the above process K times but this will give TLE, By using a stack we can solve it in \u003ccode\u003eO(n)\u003c/code\u003e where the stack contains the non deleted digits to the left of the current digit.\u003cbr /\u003eStarting from first digit where the stack is empty , we will keep deleting digits from top of the stack while the top of stack is bigger than the current digit and we can delete more digits , after that we push current digit to the stack and move to the next one . \u003c/p\u003e\u003cp\u003eNow the final result is in the stack ( from bottom to top) . \u003c/p\u003e\u003cp\u003ehere is a c++ small code : \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e        string S;\n\tint K;\n\tstack\u0026lt;char\u0026gt; Stack; \n\tfor (int i \u003d 0; i \u0026lt; S.size(); i++){\n\t\twhile (!Stack.empty() \u0026amp;\u0026amp; K \u0026gt; 0 \u0026amp;\u0026amp; S[i] \u0026lt; Stack.top()){\n\t\t\tStack.pop();\n\t\t\tK--;\n\t\t}\n\t\tStack.push(S[i]);\n\t}\n        while(k--)\n                Stack.pop();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003erepeat a similar process to find the biggest number . \u003c/p\u003e\u003ch4\u003eSecond solution\u003c/h4\u003e\u003cp\u003eDeleting \u003ccode\u003eN\u003c/code\u003e digits from \u003ccode\u003eS\u003c/code\u003e can be also understood as keeping \u003ccode\u003elen - N\u003c/code\u003e digits from the number \u003ccode\u003eS\u003c/code\u003e, where \u003ccode\u003elen\u003c/code\u003e is the length of the number \u003ccode\u003eS\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eLet\u0027s calculate an array \u003ccode\u003ecnt[i][j]\u003c/code\u003e which represents the last appearance of the digit \u003ccode\u003ei\u003c/code\u003e after the position \u003ccode\u003ej\u003c/code\u003e. This array can be calculated using simple dynamic approach.\u003c/p\u003e\u003cp\u003eThe maximum number can be obtained using the following approach: Let\u0027s iterate over the digits of the number \u003ccode\u003eS\u003c/code\u003e from left to right, taking as many \u003cstrong\u003e9\u003c/strong\u003e\u0027s as we can, and skipping other digits. When we can\u0027t take any more \u003cstrong\u003e9\u003c/strong\u003e\u0027s (either because there is no more \u003cstrong\u003e9\u003c/strong\u003e\u0027s, or because taking the next \u003cstrong\u003e9\u003c/strong\u003e would result in a string with length less than \u003ccode\u003elen - N\u003c/code\u003e), let\u0027s start taking as many \u003cstrong\u003e8\u003c/strong\u003e\u0027s as we can in the same manner, and so on.\u003c/p\u003e\u003cp\u003eThe minimum number can be obtained using a similar approach: Let\u0027s iterate over the digits of the number \u003ccode\u003eS\u003c/code\u003e from left to right, taking as many \u003cstrong\u003e0\u003c/strong\u003e\u0027s as we can, and skipping other digits. When we can\u0027t take any more \u003cstrong\u003e0\u003c/strong\u003e\u0027s (either because there is no more \u003cstrong\u003e0\u003c/strong\u003e\u0027s, or because taking the next \u003cstrong\u003e0\u003c/strong\u003e would result in a string with length less than \u003ccode\u003elen - N\u003c/code\u003e), let\u0027s start taking as many \u003cstrong\u003e1\u003c/strong\u003e\u0027s as we can in the same manner, and so on.\u003c/p\u003e\u003cp\u003eTotal Complexity: \u003cstrong\u003eO(length(S))\u003c/strong\u003e.\u003cbr /\u003eProblem by: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/AHMED_GAFER\" title\u003d\"Expert AHMED_GAFER\"\u003eAHMED_GAFER\u003c/a\u003e \u003c/p\u003e\u003ch2\u003eFairness\u003c/h2\u003e\u003cp\u003eLet \u003ccode\u003eDP[i][j]\u003c/code\u003e be the minimum possible unfairness factor after distributing the first \u003ccode\u003ei\u003c/code\u003e coins, while the current difference between the sum of Dwik\u0027s and Samir\u0027s coins is \u003ccode\u003ej\u003c/code\u003e.\u003cbr /\u003eSince j might be negative, Add M to all differences. (M is the maximum possible difference).\u003cbr /\u003eAt each step, you can either give the next coin to the Samir or to Dwik.\u003cbr /\u003eIf you give it to Samir, the difference will increase by \u003ccode\u003ea[i+1]\u003c/code\u003e. Otherwise it will decrease by \u003ccode\u003ea[i+1]\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eAnd the unfairness value would be \u003ccode\u003emax(maximum difference so far,current difference)\u003c/code\u003e \u003c/p\u003e\u003cp\u003e\u003ccode\u003eDP[0][M]\u003d0\u003c/code\u003e \u003c/p\u003e\u003cp\u003e\u003ccode\u003eDP[i+1][j+a[i+1]]\u003dmin(DP[i+1][j+a[i+1]],max(DP[i][j],abs(j+a[i+1]-M)))\u003c/code\u003e \u003c/p\u003e\u003cp\u003e\u003ccode\u003eDP[i+1][j-a[i+1]]\u003dmin(DP[i+1][j-a[i+1]],max(DP[i][j],abs(j-a[i+1]-M)))\u003c/code\u003e \u003c/p\u003e\u003cp\u003eTotal Complexity: \u003cstrong\u003eO(n*M)\u003c/strong\u003e \u003c/p\u003e\u003cp\u003eNote: With these constraints, it would be enough to consider that \u003ccode\u003eM\u003c/code\u003e equals the sum of all coins. \u003c/p\u003e\u003cp\u003eHowever, you can prove that the difference will never be more than the maximum coin. (If giving the coin to one of the kids will make the difference more than the maximum coin, you can give it to the other kid and guarantee a difference less than or equal to the maximum coin). \u003c/p\u003e\u003cp\u003eProblem by: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/AHMED_GAFER\" title\u003d\"Expert AHMED_GAFER\"\u003eAHMED_GAFER\u003c/a\u003e \u003c/p\u003e\u003ch2\u003eRepeat it\u003c/h2\u003e\u003ch4\u003eFirst Solution\u003c/h4\u003e\u003cp\u003eIf we started with \u003ccode\u003eN\u003c/code\u003e , Adding \u0027N\u0027 to the right of it means adding \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e * 10\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e, then to add another N we should add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e * 10\u003csup class\u003d\"upper-index\"\u003e(\u003ci\u003elen\u003c/i\u003e * 2)\u003c/sup\u003e\u003c/span\u003e and so on .. \u003c/p\u003e\u003cp\u003eIt\u0027s easy to see that the final number is equal to : \u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/fa/d7/fad7aa23754cdc2029b36cd62d458a75ef07f4e7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003ch4\u003eSecond solution\u003c/h4\u003e\u003cp\u003eWe can notice that the answer can be calculated on \u003ccode\u003eM\u003c/code\u003e steps.\u003c/p\u003e\u003cp\u003eOn the first step for example the answer would be \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eN\u003c/i\u003e * 10\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003elen\u003c/i\u003e\u003c/sup\u003e + \u003ci\u003eN\u003c/i\u003e)%10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e + 7\u003c/span\u003e, where \u003ccode\u003elen\u003c/code\u003e is the length of the number \u003ccode\u003eN\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eUsing this we can solve the problem with fast matrix multiplication.\u003c/p\u003e\u003cp\u003eTotal Complexity: \u003cstrong\u003eO(Log(M))\u003c/strong\u003e. \u003c/p\u003e\u003cp\u003eProblem by: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/spiral_out\" title\u003d\"Candidate Master spiral_out\"\u003espiral_out\u003c/a\u003e \u003c/p\u003e\u003ch2\u003eRobocon Club\u003c/h2\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003elet\u0027s convert the revolution speed to linear speed by multiplying \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e , \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e2 * π * \u003ci\u003eR\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eit can be proven that the linear speed of the center is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/sub\u003e \u003d (\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e) / 2\u003c/span\u003e \u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eif \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e then the robot is moving forward in a straight line and the coordinates of the center will be \u003cspan class\u003d\"tex-span\"\u003e(0, \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e * \u003ci\u003es\u003c/i\u003e)\u003c/span\u003e \u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eif \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e ≠ \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e then it can be proven that the robot is moving around a point in a circular path , if we know the coordinates of this point we can compute the new coordinate of the center by rotating it around this point. \u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eDraw a vector of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e(0, \u003ci\u003eL\u003c/i\u003e)\u003c/span\u003e (right wheel point ) facing positive \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e axis (because the speed is positive), and another one of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e(0,  - \u003ci\u003eL\u003c/i\u003e)\u003c/span\u003e (left wheel point ) facing positive \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e axis, then draw a line that passes from the ends of these two vectors , it will intersect with the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e axis in a point which is the center of the circular path of the robot , it is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c1/b9/c1b9435db6d0a8395c51a7493b2df20f5329e59a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e let it be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e . \u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eNow rotate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(0, 0)\u003c/span\u003e (the center of the robot ) around \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e by angle \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e degrees clockwise if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e \u0026gt; \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e or counter clockwise if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e \u0026lt; \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e where \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/73/32/7332b75c94f33f3330411c40ba0a1d1d3f089fdf.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e is the distance between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e . \u003c/p\u003e\u003cp\u003eProblem by: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/AHMED_GAFER\" title\u003d\"Expert AHMED_GAFER\"\u003eAHMED_GAFER\u003c/a\u003e \u003c/p\u003e\u003ch2\u003ePlaying With Strings\u003c/h2\u003e\u003cp\u003eWe can easily notice that the order of the letters in each string is not important. Therefore, all we have to do, is to calculate the number of appearances for each alphabetical letter. Let\u0027s calculate two arrays \u003ccode\u003ecnt1\u003c/code\u003e and \u003ccode\u003ecnt2\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003ccode\u003ecnt1[i]\u003c/code\u003e represents the number of times the letter \u003ccode\u003ei\u003c/code\u003e has appeared in the string \u003ccode\u003eS1\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003ccode\u003ecnt2[i]\u003c/code\u003e represents the number of times the letter \u003ccode\u003ei\u003c/code\u003e has appeared in the string \u003ccode\u003eS2\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eThe answer is simply to accumulate \u003ccode\u003eabs(cnt1[i] - cnt2[i])\u003c/code\u003e for all \u003ccode\u003ei\u003c/code\u003e from \u003cstrong\u003ea\u003c/strong\u003e to \u003cstrong\u003ez\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eTotal Complexity: \u003cstrong\u003eO(n)\u003c/strong\u003e, where \u003cstrong\u003en\u003c/strong\u003e is the length of the longest string among \u003ccode\u003eS1\u003c/code\u003e and \u003ccode\u003eS2\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eProblem by: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Saeed.Sryhini\" title\u003d\"Expert Saeed.Sryhini\"\u003eSaeed.Sryhini\u003c/a\u003e \u003c/p\u003e\u003ch2\u003eCola\u003c/h2\u003e\u003cp\u003e1) The order of processing the queries does not change the outcome.\u003cbr /\u003e2) \u003c/p\u003e\u003cp\u003e\u003ccode\u003eAdd x to position i\u003c/code\u003e\u003cbr /\u003e\u003ccode\u003eAdd y to position i\u003c/code\u003e\u003c/p\u003e\u003cp\u003eNo matter where they appear in the sequence of queries, are equivalent to: \u003c/p\u003e\u003cp\u003e\u003ccode\u003eAdd x+y to position i\u003c/code\u003e\u003c/p\u003e\u003cp\u003eUsing the previous observations, we can process the queries offline. \u003c/p\u003e\u003cp\u003eLet \u003ccode\u003eA[i]\u003c/code\u003e be the sum of all values of queries related to \u003ccode\u003ei\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eStart from left to right, if \u003ccode\u003eA[i]\u003c/code\u003e is more than the size of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eth\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e bottle, fill it and add the rest to \u003ccode\u003eA[i+1]\u003c/code\u003e, otherwise add \u003ccode\u003eA[i]\u003c/code\u003e liters to the bottle. \u003c/p\u003e\u003cp\u003e\u003ccode\u003eA[n+1]\u003c/code\u003e is the amount of wasted cola. \u003c/p\u003e\u003cp\u003eTotal Complexity: \u003cstrong\u003eO(n+q)\u003c/strong\u003e \u003c/p\u003e\u003cp\u003eProblem by: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/AHMED_GAFER\" title\u003d\"Expert AHMED_GAFER\"\u003eAHMED_GAFER\u003c/a\u003e \u003c/p\u003e\u003ch2\u003eArmy\u003c/h2\u003e\u003cp\u003eThat\u0027s a simple Maximum Bipartite Matching problem. \u003c/p\u003e\u003cp\u003ePut the soldiers on the left and places on the right then add an edge between soldier \u003ccode\u003ex\u003c/code\u003e and place \u003ccode\u003ey\u003c/code\u003e if place \u003ccode\u003ey\u003c/code\u003e is one of the places preferred by soldier \u003ccode\u003ex\u003c/code\u003e and the union of the set of weapons available in place \u003ccode\u003ey\u003c/code\u003e and the set of weapons preferred by soldier \u003ccode\u003ex\u003c/code\u003e is not an empty set . \u003c/p\u003e\u003cp\u003eThen find the maximum matching using any algorithm . \u003c/p\u003e\u003cp\u003eProblem by: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/AHMED_GAFER\" title\u003d\"Expert AHMED_GAFER\"\u003eAHMED_GAFER\u003c/a\u003e and \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/muaz-32\" title\u003d\"Expert muaz-32\"\u003emuaz-32\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eThanks for participating!\u003c/strong\u003e \u003cstrong\u003eI hope you liked the problems, any feedback is appreciated.\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e","tags":["editorial","gym"]}}