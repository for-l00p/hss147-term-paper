{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1524534070,"rating":-16,"authorHandle":"ebanner","modificationTimeSeconds":1524591276,"id":59075,"title":"\u003cp\u003eConverting to base k\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eLet\u0027s consider the problem of converting a number to base \u003ccode\u003ek\u003c/code\u003e. Initially I was confused by this algorithm, but the more I think about it the more it makes sense.\u003c/p\u003e\u003cp\u003eThe algorithm is this. For a number \u003ccode\u003en\u003c/code\u003e in base \u003ccode\u003e10\u003c/code\u003e, if we wish to convert \u003ccode\u003en\u003c/code\u003e to base \u003ccode\u003ek\u003c/code\u003e then we do the following.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003edigits \u003d []\nwhile n \u0026gt; 0:\n    digit \u003d n%k\n    digits.append(digit)\n    n /\u003d k\nn_k \u003d reversed(digits)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ewhere \u003ccode\u003en_k\u003c/code\u003e is the number \u003ccode\u003en\u003c/code\u003e in base \u003ccode\u003ek\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eWhy does this work? Well the first thing to notice is that for any natural number base \u003ccode\u003ek\u003c/code\u003e we can write a number \u003ccode\u003en\u003c/code\u003e in base 10 in the following way.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003en \u003d sum of i from 0 to infinity of c_i*(k^i)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ewhere \u003ccode\u003e0 \u0026lt;\u003d c_i \u0026lt; k\u003c/code\u003e. \u003ccode\u003e***\u003c/code\u003e\u003c/p\u003e\u003cp\u003eAs a concrete example consider writing \u003ccode\u003e11\u003c/code\u003e in base \u003ccode\u003e3\u003c/code\u003e. By the above declaration we can write the following.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e11 \u003d 1*3^2 + 0*3^1 + 2*3^0\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow why is this useful? Well if you read off the coefficients from left to right of the above expression, that \u003cem\u003eis\u003c/em\u003e \u003ccode\u003e11\u003c/code\u003e in base \u003ccode\u003e3\u003c/code\u003e!\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e11_10 \u003d 102_3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ewhere \u003ccode\u003en_k\u003c/code\u003e is the number \u003ccode\u003en\u003c/code\u003e in base \u003ccode\u003ek\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eSo given this fact, we just need a way to read off the coefficients of each of these terms. Here is an algorithm for doing so.\u003c/p\u003e \u003col\u003e   \u003cli\u003eRead off the rightmost coefficient\u003c/li\u003e   \u003cli\u003eShift all the terms rightwards while eliminating the rightmost term\u003c/li\u003e   \u003cli\u003eGo back to step 1\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eWe can accomplish step 1 by doing \u003ccode\u003en % k\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e11 % 3 \u003d (1*3^2 + (0*3)^1 + 2*3^0) % 3\n       \u003d 0      + 0       + 2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTo see why this is the case note that all the terms except the rightmost term have a modulus of zero (because they contain at least one factor of \u003ccode\u003e3\u003c/code\u003e). So doing the modulus has the effect of reading off the rightmost coefficient.\u003c/p\u003e\u003cp\u003eNow how do we do step 2? We just do \u003ccode\u003en / k\u003c/code\u003e. Let\u0027s look and see what that does.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e10 / 3 \u003d [1*3^2      +  0*3^1     + 2*3^0] / 3\n       \u003d (1*3^2)/3   + (0*3^1)/3  + (2*3^0)/3\n       \u003d 1*(3^1)     +  0*3^0     + 0\n       \u003d 1*(3^1)     +  0*3^0\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNotice the last term zeros out because there is no factor of \u003ccode\u003e3\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eSo it looks like we\u0027ve done the main things required to convert to base \u003ccode\u003ek\u003c/code\u003e. As a last (and small) order of business notice that we\u0027ve accumulated digits from right to left and hence they are backwards. We only need to reverse them to straighten them out.\u003c/p\u003e\u003cp\u003e\u003ccode\u003e***\u003c/code\u003e A proof of this fact is outside the scope of this guide (I\u0027m sure there is a proof out there somewhere). To convince you that this is true, consider that if it was not true then we wouldn\u0027t be able to use binary nor octal nor hexadecimal to represent numbers (why?).\u003c/p\u003e\u003c/div\u003e","tags":[]}}