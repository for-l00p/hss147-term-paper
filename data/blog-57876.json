{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1519037102,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1525378677,"id":57876,"title":"\u003cp\u003eУсловные операторы и циклы\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eВ этой записи мы кратко обсудим синтаксис условных операторов и циклов. Также будут приведены простые примеры. Приведённых ниже сведений определённо должно хватить для решения первых восьми задач \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eA\u003c/i\u003e - \u003ci\u003eH\u003c/i\u003e)\u003c/span\u003e из уже предложенного \u003ca href\u003d\"//codeforces.com/group/vttlHWo2Li/contest/101729\"\u003eсоревнования\u003c/a\u003e. Задачи в этом соревновании упорядочены по сложности (с точки зрения автора задач) \u003cbr /\u003e\u003c/p\u003e\u003ch4\u003eСинтаксис оператора \u003ccode\u003eif\u003c/code\u003e\u003c/h4\u003e\u003cp\u003eВ \u0026quot;классической форме\u0026quot; условный оператор выглядит так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eif (\u0026lt;условие\u0026gt;) {\n    \u0026lt;операторы 1\u0026gt;\n}\nelse {\n    \u0026lt;операторы 2\u0026gt;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗдесь \u003ccode\u003e\u0026lt;условие\u0026gt;\u003c/code\u003e — некоторое выражение логического (\u003ccode\u003eboolean\u003c/code\u003e) типа, \u003ccode\u003e\u0026lt;операторы 1\u0026gt;\u003c/code\u003e — операторы, которые должны быть выполнены, если условие имеет значение \u003ccode\u003etrue\u003c/code\u003e, \u003ccode\u003e\u0026lt;операторы 2\u0026gt;\u003c/code\u003e — операторы, которые должны быть выполнены, если условие имеет значение \u003ccode\u003efalse\u003c/code\u003e. Условие \u003cem\u003eобязательно\u003c/em\u003e должно быть заключено в круглые скобки. \u003c/p\u003e\u003cp\u003eВетвь \u003ccode\u003eelse\u003c/code\u003e является необязательной, поэтому её можно не писать, если никаких действий (\u003ccode\u003e\u0026lt;операторы 2\u0026gt;\u003c/code\u003e) не требуется:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eif (\u0026lt;условие\u0026gt;) {\n    \u0026lt;операторы 1\u0026gt;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЕсли в группе операторов \u003ccode\u003e\u0026lt;операторы 1\u0026gt;\u003c/code\u003e или \u003ccode\u003e\u0026lt;операторы 2\u0026gt;\u003c/code\u003e только один оператор, то фигурные скобки вокруг этой группы можно не писать (в примере ниже обе группы состоят из одного оператора):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eif (\u0026lt;условие\u0026gt;)\n    \u0026lt;оператор 1\u0026gt;;\nelse\n    \u0026lt;оператор 2\u0026gt;;\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНапомним, что в Java после каждого оператора необходимо ставить точку с запятой \u003ccode\u003e;\u003c/code\u003e (можете считать, что это признак окончания оператора). \u003c/p\u003e\u003cp\u003eПоскольку условный оператор является одним \u0026quot;большим\u0026quot; оператором, то нередко опускать скобки можно при использовании вложенного условного оператора. Сравните:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eif (\u0026lt;условие 1\u0026gt;) {\n    \u0026lt;операторы 1.1\u0026gt;\n}\nelse {\n    if (\u0026lt;условие 2\u0026gt;) {\n        \u0026lt;операторы 2.1\u0026gt;\n    }\n    else {\n        \u0026lt;операторы 2.2\u0026gt;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eи\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eif (\u0026lt;условие 1\u0026gt;) {\n    \u0026lt;операторы 1.1\u0026gt;\n}\nelse if (\u0026lt;условие 2\u0026gt;) {\n    \u0026lt;операторы 2.1\u0026gt;\n}\nelse {\n    \u0026lt;операторы 2.2\u0026gt;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВторая запись используется чаще, нужно просто помнить, что компилятор всегда считает \u003ccode\u003eelse\u003c/code\u003e принадлежащим ближайшему \u003ccode\u003eif\u003c/code\u003e (первому выше этого \u003ccode\u003eelse\u003c/code\u003e). \u003c/p\u003e\u003cp\u003eЕсли оператор \u003ccode\u003eif\u003c/code\u003e нужно вложить в ветвь \u003ccode\u003eif\u003c/code\u003e, то преобразовать конструкцию в \u0026quot;менее вложенную\u0026quot; будет сложнее.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eif (\u0026lt;условие 1\u0026gt;) {\n    if (\u0026lt;условие 2\u0026gt;) {\n        \u0026lt;операторы 2.1\u0026gt;\n    }\n    else {\n        \u0026lt;операторы 2.2\u0026gt;\n    }\n}\nelse {\n    \u0026lt;операторы 1.2\u0026gt;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПонадобится объединить условия \u003ccode\u003e\u0026lt;условие 1\u0026gt;\u003c/code\u003e и \u003ccode\u003e\u0026lt;условие 2\u0026gt;\u003c/code\u003e в одно, а далее придётся проверить соблюдение условия 1 \u0026quot;отдельно\u0026quot; от условия 2, чтобы, в зависимости от результата проверки, выполнить операторы 2.2 или 2.1:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eif (\u0026lt;условие 1\u0026gt; \u0026amp;\u0026amp; \u0026lt;условие 2\u0026gt;) {\n    \u0026lt;операторы 2.1\u0026gt;\n}\nelse if (\u0026lt;условие 1\u0026gt;) {\n        \u0026lt;операторы 2.2\u0026gt;    \n}\nelse {\n    \u0026lt;операторы 1.2\u0026gt;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДействительно, \u003ccode\u003e\u0026lt;операторы 2.1\u0026gt;\u003c/code\u003e должны выполняться в том случае, если и \u003ccode\u003e\u0026lt;условие 1\u0026gt;\u003c/code\u003e, и \u003ccode\u003e\u0026lt;условие 2\u0026gt;\u003c/code\u003e принимают значение \u003ccode\u003etrue\u003c/code\u003e (за это и отвечает первый \u003ccode\u003eif\u003c/code\u003e). Далее, \u003ccode\u003e\u0026lt;операторы 2.2\u0026gt;\u003c/code\u003e должны выполняться, если \u003ccode\u003e\u0026lt;условие 1\u0026gt;\u003c/code\u003e принимает значение \u003ccode\u003etrue\u003c/code\u003e, а \u003ccode\u003e\u0026lt;условие 2\u0026gt;\u003c/code\u003e, напротив, принимает значение \u003ccode\u003efalse\u003c/code\u003e. Понятно, что в первую ветвь \u003ccode\u003eelse\u003c/code\u003e можно попасть при условии, что логическое выражение \u003ccode\u003e(\u0026lt;условие 1\u0026gt; \u0026amp;\u0026amp; \u0026lt;условие 2\u0026gt;)\u003c/code\u003e принимает значение \u003ccode\u003efalse\u003c/code\u003e. Но \u0026quot;причиной\u0026quot; этого значения может быть как \u003ccode\u003e\u0026lt;условие 2\u0026gt;\u003c/code\u003e, так и \u003ccode\u003e\u0026lt;условие 1\u0026gt;\u003c/code\u003e, именно это и проверяется с помощью второго \u003ccode\u003eif\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eКонечно, не нужно стремиться любой ценой преобразовать вложенную структуру в \u0026quot;плоскую\u0026quot; (хотя плоскую зачастую легче читать). Но если решено преобразовывать, необходимо проследить, чтобы все операторы выполнялись именно и только при соблюдении тех условий, при соблюдении которых они выполнялись в исходной структуре.\u003c/p\u003e\u003ch4\u003eСинтаксис оператора \u003ccode\u003eswitch\u003c/code\u003e\u003c/h4\u003e\u003cp\u003eОператор выбора также является условным оператором. В отличие от оператора \u003ccode\u003eif\u003c/code\u003e, предоставляющего две альтернативы, \u003ccode\u003eswitch\u003c/code\u003e позволяет рассмотреть несколько вариантов. Вообще говоря, эти операторы могут успешно заменять друг друга, хотя у каждого есть предпочтительная \u0026quot;сфера применения\u0026quot;.\u003c/p\u003e\u003cp\u003eОператор выбора выглядит следующим образом:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eswitch (\u0026lt;переключатель\u0026gt;) {\n    case \u0026lt;вариант 1\u0026gt;: \u0026lt;операторы 1\u0026gt;\n    case \u0026lt;вариант 2\u0026gt;: \u0026lt;операторы 2\u0026gt;\n    ...\n    case \u0026lt;вариант N\u0026gt;: \u0026lt;операторы N\u0026gt;\n    default: \u0026lt;операторы\u0026gt;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ качестве \u003cstrong\u003eпереключателя\u003c/strong\u003e могут быть использованы переменные примитивных типов \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003eshort\u003c/code\u003e, \u003ccode\u003ebyte\u003c/code\u003e, \u003ccode\u003echar\u003c/code\u003e, соответствующих им типов-оболочек \u003ccode\u003eInteger\u003c/code\u003e, \u003ccode\u003eShort\u003c/code\u003e, \u003ccode\u003eByte\u003c/code\u003e, \u003ccode\u003eCharacter\u003c/code\u003e, типов-перечислений \u003ccode\u003eenum\u003c/code\u003e, а также типа \u003ccode\u003eString\u003c/code\u003e. Типы-оболочки и типы-перечисления будут рассматриваться позже, хотя, надо полагать, их \u0026quot;концепция\u0026quot; может быть интуитивно понятна уже сейчас. Если не вдаваться в подробности, типы-оболочки используются там, где в силу особенностей синтаксиса не могут быть использованы примитивные типы; типы-перечисления позволяют задать набор именованных констант.\u003c/p\u003e\u003cp\u003eЗначения \u003ccode\u003eвариант 1\u003c/code\u003e, \u003ccode\u003eвариант 2\u003c/code\u003e, ..., \u003ccode\u003eвариант N\u003c/code\u003e должны быть того же (или совместимого) типа, что и переключатель. Важно: варианты должны быть попарно несовпадающими значениями.\u003c/p\u003e\u003cp\u003eВетвь \u003ccode\u003edefault\u003c/code\u003e может отсутствовать; если же она есть, то выполняется в случае, если ни один вариант не соответствует переключателю. \u003c/p\u003e\u003cp\u003eКоличество операторов в блоках может быть любым: поскольку имеются \u0026quot;естественные границы\u0026quot;, позволяющие отделить один блок от другого. Заметим, что \u0026quot;любым\u0026quot; означает в том числе и нулевым: если имеется несколько вариантов, для которых выполняются одни и те же операторы, то это будет записано, например, так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e    case \u0026lt;вариант 3\u0026gt;: \n    case \u0026lt;вариант 4\u0026gt;: \n    case \u0026lt;вариант 5\u0026gt;:  \u0026lt;операторы 5\u0026gt;\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВыполняется оператор \u003ccode\u003eswitch\u003c/code\u003e следующим образом. Вычисляется значение переключателя, после чего последовательно просматриваются все варианты. Если значение переключателя совпадает с некоторым вариантом, будут выполнены \u003cstrong\u003eвсе\u003c/strong\u003e операторы, записанные после него (разумеется, если среди этих операторов не будет оператора, прерывающего исполнение \u003ccode\u003eswitch\u003c/code\u003e — о нём чуть ниже).\u003c/p\u003e\u003cp\u003eТ.е., если, например, значение переключателя совпало со значением \u003ccode\u003eвариант 1\u003c/code\u003e, то будут выполнены и \u003ccode\u003e\u0026lt;операторы 1\u0026gt;\u003c/code\u003e, и \u003ccode\u003e\u0026lt;операторы 2\u0026gt;\u003c/code\u003e, и все остальные операторы, вплоть до блоков \u003ccode\u003e\u0026lt;операторы N\u0026gt;\u003c/code\u003e и \u003ccode\u003e\u0026lt;операторы\u0026gt;\u003c/code\u003e в ветви \u003ccode\u003edefault\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eДовольно часто требуется выполнить только операторы для конкретного варианта, после чего прервать выполнение оператора \u003ccode\u003eswitch\u003c/code\u003e. Чтобы обеспечить такое поведение, каждый блок операторов завершают оператором \u003ccode\u003ebreak\u003c/code\u003e. Однако бывают ситуации, когда в некоторых вариантах оператор \u003ccode\u003ebreak\u003c/code\u003e полезно не использовать. Приведём пример такого кода.\u003c/p\u003e\u003cp\u003eПусть на вход подаётся число от 1 до 10, и нам нужно вывести \u0026quot;римскую запись\u0026quot; для этого числа. Записывать ответ мы будем в строку.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003eint arabic;\n// ввод числа от 1 до 10\n\nString rome \u003d \u0026quot;\u0026quot;;\n\nswitch (arabic) {\n    case 3: rome +\u003d \u0026quot;I\u0026quot;;\n    case 2: rome +\u003d \u0026quot;I\u0026quot;;\n    case 1: rome +\u003d \u0026quot;I\u0026quot;; break;\n    case 4: rome \u003d \u0026quot;IV\u0026quot;;\n    case 8: rome \u003d \u0026quot;I\u0026quot; + rome;\n    case 7: rome \u003d \u0026quot;I\u0026quot; + rome;\n    case 6: rome \u003d \u0026quot;I\u0026quot; + rome;\n    case 5: rome \u003d \u0026quot;V\u0026quot; + rome; break;\n    case 9: rome +\u003d \u0026quot;I\u0026quot;;\n    case 10: rome +\u003d \u0026quot;X\u0026quot;; break;\n    default: rome \u003d \u0026quot;undefined transformation\u0026quot;;\n}\n\nSystem.out.println(rome);\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eРассмотрим несколько случаев работы этого оператора.\u003c/p\u003e\u003cp\u003eПусть на вход подано число 7. Последовательно будут выполнены такие присваивания:\u003c/p\u003e\u003cp\u003e\u003ccode\u003erome \u003d \u0026quot;I\u0026quot; + rome;\u003c/code\u003e — в case 7 \u0026quot;I\u0026quot; + \u0026quot;\u0026quot; даст \u0026quot;I\u0026quot;\u003c/p\u003e\u003cp\u003e\u003ccode\u003erome \u003d \u0026quot;I\u0026quot; + rome;\u003c/code\u003e — в case 6 \u0026quot;I\u0026quot; + \u0026quot;I\u0026quot; даст \u0026quot;II\u0026quot;\u003c/p\u003e\u003cp\u003e\u003ccode\u003erome \u003d \u0026quot;V\u0026quot; + rome;\u003c/code\u003e — в case 5 \u0026quot;V\u0026quot; + \u0026quot;II\u0026quot; даст \u0026quot;VII\u0026quot;\u003c/p\u003e\u003cp\u003eПусть на вход подано число 9. Тогда сначала строка rome получит значение \u0026quot;I\u0026quot; (при срабатывании \u003ccode\u003ecase 9\u003c/code\u003e), после чего будут исполнены операторы, записанные в \u003ccode\u003ecase 10\u003c/code\u003e- т.е. строка rome получит значение \u0026quot;IX\u0026quot;, а затем оператор \u003ccode\u003ebreak\u003c/code\u003e прекратит исполнение оператора \u003ccode\u003eswitch\u003c/code\u003e. Обратите внимание, что если в \u003ccode\u003ecase 10\u003c/code\u003e оператор \u003ccode\u003ebreak\u003c/code\u003e будет отсутствовать, то это приведёт к исполнению оператора из ветви \u003ccode\u003edefault\u003c/code\u003e, и вместо верного ответа \u0026quot;IX\u0026quot; будет получено сообщение о неопределенном преобразовании (undefined transformation).\u003c/p\u003e\u003ch4\u003eПример решения задачи\u003c/h4\u003e\u003cp\u003eВ этой задаче нам потребуется только оператор \u003ccode\u003eif\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003cem\u003eЗадача \u0026quot;Автобус или трамвай?\u0026quot;\u003c/em\u003e\u003c/p\u003e\u003cp\u003eВ этой задаче для удобства будем отсчитывать время в минутах от начала суток.\u003c/p\u003e\u003cp\u003eКеша может поехать в университет как на автобусе, так и на трамвае. Каких-либо предпочтений у Кеши нет: он садится в первый подошедший транспорт. \u003cbr /\u003e Автобусы и трамваи ходят регулярно. Первый автобус приезжает на остановку в момент времени \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, а затем каждые \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e минут на остановку приезжает очередной автобус. Первый трамвай приезжает на остановку в момент времени \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e, а затем каждые \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e минут на остановку приезжает очередной трамвай. \u003cbr /\u003e Сегодня Кеша пришёл на остановку в момент времени \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e. Определите, поедет ли Кеша на автобусе или на трамвае. \u003cbr /\u003e Считайте, что если автобус и трамвай приедут одновременно, Кеша поедет на автобусе. Считайте также, что если Кеша приходит на остановку одновременно с автобусом и / или трамваем, он успеет сесть в подошедший транспорт. \u003cbr /\u003e Если Кеша поедет на автобусе, выведите \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eBUS\u003c/i\u003e\u003c/span\u003e, если же на трамвае — выведите \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eTRAM\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003e\u003cem\u003eВходные данные\u003c/em\u003e\u003c/p\u003e\u003cp\u003eВ первой строке содержатся два целых числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(0 ≤ \u003ci\u003ea\u003c/i\u003e ≤ 1000,  1 ≤ \u003ci\u003eb\u003c/i\u003e ≤ 100)\u003c/span\u003e — момент времени, в который к остановке приезжает первый автобус, и интервал движения автобусов.\u003c/p\u003e\u003cp\u003eВо второй строке содержатся два целых числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(0 ≤ \u003ci\u003ec\u003c/i\u003e ≤ 1000,  1 ≤ \u003ci\u003ed\u003c/i\u003e ≤ 100)\u003c/span\u003e — момент времени, в который к остановке приезжает первый трамвай, и интервал движения трамваев.\u003c/p\u003e\u003cp\u003eВ третьей строке содержится целое число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(0 ≤ \u003ci\u003eh\u003c/i\u003e ≤ 1200)\u003c/span\u003e — момент времени, в который Кеша пришёл на остановку.\u003c/p\u003e\u003cp\u003e\u003cem\u003eВыходные данные\u003c/em\u003e\u003c/p\u003e\u003cp\u003eВыведите в первой строке слово \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eBUS\u003c/i\u003e\u003c/span\u003e, если Кеша поедет на автобусе, и слово \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eTRAM\u003c/i\u003e\u003c/span\u003e, если Кеша поедет на трамвае.\u003c/p\u003e\u003cp\u003e\u003cem\u003eРешение\u003c/em\u003e\u003c/p\u003e\u003cp\u003eСначала обсудим \u0026quot;математическую\u0026quot; часть решения. \u003cbr /\u003e Задача может быть переформулирована так: начиная с момента времени \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e, будем вести наблюдения за транспортом. Нужно установить, автобус или трамвай придёт первым. \u003c/p\u003e\u003cp\u003eМы знаем, что автобус приезжает к остановке в моменты времени \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + 2·\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, ... \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e·\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, ...\u003c/p\u003e\u003cp\u003eНайдём такое целое \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, чтобы \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e·\u003ci\u003eb\u003c/i\u003e \u0026lt; \u003ci\u003eh\u003c/i\u003e\u003c/span\u003e, но \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + (\u003ci\u003ek\u003c/i\u003e + 1)·\u003ci\u003eb\u003c/i\u003e ≥ \u003ci\u003eh\u003c/i\u003e\u003c/span\u003e. Тогда момент времени \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + (\u003ci\u003ek\u003c/i\u003e + 1)·\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e и будет моментом времени, в который к остановке приедет первый с начала наблюдений автобус. \u003c/p\u003e\u003cp\u003eС точки зрения математики вроде бы всё просто: нужно вычислить \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d (\u003ci\u003eh\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e) / \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e и при необходимости округлить его вверх. Действительно, пусть \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d 400\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e \u003d 20\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e \u003d 517\u003c/span\u003e. Тогда \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d (517 - 400) / 20 \u003d 5 + 17 / 20\u003c/span\u003e. Округление вверх даёт нам \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d 6\u003c/span\u003e и время \u003cspan class\u003d\"tex-span\"\u003e520 \u003d 400 + 6·20\u003c/span\u003e — т.е. ближайший автобус, на котором сможет поехать Кеша, приедет к остановке в момент времени 520 (предыдущий автобус приедет в момент времени 500, очевидно, что Кеша на него не успевает). \u003c/p\u003e\u003cp\u003eНо давайте рассмотрим такие данные: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d 400\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e \u003d 20\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e \u003d 300\u003c/span\u003e. Мы получаем для \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e значение \u003cspan class\u003d\"tex-span\"\u003e - 5\u003c/span\u003e, которое нас не устроит. Вполне понятно, что Кеша в этом случае будет вынужден ждать первый автобус (конечно, если раньше него не придёт трамвай), и \u0026quot;фактическое\u0026quot; значение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e будет равно 0. Значит, пользоваться этой формулой мы можем только при условии, что \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e ≥ \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eЕщё один важный момент состоит в том, что с точки зрения компьютера целые и вещественные числа — очень разные сущности. И целочисленной единице может соответствовать как вещественное \u003cspan class\u003d\"tex-span\"\u003e0.999999999999\u003c/span\u003e, так и \u003cspan class\u003d\"tex-span\"\u003e1.00000000001\u003c/span\u003e. Заметим, что второе при округлении вверх даст ответ 2, а это тоже не совсем то, чего мы ожидаем. \u003c/p\u003e\u003cp\u003eВ Java (впрочем, как и в большинстве языков, использующих вещественную арифметику) при возможности следует отдавать предпочтение операциям над целыми числами (а не операциям над вещественными числами). Поэтому при вычислении \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e мы также будем вычислять и остаток от деления \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eh\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e)%\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. Если остаток отличен от нуля, то к \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e нужно прибавить 1 (это и будет округление вверх). \u003c/p\u003e\u003cp\u003eАналогичным образом можно провести вычисления для трамвая (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e будет заменено на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e, а \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e — на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e). Когда будут вычислены искомые моменты времени, останется их просто сравнить. \u003c/p\u003e\u003cp\u003e\u003cbr /\u003e А теперь перейдём к \u0026quot;программистской\u0026quot; части решения.\u003c/p\u003e\u003cp\u003eБудем считать, что вы уже уверенно пишете простые задачи, в которых условный оператор не нужен, и что вы умеете создавать классы и методы. Мы уже не будем останавливаться на этом так же подробно, как в предыдущих записях в блоге. \u003c/p\u003e\u003cp\u003eСоздайте новый проект с именем \u003ccode\u003ebustram\u003c/code\u003e; в нём — класс (это будет \u0026quot;запускающий класс\u0026quot;, согласно терминам предыдущих записей) \u003ccode\u003eBusOrTram\u003c/code\u003e. Не забудьте удалить название пакета в строке \u003ccode\u003ePackage\u003c/code\u003e диалогового окна и поставить в этом же диалоговом окне галочку на \u003ccode\u003epublic static void main(String[] args)\u003c/code\u003e. У вас должно получиться следующее:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epublic class BusOrTram {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТеперь создадим класс, содержащий логику. Назовём его \u003ccode\u003eKChoice\u003c/code\u003e \u003cem\u003e(англ. choice — выбор, K — от имени Кеши)\u003c/em\u003e. Входные данные — пять целых чисел, поэтому объявим пять целочисленных переменных с названиями, соответствующими обозначениям во входных данных. Также напишем конструктор класса, в котором будет создаваться объект класса \u003ccode\u003eScanner\u003c/code\u003e, читающий данные со стандартного входа \u003ccode\u003eSystem.in\u003c/code\u003e, и выполним чтение входных данных. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport java.util.Scanner;\n\npublic class BusOrTram {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass KChoice {\n\t\n\tKChoice() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\ta \u003d in.nextInt();\n\t\tb \u003d in.nextInt();\n\t\tc \u003d in.nextInt();\n\t\td \u003d in.nextInt();\n\t\th \u003d in.nextInt();\n\t\tin.close();\n\t}\n\t\n\tint a;\n\tint b;\n\tint c;\n\tint d;\n\tint h;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ качестве ответа нам нужно вывести строку, поэтому к объявлению пяти целочисленных переменных следует добавить объявление строковой переменной. Никакого имени в условии задачи для этой переменной не предлагается, поэтому назовём её \u003ccode\u003eans\u003c/code\u003e \u003cem\u003e(сокращённое от англ. answer — ответ).\u003c/em\u003e \u003c/p\u003e\u003cp\u003eТеперь займёмся методом \u003ccode\u003esolve()\u003c/code\u003e. Он будет частью класса \u003ccode\u003eKChoice\u003c/code\u003e, и именно в нём будут выполнены необходимые выкладки. Как уже понятно, для них нам потребуются дополнительные переменные. Однако, поскольку эти переменные нужны будут только в рамках метода \u003ccode\u003esolve()\u003c/code\u003e, именно там мы их и объявим. \u003c/p\u003e\u003cp\u003eСначала напишем вычисление момента времени, в который придёт первый (с момента прихода Кеши на остановку) автобус.\u003c/p\u003e\u003cp\u003e\u003cem\u003eСовет. Не спешите перепечатывать этот метод. Мы покажем, как прийти к более короткой записи. Хотя... Возможно, будет полезно воспроизвести все описанные ниже шаги.\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tvoid solve() {\n\t\tint x;\n\t\tif (h \u0026lt; a) {\n\t\t\tx \u003d 0;\n\t\t}\n\t\telse {\n\t\t\tx \u003d (h - a) / b;\n\t\t\tint r \u003d (h - a) % b;\n\t\t\tif (r \u0026gt; 0) {\n\t\t\t\tx \u003d x + 1;\n\t\t\t}\n\t\t}\n\t\tint tb \u003d a + x * b;\t\t\n\t\t\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗдесь, по сравнению с \u0026quot;математической\u0026quot; частью решения, появились две новые переменные: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etb\u003c/i\u003e\u003c/span\u003e. Как можно видеть, в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e мы сохраняем остаток от деления, позволяющий узнать, как мы должны округлить вверх величину \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, а в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etb\u003c/i\u003e\u003c/span\u003e мы, используя полученное значение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, записываем момент времени, в который Кеша сможет сесть в автобус. \u003c/p\u003e\u003cp\u003eПриведённую выше запись можно сделать немного короче. Поскольку переменная \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e используется только для сравнения, мы можем записать выражение непосредственно в скобках во вложенном операторе \u003ccode\u003eif\u003c/code\u003e. Также мы можем сразу присвоить величине \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e значение \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e и менять его только при выполнении условия \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e ≥ \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. Сделав такие преобразования, получим:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tvoid solve() {\n\t\tint x \u003d 0;\n\t\tif (h \u0026gt;\u003d a) {\n\t\t\tx \u003d (h - a) / b;\n\t\t\tif ((h - a) % b \u0026gt; 0) {\n\t\t\t\tx \u003d x + 1;\n\t\t\t}\n\t\t}\n\t\tint tb \u003d a + x * b;\t\t\n\t\t\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТеперь нужно провести аналогичные вычисления для трамвая. Как кажется, проще всего скопировать уже имеющиеся строчки и слегка поправить их, заменяя \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e. Переменная \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e может быть использована повторно (так как нет необходимости сохранять её значение), но можно заменить её на какую-то другую переменную, например, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. Метод \u003ccode\u003esolve()\u003c/code\u003e примет следующий вид:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tvoid solve() {\n\t\tint x \u003d 0;\n\t\tif (h \u0026gt;\u003d a) {\n\t\t\tx \u003d (h - a) / b;\n\t\t\tif ((h - a) % b \u0026gt; 0) {\n\t\t\t\tx \u003d x + 1;\n\t\t\t}\n\t\t}\n\t\tint tb \u003d a + x * b;\t\t\n\t\t\n\t\tint y \u003d 0;\n\t\tif (h \u0026gt;\u003d c) {\n\t\t\ty \u003d (h - c) / d;\n\t\t\tif ((h - c) % d \u0026gt; 0) {\n\t\t\t\ty \u003d y + 1;\n\t\t\t}\n\t\t}\n\t\tint tt \u003d c + y * d;\t\n\t\t\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКонечно, метод \u0026quot;скопировать — вставить\u0026quot; может быть хорош в некоторых случаях. Но давайте посчитаем, сколько раз нам пришлось менять имена переменных? Было сделано 4 замены \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, 4 замены \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e, 3 замены \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e и одна замена \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etb\u003c/i\u003e\u003c/span\u003e на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ett\u003c/i\u003e\u003c/span\u003e. Целых 12 изменений в таком небольшом фрагменте кода... \u003c/p\u003e\u003cp\u003eСамое неприятное заключается в том, что если Вы забудете сделать хотя бы одну из этих замен, результат будет совсем другим. Найти такую ошибку может быть очень непросто. Наиболее правильный подход — в случае повторяющихся вычислений вынести их в отдельную функцию. Конечно, это потребует выполнения ещё одной операции \u0026quot;копировать — вставить\u0026quot;, но мы введём осмысленные обозначения, и это поможет нам не запутаться. \u003c/p\u003e\u003cp\u003eЕсли вдруг мы допустили ошибку в вычислении времени, то исправить её будет нужно в одном месте — в функции \u003ccode\u003ecalcTime()\u003c/code\u003e. В методе же \u003ccode\u003esolve()\u003c/code\u003e теперь осталось лишь две строки — два вызова функции \u003ccode\u003ecalcTime()\u003c/code\u003e с разными параметрами.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tint calcTime(int start, int interval) {\n\t\tint x \u003d 0;\n\t\tif (h \u0026gt;\u003d start) {\n\t\t\tx \u003d (h - start) / interval;\n\t\t\tif ((h - start) % interval \u0026gt; 0) {\n\t\t\t\tx \u003d x + 1;\n\t\t\t}\n\t\t}\n\t\tint tres \u003d start + x * interval;\n\t\treturn tres;\n\t}\n\t\n\t\n\tvoid solve() {\n\t\tint tb \u003d calcTime(a, b);\t\t\n\t\tint tt \u003d calcTime(c, d);\t\n\t\t\n\t}\n\t\t\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗавершающий штрих — это сравнение величин \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etb\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ett\u003c/i\u003e\u003c/span\u003e, присваивание переменной \u003ccode\u003eans\u003c/code\u003e соответствующего значения и вывод его на печать. Разумеется, нужно будет дописать несколько строк и в метод \u003ccode\u003emain()\u003c/code\u003e запускающего класса.\u003c/p\u003e\u003cp\u003eПри присваивании переменной \u003ccode\u003eans\u003c/code\u003e значения используем такой же подход, какой был применён выше: присвоим сначала одно из допустимых значений, а затем выполним сравнение и, если потребуется, изменим значение переменной. \u003c/p\u003e\u003cp\u003eВ итоге получим следующую программу:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport java.util.Scanner;\n\npublic class BusOrTram {\n\n\tpublic static void main(String[] args) {\n\t\tKChoice kc \u003d new KChoice();\n\t\tkc.solve();\n\t\tkc.print();\n\t}\n\n}\n\nclass KChoice {\n\t\n\tKChoice() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\ta \u003d in.nextInt();\n\t\tb \u003d in.nextInt();\n\t\tc \u003d in.nextInt();\n\t\td \u003d in.nextInt();\n\t\th \u003d in.nextInt();\n\t\tin.close();\n\t}\n\t\n\tint calcTime(int start, int interval) {\n\t\tint x \u003d 0;\n\t\tif (h \u0026gt;\u003d start) {\n\t\t\tx \u003d (h - start) / interval;\n\t\t\tif ((h - start) % interval \u0026gt; 0) {\n\t\t\t\tx \u003d x + 1;\n\t\t\t}\n\t\t}\n\t\tint tres \u003d start + x * interval;\n\t\treturn tres;\n\t}\n\t\n\tvoid solve() {\n\t\tint tb \u003d calcTime(a, b);\t\t\n\t\tint tt \u003d calcTime(c, d);\t\n\t\tans \u003d \u0026quot;BUS\u0026quot;;\n\t\tif (tt \u0026lt; tb) {\n\t\t\tans \u003d \u0026quot;TRAM\u0026quot;;\n\t\t}\n\t}\n\t\n\tvoid print() {\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tint a;\n\tint b;\n\tint c;\n\tint d;\n\tint h;\n\tString ans;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eСохраните файл и попробуйте запустить программу на следующих входных данных:\u003c/p\u003e\u003cp\u003eВходные данные:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e400 25\n380 27\n520\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОтвет:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eBUS\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКомментарий. \u003cbr /\u003e Действительно, можно посчитать, что трамвай придёт в момент времени 515, а потом — в момент времени 542. Автобус же подъедет к остановке в момент времени 525, так что Кеша, придя в момент времени 520, конечно, поедет на автобусе.\u003c/p\u003e\u003cp\u003eВходные данные:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e400 25\n380 27\n530\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОтвет:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eTRAM\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКомментарий. \u003cbr /\u003e От предыдущего примера этот отличается лишь временем прихода на остановку Кеши. Теперь он не успевает на автобус, приходящий в момент времени 525, а следующий автобус подъедет только в момент времени 550. Так что Кеша уедет на трамвае, который придёт в момент времени 542. \u003c/p\u003e\u003cp\u003eВходные данные:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e400 25\n380 27\n250\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОтвет:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eTRAM\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКомментарий. \u003cbr /\u003e Этот пример иллюстрирует ситуацию, когда Кеша пришёл на остановку и раньше первого автобуса, и раньше первого трамвая. Поскольку первый трамвай приедет раньше первого автобуса, то Кеша уедет на нём.\u003c/p\u003e\u003cp\u003eВходные данные:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e400 25\n380 27\n385\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОтвет:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eBUS\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКомментарий. \u003cbr /\u003e Этот пример показывает, что Кеше выгоднее дождаться первого автобуса. Первый трамвай он пропустил, а следующий придет лишь через 7 минут после первого автобуса.\u003c/p\u003e\u003cp\u003eВходные данные:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e400 25\n380 20\n600\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОтвет:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eBUS\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКомментарий. \u003cbr /\u003e Этот пример показывает ситуацию, когда и автобус, и трамвай подъезжают к остановке одновременно. Согласно условию задачи Кеша должен выбрать автобус. Именно так и поступает программа.\u003c/p\u003e\u003cp\u003eВходные данные:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e400 25\n380 27\n542\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОтвет:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eTRAM\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКомментарий. \u003cbr /\u003e Этот пример показывает, что если Кеша приходит одновременно с трамваем, он успевает уехать на этом трамвае (можно придумать аналогичный пример с автобусом).\u003c/p\u003e\u003cp\u003eПридумайте свои примеры входных данных и удостоверьтесь, что ваша программа выводит правильный ответ.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eВажно!\u003c/strong\u003e Придумывая свои примеры, также продумывайте, какую ситуацию они иллюстрируют. Конечно, проверка на произвольных входных данных тоже нужна, но необходимо рассмотреть и \u0026quot;крайние\u0026quot; случаи, как это было сделано выше. Действительно, мы проверили, что програма выводит корректный результат не только в \u0026quot;общем\u0026quot; случае (первые два примера входных данных), но и в ситуациях, когда Кеша должен дождаться первого автобуса / трамвая, когда Кеша приходит на остановку одновременно с каким-либо видом транспорта, когда и автобус, и трамвай приезжают одновременно. \u003c/p\u003e\u003cp\u003eМы ограничивались проверкой для одного из видов транспорта потому, что вычисления для обоих видов транспорта выполняются одной и той же функцией. В случае же применения метода \u0026quot;копировать — вставить\u0026quot; с последующей заменой переменных настоятельно рекомендуется тестировать оба случая независимо. \u003c/p\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003ch4\u003eCинтаксис циклических операторов\u003c/h4\u003e\u003cp\u003eПростой \u003cstrong\u003e\u003ci\u003eцикл с предусловием\u003c/i\u003e\u003c/strong\u003e выглядит так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003ewhile (\u0026lt;условие\u0026gt;) {\n   \u0026lt;операторы\u0026gt;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eУсловие — это логическое выражение, т.е. оно может принимать значение \u003ccode\u003etrue\u003c/code\u003e или \u003ccode\u003efalse\u003c/code\u003e. Обратите внимание, что условие обязательно заключать в круглые скобки, а каждый оператор должен завершаться точкой с запятой. Если оператор один, то фигурные скобки можно не писать (это относится и к другим циклам, которые описаны ниже).\u003c/p\u003e\u003cp\u003eКак работает этот цикл? \u003cbr /\u003e 1. Выполняется проверка условия. \u003cbr /\u003e 2. Если условие истинно (\u003ccode\u003etrue\u003c/code\u003e), то выполняются записанные в теле цикла операторы. Когда будут выполнены все операторы, возвращаемся к п.1. Если условие ложно (\u003ccode\u003efalse\u003c/code\u003e), то осуществляется переход к оператору, следующему непосредственно за циклом.\u003c/p\u003e\u003cp\u003eПрактический вывод из этого описания состоит в том, что в теле цикла должны присутствовать операторы, меняющие условие цикла (иначе цикл будет работать бесконечно, а в большинстве случаев это не нужно).\u003c/p\u003e\u003cp\u003eИногда бывает удобно выполнять первую итерацию цикла без проверки условия. В этом случае может оказаться полезен \u003cstrong\u003e\u003ci\u003eцикл с постусловием\u003c/i\u003e\u003c/strong\u003e. Он выглядит так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003edo {\n   \u0026lt;операторы\u0026gt;\n}\nwhile (\u0026lt;условие\u0026gt;) \n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКак работает этот цикл? \u003cbr /\u003e 1. Выполняются операторы, записанные в теле цикла. \u003cbr /\u003e 2. Выполняется проверка условия. Если условие истинно (\u003ccode\u003etrue\u003c/code\u003e), то возвращаемся к п.1. Если условие ложно (\u003ccode\u003efalse\u003c/code\u003e), то осуществляется переход к оператору, следующему непосредственно за циклом.\u003c/p\u003e\u003cp\u003eЕщё один цикл с предусловием — цикл \u003ccode\u003efor\u003c/code\u003e. Он имеет более сложную структуру, нежели \u003ccode\u003ewhile\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003efor (\u0026lt;секция инициализации\u0026gt;; \u0026lt;условие\u0026gt;; \u0026lt;секция итерации\u0026gt;){\n    \u0026lt;операторы\u0026gt;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eУсловие имеет тот же смысл, что и в предыдущих циклах. \u003c/p\u003e\u003cp\u003eСекция инициализации может содержать операторы присваивания значений каким-либо переменным, которые могут быть совмещены с объявлениями этих переменных. Если переменные объявлены в секции инициализации, то по завершении цикла они прекратят свое существование. В частности, это означает, что имена переменных можно будет использовать повторно — однако лучше не злоупотреблять такой возможностью. Вполне допустимо, например, использовать \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e или \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e в качестве счётчиков в нескольких независимых циклах. \u003c/p\u003e\u003cp\u003eСекция итерации может содержать операторы присваивания, изменяющие какие-либо переменные. \u003c/p\u003e\u003cp\u003eЕсли секции инициализации и итерации содержат несколько операторов присваивания, они разделяются запятыми. (На самом деле есть ряд тонких моментов, но представляется, что на этапе первого знакомства с циклами их можно опустить).\u003c/p\u003e\u003cp\u003eЛюбая из секций цикла \u003ccode\u003efor\u003c/code\u003e может быть пустой (причём пустыми могут быть и две, и даже все три секции одновременно). Однако точки с запятыми при этом всё равно должны ставиться (они разграничивают секции и потому необходимы). \u003c/p\u003e\u003cp\u003eЦикл \u003ccode\u003efor\u003c/code\u003e работает следующим образом: \u003cbr /\u003e 0. Однократно выполняются операторы секции инициализации (если есть). \u003cbr /\u003e 1. Проверяется условие. Если оно истинно, то выполняются операторы тела цикла, если же ложно — цикл завершается, управление передается оператору, следующему за циклом. \u003cbr /\u003e 2. После выполнения операторов тела цикла выполняются операторы секции итерации (если есть). После этого происходит переход к п.1\u003c/p\u003e\u003cp\u003eВажно отметить, что работа всех циклов описана в предположении, что в теле цикла нет операторов \u003ccode\u003ebreak\u003c/code\u003e или \u003ccode\u003econtinue\u003c/code\u003e, которые меняют \u0026quot;естественный ход\u0026quot; цикла. Оператор \u003ccode\u003ebreak\u003c/code\u003e прерывает исполнение цикла в том месте, где он записан; управление передается оператору, следующему за циклом. Оператор \u003ccode\u003econtinue\u003c/code\u003e прерывает текущую итерацию цикла и передает управление в заголовок цикла. \u003c/p\u003e\u003cp\u003eИ оператор \u003ccode\u003ebreak\u003c/code\u003e, и оператор \u003ccode\u003econtinue\u003c/code\u003e могут использоваться вместе с \u003cem\u003eметкой\u003c/em\u003e. Метка — это некоторая последовательность символов, подчиняющаяся тем же правилам, что и имя переменной. Метка может быть расположена перед заголовком какого-либо цикла. В этом случае, если после \u003ccode\u003ebreak\u003c/code\u003e будет указана эта же метка, то прерван будет именно этот цикл. Если же метка будет указана после \u003ccode\u003econtinue\u003c/code\u003e, то, соответственно, управление будет передано именно в этот заголовок цикла. Общее правило состоит в том, что передавать управление можно только изнутри наружу — т.е. оператор \u003ccode\u003ebreak\u003c/code\u003e или \u003ccode\u003econtinue\u003c/code\u003e, используемый с меткой, должен находиться внутри того цикла, который отмечен меткой (например, допустимо, чтобы оператор \u003ccode\u003ebreak\u003c/code\u003e находился внутри цикла, вложенного в другой цикл, и прерывал именно этот другой цикл). \u003c/p\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003ch4\u003eПример решения задачи\u003c/h4\u003e\u003cp\u003eВ этом разделе циклы используются в разных ситуациях. Одной из типичных ситуаций является необходимость обработки данных при вводе, и сначала мы рассмотрим достаточно простую задачу, иллюстрирующую такую ситуацию.\u003c/p\u003e\u003cp\u003eНо сначала — совет, который, возможно, покажется вам странным. \u003c/p\u003e\u003cp\u003eПрочтите условие задачи и пролистайте этот длинный текст до того места, где приводится решение целиком. Вы уже достаточно знакомы с синтаксисом, чтобы прочесть его. Если решение кажется вам понятным, попробуйте написать решение самой первой задачи из списка. Если решение не показалось понятным или же не получается написать решение первой задачи — тогда приступайте к чтению текста. В тексте явно выделены три подзадачи, так что если вам непонятна только одна из них, попробуйте сначала прочесть фрагмент текста, относящийся непосредственно к ней. \u003c/p\u003e\u003cp\u003eКогда будете читать текст, не надо стремиться запомнить все эти пространные рассуждения. Вполне достаточно понять, почему программа написана именно таким образом. Если какие-то моменты стали понятными — нет ничего плохого в том, чтобы пропустить какие-то абзацы. Этот текст в значительной мере является \u0026quot;сборником\u0026quot; ответов на вопросы начинающих программистов, и не все эти вопросы возникнут у вас. Однако если они всё-таки возникнут, есть надежда, что вы сможете найти ответ в нижеследующем рассказе. Ну а если не сможете — задавайте вопросы в комментариях или личных сообщениях.\u003c/p\u003e\u003cp\u003eКонечно, если вас не пугают длинные тексты, да и просто есть настроение — читайте всё подряд. Но помните, что научиться решать задачи можно только решая задачи, а не читая про то, как их надо решать.\u003c/p\u003e\u003cp\u003e\u003ci\u003eЗадача \u0026quot;О решении задач\u0026quot;\u003c/i\u003e\u003c/p\u003e\u003cp\u003eКеша готовился к экзамену в течение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e дней. Каждый день он записывал количество задач, которое ему удалось решить. Теперь у него есть последовательность чисел \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e , и он хочет узнать, во-первых, сколько всего задач он решил, во-вторых, максимальное количество задач, которое он смог решить за один день, и, в-третьих, количество дней, в которые он решал максимальное количество задач.\u003c/p\u003e\u003cp\u003e\u003ci\u003eВходные данные\u003c/i\u003e\u003c/p\u003e\u003cp\u003eВ первой строке содержится целое число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(1 ≤ \u003ci\u003en\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e)\u003c/span\u003e — количество дней, в течение которых Кеша готовился к экзамену. \u003c/p\u003e\u003cp\u003eВо второй строке содержится \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e целых чисел \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(0 ≤ \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ 1000, \u003ci\u003ei\u003c/i\u003e \u003d 1, 2, ..., \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — количество решённых в день \u003cspan class\u003d\"tex-span\"\u003e#\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e задач.\u003c/p\u003e\u003cp\u003e\u003ci\u003eВыходные данные\u003c/i\u003e\u003c/p\u003e\u003cp\u003eВыведите целые числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e — общее количество решённых задач, максимальное количество задач, которое удалось решить Кеше в течение одного дня, и количество дней, в которые он решал максимальное количество задач.\u003c/p\u003e\u003cp\u003e\u003cem\u003eРешение\u003c/em\u003e\u003c/p\u003e\u003cp\u003eОпишем постановку задачи чуть более формально. Для последовательности целых неотрицательных чисел \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e нужно посчитать сумму элементов, найти максимальный элемент и посчитать, сколько раз максимальный элемент встречается в последовательности.\u003c/p\u003e\u003cp\u003eМы будем писать программу \u0026quot;по частям\u0026quot;: сначала научимся подсчитывать сумму элементов, затем дополним программу так, чтобы находить максимальный элемент, а уже после этого будем решать задачу подсчёта количества максимальных элементов. Такой подход использован из \u0026quot;методических\u0026quot; соображений, чтобы по отдельности пояснить каждое из действий. Если вы чётко представляете себе каждое из действий, нет необходимости писать программу \u0026quot;в несколько проходов\u0026quot;. \u003c/p\u003e\u003cp\u003eСоздайте новый проект с названием \u003ccode\u003eproblemssolving\u003c/code\u003e, в нём — класс \u003ccode\u003eProblemsSolving\u003c/code\u003e (он будет \u0026quot;запускающим\u0026quot;). Не забудьте поставить галочку, автоматически формирующую в классе функцию \u003ccode\u003emain()\u003c/code\u003e. Также можно удалить имя пакета в строке \u003ccode\u003ePackage\u003c/code\u003e (если не удалите — ничего страшного, эту задачу мы не будем сдавать в проверяющие системы, а при локальной работе нет разницы, работаете вы с именованным пакетом или с пакетом по умолчанию). \u003c/p\u003e \u003cpre\u003e\u003ccode\u003epublic class ProblemsSolving {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eСледующий шаг — создание класса, содержащего \u0026quot;логику\u0026quot;. Назовите его \u003ccode\u003eProblemsDay\u003c/code\u003e. Входные данные — целое число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e и последовательность из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e чисел \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Поскольку \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e заранее неизвестно и может быть велико (до \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e), то объявить такое количество переменных \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e нереально (да и бессмысленно). \u003cbr /\u003e \u003cem\u003eЕсли вы изучали программирование на каком-либо другом языке, то можете предположить, что здесь была бы уместна структура данных, способная хранить перенумерованный набор элементов (обычно такая структура называется \u0026quot;массив\u0026quot; или \u0026quot;список\u0026quot;). Но, во-первых, мы ещё не изучали такие структуры данных в Java, и, во-вторых, как мы увидим из решения, нет необходимости хранить все элементы последовательности.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eПоэтому в классе мы опишем только переменную \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, а работу с последовательностью данных обсудим чуть позже. Выходными данными будут три целых числа, и такие переменные мы тоже опишем в классе. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003epublic class ProblemsSolving {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass ProblemsDay {\n\t\n\t\n\tint n;\n\tint s;\n\tint z;\n\tint d;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003csmall\u003e \u003cem\u003e\u003cb\u003eЗамечание\u003c/b\u003e\u003c/em\u003e. \u003c/small\u003e \u003cbr /\u003e \u003csmall\u003e Мы пока не слишком много внимания уделяли типам данных: если целое — значит,\u003ccode\u003eint\u003c/code\u003e, если вещественное — \u003ccode\u003edouble\u003c/code\u003e, если строка — \u003ccode\u003eString\u003c/code\u003e, если булево значение — \u003ccode\u003eboolean\u003c/code\u003e (кажется, его и вовсе ещё не использовали). Однако тип данных с точки зрения компьютера — это ещё и количество байтов, которое отводится для его записи. Для записи величины типа \u003ccode\u003eint\u003c/code\u003e отводится 4 байта, поэтому \u0026quot;без потерь\u0026quot; могут быть записаны числа примерно от \u003cspan class\u003d\"tex-span\"\u003e - 2·10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e до \u003cspan class\u003d\"tex-span\"\u003e2·10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e (от \u003cspan class\u003d\"tex-span\"\u003e - 2147483648\u003c/span\u003e до \u003cspan class\u003d\"tex-span\"\u003e2147483647\u003c/span\u003e, если точно). \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e В этой задаче нужно посчитать общее количество решённых задач. Чтобы понять, какое максимальное число может получиться в ответе, предположим, что Кеша решал задачи в течение максимально возможного по условию количества дней \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e, при этом каждый день он решал максимально возможное по условию количество задач, т.е. все \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e были равны \u003cspan class\u003d\"tex-span\"\u003e1000\u003c/span\u003e. В этом случае \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e8\u003c/sup\u003e\u003c/span\u003e, что вполне помещается в тип \u003ccode\u003eint\u003c/code\u003e, и, значит, его можно использовать. Если бы условие допускало, например, что Кеша может решать до \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e задач в день, то мы получили бы верхнюю оценку для \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e10\u003c/sup\u003e\u003c/span\u003e. Такое число не может быть корректно записано в типе \u003ccode\u003eint\u003c/code\u003e, и нужно было бы использовать тип \u003ccode\u003elong\u003c/code\u003e. \u003c/small\u003e\u003c/p\u003e\u003cp\u003eДля ввода данных мы, как и всегда, будем использовать объект класса \u003ccode\u003eScanner\u003c/code\u003e. Однако теперь мы опишем его в классе, а не в конструкторе, как раньше. Дело в том, что этот объект понадобится нам не только в конструкторе, но и в методе \u003ccode\u003esolve()\u003c/code\u003e, поскольку чтение и обработку последовательности \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e мы будем выполнять именно в этом методе. Создавать объект мы по-прежнему будем в конструкторе, а вот завершать работу с ним — в конце метода \u003ccode\u003esolve()\u003c/code\u003e. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass ProblemsDay {\n\t\n\tProblemsDay() {\n\t\tin \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t}\n\t\n\tvoid solve() {\n\t\t\n\t\tin.close();\n\t}\n\t\n\t\n\tScanner in;\n\t\n\tint n;\n\tint s;\n\tint z;\n\tint d;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТеперь обсудим, как организовать \u003cem\u003e\u003cb\u003eподсчёт общего количества решённых задач\u003c/b\u003e\u003c/em\u003e. \u003c/p\u003e\u003cp\u003eКак действовал бы человек, если бы ему последовательно называли какие-то числа, сказав, что в конце спросят их общую сумму? Конечно, он не пытался бы запомнить их все и только потом сложить. Он запомнил бы первое число; затем, когда ему назвали бы второе — прибавил бы второе к первому и запомнил бы сумму. Первое число после этого помнить ему уже не нужно. Точно так же он поступил бы, когда ему назвали бы третье число: прибавил бы его к сумме первого и второго и запомнил бы результат. \u003c/p\u003e\u003cp\u003eМожно сказать, что для каждого очередного числа последовательность действий выглядит следующим образом: \u003cbr /\u003e \u003cem\u003eуслышал очередное число — прибавил это число к уже имеющейся сумме — запомнил результат\u003c/em\u003e \u003cbr /\u003e После того как все \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e чисел будут названы, их сумма будет известна. \u003c/p\u003e\u003cp\u003eЕдинственный момент, который требует небольшой коррекции, — в нашем пояснении человек запоминал первое число, а не прибавлял его к уже имеющейся сумме. Чтобы действия с первым числом не отличались от действий со всеми остальными числами, мы можем считать, что исходно имеющаяся сумма была равна нулю (добавление нуля к любому числу не изменит это число). \u003c/p\u003e\u003cp\u003eКак, наверное, понятно, имеющейся суммой в нашем случае будет переменная \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, а \u0026quot;услышал число\u0026quot; будет означать, что мы прочитали очередное введённое с клавиатуры число.\u003c/p\u003e\u003cp\u003eДля записи повторяющихся действий воспользуемся циклом \u003ccode\u003efor\u003c/code\u003e. Поскольку изменения вносились только в метод \u003ccode\u003esolve()\u003c/code\u003e, приведён только его код. Ниже (после фрагмента программы) — подробные пояснения записи.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tvoid solve() {\n\t\ts \u003d 0;\n\t\tfor (int i \u003d 1; i \u0026lt;\u003d n; i++) {\n\t\t\tint p \u003d in.nextInt();\n\t\t\ts \u003d s + p;\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eИтак, \u003ccode\u003es \u003d 0\u003c/code\u003e — это как раз отражение того факта, что исходно имеющаяся сумма должна быть равна нулю. Далее записан оператор цикла \u003ccode\u003efor\u003c/code\u003e. В его секции инициализации объявляется переменная \u003ccode\u003ei\u003c/code\u003e: \u003ccode\u003eint i \u003d 1\u003c/code\u003e. Эта переменная будет выполнять роль индекса для переменной \u003ccode\u003ep\u003c/code\u003e, а по завершении цикла прекратит своё существование. Секция условия показывает, что цикл будет выполняться, пока значение \u003ccode\u003ei\u003c/code\u003e будет оставаться в пределах отрезка \u003ccode\u003e[1..n]\u003c/code\u003e. Секция итерации содержит оператор инкремента, увеличивающий значение \u003ccode\u003ei\u003c/code\u003e на единицу. \u003c/p\u003e\u003cp\u003eВообще говоря, условия, содержащие \u0026quot;составной знак\u0026quot; (\u003ccode\u003e\u0026lt;\u003d\u003c/code\u003e) считаются менее удачным решением, чем условия, содержащие \u0026quot;простой\u0026quot; знак. Поэтому во многих руководствах по программированию (и по стилю кода) рекомендуют при возможности использовать именно знаки \u003ccode\u003e\u0026lt;\u003c/code\u003e и \u003ccode\u003e\u0026gt;\u003c/code\u003e вместо \u003ccode\u003e\u0026lt;\u003d\u003c/code\u003e и \u003ccode\u003e\u0026gt;\u003d\u003c/code\u003e. В нашей программе мы могли бы, например, написать так: \u003ccode\u003ei \u0026lt; n+1\u003c/code\u003e. Однако вряд ли это хороший подход: рекомендации не использовать составные знаки обосновывают именно тем, что знак \u003ccode\u003e\u003d\u003c/code\u003e можно забыть поставить. Но точно так же можно забыть поставить и \u003ccode\u003e+1\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eВпрочем, есть способ сделать всё \u0026quot;красиво\u0026quot;: нужно начать нумерацию с 0. Тогда последний элемент будет иметь номер не \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, а \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e, и условие можно будет записать как \u003ccode\u003ei \u0026lt; n\u003c/code\u003e. Конечно, поначалу это может выглядеть непривычно, но в очень многих языках программирования нумерацию элементов принято начинать с нуля. Поэтому немного отредактируем написанное.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tvoid solve() {\n\t\ts \u003d 0;\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\t\tint p \u003d in.nextInt();\n\t\t\ts \u003d s + p;\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eИ, конечно, продолжим обсуждение цикла \u003ccode\u003efor\u003c/code\u003e. Напомним, что в цикле сначала единожды выполняется секция инициализации — в нашем случае объявляется переменная \u003ccode\u003ei\u003c/code\u003e, которой при объявлении сразу же присваивается нулевое значение. Затем повторяется следующий набор действий: \u003cem\u003eпроверка условия — операторы тела цикла — секция итерации\u003c/em\u003e — до тех пор, пока условие выполняется. Когда оно перестанет выполняться, программа переходит к оператору, следующему за циклом (в нашем случае это \u003ccode\u003ein.close()\u003c/code\u003e).\u003c/p\u003e\u003cp\u003eВ теле цикла сейчас у нас записаны (пока) два оператора. Первый из них, \u003ccode\u003eint p \u003d in.nextInt()\u003c/code\u003e, объявляет целочисленную переменную \u003ccode\u003ep\u003c/code\u003e и сразу же присваивает ей значение, прочитанное из входного потока данных объектом \u003ccode\u003ein\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eЧтобы понять, как это работает, представьте себе, что все числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e записаны подряд на полоске бумаги. По этой полоске бумаги двигается \u0026quot;окошко\u0026quot; (вы наверняка видели календари, в которых текущее число выделяется перемещаемой пластиковой рамкой). Метод \u003ccode\u003enextInt()\u003c/code\u003e каждый раз перемещает окошко на один \u0026quot;шаг\u0026quot; — на следующее число. \u003c/p\u003e\u003cp\u003eНа первой итерации цикла сначала будет выполнена проверка условия \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Поскольку \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u003d 0\u003c/span\u003e, а \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e по условию должно быть равно хотя бы \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, первая итерация будет выполняться всегда. После проверки условия управление будет передано телу цикла. \u003c/p\u003e\u003cp\u003eВ теле цикла будет создана переменная \u003ccode\u003ep\u003c/code\u003e, и в неё будет записано значение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e. Создание переменной подразумевает выделение памяти для хранения её значения и назначение имени этой области памяти. Мы уже упоминали, что переменная типа \u003ccode\u003eint\u003c/code\u003e нуждается в 4 байтах памяти для хранения значения. Поэтому будет выделена область памяти размером 4 байта, которой будет назначено имя \u003ccode\u003ep\u003c/code\u003e. Однако это имя будет привязано именно к этой области памяти только на этой итерации цикла. Это отвечает нашему описанию человека, суммирующего числа: услышав очередное число, он помнит его — но лишь до тех пор, пока не прибавит его к имеющейся сумме. Дальше ему достаточно помнить только результат. \u003c/p\u003e\u003cp\u003eКогда очередное значение из входного потока прочитано, нужно прибавить его к (уже имеющейся сумме) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e. Это делает оператор \u003ccode\u003es \u003d s + p\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eНапомним (на всякий случай), как работает оператор присваивания. Сначала вычисляется адрес области памяти, в которую должен быть помещён результат. Этот адрес вычисляется по имени \u003ccode\u003es\u003c/code\u003e, с которым связана область памяти. Затем вычисляется значение выражения в правой части оператора присваивания: происходит обращение сначала к области памяти, связанной с именем \u003ccode\u003es\u003c/code\u003e, и чтение значения, записанного в этой области; затем происходит обращение к области памяти, связанной с именем \u003ccode\u003ep\u003c/code\u003e, и чтение значения, записанного в этой области. После чего прочитанные значения складываются (на этом этапе задействованы регистры процессора, именно в них временно хранится результат), и результат помещается по адресу, вычисленному на первом этапе. Поскольку адрес результата связан с переменной \u003ccode\u003es\u003c/code\u003e, прежнее значение, которое там было (до сложения) затирается, а на его место записывается новое значение. \u003c/p\u003e\u003cp\u003eБольше в теле цикла операторов нет, и управление переходит к секции итерации. Значение переменной \u003ccode\u003ei\u003c/code\u003e увеличивается на 1 и становится равным 1. На этом первая итерация завершена. \u003c/p\u003e\u003cp\u003eВторая (и любая последующая) итерация будет отличаться от первой лишь тем, что в создаваемую переменную \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e будет прочитываться уже не \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, а \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e (или другое значение, соответствующее номеру итерации). И, конечно, в какой-то момент значение i станет равным \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, после чего условие \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003en\u003c/i\u003e\u003c/span\u003e перестанет выполняться. Цикл завершится, а в переменной \u003ccode\u003es\u003c/code\u003e будет храниться общее количество решённых Кешей задач.\u003c/p\u003e\u003cp\u003eРассмотрим, как работает написанный нами цикл, на примере. Пусть входные данные таковы (Кеша решал задачи в течение 8 дней, во второй строке приведено количество решённых задач для каждого из дней):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e8\n4 2 4 7 5 7 7 3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВероятно, проще всего составить таблицу пошаговой трассировки. Обратите внимание, что мы указываем значение переменной \u003ccode\u003ei\u003c/code\u003e в начале итерации; после выполнения тела цикла выполняется ещё и оператор из секции итерации, увеличивающий значение \u003ccode\u003ei\u003c/code\u003e на 1.\u003c/p\u003e \u003ctable\u003e   \u003ctbody\u003e\u003ctr\u003e     \u003cth\u003e Номер итерации \u003c/th\u003e     \u003cth\u003e i \u003c/th\u003e     \u003cth\u003e p \u003c/th\u003e     \u003cth\u003e s \u003c/th\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e До цикла \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e 0 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 1 \u003c/td\u003e     \u003ctd\u003e 0 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 2 \u003c/td\u003e     \u003ctd\u003e 1 \u003c/td\u003e     \u003ctd\u003e 2 \u003c/td\u003e     \u003ctd\u003e 6 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 3 \u003c/td\u003e     \u003ctd\u003e 2 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 10 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 3 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 17 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 5 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 5 \u003c/td\u003e     \u003ctd\u003e 22 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 6 \u003c/td\u003e     \u003ctd\u003e 5 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 29 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 6 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 36 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 8 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 3 \u003c/td\u003e     \u003ctd\u003e 39 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e После цикла \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e 39 \u003c/td\u003e   \u003c/tr\u003e  \u003c/tbody\u003e\u003c/table\u003e\u003cp\u003eВ конце последней, восьмой, итерации значение \u003ccode\u003ei\u003c/code\u003e станет равным 8, и условие цикла \u003ccode\u003ei \u0026lt; n\u003c/code\u003e при \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 8\u003c/span\u003e перестанет выполняться. \u003c/p\u003e\u003cp\u003eСледует отметить, что значения в столбце \u0026quot;Номер итерации\u0026quot;, вообще говоря, излишни: их можно заменить значениями \u003ccode\u003ei\u003c/code\u003e (пусть и отличающимися на 1, но что мешает установить нумерацию итераций с 0?).\u003c/p\u003e\u003cp\u003eПеред тем как перейти к поиску максимума, напишем метод \u003ccode\u003eprint()\u003c/code\u003e: действительно, суммарное количество задач мы уже можем вывести.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tvoid solve() {\n\t\ts \u003d 0;\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\t\tint p \u003d in.nextInt();\n\t\t\ts \u003d s + p;\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tvoid print() {\n\t\tSystem.out.println(s);\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eСледующая подзадача, которую мы будем решать — поиск в последовательности максимального элемента или, в терминах задачи, \u003cem\u003e\u003cb\u003eпоиск максимального количества задач, решённых в течение одного дня\u003c/b\u003e\u003c/em\u003e. \u003c/p\u003e\u003cp\u003eВажный момент — мы не можем прочитать входные данные (или их часть) ещё раз. Это означает, что для поиска максимального элемента в последовательности нам придётся воспользоваться уже написанным циклом \u003ccode\u003efor\u003c/code\u003e, дополнив его тело соответствующими операторами. Конечно, какие-то операторы понадобится добавить до цикла.\u003c/p\u003e\u003cp\u003eКак и в предыдущий раз, попробуем представить себе действия человека, которому последовательно называют некоторые числа, предупредив, что в конце он должен сообщить максимальное из названных чисел. \u003c/p\u003e\u003cp\u003eКогда человеку называют первое число, он запомнит его, и будет считать максимальным — среди всех названных. Когда человеку называют второе число — он сравнит его с первым и запомнит большее из них. Точно так же он будет поступать и со всеми последующими числами. Т.е. его действия можно описать так: \u003cem\u003eуслышал очередное число — сравнил с максимальным среди названных ранее — запомнил максимальное из двух сравниваемых\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eИ вновь нам нужно скорректировать описанную последовательность действий так, чтобы она работала и для первого названного числа. Получается, что человек должен \u0026quot;помнить\u0026quot; какое-то число, которое гарантированно меньше, чем первое названное число — потому что ему нужно будет выбрать максимум из этих двух чисел, и этим максимумом должно оказаться именно первое названное число. \u003c/p\u003e\u003cp\u003eПо условию задачи \u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ 1000\u003c/span\u003e, так что в качестве исходного значения максимума нам подойдёт любое отрицательное число. \u003c/p\u003e\u003cp\u003e\u003csmall\u003e Вообще говоря, можно использовать в качестве исходного значения максимума и 0, но у отрицательного числа есть важное преимущество. Если в качестве ответа мы получим 0, это может просто означать, что Кеша не решил ни одной задачи за весь срок подготовки к экзамену (что в принципе возможно). А вот если в качестве ответа мы получим отрицательное число, это будет свидетельствовать, что наша программа не выполнила поиск максимума. Похожий подход — инициализировать переменную значением, которое она не может и не должна принимать при нормальном выполнении программы — может оказаться весьма полезен и в ряде других ситуаций. \u003c/small\u003e\u003c/p\u003e\u003cp\u003eДля хранения максимума будем использовать переменную \u003ccode\u003ez\u003c/code\u003e (как и предлагалось в условии задачи). Доработанный код будет выглядеть следующим образом:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e        void solve() {\n\t\ts \u003d 0;\n\t\tz \u003d -1;\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\t\tint p \u003d in.nextInt();\n\t\t\ts \u003d s + p;\n\t\t\tif (p \u0026gt; z) {\n\t\t\t\tz \u003d p;\n\t\t\t}\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tvoid print() {\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(z);\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКак можно видеть, \u003ccode\u003ez\u003c/code\u003e инициализируется значением \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e, после чего на каждой итерации цикла происходит её сравнение с очередным прочитанным из входных данных значением. Если прочитанное значение оказывается больше максимума из уже прочитанных, максимум из прочитанных перезаписывается.\u003c/p\u003e\u003cp\u003eДополним таблицу пошаговой трассировки:\u003c/p\u003e \u003ctable\u003e   \u003ctbody\u003e\u003ctr\u003e     \u003cth\u003e Номер итерации \u003c/th\u003e     \u003cth\u003e i \u003c/th\u003e     \u003cth\u003e p \u003c/th\u003e     \u003cth\u003e s \u003c/th\u003e     \u003cth\u003e z \u003c/th\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e До цикла \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e 0 \u003c/td\u003e     \u003ctd\u003e -1 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 1 \u003c/td\u003e     \u003ctd\u003e 0 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 2 \u003c/td\u003e     \u003ctd\u003e 1 \u003c/td\u003e     \u003ctd\u003e 2 \u003c/td\u003e     \u003ctd\u003e 6 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 3 \u003c/td\u003e     \u003ctd\u003e 2 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 10 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 3 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 17 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 5 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 5 \u003c/td\u003e     \u003ctd\u003e 22 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 6 \u003c/td\u003e     \u003ctd\u003e 5 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 29 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 6 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 36 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 8 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 3 \u003c/td\u003e     \u003ctd\u003e 39 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e После цикла \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e 39 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e   \u003c/tr\u003e  \u003c/tbody\u003e\u003c/table\u003e\u003cp\u003eКак можно видеть, уже на четвёртой итерации \u003ccode\u003ez\u003c/code\u003e обретёт свое окончательное значение. Ни на одной из итераций, начиная с пятой, условие \u003ccode\u003ep \u0026gt; z\u003c/code\u003e выполняться уже не будет.\u003c/p\u003e\u003cp\u003eНаконец, рассмотрим последнюю подзадачу — \u003cem\u003e\u003cb\u003eподсчет количества дней, в каждый из которых Кеша решал максимальное количество задач\u003c/b\u003e\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eСнова обсудим, как действовал бы человек, которому последовательно называют числа, а в конце просят назвать не только максимальное из них, но и количество раз, которое оно встретилось в последовательности.\u003c/p\u003e\u003cp\u003eВозможно, сейчас тот случай, когда на конкретном примере разобраться будет проще. Рассмотрим наш \u0026quot;тестовый пример\u0026quot;\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e8\n4 2 4 7 5 7 7 3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЕщё у нас есть переменная \u003ccode\u003ez\u003c/code\u003e, начальное значение которой задано как \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e, и переменная \u003ccode\u003ed\u003c/code\u003e, в которой мы будем хранить ответ на вопрос подзадачи (пока мы её никак не использовали и не инициализировали). \u003c/p\u003e\u003cp\u003eТакже мы сформулировали последовательность действий при поиске максимума: \u003cbr /\u003e \u003cem\u003eуслышал очередное число — сравнил с максимальным среди названных ранее — запомнил максимальное из двух сравниваемых\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eИтак, человеку называют число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u003d 4\u003c/span\u003e. Он сравнивает его с \u003ccode\u003ez \u003d -1\u003c/code\u003e (которое он помнит), и, поскольку \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u0026gt; \u003ci\u003ez\u003c/i\u003e\u003c/span\u003e, запоминает значение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e в переменной \u003ccode\u003ez\u003c/code\u003e. Это значение встретилось человеку впервые, и оно самое большое среди уже названных. Человек не знает, какие числа ему будут называть в дальнейшем, поэтому может сделать предположение, что число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u003d 4\u003c/span\u003e и есть максимальное во всей последовательности. В таком случае ему придётся сосчитать, сколько раз в последовательности ему встретится число \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eХранить количество максимальных значений он будет в переменной \u003ccode\u003ed\u003c/code\u003e, и в настоящий момент это количество равно \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e: действительно, мы впервые встретили такое число. \u003c/p\u003e\u003cp\u003eДалее человеку называют число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u003d 2\u003c/span\u003e. Он сравнивает его с \u003ccode\u003ez \u003d 4\u003c/code\u003e, и тут уже сравнение не в пользу \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e. В результате сравнения не меняется ни максимум, ни количество максимальных значений.\u003c/p\u003e\u003cp\u003eТеперь подошла очередь \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e \u003d 4\u003c/span\u003e. При сравнении условие \u003ccode\u003ep \u0026gt; z\u003c/code\u003e не выполняется, т.е. значение максимума меняться не должно (и это правильно). Однако количество максимальных значений должно измениться, ведь \u003ccode\u003ep \u003d\u003d z\u003c/code\u003e. Поэтому нам необходимо рассматривать ещё случай равенства очередного числа и максимума: если это так, то следует увеличить значение \u003ccode\u003ed\u003c/code\u003e на единицу (и \u003ccode\u003ed\u003c/code\u003e станет равным 2).\u003c/p\u003e\u003cp\u003eЗатем человеку называют число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e4\u003c/sub\u003e \u003d 7\u003c/span\u003e. Выполняется условие \u003ccode\u003ep \u0026gt; z\u003c/code\u003e, и это значит, что, во-первых, необходимо обновить максимум (\u003ccode\u003ez \u003d p\u003c/code\u003e), и, во-вторых, снова установить \u003ccode\u003ed\u003c/code\u003e равным \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e (чисел, равных \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e4\u003c/sub\u003e\u003c/span\u003e, в последовательности ещё не было).\u003c/p\u003e\u003cp\u003eЧисло \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e5\u003c/sub\u003e \u003d 5\u003c/span\u003e не приводит к каким-либо изменениям: оно не больше и не равно текущего максимума. А вот число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e6\u003c/sub\u003e \u003d 7\u003c/span\u003e изменит величину \u003ccode\u003ed\u003c/code\u003e: это второе значение, равное \u003cspan class\u003d\"tex-span\"\u003e7\u003c/span\u003e, встреченное в последовательности. Число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e7\u003c/sub\u003e \u003d 7\u003c/span\u003e увеличит \u003ccode\u003ed\u003c/code\u003e ещё на единицу, а число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e8\u003c/sub\u003e \u003d 3\u003c/span\u003e, как и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e5\u003c/sub\u003e\u003c/span\u003e, никаких изменений не вызовет.\u003c/p\u003e\u003cp\u003eИз наших рассуждений следует, что инициализировать \u003ccode\u003ed\u003c/code\u003e каким-либо значением необязательно. В принципе можно этого и не делать — переменные класса Java по умолчанию инициализирует \u0026quot;нулевым\u0026quot; значением (\u0026quot;нулевым\u0026quot; — поскольку ноль с точки зрения типа, отличного от \u003ccode\u003eint\u003c/code\u003e или \u003ccode\u003edouble\u003c/code\u003e, может выглядеть не как \u003ccode\u003e0\u003c/code\u003e; к примеру, переменные типа \u003ccode\u003eboolean\u003c/code\u003e по умолчанию получат значение \u003ccode\u003efalse\u003c/code\u003e). Результат \u003ccode\u003e0\u003c/code\u003e будет свидетельствовать об ошибке в программе: понятно, что максимальное значение должно встретиться как минимум один раз. Однако он не так \u0026quot;бросается в глаза\u0026quot;, как, например, \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e. Поэтому будет лучше, если в качестве начального значения \u003ccode\u003ed\u003c/code\u003e мы будем использовать не просто \u0026quot;заведомо невозможное\u0026quot;, но и \u0026quot;заметно ошибочное\u0026quot; значение \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Есть ещё важный довод в пользу инициализации переменных вручную вместо использования значений по умолчанию. \u003cbr /\u003e Если подходить к анализу нашего кода формально, присваивания значения величине \u003ccode\u003ed\u003c/code\u003e может и не произойти. Мы выбрали начальное значение \u003ccode\u003ez\u003c/code\u003e, исходя из ограничений в задаче (которые, как мы надеемся, соблюдаются в тестах). Но формально величины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e могут принимать любые значения, допустимые с точки зрения типа \u003ccode\u003eint\u003c/code\u003e. Если начальное значение \u003ccode\u003ez\u003c/code\u003e окажется большим (или равным), чем максимальное значение в последовательности \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, то условие \u003ccode\u003ep \u0026gt; z\u003c/code\u003e не выполнится ни разу, и переменная \u003ccode\u003ed\u003c/code\u003e не получит никакого \u0026quot;реального\u0026quot; значения. \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Заметим также, что значения по умолчанию не присваиваются переменным, которые объявлены внутри методов. Мы пока не рассматриваем подробно языковые тонкости; достаточно запомнить, что в большинстве случаев инициализировать переменные полезно, а если на этом настаивает компилятор — то и необходимо. \u003c/small\u003e\u003c/p\u003e\u003cp\u003eТеперь мы готовы записать доработанный код методов \u003ccode\u003esolve()\u003c/code\u003e и \u003ccode\u003eprint()\u003c/code\u003e. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tvoid solve() {\n\t\ts \u003d 0;\n\t\tz \u003d -1;\n\t\td \u003d -1;\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\t\tint p \u003d in.nextInt();\n\t\t\ts \u003d s + p;\n\t\t\tif (p \u0026gt; z) {\n\t\t\t\tz \u003d p;\n\t\t\t\td \u003d 1;\n\t\t\t}\n\t\t\telse if (p \u003d\u003d z) {\n\t\t\t\td++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tvoid print() {\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(z);\n\t\tSystem.out.println(d);\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбратите внимание, что сравнение \u003ccode\u003ep \u003d\u003d z\u003c/code\u003e мы записали в ветви \u003ccode\u003eelse\u003c/code\u003e. Если вы опустите \u003ccode\u003eelse\u003c/code\u003e, получите неправильный результат. Если сначала сработает условие \u003ccode\u003ep \u0026gt; z\u003c/code\u003e, то \u003ccode\u003ez\u003c/code\u003e получит в качестве значения именно \u003ccode\u003ep\u003c/code\u003e. Второй условный оператор (в отсутствие \u003ccode\u003eelse\u003c/code\u003e) будет выполняться независимо — и выполнится, поскольку после срабатывания первого \u003ccode\u003eif\u003c/code\u003e условие \u003ccode\u003ep \u003d\u003d z\u003c/code\u003e верное. В итоге \u003ccode\u003ed\u003c/code\u003e получит значение \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Да, конечно, можно записать правильный код с двумя независимыми \u003ccode\u003eif\u003c/code\u003e. Для этого следует при изменении максимального значения присваивать \u003ccode\u003ed\u003c/code\u003e не единицу, а ноль: \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e\u003c/small\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\t\t\tif (p \u0026gt; z) {\n\t\t\t\tz \u003d p;\n\t\t\t\td \u003d 0;\n\t\t\t}\n\t\t\tif (p \u003d\u003d z) {\n\t\t\t\td++;\n\t\t\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003csmall\u003e Однако этот \u0026quot;финт\u0026quot; похож на ситуацию, когда не все блоки \u003ccode\u003ecase\u003c/code\u003e оператора \u003ccode\u003eswitch\u003c/code\u003e завершаются оператором \u003ccode\u003ebreak\u003c/code\u003e. Такой подход может быть полезен, но он определённо проигрывает в \u0026quot;читабельности\u0026quot; (а, значит, в таком коде труднее найти ошибку). Общее правило таково, что пересечения \u0026quot;ветвей\u0026quot; в программе в большинстве случаев следует избегать. \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Так что если хочется сделать операторы \u003ccode\u003eif\u003c/code\u003e \u0026quot;независимыми\u0026quot;, придётся поменять порядок действий: \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e\u003c/small\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\t\t\tif (p \u003d\u003d z) {\n\t\t\t\td++;\n\t\t\t}\n\t\t\tif (p \u0026gt; z) {\n\t\t\t\tz \u003d p;\n\t\t\t\td \u003d 1;\n\t\t\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003csmall\u003e Воспринимается ли такой код лучше, чем предложенный в основном тексте — решать вам. \u003c/small\u003e\u003c/p\u003e\u003cp\u003eДля полноты картины приведём полную версию таблицы пошаговой трассировки.\u003c/p\u003e \u003ctable\u003e   \u003ctbody\u003e\u003ctr\u003e     \u003cth\u003e Номер итерации \u003c/th\u003e     \u003cth\u003e i \u003c/th\u003e     \u003cth\u003e p \u003c/th\u003e     \u003cth\u003e s \u003c/th\u003e     \u003cth\u003e z \u003c/th\u003e     \u003cth\u003e d \u003c/th\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e До цикла \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e 0 \u003c/td\u003e     \u003ctd\u003e -1 \u003c/td\u003e     \u003ctd\u003e -1 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 1 \u003c/td\u003e     \u003ctd\u003e 0 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 1 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 2 \u003c/td\u003e     \u003ctd\u003e 1 \u003c/td\u003e     \u003ctd\u003e 2 \u003c/td\u003e     \u003ctd\u003e 6 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 1 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 3 \u003c/td\u003e     \u003ctd\u003e 2 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 10 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 2 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 3 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 17 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 1 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 5 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 5 \u003c/td\u003e     \u003ctd\u003e 22 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 1 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 6 \u003c/td\u003e     \u003ctd\u003e 5 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 29 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 2 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 6 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 36 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 3 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 8 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 3 \u003c/td\u003e     \u003ctd\u003e 39 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 3 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e После цикла \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e 39 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 3 \u003c/td\u003e   \u003c/tr\u003e  \u003c/tbody\u003e\u003c/table\u003e\u003cp\u003eТакже приведём \u003cstrong\u003eполный текст\u003c/strong\u003e программы, решающей задачу.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport java.util.Scanner;\n\npublic class ProblemsSolving {\n\n\tpublic static void main(String[] args) {\n\t\tProblemsDay pr \u003d new ProblemsDay();\n\t\tpr.solve();\n\t\tpr.print();\n\t}\n\n}\n\nclass ProblemsDay {\n\t\n\tProblemsDay() {\n\t\tin \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t}\n\t\n\tvoid solve() {\n\t\ts \u003d 0;\n\t\tz \u003d -1;\n\t\td \u003d -1;\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\t\tint p \u003d in.nextInt();\n\t\t\ts \u003d s + p;\n\t\t\tif (p \u0026gt; z) {\n\t\t\t\tz \u003d p;\n\t\t\t\td \u003d 1;\n\t\t\t}\n\t\t\telse if (p \u003d\u003d z) {\n\t\t\t\td++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tvoid print() {\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(z);\n\t\tSystem.out.println(d);\n\t}\n\t\n\t\n\tScanner in;\n\t\n\tint n;\n\tint s;\n\tint z;\n\tint d;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДля тестирования программы можно использовать следующий набор тестов.\u003c/p\u003e\u003cp\u003e\u003cem\u003eВходные данные\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e8\n4 2 4 7 5 7 4 3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eВыходные данные\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e36\n7\n2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eКомментарий\u003c/em\u003e \u003cbr /\u003e Число, которое однажды становится максимальным, но потом перестаёт им быть, встречается в последовательности большее количество раз, чем \u0026quot;настоящий\u0026quot; максимум.\u003c/p\u003e\u003cp\u003e\u003cem\u003eВходные данные\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e8\n7 2 4 4 5 7 4 3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eВыходные данные\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e36\n7\n2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eКомментарий\u003c/em\u003e \u003cbr /\u003e Максимум встречается в последовательности на первом месте, нужно убедиться, что первое число обрабатывается корректно.\u003c/p\u003e\u003cp\u003e\u003cem\u003eВходные данные\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e8\n7 2 4 4 5 7 4 7\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eВыходные данные\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e40\n7\n3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eКомментарий\u003c/em\u003e \u003cbr /\u003e Максимум встречается в последовательности и на последнем месте, нужно убедиться, что последнее число обрабатывается корректно.\u003c/p\u003e\u003cp\u003e\u003cem\u003eВходные данные\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e3\n1000 1000 1000\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eВыходные данные\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e3000\n1000\n3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eКомментарий\u003c/em\u003e \u003cbr /\u003e Последовательность состоит только из максимумов.\u003c/p\u003e\u003cp\u003e\u003cem\u003eВходные данные\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e1\n0\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eВыходные данные\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e0\n0\n1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eКомментарий\u003c/em\u003e \u003cbr /\u003e В последовательности содержится один элемент (он же максимум).\u003c/p\u003e\u003cp\u003eПопробуйте придумать свои тестовые примеры (и обязательно сформулируйте, что именно они проверяют), чтобы убедиться в правильной работе программы. \u003c/p\u003e\u003cp\u003e\u003cem\u003eДополнение\u003c/em\u003e\u003c/p\u003e\u003cp\u003eПосле (успешной) сдачи задачи в проверяющую систему необходимо сдать задачу вашему преподавателю (преподаватель может группировать отчеты по нескольким задачам). Разумеется, если в течение длительного времени у вас не получается сдать задачу, это также повод обратиться к преподавателю или лектору. \u003c/p\u003e\u003cp\u003eПри сдаче задачи следует:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eобъяснить алгоритм работы программы;\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eпродемонстрировать самостоятельно составленные тестовые примеры и пояснить, что именно они проверяют;\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eобъяснить, почему использована та или иная синтаксическая конструкция;\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eобъяснить, почему те или иные переменные сделаны полями класса, а не локальными переменными;\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eответить на вопросы преподавателя.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003c/div\u003e","tags":["java","if","switch","cycles"]}}