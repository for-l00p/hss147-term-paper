{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1440688304,"rating":0,"authorHandle":"flash_7","modificationTimeSeconds":1440689385,"id":19999,"title":"\u003cp\u003eLight OJ 1269 — Consecutive Sum\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eCany anyone give me some hints how can i solve the problem using segment tree?\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem Link:\u003c/strong\u003e \u003ca href\u003d\"http://lightoj.com/volume_showproblem.php?problem\u003d1269\"\u003eConsecutive Sum\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem Description:\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eLittle Jimmy is learning how to add integers. As in decimal the digits are 0 to 9, it makes a bit hard for him to understand the summation of all pair of digits. Since addition of numbers requires the knowledge of adding digits. So, his mother gave him a software that can convert a decimal integer to its binary and a binary to its corresponding decimal. So, Jimmy\u0027s idea is to convert the numbers into binaries, and then he adds them and turns the result back to decimal using the software. It\u0027s easy to add in binary, since you only need to know how to add (0, 0), (0, 1), (1, 0), (1, 1). Jimmy doesn\u0027t have the idea of carry operation, so he thinks that\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e1 + 1 \u003d 0\n1 + 0 \u003d 1\n0 + 1 \u003d 1\n0 + 0 \u003d 0\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eUsing these operations, he adds the numbers in binary. So, according to his calculations, \u003ccode\u003e 3 (011) + 7 (111) \u003d 4 (100) \u003c/code\u003e\u003c/p\u003e\u003cp\u003eNow you are given an array of n integers, indexed from 0 to n-1, you have to find two indices i j in the array \u003ccode\u003e(0 ≤ i ≤ j \u0026lt; n)\u003c/code\u003e such that the summation (according to Jimmy) of all integers between indices i and j in the array, is maximum. And you also have to find two indices, p q in the array \u003ccode\u003e(0 ≤ p ≤ q \u0026lt; n)\u003c/code\u003e such that the summation (according to Jimmy) of all integers between indices p and q in the array, is minimum. You only have to report the maximum and minimum integers.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eInput\u003c/strong\u003e Input starts with an integer T (≤ 10), denoting the number of test cases.\u003c/p\u003e\u003cp\u003eEach case starts with a line containing an integer \u003ccode\u003en (1 ≤ n ≤ 50000)\u003c/code\u003e The next line contains n space separated non-negative integers, denoting the integers of the given array. Each integer fits into a 32 bit signed integer.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eOutput\u003c/strong\u003e For each case, print the case number, the maximum and minimum summation that can be made using Jimmy\u0027s addition.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSample Input:\u003c/strong\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e2\n5\n6 8 2 4 2\n5\n3 8 2 6 5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eOutput for Sample Input:\u003c/strong\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eCase 1: 14 2\nCase 2: 15 1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["segment tree","trie","advanced data structure"]}}