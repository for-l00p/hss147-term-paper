{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1521626546,"rating":0,"authorHandle":"Sammarize","modificationTimeSeconds":1521626546,"id":58486,"title":"\u003cp\u003eРазбор тренировки 21\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eЗадача A\u003c/h2\u003e\u003cp\u003eЭто очень простая задача. Пусть \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/dd/40/dd40e0454aa3887b4715dc1ce9d4d475070a00f4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, где — \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d9/a0/d9a081464a6ed85f6c6f4b447ba0b8a758b0e4e6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Предположим, слоник будет ходить только на 5 клеток. Тогда через \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/95/4d/954dfc4f9a7f1e2d5070a8dcd6e4664d80c23f59.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e ходов он достигнет точки \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1a/c4/1ac4a8617a63d2ae51918d1b6e5c0857fde67c42.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Теперь если заменить последний ход на \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7b/ad/7bad579b3e0d64aadfaea8d6a81f99cea7217adf.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, то за \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/24/44/244421bedfdd20f3ee6defa31866bf3e63421ddb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e ходов он как раз достигнет клетки \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Быстрее, чем за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e достичь клетки \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e нельзя, так как \u003cspan class\u003d\"tex-span\"\u003e5\u003ci\u003ek\u003c/i\u003e - 5 \u0026lt; \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eНапоминаем, что \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ed/96/ed962d1df8dc9bdadfe3f92f69a3cdd4b159f9c7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e можно легко найти по формуле \u003ccode\u003e(x+4)/5\u003c/code\u003e.\u003c/p\u003e\u003ch2\u003eЗадача B\u003c/h2\u003e\u003cp\u003eУ Лимака есть \u003cspan class\u003d\"tex-span\"\u003e240 - \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e минут, чтобы написать как можно больше задач. Заметим, что если Лимак успевает написать какие-то \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e задач, то он успевает написать первые \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e задач, потому что они самые быстрые. Поэтому вопрос о том, успевает ли Лимак написать \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e задач — это вопрос о том, успевает ли он написать именно первые \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e задач, то есть, верно ли, что \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f2/04/f204b532e09310049d52c842688354882605bdaf.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Значит, надо просто перебрать \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e от 0 до 10 и найти среди них максимальное такое \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, что \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f2/04/f204b532e09310049d52c842688354882605bdaf.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003ch2\u003eЗадача C\u003c/h2\u003e\u003cp\u003eОбозначим сумму всех монет за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e. Отметим, что если мы можем взять какие-то \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e монет так, чтобы их сумма была больше \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/62/c9/62c9f36b59d16d553b3d06d2f3ae29f5e93c5a5f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, то \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e наибольших монет тоже подходят на эту роль. Значит, вопрос о том, можем ли мы взять \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e монет так, чтобы их сумма была больше, чем \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/62/c9/62c9f36b59d16d553b3d06d2f3ae29f5e93c5a5f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e — это вопрос о том, правда ли, что \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e наибольших монет в сумме больше, чем \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/62/c9/62c9f36b59d16d553b3d06d2f3ae29f5e93c5a5f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Значит, мы можем просто отсортировать монеты в порядке убывания, например, так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003esort(a.begin(), a.end());\nreverese(a.begin(), a.end());\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eили так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003esort(a.begin(), a.end(), [](int x, int y) {return x \u0026gt; y;});\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eА затем перебрать все возможные \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e и найти минимальное такое \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, что сумма первых \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e элементов вектора \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e больше, чем \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/62/c9/62c9f36b59d16d553b3d06d2f3ae29f5e93c5a5f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Можно заранее посчитать все префиксные суммы, а можно их считать сумму заново на каждом шагу; можно использовать бинпоиск, а можно не использовать — зайдёт по-всякому, потому что ограничения всего лишь \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≤ 100\u003c/span\u003e.\u003c/p\u003e\u003ch2\u003eЗадача D\u003c/h2\u003e\u003cp\u003eПереформулируя условия задачи, можно сказать, что Вася ищет у строки подстроку максимальной длины такую, что в ней можно заменить не более, чем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e символов так, чтобы в ней все символы стали одинаковые, иными словами, такую подстроку, которой не более, чем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e букв \u003ccode\u003ea\u003c/code\u003e или \u003ccode\u003eb\u003c/code\u003e. Будем называть такую подстроку подходящей.\u003c/p\u003e\u003cp\u003eЯсно, что если мы нашли подходящую подстроку определённой длины, то подходящие подстроки всех меньших длин тем более найдутся. Значит, максимальную длину подходящей строки можно найти бинарный поиском.\u003c/p\u003e\u003cp\u003eЧтобы использовать бинарный поиск, надо научиться определять для данного \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e, существует ли подстрока длины ровно \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e, в которой присутствуют не более \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e букв \u003ccode\u003ea\u003c/code\u003e или \u003ccode\u003eb\u003c/code\u003e. Это легко сделать способом плавающего окна: найдём количество букв \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e на префиксе длины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e и дальше будем двигать позицию подстроки направо до упора. Продвигаясь направо на один символ, будем подправлять количество букв \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint L \u003d 0;\ninr R \u003d n + 1;\nwhile (R - L \u0026gt; 1) {\n    int M \u003d (L + R) / 2;\n    map\u0026lt;char, int\u0026gt; cnt;\n    for (int i \u003d 0; i \u0026lt; M; i++) cnt[s[i]]++;\n    bool found \u003d cnt[\u0027a\u0027] \u0026lt;\u003d k || cnt[\u0027b\u0027] \u0026lt;\u003d k;\n\n    for (int start \u003d 0; start + M \u0026lt; n; start++) {\n        cnt[s[start]]--;\n        cnt[s[start + M]]++;\n        if (cnt[\u0027a\u0027] \u0026lt;\u003d k || cnt[\u0027b\u0027] \u0026lt;\u003d k) found \u003d true;\n    }\n    \n    if (found) L \u003d M;\n    else R \u003d M;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eЗадача E\u003c/h2\u003e\u003cp\u003eЭта задача решается с помощью динамического программирования. А именно, мы можем посчитать для всех \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/cc/f3/ccf3282b6fdbc6c70b8c2ddd95828466a2fbcfee.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e две величины: \u003ccode\u003ecntD[k]\u003c/code\u003e — количество путей длины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, которые начинаются и заканчиваются в вершине \u003ccode\u003eD\u003c/code\u003e, и \u003ccode\u003ecntOther[k]\u003c/code\u003e — количество путей длины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, которые начинаются в вершине \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e, а заканчиваются в другой вершине. Легко заметить, что \u003ccode\u003ecntD[0] \u003d 1\u003c/code\u003e, \u003ccode\u003ecntOther[0] \u003d 0\u003c/code\u003e. Кроме того,\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ecntD[k + 1] \u003d cntOther[k];\ncntOther[k + 1] \u003d cntOther[k] * 2 + cntD[k] * 3;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eпоскольку из вершины \u003ccode\u003eD\u003c/code\u003e нельзя пойти в вершину \u003ccode\u003eD\u003c/code\u003e, но есть 3 способа пойти в другие вершины, а из другой вершины есть единственный способ пойти в вершину \u003ccode\u003eD\u003c/code\u003e и ещё два способа пойти в другие вершины.\u003c/p\u003e\u003ch2\u003eЗадача F\u003c/h2\u003e\u003cp\u003eВ задаче фигурируют суммы величин типа \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/53/3e/533e799f31fdd5496f40a8b830cd67c8b3fb8adb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, причём некоторые из этих модулей прибавляются, а некоторые — вычитаются. Сосредоточимся на таких отрезках \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e, что \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e чётно. Для всех таких отрезков \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/53/3e/533e799f31fdd5496f40a8b830cd67c8b3fb8adb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e прибавляется для чётного \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e и вычитаются для нечётного. Введём обозначение: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f6/be/f6be57dfbc0eb003a5d24d391dcc377365ff43e5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Для чётного \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e значение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e можно представить, как сумму нескольких последовательных \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eПосчитать максимальную такую сумму — это стандартная задача. Чтобы это сделать, можно посчитать префиксные суммы \u003ccode\u003epref_b[i]\u003c/code\u003e этой последовательности и далее рассмотреть для каждого \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e разность \u003ccode\u003epref_b[i] - pref_b[j]\u003c/code\u003e, где \u003ccode\u003epref_b[j]\u003c/code\u003e — минимальное значение \u003ccode\u003epref_b\u003c/code\u003e до момента \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Это \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e можно постоянно обновлять в процессе перебора индексов \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint j \u003d 0;\nint maxb \u003d 0;\nfor (int i \u003d 0; i \u0026lt;\u003d n; i++) {\n   maxb \u003d max(maxb, pref_b[i] - pref_b[j]);\n   if (pref_b[i] \u0026lt; pref_b[j]) j \u003d i;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eАналогично разбирается случай с нечётными \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e","tags":[]}}