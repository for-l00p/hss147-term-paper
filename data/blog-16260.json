{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1423342992,"rating":172,"authorHandle":"llaki","modificationTimeSeconds":1423372604,"id":16260,"title":"\u003cp\u003eRockethon 2015 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e(This is a beta version of editorial. It will be changed later)\u003c/p\u003e\u003cp\u003eI hope everybody enjoyed the contest. Here we\u0027ll present some of the author\u0027s solutions to the problems together with some other approaches that we came up with. The editorial is prepared by Lasha Lakirbaia, Anton Lomonos, and Ievgen Soboliev.\u003c/p\u003e\u003ch1\u003eA — Game\u003c/h1\u003e\u003cp\u003e(developed by Ievgen Soboliev \u0026amp; Eldar Bogdanov, editorial written by Lasha Lakirbaia)\u003c/p\u003e\u003cp\u003eThe problem can be solved with dynamic programming technique. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ewinner\u003c/i\u003e[\u003ci\u003ea\u003c/i\u003e][\u003ci\u003eb\u003c/i\u003e][\u003ci\u003emove\u003c/i\u003e]\u003c/span\u003e denote who wins if both players play optimally and the first has a balls left in his box, the second has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e balls left in his box and move defines who is to move next. To determine the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ewinner\u003c/i\u003e[\u003ci\u003ea\u003c/i\u003e][\u003ci\u003eb\u003c/i\u003e][\u003ci\u003emove\u003c/i\u003e]\u003c/span\u003e, we should consider all the possible moves the next player can make and see whether any of them lead into the position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ewinner\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e][\u003ci\u003ey\u003c/i\u003e][\u003ci\u003emove\u003c/i\u003e2]\u003c/span\u003e in which this player can win with optimal play. Thus, values of winner can be defined recursively.\u003c/p\u003e\u003cp\u003eOk it was a joke, the solution is just this one line: \u003cstrong\u003eprintln (n1 \u0026gt; n2 ? “First” : “Second”)\u003c/strong\u003e.\u003c/p\u003e\u003ch1\u003eB — Permutations\u003c/h1\u003e\u003cp\u003e(developed by Ievgen Soboliev \u0026amp; Eldar Bogdanov, editorial written by Lasha Lakirbaia)\u003c/p\u003e\u003cp\u003eFor a given array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e let’s call the value of that expression the \u003cem\u003evalue\u003c/em\u003e of that array.\u003c/p\u003e\u003cp\u003eFor the first subproblem, we can just consider all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e!\u003c/span\u003e permutations in lexicographic order and keep 2 variables — one of them should be the highest value so far, and the other should be the list of permutations with that highest value. Than we can update this variables like this: When he have a new permutation, if it has smaller value, we disregard it. If it has larger value, we assign the first variable this new value and to the second variable we assign 1-element list, containing this current permutation only. In the end we just pick \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e-th element from the second variable. From now on we’ll concentrate on solving the harder one.\u003c/p\u003e\u003cp\u003eFirst of all let’s find out which permutations have the highest values among all the permutations of \u003cspan class\u003d\"tex-span\"\u003e(1, 2, ..., \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. It\u0027s easy to note that whenever we have some \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e-element array, in the highest valued permutations the position of the smallest element of the array will be either first or the last in the permutation. This can be proved easily as follows: There can\u0027t be an optimal (highest valued) permutation where the smallest element is in the middle (I mean after the first and before the last), because moving this element to either beginning or ending would obviously increase the value, that would thus contradict the statement that the original permutation had the highest value. So we proved that the position of \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e should either be at the beginning or at the end of a highest valued permutation. Moreover, it’s easy to see that in both cases, the value will be the same. After we decide on which end \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e will be, than we can move on to the remaining array \u003cspan class\u003d\"tex-span\"\u003e(2, 3, ..., \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e and do the same for \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e as we did for \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Than we go on and do the same for \u003cspan class\u003d\"tex-span\"\u003e3, 4, ..., \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eFrom here we can clearly say what are all the permutations with the highest value — all the permutations which can be derived by the following algorithm: Consider numbers \u003cspan class\u003d\"tex-span\"\u003e(1, 2, ..., \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e in the reverse order. Each time add the current number to one of the ends of the current permutation (initially the permutation is empty). For example, for n\u003d5 the possible permutations are \u003cspan class\u003d\"tex-span\"\u003e(1, 2, 3, 4, 5), (1, 3, 5, 4, 2), (5, 4, 3, 2, 1)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(1, 2, 5, 4, 3)\u003c/span\u003e. One more important thing to note is that the number of highest valued permutations of any n-element array is equal to \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e, which easily follows from the way we’re constructing all these permutations. With all that said, the rest of the solution is pretty straightforward. Let’s consider numbers \u003cspan class\u003d\"tex-span\"\u003e1, 2, ..., \u003ci\u003en\u003c/i\u003e\u003c/span\u003e in this order and apply the following recursive approach: If we’re currently on \u003cstrong\u003epos\u003c/strong\u003e-th position and searching for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e-th element, having already decided the indices of all the elements less than pos, then there are \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e cases: We know that number of possible permutations is \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003epos\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e ≤ 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003epos\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e, then we put pos element in the beginning of the array and recursively go to the state \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003epos\u003c/i\u003e + 1, \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e. Otherwise, we’ll put pos in the end of the array and recursively go to the state \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003epos\u003c/i\u003e + 1, 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003epos\u003c/i\u003e - 1\u003c/sup\u003e - \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e. The total running time of this solution is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e, if implemented in optimal way but almost any kind of implementation of this idea would work, as the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is relatively small.\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote 1: From the solution it\u0027s visible that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e ≤ 2\u003csup class\u003d\"upper-index\"\u003e49\u003c/sup\u003e\u003c/span\u003e, and also for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 50\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e can be as big as \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e49\u003c/sup\u003e\u003c/span\u003e, which doesn\u0027t fit in int but fits in long.\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote 2: This last steps can also be implemented by just considering the binary representation of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e.\u003c/em\u003e\u003c/p\u003e\u003ch1\u003eC — Second Price Auction\u003c/h1\u003e\u003cp\u003e(developed by Ievgen Soboliev \u0026amp; Eldar Bogdanov, editorial written by Lasha Lakirbaia)\u003c/p\u003e\u003cp\u003eThis problem can be solved in many different ways. Here we’ll explain 3 of them. Let’s denote by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e the probability of second highest bid being equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. Obviously, possible values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e are only integers from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e10, 000\u003c/span\u003e. If we can calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e in that range, then the desired expected value is just \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4f/46/4f4603938cfc35a175ba155ddfe555ec39493e63.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Now let’s concentrate on calculating \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e for a given \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. These 3 solutions have different approaches to calculating the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFirst solution (the easiest) — brute force\u003c/p\u003e\u003cp\u003eLet’s consider every partition of a set of bidders into \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e subsets, such that in the first set each bidder had higher bid than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, in second set each bid was equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, while in the third set each bid was less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. As we assume that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e is the second highest bid, it’s easy to notice that the first set contains either \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e element, while the second set contains at least \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e element. (Also, if the first set is empty, the second set must contain at least \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e elements) Number of such partitions is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e·\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. After we have this partition, for each bidder we know if its bid should be more, equal or less then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. Probability of any of these can easily be counted in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e. So in the end we get the complexity of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e·\u003ci\u003en\u003c/i\u003e·\u003ci\u003emax\u003c/i\u003e(\u003ci\u003eR\u003c/i\u003e - \u003ci\u003eL\u003c/i\u003e + 1))\u003c/span\u003e, which is good enough for given constraints.\u003c/p\u003e\u003cp\u003eSecond solution — dynamic programming\u003c/p\u003e\u003cp\u003eLet’s consider the following dynamic programming approach. Denote by \u003cstrong\u003e(pos, moreCount, equalCount)\u003c/strong\u003e the state, when we already considered all bidders with indices less then \u003cstrong\u003epos\u003c/strong\u003e, the second largest bid in the end must be equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, currently the number of bidders with bid higher than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e is \u003cstrong\u003emoreCount\u003c/strong\u003e and the number of bidders with bid equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e is \u003cstrong\u003eequalCount\u003c/strong\u003e. Finally, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003epos\u003c/i\u003e, \u003ci\u003emoreCount\u003c/i\u003e, \u003ci\u003eequalCount\u003c/i\u003e)\u003c/span\u003e denotes the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e for this state. Note, that we don’t have to consider the states where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emoreCount\u003c/i\u003e \u0026gt; 1\u003c/span\u003e, because for them \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e) \u003d 0\u003c/span\u003e. Also, we don’t need to distinguish between states where some of them has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eequalCount\u003c/i\u003e \u003d 2\u003c/span\u003e and some of them has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eequalCount\u003c/i\u003e \u0026gt; 2\u003c/span\u003e. They have same values. So we’ll assume that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eequalCount\u003c/i\u003e \u0026lt; 3\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emoreCount\u003c/i\u003e \u0026lt; 2\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eTransitions for this dynamic programming are as follows: - Consider current bid to be higher than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. It’s only possible if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emoreCount\u003c/i\u003e \u003d 0\u003c/span\u003e, because otherwise the probability of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e will be \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emoreCount\u003c/i\u003e \u003d 0\u003c/span\u003e, the transition will be to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003epos\u003c/i\u003e + 1, 1, \u003ci\u003eequalCount\u003c/i\u003e)\u003c/span\u003e. - Consider current bid to be equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. It will lead us to a transition to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003epos\u003c/i\u003e + 1, \u003ci\u003emoreCount\u003c/i\u003e, \u003ci\u003emin\u003c/i\u003e(\u003ci\u003eequalCount\u003c/i\u003e + 1, 2))\u003c/span\u003e. - Consider current bid to be less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. Transition in the case will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003epos\u003c/i\u003e + 1, \u003ci\u003emoreCount\u003c/i\u003e, \u003ci\u003eequalCount\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eAll these cases have their respective probabilities, which are straightforward to calculate in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e. So as we see, the number of states of dynamic programming is O(n), while calculating each state take \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e. So in total, calculating \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time, which leads us to the solution of the initial problem in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e * \u003ci\u003emax\u003c/i\u003e(\u003ci\u003eR\u003c/i\u003e - \u003ci\u003eL\u003c/i\u003e + 1))\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThird solution — pure math\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e) \u003d \u003ci\u003ePr\u003c/i\u003e.(\u003ci\u003emaxBid\u003c/i\u003e \u003d \u003ci\u003eb\u003c/i\u003e, \u003ci\u003esecondMaxBid\u003c/i\u003e \u003d \u003ci\u003eb\u003c/i\u003e) + \u003ci\u003ePr\u003c/i\u003e.(\u003ci\u003emaxBid\u003c/i\u003e \u0026gt; \u003ci\u003eb\u003c/i\u003e, \u003ci\u003esecondMaxBid\u003c/i\u003e \u003d \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e. Let’s calculate these 2 summands separately. Denote by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e a random bid of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e bidder.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ePr\u003c/i\u003e.(\u003ci\u003emaxBid\u003c/i\u003e \u003d \u003ci\u003eb\u003c/i\u003e, \u003ci\u003esecondMaxBid\u003c/i\u003e \u003d \u003ci\u003eb\u003c/i\u003e) \u003d \u003ci\u003ePr\u003c/i\u003e.(\u003ci\u003emaxBidb\u003c/i\u003e) - \u003ci\u003ePr\u003c/i\u003e.(\u003ci\u003emaxBid\u003c/i\u003e \u0026lt; \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e3/94/e394803433a5164bc6dfa3765d75c730d0426fd5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d1/7f/d17f1b74b08674296bfcb515383f0a882d12b9dc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/84/81/84812cd13dd37d58b67fadb6edeb2ebd80ebbe50.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Now let’s calculate the other summand: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e8/87/e8872a499d35d8a5bdd7226174f9388204dd0550.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eNote that each of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ePr\u003c/i\u003e.(\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u0026gt; \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ePr\u003c/i\u003e.(\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ePr\u003c/i\u003e.(\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u0026lt; \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e can be calculated in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e, so \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e can be calculated in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e. So in the end, we get the running time of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e·\u003ci\u003emax\u003c/i\u003e(\u003ci\u003eR\u003c/i\u003e - \u003ci\u003eL\u003c/i\u003e + 1))\u003c/span\u003e. However, the last step can easily be implemented in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e, which would give us the total running time of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e·\u003ci\u003emax\u003c/i\u003e(\u003ci\u003eR\u003c/i\u003e - \u003ci\u003eL\u003c/i\u003e + 1))\u003c/span\u003e, but in this problem it’s not required as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≤ 5\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNote: As you can see, using second and third solutions the problem could be solvable for much larger values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. However, we felt like all three approaches are equally interesting and let any of them pass. Bonus: assuming that we can multiply doubles without precision loss in polynomial time, can you solve the problem in polynomial time if the bid ranges of each company are unbounded?\u003c/p\u003e\u003ch1\u003eD — Constrained Tree\u003c/h1\u003e\u003cp\u003e(developed by Eldar Bogdanov, Alexander Ruff and Anton Lomonos, editorial written by Anton Lomonos)\u003c/p\u003e\u003cp\u003eLet\u0027s try to construct this tree from top to bottom trying to comply with given set of constraints. The first observation you need to make is if vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e (\u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e should be in a given subtree then any vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e (\u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003ek\u003c/i\u003e \u0026lt; \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e should also be in this subtree. It leads to 2 important conclusions:\u003c/p\u003e \u003col\u003e   \u003cli\u003eOur task \u0026quot;find a tree rooted at vertex \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e which should contain \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e vertices and comply to the given set of constraints\u0026quot; can be rephrased to \u0026quot;find a tree rooted at vertex \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e which should comply to the given set of constraints, contain the least number of vertices as possible, and contain vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e\u0026quot;.\u003c/li\u003e   \u003cli\u003eWe need to know only minimums and maximums for left and right parts of each subtree.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eLet\u0027s assume we are trying to construct subtree rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e that should contain vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e, vertices \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e..\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e]\u003c/span\u003e to the left of the root, and vertices \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e..\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e]\u003c/span\u003e to the right of the root. If we don\u0027t have constraints for the left part or for the right part of the subtree then we can place all the vertices utterly to the right or to the left (we still need to check constraints for sanity). Otherwise, the conditions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u0026lt; \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e should take place. The vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e should be the left child of the root. Vertices \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + 1;\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e - 1]\u003c/span\u003e may be placed to the left or to the right which depends on the constraints. Let\u0027s construct the left subtree rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e in such a way that it should contain the vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e and contain at least number of vertices as possible. Let\u0027s assume the vertex with the biggest label in this subtree is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e\u003c/span\u003e. Condition \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e \u0026lt; \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e should take place. Then we can make right child of the root to be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e + 1\u003c/span\u003e, and we need to construct subtree rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e + 1\u003c/span\u003e that should contain at least number of vertices as possible and should contain vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003eThe complexity of algorithm is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e + \u003ci\u003eC\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch1\u003eE — Subarray Cuts\u003c/h1\u003e\u003cp\u003e(proposed by Nikhil Goyal, developed by Anton Lomonos and Lasha Lakirbaia, editorial written by Anton Lomonos and Lasha Lakirbaia)\u003c/p\u003e\u003cp\u003eThis problem can be solved in several ways. One of the expected solution for the easier part has complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e, which will be presented later. For now let\u0027s discuss another solution, which is also good enough for first subproblem and has complexity of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enk\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e).\u003c/span\u003e\u003c/p\u003e\u003cp\u003eLet’s call the set of all possible \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e-tuples of partitions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e; So we’re concentrating on finding the element of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e with the maximal sum value. Let’s consider another set of tuples of partitions but with the following properties: We have at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e disjoint subarrays chosen. Call their sums \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, …, \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e is the number of subarrays and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e ≤ \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e). For each \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ (\u003ci\u003em\u003c/i\u003e - 1)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003c/sub\u003e(\u003ci\u003ei\u003c/i\u003e - 1) - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e) * (\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003c/sub\u003e(\u003ci\u003ei\u003c/i\u003e + 1)) \u0026lt; 0\u003c/span\u003e. In other words, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is \u003cstrong\u003enot between\u003c/strong\u003e its neighbors by value. (For example, if its neighbors are 3 and 11, it will be either greater than 11 or less than 3). The number of unused (not picked) elements from the initial array is at least \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e - \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e. In other words, we are able to add enough disjoint subarrays to this \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e subarrays so that in the end we have exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e of them. Let’s call this set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIt can be easily proved, that the maximal valued elements in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e have the same value. The proof of this statement is given in the very end of the solution. For now let’s believe it and solve the problem.\u003c/p\u003e\u003cp\u003eSo from now on we concentrate on finding the maximal value with the property of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNote that the value of any element of B with sums \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, …, \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is equal to the maximum of \u003cspan class\u003d\"tex-span\"\u003e( + \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e - 2·\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + 2·\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e - 2·\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e4\u003c/sub\u003e + …)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e( - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + 2 \u003ci\u003ecdots\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - 2 \u003ci\u003ecdots\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e + 2·\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e4\u003c/sub\u003e - …)\u003c/span\u003e. The important catch here is that we can ignore the property of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e which says that each sum of subarray is NOT between it’s neighboring sums, because in the end we’ll get the same answers. So we just ignore that property and solve the problem without that restriction. The only restriction remaining is that they should be disjoint and the total number of unused elements should be at least \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e - \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e. Here is the sketch of the proof why will it give the same answer: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e - 2·\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + 2·\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e - … \u003d (\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e) + (\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e) + … ≤ |\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e| + |\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e| + …\u003c/span\u003e, as well as \u003cspan class\u003d\"tex-span\"\u003e( - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + 2·\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - 2·\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e + ...)\u003c/span\u003e. It means that when they’re both maximum, they equal to each other.\u003c/p\u003e\u003cp\u003eSo we can instead concentrate on finding the maximal possible \u003cspan class\u003d\"tex-span\"\u003e( + \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e - 2·\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + 2·\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e - 2·\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e4\u003c/sub\u003e + …)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e( - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + 2·\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - 2·\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e + 2·\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e4\u003c/sub\u003e - …)\u003c/span\u003e values and it will coincide with the answer to our problem.\u003c/p\u003e\u003cp\u003eDenote by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003epos\u003c/i\u003e, \u003ci\u003esign\u003c/i\u003e, \u003ci\u003efirst\u003c/i\u003e, \u003ci\u003elast\u003c/i\u003e, \u003ci\u003eunused\u003c/i\u003e, \u003ci\u003emax\u003c/i\u003e)\u003c/span\u003e — the answer for the subproblem \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003epos\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003c/sub\u003e(\u003ci\u003epos\u003c/i\u003e + 1), …)\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esign\u003c/i\u003e\u003c/span\u003e means the sign of the first chosen subarray, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efirst\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elast\u003c/i\u003e\u003c/span\u003e denote whether the current subarray should be first, last or none of them, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eunused\u003c/i\u003e\u003c/span\u003e denotes the number of unused elements that we should preserve and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/span\u003e denotes the maximum number of subarrays we may take. There are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enk\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e states here, cause \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esign\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003efirst\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elast\u003c/i\u003e\u003c/span\u003e each have just \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e options. Important part here is how we make transitions in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e and thus solve the entire problem in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enk\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e. First transition would correspond to ignoring \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e\u003c/span\u003e-th element — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003epos\u003c/i\u003e + 1, \u003ci\u003esign\u003c/i\u003e, \u003ci\u003efirst\u003c/i\u003e, \u003ci\u003elast\u003c/i\u003e, \u003ci\u003emin\u003c/i\u003e(\u003ci\u003eunused\u003c/i\u003e + 1, \u003ci\u003ek\u003c/i\u003e), \u003ci\u003emax\u003c/i\u003e)\u003c/span\u003e. Otherwise we are taking \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003epos\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e in the first chosen subarray. There are 2 cases here: Either the current interval is just \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003epos\u003c/i\u003e, \u003ci\u003epos\u003c/i\u003e)\u003c/span\u003e, or it’s length is more than 1. In the first case, the value is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esigna\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003epos\u003c/i\u003e\u003c/sub\u003e·((\u003ci\u003efirstorlast\u003c/i\u003e)?1: 2) + \u003ci\u003edp\u003c/i\u003e(\u003ci\u003epos\u003c/i\u003e + 1,  - \u003ci\u003esign\u003c/i\u003e, \u003ci\u003efalse\u003c/i\u003e, 0\u003ci\u003eor\u003c/i\u003e1, \u003ci\u003eunused\u003c/i\u003e, \u003ci\u003emax\u003c/i\u003e - 1)\u003c/span\u003e. In the second case, the value would be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esign\u003c/i\u003e·\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003epos\u003c/i\u003e\u003c/sub\u003e·((\u003ci\u003efirstorlast\u003c/i\u003e)?1: 2) + \u003ci\u003edp\u003c/i\u003e(\u003ci\u003epos\u003c/i\u003e + 1, \u003ci\u003esign\u003c/i\u003e, \u003ci\u003efirst\u003c/i\u003e, \u003ci\u003elast\u003c/i\u003e, \u003ci\u003eunused\u003c/i\u003e, \u003ci\u003emax\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eHence, in total we have \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e transitions and thus we calculate each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003epos\u003c/i\u003e, \u003ci\u003esign\u003c/i\u003e, \u003ci\u003efirst\u003c/i\u003e, \u003ci\u003elast\u003c/i\u003e, \u003ci\u003eunused\u003c/i\u003e, \u003ci\u003emax\u003c/i\u003e)\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e. It means the entire complexity of the solution is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enk\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e. Note: We didn’t present every detail and corner case, because it would be very boring to read otherwise.\u003c/p\u003e\u003cp\u003eBelow we’ll present the solution for the harder version of this problem.\u003c/p\u003e\u003cp\u003eIn general case we are trying to calculate this expression:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(... + |\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e - 2\u003c/sub\u003e - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e - 1\u003c/sub\u003e| + |\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e - 1\u003c/sub\u003e - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e| + |\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/sub\u003e| + ...) \u003d \u003ci\u003emax\u003c/i\u003e(... ± (\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e - 2\u003c/sub\u003e - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e - 1\u003c/sub\u003e) ± (\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e - 1\u003c/sub\u003e - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e) ± (\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/sub\u003e) ± ...)\u003c/span\u003e\u003c/p\u003e\u003cp\u003eThis task can be solved by using dynamic programming. Let\u0027s try to calculate recurrently the following function where we should pick subarrays \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e..\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e from array \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ei\u003c/i\u003e; \u003ci\u003en\u003c/i\u003e]\u003c/span\u003e:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e) \u003d \u003ci\u003emax\u003c/i\u003e(... ± (0 - 0) \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e (0 - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e) \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e (\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/sub\u003e) ± (\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/sub\u003e - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e + 2\u003c/sub\u003e) ± ...)\u003c/span\u003e, where \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/26/90/2690147cb479d7062361b4752c248fc5b9145b1b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e are defined.\u003c/p\u003e\u003cp\u003eThe recurrent formula for this function is:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e) \u003d \u003ci\u003emax\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sub\u003e(\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ( - \u003ci\u003esum\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e \u003d \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e..\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e) \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e (\u003ci\u003esum\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e \u003d \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e..\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e) + \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + 1, \u003ci\u003ej\u003c/i\u003e + 1, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e,  ± ))\u003c/span\u003e\u003c/p\u003e\u003cp\u003eWe can easily get rid of using \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e) \u003d \u003ci\u003emax\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e), \u003ci\u003emax\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ( - \u003ci\u003esum\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e \u003d \u003ci\u003ei\u003c/i\u003e..\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e) \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e (\u003ci\u003esum\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e \u003d \u003ci\u003ei\u003c/i\u003e..\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e) + \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + 1, \u003ci\u003ej\u003c/i\u003e + 1, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e,  ± ))\u003c/span\u003e\u003c/p\u003e\u003cp\u003eWe can get rid from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e by using additional function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e, which states that subarray \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e already has some elements in it:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e) \u003d \u003ci\u003emax\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e), \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ( - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e) \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003eg\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e))\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e) \u003d \u003ci\u003emax\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e + 1, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e,  + ), \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e + 1, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e,  - ), \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ( - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e) \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e (\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e) + \u003ci\u003eg\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e))\u003c/span\u003e\u003c/p\u003e\u003cp\u003eThere is still a matter of handling the beginning and ending of dynamic programming. There are several ways to do it. For example, we can calculate maximums and minimums of values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e based on their endings or beginnings, or we can make exceptions for using \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e \u003d 1\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e \u003d \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe complexity of the algorithm is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e * \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch1\u003eF — Scaygerboss\u003c/h1\u003e\u003cp\u003e(developed by Anton Lomonos, editorial written by Anton Lomonos)\u003c/p\u003e\u003cp\u003eThe task reduces to the situation when we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e females and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e males, and we need to connect them in such a way, that there will be no more than one pair in each cell. This task can be solved by using maximum flow algorithm. \u003c/p\u003e\u003cp\u003eFirstly we need to choose the value of our answer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003c/span\u003e (for example, by binary search) and check if they can connect in a time no more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003c/span\u003e. Let\u0027s make edges of capacity 1 between source and females, between males and sink, and between inputs and outputs of each cell. Then let\u0027s make edges of capacity 1 between females and inputs of cells and between outputs of cells and males if they can reach this cell within \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003c/span\u003e (we can calculate these values by using breadth-first algorithm). If we can get a maximum flow of capacity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e on this graph then they can reach each other within \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe above approach is enough to solve the first part of the task. It has complexity of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e·\u003ci\u003elog\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e))\u003c/span\u003e. For solving second part of the task one should optimize the above solution. Highly optimized solution with complexity of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e·\u003ci\u003elog\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e))\u003c/span\u003e could pass, but there exists a solution with complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eThe first observation you need to make is you don\u0027t need to reconstruct the graph each time for running maximum flow algorithm. If you run the algorithm for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, and then run the algorithm for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e \u003d \u003ci\u003eb\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e \u0026gt; \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, you would just need to add additional edges and \u0026quot;continue to run\u0026quot; maximum flow algorithm. The complexity of this would be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e + \u003ci\u003el\u003c/i\u003e·\u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e is the number of times you do this trick. Using this observations in different ways could be enough to pass the second part of the task. \u003c/p\u003e\u003cp\u003eYou can achieve the complexity of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e by using square root decomposition. You need to divide \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e edges to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e batches of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e edges based on the values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003c/span\u003e you can use these edges for. Running maximum flow algorithm after adding each of these batches would get you \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e complexity. Then you know which batch would tell you what the answer is, and you run maximum flow algorithm for this batch, which is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e complexity too. \u003c/p\u003e\u003cp\u003eYou can also divide edges to batches not based by their quantities, but based by their values. You will be adding the edges of the same values to the graph in the same blow. That way your algorithm would run even faster.\u003c/p\u003e\u003cp\u003eI (\u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/White_Bear\" title\u003d\"International master White_Bear\"\u003eWhite_Bear\u003c/a\u003e) would like to give special congratulations to \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/mmaxio\" title\u003d\"International Grandmaster mmaxio\"\u003emmaxio\u003c/a\u003e, \u003ca class\u003d\"rated-user user-legendary\" href\u003d\"/profile/Petr\" title\u003d\"Legendary grandmaster Petr\"\u003e\u003cspan class\u003d\"legendary-user-first-letter\"\u003eP\u003c/span\u003eetr\u003c/a\u003e, \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/niyaznigmatul\" title\u003d\"International Grandmaster niyaznigmatul\"\u003eniyaznigmatul\u003c/a\u003e, and \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Egor\" title\u003d\"International Grandmaster Egor\"\u003eEgor\u003c/a\u003e who solved F2 using Java.\u003c/p\u003e\u003ch1\u003eG — Inversions Problem\u003c/h1\u003e\u003cp\u003e(proposed by Ievgen Soboiliev, developed by Ievgen Soboiliev, editorial written by Lasha Lakirbaia, to be changed)\u003c/p\u003e\u003cp\u003eThis is a draft of solution to this problem. It will be changed later. Currently it contains solutions of first 2 subproblems.\u003c/p\u003e\u003cp\u003eThe first subproblem can be solved many ways. The easiest probably is the following: consider the dynamic programming approach where the state is \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eperm\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e — where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eperm\u003c/i\u003e\u003c/span\u003e is the current permutation and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e is the number of operations that are going to be performed over it. Transitions are just all the possible permutations that can be derived in the next turns (with their respective probabilities) and obviously the other variable will be just \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003em\u003c/i\u003e - 1)\u003c/span\u003e. The running time for this approach is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e! * \u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e * \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e, which is good enough for the given constraints. Note that even though for small \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e the number of possible permutations is pretty small and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is also small, solutions based on simulation are not working at the precision level that’s required.  To solve 2 other subproblems, we are gonna need more observations. First one is the linearity of expected value. It basically means that the expected value of a sum of random variables is equal to the sum of expected values of those variables, even if they’re somehow dependent on each other. Let’s see how we can use this idea to solve this problem. For this we have to look at the number of inversions a bit differently. For each possible pair \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003ej\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e, let’s define the random variable \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e to be \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e elements will preserve the order after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e operations and \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e otherwise. Now, the number of inversions in terms of these variables is equal to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/52/ba/52ba7a3fb97144922b9c2c4cc9b698003e84f00c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. So if we can find the expected values of each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e variables, than calculating the answer will be straightforward.\u003c/p\u003e\u003cp\u003eAnother observation is that the expected value of a binary variables is the same as it’s probability of being equal to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. It means that the expected value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e is same as probability that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e elements will swap the order in the end, after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e moves. \u003c/p\u003e\u003cp\u003eFrom now on, let’s denote by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e the probability, that after m steps the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e elements will swap the order (in other words, probability that the final position of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e element will be to the right side of the final position of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e element). The solutions of second and third subproblems differ only in ways of calculating these values.\u003c/p\u003e\u003cp\u003eEasier way to find these values is to use recursive approach: Consider all the possible next moves — namely all possible intervals \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e on which the next step will be performed. Each of them has probability equal to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a7/e0/a7e060c2a47243fe9212d6f24c1c695777ef35e8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. There are several cases:\u003c/p\u003e\u003cp\u003e(1) Intervals \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e are either disjoint, or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e \u0026lt; \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. In both cases, the transition will be just \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e - 1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e(2) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003ey\u003c/i\u003e \u0026lt; \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. In this case the transition is gonna be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e - 1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e(3) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003ex\u003c/i\u003e ≤ \u003ci\u003ej\u003c/i\u003e ≤ \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. In this case the transition will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e - \u003ci\u003ej\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e - 1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e(4) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003ej\u003c/i\u003e ≤ \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. In this case the transition will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e - \u003ci\u003ej\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e - 1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe running time of this solution will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e * \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e, which is good enough for 2-nd subproblem, but not for the third one. This solution can actually be optimized. For this, we will need to deal with above 4 cases in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e each, instead of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e(1) We just count how many \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e intervals are of this type \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e \u0026lt; \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e and than multiply this number by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e - 1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e(2) For each fixed possible value of \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e, count how many \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e exist with that sum such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003ey\u003c/i\u003e \u0026lt; \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. It can easily be done in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e. As there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e possible values of \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e, this whole step takes O(n).\u003c/p\u003e\u003cp\u003e(3) The approach here is exactly the same as in the second case.\u003c/p\u003e\u003cp\u003e(4) For each possible value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e \u003d \u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003ej\u003c/i\u003e ≤ \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e and sum up \u003cspan class\u003d\"tex-span\"\u003e(1 - \u003ci\u003ep\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e - \u003ci\u003ej\u003c/i\u003e, \u003ci\u003es\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e - 1))\u003c/span\u003e. There are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e possible values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, so this whole step takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time.\u003c/p\u003e\u003cp\u003eAs these 4 steps each take at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e, the total running time will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e·\u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e. The fastest solution works in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e·\u003ci\u003emin\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e, 2000))\u003c/span\u003e. This solution will be described later.\u003c/p\u003e\u003c/div\u003e","tags":["rockethon 2015","editorial"]}}