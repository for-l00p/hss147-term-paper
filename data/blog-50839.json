{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1488834152,"rating":0,"authorHandle":"1am","modificationTimeSeconds":1488834152,"id":50839,"title":"\u003cp\u003eDay 2 (rc)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003e\u003ca href\u003d\"//codeforces.com/group/HkEoaKeslR/contest/212317/problem/A\"\u003eA. Little Pigs and Wolves\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eThis problem states that you have to calculate the number of wolves that will eat a pig. Because a wolf can only eat on pig, we must check if there is a pig in any of the four directions (up , down, left, right) around the wolf. If there is at least one, then we increase our counter by 1.\u003c/p\u003e\u003cp\u003eIf i am at position (x, y)\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eThe position above me in the array is (x-1, y)\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThe position below me in the array is (x+1, y)\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThe position to the right of me is (x, y+1)\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThe position to the left of me is (x, y-1) \u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eInstead of defining each of these places, we can instead use a delta x array and delta y array and loop four times for each direction. The implementation of it is in the code: \u003ca href\u003d\"http://ideone.com/pAY1Gr\"\u003ehttp://ideone.com/pAY1Gr\u003c/a\u003e\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"//codeforces.com/group/HkEoaKeslR/contest/212317/problem/C\"\u003eC. Worms Evolution\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eThis problem just wants you to find three differnt indices such that ai \u003d aj + ak.\u003c/p\u003e\u003cp\u003eThe solution to this problem is brute force, with three for loops, one for i, j, and k ( each till 100). The complexity of this solution is O (n^3) which comes around to maximum 10^6 operations (since max n is 100). Up until 10 ^7 can easily pass in a second.\u003c/p\u003e\u003cp\u003eHere is the code for it: \u003ca href\u003d\"http://ideone.com/42Sfav\"\u003ehttp://ideone.com/42Sfav\u003c/a\u003e\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"//codeforces.com/group/HkEoaKeslR/contest/212317/problem/D\"\u003eD. 2Char\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eThe solution to this problem is also brute force, we try every combination of two letters which is 26*26. Then for every combination we see all strings that have only those two letters. If it does, we add its length to a temp counter for that combination, and the answer is the maximum counter between all combinations.\u003c/p\u003e\u003cp\u003eComplexity is O(26 *26 *n*m) where n is the number of strings and m is max length of string.\u003c/p\u003e\u003cp\u003eHere is its code: \u003ca href\u003d\"http://ideone.com/cS23X5\"\u003ehttp://ideone.com/cS23X5\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}