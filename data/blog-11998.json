{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1398631269,"rating":-18,"authorHandle":"Sereja","modificationTimeSeconds":1398890827,"id":11998,"title":"\u003cp\u003eCodeforces Round #243 tutorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/426/problem/A\" title\u003d\"Codeforces Round 243 (Div. 2)\"\u003e426A - Sereja and Mugs\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eLets count the sum of all elements \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eSum\u003c/i\u003e\u003c/span\u003e and value of the maximal element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eSum\u003c/i\u003e - \u003ci\u003eM\u003c/i\u003e ≤ \u003ci\u003eS\u003c/i\u003e\u003c/span\u003e then answer is yes, otherwise — no.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/426/problem/B\" title\u003d\"Codeforces Round 243 (Div. 2)\"\u003e426B - Sereja and Mirroring\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eLets solve problem from another side. We will try to \u003cem\u003ecut\u003c/em\u003e of matix as many times as we can. \u003cem\u003eCut\u003c/em\u003e means operation, reversed to operation described in statement. To check, can we cut matrix we need to check following conditions:\u003cbr /\u003e1). \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003ci\u003emod\u003c/i\u003e 2 \u003d 0\u003c/span\u003e\u003cbr /\u003e2). \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e, 1 ≤ \u003ci\u003ej\u003c/i\u003e ≤ \u003ci\u003em\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/425/problem/A\" title\u003d\"Codeforces Round 243 (Div. 1)\"\u003e425A - Sereja and Swaps\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eLets backtrack interval on which will contain maximal sum. To improve our sum we can swap not more then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e minimal elements from the interval to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e maximal elements that don\u0027t belong to interval. As \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e isn\u0027t big we can do it in any way. Author solution sort all elemets from interval in increasing order and all elements that don\u0027t belong to interval by descreasing order. We will swap elements one by one while we haven\u0027t done \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e swaps and we have some unswaped elements in first set and we have some unswaped elemets in second set and swap is optimal(we will optimize the answer after this swap). Author solution works in time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e·\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eIs there some ideas how to solve this problem in time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e·\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e ? \u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/425/problem/B\" title\u003d\"Codeforces Round 243 (Div. 1)\"\u003e425B - Sereja and Table \u003c/a\u003e\u003c/h3\u003e\u003cp\u003eNote, that if we have two arrays \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e[1..\u003ci\u003en\u003c/i\u003e], 0 ≤ \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e[1..\u003ci\u003em\u003c/i\u003e], 0 ≤ \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ 1\u003c/span\u003e, then described matrix can be showed as next one: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003ci\u003exor\u003c/i\u003e \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003cbr /\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≤ \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, then we can backtrack array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and using greedy find best \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. Otherwise there will be atleast one \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, such that we will not change any cell in row number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. So we can simply bruteforce some row and use it like \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Then we use greedy and find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. From all possible rows we choose most optimal. Such row will be as number of mistakes is lower then number of rows, so it isn\u0027t possible to have atleast one mistake in each row. \u003c/p\u003e\u003cp\u003eGreedy means next algorithm: for every element of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e we will look, will it be better to choose it like \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. To find better choise, we will count number of different bits in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and current(lets it be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e) column. If number of different if lower then count of same cells we will set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u003d 0\u003c/span\u003e, otherwise \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u003d 1\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/425/problem/C\" title\u003d\"Codeforces Round 243 (Div. 1)\"\u003e425C - Sereja and Two Sequences\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eIn thgis problem we will use dynamic programming: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — minimal pozition of deleted element in second array, such that we have made first operation \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e times and have deleted not more then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e elements from first array. \u003c/p\u003e\u003cp\u003eLets decided how to calculate transfers. Standing in pozition \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e we can change nothing and go to pozition \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, by other words make transfer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e:  \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e. What happens when we make first operation with fixed prefix(by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th element) in first array? We should find element in second array with number greater \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and value equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, lets its pozition is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e, so we need to make transfer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003ej\u003c/i\u003e + 1\u003c/sub\u003e:  \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003ej\u003c/i\u003e + 1\u003c/sub\u003e, \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eHow to find required element quickly: lets just do vector of pozition in second array for all different elements that contains in second array. Then we can simply use binary search. \u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/425/problem/D\" title\u003d\"Codeforces Round 243 (Div. 1)\"\u003e425D - Sereja and Squares\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eLets line \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e contain not more then \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/5c/4e5c9f371024ad4e1f5b0f2dfeb967ffe7cb5f4e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e points. Then for each pair of points on this line (lets it be \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e) check: is there squere that contain them as vertexes. So we should check: is there(in input) pair of points \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e - |\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e|, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e - |\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e|, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e, or pair \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e + |\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e|, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e + |\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e|, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eLets delete all watched points, and reverse points about line \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. Then each line \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e will contain not more then \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/5c/4e5c9f371024ad4e1f5b0f2dfeb967ffe7cb5f4e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e points. Will solve problem in the same way. \u003c/p\u003e\u003cp\u003eNow we should learn: how to check is some pair of points(on one vertical line) in input. Lets write all of this pairs in vectors. Each vector(for every line) will contain pairs that we should check on it. Suppose, that we check it for line number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Lets mark in some array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e for all points with x-coordinate equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Now to check is our pair with y-coordinates \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e on line we can simply check following condition: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sub\u003e \u003d \u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sub\u003e \u003d \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/425/problem/E\" title\u003d\"Codeforces Round 243 (Div. 1)\"\u003e425E - Sereja and Sets\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eFirst, lets look at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003eS\u003c/i\u003e)\u003c/span\u003e. First, we sort all intervals by second coordinte and then go by them in sorted order. And if current interval don\u0027t intersected with last taken to the optimal set, we get our current to the set.\u003c/p\u003e\u003cp\u003eOur solution will be based on this greedy. Solution of the problem is next dynamic:\u003cbr /\u003e1). number of position of second coordinte of interval\u003cbr /\u003e2). number of intervals in good set\u003cbr /\u003e3). second coordinate of last taken interval to the optimal set \u003c/p\u003e\u003cp\u003eHow should we make transfers? Lets note that when we know \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ecount\u003c/i\u003e, \u003ci\u003elast\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e we can change \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elast\u003c/i\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, or not change at all. Lets look what happens in every case. In first case \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elast\u003c/i\u003e\u003c/span\u003e is changed by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, so we should take to optimal set atleast one of the inervals: \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003elast\u003c/i\u003e + 1, \u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003elast\u003c/i\u003e + 2, \u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e, ..., \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e, number of such intervals \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003elast\u003c/i\u003e\u003c/span\u003e, number of ways to get at least one of them is \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003elast\u003c/i\u003e\u003c/sup\u003e - 1\u003c/span\u003e. All other intervals: \u003cspan class\u003d\"tex-span\"\u003e[1, \u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e[2, \u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e, ..., \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003elast\u003c/i\u003e, \u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e we could get as we wish, so we have \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003elast\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e ways. So total number of transfers from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ecount\u003c/i\u003e, \u003ci\u003elast\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003ecount\u003c/i\u003e + 1, \u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003elast\u003c/i\u003e\u003c/sup\u003e - 1)·(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003elast\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e. If we count number of transfers from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ecount\u003c/i\u003e, \u003ci\u003elast\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003ecount\u003c/i\u003e, \u003ci\u003elast\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, we can simply use number \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003elast\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e(as described early). \u003c/p\u003e\u003cp\u003eAlso we shouldn\u0027t forget about trivial case \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e, 0, 0\u003c/sub\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eSo now we have quite easy solution.\u003c/p\u003e\u003c/div\u003e","tags":["codeforces round #243","tutorial"]}}