{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1491831346,"rating":0,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1491831346,"id":51522,"title":"\u003cp\u003eSolutions to Codeforces Beta Round #34, A, B, C, D\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA. Reconnaissance 2\u003c/p\u003e\u003cp\u003eThis problem asks to find out two neighbouring elements with the minimum difference. Specifically, the difference between the first element and the last one should be taken into consideration as well. \u003c/p\u003e\u003cp\u003eB. Sale\u003c/p\u003e\u003cp\u003eBob can only earn money by \u0026quot;buying\u0026quot; those TVs with negative price. Therefore, we can sort all the TVs in an increasing order of their price, and denote the number of TVs with negative price as M. Then, we add the prices of the first min{M,m} TVs together to obtain the final answer.\u003c/p\u003e\u003cp\u003eC. Page Numbers\u003c/p\u003e\u003cp\u003eThis problem is straightforward however a little bit complicated. As the largest page number does not exceed 1000, we can adopt a \u0026quot;hash table\u0026quot; to record which pages have appeared in the sequence. At first, we should calculate the exact page number from the given sequence. Then, we set the value of hash table corresponding to the current page number to 1 to denote that this page is required to print. Finally, we enumerate the hash table from the first index to the last one. Whenever we meet a \u0026quot;1\u0026quot;, we check whether the next one is \u0026quot;1\u0026quot; or not. If it is, then we move on to check the following one until we meet a \u0026quot;0\u0026quot;, and output them in a \u0026quot;i-j\u0026quot; manner; otherwise we directly output the current page number. Take care of the position at which we should output a comma \u0027,\u0027.\u003c/p\u003e\u003cp\u003eD. Road Map\u003c/p\u003e\u003cp\u003eThis problem is in fact equivalent to reversing a single linked list. \u003c/p\u003e\u003cp\u003eThe map can be viewed as a tree, and thus the representation of the road provides the parent node for each node. Suppose that we write the connection relationship between r2 to the original root node r1 as r2-\u0026gt;A-\u0026gt;B-\u0026gt;...-\u0026gt;r1. When the root node is changed from r1 to r2, it can be observed that only the parent nodes of r2,A,B,...,r1 should be altered. More specifically, the connection should be altered as r2\u0026lt;-A\u0026lt;-B...\u0026lt;-r1. Therefore, it is sufficient to reverse such a single linked list with complexity O(n). \u003c/p\u003e\u003c/div\u003e","tags":["linked list","sorting"]}}