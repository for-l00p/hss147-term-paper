{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1483120692,"rating":168,"authorHandle":"Errichto","modificationTimeSeconds":1485180390,"id":49412,"title":"\u003cp\u003eGood Bye 2016 — hints and codes\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eYou can download my codes to all problems \u003ca href\u003d\"http://www.filedropper.com/codes_1\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eI will write a full editorial in the next few days. Now you can read hints and short solutions.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/750/problem/B\" title\u003d\"Good Bye 2016\"\u003e750B - New Year and North Pole\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eCreate a variable that will denote your current distance from the North Pole. What are allowed values of this variable? When can\u0027t we go West or East?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/750/problem/C\" title\u003d\"Good Bye 2016\"\u003e750C - New Year and Rating\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e denote the initial rating (or his final rating, whatever is easier for you to think about). The information that Limak is in some division in the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th contest gives us some inequality for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Can you see it?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFor every contest we know that the current rating is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e increased by some prefix sum of c_i (changes of rating). If Limak is in the division 1, we have inequality x+prefSum \u0026gt;\u003d 1900 so we have x \u0026gt;\u003d 1900-prefSum. If Limak is in the division 2, we have inequality x_prefSum \u0026lt;\u003d 1899 so it is x \u0026lt;\u003d 1899-prefSum. From this set of inequalities, your task is to find the biggest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e satisfying all of them.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/750/problem/D\" title\u003d\"Good Bye 2016\"\u003e750D - New Year and Fireworks\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eSince constrains are quite low, the firework won\u0027t visit cells far away from the initial cell. There aren\u0027t that many cells that can be visited. How can we use this fact?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eIf the initial cell has coordinates \u003cspan class\u003d\"tex-span\"\u003e(0, 0)\u003c/span\u003e, we are interested only in cells with coordinates up to MAX_N * MAX_T that is equal to \u003cspan class\u003d\"tex-span\"\u003e30·5 \u003d 150\u003c/span\u003e. So there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(150\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e interesting cells. Use backtrack with memoization. Think about possible states.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003esolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eAs a state you should keep: x-coordinate, y-coordinate, the current direction of this part of firework, and the recursion level (it says how much time this part will live). You can keep everything in C++ set, or use a big boolean array to make your solution faster.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/750/problem/E\" title\u003d\"Good Bye 2016\"\u003e750E - New Year and Old Subsequence\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThe intended solution is also able to process queries of form \u0026quot;change the i-th digit to x\u0026quot;. This is a big hint.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eBuild a segment tree to answer queries in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. What should be stored in such a tree?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint3\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eImagine going from left to right over a substring, maybe removing some digits. What is important in every moment is: what prefix of \u0026quot;2017\u0026quot; we already got as a subsequence. How to apply it to segment that should be merge in the segment tree?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint4\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eIn the segment tree store matrices of size 5 x 5, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e means: the minimum number of digits to remove so that if there it was already possible to get prefix of \u0026quot;2017\u0026quot; of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, then with this segment of digits it will be possible to get prefix of \u0026quot;2017\u0026quot; of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/750/problem/F\" title\u003d\"Good Bye 2016\"\u003e750F - New Year and Finding Roots\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003epart1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThe intended solution is deterministic (it doesn\u0027t use any randomization). There is just enough queries to always find the root. So, you can\u0027t waste even one query. After asking about the first vertex, you should start moving from there, asking about its neighbour and its neighbour again, till you get a leaf. After getting a leaf let\u0027s start again from the first vertex and go in some other direction, again till you find a leaf. Now you have a path between two leaves. Draw it on paper. Where you should now go, to find a root?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003epart2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eYou should find LCA of the found path and go from there to a neighbour that wasn\u0027t yet visited. Then again go till you find a leaf (because what else could we do?). Draw on paper a situation after finding some new leaf. You should see that again we should choose LCA of some path and go in some particular direction. How many queries do we need to find the root?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003epart3\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eWe need \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5f/4d/5f4dcaf5df40a059dfcf3ccf1a8e7d700ce2950e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e queries at most, what happens if me always go from LCA to its parent and then unfortunately we start moving down. You are close to the solution now!\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/bc/c3/bcc3a08089f3c1a284c57166c41eb0b640f7c503.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003epart4\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eIf our current LCA is close to the root (we know that when it\u0027s far away from leaves), instead of going blindly in some direction to get a leaf after ~6 queries, we should check only vertices close to the LCA. After going from LCA to its last unknown neighbour, we should check that neighbour\u0027s neighbours and also their neighbours (in total, checking all vertices withing distance \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e). The root must be there! This approach needs \u003cspan class\u003d\"tex-span\"\u003e1 + 2 + 3 + 4 + 1 + 2 + 4 \u003d 17\u003c/span\u003e queries. Can you get rid of one more query in some easy way?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003epart5\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eIf you already used \u003cspan class\u003d\"tex-span\"\u003e16\u003c/span\u003e queries, instead of asking about one more neighbour, you should say that it\u0027s the root. It\u0027s the last candidate so it must indeed be a root.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/750/problem/G\" title\u003d\"Good Bye 2016\"\u003e750G - New Year and Binary Tree Paths\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eAll paths consists of LCA and two sides. It\u0027s hard to iterate over LCA in this problem so try to iterate over length of sides.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eIt turns out that lengths of sides are enough to compute exact value of LCA. Find a formula on paper or see my code (the top of this page). Now you can subtract something from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e and assume that we count paths with LCA equal to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, still with fixed length of left and right sides. Now some observation is needed.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint3\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eWhat is the sum of vertices on a path from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e? It\u0027s almost \u003cspan class\u003d\"tex-span\"\u003e2·\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, right?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint4\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eIt is \u003cspan class\u003d\"tex-span\"\u003e2·\u003ci\u003ex\u003c/i\u003e - \u003ci\u003epopcount\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e (maybe \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e + 1\u003c/span\u003e). Try to use it solve solve the problem of counting paths with LCA equal to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and some fixed length of sides.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint5\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eIf endpoints are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, the sum of vertices will be something like \u003cspan class\u003d\"tex-span\"\u003e2·\u003ci\u003ea\u003c/i\u003e - \u003ci\u003epopcount\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e) + 2·\u003ci\u003eb\u003c/i\u003e - \u003ci\u003epopcount\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e. Since popcounts are small, we can iterate over them. Then we know that \u003cspan class\u003d\"tex-span\"\u003e2·\u003ci\u003ea\u003c/i\u003e - \u003ci\u003epopcount\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e) + 2·\u003ci\u003eb\u003c/i\u003e - \u003ci\u003epopcount\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e) \u003d \u003ci\u003esomething\u003c/i\u003e\u003c/span\u003e means \u003cspan class\u003d\"tex-span\"\u003e2·\u003ci\u003ea\u003c/i\u003e + 2·\u003ci\u003eb\u003c/i\u003e \u003d \u003ci\u003esomething\u003c/i\u003e + \u003ci\u003epopcount\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e) + \u003ci\u003epopcount\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e, so we know how big \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e should be. What remains is to quickly solve the following problem: Count the number of pairs \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e with fixed length of binary representations, fixed sum and fixed total number of \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e\u0027s in the binary representation.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint6\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eDynamic programming on bits.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"/contest/750/problem/H\" title\u003d\"Good Bye 2016\"\u003e750H - New Year and Snowy Grid\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eDuality\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ehint2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFor every query we must say if the top-right side is almost connected with the bottom-left side. Here, \u0026quot;almost connected\u0026quot; means that they would be connected after adding at most one more vertex (cell). With preprocessing, you should find CC\u0027s (connected components) in the dual problem. Remember that now from one cell you can go in \u003cspan class\u003d\"tex-span\"\u003e8\u003c/span\u003e directions. Also find pairs of CC\u0027s that are almost connected.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003ch1\u003e\u003ca href\u003d\"/contest/750/problem/A\" title\u003d\"Good Bye 2016\"\u003e750A - New Year and Hurry\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eDo you see what is produced by the following piece of code?\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint total \u003d 0;\nfor(int i \u003d 1; i \u0026lt;\u003d n; ++i) {\n\ttotal +\u003d 5 * i;\n\tprintf(\u0026quot;%d\\n\u0026quot;, total);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe iterate over problems (a variable \u003ccode\u003ei\u003c/code\u003e denotes the index of problem) and in a variable \u003ccode\u003etotal\u003c/code\u003e we store the total time needed to solve them. The code above would print numbers \u003cspan class\u003d\"tex-span\"\u003e5, 15, 30, 50, ...\u003c/span\u003e — the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th of these numbers is the number of minutes the hero would spend to solve easiest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e problems.\u003c/p\u003e\u003cp\u003eInside the loop you should also check if there is enough time to make it to the party, i.e. check if \u003ccode\u003etotal + k \u0026lt;\u003d 240\u003c/code\u003e.\u003c/p\u003e\u003cp\u003esimple C++ code:\u003ca href\u003d\"/contest/750/submission/24067296\" title\u003d\"Submission 24067296 by Errichto\"\u003e24067296\u003c/a\u003e\u003cbr /\u003eshorter but harder C++ code: \u003ca href\u003d\"/contest/750/submission/24067301\" title\u003d\"Submission 24067301 by Errichto\"\u003e24067301\u003c/a\u003e\u003cbr /\u003epython: \u003ca href\u003d\"/contest/750/submission/24067479\" title\u003d\"Submission 24067479 by Errichto\"\u003e24067479\u003c/a\u003e\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"/contest/750/problem/B\" title\u003d\"Good Bye 2016\"\u003e750B - New Year and North Pole\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eOur goal is to simulate Limak\u0027s journey and to check if he doesn\u0027t make any forbidden moves. To track his position, it\u0027s enough to store one variable denoting his current distance from the North Pole. To solve this problem, you should implement checking three conditions given in the statement.\u003c/p\u003e\u003cp\u003eUpdating \u003ccode\u003edist_from_north\u003c/code\u003e variable is an easy part. Moving \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e kilometers to the North increases the distance from the North Pole by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, while moving South decreases that distance by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Moving to the West or East doesn\u0027t affect the distance from Poles, though you should still check if it doesn\u0027t happen when Limak is on one of two Poles — you must print \u0026quot;NO\u0026quot; in this case.\u003c/p\u003e\u003cp\u003eLet\u0027s proceed to checking the three conditions. First, Limak can\u0027t move further to the North if he is already on the North Pole \u003cem\u003e\u0026quot;at any moment of time (before any of the instructions or while performing one of them)\u0026quot;\u003c/em\u003e. So you should print \u0026quot;NO\u0026quot; if \u003ccode\u003edirection \u003d\u003d \u0026quot;North\u0026quot;\u003c/code\u003e and either \u003ccode\u003edist_from_north \u003d\u003d 0\u003c/code\u003e or \u003ccode\u003edist_from_north \u0026lt; t[i]\u003c/code\u003e. The latter case happens e.g. if Limak is \u003cspan class\u003d\"tex-span\"\u003e150\u003c/span\u003e kilometers from the North Pole and is supposed to move \u003cspan class\u003d\"tex-span\"\u003e170\u003c/span\u003e kilometers to the North — after \u003cspan class\u003d\"tex-span\"\u003e150\u003c/span\u003e kilometers he would reach the North Pole and couldn\u0027t move further to the North. In the intended solution below you will see an alternative implementation: after updating the value of \u003ccode\u003edist_from_north\u003c/code\u003e we can check if \u003ccode\u003edist_from_north \u0026lt; 0\u003c/code\u003e — it would mean that Limak tried to move North from the North Pole. Also, you should print \u0026quot;NO\u0026quot; if \u003ccode\u003edist_from_north \u003d\u003d 0\u003c/code\u003e (i.e. Limak is on the North Pole) and the direction is West or East.\u003c/p\u003e\u003cp\u003eYou should deal with the South Pole case in a similar way. Limak is on the South Pole when \u003ccode\u003edist_from_north \u003d\u003d M\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eFinally, you must check if Limak finished on the North Pole, i.e. \u003ccode\u003edist_from_north \u003d\u003d 0\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eThere were two common doubts about this problem: 1) \u003cem\u003e\u0026quot;Limak is allowed to move \u003cspan class\u003d\"tex-span\"\u003e40 000\u003c/span\u003e kilometers to the South from the North Pole and will be again on the North Pole.\u0026quot;\u003c/em\u003e 2) \u003cem\u003e\u0026quot;Moving West/East may change the latitude (equivalently: the distance from Poles) and this problem is hard 3d geometry problem.\u0026quot;\u003c/em\u003e Both doubts make sense because they come from misinterpreting a problem as: Limak looks in the direction represented by the given string (e.g. to the North) and just goes straight in that direction (maybe after some time he will start moving to the South but he doesn\u0027t care about it). What organizers meant is that Limak should be directed in the given direction at any moment of time, i.e. he should continuously move in that direction. It\u0027s a sad thing that many participants struggled with that. I should have written the statement better and I\u0027m sorry about it.\u003c/p\u003e\u003cp\u003eC++ code: \u003ca href\u003d\"/contest/750/submission/24067685\" title\u003d\"Submission 24067685 by Errichto\"\u003e24067685\u003c/a\u003e\u003cbr /\u003epython code: \u003ca href\u003d\"/contest/750/submission/24067669\" title\u003d\"Submission 24067669 by Errichto\"\u003e24067669\u003c/a\u003e\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"/contest/750/problem/C\" title\u003d\"Good Bye 2016\"\u003e750C - New Year and Rating\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eWe don\u0027t know the initial or final rating but we can use the given rating changes to draw a plot of function representing Limak\u0027s rating. For each contest we also know in which division Limak was.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/5c/91/5c9169c993d5a1095861e8b4142a39cb71de9cf0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eRed and blue points denote contests in div1 and div2. Note that we still don\u0027t know exact rating at any moment.\u003c/p\u003e\u003cp\u003eLet\u0027s say that a \u003cem\u003eborder\u003c/em\u003e is a horizontal line at height \u003cspan class\u003d\"tex-span\"\u003e1900\u003c/span\u003e. Points above the border and exactly on it should be red, while points below should be blue. Fixing the placement of the border will give us the answer (because then we will know height of all points). Let\u0027s find the highest blue point and the lowest red point — the border can lie anywhere between them, i.e. anywhere between these two horizontal lines:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/25/b8/25b8be67b3de7135b35cd9629181c662a90122f3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eSmall detail: the border can lie exactly on the upper line (because rating \u003cspan class\u003d\"tex-span\"\u003e1900\u003c/span\u003e belongs to div1) but it can\u0027t lie exactly on the lower line (because \u003cspan class\u003d\"tex-span\"\u003e1900\u003c/span\u003e doesn\u0027t belong to div2).\u003c/p\u003e\u003cp\u003eThe last step is to decide where exactly it\u0027s best to put the border. The answer will be \u003cspan class\u003d\"tex-span\"\u003e1900 + \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e is the difference between the height of the border and the height of the last point (representing the last contest), so we should place the border as low as possible: just over the lower of two horizontal lines we found. It means that the highest blue point should be at height \u003cspan class\u003d\"tex-span\"\u003e1899\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThere is an alternative explanation. If Limak never had rating exactly \u003cspan class\u003d\"tex-span\"\u003e1899\u003c/span\u003e, we could increase his rating at the beginning by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e (thus moving up the whole plot of the function by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e) and everything would still be fine, while the answer increased.\u003c/p\u003e\u003cp\u003eTo implement this solution, you should find prefix sums of rating changes (what represents the height of points on drawings above, for a moment assuming that the first point has height \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e) and compute two values: the smallest prefix sum ending in a div1 contest and the greatest prefix sum ending in a div2 contest. If the first value is less than or equal to the second value, you should print \u0026quot;Impossible\u0026quot; — it means that the highest blue point isn\u0027t lower that the lowest red point. If all contests were in div1, we should print \u0026quot;Infinity\u0026quot; because there is no upper limit for Limak\u0027s rating at any time (and there is no upper limit for the placement of the border). Otherwise we say that the highest blue point (a div2 contest with the greatest prefix sum) is a contest when Limak had rating \u003cspan class\u003d\"tex-span\"\u003e1899\u003c/span\u003e and we easily compute the final rating.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e code in C++: \u003ca href\u003d\"/contest/750/submission/24069564\" title\u003d\"Submission 24069564 by Errichto\"\u003e24069564\u003c/a\u003e\u003cbr /\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/39/f339690164360934a2243ffa0e9bb5b621839990.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e code in C++, with binary search: \u003ca href\u003d\"/contest/750/submission/24069586\" title\u003d\"Submission 24069586 by Errichto\"\u003e24069586\u003c/a\u003e\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"/contest/750/problem/D\" title\u003d\"Good Bye 2016\"\u003e750D - New Year and Fireworks\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eA trivial \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e solution is to simulate the whole process and mark visited cells. Thanks to a low constraint for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, a backtrack with memoization has much better complexity. Let\u0027s understand the reason.\u003c/p\u003e\u003cp\u003eParts of the firework move by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e in the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th level of recursion so they can\u0027t reach cells further than \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1c/af/1caf5d8614c0eeac70f05db1bfa6f9d3bc71cd9a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e from the starting cell. That sum can\u0027t exceed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e·\u003ci\u003emax\u003c/i\u003e_\u003ci\u003et\u003c/i\u003e \u003d 150\u003c/span\u003e. We can\u0027t visit cells with bigger coordinates so there are only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003en\u003c/i\u003e·\u003ci\u003emax\u003c/i\u003e_\u003ci\u003et\u003c/i\u003e)\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e cells we can visit.\u003c/p\u003e\u003cp\u003eAs usually in backtracks with memoization, for every \u003cem\u003estate\u003c/em\u003e we can do computations only once — let\u0027s think what that \u0026quot;state\u0026quot; is. We can\u0027t say that a state is defined by the current cell only, because maybe before we visited it going in a different direction and now we would reach new cells. It also isn\u0027t correct to say that we can skip further simulation if we\u0027ve already been in this cell going in the same direction, because maybe it was the different level of recursion (so now next step will in in a different direction, what can allow us to visit new cells). It turns out that a state must be defined by four values: two coordinates, a direction and a level of recursion (there are \u003cspan class\u003d\"tex-span\"\u003e8\u003c/span\u003e possible directions). One way to implement this approach is to create \u003ccode\u003eset\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; visitedStates\u003c/code\u003e where each vector contains four values that represent a state.\u003c/p\u003e\u003cp\u003eThe complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6d/b4/6db46d4f02719e5d7546ed6ca36f30dd3dc448f3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e what is enough to get AC. It isn\u0027t hard to get rid of the logarithm factor what you can see in the last code below.\u003c/p\u003e\u003cp\u003eIf implementing the simulation part is hard for you, see the first code below with too slow exponential solution. It shows an easy way to deal with \u003cspan class\u003d\"tex-span\"\u003e8\u003c/span\u003e directions and changing the direction by \u003cspan class\u003d\"tex-span\"\u003e45\u003c/span\u003e degrees — you can spend a moment to hardcode changes of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e for each direction and clockwise or counter-clockwise order and then keep an integer variable and change its value by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e modulo \u003cspan class\u003d\"tex-span\"\u003e8\u003c/span\u003e. You can add memoization to this slow code yourself and try to get AC.\u003c/p\u003e\u003cp\u003etoo slow \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e approach (TLE): \u003ca href\u003d\"/contest/750/submission/24070543\" title\u003d\"Submission 24070543 by Errichto\"\u003e24070543\u003c/a\u003e\u003cbr /\u003ethe same code with memoization (AC): \u003ca href\u003d\"/contest/750/submission/24070548\" title\u003d\"Submission 24070548 by Errichto\"\u003e24070548\u003c/a\u003e\u003cbr /\u003efaster memoization without logarithm (AC): \u003ca href\u003d\"/contest/750/submission/24070567\" title\u003d\"Submission 24070567 by Errichto\"\u003e24070567\u003c/a\u003e\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"/contest/750/problem/E\" title\u003d\"Good Bye 2016\"\u003e750E - New Year and Old Subsequence\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eIt\u0027s often helpful to think about an algorithm to solve some easier problem. To check if a string has a subsequence \u0026quot;2017\u0026quot;, we can find the find the first \u00272\u0027, then to the right from that place find the first \u00270\u0027, then first \u00271\u0027, then first \u00277\u0027. If in some of these \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e steps we can\u0027t find the needed digit on the right, the string doesn\u0027t have \u0026quot;2017\u0026quot; as a subsequence. To additionally check if there is a subsequence \u0026quot;2016\u0026quot;, after finding \u00271\u0027 (before finding \u00277\u0027) we should check if there is any \u00276\u0027 on the right. Let\u0027s refer to this algorithm as \u003cem\u003eAlgo\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eIt turns out that the problem can be solved with a segment tree (btw. the solution will also allow for queries changing some digits). The difficulty is to choose what we want to store in its nodes. Let\u0027s first use the Algo to answer simpler queries: \u003cem\u003e\u0026quot;for the given segment check if it\u0027s nice\u0026quot;\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eThere is only one thing that matters for segments represented by nodes. For a segment we want to know for every prefix of \u0026quot;2017\u0026quot; (e.g. for \u0026quot;20\u0026quot;): assuming that the Algo already got this prefix as a subsequence, what is the prefix we have after the Algo processes this segment. Let\u0027s see an example.\u003c/p\u003e\u003cp\u003eTODO\u003c/p\u003e\u003c/div\u003e","tags":["good bye 2016","good bye","editorial"]}}