{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1498081347,"rating":0,"authorHandle":"bssanches","modificationTimeSeconds":1498081347,"id":52805,"title":"\u003cp\u003eKruskal\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eKruskal é o algoritmo que resolve o problema de minimum spaning tree (MST)\u003c/p\u003e\u003cp\u003eCódigo (Só funciona em C++11):\u003c/p\u003e\u003cp\u003ePara compilar em C++11 \u003ccode\u003eg++ a.cpp -std\u003dc++11\u003c/code\u003e ou \u003ccode\u003eg++ a.cpp -std\u003dc++0x\u003c/code\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003evector\u0026lt;tuple\u0026lt;int,int,int\u0026gt; \u0026gt; edges;\n\nint f(int x)\n{\n    if (g[x] \u003d\u003d x)\n       return x;\n    return g[x] \u003d f(g[x]);\n}\n\nint unio(int x, int y)\n{\n   x \u003d f(x);\n   y \u003d f(y);\n   if (x \u003d\u003d y) return false;\n   g[x] \u003d y;\n   return true;\n}\n\nint kruskal()\n{\n   sort(edges.begin(), edges.end());\n   int mst \u003d 0;\n   for (int i \u003d 0; i \u0026lt; edges.size(); ++i)\n   {\n       int peso,x,y;\n       tie(peso, x, y) \u003d edges[i];\n       if (unio(x, y))\n            mst +\u003d peso;\n   }\n   return mst;\n}\n\n\nint main()\n{\n\n   for (int i \u003d 1; i \u0026lt;\u003d n; ++i) \n       g[i] \u003d i;\n   edges.push_back(make_tuple(peso, x, y));\n   kruskal();\n    \n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eProblemas:\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://olimpiada.ic.unicamp.br/pratique/programacao/nivel2/2011f2p2_rmapa\"\u003ehttp://olimpiada.ic.unicamp.br/pratique/programacao/nivel2/2011f2p2_rmapa\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://olimpiada.ic.unicamp.br/pratique/programacao/nivel2/2008f2p2_frete\"\u003ehttp://olimpiada.ic.unicamp.br/pratique/programacao/nivel2/2008f2p2_frete\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}