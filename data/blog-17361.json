{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1428810113,"rating":421,"authorHandle":"eduardische","modificationTimeSeconds":1428813607,"id":17361,"title":"\u003cp\u003eSolving Code Jam Qualification Round. In Excel.\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eSo, the qualification round was upon us, and it\u0027s a nice way to have some fun. In the past two years I\u0027ve been writing solutions in multiple languages. In both of them I used Excel for one problem. Without any use of VBA of course, as it would\u0027ve been too boring. This year I decided to go nuclear and use Excel for everything. I managed to get 100 points. Here are the notes on this glorious experience. .\u003c/p\u003e\u003cp\u003eSo, how does this works overall? In Excel you can import data, particularly from text. You can also specify separator, which is usually space, which means the numbers will spread out over the columns. Then you can write formulas to calculate the output row for every test, and if they\u0027re presented sequentially in one column, you can easily select them and copy-paste into any text editor.\u003c/p\u003e\u003cp\u003eLet\u0027s deal with the easiest problem first in terms of implementation in Excel — D. X is in column A, R is in column B, C is in column C. Use simple formula:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003dIF(A2\u003d\u0026quot;\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;Case #\u0026quot; \u0026amp; ROW(D2)-1 \u0026amp; \u0026quot;: \u0026quot; \u0026amp; IF(MOD(B2*C2, A2) \u003d 0, IF(A2 \u0026lt;\u003d 2, \u0026quot;GABRIEL\u0026quot;, IF(A2 \u0026gt;\u003d 7, \u0026quot;RICHARD\u0026quot;, IF(A2 \u003d 3, IF(MIN(B2, C2) \u0026lt;\u003d 1, \u0026quot;RICHARD\u0026quot;, \u0026quot;GABRIEL\u0026quot;), IF(A2 \u003d 4, IF(MIN(B2, C2) \u0026lt;\u003d 2, \u0026quot;RICHARD\u0026quot;, \u0026quot;GABRIEL\u0026quot;), IF(A2 \u003d 5, IF(OR(MIN(B2, C2) \u0026lt;\u003d 2, AND(MIN(B2, C2) \u003d 3, MAX(B2, C2) \u003d 5)), \u0026quot;RICHARD\u0026quot;, \u0026quot;GABRIEL\u0026quot;), IF(MIN(B2, C2) \u0026lt;\u003d 3, \u0026quot;RICHARD\u0026quot;, \u0026quot;GABRIEL\u0026quot;)))))), \u0026quot;RICHARD\u0026quot;))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDone. Boring. Next, please.\u003c/p\u003e\u003cp\u003eSo let\u0027s deal with A next. This introduces some complications. The data grows up to 1000 in size, so we might want to use 1000 cells. Now, we have 100 test cases and we have ourselves a first problem — source code size limit. However, we have this nice feature, that if we select a range of cells and drag the bottom-right corner of it, it will copy-paste the formula and adjust the references incrementally. We can also control what exactly do we want to change incrementally by placing \u003ccode\u003e$\u003c/code\u003e before column name or row number. For example, \u003ccode\u003e$A$1\u003c/code\u003e will always remain A1, \u003ccode\u003e$A1\u003c/code\u003e will keep the column name the same, but will increase the row number in the next row and so on. So essentially, we could still have the large data tables, however remove them initially and add some instructions to auto-fill some ranges before using the spreadsheet. So, with that in mind, we can get under 100KB for .xlsx.\u003c/p\u003e\u003cp\u003eGreat. So with A in mind, let\u0027s have 1001 columns, where we compute partial sums for all prefixes. Then, in another 1000 columns, for every position we can compute how many people do we need to add for that group to stand up and in the result column just pick the maximum of those. So, if we avoid checks for empty test cases and small stuff like that, we get formulas looking like this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003dIF(LEN($B2) \u0026gt;\u003d D$1, VALUE(MID($B2,D$1,1)) + C2, \u0026quot;\u0026quot;)\n\u003dIF($A2 \u0026gt;\u003d ALP$1, MAX(ALP$1-D2, 0), \u0026quot;\u0026quot;)\n\u003dIF($B2\u003d\u0026quot;\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;Case #\u0026quot; \u0026amp; ROW()-1 \u0026amp; \u0026quot;: \u0026quot; \u0026amp; MAX(0, ALP2:BYA2))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003eMID()\u003c/code\u003e takes one character of the string, \u003ccode\u003eVALUE()\u003c/code\u003e converts it to integer and we get our partial sums; the second line checks how much people for that index we need to add. First row has just stored indexes for convenience, we could get the same result using \u003ccode\u003eCOLUMN() - CONST\u003c/code\u003e function. Anyway, nothing complicated here, just need to make sure to make the second column where the strings ends up as column containing text. Otherwise, they might get treated as number and leading zeroes might get removed, messing up everything. Anyway, let\u0027s move on.\u003c/p\u003e\u003cp\u003eSo, we get to B. My approach was for every possible amount of non-special minutes M we sum \u003ccode\u003e(X-1)/M\u003c/code\u003e for all given values X to figure how many minutes will be special to move pancakes around. Then pick such M that the sum is minimal. Sounds great. However we need 1000 blocks for all possible values of M and then we need to divide all the data by that number, meaning that we need 1M numbers for every test case. Not ideal. So, I solved small by having 36 columns in that way, but for large we need something else, since we don\u0027t have (or at least I\u0027m not aware) how we can have a sum over range where some function is applied to every cell beforehand.\u003c/p\u003e\u003cp\u003eBut! We do have such function for one particular function — \u003ccode\u003eSUMPRODUCT()\u003c/code\u003e. It takes two or more ranges identical in size and returns the sum of their products. We need the division though. However, let\u0027s transform the data to counting how many people have X pancakes on the plate like this with 1000 columns:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003dCOUNTIF(INDIRECT(\u0026quot;A\u0026quot;\u0026amp;$ALM2):INDIRECT(\u0026quot;ALL\u0026quot;\u0026amp;$ALM2), \u0026quot;\u003d\u0026quot;\u0026amp;ALN$1)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOK, So \u003ccode\u003eINDIRECT()\u003c/code\u003e is the awesome function. It can take a string with cell name and returns a reference to it. So we just construct the name of range endpoints and then convert them to references, meaning we will look for our required number of pancakes in the correct range. Again, row 1 stores pancake counts for convenience and column ALM stores row numbers where to look for the data (could be \u003ccode\u003eROW()*2-1\u003c/code\u003e if I wasn\u0027t too lazy). Great. Now we can notice that if we fix M, the answer will be SUMPRODUCT of the data row stored in this way with the row where we divide all number (X-1) by M. Great. However we require that rows for every M. Oh well, let\u0027s put this 1000x1000 table somewhere in the spreadsheet. To make it auto-fillable, we can use something like this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003dQUOTIENT(ALO$1 - 1, ROW()-101)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003eROW()\u003c/code\u003e will get us our divisor for every row, and row 1 stores pancake counts, so we can auto-fill everything. Now we can use \u003ccode\u003eSUMPRODUCT()\u003c/code\u003e to get sums for every M:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003dSUMPRODUCT($ALN2:$BXY2, INDIRECT(\u0026quot;ALN\u0026quot; \u0026amp; 101+BXZ$1):INDIRECT(\u0026quot;BXY\u0026quot; \u0026amp; 101+BXZ$1)) + BXZ$1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFinally, just look for minimum in that range. And get our output. Done. Let\u0027s move on to the final one.\u003c/p\u003e\u003cp\u003eSo, C. Our string size is now 10K. Close to failing, since the maximum string size in Excel is 32K. Also, we only have 16K columns in sheet, so that is another concern. In my approach, I computed the result for every prefix with length \u0026lt;\u003d 40K and for every suffix with length \u0026lt;\u003d 40K. I find the shortest prefix giving i, the shortest suffix giving k, and checking if the remainder gives us j.\u003c/p\u003e\u003cp\u003eFirst problem: with previous approach we don\u0027t have enough columns. So we have to store that array in other orientation. So, how can we calculate the character from the table? I just extend it with negatives for simplicity, and have that 8x8 table somewhere in the sheet. We can then use \u003ccode\u003eMATCH()\u003c/code\u003e to find the position in header arrays for that table, and get a correct reference from there:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003dINDIRECT(CHAR(MATCH(MID(L$2, MOD(ROW()-5, L$3)+1, 1), $D$1:$K$1, 0)+67) \u0026amp; MATCH(L4, $C$2:$C$9, 0)+1)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe third argument of \u003ccode\u003eMATCH()\u003c/code\u003e changes the behavior — when it\u0027s 0 we look for first element position in array that is exactly the same. We\u0027ll use it to find the shortest prefix and suffix as well later on. Now, as we have computed all the prefixes and suffixes, I computed if the split exists in another 20 columns. The other useful function is \u003ccode\u003eADDRESS()\u003c/code\u003e, which takes row and column number and computes the string, which you can then feed to \u003ccode\u003eINDIRECT()\u003c/code\u003e, so there\u0027s no need to compute three-letter column names from column number manually, but I do that with one-letter names with \u003ccode\u003eCHAR()\u003c/code\u003e for simplicity.\u003c/p\u003e\u003cp\u003eAnyway, that\u0027s all great, but we hit another major problem — the sheet now won\u0027t calculate in 4 minutes on small dataset. Well, shit. I tried to slightly modify formulas to make them shorter, but to no avail. At the signs of desperation, I installed LibreOffice in hope that it might be somehow faster. My expectations of LibreOffice were not disappointed, as it crashed when opening already filled 50MB .xlsx and crashed when trying to fill those 8M cells, so it got uninstalled as quickly as it got installed.\u003c/p\u003e\u003cp\u003eIt was 9AM, I still hadn\u0027t slept, because I decided that spending time using Excel in ways Excel shouldn\u0027t be used is way more fun than sleeping. So, I was about to give up, but then I had one final idea — what if \u003ccode\u003eMID()\u003c/code\u003e which I use to get a single character from data in those 8M cells is somehow non O(1). The idea was stupid, but it led to some juicy results. So I quickly, inserted spaces between every letter in data in the .small input I had failed to solve in time earlier, and tried to see how quickly can I recalculate those 8M values. Since I had to manually change formulas after modifying column layout due to some $ signs, I just remove the whole result calculation part for now and tested it with every character now being in its own cell. It processed reasonably quickly. Great! Let\u0027s add result calculation back and it\u0027ll all work, right? Wrong. Same slowness. Hm, this is very weird. Is this behavior the same when I\u0027m using \u003ccode\u003eMID()\u003c/code\u003e on a huge string? Yep. Remove all result calculation and leave just prefixes and suffixes — it gets calculated in 20 seconds. I still have no idea why — my current suggestion is that caches might be to blame, as with result calculation distorted my nice dependency grid I somehow got a lot of cache misses now. Anyway, whatever the reason is, I now have something to go on.\u003c/p\u003e\u003cp\u003eIn Excel, you can turn off automatic calculation. That\u0027s a start. However, you still can\u0027t recalculate selected region. But, you can recalculate the whole sheet. And that\u0027s our solution. I left prefix/suffix calculation on one sheet, and then when I import the data I recalculate that sheet in about 20 seconds. Then I go to the second sheet, where the results are computed using those prefixes/suffixes, and now I can calculate that sheet separately, meaning it won\u0027t affect the performance of prefix/suffix calculation anymore. As such, we managed to improve spreadsheet calculation speed by splitting cells in two datasheets, which was quite a fun trick.\u003c/p\u003e\u003cp\u003eSo in the end, I managed to get my spreadsheets bug-free and get 100 points with pure Excel. For anyone interested in seeing this madness in full, \u003ca href\u003d\"http://www.go-hero.net/jam/15/name/eduardische\"\u003ehere is the link\u003c/a\u003e. Also, as mentioned above, you do need Microsoft Office (I used 2013), as LibreOffice can\u0027t handle that madness. However, it\u0027s totally fine this year, as they relaxed the rule on having a free compiler or interpreter available for the language in qualification round. Now it reads: \u0026quot;For the qualification round of Code Jam, you may use any programming language to solve a Code Jam problem, using any development environment or text editor\u0026quot;. So, that\u0027s cool. Enjoy, but probably don\u0027t try this at home. For your own sanity. I don\u0027t really want to optimize anymore spreadsheets myself. At least for another year.\u003c/p\u003e\u003c/div\u003e","tags":["code","jam","google","qualification","2015","excel","do not try this at home","gcj"]}}