{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1457407383,"rating":-7,"authorHandle":"qzqzgfy","modificationTimeSeconds":1457407448,"id":43651,"title":"\u003cp\u003eCodeforces Round #345 (Div. 2)-------The Solution And Code\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"//codeforces.com/d51463/hwsx.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e \u003cpre\u003eA. Joysticks\u003c/pre\u003e\u003cp\u003e\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d  Friends are going to play console. They have two joysticks and only one charger for them. Initially first joystick is charged at a1 percent and second one is charged at a2 percent. You can connect charger to a joystick only at the beginning of each minute. In one minute joystick either discharges by 2 percent (if not connected to a charger) or charges by 1 percent (if connected to a charger).\u003c/p\u003e \u003cpre\u003eGame continues while both joysticks have a positive charge. Hence, if at the beginning of minute some joystick is charged by 1 percent, it has to be connected to a charger, otherwise the game stops. If some joystick completely discharges (its charge turns to 0), the game also stops.\n\nDetermine the maximum number of minutes that game can last. It is prohibited to pause the game, i. e. at each moment both joysticks should be enabled. It is allowed for joystick to be charged by more than 100 percent.\u003c/pre\u003e\u003cp\u003eInput  The first line of the input contains two positive integers a1 and a2 (1 ≤ a1, a2 ≤ 100), the initial charge level of first and second joystick respectively.\u003c/p\u003e\u003cp\u003eOutput  Output the only integer, the maximum number of minutes that the game can last. Game continues until some joystick is discharged.\u003c/p\u003e\u003cp\u003eExamples input 3 5 output 6 input 4 4 output 5 It doesn\u0027t stop me too much,and the solution is to charge the one with less electricity and discharge the one with more electricity.But the first three times I got f**k in the test No.7 and finally there is a trick(maybe not) that you should break at once the two joysticks are both in 1%.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstdio\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n#include\u0026lt;cmath\u0026gt;\n#include\u0026lt;string\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\nlong long n,m,cnt;\nint main(){\n\tscanf(\u0026quot;%I64d%I64d\u0026quot;,\u0026amp;n,\u0026amp;m);\n\tcnt\u003d0;\n\twhile (1){\n\t  if (n\u0026lt;\u003d0||m\u0026lt;\u003d0) break;\n\t  if (n\u003d\u003d1\u0026amp;\u0026amp;m\u003d\u003d1) break;\n\t  if (n\u0026gt;m) std::swap(n,m);\n\t  n+\u003d1;\n\t  m-\u003d2;\n\t  cnt++;\n\t}\n\tprintf(\u0026quot;%I64d\\n\u0026quot;,cnt);\n}\n\u003c/code\u003e\u003c/pre\u003e \u003cpre\u003eB. Beautiful Paintings\u003c/pre\u003e\u003cp\u003e\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d  There are n pictures delivered for the new exhibition. The i-th painting has beauty ai. We know that a visitor becomes happy every time he passes from a painting to a more beautiful one.\u003c/p\u003e \u003cpre\u003eWe are allowed to arranged pictures in any order. What is the maximum possible number of times the visitor may become happy while passing all pictures from first to last? In other words, we are allowed to rearrange elements of a in any order. What is the maximum possible number of indices i (1 ≤ i ≤ n - 1), such that ai + 1 \u0026gt; ai.\u003c/pre\u003e\u003cp\u003eInput  The first line of the input contains integer n (1 ≤ n ≤ 1000) — the number of painting.\u003c/p\u003e \u003cpre\u003eThe second line contains the sequence a1, a2, ..., an (1 ≤ ai ≤ 1000), where ai means the beauty of the i-th painting.\u003c/pre\u003e\u003cp\u003eOutput  Print one integer — the maximum possible number of neighbouring pairs, such that ai + 1 \u0026gt; ai, after the optimal rearrangement.\u003c/p\u003e\u003cp\u003eExamples input 5 20 30 10 50 40 output 4 input 4 200 100 100 200 output 2\u003c/p\u003e\u003cp\u003eAnother water problem..,use the counting sort and every time you got a longest monotonic rise sequence a1..ai..an,and the ans+\u003d(n-1),and delete the sequence from the array sorted. when the num of the array is 0,then the ans is the ans.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstdio\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n#include\u0026lt;cmath\u0026gt;\n#include\u0026lt;string\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\nint n,x,a[1005],cnt,ans;\nint main(){\n\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\n\tfor (int i\u003d1;i\u0026lt;\u003dn;i++){\n\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;x);\n\t\ta[x]++;\n\t}\n\twhile (1){\n\t if (n\u003d\u003d0) break;\n\t int cnt\u003d0;\n     for (int i\u003d1;i\u0026lt;\u003d1000;i++) if (a[i]) cnt++,a[i]--,n--;\n     ans+\u003dcnt-1;\n    }\n   printf(\u0026quot;%d\\n\u0026quot;,ans); \n}\n\u003c/code\u003e\u003c/pre\u003e \u003cpre\u003eC. Watchmen\u003c/pre\u003e\u003cp\u003e\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d  Watchmen are in a danger and Doctor Manhattan together with his friend Daniel Dreiberg should warn them as soon as possible. There are n watchmen on a plane, the i-th watchman is located at point (xi, yi).\u003c/p\u003e \u003cpre\u003eThey need to arrange a plan, but there are some difficulties on their way. As you know, Doctor Manhattan considers the distance between watchmen i and j to be |xi - xj| + |yi - yj|. Daniel, as an ordinary person, calculates the distance using the formula .\n\nThe success of the operation relies on the number of pairs (i, j) (1 ≤ i \u0026lt; j ≤ n), such that the distance between watchman i and watchmen j calculated by Doctor Manhattan is equal to the distance between them calculated by Daniel. You were asked to compute the number of such pairs.\u003c/pre\u003e\u003cp\u003eInput  The first line of the input contains the single integer n (1 ≤ n ≤ 200 000) — the number of watchmen.\u003c/p\u003e\u003cp\u003eEach of the following n lines contains two integers xi and yi (|xi|, |yi| ≤ 109).\u003c/p\u003e\u003cp\u003eSome positions may coincide.\u003c/p\u003e\u003cp\u003eOutput  Print the number of pairs of watchmen such that the distance between them calculated by Doctor Manhattan is equal to the distance calculated by Daniel.\u003c/p\u003e\u003cp\u003eExamples input 3 1 1 7 5 1 5 output 2 input 6 0 0 0 1 0 2 -1 1 0 1 1 1 output 11\u003c/p\u003e\u003cp\u003eSolution:  First,we should know about that : the pair of two points whose Manhattan distance equals to Euclidean distance must be in the same row or the same line.But if two points are in the same coordinate,the we must delete the number that repeated.  so the final ans is: ∑the num of the points in same line+∑the num of points in the row- ∑the num of points in the same coordinate.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstdio\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n#include\u0026lt;cmath\u0026gt;\n#include\u0026lt;string\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\nstruct op{\n\tlong long x,y;\n}p[200005];\nlong long y[200005],x[200005],xx,yy,n,ans,nx[200005],ny[200005];\nbool cmp(op q,op w){\n    if (q.x\u003d\u003dw.x) return q.y\u0026lt;w.y;\n\treturn q.x\u0026lt;w.x;\n}\nint main(){\n\tscanf(\u0026quot;%I64d\u0026quot;,\u0026amp;n);\n\tfor (int i\u003d1;i\u0026lt;\u003dn;i++){\n\t\tscanf(\u0026quot;%I64d%I64d\u0026quot;,\u0026amp;xx,\u0026amp;yy);\n\t\tx[++x[0]]\u003dxx;\n\t\ty[++y[0]]\u003dyy;\n\t\tp[i].x\u003dxx;\n\t\tp[i].y\u003dyy;\n\t}\n\tstd::sort(p+1,p+1+n,cmp);\n\tstd::sort(x+1,x+1+x[0]);\n\tstd::sort(y+1,y+1+y[0]);\n\tlong long tx\u003d1;\n\tnx[1]\u003d1;\n\tfor (long long i\u003d2;i\u0026lt;\u003dx[0];i++)\n\t if (x[i]!\u003dx[i-1]) x[++tx]\u003dx[i],nx[tx]\u003d1;\n\t else nx[tx]++;\n\tx[0]\u003dtx;\n\tlong long ty\u003d1;\n\tny[1]\u003d1;\n\tfor (long long i\u003d2;i\u0026lt;\u003dy[0];i++)\n\t if (y[i]!\u003dy[i-1]) y[++ty]\u003dy[i],ny[ty]\u003d1;\n\t else ny[ty]++;\n\ty[0]\u003dty;\n\tfor (long long i\u003d1;i\u0026lt;\u003dx[0];i++)\n\t if (nx[i]\u0026gt;1) ans+\u003d(nx[i]*(nx[i]-1))/2;\n\tfor (long long i\u003d1;i\u0026lt;\u003dy[0];i++)\n\t if (ny[i]\u0026gt;1) ans+\u003d(ny[i]*(ny[i]-1))/2;\n\tlong long cnt\u003d1; \n\tfor (long long i\u003d2;i\u0026lt;\u003dn;i++)\n\t if (p[i].x\u003d\u003dp[i-1].x\u0026amp;\u0026amp;p[i].y\u003d\u003dp[i-1].y){\n\t \tcnt++;\n\t }    \n\t else{\n\t \tif (cnt\u0026gt;1) ans-\u003d(cnt-1)*cnt/2;\n\t \tcnt\u003d1;\n\t }\n\tif (cnt\u0026gt;1) ans-\u003d(cnt-1)*cnt/2;\n\tprintf(\u0026quot;%I64d\\n\u0026quot;,ans); \n}\n\u003c/code\u003e\u003c/pre\u003e \u003cpre\u003eD. Image Preview\u003c/pre\u003e\u003cp\u003e\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003c/p\u003e\u003cp\u003eVasya\u0027s telephone contains n photos. Photo number 1 is currently opened on the phone. It is allowed to move left and right to the adjacent photo by swiping finger over the screen. If you swipe left from the first photo, you reach photo n. Similarly, by swiping right from the last photo you reach photo 1. It takes a seconds to swipe from photo to adjacent.\u003c/p\u003e\u003cp\u003eFor each photo it is known which orientation is intended for it — horizontal or vertical. Phone is in the vertical orientation and can\u0027t be rotated. It takes b second to change orientation of the photo.\u003c/p\u003e\u003cp\u003eVasya has T seconds to watch photos. He want to watch as many photos as possible. If Vasya opens the photo for the first time, he spends 1 second to notice all details in it. If photo is in the wrong orientation, he spends b seconds on rotating it before watching it. If Vasya has already opened the photo, he just skips it (so he doesn\u0027t spend any time for watching it or for changing its orientation). It is not allowed to skip unseen photos.\u003c/p\u003e\u003cp\u003eHelp Vasya find the maximum number of photos he is able to watch during T seconds.\u003c/p\u003e\u003cp\u003eInput  The first line of the input contains 4 integers n, a, b, T (1 ≤ n ≤ 5·105, 1 ≤ a, b ≤ 1000, 1 ≤ T ≤ 109) — the number of photos, time to move from a photo to adjacent, time to change orientation of a photo and time Vasya can spend for watching photo.\u003c/p\u003e\u003cp\u003eSecond line of the input contains a string of length n containing symbols \u0027w\u0027 and \u0027h\u0027.\u003c/p\u003e\u003cp\u003eIf the i-th position of a string contains \u0027w\u0027, then the photo i should be seen in the horizontal orientation.\u003c/p\u003e\u003cp\u003eIf the i-th position of a string contains \u0027h\u0027, then the photo i should be seen in vertical orientation.\u003c/p\u003e\u003cp\u003eOutput  Output the only integer, the maximum number of photos Vasya is able to watch during those T seconds.\u003c/p\u003e\u003cp\u003eExamples input 4 2 3 10 wwhw output 2 input 5 2 4 13 hhwhh output 4 input 5 2 4 1000 hhwhh output 5 input 3 1 100 10 whw output 0\u003c/p\u003e\u003cp\u003eSolution:  First we must got to know: it\u0027s only once we can swipe from the one side back to the other side,because if we had read the photo,then if we back to the other side then the cost is depend on the length of the path.if we \u0026quot;across over\u0026quot; the photo we had read,then it\u0027s only once and if more,it\u0027s waste.  So we can just pretreat the cost we swipe left and swipe right.And enums to swipe left,and use two pointers to find the how far can I get to the opside with the rest time. If I go right first,then is the same. (I forgot to consider the two situations but the only one yesterday,f**k) \u003cimg alt\u003d\" \" src\u003d\"/predownloaded/7e/7f/7e7fb5f4cd6294b7b036fe961925350610521e5f.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstdio\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n#include\u0026lt;cmath\u0026gt;\n#include\u0026lt;string\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n#define ll long long\nll l[500005],r[500005],n,a,b,T,cost[500005],ans;\nll find(ll x){\n\tll L\u003d2,R\u003dn,res\u003dn;\n\tif (x\u0026lt;l[n]) return n+1;\n\tif (x\u0026gt;\u003dl[2]) return 2;\n\twhile (L\u0026lt;\u003dR){\n\t\tll mid\u003d(L+R)/2;\n\t\tif (l[mid]\u0026lt;\u003dx) res\u003dmid,R\u003dmid-1;\n\t\telse L\u003dmid+1;\n\t}\n\twhile (x\u0026lt;\u003dl[res]\u0026amp;\u0026amp;res\u0026lt;n+1) res++;\n\twhile (res\u0026gt;2\u0026amp;\u0026amp;x\u0026gt;\u003dl[res-1]) res--;\n\treturn res;\n}\nll find1(ll x){\n\tll L\u003d2,R\u003dn,res\u003dn;\n\tif (x\u0026lt;r[2]) return 1;\n\tif (x\u0026gt;\u003dr[n]) return n;\n\twhile (L\u0026lt;\u003dR){\n\t\tll mid\u003d(L+R)/2;\n\t\tif (r[mid]\u0026lt;\u003dx) res\u003dmid,L\u003dmid+1;\n\t\telse R\u003dmid-1;\n\t}\n\twhile (x\u0026lt;r[res]\u0026amp;\u0026amp;res\u0026gt;1) res--;\n\twhile (x\u0026gt;\u003dr[res+1]\u0026amp;\u0026amp;res\u0026lt;n) res++;\n\treturn res;\n}\nint main(){\n\tscanf(\u0026quot;%I64d%I64d%I64d%I64d\u0026quot;,\u0026amp;n,\u0026amp;a,\u0026amp;b,\u0026amp;T);\n\tchar s[500005];\n\tscanf(\u0026quot;%s\u0026quot;,s+1);\n\tfor (ll i\u003d1;i\u0026lt;\u003dn;i++)\n\t if (s[i]\u003d\u003d\u0027w\u0027)\n\t  cost[i]\u003db+1;\n\t else\n\t  cost[i]\u003d1;\n\tfor (ll i\u003d2;i\u0026lt;\u003dn;i++)\n\t r[i]\u003dr[i-1]+a+cost[i]; \n\tfor (ll i\u003dn;i\u0026gt;\u003d2;i--)\n\t l[i]\u003dl[i+1]+a+cost[i];\n\tfor (ll i\u003dn+1;i\u0026gt;\u003d2;i--){\n\t\tll t;\n\t\tif (i\u003d\u003dn+1)\n\t\tt\u003dT-cost[1];\n\t\telse\n\t\tt\u003dT-l[i]-cost[1]-(n-i+1)*a;\n\t\tif (t\u0026lt;0) continue;\n\t\tll x\u003dfind1(t);\n\t\tans\u003dstd::max(ans,x+(n-i+1));\n\t\tif (ans\u0026gt;n) ans\u003dn;\n\t}\n\tfor (ll i\u003d1;i\u0026lt;\u003dn;i++){\n\t  ll t;\n\t  if (i\u003d\u003d1)\n\t  t\u003dT-cost[1];\n\t  else\n\t  t\u003dT-r[i]-cost[1]-(i-1)*a;\n\t  if (t\u0026lt;0) continue;\n\t  ll x\u003dfind(t);\n\t  ans\u003dstd::max(ans,i+n-x+1);\n\t  if (ans\u0026gt;n) ans\u003dn;\n\t} \n\n\tprintf(\u0026quot;%I64d\\n\u0026quot;,ans);\n}\n\u003c/code\u003e\u003c/pre\u003e \u003cpre\u003eE. Table Compression\u003c/pre\u003e\u003cp\u003e\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003cbr /\u003e Little Petya is now fond of data compression algorithms. He has already studied gz, bz, zip algorithms and many others. Inspired by the new knowledge, Petya is now developing the new compression algorithm which he wants to name dis.\u003c/p\u003e\u003cp\u003ePetya decided to compress tables. He is given a table a consisting of n rows and m columns that is filled with positive integers. He wants to build the table a\u0027 consisting of positive integers such that the relative order of the elements in each row and each column remains the same. That is, if in some row i of the initial table ai, j \u0026lt; ai, k, then in the resulting table a\u0027i, j \u0026lt; a\u0027i, k, and if ai, j \u003d ai, k then a\u0027i, j \u003d a\u0027i, k. Similarly, if in some column j of the initial table ai, j \u0026lt; ap, j then in compressed table a\u0027i, j \u0026lt; a\u0027p, j and if ai, j \u003d ap, j then a\u0027i, j \u003d a\u0027p, j.\u003c/p\u003e\u003cp\u003eBecause large values require more space to store them, the maximum value in a\u0027 should be as small as possible.\u003c/p\u003e\u003cp\u003ePetya is good in theory, however, he needs your help to implement the algorithm.\u003c/p\u003e\u003cp\u003eInput  The first line of the input contains two integers n and m (, the number of rows and the number of columns of the table respectively.\u003c/p\u003e\u003cp\u003eEach of the following n rows contain m integers ai, j (1 ≤ ai, j ≤ 109) that are the values in the table.\u003c/p\u003e\u003cp\u003eOutput  Output the compressed table in form of n lines each containing m integers.\u003c/p\u003e\u003cp\u003eIf there exist several answers such that the maximum number in the compressed table is minimum possible, you are allowed to output any of them.\u003c/p\u003e\u003cp\u003eExamples input 2 2 1 2 3 4 output 1 2 2 3 input 4 3 20 10 30 50 40 30 50 60 70 90 80 70 output 2 1 3 5 4 3 5 6 7 9 8 7\u003c/p\u003e\u003cp\u003eSolution:  The last problem.I don\u0027t know how to deal with it in exam :|  Next day,after consulting others\u0027code,it passed finally.  First we sort the n*m numbers in their value.  Every time extract the same numbers,union the numbers in same rows or in same lines by using union-find,and find the max number which is in the same row or line to the number of the set.and the ans of the number now I\u0027m solving is the maxinum+1.(My express maybe some kind of ambiguous:)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstdio\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n#include\u0026lt;cmath\u0026gt;\n#include\u0026lt;string\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n#define N 1000005\nstruct op{\n\tint x,y,num;\n}f[N];\nint tot,go[N],first[N],next[N],n,m,fa[N],a[N],b[N];\nbool cmp1(op q,op w){\n\treturn q.x\u0026lt;w.x;\n}\nbool cmp2(op q,op w){\n\treturn q.num\u0026lt;w.num;\n}\nbool cmp3(op q,op w){\n\treturn (q.num-1)/m\u0026lt;(w.num-1)/m;\n}\nbool cmp4(op q,op w){\n\treturn (q.num-1)%m\u0026lt;(w.num-1)%m;\n}\nint find(int x){\n\tif (x\u003d\u003dfa[x]) return x;\n\telse return fa[x]\u003dfind(fa[x]);\n}\nvoid insert(int x,int y){\n\ttot++;\n\tgo[tot]\u003dy;\n\tnext[tot]\u003dfirst[x];\n\tfirst[x]\u003dtot;\n}\nint main(){\n\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\n\tfor (int i\u003d1;i\u0026lt;\u003dn*m;i++){\n\t scanf(\u0026quot;%d\u0026quot;,\u0026amp;f[i].x);\n\t f[i].num\u003di;\n\t fa[i]\u003di; \n    }\n    std::sort(f+1,f+1+n*m,cmp1);\n    int la\u003d0;\n    for (int i\u003d1;i\u0026lt;\u003dn*m;i\u003dla+1){\n    \tla\u003di;\n\t\twhile (f[la+1].x\u003d\u003df[la].x\u0026amp;\u0026amp;la\u0026lt;n*m) la++;\n\t\tstd::sort(f+i,f+la+1,cmp3);\n\t\tfor (int j\u003di+1;j\u0026lt;\u003dla;j++)\n\t\t if ((f[j].num-1)/m\u003d\u003d(f[j-1].num-1)/m)\n\t\t  fa[find(f[j].num)]\u003dfind(f[j-1].num);\n\t\tstd::sort(f+i,f+la+1,cmp4);\n\t\tfor (int j\u003di+1;j\u0026lt;\u003dla;j++)\n\t\t if ((f[j].num-1)%m\u003d\u003d(f[j-1].num-1)%m\u0026amp;\u0026amp;find(f[j-1].num)!\u003dfind(f[j].num))\n\t\t  fa[find(f[j].num)]\u003dfind(f[j-1].num);\n\t\tfor (int j\u003di;j\u0026lt;\u003dla;j++)\n\t\t insert(find(f[j].num),j);\n\t\tfor (int j\u003di;j\u0026lt;\u003dla;j++){\n\t\t\tint o\u003df[j].num,now\u003d0;\n\t\t\tfor (int k\u003dfirst[o];k;k\u003dnext[k]){\n\t\t\t\tnow\u003dstd::max(now,std::max(a[(f[k].num-1)/m+1],b[(f[k].num-1)%m+1]));\n\t\t\t}\n\t\t\tfor (int k\u003dfirst[o];k;k\u003dnext[k]){\n\t\t\t\tf[k].y\u003dnow+1;\n\t\t\t\ta[(f[k].num-1)/m+1]\u003db[(f[k].num-1)%m+1]\u003dnow+1;\n\t\t\t}\n\t\t}     \n    }\n    std::sort(f+1,f+1+n*m,cmp2);\n    for (int i\u003d1;i\u0026lt;\u003dn;i++){\n    \tfor (int j\u003d1;j\u0026lt;\u003dm;j++)\n    \t printf(\u0026quot;%d \u0026quot;,f[(i-1)*m+j].y);\n    \tprintf(\u0026quot;\\n\u0026quot;); \n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["water","enums","union-find","sorting","two pointers","counting"]}}