{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1513937591,"rating":0,"authorHandle":"Helgui","modificationTimeSeconds":1513937591,"id":56547,"title":"\u003cp\u003eОбыкновенные дроби и длинка в факторизованном виде\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eДроби с точки зрения теории чисел\u003c/h3\u003e\u003cp\u003eО том, что есть предпериод и период дроби (в обеих PDF примерно одно и то же): \u003ca href\u003d\"https://yadi.sk/i/TKKZsm5e3Qr2zw\"\u003eдроби №1\u003c/a\u003e, \u003ca href\u003d\"https://yadi.sk/i/I-IUHgEo3Qr33h\"\u003eдроби №2\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eВыводы\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003col\u003e   \u003cli\u003eДробь имеет конечную десятичную запись, если её знаменатель \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sup\u003e·5\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. Такая дробь имеет \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e цифр после запятой.\u003c/li\u003e   \u003cli\u003eВ остальных случаях дробь имеет бесконечную запись, состояющую из периода и, возможно, предпериода. Если знаменатель дроби представить, как \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sup\u003e·5\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sup\u003e·\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e не делится ни на 5, ни на 2, то длина предпериода — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e, а длина периода — показатель \u003cspan class\u003d\"tex-span\"\u003e10\u003c/span\u003e по модулю \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e. Показатель числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e по модулю \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e (\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/55/81/55819366104bab7ceab8be9500610d13c0a4d88e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e) — наименьшее \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u0026gt; 0\u003c/span\u003e, при котором \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a0/9e/a09ed606a8fa4175e6232f1ea5bb0ba3d003f06f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/li\u003e   \u003cli\u003eДлина периода \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e / \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e не превышает \u003cspan class\u003d\"tex-span\"\u003eφ(\u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e, т.к. по теореме Эйлера \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e0/33/e0331efe37c02b2ccb9a49e9b47f19396efdb597.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e для любого \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, взаимнопростого с \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e\u003c/li\u003e \u003c/ol\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eДля решения задачи необходимо понять, как взаимосвязан показатель числа по модулю и функция Эйлера (кроме того, что показатель не больше).\u003c/p\u003e\u003ch3\u003eДлинная арифметика в факторизованном виде\u003c/h3\u003e\u003cp\u003eМногие операции над числами сводятся к операциям над их факторизациями:\u003c/p\u003e \u003col\u003e   \u003cli\u003eУмножение, деление без остатка (и проверка делимости)\u003c/li\u003e   \u003cli\u003eИзвлечение корня любой степени (и проверка его извлекаемости), логарифмирование (и проверка логарифмируемости)\u003c/li\u003e   \u003cli\u003eВычисление gcd и lcm\u003c/li\u003e   \u003cli\u003eВычисление теоретико-числовых функций (число делителей, сумма делителей, функция Эйлера и т.д.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eСведение к операциям над факторизациями выполняется на основе простейших свойств, например, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sup\u003e·\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sup\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sup\u003e / \u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sup\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e - \u003ci\u003eb\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sup\u003e)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sup\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ea\u003c/i\u003e·\u003ci\u003eb\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. Это является предметом задачи, поэтому подробно разбирать конкретные случаи мы не будем. Рассмотрим, как может быть реализована длинная арифметика в факторизованном виде.\u003c/p\u003e\u003ch4\u003eСлучай 1 — небольшие простые в факторизации\u003c/h4\u003e\u003cp\u003eЕсли простые числа в факторизации ограничены, скажем, \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e, то можно хранить факторизацию в массиве \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e[10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e]\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e]\u003c/span\u003e — степень простого \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e. Очевидно, что сложность и по памяти, и по времени будет \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — максимально возможное простое число. Для примера рассмотрим реализацию умножения.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid multiply(int *a, int *b, int *res) {\n\tfor(int i \u003d 2; i \u0026lt;\u003d MAX; ++i) {\n\t\tres[i] \u003d a[i] + b[i]\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЭтот способ самый короткий, но уместен лишь тогда, когда число операций невелико.\u003c/p\u003e\u003ch4\u003eСлучай 2.1 — используем map\u003c/h4\u003e\u003cp\u003eЕсли мы не можем хранить факторизацию в обычном массиве, то выход очевиден — используем ассоциативный массив. В этом случае факторизация занимает \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eF\u003c/i\u003e)\u003c/span\u003e памяти, а операции выполняются за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eF\u003c/i\u003e·\u003ci\u003eM\u003c/i\u003e(\u003ci\u003eF\u003c/i\u003e))\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003c/span\u003e — размер факторизации, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e(\u003ci\u003eF\u003c/i\u003e)\u003c/span\u003e — сложность доступа к элементу контейнера (логарифм или амортизированная константа). В качестве примера рассмотрим реализацию \u003ccode\u003egcd\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003emap\u0026lt;int, int\u0026gt; gcd(const map\u0026lt;int, int\u0026gt; \u0026amp;a, const map\u0026lt;int, int\u0026gt; \u0026amp;b) {\n\tmap\u0026lt;int, int\u0026gt; res;\n\tfor(const auto \u0026amp;f : a) {\n\t\tauto it \u003d b.find(f.first);\n\t\tif (it \u003d\u003d b.end())\n\t\t\tcontinue;\n\t\tres.emplace(f.first, min(f.second, it -\u0026gt; second));\n\t}\n\treturn res;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003eСлучай 2.2 — алгоритм слияния\u003c/h4\u003e\u003cp\u003eАлгоритм слияния позволяет объединить две упорядоченные последовательности в одну за линейное время\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;int\u0026gt; merge(const vector\u0026lt;int\u0026gt; \u0026amp;a, const vector\u0026lt;int\u0026gt; \u0026amp;b) {\n\tvector\u0026lt;int\u0026gt; res;\n\tsize_t p1 \u003d 0, p2 \u003d 0;\n\twhile(p1 \u0026lt; a.size() \u0026amp;\u0026amp; p2 \u0026lt; b.size) {\n\t\tif (a[p1] \u0026lt; b[p2]) {\n\t\t\tres.push_back(a[p1]);\n\t\t\t++p1;\n\t\t\tcontinue;\n\t\t}\n\t\tres.push_back(b[p2]);\n\t\t++p2;\n\t}\n\t//из двух следующих циклов выполнится только один\n\tfor(; p1 \u0026lt; a.size(); ++p1) {\n\t\tres.push_back(a[p1]);\n\t}\n\tfor(; p2 \u0026lt; b.size(); ++p2) {\n\t\tres.push_back(b[p2]);\n\t}\n\treturn res;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЕсли факторизации упорядочены по величине простых, то операции над ними можно выполнять на основе алгоритма слияния за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eF\u003c/i\u003e)\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003c/span\u003e — размер факторизации. Эффективнее всего хранить числа в векторах, отсортировав исходные числа, если требуется. Результаты операций будут упорядочены благодаря алгоритму слияния. Можно заметить, что стандартный алгоритм факторизации за корень также даёт упорядоченную факторизацию. Пример реализации умножения алгоритмом слияния:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e//Factor - пара (p, e) - простое число и показатель степени\nvector\u0026lt;Factor\u0026gt; mult(const vector\u0026lt;Factor\u0026gt; \u0026amp;a, const vector\u0026lt;Factor\u0026gt; \u0026amp;b) {\n\tvector\u0026lt;Factor\u0026gt; res;\n\tsize_t p1 \u003d 0, p2 \u003d 0;\n\twhile (p1 \u0026lt; a.size() \u0026amp;\u0026amp; p2 \u0026lt; b.size()) {\n\t\tif (a[p1].p \u003d\u003d b[p2].p) {\n\t\t\tres.emplace_back(a[p1].p, a[p1].e + b[p2].e);\n\t\t\t++p1; ++p2;\n\t\t\tcontinue;\n\t\t}\t\t\n\t\tif (primes[p1] \u0026lt; b.primes[p2]) {\n\t\t\tres.push_back(a[p1]);\n\t\t\t++p1;\n\t\t\tcontinue;\n\t\t}\n\t\tres.push_back(b[p2]);\n\t\t++p2;\n\t}\n\n\tfor(; p1 \u0026lt; a.size(); ++p1) {\n\t\tres.push_back(a[p1]);\n\t}\n\t\n\tfor(; p2 \u0026lt; b.size(); ++p2) {\n\t\tres.push_back(b[p2]);\n\t}\n\treturn res;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}