{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1526476393,"rating":0,"authorHandle":"Sammarize","modificationTimeSeconds":1526481070,"id":59499,"title":"\u003cp\u003eРазбор командной тренировки\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eРазбор задач напишем в порядке возрастания сложности задач.\u003c/h3\u003e\u003ch2\u003eЗадача B (Выражение).\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eНапоминание об условии:\u003c/strong\u003e В этой задаче требовалось найти минимальный номер числа в данной последовательности, которое равно сумме всех остальных чисел.\u003cbr /\u003e Можно было заметить, что если какое-то число равно сумме всех остальных, то оно также равно половине суммы всех чисел. Поэтому можно было найти сумму всех чисел, и далее найти первое число, которое было равно половине этой суммы. Впрочем, ограничения позволяли бесхитростно перебрать все числа и проверить условие для каждого по-отдельности:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (int i \u003d 0; i \u0026lt; n; i++) {\n    int sum \u003d 0;\n    for (int j \u003d 0; j \u0026lt; n; j++) if (j !\u003d i)\n        sum +\u003d a[j];\n    if (a[i] \u003d\u003d sum) {\n        cout \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n        break;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eЗадача Е (Игра с графом)\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eНапоминание об условии:\u003c/strong\u003e В этой задача требовалось определить, кто из игроков проиграет в игре с удалением рёбер из графа.\u003cbr /\u003e Давайте отметим, что всегда, когда в графе ещё есть цикл, игром может походить, удалив одно из рёбер цикла и оставив граф связным. Когда циклов нет, это означает, что граф — дерево, и удаление любого ребра приводит к поражению. Таким образом, игроки будут играть, пока граф не станет деревом, после чего один из них проиграет. Изначально в графе \u003ccode\u003em\u003c/code\u003e рёбер, в дереве \u003ccode\u003en-1\u003c/code\u003e ребро и на каждом ходу количество рёбер уменьшается на один. Значит, чтобы определить , кто проиграет, надо просто определить, чётно ли число \u003ccode\u003em - (n - 1)\u003c/code\u003e.\u003cbr /\u003e Так же есть вариант, когда в графе 1 вершина и нет рёбер. Тогда никто из игроков не может походить и, соответственно, никто из них не проиграет.\u003cbr /\u003e\u003c/p\u003e\u003ch2\u003eЗадача F (Монстры)\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eНапоминание об условии:\u003c/strong\u003e В этой задача требовалось определить, сможет ли игрок, создавая Феврониев, уничтожить всех монстров в комнатах.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eПрожорливость Феврониев, будет равна степеням двойки, начиная с единицы. Игроку надо распределить их по комнатам таким образом, чтобы сумма прожорливостей Феврониев, посланных в каждую комнату, была равна количеству монстров в этой комнате. Рассмотрим первого Феврония, его прожорливость равна 1. Прожорливость всех остальных Феврониев чётна. Следовательно, должна быть ровно одна комната, в которой нечётное количество монстров, в которую и надо послать первого Феврония. Если это не так, игроку не жить.\u003c/p\u003e\u003cp\u003eРассмотрим второго Феврония, его прожорливость 2. Прожорливость всех остальных Феврониев кратна 4. Следовательно, должна быть ровно одна комната в которой количество оставшихся монстров не делится на 4, туда и надо послать второго Феврония, иначе игроку не жить.\u003c/p\u003e\u003cp\u003eТак дальше и будем рассылать Феврониев по комнатам, согласно этому принципу, пока не выяснится, что монстры во всех комнатах кончились или что очередного Феврония некуда послать.\u003c/p\u003e\u003ch2\u003eЗадача C (Строки фибоначчи)\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eНапоминание об условии:\u003c/strong\u003e В этой задаче требовалось определить длину максимального палиндрома в строчке определённого вида.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eВ этой задаче, если записать ещё несколько строк фибоначчи и посмотреть на них, нетрудно было заметить, а затем доказать по индукции, что вся строка без последних двух символов будет палинромом. Можно было предположить, что начиная с \u003ccode\u003ek\u003d5\u003c/code\u003e ответ будет равен \u003ccode\u003ek\u003c/code\u003e-тому числу Фибоначчи \u003ccode\u003e-2\u003c/code\u003e и послать. Доказать это тоже можно, но муторно.\u003c/p\u003e\u003cp\u003eЗадача D (Кубок Гагарина)\u003cbr /\u003e \u003cstrong\u003eНапоминание об условии:\u003c/strong\u003e В этой задаче требовалось определить вероятность того, что матч закончится с определённым счётом.\u003cbr /\u003e Чтобы решить эту задачу, проще всего написать рекурсивную функцию:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003edouble p(int a, int b, int c, int d)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eкоторая вычисляет вероятность того, что серия закончится счётом \u003ccode\u003ec:d\u003c/code\u003e при условии, что сейчас счёт \u003ccode\u003ea:b\u003c/code\u003e.\u003cbr /\u003e При этом будем использовать \u003cbr /\u003e массив \u003ccode\u003eq[] \u003d {q1, q2}\u003c/code\u003e, где \u003ccode\u003eq1\u003c/code\u003e — вероятность победы первой команды на своём поле, а \u003ccode\u003eq2\u003c/code\u003e — вероятность победы первой команды на чужом поле.\u003cbr /\u003e массив \u003ccode\u003efield[] \u003d {0, 0, 1, 1, 0, 1, 0}\u003c/code\u003e -- поле, на котором проводится очередной матч.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003edouble p(int a, int b, int c, int d) {\n    if (a \u0026gt; c) return 0;\n    if (b \u0026gt; d) return 0;\n    return p[a + b] * p(a + 1, b, c, d) + (1 - p[a + b]) * (p(a, b + 1, c, d));\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eЗадача A (Держать строй — 3)\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eНапоминание об условии:\u003c/strong\u003e В этой задаче требовалось найти непрерывный подотрезок солдат с максимальный суммарным показателем роста.\u003cbr /\u003e Задача делится на две части: сначала найти показатели роста всех солдат, а потом найти искомый отрезок.\u003c/p\u003e\u003cp\u003eЕсли внимательно прочитать условие, можно увидеть, что показатель роста солдата — это на самом деле обще количество солдат ниже данного. Есть множество способов найти это количество для всех солдат. Разумеется, мы не можем просто для всех солдат перебрать всех остальных и посчитать количество солдит ниже ростом, потому что это будет слишком долго. Однако мы можем, например, отсортировать всех солдат по возрастанию и для каждого солдата бинпоиском найти момент, когда начинаются солдаты одного роста с ним.\u003c/p\u003e\u003cp\u003eТеперь остаётся только воспользовать методом двух указателей: перебирая начало отрезка солдатов длины \u003ccode\u003ek\u003c/code\u003e, мы будем модифицировать сумма показателей роста солдат на этом отрезке, убирая одного солдата, который больше не входит в отрезок и добавляя одного, который входит.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003elong long sum \u003d 0;\nfor (int i \u003d 0; i \u0026lt; k; i++) sum +\u003d p[i];\nlong long maxsum \u003d sum;\nint answ \u003d 0;\nfor (int i \u003d k; i \u0026lt; n; i++) {\n    sum +\u003d p[i] - p[i - k];\n    if (sum \u0026gt; maxsum) {\n        maxsum \u003d sum;\n        answ \u003d i;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eЗадача H (СМС)\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eНапоминание об условии\u003c/strong\u003e: Определить расположение кнопок на клавиатуре, которое позволяет минимизировать количество нажатий кнопок при наборе текста.\u003c/p\u003e\u003cp\u003eЭту задачу можно решить с помощью динамики. А именно, можно динамически посчитать функцию \u003ccode\u003ef(a, b)\u003c/code\u003e — минимальное количество нажатий, которое придётся сделать на первые \u003ccode\u003ea\u003c/code\u003e кнопок, если мы разместим там первые \u003ccode\u003eb\u003c/code\u003e букв.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003elong long inf \u003d 1e9;\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(m + 1, vector\u0026lt;int\u0026gt;(n + 1, inf));\nf[0][0] \u003d 0;\nfor (int i \u003d 1; i \u0026lt;\u003d m; i++) {\n    for (int j \u003d 1; j \u0026lt;\u003d n; j++) {\n        for (int t \u003d 1; t \u0026lt;\u003d j; t++) {\n            int sum \u003d 0;\n            for (int s \u003d 1; s \u0026lt;\u003d t; s++) sum +\u003d a[j - t + s] * s;\n            f[i][j] \u003d min(f[i][j], f[i - 1][j - t] + sum);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eЗадача G (Фотография)\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eНапоминание об условии\u003c/strong\u003e: В этой задаче требовалось определить количество возможных дат с данном промежутке, удовлетворяющих даным ограничениям.\u003c/p\u003e\u003cp\u003eПоскольку в интервале возможных дат находится меньше 70 лет, всего есть меньше 10000 возможных дат. Поэтому можно просто перебрать все даты в данном промежутке и проверить каждую по-отдельности. Чтобы перебирать даты, наддо написать небольшую функцию \u003ccode\u003enextDate\u003c/code\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint monthLen(int y, int m) {\n    if (m \u003d\u003d 2 \u0026amp;\u0026amp; (y % 4 \u003d\u003d 0 \u0026amp;\u0026amp; (y % 400 \u003d\u003d 0 || y % 100 !\u003d 0)) return monthLenArray[m] + 1;\n    return monthLenArray[m];\n}\n\nvoid nextDate(int\u0026amp; y, int\u0026amp; m, int\u0026amp; d) {\n    if (d \u0026lt; monthLen(y, m)) d++;\n    else {\n        d \u003d 1;\n        if (m \u0026lt; 12) m++;\n        else {\n            m \u003d 1;\n            y++;\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}