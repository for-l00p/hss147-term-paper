{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1458914425,"rating":43,"authorHandle":"Edvard","modificationTimeSeconds":1461769838,"id":43986,"title":"\u003cp\u003eEditorial of Educational Codeforces Round 10\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/652/problem/A\" title\u003d\"Educational Codeforces Round 10\"\u003e652A - Gabriel and Caterpillar\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem was suggested by \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/unprost\" title\u003d\"Expert unprost\"\u003eunprost\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eLet\u0027s consider three cases.\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + 8\u003ci\u003ea\u003c/i\u003e ≥ \u003ci\u003eh\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e — in this case the caterpillar will get the apple on the same day, so the answer is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThe first condition is false and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e ≤ \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e — in this case the caterpillar will never get the apple, because it can\u0027t do that on the first day and after each night it will be lower than one day before.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf the first two conditions are false easy to see that the answer equals to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f5/b4/f5b4d2645f7a0c92e0b50553da334312041bca22.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eint h1, h2;\nint a, b;\n\nbool read() {\n\treturn !!(cin \u0026gt;\u0026gt; h1 \u0026gt;\u0026gt; h2 \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b);\n}\n\nvoid solve() {\n\tif (h1 + 8 * a \u0026gt;\u003d h2)\n\t\tputs(\u0026quot;0\u0026quot;);\n\telse if (a \u0026gt; b) {\n\t\tint num \u003d h2 - h1 - 8 * a, den \u003d 12 * (a - b);\n\t\tcout \u0026lt;\u0026lt; (num + den - 1) / den \u0026lt;\u0026lt; endl;\n\t} else\n\t\tputs(\u0026quot;-1\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eAlso this problem can be solved by simple modelling, because the heights and speeds are small.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/652/problem/B\" title\u003d\"Educational Codeforces Round 10\"\u003e652B - z-sort\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem was suggested by \u003ca class\u003d\"rated-user user-green\" href\u003d\"/profile/aminra\" title\u003d\"Pupil aminra\"\u003eaminra\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eEasy to see that we can \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e-sort any array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. Let \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/27/bc/27bc5750d56e1bf4e6fbfb75b7742b5071ed4060.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e be the number of even positions in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. We can assign to those positions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e maximal elements and distribute other \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e elements to odd positions. Obviously the resulting array is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e-sorted.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003econst int N \u003d 1010;\n\nint n, a[N];\n\nbool read() {\n\tif (!(cin \u0026gt;\u0026gt; n)) return false;\n\tforn(i, n) assert(scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]) \u003d\u003d 1);\n\treturn true;\n}\n\nint ans[N];\n\nvoid solve() {\n\tsort(a, a + n);\n\n\tint p \u003d 0, q \u003d n - 1;\n\tforn(i, n)\n\t\tif (i \u0026amp; 1) ans[i] \u003d a[q--];\n\t\telse ans[i] \u003d a[p++];\n\tassert(q + 1 \u003d\u003d p);\n\n\tforn(i, n) {\n\t\tif (i) putchar(\u0027 \u0027);\n\t\tprintf(\u0026quot;%d\u0026quot;, ans[i]);\n\t}\n\tputs(\u0026quot;\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlogn\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/652/problem/C\" title\u003d\"Educational Codeforces Round 10\"\u003e652C - Foe Pairs\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThis is one of the problems suggested by Bayram Berdiyev \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Bayram\" title\u003d\"Expert Bayram\"\u003eBayram\u003c/a\u003e, Allanur Shiriyev \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Allanur-98\" title\u003d\"Expert Allanur-98\"\u003eAllanur-98\u003c/a\u003e, Bekmyrat Atayev \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Bekmyrat-Atayev\" title\u003d\"Expert Bekmyrat-Atayev\"\u003eBekmyrat-Atayev\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eLet\u0027s precompute for each value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e its position in permutation \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. It\u0027s easy to do in linear time. Consider some foe pair \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e (we may assume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e \u0026lt; \u003ci\u003epos\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e). Let\u0027s store for each value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e the leftmost position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epos\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e is a foe pair. Denote that value as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Now let\u0027s iterate over the array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e from right to left and maintain the position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003erg\u003c/i\u003e\u003c/span\u003e of the maximal correct interval with the left end in the current position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elf\u003c/i\u003e\u003c/span\u003e. To maintain the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003erg\u003c/i\u003e\u003c/span\u003e we should simply take the minimum with the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e[\u003ci\u003elf\u003c/i\u003e]\u003c/span\u003e: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003erg\u003c/i\u003e \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003erg\u003c/i\u003e, \u003ci\u003ez\u003c/i\u003e[\u003ci\u003elf\u003c/i\u003e])\u003c/span\u003e. And finally we should increment the answer by the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003erg\u003c/i\u003e - \u003ci\u003elf\u003c/i\u003e + 1\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003econst int N \u003d 300300;\n\nint n, m;\nint p[N];\npt b[N];\n\nbool read() {\n\tif (!(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m)) return false;\n\tforn(i, n) {\n\t\tassert(scanf(\u0026quot;%d\u0026quot;, \u0026amp;p[i]) \u003d\u003d 1);\n\t\tp[i]--;\n\t}\n\tforn(i, m) {\n\t\tint x, y;\n\t\tassert(scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;x, \u0026amp;y) \u003d\u003d 2);\n\t\tx--, y--;\n\t\tb[i] \u003d pt(x, y);\n\t}\n\treturn true;\n}\n\nint pos[N];\nvector\u0026lt;int\u0026gt; z[N];\n\nvoid solve() {\n\tforn(i, n) pos[p[i]] \u003d i;\n\tforn(i, n) z[i].clear();\n\tforn(i, m) {\n\t\tint x \u003d pos[b[i].x], y \u003d pos[b[i].y];\n\t\tif (x \u0026gt; y) swap(x, y);\n\t\tz[x].pb(y);\n\t}\n\n\tli ans \u003d 0;\n\tint rg \u003d n;\n\tnfor(i, n) {\n\t\tforn(j, sz(z[i])) rg \u003d min(rg, z[i][j]);\n\t\tans +\u003d rg - i;\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/652/problem/D\" title\u003d\"Educational Codeforces Round 10\"\u003e652D - Nested Segments\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem was suggested by Alexey Dergunov \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/dalex\" title\u003d\"Candidate Master dalex\"\u003edalex\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThis problem is a standard two-dimensional problem that can be solved with one-dimensional data structure. In the same way a lot of other problems can be solved (for example the of finding the maximal weighted chain of points so that both coordinates of each point are greater than the coordinates of the predecessing point). Rewrite the problem formally: for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e we should count the number of indices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e so that the following conditions are hold: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u0026lt; \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u0026lt; \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Let\u0027s sort all segments by the left ends from right to left and maintain some data structure (Fenwick tree will be the best choice) with the right ends of the processed segments. To calculate the answer for the current segment we should simple take the prefix sum for the right end of the current segment.\u003c/p\u003e\u003cp\u003eSo the condition \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u0026lt; \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is hold by sorting and iterating over the segments from the right to the left (the first dimension of the problem). The condition \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u0026lt; \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is hold by taking the prefix sum in data structure (the second dimension).\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003econst int N \u003d 1200300;\n\nint n;\npair\u0026lt;pti, int\u0026gt; a[N];\n\nbool read() {\n\tif (!(cin \u0026gt;\u0026gt; n)) return false;\n\tforn(i, n) assert(scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;a[i].x.x, \u0026amp;a[i].x.y) \u003d\u003d 2), a[i].y \u003d i;\n\treturn true;\n}\n\nint t[N];\nvector\u0026lt;int\u0026gt; ys;\n\ninline void inc(int i, int val) {\n\tfor ( ; i \u0026lt; sz(ys); i |\u003d i + 1)\n\t\tt[i] +\u003d val;\n}\n\ninline int sum(int i) {\n\tint ans \u003d 0;\n\tfor ( ; i \u0026gt;\u003d 0; i \u003d (i \u0026amp; (i + 1)) - 1)\n\t\tans +\u003d t[i];\n\treturn ans;\n}\n\nint ans[N];\n\nvoid solve() {\n\tys.clear();\n\tforn(i, n) ys.pb(a[i].x.y);\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tforn(i, sz(ys)) t[i] \u003d 0;\n\n\tsort(a, a + n);\n\tnfor(i, n) {\n\t\tint idx \u003d int(lower_bound(all(ys), a[i].x.y) - ys.begin());\n\t\tans[a[i].y] \u003d sum(idx);\n\t\tinc(idx, +1);\n\t}\n\n\tforn(i, n) printf(\u0026quot;%dn\u0026quot;, ans[i]);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlogn\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/652/problem/E\" title\u003d\"Educational Codeforces Round 10\"\u003e652E - Pursuit For Artifacts\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem was suggested by Alexey Dergunov \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/dalex\" title\u003d\"Candidate Master dalex\"\u003edalex\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eEdge biconnected component in an undirected graph is a maximal by inclusion set of vertices so that there are two edge disjoint paths between any pair of vertices. Consider the graph with biconnected components as vertices. Easy to see that it\u0027s a tree (if it contains some cycle then the whole cycle is a biconnected component). All edges are destroying when we passing over them so we can\u0027t returnto the same vertex (in the tree) after leaving it by some edge.\u003c/p\u003e\u003cp\u003eConsider the biconncted components that contains the vertices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. Let\u0027s denote them \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e. Statement: the answer is \u003cem\u003eYES\u003c/em\u003e if and only if on the path in the tree from the vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e to the vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e there are an edge with an artifact or there are a biconnected component that contains some edge with an artifact. Easy to see that the statement is true: if there are such edge then we can pass over it in the tree on the path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e or we can pass over it in biconnected component. The converse also easy to check.\u003c/p\u003e\u003cp\u003eHere is one of the ways to find edge biconnected components:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eLet\u0027s orient all edges to direction that depth first search passed it for the first time.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eLet\u0027s find in new directed graph strongly connected components.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eStatement: the strongly connected components in the new graph coincide with the biconnected components in old undirected graph.\u003c/p\u003e\u003cp\u003eAlso you can notice that the edges in tree is the bridges of the graph (bridges in terms of graph theory). So you can simply find the edges in the graph.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eNot too short C++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003econst int N \u003d 500500, M \u003d 500500;\u003c/p\u003e\u003cp\u003eint n, m; int eused[M]; vector eid[N]; vector g1[N], tg1[N]; vector w[N]; int a, b;\u003c/p\u003e\u003cp\u003ebool read() {  if (!(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m)) return false;  forn(i, m) eused[i] \u003d false;  forn(i, n) {  g1[i].clear();  tg1[i].clear();  eid[i].clear();  w[i].clear();  }  forn(i, m) {  int x, y, z;  assert(scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;x, \u0026amp;y, \u0026amp;z) \u003d\u003d 3);  x--, y--;  g1[x].pb(y);  g1[y].pb(x);  eid[x].pb(i);  eid[y].pb(i);  w[x].pb(z);  w[y].pb(z);  }  assert(cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b);  a--, b--;  return true; }\u003c/p\u003e\u003cp\u003eint u, used[N]; int sz, perm[N];\u003c/p\u003e\u003cp\u003evoid dfs1(int v) {  used[v] \u003d u;  forn(i, sz(g1[v])) {  int u \u003d g1[v][i];  int cid \u003d eid[v][i];  if (!eused[cid]) {  eused[cid] \u003d true;  tg1[u].pb(v);  }  if (used[u] !\u003d ::u)  dfs1(u);  }  perm[sz++] \u003d v; }\u003c/p\u003e\u003cp\u003eint c, comp[N];\u003c/p\u003e\u003cp\u003evoid dfs2(int v) {  used[v] \u003d u;  for (auto u : tg1[v]) if (used[u] !\u003d ::u) dfs2(u);  comp[v] \u003d c; }\u003c/p\u003e\u003cp\u003evector g2[N]; vector w2[N];\u003c/p\u003e\u003cp\u003ebool good[N];\u003c/p\u003e\u003cp\u003ebool dfs3(int v, int p, int t, bool\u0026amp; ans) {  if (v \u003d\u003d t) {  ans |\u003d good[v];  return true;  }\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eforn(i, sz(g2[v])) {\n    int to \u003d g2[v][i];\n    if (to \u003d\u003d p) continue;\n    if (dfs3(to, v, t, ans)) {\n       ans |\u003d good[v];\n       ans |\u003d w2[v][i];\n       return true;\n    }\n}\nreturn false;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e}\u003c/p\u003e\u003cp\u003evoid solve() {  u++, sz \u003d 0;  dfs1(0);  assert(sz \u003d\u003d n);  reverse(perm, perm + sz);\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eu++, c \u003d 0;\nforn(i, sz) if (used[perm[i]] !\u003d u) dfs2(perm[i]), c++;\n\nforn(i, c) good[i] \u003d false;\n\nforn(i, c) {\n    g2[i].clear();\n    w2[i].clear();\n}\nforn(i, n)\n    forn(j, sz(g1[i])) {\n       int x \u003d comp[i], y \u003d comp[g1[i][j]];\n       if (x !\u003d y) {\n         g2[x].pb(y);\n         w2[x].pb(w[i][j]);\n       } else if (w[i][j]) good[x] \u003d true;\n    }\n\nn \u003d c;\na \u003d comp[a], b \u003d comp[b];\n\nbool ans \u003d good[a];\nassert(dfs3(a, -1, b, ans));\nputs(ans ? \u0026quot;YES\u0026quot; : \u0026quot;NO\u0026quot;);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e}\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/652/problem/F\" title\u003d\"Educational Codeforces Round 10\"\u003e652F - Ants on a Circle\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThe problem was suggested by Lewin Gan \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/lewin\" title\u003d\"International master lewin\"\u003elewin\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThe first observation: if all the ants are indistinguishable we can consider that there are no collisions and all the ants are passing one through another. So we can easily determine the final positions of all the ants, but we can\u0027t say which ant will be in which position.\u003c/p\u003e\u003cp\u003eThe second observation: the relative order of the ants will be the same all the time.\u003c/p\u003e\u003cp\u003eSo to solve the problem we should only find the position of one ant after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e seconds.\u003c/p\u003e\u003cp\u003eLet\u0027s solve that problem in the following way:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eConsider the positions of all the ants after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e time units. Easy to see that by the first observation all the positions of the ants will left the same, but the order will be different (we will have some cyclic shift of the ants). If we find that cyclic shift \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esh\u003c/i\u003e\u003c/span\u003e we can apply it \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/76/2e/762eafd84f36d20da2c9413302063778a2afa524.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e times.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eAfter that we will have only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e ± \u003ci\u003eod\u003c/i\u003e \u003ci\u003em\u003c/i\u003e\u003c/span\u003e time units.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eSo the problem now is to model the process for the one ant with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e ± \u003ci\u003eod\u003c/i\u003e \u003ci\u003em\u003c/i\u003e\u003c/span\u003e time units. Note that in that time interval the fixed ant will have no more than two collisions with each other ant. So if we model the process with ignoring all collisions except the ones that include the fixed ant, we will have no more than \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003en\u003c/i\u003e\u003c/span\u003e collisions.\u003c/p\u003e\u003cp\u003eLet\u0027s model that process with two queues for the ants going to the left and to the right. Each time we should take the first ant in the queue with opposite direction, process the collision and add that ant to the end of the other queue.\u003c/p\u003e\u003cp\u003eHint: you will have a problem when the fixed ant can be in two different positions at the end, but it\u0027s easy to fix with doing the same with the next ant.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC++ solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003econst int N \u003d 300300;\u003c/p\u003e\u003cp\u003eint n, m; li t; pair\u0026lt;pair\u0026lt;int, char\u0026gt;, int\u0026gt; a[N];\u003c/p\u003e\u003cp\u003ebool read() {  if (!(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; t)) return false;  forn(i, n) {  assert(scanf(\u0026quot;%d %c\u0026quot;, \u0026amp;a[i].x.x, \u0026amp;a[i].x.y) \u003d\u003d 2);  a[i].x.x--;  a[i].y \u003d i;  }  return true; }\u003c/p\u003e\u003cp\u003eint dx[] \u003d { -1, +1 }; const string dirs(\u0026quot;LR\u0026quot;); inline int getDir(char d) { return (int) dirs.find(d); }\u003c/p\u003e\u003cp\u003einline int getPos(li x, char d, li t) {  x %\u003d m, t %\u003d m;  li ans \u003d (x + t * dx[getDir(d)]) % m;  (ans \u0026lt; 0) \u0026amp;\u0026amp; (ans +\u003d m);  return int(ans); }\u003c/p\u003e\u003cp\u003etypedef pair\u0026lt;li, li\u0026gt; ptl; void clear(queue\u0026amp; q) { while (!q.empty()) q.pop(); } queue tol, tor;\u003c/p\u003e\u003cp\u003eint calc(int v, li t) {  clear(tol);  clear(tor);\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efore(d, 1, n) {\n    int i \u003d (v - d + n) % n;\n    if (a[i].x.y \u003d\u003d \u0027R\u0027) tor.push(mp(i \u0026gt; v ? a[i].x.x - m : a[i].x.x, 0));\n}\nfore(d, 1, n) {\n    int i \u003d (v + d) % n;\n    if (a[i].x.y \u003d\u003d \u0027L\u0027) tol.push(mp(i \u0026lt; v ? a[i].x.x + m : a[i].x.x, 0));\n}\n\nli cx \u003d a[v].x.x;\nchar cd \u003d a[v].x.y;\nli curt \u003d 0;\nwhile (t \u0026gt; 0) {\n    if (cd \u003d\u003d \u0027R\u0027) {\n       if (tol.empty()) return getPos(cx, cd, t);\n       assert(curt \u0026gt;\u003d tol.front().y);\n       li nx \u003d tol.front().x - (curt - tol.front().y);\n       tol.pop();\n       li d \u003d min((nx - cx + 1) \u0026gt;\u0026gt; 1, t);\n       assert(cx \u0026lt;\u003d nx);\n       cx +\u003d d, nx -\u003d d;\n       t -\u003d d;\n       if (cx \u0026gt; nx) {\n         assert((nx - cx) \u0026amp; 1);\n         cx--, nx++;\n       }\n       assert(cx \u0026lt;\u003d nx);\n       cd \u003d \u0027L\u0027;\n       curt +\u003d d;\n       assert(nx - m \u0026lt; cx);\n       tor.push(mp(nx - m, curt));\n    } else {\n       if (tor.empty()) return getPos(cx, cd, t);\n       assert(curt \u0026gt;\u003d tor.front().y);\n       li nx \u003d tor.front().x + (curt - tor.front().y);\n       tor.pop();\n       li d \u003d min((cx - nx + 1) \u0026gt;\u0026gt; 1, t);\n       assert(cx \u0026gt;\u003d nx);\n       cx -\u003d d, nx +\u003d d;\n       t -\u003d d;\n       if (cx \u0026lt; nx) {\n         assert((cx - nx) \u0026amp; 1);\n         cx++, nx--;\n       }\n       assert(cx \u0026gt;\u003d nx);\n       cd \u003d \u0027R\u0027;\n       curt +\u003d d;\n       assert(nx + m \u0026gt; cx);\n       tol.push(mp(nx + m, curt));\n    }\n}\nreturn getPos(cx, cd, 0);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e}\u003c/p\u003e\u003cp\u003eint ans[N];\u003c/p\u003e\u003cp\u003evoid solve() {  assert(n \u0026gt; 1);  sort(a, a + n);\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;int\u0026gt; poss;\nforn(i, n)\n    poss.pb(getPos(a[i].x.x, a[i].x.y, t));\nsort(all(poss));\n\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; xs;\nforn(s, 2) {\n    int x \u003d calc(s, m);\n    int pos \u003d -1;\n    forn(i, n)\n       if (a[i].x.x \u003d\u003d x) {\n         assert(pos \u003d\u003d -1);\n         pos \u003d i;\n       }\n    assert(pos !\u003d -1);\n    pos \u003d (pos - s + n) % n;\n    li k \u003d (t / m) % n;\n    pos \u003d int((s + pos * k) % n);\n\n    x \u003d calc(pos, t % m);\n    xs.pb(vector\u0026lt;int\u0026gt;());\n    forn(i, sz(poss))\n       if (poss[i] \u003d\u003d x)\n         xs.back().pb(i);\n    assert(!xs.back().empty());\n    if (sz(xs.back()) \u003d\u003d 2) assert(xs.back()[0] + 1 \u003d\u003d xs.back()[1]);\n}\n\nint pos \u003d xs[0][0];\nif (sz(xs[0]) \u0026gt; 1) {\n    assert(sz(xs[0]) \u003d\u003d 2);\n    assert(pos + 1 \u003d\u003d xs[0][1]);\n    if (xs[0] !\u003d xs[1])\n       pos \u003d xs[0][1];\n}\n\nforn(ii, n) {\n    int i \u003d (ii + pos) % sz(poss);\n    ans[a[ii].y] \u003d poss[i];\n}\n\nforn(i, n) {\n    if (i) putchar(\u0027 \u0027);\n    assert(0 \u0026lt;\u003d ans[i] \u0026amp;\u0026amp; ans[i] \u0026lt; m);\n    printf(\u0026quot;%d\u0026quot;, ans[i] + 1);\n}\nputs(\u0026quot;\u0026quot;);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e}\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlogn\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e","tags":["education round 10","editorial"]}}