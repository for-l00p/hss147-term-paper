{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1420923445,"rating":5,"authorHandle":"Qumeric","modificationTimeSeconds":1420923445,"id":15706,"title":"\u003cp\u003eНебольшой трюк с проверкой выхода за пределы массива\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eИногда встречаются задачи с дву/многомерными массивами, в которых есть несколько очевидных случаев возможного выхода за пределы массива. Они просты и понятны, но для их обработки порой требуется много \u0026quot;лишнего\u0026quot; кода (однажды автор написал 16 if-ов!). Я придумал простой способ, который поможет избежать этого. Возможно, это покажется вам очевидным, но лично мне так не казалось еще вчера. Думаю, я не один такой.\u003c/p\u003e\u003cp\u003eПример задачи (как можно более простой, взята отсюда \u003ca href\u003d\"http://informatics.mccme.ru/mod/statements/view3.php?chapterid\u003d946\"\u003ehttp://informatics.mccme.ru/mod/statements/view3.php?chapterid\u003d946\u003c/a\u003e ):\u003c/p\u003e\u003cp\u003eДана прямоугольная доска N × N (N \u0026lt;\u003d 20). Конь стоит в верхнем левом углу доски. Выведите количество способов добраться конём до правого нижнего угла доски, если конь может ходить только так:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/2e/fe/2efe1623cbf789d3ace5fdd228cfe852d360b080.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eВот обычное решение этой задачи динамическим программированием:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n\nint n, dp[20][20];\n\nint main() {\n    std::cin \u0026gt;\u0026gt; n;\n    dp[0][0] \u003d 1;\n    for (int i \u003d 1; i \u0026lt; n; i++) {\n        for (int j \u003d 1; j \u0026lt; n; j++) {\n            if (i-2 \u0026gt;\u003d 0 \u0026amp;\u0026amp; j-1 \u0026gt;\u003d 0)\n                dp[i][j] +\u003d dp[i-2][j-1];\n            if (i-1 \u0026gt;\u003d 0 \u0026amp;\u0026amp; j-2 \u0026gt;\u003d 0)\n                dp[i][j] +\u003d dp[i-1][j-2];\n        }\n    }\n    std::cout \u0026lt;\u0026lt; dp[n-1][n-1] \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКазалось бы, ничего сложного. Но тем не менее его можно упростить:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n\nint n, dp[20][20];\n\nint f(int i, int j) {\n    return (i \u0026lt; 0 || j \u0026lt; 0) ? 0 : dp[i][j];\n}\n\nint main() {\n    std::cin \u0026gt;\u0026gt; n;\n    dp[0][0] \u003d 1;\n    for (int i \u003d 1; i \u0026lt; n; i++)\n        for (int j \u003d 1; j \u0026lt; n; j++)\n            dp[i][j] \u003d f(i-2, j-1) + f(i-1, j-2);\n    std::cout \u0026lt;\u0026lt; dp[n-1][n-1] \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ данном примере не видно большой разницы, но в некоторых случаях это может действительно сократить код, тем самым уменшив возможность ошибки. Это способ хорош еще тем, что если вдруг надо будет возвращать не 0 в случае выхода за пределы, а, например -inf, то это легко сделать.\u003c/p\u003e\u003cp\u003eКстати, функцию f можно сделать более гибкой, передав ей массив/вектор в качестве аргумента, например: \u003ccode\u003eint f(vector\u0026lt;int\u0026gt;\u0026amp; v, int i, int j) {\u003c/code\u003e, а можно даже использовать C++14 и написать так: \u003ccode\u003eint f(auto\u0026amp; v, int i, int j) {\u003c/code\u003e.\u003c/p\u003e\u003c/div\u003e","tags":["дп","совет"]}}