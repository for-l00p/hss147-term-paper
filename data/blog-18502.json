{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1434135346,"rating":5,"authorHandle":"zholnin","modificationTimeSeconds":1434143655,"id":18502,"title":"\u003cp\u003eDistributed Code Jam Practice Round — solutions ideas\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi,\u003c/p\u003e\u003cp\u003eJust wanted to double check if my solutions for Distributed Code Jam practice problems are reasonably correct. This is not the full description, but just ideas on how to solve:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSandwich\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eCut sandwich into number_of_nodes pieces. Every node is responsible for delivering four numbers to central node. Four numbers being \u0026quot;maximum eating from the left\u0026quot;, \u0026quot;maximum eating from the right\u0026quot;, \u0026quot;total sum\u0026quot;, \u0026quot;maximum eating from both ends\u0026quot;. Central node having all this numbers can do any algorithm (even O(n^4) if you wish) to come up with an answer, as n is not more than 100 at that point.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMajority\u003c/strong\u003e\u003c/p\u003e\u003cp\u003ePopulation is split evenly between every node. Every node sends to central node the best candidate and the runner-up candidate. Central node combines No\u00271 and No\u00272 candidates and picks two most frequent (maybe one is enough?). Central node sends request to all other nodes to provide vote count for two most frequent candidates. Nodes respond, central node adds votes up and produces result. (UPD — wrong approach — see in comments below)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eShhhh\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eI found it most interesting. My solution went like this — we have to go through the whole circle to get the answer, there is no way around it. We want to split work across nodes, but we can\u0027t do it evenly, as we don\u0027t know where each person sits. Randomization helps (was it intended solution?). I played with numbers a little bit to see that if we have 100*number_of_nodes \u0026quot;key numbers\u0026quot;, every node can start from each of it\u0027s 100 key_numbers and go right until getting to another key_number. Then send to the central node information in form \u0026quot;from key number x to key number y distance is D\u0026quot;. Central node combines all this data and give out result. I think we are protected by statistics from situation where one node might get unusually long sequence leading to TLE.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eLoad Balance\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eClassical partitioning problem. I only used 8 nodes for small and 64 nodes for large (not 100). With 52 numbers you can split them into 64 sub-tasks with 45 numbers each. 45 numbers are solvable by \u0026quot;meet in the middle\u0026quot; algorithm for sub sequence sum search. So each node receives 45 numbers and sum to search for. Sum to search for is Total / 2 adjusted depending on whether you include first 7 numbers in this sub-task or not.\u003c/p\u003e\u003c/div\u003e","tags":["dgcj"]}}