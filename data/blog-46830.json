{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1472480082,"rating":100,"authorHandle":"zscoder","modificationTimeSeconds":1472486167,"id":46830,"title":"\u003cp\u003eCodeforces Round #369 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHere are the editorials for all the problems. Hope you enjoyed them and found them interesting!\u003c/p\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"711A\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int INF \u003d 1e9 + 7;\nconst int MOD \u003d 1e9 + 7;\nconst int N \u003d 1000;\nchar bus[N][5];\n\nvoid printbus(int n)\n{\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; 5; j++)\n\t\t{\n\t\t\tcout \u0026lt;\u0026lt; bus[i][j];\n\t\t}\n\t\tcout \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t}\n}\n\nvoid yes()\n{\n\tcout \u0026lt;\u0026lt; \u0026quot;YES\u0026quot; \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\nvoid no()\n{\n\tcout \u0026lt;\u0026lt; \u0026quot;NO\u0026quot; \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin \u0026gt;\u0026gt; n;\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; 5; j++)\n\t\t{\n\t\t\tcin \u0026gt;\u0026gt; bus[i][j];\n\t\t}\n\t}\n\tbool possible \u003d false;\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; 2; j++)\n\t\t{\n\t\t\tif(bus[i][j*3] \u003d\u003d \u0027O\u0027 \u0026amp;\u0026amp; bus[i][j*3+1] \u003d\u003d \u0027O\u0027)\n\t\t\t{\n\t\t\t\tbus[i][j*3] \u003d \u0027+\u0027;\n\t\t\t\tbus[i][j*3+1] \u003d \u0027+\u0027;\n\t\t\t\tpossible \u003d true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(possible) break;\n\t}\n\tif(!possible)\n\t{\n\t\tno();\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tyes();\n\t\tprintbus(n);\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"711B\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int INF \u003d 1e9 + 7;\nconst int MOD \u003d 1e9 + 7;\nconst int LG \u003d 20;\n\nll a[1001][1001];\nll r[1001]; //row sum\nll c[1001]; //column sum\nint n;\n\nvoid no()\n{\n\tcout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin \u0026gt;\u0026gt; n;\n\tint x, y; ll diagonal1 \u003d 0; ll diagonal2 \u003d 0;\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt; n; j++)\n\t\t{\n\t\t\tcin \u0026gt;\u0026gt; a[i][j];\n\t\t\tif(a[i][j] \u003d\u003d 0)\n\t\t\t{\n\t\t\t\tx \u003d i; y \u003d j;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr[i] +\u003d a[i][j];\n\t\t\t\tc[j] +\u003d a[i][j];\n\t\t\t\tif(i \u003d\u003d j)\n\t\t\t\t{\n\t\t\t\t\tdiagonal1 +\u003d a[i][j];\n\t\t\t\t}\n\t\t\t\tif(i + j \u003d\u003d n - 1)\n\t\t\t\t{\n\t\t\t\t\tdiagonal2 +\u003d a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(n \u003d\u003d 1)\n\t{\n\t\tcout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t\treturn 0;\n\t}\n\tll commonsum \u003d r[0];\n\tif(x \u003d\u003d 0) commonsum \u003d r[1];\n\t//cout \u0026lt;\u0026lt; commonsum \u0026lt;\u0026lt; \u0027\\n\u0027;\n\tll rowsum \u003d -1; ll colsum \u003d -1; ll d1sum \u003d -1; ll d2sum \u003d -1;\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tif(i !\u003d x)\n\t\t{\n\t\t\tif(r[i] !\u003d commonsum)\n\t\t\t{\n\t\t\t\tno();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\trowsum \u003d r[i];\n\t\t}\n\t}\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tif(i !\u003d y)\n\t\t{\n\t\t\tif(c[i] !\u003d commonsum)\n\t\t\t{\n\t\t\t\tno(); return 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcolsum \u003d c[i];\n\t\t}\n\t}\n\tbool isdiagonal1 \u003d false; bool isdiagonal2 \u003d false;\n\tif(x \u003d\u003d y) isdiagonal1 \u003d true;\n\tif(x + y \u003d\u003d n - 1) isdiagonal2 \u003d true;\n\tif(!isdiagonal1)\n\t{\n\t\tif(diagonal1 !\u003d commonsum)\n\t\t{\n\t\t\tno();\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\td1sum \u003d diagonal1;\n\t}\n\tif(!isdiagonal2)\n\t{\n\t\tif(diagonal2 !\u003d commonsum)\n\t\t{\n\t\t\tno();\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\td2sum \u003d diagonal2;\n\t}\n\tif(rowsum \u003d\u003d colsum)\n\t{\n\t\tif(isdiagonal1 \u0026amp;\u0026amp; d1sum !\u003d rowsum)\n\t\t{\n\t\t\tno();\n\t\t\treturn 0;\n\t\t}\n\t\tif(isdiagonal2 \u0026amp;\u0026amp; d2sum !\u003d rowsum)\n\t\t{\n\t\t\tno();\n\t\t\treturn 0;\n\t\t}\n\t\tll value \u003d commonsum - rowsum;\n\t\tif(value \u0026gt; 0)\n\t\t{\n\t\t\tcout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tno();\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\tno();\n\t\treturn 0;\n\t}\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"711C\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode (O(nkm^2))\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int N \u003d 101;\nconst int MOD \u003d 1e9 + 7;\nconst ll INF \u003d ll(1e18);\n\nll dp[N][N][N];\nint c[N];\nll cost[N][N];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, m, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k;\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++)\n\t{\n\t\tcin \u0026gt;\u0026gt; c[i];\n\t}\n\tfor(int i \u003d 0; i \u0026lt;\u003d n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt;\u003d k; j++)\n\t\t{\n\t\t\tfor(int a \u003d 0; a \u0026lt;\u003d m; a++)\n\t\t\t{\n\t\t\t\tdp[i][j][a] \u003d INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++)\n\t{\n\t\tfor(int j \u003d 1; j \u0026lt;\u003d m; j++)\n\t\t{\n\t\t\tcin \u0026gt;\u0026gt; cost[i][j];\n\t\t}\n\t}\n\tif(c[1] \u003d\u003d 0)\n\t{\n\t\tfor(int i \u003d 1; i \u0026lt;\u003d m; i++)\n\t\t{\n\t\t\tdp[1][1][i] \u003d cost[1][i];\n\t\t}\n\t}\n\telse\n\t{\n\t\tdp[1][1][c[1]] \u003d 0;\n\t}\n\tfor(int i \u003d 2; i \u0026lt;\u003d n; i++)\n\t{\n\t\tfor(int j \u003d 1; j \u0026lt;\u003d k; j++)\n\t\t{\n\t\t\tif(c[i] \u003d\u003d 0)\n\t\t\t{\n\t\t\t\tfor(int a \u003d 1; a \u0026lt;\u003d m; a++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j][a] \u003d min(dp[i][j][a], dp[i-1][j][a] + cost[i][a]);\n\t\t\t\t\tfor(int b \u003d 1; b \u0026lt;\u003d m; b++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(b !\u003d a) dp[i][j][a] \u003d min(dp[i][j][a], dp[i-1][j-1][b] + cost[i][a]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j][c[i]] \u003d min(dp[i][j][c[i]], dp[i-1][j][c[i]]);\n\t\t\t\tfor(int b \u003d 1; b \u0026lt;\u003d m; b++)\n\t\t\t\t{\n\t\t\t\t\tif(b !\u003d c[i]) dp[i][j][c[i]] \u003d min(dp[i][j][c[i]], dp[i-1][j-1][b]);\n\t\t\t\t}\n\t\t\t\t//cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; c[i] \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; dp[i][j][c[i]] \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t\t\t}\n\t\t}\n\t}\n\tll ans \u003d INF;\n\tfor(int i \u003d 1; i \u0026lt;\u003d m; i++)\n\t{\n\t\tans \u003d min(ans, dp[n][k][i]);\n\t}\n\tif(ans \u0026gt;\u003d INF) ans \u003d -1;\n\tcout \u0026lt;\u0026lt; ans;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode (O(nkm))\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int N \u003d 101;\nconst int MOD \u003d 1e9 + 7;\nconst ll INF \u003d ll(1e18);\n\nll dp[N][N][N];\nint c[N];\nll cost[N][N];\nll idx[N][N];\nll m1[N][N];\nll m2[N][N];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, m, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k;\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++)\n\t{\n\t\tcin \u0026gt;\u0026gt; c[i];\n\t}\n\tfor(int i \u003d 0; i \u0026lt;\u003d n; i++)\n\t{\n\t\tfor(int j \u003d 0; j \u0026lt;\u003d k; j++)\n\t\t{\n\t\t\tm1[i][j] \u003d INF; m2[i][j] \u003d INF; idx[i][j] \u003d -1;\n\t\t\tfor(int a \u003d 0; a \u0026lt;\u003d m; a++)\n\t\t\t{\n\t\t\t\tdp[i][j][a] \u003d INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++)\n\t{\n\t\tfor(int j \u003d 1; j \u0026lt;\u003d m; j++)\n\t\t{\n\t\t\tcin \u0026gt;\u0026gt; cost[i][j];\n\t\t}\n\t}\n\tif(c[1] \u003d\u003d 0)\n\t{\n\t\tfor(int i \u003d 1; i \u0026lt;\u003d m; i++)\n\t\t{\n\t\t\tdp[1][1][i] \u003d cost[1][i];\n\t\t\tif(dp[1][1][i] \u0026lt;\u003d m1[1][1])\n\t\t\t{\n\t\t\t\tif(dp[1][1][i] \u003d\u003d m1[1][1])\n\t\t\t\t{\n\t\t\t\t\tidx[1][1] \u003d -2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tidx[1][1] \u003d i;\n\t\t\t\t}\n\t\t\t\tm2[1][1] \u003d m1[1][1];\n\t\t\t\tm1[1][1] \u003d dp[1][1][i];\n\t\t\t}\n\t\t\telse if(dp[1][1][i] \u0026lt;\u003d m2[1][1])\n\t\t\t{\n\t\t\t\tm2[1][1] \u003d dp[1][1][i];\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tdp[1][1][c[1]] \u003d 0;\n\t\tm1[1][1] \u003d 0; idx[1][1] \u003d c[1];\n\t}\n\tfor(int i \u003d 2; i \u0026lt;\u003d n; i++)\n\t{\n\t\tfor(int j \u003d 1; j \u0026lt;\u003d k; j++)\n\t\t{\n\t\t\tif(c[i] \u003d\u003d 0)\n\t\t\t{\n\t\t\t\tfor(int a \u003d 1; a \u0026lt;\u003d m; a++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j][a] \u003d min(dp[i][j][a], dp[i-1][j][a] + cost[i][a]);\n\t\t\t\t\tll tmp \u003d INF;\n\t\t\t\t\tif(a \u003d\u003d idx[i-1][j-1])\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp \u003d m2[i-1][j-1];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp \u003d m1[i-1][j-1];\n\t\t\t\t\t}\n\t\t\t\t    dp[i][j][a] \u003d min(dp[i][j][a], tmp + cost[i][a]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j][c[i]] \u003d min(dp[i][j][c[i]], dp[i-1][j][c[i]]);\n\t\t\t\tfor(int b \u003d 1; b \u0026lt;\u003d m; b++)\n\t\t\t\t{\n\t\t\t\t\tif(b !\u003d c[i]) dp[i][j][c[i]] \u003d min(dp[i][j][c[i]], dp[i-1][j-1][b]);\n\t\t\t\t}\n\t\t\t\t//cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; c[i] \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; dp[i][j][c[i]] \u0026lt;\u0026lt; \u0027\\n\u0027;\n\t\t\t}\n\t\t\tfor(int a \u003d 1; a \u0026lt;\u003d m; a++)\n\t\t\t{\n\t\t\t\tif(dp[i][j][a] \u0026lt;\u003d m1[i][j])\n\t\t\t\t{\n\t\t\t\t\tif(dp[i][j][a] \u003d\u003d m1[i][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tidx[i][j] \u003d -2;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tidx[i][j] \u003d a;\n\t\t\t\t\t}\n\t\t\t\t\tm2[i][j] \u003d m1[i][j];\n\t\t\t\t\tm1[i][j] \u003d dp[i][j][a];\n\t\t\t\t}\n\t\t\t\telse if(dp[i][j][a] \u0026lt;\u003d m2[i][j])\n\t\t\t\t{\n\t\t\t\t\tm2[i][j] \u003d dp[i][j][a];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans \u003d INF;\n\tfor(int i \u003d 1; i \u0026lt;\u003d m; i++)\n\t{\n\t\tans \u003d min(ans, dp[n][k][i]);\n\t}\n\tif(ans \u0026gt;\u003d INF) ans \u003d -1;\n\tcout \u0026lt;\u0026lt; ans;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"711D\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int INF \u003d 1e9 + 7;\nconst int MOD \u003d 1e9 + 7;\nconst int N \u003d 1e6 + 3;\n\nint a[N];\nint visited[N];\nll ans;\nvector\u0026lt;int\u0026gt; cycles;\nll dp[N];\nint cyclecnt;\n\nvoid dfs2(int u)\n{\n\tcycles[cyclecnt]++;\n\tvisited[u] \u003d 3;\n\tif(visited[a[u]] \u003d\u003d 3) return ;\n\tdfs2(a[u]);\n}\n\nvoid dfs(int u)\n{\n\tvisited[u] \u003d 2;\n\tif(visited[a[u]] \u003d\u003d 0)\n\t{\n\t\tdfs(a[u]);\n\t}\n\telse if(visited[a[u]] \u003d\u003d 1)\n\t{\n\t\tvisited[u] \u003d 1;\n\t\treturn ;\n\t}\n\telse\n\t{\n\t\tcycles.pb(0);\n\t\tdfs2(u);\n\t\tcyclecnt++;\n\t}\n\tvisited[u] \u003d 1;\n}\n\nint main()\n{\n\t//ios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++)\n\t{\n\t\tscanf(\u0026quot;%d\u0026quot;, a + i);\n\t}\n\tdp[0] \u003d 1;\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++)\n\t{\n\t\tdp[i] \u003d (dp[i-1]*2LL)%MOD;\n\t}\n\tans \u003d 1;\n\tmemset(visited, 0, sizeof(visited));\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i++)\n\t{\n\t\tif(visited[i] \u003d\u003d 0)\n\t\t{\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tll cnt \u003d n;\n\tfor(int i \u003d 0; i \u0026lt; cycles.size(); i++)\n\t{\n\t\tcnt -\u003d cycles[i];\n\t\tans \u003d (ans*(dp[cycles[i]]-2+MOD))%MOD;\n\t}\n\tans \u003d (ans*dp[cnt])%MOD;\n\tif(ans \u0026lt; 0) ans +\u003d MOD;\n\tint ans2 \u003d ans;\n\tprintf(\u0026quot;%d\\n\u0026quot;, ans2);\n\treturn 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"711E\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector\u0026lt;int\u0026gt; vi;\n\nconst int MOD \u003d 1e6 + 3;\n\nll power(ll base, ll exp)\n{\n\tll ans \u003d 1;\n    while(exp)\n    {\n\t\tif(exp\u0026amp;1) ans \u003d (ans*base)%MOD;\n\t\tbase \u003d (base*base)%MOD;\n\t\texp\u0026gt;\u0026gt;\u003d1;\n\t}\n    return ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tll n, k;\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k;\n\tif(n \u0026lt;\u003d 63 \u0026amp;\u0026amp; k \u0026gt; (1LL\u0026lt;\u0026lt;n))\n\t{\n\t\tcout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; 1;\n\t\treturn 0;\n\t}\n\tll v2 \u003d 0;\n\tint digits \u003d __builtin_popcountll(k - 1);\n\tv2 \u003d k - 1 - digits;\n\tll ntmp \u003d n % (MOD - 1);\n\tif(ntmp \u0026lt; 0) ntmp +\u003d (MOD - 1);\n\tll ktmp \u003d k % (MOD - 1);\n\tif(ktmp \u0026lt; 0) ktmp +\u003d (MOD - 1);\n\tll v2tmp \u003d v2 % (MOD - 1);\n\tif(v2tmp \u0026lt; 0) v2tmp +\u003d (MOD - 1);\n\tll exponent \u003d ntmp*(ktmp - 1) - v2tmp;\n\texponent %\u003d (MOD - 1);\n\tif(exponent \u0026lt; 0) exponent +\u003d MOD - 1;\n\tll denom \u003d power(2, exponent);\n\tll numpart \u003d 0;\n\tif(k - 1 \u0026gt;\u003d MOD)\n\t{\n\t\tnumpart \u003d 0;\n\t}\n\telse\n\t{\n\t\tll prod \u003d 1;\n\t\tll ntmp2 \u003d power(2, ntmp);\n\t\tprod \u003d power(2, v2tmp);\n\t\tprod \u003d power(prod, MOD - 2);\n\t\tif(prod \u0026lt; 0) prod +\u003d MOD;\n\t\tfor(ll y \u003d 1; y \u0026lt;\u003d k - 1; y++)\n\t\t{\n\t\t\tprod \u003d (prod * (ntmp2 - y))%MOD;\n\t\t}\n\t\tnumpart \u003d prod;\n\t}\n\tll num \u003d (denom - numpart)%MOD;\n\tnum %\u003d MOD; denom %\u003d MOD;\n\tif(num \u0026lt; 0) num +\u003d MOD;\n\tif(denom \u0026lt; 0) denom +\u003d MOD;\n\tcout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; denom;\n\treturn 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}