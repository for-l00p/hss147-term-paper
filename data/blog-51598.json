{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1492368366,"rating":63,"authorHandle":"lewin","modificationTimeSeconds":1492368366,"id":51598,"title":"\u003cp\u003eVK Cup Round 2 + Codeforces Round #409 Tutorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eViscious Keyboard\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"801A\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eexample code 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eprint (lambda s: max((s[:i] + x + s[i+1:]).count(\u0026quot;VK\u0026quot;) for x in \u0026quot;VK\u0026quot; for i in range(len(s))))(raw_input())\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eexample code 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eprint (lambda s: s.count(\u0026quot;VK\u0026quot;) + int(any(x*3 in \u0026quot;K\u0026quot; + s + \u0026quot;V\u0026quot; for x in \u0026quot;VK\u0026quot;)))(raw_input())\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eValued Keys\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"801B\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eexample code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003ex,y \u003d raw_input(), raw_input()\nprint all(a\u0026gt;\u003db for a,b in zip(x,y)) * y or \u0026quot;-1\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eVoltage Keepsake\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"772A\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eexample code (c++)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;assert.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n// Adjust MAXN for bounds\nconst ll MAXN\u003d1e5+4;\n// MAXV is the max amount of time we can take\nconst ld MAXV\u003d1e18;\nll a[MAXN],b[MAXN];\nld exhaust[MAXN];\nint n;\nll P;\nbool f(ld imid) {\n\tld needsum\u003d0;\n\tfor (int i\u003d0;i\u0026lt;n;i++) {\n\t\tld need\u003dmax(0.0L, (imid-exhaust[i])*a[i]);\n\t\tneedsum+\u003dneed;\n\t}\n\tld supply\u003dimid*P;\n\treturn supply\u0026gt;\u003dneedsum;\n}\nint main() \n{\n\tscanf(\u0026quot;%d%lld\u0026quot;,\u0026amp;n,\u0026amp;P);\n\tfor (int i\u003d0;i\u0026lt;n;i++) {\n\t\tscanf(\u0026quot;%lld%lld\u0026quot;,\u0026amp;a[i],\u0026amp;b[i]);\n\t}\n\tll suma\u003d0;\n\tfor (int i\u003d0;i\u0026lt;n;i++) {\n\t\tsuma+\u003da[i];\n\t}\n\tif (P\u0026gt;\u003dsuma) {\n\t\tprintf(\u0026quot;-1\\n\u0026quot;);\n\t\treturn 0;\n\t}\n\tfor (int i\u003d0;i\u0026lt;n;i++) {\n\t\texhaust[i]\u003d((ld)b[i])/((ld)a[i]);\n\t}\n\tld imin\u003d0,imax\u003dMAXV;\n\tfor (ll iter\u003d0;iter\u0026lt;220;iter++) {\n\t\tld imid\u003d(imin+imax)/2;\n\t\tif (f(imid)) imin\u003dimid;\n\t\telse imax\u003dimid;\n\t}\n\tif (imax\u0026gt;MAXV-100) printf(\u0026quot;-1\\n\u0026quot;);\n\telse printf(\u0026quot;%.9f\\n\u0026quot;,(double)imin);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eVolatile Kite\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"772B\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eexample code (c++)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define sim template \u0026lt; class c\n#define ris return * this\n#define dor \u0026gt; debug \u0026amp; operator \u0026lt;\u0026lt;\n#define eni(x) sim \u0026gt; typename \\\n  enable_if\u0026lt;sizeof dud\u0026lt;c\u0026gt;(0) x 1, debug\u0026amp;\u0026gt;::type operator\u0026lt;\u0026lt;(c i) {\nsim \u0026gt; struct rge {c b, e; };\nsim \u0026gt; rge\u0026lt;c\u0026gt; range(c i, c j) { return rge\u0026lt;c\u0026gt;{i, j}; }\nsim \u0026gt; auto dud(c* x) -\u0026gt; decltype(cerr \u0026lt;\u0026lt; *x, 0);\nsim \u0026gt; char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr \u0026lt;\u0026lt; endl; }\neni(!\u003d) cerr \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt; i; ris; }\neni(\u003d\u003d) ris \u0026lt;\u0026lt; range(begin(i), end(i)); }\nsim, class b dor(pair \u0026lt; b, c \u0026gt; d) {\n  ris \u0026lt;\u0026lt; \u0026quot;(\u0026quot; \u0026lt;\u0026lt; d.first \u0026lt;\u0026lt; \u0026quot;, \u0026quot; \u0026lt;\u0026lt; d.second \u0026lt;\u0026lt; \u0026quot;)\u0026quot;;\n}\nsim dor(rge\u0026lt;c\u0026gt; d) {\n  *this \u0026lt;\u0026lt; \u0026quot;[\u0026quot;;\n  for (auto it \u003d d.b; it !\u003d d.e; ++it)\n    *this \u0026lt;\u0026lt; \u0026quot;, \u0026quot; + 2 * (it \u003d\u003d d.b) \u0026lt;\u0026lt; *it;\n  ris \u0026lt;\u0026lt; \u0026quot;]\u0026quot;;\n}\n#else\nsim dor(const c\u0026amp;) { ris; }\n#endif\n};\n#define imie(...) \u0026quot; [\u0026quot; \u0026lt;\u0026lt; #__VA_ARGS__ \u0026quot;: \u0026quot; \u0026lt;\u0026lt; (__VA_ARGS__) \u0026lt;\u0026lt; \u0026quot;] \u0026quot;\n\ntypedef long double ld;\ntypedef long double ll;\n\nld K(ld a) { return a * a; }\n\nstruct P {\n\tll x, y;\n\tvoid read() { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; }\n\tP operator + (P b) { return P{x + b.x, y + b.y}; }\n\tP operator - (P b) { return P{x - b.x, y - b.y}; }\n\tP operator * (ld/*ll*/ mul) { return P{x * mul, y * mul}; }\n\tll operator * (P b) { return x * b.y - y * b.x; }\n\tll dot(P b) { return x * b.x + y * b.y; }\n\tld len() { return sqrt(K(x) + K(y)); }\n\tP lenTo(ld to) { return *this * (to / len()); }\n\tld dist(P \u0026amp; b) { return (*this - b).len(); }\n};\n\nstruct L2 {\n\tP one, two;\n\tld dist(P he) {\n\t\treturn abs((he - one) * (he - two)) / one.dist(two);\n\t}\n};\n\nint main() {\n\tint n;\n\tcin \u0026gt;\u0026gt; n;\n\tvector\u0026lt;P\u0026gt; points(n);\n\tfor(P \u0026amp; p : points)\n\t\tp.read();\n\tld answer \u003d 1e15;\n\tfor(int i \u003d 0; i \u0026lt; n; ++i)\n\t\tfor(int j \u003d 0; j \u0026lt; 2 * n; ++j)\n\t\t\tif(abs(i - j) \u0026lt;\u003d 2)\n\t\t\t\tfor(int k \u003d 0; k \u0026lt; 2 * n; ++k)\n\t\t\t\t\tif(abs(i - k) \u0026lt;\u003d 2 \u0026amp;\u0026amp; (int) set\u0026lt;int\u0026gt;{i % n, j % n, k % n}.size() \u003d\u003d 3)\n\t\t\t\t\t\tanswer \u003d min(answer, L2{points[i%n], points[j%n]}.dist(points[k%n]));\n\tprintf(\u0026quot;%.10lf\\n\u0026quot;, (double) answer / 2);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eexample code (java)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream \u003d System.in;\n        OutputStream outputStream \u003d System.out;\n        InputReader in \u003d new InputReader(inputStream);\n        OutputWriter out \u003d new OutputWriter(outputStream);\n        NonConvexPolygon solver \u003d new NonConvexPolygon();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class NonConvexPolygon {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n \u003d in.nextInt();\n            long[][] p \u003d new long[n][2];\n            for (int i \u003d 0; i \u0026lt; n; i++) {\n                p[i][0] \u003d in.nextInt();\n                p[i][1] \u003d in.nextInt();\n            }\n            double ans \u003d 1L \u0026lt;\u0026lt; 60;\n            for (int i \u003d 0; i \u0026lt; n; i++) {\n                int prev \u003d (i + n - 1) % n, next \u003d (i + 1) % n;\n                ans \u003d Math.min(ans, PointToSegmentDistance.pointToLineThroughTwoPointsDistance(\n                        p[i][0], p[i][1], p[prev][0], p[prev][1], p[next][0], p[next][1]\n                ) / 2.0);\n            }\n            out.printf(\u0026quot;%.10f\\n\u0026quot;, ans);\n        }\n\n    }\n\n    static class Utils {\n        public static double cross(Point a, Point b, Point c) {\n            Point ab \u003d new Point(b.x - a.x, b.y - a.y);\n            Point ac \u003d new Point(c.x - a.x, c.y - a.y);\n            return ab.x * ac.y - ab.y * ac.x;\n        }\n\n    }\n\n    static class PointToSegmentDistance {\n        static double fastHypot(double x, double y) {\n            return Math.sqrt(x * x + y * y);\n        }\n\n        public static double pointToLineThroughTwoPointsDistance(long x, long y, long ax, long ay, long bx, long by) {\n            double t \u003d Utils.cross(new Point(ax, ay), new Point(bx, by), new Point(x, y));\n            return Math.abs(t / fastHypot(ax - bx, ay - by));\n        }\n\n    }\n\n    static class Point implements Comparable\u0026lt;Point\u0026gt; {\n        public double x;\n        public double y;\n        public double angle;\n        public int idx;\n\n        public Point(double x, double y) {\n            this.x \u003d x;\n            this.y \u003d y;\n            angle \u003d 0;\n        }\n\n        public Point(double x, double y, int idx) {\n            this.x \u003d x;\n            this.y \u003d y;\n            this.idx \u003d idx;\n        }\n\n        public int compareTo(Point other) {\n            return x \u003d\u003d other.x ? (int) Math.signum(y - other.y) : (int) Math.signum(x - other.x);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer \u003d new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer \u003d new PrintWriter(writer);\n        }\n\n        public void printf(String format, Object... objects) {\n            writer.printf(format, objects);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf \u003d new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream \u003d stream;\n        }\n\n        public int read() {\n            if (this.numChars \u003d\u003d -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar \u0026gt;\u003d this.numChars) {\n                    this.curChar \u003d 0;\n\n                    try {\n                        this.numChars \u003d this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars \u0026lt;\u003d 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c \u003d this.read(); isSpaceChar(c); c \u003d this.read()) {\n                ;\n            }\n\n            byte sgn \u003d 1;\n            if (c \u003d\u003d 45) {\n                sgn \u003d -1;\n                c \u003d this.read();\n            }\n\n            int res \u003d 0;\n\n            while (c \u0026gt;\u003d 48 \u0026amp;\u0026amp; c \u0026lt;\u003d 57) {\n                res *\u003d 10;\n                res +\u003d c - 48;\n                c \u003d this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c \u003d\u003d 32 || c \u003d\u003d 10 || c \u003d\u003d 13 || c \u003d\u003d 9 || c \u003d\u003d -1;\n        }\n\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eVulnerable Kerbals\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"772C\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eexample code (c++)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define sim template \u0026lt; class c\n#define ris return * this\n#define dor \u0026gt; debug \u0026amp; operator \u0026lt;\u0026lt;\n#define eni(x) sim \u0026gt; typename \\\n  enable_if\u0026lt;sizeof dud\u0026lt;c\u0026gt;(0) x 1, debug\u0026amp;\u0026gt;::type operator\u0026lt;\u0026lt;(c i) {\nsim \u0026gt; struct rge {c b, e; };\nsim \u0026gt; rge\u0026lt;c\u0026gt; range(c i, c j) { return rge\u0026lt;c\u0026gt;{i, j}; }\nsim \u0026gt; auto dud(c* x) -\u0026gt; decltype(cerr \u0026lt;\u0026lt; *x, 0);\nsim \u0026gt; char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr \u0026lt;\u0026lt; endl; }\neni(!\u003d) cerr \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt; i; ris; }\neni(\u003d\u003d) ris \u0026lt;\u0026lt; range(begin(i), end(i)); }\nsim, class b dor(pair \u0026lt; b, c \u0026gt; d) {\n  ris \u0026lt;\u0026lt; \u0026quot;(\u0026quot; \u0026lt;\u0026lt; d.first \u0026lt;\u0026lt; \u0026quot;, \u0026quot; \u0026lt;\u0026lt; d.second \u0026lt;\u0026lt; \u0026quot;)\u0026quot;;\n}\nsim dor(rge\u0026lt;c\u0026gt; d) {\n  *this \u0026lt;\u0026lt; \u0026quot;[\u0026quot;;\n  for (auto it \u003d d.b; it !\u003d d.e; ++it)\n    *this \u0026lt;\u0026lt; \u0026quot;, \u0026quot; + 2 * (it \u003d\u003d d.b) \u0026lt;\u0026lt; *it;\n  ris \u0026lt;\u0026lt; \u0026quot;]\u0026quot;;\n}\n#else\nsim dor(const c\u0026amp;) { ris; }\n#endif\n};\n#define imie(...) \u0026quot; [\u0026quot; \u0026lt;\u0026lt; #__VA_ARGS__ \u0026quot;: \u0026quot; \u0026lt;\u0026lt; (__VA_ARGS__) \u0026lt;\u0026lt; \u0026quot;] \u0026quot;\n\nconst int nax \u003d 2e5 + 5;\nbool forbidden[nax];\n\nint my_gcd(int a, int b) {\n\tif(a \u003d\u003d 0 || b \u003d\u003d 0) return max(a, b); // return m\n\treturn __gcd(a, b);\n}\n#define __gcd use____my_gcd\n\nvector\u0026lt;int\u0026gt; which[nax];\npair\u0026lt;int,int\u0026gt; dp[nax];\n\nint my_pow(int a, int b, int m) {\n\tint r \u003d 1;\n\twhile(b) {\n\t\tif(b % 2) r \u003d (long long) r * a % m;\n\t\ta \u003d (long long) a * a % m;\n\t\tb /\u003d 2;\n\t}\n\treturn r;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m);\n\twhile(n--) {\n\t\tint x;\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;x);\n\t\tforbidden[x] \u003d true;\n\t}\n\t#define n use_____m\n\tfor(int i \u003d 0; i \u0026lt; m; ++i)\n\t\tif(!forbidden[i])\n\t\t\twhich[my_gcd(i, m)].push_back(i);\n\tif(forbidden[0])\n\t\twhich[m].push_back(0); // hack\n\tfor(int i \u003d 1; i \u0026lt;\u003d m; ++i)\n\t\tif(!which[i].empty()) {\n\t\t\tdp[i] \u003d {0, 0};\n\t\t\tfor(int j \u003d 1; j \u0026lt; i; ++j)\n\t\t\t\tif(i % j \u003d\u003d 0 \u0026amp;\u0026amp; dp[j].first \u0026gt; 0)\n\t\t\t\t\tdp[i] \u003d max(dp[i], make_pair(dp[j].first, j));\n\t\t\tdp[i].first +\u003d which[i].size();\n\t\t}\n\tvector\u0026lt;int\u0026gt; ans;\n\tint x \u003d m;\n\twhile(!which[x].empty()) {\n\t\tfor(int y : which[x])\n\t\t\tans.push_back(y);\n\t\tx \u003d dp[x].second;\n\t}\n\treverse(ans.begin(), ans.end());\n\tif(forbidden[0]) {\n\t\tassert(!ans.empty());\n\t\tans.pop_back();\n\t}\n\tdebug() \u0026lt;\u0026lt; imie(ans);\n\tint previous \u003d 1;\n\tprintf(\u0026quot;%d\\n\u0026quot;, (int) ans.size());\n\t\n\tint cnt_coprime \u003d 0;\n\tfor(int i \u003d 2; i \u0026lt; m; ++i)\n\t\tif(my_gcd(i, m) \u003d\u003d 1)\n\t\t\t++cnt_coprime;\n\t\n\tfor(int nxt : ans) {\n\t\tif(nxt \u003d\u003d 0) {\n\t\t\tprintf(\u0026quot;0\u0026quot;);\n\t\t\tcontinue;\n\t\t}\n\t\tint a \u003d previous / my_gcd(m, previous);\n\t\tint b \u003d nxt / my_gcd(m, nxt);\n\t\t\n\t\tint print \u003d (long long) b * my_pow(a, cnt_coprime, m) % m;\n\t\tprint \u003d (long long) print * my_gcd(m, nxt) / my_gcd(m, previous) % m;\n\t\tprintf(\u0026quot;%d \u0026quot;, print);\n\t\tprevious \u003d nxt;\n\t}\n\tputs(\u0026quot;\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eexample code (java)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream \u003d System.in;\n        OutputStream outputStream \u003d System.out;\n        InputReader in \u003d new InputReader(inputStream);\n        OutputWriter out \u003d new OutputWriter(outputStream);\n        PrefixProductSequence solver \u003d new PrefixProductSequence();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class PrefixProductSequence {\n        public int[] div;\n        public boolean[] forbidden;\n        public ArrayList\u0026lt;Long\u0026gt; ans;\n        public int n;\n        public int m;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            n \u003d in.nextInt();\n            m \u003d in.nextInt();\n            forbidden \u003d new boolean[m + 1];\n            for (int i \u003d 0; i \u0026lt; n; i++) {\n                forbidden[in.nextInt()] \u003d true;\n            }\n            int[] add \u003d new int[m + 1];\n            for (int i \u003d 0; i \u0026lt; m; i++) {\n                if (!forbidden[i]) {\n                    int g \u003d Utils.gcd(i, m);\n                    add[m / g]++;\n                }\n            }\n            int[] arr \u003d new int[m + 1];\n            div \u003d new int[m + 1];\n            Arrays.fill(arr, 1);\n            Arrays.setAll(div, x -\u0026gt; x);\n            for (int i \u003d 2; i \u0026lt;\u003d m; i++) {\n                arr[i] +\u003d add[i];\n                for (int j \u003d i + i; j \u0026lt;\u003d m; j +\u003d i) {\n                    if (arr[i] \u0026gt; arr[j]) {\n                        arr[j] \u003d arr[i];\n                        div[j] \u003d j / i;\n                    }\n                }\n            }\n\n            ans \u003d new ArrayList\u0026lt;\u0026gt;();\n            solve(1, 1);\n            out.println(ans.size());\n            boolean first \u003d true;\n            for (long x : ans) {\n                if (!first) out.print(\u0026quot; \u0026quot;);\n                out.print(x);\n                first \u003d false;\n            }\n            out.println();\n        }\n\n        public void solve(int cmult, long mm) {\n            if (cmult \u003d\u003d m) {\n                if (!forbidden[0]) {\n                    ans.add(0L);\n                }\n                return;\n            }\n            int prev \u003d 1;\n            boolean has \u003d false;\n            for (int i \u003d 1; i \u0026lt; m / cmult; i++) {\n                if (!forbidden[i * cmult] \u0026amp;\u0026amp; Utils.gcd(m / cmult, i) \u003d\u003d 1) {\n                    long x \u003d Utils.inv(prev, m / cmult) * i % m;\n                    if (!has) {\n                        has \u003d true;\n                        x \u003d x * mm % m;\n                    }\n                    ans.add(x);\n                    prev \u003d i;\n                }\n            }\n            long nmm \u003d Utils.inv(prev, m / cmult) * div[m / cmult] % m;\n            if (!has) nmm \u003d nmm * mm % m;\n            solve(cmult * div[m / cmult], nmm);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer \u003d new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer \u003d new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i \u003d 0; i \u0026lt; objects.length; i++) {\n                if (i !\u003d 0) {\n                    writer.print(\u0027 \u0027);\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println() {\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void print(long i) {\n            writer.print(i);\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf \u003d new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream \u003d stream;\n        }\n\n        public int read() {\n            if (this.numChars \u003d\u003d -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar \u0026gt;\u003d this.numChars) {\n                    this.curChar \u003d 0;\n\n                    try {\n                        this.numChars \u003d this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars \u0026lt;\u003d 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c \u003d this.read(); isSpaceChar(c); c \u003d this.read()) {\n                ;\n            }\n\n            byte sgn \u003d 1;\n            if (c \u003d\u003d 45) {\n                sgn \u003d -1;\n                c \u003d this.read();\n            }\n\n            int res \u003d 0;\n\n            while (c \u0026gt;\u003d 48 \u0026amp;\u0026amp; c \u0026lt;\u003d 57) {\n                res *\u003d 10;\n                res +\u003d c - 48;\n                c \u003d this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c \u003d\u003d 32 || c \u003d\u003d 10 || c \u003d\u003d 13 || c \u003d\u003d 9 || c \u003d\u003d -1;\n        }\n\n    }\n\n    static class Utils {\n        public static long inv(long N, long M) {\n            long x \u003d 0, lastx \u003d 1, y \u003d 1, lasty \u003d 0, q, t, a \u003d N, b \u003d M;\n            while (b !\u003d 0) {\n                q \u003d a / b;\n                t \u003d a % b;\n                a \u003d b;\n                b \u003d t;\n                t \u003d x;\n                x \u003d lastx - q * x;\n                lastx \u003d t;\n                t \u003d y;\n                y \u003d lasty - q * y;\n                lasty \u003d t;\n            }\n            return (lastx + M) % M;\n        }\n\n        public static int gcd(int a, int b) {\n            return b \u003d\u003d 0 ? a : gcd(b, a % b);\n        }\n\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eVarying Kibibits\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"772D\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eexample code (c++, inclusion/exclusion approach)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e// vvvvvvvvvvvvvvvvv Library code start\n\n#include \u0026lt;array\u0026gt;\n\n\n#define NDEBUG\nNDEBUG\n\n\n#include \u0026lt;algorithm\u0026gt;\n\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;functional\u0026gt;\n#include \u0026lt;iomanip\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;sstream\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;tuple\u0026gt;\n#include \u0026lt;unordered_map\u0026gt;\n#include \u0026lt;unordered_set\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;memory\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;random\u0026gt;\n\n\n#define forn(t, i, n) for (t i \u003d 0; i \u0026lt; (n); ++i)\n\n#define rforn(t, i, n) for (t i \u003d (n) - 1; i \u0026gt;\u003d 0; --i)\n\n#define all(c) c.begin(), c.end()\n\n\nusing namespace std;\n\n/// caide keep\nbool __hack \u003d std::ios::sync_with_stdio(false);\n/// caide keep\nauto __hack1 \u003d cin.tie(nullptr);\n\n\n// Section with adoption of array and vector algorithms.\n\n\n// 32 bit ints (sum LSB + MSB \u003d\u003d 32)\n\n\n// TODO: Section with some container algorithms\n\n\n#define ENABLE_IF(e) typename enable_if\u0026lt;e\u0026gt;::type* \u003d nullptr\n\nnamespace template_util {\n    template\u0026lt;class T\u0026gt;\n    constexpr T min(T a, T b) {\n        return a \u0026lt; b ? a : b;\n    }\n\n    \n    constexpr int bytecount(uint64_t x) {\n        return x ? 1 + bytecount(x \u0026gt;\u0026gt; 8) : 0;\n    }\n\n    /// caide keep\n    template\u0026lt;int N\u0026gt;\n    struct bytetype {\n        typedef uint64_t type;\n    };\n\n    /// caide keep\n    template\u0026lt;\u0026gt;\n    struct bytetype\u0026lt;4\u0026gt; {\n        typedef uint32_t type;\n    };\n\n    /// caide keep\n    template\u0026lt;\u0026gt;\n    struct bytetype\u0026lt;3\u0026gt; {\n        \n    };\n\n    /// caide keep\n    template\u0026lt;\u0026gt;\n    struct bytetype\u0026lt;2\u0026gt; {\n        \n    };\n\n    /// caide keep\n    template\u0026lt;\u0026gt;\n    struct bytetype\u0026lt;1\u0026gt; {\n        typedef uint8_t type;\n    };\n\n    /// caide keep\n    template\u0026lt;\u0026gt;\n    struct bytetype\u0026lt;0\u0026gt; {\n        typedef uint8_t type;\n    };\n\n    /// caide keep\n    template\u0026lt;uint64_t N\u0026gt;\n    struct minimal_uint : bytetype\u0026lt;bytecount(N)\u0026gt; {\n    };\n}\n\n\ntemplate\u0026lt;class T\u0026gt;\nT next(istream\u0026amp; in) {\n    T ret;\n    in \u0026gt;\u0026gt; ret;\n    return ret;\n}\n\ntemplate\u0026lt;class T\u0026gt;\nvector\u0026lt;T\u0026gt; next_vector(istream\u0026amp; in, size_t n) {\n    vector\u0026lt;T\u0026gt; ret(n);\n    for (size_t i \u003d 0; i \u0026lt; n; ++i) {\n        ret[i] \u003d next\u0026lt;T\u0026gt;(in);\n    }\n    return ret;\n}\n\n\n#define dbg(...) ;\n\n\n/*\nTODOs:\n cache invs\n primitive root\n discrete log\n\n tests!!!\n*/\n\nnamespace mod_impl {\n    /// caide keep\n    template \u0026lt;class T\u0026gt;\n    constexpr inline T mod(T MOD) {\n        return MOD;\n    }\n\n    /// caide keep\n    template \u0026lt;class T\u0026gt;\n    constexpr inline T mod(T* MOD) {\n        return *MOD;\n    }\n\n    /// caide keep\n    template \u0026lt;class T\u0026gt;\n    constexpr inline T max_mod(T MOD) {\n        return MOD - 1;\n    }\n\n    /// caide keep\n    template \u0026lt;class T\u0026gt;\n    constexpr inline T max_mod(T*) {\n        return numeric_limits\u0026lt;T\u0026gt;::max() - 1;\n    }\n\n    \n    constexpr inline uint64_t combine_max_sum(uint64_t a, uint64_t b) {\n        return a \u0026gt; ~b ? 0 : a + b;\n    }\n\n    constexpr inline uint64_t combine_max_mul(uint64_t a, uint64_t b) {\n        return a \u0026gt; numeric_limits\u0026lt;uint64_t\u0026gt;::max() / b ? 0 : a * b;\n    }\n\n    /// caide keep\n    template \u0026lt;class T\u0026gt;\n    constexpr inline uint64_t next_divisible(T mod, uint64_t max) {\n        return max % mod \u003d\u003d 0 ? max : combine_max_sum(max, mod - max % mod);\n    }\n\n    /// caide keep\n    template \u0026lt;class T\u0026gt;\n    constexpr inline uint64_t next_divisible(T*, uint64_t) {\n        return 0;\n    }\n\n    //caide keep\n    constexpr int IF_THRESHOLD \u003d 2;\n\n    template \u0026lt;class T, T MOD_VALUE, uint64_t MAX,\n            class RET \u003d typename template_util::minimal_uint\u0026lt;max_mod(MOD_VALUE)\u0026gt;::type,\n            ENABLE_IF(MAX \u0026lt;\u003d max_mod(MOD_VALUE) \u0026amp;\u0026amp; !is_pointer\u0026lt;T\u0026gt;::value)\u0026gt;\n    inline RET smart_mod(typename template_util::minimal_uint\u0026lt;MAX\u0026gt;::type value) {\n        return value;\n    }\n\n    template \u0026lt;class T, T MOD_VALUE, uint64_t MAX,\n            class RET \u003d typename template_util::minimal_uint\u0026lt;max_mod(MOD_VALUE)\u0026gt;::type,\n            ENABLE_IF(max_mod(MOD_VALUE) \u0026lt; MAX \u0026amp;\u0026amp; MAX \u0026lt;\u003d IF_THRESHOLD * max_mod(MOD_VALUE) \u0026amp;\u0026amp; !is_pointer\u0026lt;T\u0026gt;::value)\u0026gt;\n    inline RET smart_mod(typename template_util::minimal_uint\u0026lt;MAX\u0026gt;::type value) {\n        while (value \u0026gt;\u003d mod(MOD_VALUE)) {\n            value -\u003d mod(MOD_VALUE);\n        }\n        return (RET)value;\n    }\n\n    template \u0026lt;class T, T MOD_VALUE, uint64_t MAX,\n             class RET \u003d typename template_util::minimal_uint\u0026lt;max_mod(MOD_VALUE)\u0026gt;::type,\n             ENABLE_IF(IF_THRESHOLD * max_mod(MOD_VALUE) \u0026lt; MAX || is_pointer\u0026lt;T\u0026gt;::value)\u0026gt;\n    inline RET smart_mod(typename template_util::minimal_uint\u0026lt;MAX\u0026gt;::type value) {\n        return (RET)(value % mod(MOD_VALUE));\n    }\n}\n\n#define MOD mod_impl::mod(MOD_VALUE)\n#define MAX_MOD mod_impl::max_mod(MOD_VALUE)\n\nstruct DenormTag {};\n\ntemplate \u0026lt;class T, T MOD_VALUE, uint64_t MAX \u003d MAX_MOD, ENABLE_IF(MAX_MOD \u0026gt;\u003d 2)\u0026gt;\nstruct ModVal {\n    typedef typename template_util::minimal_uint\u0026lt;MAX\u0026gt;::type storage;\n    storage value;\n\n    /// caide keep\n    inline ModVal(): value(0) {\n        assert(MOD \u0026gt;\u003d 2);\n    }\n\n    \n    inline ModVal(storage v, DenormTag): value(v) {\n        assert(MOD \u0026gt;\u003d 2);\n        assert(v \u0026lt;\u003d MAX);\n    };\n\n    inline operator ModVal\u0026lt;T, MOD_VALUE\u0026gt;() {\n        return {v(), DenormTag()};\n    };\n\n    explicit inline operator uint64_t() const {\n        return v();\n    }\n\n    typename template_util::minimal_uint\u0026lt;mod_impl::max_mod(MOD_VALUE)\u0026gt;::type v() const {\n        return mod_impl::smart_mod\u0026lt;T, MOD_VALUE, MAX\u0026gt;(value);\n    }\n};\n\ntemplate \u0026lt;class T, T MOD_VALUE, uint64_t MAX,\n        uint64_t NEW_MAX \u003d mod_impl::next_divisible(MOD_VALUE, MAX),\n        ENABLE_IF(NEW_MAX !\u003d 0),\n        class Ret \u003d ModVal\u0026lt;T, MOD_VALUE, NEW_MAX\u0026gt;\u0026gt;\ninline Ret operator-(const ModVal\u0026lt;T, MOD_VALUE, MAX\u0026gt;\u0026amp; o) {\n    static_assert(NEW_MAX \u0026lt;\u003d numeric_limits\u0026lt;typename Ret::storage\u0026gt;::max(), \u0026quot;bad unary minus template\u0026quot;);\n    assert(NEW_MAX % MOD \u003d\u003d 0 \u0026amp;\u0026amp; o.value \u0026lt;\u003d NEW_MAX);\n    return {typename Ret::storage(NEW_MAX - o.value), DenormTag()};\n}\n\n\ntemplate \u0026lt;class T, T MOD_VALUE, uint64_t MAX1, uint64_t MAX2,\n        uint64_t NEW_MAX \u003d mod_impl::combine_max_sum(MAX1, MAX2),\n        ENABLE_IF(NEW_MAX !\u003d 0), class Ret \u003d ModVal\u0026lt;T, MOD_VALUE, NEW_MAX\u0026gt;\u0026gt;\ninline Ret operator+(ModVal\u0026lt;T, MOD_VALUE, MAX1\u0026gt; o1, ModVal\u0026lt;T, MOD_VALUE, MAX2\u0026gt; o2) {\n    return {typename Ret::storage(typename Ret::storage() + o1.value + o2.value), DenormTag()};\n}\n\n\ntemplate \u0026lt;class T, T MOD_VALUE, uint64_t MAX1, uint64_t MAX2,\n        uint64_t NEW_MAX \u003d mod_impl::combine_max_mul(MAX1, MAX2),\n        ENABLE_IF(NEW_MAX !\u003d 0), class Ret \u003d ModVal\u0026lt;T, MOD_VALUE, NEW_MAX\u0026gt;\u0026gt;\ninline Ret operator*(ModVal\u0026lt;T, MOD_VALUE, MAX1\u0026gt; o1, ModVal\u0026lt;T, MOD_VALUE, MAX2\u0026gt; o2) {\n    return {typename Ret::storage(typename Ret::storage(1) * o1.value * o2.value), DenormTag()};\n}\n\ntemplate \u0026lt;class T, T MOD_VALUE, uint64_t MAX1, uint64_t MAX2,\n        uint64_t NEW_MAX \u003d mod_impl::combine_max_mul(MAX1, MAX2),\n        uint64_t NEW_MAX1 \u003d mod_impl::combine_max_mul(MAX_MOD, template_util::min(MAX1, MAX2)),\n        ENABLE_IF(NEW_MAX \u003d\u003d 0 \u0026amp;\u0026amp; NEW_MAX1 !\u003d 0 \u0026amp;\u0026amp; MAX1 \u0026lt;\u003d MAX2),\n        class Ret \u003d ModVal\u0026lt;T, MOD_VALUE, mod_impl::combine_max_mul(MAX1, MAX_MOD)\u0026gt;\u0026gt;\ninline Ret operator*(const ModVal\u0026lt;T, MOD_VALUE, MAX1\u0026gt;\u0026amp; o1, const ModVal\u0026lt;T, MOD_VALUE, MAX2\u0026gt;\u0026amp; o2) {\n    return {typename Ret::storage(typename Ret::storage(1) * o1.value * o2.v()), DenormTag()};\n}\n\ntemplate \u0026lt;class T, T MOD_VALUE, uint64_t MAX1, uint64_t MAX2,\n        uint64_t NEW_MAX \u003d mod_impl::combine_max_mul(MAX1, MAX2),\n        uint64_t NEW_MAX1 \u003d mod_impl::combine_max_mul(MAX_MOD, template_util::min(MAX1, MAX2)),\n        ENABLE_IF(NEW_MAX \u003d\u003d 0 \u0026amp;\u0026amp; NEW_MAX1 !\u003d 0 \u0026amp;\u0026amp; MAX2 \u0026lt; MAX1),\n        class Ret \u003d ModVal\u0026lt;T, MOD_VALUE, mod_impl::combine_max_mul(MAX_MOD, MAX2)\u0026gt;\u0026gt;\ninline Ret operator*(const ModVal\u0026lt;T, MOD_VALUE, MAX1\u0026gt;\u0026amp; o1, const ModVal\u0026lt;T, MOD_VALUE, MAX2\u0026gt;\u0026amp; o2) {\n    return {typename Ret::storage(typename Ret::storage(1) * o1.v() * o2.value), DenormTag()};\n}\n\n\ntemplate \u0026lt;class T, T MOD_VALUE, uint64_t MAX1, uint64_t MAX2\u0026gt;\ninline auto operator-(const ModVal\u0026lt;T, MOD_VALUE, MAX1\u0026gt;\u0026amp; lhs, const ModVal\u0026lt;T, MOD_VALUE, MAX2\u0026gt;\u0026amp; rhs) -\u0026gt; decltype(lhs + (-rhs)) {\n    return lhs + (-rhs);\n}\n\ntemplate \u0026lt;class T, T MOD_VALUE, uint64_t MAX\u0026gt;\ninline ModVal\u0026lt;T, MOD_VALUE\u0026gt;\u0026amp; operator+\u003d(ModVal\u0026lt;T, MOD_VALUE\u0026gt;\u0026amp; lhs, const ModVal\u0026lt;T, MOD_VALUE, MAX\u0026gt;\u0026amp; rhs) {\n    lhs \u003d lhs + rhs;\n    return lhs;\n}\n\ntemplate \u0026lt;class T, T MOD_VALUE, uint64_t MAX\u0026gt;\ninline ModVal\u0026lt;T, MOD_VALUE\u0026gt;\u0026amp; operator-\u003d(ModVal\u0026lt;T, MOD_VALUE\u0026gt;\u0026amp; lhs, const ModVal\u0026lt;T, MOD_VALUE, MAX\u0026gt;\u0026amp; rhs) {\n    lhs \u003d lhs - rhs;\n    return lhs;\n}\n\n\ntemplate \u0026lt;class T, T MOD_VALUE, uint64_t MAX1, uint64_t MAX2\u0026gt;\ninline bool operator!\u003d(const ModVal\u0026lt;T, MOD_VALUE, MAX1\u0026gt;\u0026amp; lhs, const ModVal\u0026lt;T, MOD_VALUE, MAX2\u0026gt;\u0026amp; rhs) {\n    return lhs.v() !\u003d rhs.v();\n}\n\n\ntemplate \u0026lt;class T, T MOD_VALUE, class MOD_TYPE\u0026gt;\nstruct ModCompanion {\n    typedef MOD_TYPE mod_type;\n    typedef ModVal\u0026lt;mod_type, MOD_VALUE\u0026gt; type;\n    \n\n    template \u0026lt;uint64_t C\u0026gt;\n    inline static constexpr ModVal\u0026lt;mod_type, MOD_VALUE, C\u0026gt; c() {\n        return {C, DenormTag()};\n    };\n\n    template \u0026lt;uint64_t MAX \u003d numeric_limits\u0026lt;uint64_t\u0026gt;::max()\u0026gt;\n    inline static ModVal\u0026lt;mod_type, MOD_VALUE, MAX\u0026gt; wrap(uint64_t x) {\n        assert(x \u0026lt;\u003d MAX);\n        return {typename ModVal\u0026lt;mod_type, MOD_VALUE, MAX\u0026gt;::storage(x), DenormTag()};\n    };\n\n    template \u0026lt;uint64_t MAX, ENABLE_IF(!is_pointer\u0026lt;T\u0026gt;::value \u0026amp;\u0026amp; MAX \u0026lt;\u003d MAX_MOD)\u0026gt;\n    inline static ModVal\u0026lt;mod_type, MOD_VALUE\u0026gt; inv(const ModVal\u0026lt;mod_type, MOD_VALUE, MAX\u0026gt;\u0026amp; x) {\n        if (x.value \u003d\u003d 1) {\n            return c\u0026lt;1\u0026gt;();\n        }\n        return -(wrap\u0026lt;MAX_MOD / 2\u0026gt;(MOD / x.value) * inv(wrap\u0026lt;MAX\u0026gt;(MOD % x.value)));\n    };\n\n    \n};\n\n\n#undef MOD\n#undef MAX_MOD\n\ntemplate \u0026lt;uint64_t MOD_VALUE\u0026gt;\nstruct Mod : ModCompanion\u0026lt;uint64_t, MOD_VALUE, typename template_util::minimal_uint\u0026lt;MOD_VALUE\u0026gt;::type\u0026gt; {\n    template\u0026lt;uint64_t VAL\u0026gt;\n    static constexpr uint64_t literal_builder() {\n        return VAL;\n    }\n\n    template\u0026lt;uint64_t VAL, char DIGIT, char... REST\u0026gt;\n    static constexpr uint64_t literal_builder() {\n        return literal_builder\u0026lt;(10 * VAL + DIGIT - \u00270\u0027) % MOD_VALUE, REST...\u0026gt;();\n    }\n};\n\n\n#define REGISTER_MOD_LITERAL(mod, suffix) \\\ntemplate \u0026lt;char... DIGITS\u0026gt; mod::type operator \u0026quot;\u0026quot; _##suffix() { \\\n    return mod::c\u0026lt;mod::literal_builder\u0026lt;0, DIGITS...\u0026gt;()\u0026gt;(); \\\n}\n\n\n// ^^^^^^^^^^^^^^^^^ Library code end\n\nusing md \u003d Mod\u0026lt;1000000007\u0026gt;;\nusing mt \u003d md::type;\nREGISTER_MOD_LITERAL(md, mod)\n\nusing Val \u003d tuple\u0026lt;int, mt, mt\u0026gt;;\n\nmt pow2s[1000001], powInv2s[1000001];\n\nmt pow2(int p) {\n    return p \u0026lt; 0 ? powInv2s[-p] : pow2s[p];\n}\n\nVal mul(Val a, Val b) {\n    const mt p2a \u003d pow2(get\u0026lt;0\u0026gt;(a));\n    const mt p2b \u003d pow2(get\u0026lt;0\u0026gt;(b));\n    return Val{get\u0026lt;0\u0026gt;(a) + get\u0026lt;0\u0026gt;(b), p2a * get\u0026lt;1\u0026gt;(b) + get\u0026lt;1\u0026gt;(a) * p2b, p2a * get\u0026lt;2\u0026gt;(b) + 2_mod * get\u0026lt;1\u0026gt;(a) * get\u0026lt;1\u0026gt;(b) + get\u0026lt;2\u0026gt;(a) * p2b};\n}\n\nVal inv(Val a) {\n    Val b;\n    get\u0026lt;0\u0026gt;(b) \u003d -get\u0026lt;0\u0026gt;(a);\n    const mt p2b \u003d pow2(get\u0026lt;0\u0026gt;(b));\n    get\u0026lt;1\u0026gt;(b) \u003d -p2b * (get\u0026lt;1\u0026gt;(a) * p2b);\n    get\u0026lt;2\u0026gt;(b) \u003d -p2b * (2_mod * get\u0026lt;1\u0026gt;(a) * get\u0026lt;1\u0026gt;(b) + get\u0026lt;2\u0026gt;(a) * p2b);\n    return b;\n}\n\nVal d[1000000][7];\nmt dSum[1000000][7];\n\nvoid solve(istream\u0026amp; in, ostream\u0026amp; out) {\n    pow2s[0] \u003d powInv2s[0] \u003d 1_mod;\n    mt inv2 \u003d md::inv(2_mod);\n    forn (int, i, 1000000) {\n        pow2s[i + 1] \u003d pow2s[i] * 2_mod;\n        powInv2s[i + 1] \u003d powInv2s[i] * inv2;\n    }\n\n    int n \u003d next\u0026lt;int\u0026gt;(in);\n    auto as \u003d next_vector\u0026lt;int\u0026gt;(in, n);\n    sort(all(as));\n    uint64_t ans \u003d 0;\n    int add[1 \u0026lt;\u0026lt; 6];\n    forn (int, mask, 1 \u0026lt;\u0026lt; 6) {\n        add[mask] \u003d 0;\n        int mask1 \u003d mask;\n        forn (int, it, 6) {\n            add[mask] \u003d add[mask] * 10 + (mask1 \u0026amp; 1);\n            mask1 /\u003d 2;\n        }\n    }\n    int asIt \u003d n - 1;\n    rforn (int, x, 1000000) {\n        int badMask \u003d 0;\n        int x1 \u003d x;\n        forn (int, it, 6) {\n            badMask \u003d 2 * badMask + (x1 % 10 \u003d\u003d 9 ? 1 : 0);\n            x1 /\u003d 10;\n        }\n        d[x][0] \u003d Val{0, 0_mod, 0_mod};\n        dSum[x][0] \u003d 0_mod;\n        forn (int, bit, 6) {\n            d[x][bit + 1] \u003d d[x][bit];\n            dSum[x][bit + 1] \u003d dSum[x][bit];\n            if (!(badMask \u0026amp; (1 \u0026lt;\u0026lt; bit))) {\n                d[x][bit + 1] \u003d mul(d[x][bit + 1], inv(d[x + add[1 \u0026lt;\u0026lt; bit]][bit]));\n                dSum[x][bit + 1] -\u003d  dSum[x + add[1 \u0026lt;\u0026lt; bit]][bit];\n            }\n        }\n        auto val \u003d inv(d[x][6]);\n        while (asIt \u0026gt;\u003d 0 \u0026amp;\u0026amp; as[asIt] \u003d\u003d x) {\n            --asIt;\n            val \u003d mul(val, Val{1, md::wrap(x), md::wrap(1ULL * x * x)});\n        }\n        auto sum \u003d get\u0026lt;2\u0026gt;(val) + dSum[x][6];\n        forn (int, bit, 6) {\n            d[x][bit] \u003d mul(d[x][bit], val);\n            dSum[x][bit] +\u003d get\u0026lt;2\u0026gt;(val);\n        }\n        if (sum !\u003d 0_mod) {\n            dbg(x, sum, x * uint64_t(sum));\n            ans ^\u003d x * uint64_t(sum);\n        }\n    }\n    out \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\n\nint main() {\n    solve(cin, cout);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eexample code (java, FWHT approach)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream \u003d System.in;\n        OutputStream outputStream \u003d System.out;\n        InputReader in \u003d new InputReader(inputStream);\n        OutputWriter out \u003d new OutputWriter(outputStream);\n        MinAddition solver \u003d new MinAddition();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class MinAddition {\n        public int[] pow10 \u003d {1, 10, 100, 1000, 10000, 100000, 1000000};\n        public int MAXN \u003d 1000000;\n        public int LOG \u003d 6;\n        public int mod \u003d 1000000007;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n \u003d in.nextInt();\n            int[] freq \u003d new int[MAXN];\n            int[] sum \u003d new int[MAXN];\n            int[] sum2 \u003d new int[MAXN];\n            int[] pow2 \u003d new int[n + 1];\n            pow2[0] \u003d 1;\n            for (int i \u003d 1; i \u0026lt;\u003d n; i++) pow2[i] \u003d (pow2[i - 1] \u0026lt;\u0026lt; 1) % mod;\n            for (int i \u003d 0; i \u0026lt; n; i++) {\n                int a \u003d in.nextInt();\n                freq[a]++;\n                sum[a] +\u003d a;\n                if (sum[a] \u0026gt;\u003d mod) sum[a] -\u003d mod;\n                int x \u003d (int) (1L * a * a % mod);\n                sum2[a] +\u003d x;\n                if (sum2[a] \u0026gt;\u003d mod) sum2[a] -\u003d mod;\n            }\n\n            int[] mod10 \u003d new int[MAXN];\n            for (int i \u003d 0; i \u0026lt; 10; i++) mod10[i] \u003d i;\n            for (int i \u003d 10; i \u0026lt; MAXN; i++) mod10[i] \u003d mod10[i - 10];\n\n            for (int level \u003d LOG - 1; level \u0026gt;\u003d 0; level--) {\n                for (int i \u003d MAXN - 1; i \u0026gt;\u003d 0; i--) {\n                    int d \u003d mod10[i / pow10[level]];\n                    if (d \u0026gt; 0) {\n                        int p \u003d i - pow10[level];\n                        freq[p] +\u003d freq[i];\n                        sum[p] +\u003d sum[i];\n                        if (sum[p] \u0026gt;\u003d mod) sum[p] -\u003d mod;\n                        sum2[p] +\u003d sum2[i];\n                        if (sum2[p] \u0026gt;\u003d mod) sum2[p] -\u003d mod;\n                    }\n                }\n            }\n            for (int i \u003d 0; i \u0026lt; MAXN; i++) {\n                int sdiff \u003d (int) ((1L * sum[i] * sum[i] + mod - sum2[i]) % mod);\n                int ssame \u003d sum2[i];\n                int g \u003d 0;\n                if (freq[i] \u0026gt;\u003d 1)\n                    g +\u003d (int) (1L * ssame * pow2[freq[i] - 1] % mod);\n                if (freq[i] \u0026gt;\u003d 2)\n                    g +\u003d (int) (1L * sdiff * pow2[freq[i] - 2] % mod);\n                while (g \u0026gt;\u003d mod) g -\u003d mod;\n                freq[i] \u003d g;\n            }\n\n            for (int level \u003d 0; level \u0026lt; LOG; level++) {\n                for (int i \u003d 0; i \u0026lt; MAXN; i++) {\n                    int d \u003d mod10[i / pow10[level]];\n                    if (d + 1 \u0026lt; 10) {\n                        int p \u003d i + pow10[level];\n                        freq[i] -\u003d freq[p];\n                        if (freq[i] \u0026lt; 0) freq[i] +\u003d mod;\n                    }\n                }\n            }\n\n            long s \u003d 0;\n            for (int i \u003d 0; i \u0026lt; MAXN; i++) {\n                s ^\u003d 1L * i * freq[i];\n            }\n            out.println(s);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer \u003d new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer \u003d new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf \u003d new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream \u003d stream;\n        }\n\n        public int read() {\n            if (this.numChars \u003d\u003d -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar \u0026gt;\u003d this.numChars) {\n                    this.curChar \u003d 0;\n\n                    try {\n                        this.numChars \u003d this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars \u0026lt;\u003d 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c \u003d this.read(); isSpaceChar(c); c \u003d this.read()) {\n                ;\n            }\n\n            byte sgn \u003d 1;\n            if (c \u003d\u003d 45) {\n                sgn \u003d -1;\n                c \u003d this.read();\n            }\n\n            int res \u003d 0;\n\n            while (c \u0026gt;\u003d 48 \u0026amp;\u0026amp; c \u0026lt;\u003d 57) {\n                res *\u003d 10;\n                res +\u003d c - 48;\n                c \u003d this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c \u003d\u003d 32 || c \u003d\u003d 10 || c \u003d\u003d 13 || c \u003d\u003d 9 || c \u003d\u003d -1;\n        }\n\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eVerifying Kingdom\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"772E\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eexample code (c++)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e// vvvvvvvvvvvvvvvvv Library code start\n\n\n#define NDEBUG\nNDEBUG\n\n\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;array\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;functional\u0026gt;\n#include \u0026lt;iomanip\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;sstream\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;tuple\u0026gt;\n#include \u0026lt;unordered_map\u0026gt;\n#include \u0026lt;unordered_set\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;memory\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;random\u0026gt;\n\n\n#define forn(t, i, n) for (t i \u003d 0; i \u0026lt; (n); ++i)\n#define foran(t, i, a, n) for (t i \u003d (a); i \u0026lt; (n); ++i)\n\n\nusing namespace std;\n\n/// caide keep\nbool __hack \u003d std::ios::sync_with_stdio(false);\n/// caide keep\nauto __hack1 \u003d cin.tie(nullptr);\n\ntemplate\u0026lt;class T\u0026gt;\ninline T mn(T arg) {\n    return arg;\n}\n\n\ntemplate\u0026lt;class T, class... Args\u0026gt;\ninline bool rmx(T \u0026amp;to, Args... args) {\n    auto v \u003d mn(args...);\n    if (to \u0026lt; v) {\n        to \u003d v;\n        return true;\n    }\n    return false;\n}\n\n\n// Section with adoption of array and vector algorithms.\n\n\n// 32 bit ints (sum LSB + MSB \u003d\u003d 32)\n\n\n// TODO: Section with some container algorithms\n\n\nnamespace template_util {\n    \n\n    constexpr int bytecount(uint64_t x) {\n        return x ? 1 + bytecount(x \u0026gt;\u0026gt; 8) : 0;\n    }\n\n    /// caide keep\n    template\u0026lt;int N\u0026gt;\n    struct bytetype {\n        \n    };\n\n    /// caide keep\n    template\u0026lt;\u0026gt;\n    struct bytetype\u0026lt;4\u0026gt; {\n        \n    };\n\n    /// caide keep\n    template\u0026lt;\u0026gt;\n    struct bytetype\u0026lt;3\u0026gt; {\n        \n    };\n\n    /// caide keep\n    template\u0026lt;\u0026gt;\n    struct bytetype\u0026lt;2\u0026gt; {\n        \n    };\n\n    /// caide keep\n    template\u0026lt;\u0026gt;\n    struct bytetype\u0026lt;1\u0026gt; {\n        \n    };\n\n    /// caide keep\n    template\u0026lt;\u0026gt;\n    struct bytetype\u0026lt;0\u0026gt; {\n        \n    };\n\n    /// caide keep\n    template\u0026lt;uint64_t N\u0026gt;\n    struct minimal_uint : bytetype\u0026lt;bytecount(N)\u0026gt; {\n    };\n}\n\n\ntemplate\u0026lt;class T\u0026gt;\nT next(istream\u0026amp; in) {\n    T ret;\n    in \u0026gt;\u0026gt; ret;\n    return ret;\n}\n\n\n// ^^^^^^^^^^^^^^^^^ Library code end\n\nint tr[1000][3];\nint l[1000], r[1000];\nbool col[1000];\nint ans[2000];\n\ntuple\u0026lt;int, int, int\u0026gt; chooseDfs(int total, int i, int p \u003d -1) {\n    int size \u003d 1, best \u003d -1, bestSize \u003d 1000000000, maxSize \u003d 0;\n    forn (int, e, 3) {\n        int j \u003d tr[i][e];\n        if (j !\u003d p \u0026amp;\u0026amp; j \u0026gt;\u003d 0 \u0026amp;\u0026amp; !col[j]) {\n            auto r1 \u003d chooseDfs(total, j, i);\n            if (get\u0026lt;1\u0026gt;(r1) \u0026lt; bestSize) {\n                best \u003d get\u0026lt;0\u0026gt;(r1);\n                bestSize \u003d get\u0026lt;1\u0026gt;(r1);\n            }\n            size +\u003d get\u0026lt;2\u0026gt;(r1);\n            rmx(maxSize, get\u0026lt;2\u0026gt;(r1));\n        }\n    }\n    rmx(maxSize, total - size);\n    if (maxSize \u0026lt; bestSize) {\n        best \u003d i;\n        bestSize \u003d maxSize;\n    }\n    return tuple\u0026lt;int, int, int\u0026gt;{best, bestSize, size};\n}\n\nint sizeDfs(int i, int p \u003d -1) {\n    auto r \u003d 1;\n    forn (int, e, 3) {\n        int j \u003d tr[i][e];\n        if (j !\u003d p \u0026amp;\u0026amp; j \u0026gt;\u003d 0 \u0026amp;\u0026amp; !col[j]) {\n            r +\u003d sizeDfs(j, i);\n        }\n    }\n    return r;\n}\n\nvoid ansDfs(int n, int i) {\n    forn (int, e, 2) {\n        if (tr[i][e] \u0026gt;\u003d 0) {\n            ansDfs(n, tr[i][e]);\n        }\n        ans[tr[i][e] \u0026lt; 0 ? -2 - tr[i][e] : n + tr[i][e]] \u003d n + i + 1;\n    }\n}\n\nvoid solve(istream\u0026amp; in, ostream\u0026amp; out) {\n    auto q \u003d [\u0026amp;](int a, int b, int c) {\n        out \u0026lt;\u0026lt; a + 1 \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; b + 1 \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; c + 1 \u0026lt;\u0026lt; endl;\n        string s \u003d next\u0026lt;string\u0026gt;(in);\n        if (s \u003d\u003d \u0026quot;X\u0026quot;) {\n            return 2;\n        } else if (s \u003d\u003d \u0026quot;Y\u0026quot;) {\n            return 1;\n        } else if (s \u003d\u003d \u0026quot;Z\u0026quot;) {\n            return 0;\n        } else {\n            throw 42;\n        }\n    };\n    int n \u003d next\u0026lt;int\u0026gt;(in);\n    memset(tr, -1, sizeof(tr));\n    tr[0][0] \u003d -2;\n    tr[0][1] \u003d -3;\n    l[0] \u003d 0;\n    r[0] \u003d 1;\n    foran (int, i, 2, n) {\n        memset(col, 0, sizeof(col));\n        int x \u003d 0;\n        while (true) {\n            x \u003d get\u0026lt;0\u0026gt;(chooseDfs(sizeDfs(x), x));\n            int e \u003d q(l[x], r[x], i);\n            if (tr[x][e] \u0026lt; 0 || col[tr[x][e]]) {\n                if (tr[x][e] \u0026gt;\u003d 0) {\n                    forn (int, e1, 3) {\n                        if (tr[tr[x][e]][e1] \u003d\u003d x) {\n                            tr[tr[x][e]][e1] \u003d i - 1;\n                        }\n                    }\n                }\n                tr[i - 1][e] \u003d tr[x][e];\n                tr[x][e] \u003d i - 1;\n                tr[i - 1][e \u003d\u003d 0 ? 1 : 0] \u003d -2 - i;\n                tr[i - 1][e \u003d\u003d 2 ? 1 : 2] \u003d x;\n                l[i - 1] \u003d tr[i - 1][0] \u0026lt; 0 ? -2 - tr[i - 1][0] : l[tr[i - 1][0]];\n                r[i - 1] \u003d tr[i - 1][1] \u0026lt; 0 ? -2 - tr[i - 1][1] : r[tr[i - 1][1]];\n                break;\n            }\n            col[x] \u003d true;\n            x \u003d tr[x][e];\n        }\n    }\n    int r \u003d 0;\n    while (tr[r][2] !\u003d -1) {\n        r \u003d tr[r][2];\n    }\n    ans[n + r] \u003d -1;\n    ansDfs(n, r);\n    out \u0026lt;\u0026lt; \u0026quot;-1\\n\u0026quot;;\n    forn (int, i, 2 * n - 1) {\n        out \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n    }\n    out \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n}\n\n\nint main() {\n    solve(cin, cout);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eexample code (java)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream \u003d System.in;\n        OutputStream outputStream \u003d System.out;\n        InputReader in \u003d new InputReader(inputStream);\n        OutputWriter out \u003d new OutputWriter(outputStream);\n        ForgottenTree solver \u003d new ForgottenTree();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ForgottenTree {\n        public InputReader in;\n        public OutputWriter out;\n        public int nidx;\n        public int n;\n        public int[] par;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            this.in \u003d in;\n            this.out \u003d out;\n\n            n \u003d in.nextInt();\n            nidx \u003d n;\n            ForgottenTree.Node root \u003d new ForgottenTree.Node(0);\n            ForgottenTree.Node.cgen \u003d 0;\n            for (int i \u003d 1; i \u0026lt; n; i++) {\n                ForgottenTree.Node.cgen++;\n                root.getLeaves();\n                root \u003d insert(root, i);\n            }\n            out.println(-1);\n            par \u003d new int[2 * n - 1];\n            dfs(root, -2);\n            out.println(par);\n        }\n\n        public String ask(int a, int b, int c) {\n            out.println((a + 1) + \u0026quot; \u0026quot; + (b + 1) + \u0026quot; \u0026quot; + (c + 1));\n            out.flush();\n            String ret \u003d in.next();\n            if (ret.equals(\u0026quot;-1\u0026quot;)) System.exit(0);\n            return ret;\n        }\n\n        public void dfs(ForgottenTree.Node root, int p) {\n            par[root.label] \u003d p + 1;\n            if (root.lchild !\u003d null) {\n                dfs(root.lchild, root.label);\n                dfs(root.rchild, root.label);\n            }\n        }\n\n        public ForgottenTree.Node insert(ForgottenTree.Node root, int label) {\n            if (!root.active()) {\n                return add(root, label);\n            }\n            root.dfs();\n\n            if (root.lchild \u003d\u003d null) {\n                return add(root, label);\n            }\n\n            int curleaves \u003d root.nleaves;\n            if (curleaves \u0026lt;\u003d 1) {\n                int nnodes \u003d 0;\n                ForgottenTree.Node cur \u003d root;\n                while (!cur.isLeaf()) {\n                    nnodes++;\n                    if (cur.lchild.active()) cur \u003d cur.lchild;\n                    else cur \u003d cur.rchild;\n                }\n                cur \u003d root;\n                int depth \u003d 0;\n                while (2 * (depth + 1) \u0026lt; nnodes) {\n                    if (cur.lchild.active()) cur \u003d cur.lchild;\n                    else cur \u003d cur.rchild;\n                    depth++;\n                }\n\n                return process(root, cur, label);\n            }\n\n            ForgottenTree.Node cur \u003d root;\n            while (true) {\n                if (cur.lchild \u003d\u003d null) {\n                    if (cur.par \u003d\u003d null) {\n                        return add(cur, label);\n                    }\n                    if (cur.which \u003d\u003d 0) {\n                        cur.par.setChild(0, add(cur, label));\n                        return root;\n                    } else {\n                        cur.par.setChild(1, add(cur, label));\n                        return root;\n                    }\n                }\n                int x1 \u003d cur.lchild.active() ? cur.lchild.nleaves : 0;\n                int x2 \u003d cur.rchild.active() ? cur.rchild.nleaves : 0;\n\n                if (x1 * 2 \u0026gt; curleaves) {\n                    cur \u003d cur.lchild;\n                    continue;\n                }\n                if (x2 * 2 \u0026gt; curleaves) {\n                    cur \u003d cur.rchild;\n                    continue;\n                }\n\n                return process(root, cur, label);\n            }\n        }\n\n        public ForgottenTree.Node process(ForgottenTree.Node root, ForgottenTree.Node cur, int label) {\n            String s \u003d ask(cur.x, cur.y, label);\n            switch (s) {\n                case \u0026quot;X\u0026quot;:\n                    if (cur.par \u003d\u003d null) {\n                        return add(cur, label);\n                    }\n                    cur.disable();\n                    return insert(root, label);\n                case \u0026quot;Y\u0026quot;:\n                    cur.setChild(1, insert(cur.rchild, label));\n                    return root;\n                case \u0026quot;Z\u0026quot;:\n                    cur.setChild(0, insert(cur.lchild, label));\n                    return root;\n                default:\n                    throw new RuntimeException();\n            }\n        }\n\n        public ForgottenTree.Node add(ForgottenTree.Node cnode, int label) {\n            ForgottenTree.Node add \u003d new ForgottenTree.Node(nidx++);\n            add.setChild(0, cnode);\n            add.setChild(1, new ForgottenTree.Node(label));\n            return add;\n        }\n\n        static class Node {\n            public static int cgen;\n            public int x;\n            public int y;\n            public int label;\n            public int gen;\n            public int nleaves;\n            public int which;\n            public ForgottenTree.Node lchild;\n            public ForgottenTree.Node rchild;\n            public ForgottenTree.Node par;\n\n            public Node(int label) {\n                this.lchild \u003d null;\n                this.rchild \u003d null;\n                this.par \u003d null;\n                this.which \u003d 0;\n                this.label \u003d label;\n                this.gen \u003d 0;\n                this.nleaves \u003d 1;\n            }\n\n            public boolean active() {\n                return gen \u0026lt; cgen;\n            }\n\n            public void disable() {\n                this.gen \u003d cgen;\n            }\n\n            public boolean isLeaf() {\n                return lchild \u003d\u003d null || (!lchild.active() \u0026amp;\u0026amp; !rchild.active());\n            }\n\n            public void setChild(int which, ForgottenTree.Node x) {\n                if (which \u003d\u003d 0) {\n                    this.lchild \u003d x;\n                } else {\n                    this.rchild \u003d x;\n                }\n                x.par \u003d this;\n                x.which \u003d which;\n            }\n\n            public void dfs() {\n                if (isLeaf()) {\n                    this.nleaves \u003d 1;\n                    return;\n                }\n\n                this.nleaves \u003d 0;\n                if (lchild.active()) {\n                    lchild.dfs();\n                    this.nleaves +\u003d lchild.nleaves;\n                }\n                if (rchild.active()) {\n                    rchild.dfs();\n                    this.nleaves +\u003d rchild.nleaves;\n                }\n            }\n\n            public void getLeaves() {\n                if (lchild \u003d\u003d null) {\n                    this.x \u003d this.y \u003d label;\n                    return;\n                }\n                lchild.getLeaves();\n                rchild.getLeaves();\n                this.x \u003d lchild.x;\n                this.y \u003d rchild.x;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf \u003d new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream \u003d stream;\n        }\n\n        public int read() {\n            if (this.numChars \u003d\u003d -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar \u0026gt;\u003d this.numChars) {\n                    this.curChar \u003d 0;\n\n                    try {\n                        this.numChars \u003d this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars \u0026lt;\u003d 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c \u003d this.read(); isSpaceChar(c); c \u003d this.read()) {\n                ;\n            }\n\n            byte sgn \u003d 1;\n            if (c \u003d\u003d 45) {\n                sgn \u003d -1;\n                c \u003d this.read();\n            }\n\n            int res \u003d 0;\n\n            while (c \u0026gt;\u003d 48 \u0026amp;\u0026amp; c \u0026lt;\u003d 57) {\n                res *\u003d 10;\n                res +\u003d c - 48;\n                c \u003d this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public String next() {\n            int c;\n            while (isSpaceChar(c \u003d this.read())) {\n                ;\n            }\n\n            StringBuilder result \u003d new StringBuilder();\n            result.appendCodePoint(c);\n\n            while (!isSpaceChar(c \u003d this.read())) {\n                result.appendCodePoint(c);\n            }\n\n            return result.toString();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c \u003d\u003d 32 || c \u003d\u003d 10 || c \u003d\u003d 13 || c \u003d\u003d 9 || c \u003d\u003d -1;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer \u003d new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer \u003d new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i \u003d 0; i \u0026lt; objects.length; i++) {\n                if (i !\u003d 0) {\n                    writer.print(\u0027 \u0027);\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void print(int[] array) {\n            for (int i \u003d 0; i \u0026lt; array.length; i++) {\n                if (i !\u003d 0) {\n                    writer.print(\u0027 \u0027);\n                }\n                writer.print(array[i]);\n            }\n        }\n\n        public void println(int[] array) {\n            print(array);\n            writer.println();\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void flush() {\n            writer.flush();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["vk","cup","round2","tutorial","codeforces","round","409"]}}