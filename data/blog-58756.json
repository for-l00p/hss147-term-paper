{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1522994383,"rating":-3,"authorHandle":"Akikaze","modificationTimeSeconds":1522994383,"id":58756,"title":"\u003cp\u003eEditorial — ACM ProPTIT — Warm-up Round 2\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eĐề được thực hiện bởi \u003ca class\u003d\"rated-user user-black\" href\u003d\"/profile/thegirlinthemoon\" title\u003d\"Unrated, thegirlinthemoon\"\u003ethegirlinthemoon\u003c/a\u003e, \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/lananh98.ptit\" title\u003d\"Specialist lananh98.ptit\"\u003elananh98.ptit\u003c/a\u003e, \u003ca class\u003d\"rated-user user-green\" href\u003d\"/profile/thanthoai999999999\" title\u003d\"Pupil thanthoai999999999\"\u003ethanthoai999999999\u003c/a\u003e, \u003ca class\u003d\"rated-user user-green\" href\u003d\"/profile/duonglee\" title\u003d\"Pupil duonglee\"\u003eduonglee\u003c/a\u003e, \u003ca class\u003d\"rated-user user-green\" href\u003d\"/profile/nghiatd_16\" title\u003d\"Pupil nghiatd_16\"\u003enghiatd_16\u003c/a\u003e và \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Akikaze\" title\u003d\"Expert Akikaze\"\u003eAkikaze\u003c/a\u003e, và được test bởi \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/neko_nyaa\" title\u003d\"Expert neko_nyaa\"\u003eneko_nyaa\u003c/a\u003e và \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Akikaze\" title\u003d\"Expert Akikaze\"\u003eAkikaze\u003c/a\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eBài A - T4k3D4Ch14\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTác giả: \u003ca class\u003d\"rated-user user-black\" href\u003d\"/profile/thegirlinthemoon\" title\u003d\"Unrated, thegirlinthemoon\"\u003ethegirlinthemoon\u003c/a\u003e\u003c/p\u003e\u003cp\u003eEditorial: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Akikaze\" title\u003d\"Expert Akikaze\"\u003eAkikaze\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTags: greedy, two-pointers\u003c/p\u003e\u003cp\u003eTa có thể xử lý tham lam để giải quyết bài toán này.\u003c/p\u003e\u003cp\u003eĐặt 2 con trỏ, mỗi con trỏ nằm ở điểm đầu tiên của mỗi mảng. Ta sẽ di chuyển dần chúng về cuối mảng theo nguyên tắc sau:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eBất cứ khi nào có một con trỏ đi được tới cuối mảng thì ta dừng quá trình di chuyển.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eNếu tổng các phần tử nằm bên trái hoặc nằm trên con trỏ của hai mảng bằng nhau, ta đẩy cả hai con trỏ sang phải \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e bước, và tăng số dãy con tìm được thêm 1 đơn vị.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eNếu giá trị tổng của mảng 1 nhỏ hơn của mảng 2, ta đẩy con trỏ của mảng 1 sang phải \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e bước, và ngược lại nếu tổng của mảng 2 nhỏ hơn của mảng 1.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eViệc tính toán giá trị tổng này có thể thực hiện qua mảng cộng dồn, hoặc qua việc cộng tuần tự trong lúc di chuyển con trỏ.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eĐộ phức tạp của bài toán là \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLời giải: \u003ca href\u003d\"https://ideone.com/oP3A9d\"\u003eIdeone.com\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eBài B - Xayah.PROPTIT\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTác giả: \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/lananh98.ptit\" title\u003d\"Specialist lananh98.ptit\"\u003elananh98.ptit\u003c/a\u003e\u003c/p\u003e\u003cp\u003eEditorial: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Akikaze\" title\u003d\"Expert Akikaze\"\u003eAkikaze\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTags: greedy\u003c/p\u003e\u003cp\u003eKadane returned!\u003c/p\u003e\u003cp\u003eVới các D17 đã làm contest từ trước Tết, hẳn các bạn vẫn nhớ về thuật toán Kadane. Nếu không, bạn có thể xem lại tại \u003ca href\u003d\"https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/\"\u003eđây.\u003c/a\u003e\u003c/p\u003e\u003cp\u003eĐây cũng là một bài áp dụng tư tưởng tham lam của thuật toán Kadane.\u003c/p\u003e\u003cp\u003eDo điều kiện đề bài nên ta nhận thấy, nếu tồn tại mảng con có chỉ số tình yêu \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026gt; 0\u003c/span\u003e), chắc chắn sẽ tồn tại mảng con có chỉ số tình yêu \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - 1\u003c/span\u003e. Ngược lại, nếu tồn tại mảng con có chỉ số tình yêu \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026lt; 0\u003c/span\u003e), chắc chắn sẽ tồn tại mảng con có chỉ số tình yêu \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + 1\u003c/span\u003e. Mảng con có chỉ số tình yêu \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d 0\u003c/span\u003e luôn tồn tại, vì luôn tồn tại mảng con rỗng.\u003c/p\u003e\u003cp\u003eTa sẽ thực hiện giải bài toán này như sau:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eKhởi tạo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eminValue\u003c/i\u003e \u003d 0\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emaxValue\u003c/i\u003e \u003d 0\u003c/span\u003e, lần lượt là giá trị chỉ số tình yêu nhỏ nhất và lớn nhất của toàn bộ bài toán.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eKhởi tạo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecurrMin\u003c/i\u003e \u003d 0\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecurrMax\u003c/i\u003e \u003d 0\u003c/span\u003e, lần lượt là giá trị chỉ số tình yêu nhỏ nhất và lớn nhất của mảng con kết thúc tại vị trí đang xét. Đương nhiên, vị trí khởi tạo là vị trí phần tử thứ \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e (chỉ có thể là mảng rỗng).\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThực hiện duyệt tuần tự mảng. Nếu vị trí đang xét có giá trị là \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e thì tăng \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecurrMax\u003c/i\u003e\u003c/span\u003e lên \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e đơn vị, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecurrMin\u003c/i\u003e \u003d \u003ci\u003emin\u003c/i\u003e(0, \u003ci\u003ecurrMin\u003c/i\u003e + 1)\u003c/span\u003e, còn nếu vị trí đang xét có giá trị là \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e thì giảm \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecurrMin\u003c/i\u003e\u003c/span\u003e xuống \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e đơn vị, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecurrMax\u003c/i\u003e \u003d \u003ci\u003emax\u003c/i\u003e(0, \u003ci\u003ecurrMax\u003c/i\u003e - 1)\u003c/span\u003e. Cập nhật \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eminValue\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emaxValue\u003c/i\u003e\u003c/span\u003e theo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecurrMin\u003c/i\u003e\u003c/span\u003e và \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecurrMax\u003c/i\u003e\u003c/span\u003e vừa tìm được.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eKết quả bài toán sẽ là \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emaxValue\u003c/i\u003e - \u003ci\u003eminValue\u003c/i\u003e + 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eĐộ phức tạp của bài toán là \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLời giải: \u003ca href\u003d\"https://ideone.com/TsoybH\"\u003eIdeone.com\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eBài C - Biến đổi\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTác giả: \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/lananh98.ptit\" title\u003d\"Specialist lananh98.ptit\"\u003elananh98.ptit\u003c/a\u003e\u003c/p\u003e\u003cp\u003eEditorial: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Akikaze\" title\u003d\"Expert Akikaze\"\u003eAkikaze\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTags: data structures\u003c/p\u003e\u003cp\u003eĐây là một bài toán cơ bản sử dụng cấu trúc dữ liệu ngăn xếp (stack). Nguyên tắc sẽ là: ta lưu các phần tử trong stack sao cho từ đỉnh stack tới cuối stack, các phần tử đơn điệu theo chiều giảm ngặt (không được phép có hai phần tử bằng nhau trong stack).\u003c/p\u003e\u003cp\u003eGiản lược thì việc xử lý bài toán sẽ như sau:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eDuyệt tuần tự trên mảng.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eVới mỗi bước duyệt, ta kiểm tra stack. Chừng nào stack không rỗng, và đỉnh stack có giá trị lớn hơn giá trị phần tử đang được duyệt, thì ta loai bỏ phần tử ở đỉnh stack và cộng thêm \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e vào đáp án.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eNếu đỉnh stack (khi stack không rỗng) có giá trị nhỏ hơn hẳn giá trị phần tử đang được duyệt hoặc nếu stack rỗng, ta đưa phần tử đang duyệt vào stack.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eSau khi kết thúc duyệt tuần tự, nếu stack không rỗng, ta loại bỏ dần các phần tử trong stack cho tới hết. Mỗi bước loại bỏ tăng thêm \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e đơn vị vào đáp án.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eĐộ phức tạp của thuật toán là \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLời giải: \u003ca href\u003d\"https://ideone.com/VQiUQt\"\u003eIdeone.com\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eBài D - Dãy con có giá trị liên tiếp dài nhất\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTác giả: \u003ca class\u003d\"rated-user user-green\" href\u003d\"/profile/thanthoai999999999\" title\u003d\"Pupil thanthoai999999999\"\u003ethanthoai999999999\u003c/a\u003e\u003c/p\u003e\u003cp\u003eEditorial: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Akikaze\" title\u003d\"Expert Akikaze\"\u003eAkikaze\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTags: sortings\u003c/p\u003e\u003cp\u003eTa nhận thấy, dãy con cần tìm không liên tiếp, và chỉ cần chứa các số liên tiếp, không cần theo thứ tự nào, cho nên các quy tắc về thứ tự trở nên vô nghĩa ở đây, hoàn toàn ta có thể sắp xếp dãy thành một dãy tăng dần.\u003c/p\u003e\u003cp\u003eSau quá trình sắp xếp này, ta thực hiện tìm tuần tự các dãy con liên tiếp trong mảng, sao cho dãy chỉ gồm các phần tử liên tiếp và khác \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e (số \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e sẽ được loại bỏ vì nó chỉ có giá trị cho biết có thể thêm một số bất kỳ khác vào mảng hay không). Ta lưu các mảng này lại: mỗi mảng chỉ cần lưu hai thông tin, là điểm bắt đầu mảng và độ dài mảng.\u003c/p\u003e\u003cp\u003eNếu mảng ban đầu không có số \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, đáp án là độ dài mảng con lớn nhất.\u003c/p\u003e\u003cp\u003eNếu mảng ban đầu có số \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, ta cũng sẽ khởi tạo đáp án ban đầu là giá trị trên, nhưng sau đó ta thực hiện duyệt lại các mảng con đó: với hai mảng con \u0026quot;ngắt quãng 1\u0026quot; (tức là phần tử cuối của mảng trước cách một bước mới tới phần tử đầu của mảng sau), ta lấy giá trị tổng độ dài 2 mảng con cộng thêm \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, và thực hiện phép lấy max giá trị đó với đáp án hiện có.\u003c/p\u003e\u003cp\u003eỞ cả hai trường hợp, độ phức tạp của bài toán đều là \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLời giải: \u003ca href\u003d\"https://ideone.com/Ky966r\"\u003eIdeone.com\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eBài E - Double Tìm Bạn\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTác giả: \u003ca class\u003d\"rated-user user-green\" href\u003d\"/profile/duonglee\" title\u003d\"Pupil duonglee\"\u003eduonglee\u003c/a\u003e\u003c/p\u003e\u003cp\u003eEditorial: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Akikaze\" title\u003d\"Expert Akikaze\"\u003eAkikaze\u003c/a\u003e, \u003ca class\u003d\"rated-user user-green\" href\u003d\"/profile/duonglee\" title\u003d\"Pupil duonglee\"\u003eduonglee\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTags: sortings, binary search, implementation\u003c/p\u003e\u003cp\u003eĐây là một bài ở mức trung bình, nhưng phức tạp ở việc xử lý input và phân loại nhóm.\u003c/p\u003e\u003cp\u003eNhập dữ liệu cho mỗi người vào các nhóm khác nhau, đồng thời tìm một người cao nhất mỗi nhóm, rồi cho những người cao nhất vào một nhóm riêng.\u003c/p\u003e\u003cp\u003eCác thao tác này nếu thực hiện trên mảng tĩnh sẽ tương đối phức tạp, do đó mình khuyến khích sử dụng thư viện \u003cstrong\u003evector\u003c/strong\u003e của C++.\u003c/p\u003e\u003cp\u003eLấy lần lượt người cao nhất mỗi nhóm:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eDùng biến thể Bsearch trên mảng H ban đầu, ta thu được số người thấp hơn. (Với điều kiện mảng H phải đã được sắp xếp), trừ đi số thành viên trong nhóm ta thu được kết quả.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eDùng biến thể Bsearch trên nhóm những người cao nhất, ta thu được số nhóm tìm thấy được. (Với điều kiện mảng những người cao nhất đã được sắp xếp).\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eĐộ phức tạp của bài toán là \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e * \u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLời giải: \u003ca href\u003d\"https://ideone.com/gINJwV\"\u003eIdeone.com\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eBài F - Đồ thị có hướng\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTác giả: \u003ca class\u003d\"rated-user user-green\" href\u003d\"/profile/nghiatd_16\" title\u003d\"Pupil nghiatd_16\"\u003enghiatd_16\u003c/a\u003e\u003c/p\u003e\u003cp\u003eEditorial: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Akikaze\" title\u003d\"Expert Akikaze\"\u003eAkikaze\u003c/a\u003e, \u003ca class\u003d\"rated-user user-green\" href\u003d\"/profile/nghiatd_16\" title\u003d\"Pupil nghiatd_16\"\u003enghiatd_16\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTags: graphs, matrices\u003c/p\u003e\u003cp\u003eĐây là một bài tương đối khó của contest, lý do là bởi tư duy khá mở và hardcore.\u003c/p\u003e\u003cp\u003eGọi \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e là ma trận chỉ đường đi ngắn nhất từ một đỉnh tới một đỉnh khác, đi qua đúng \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e cạnh.\u003c/p\u003e\u003cp\u003eDĩ nhiên, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(1) \u003d \u003ci\u003eA\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eĐể xây dựng \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(2)\u003c/span\u003e, ta có hệ thức: với \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e bất kỳ trong khoảng \u003cspan class\u003d\"tex-span\"\u003e[1, \u003ci\u003en\u003c/i\u003e]\u003c/span\u003e thì \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(2)[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e] \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e] + \u003ci\u003eA\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e])\u003c/span\u003e (đường đi độ dài 2 cạnh thì qua trung gian 1 đỉnh).\u003c/p\u003e\u003cp\u003eTương tự với xây dựng \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(3)\u003c/span\u003e: với \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e bất kỳ trong khoảng \u003cspan class\u003d\"tex-span\"\u003e[1, \u003ci\u003en\u003c/i\u003e]\u003c/span\u003e thì \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(3)[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e] \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e] + \u003ci\u003eA\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e, \u003ci\u003eu\u003c/i\u003e] + \u003ci\u003eA\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e]) \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003eC\u003c/i\u003e(1)[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003eu\u003c/i\u003e] + \u003ci\u003eA\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e])\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eGọi \u003cem\u003emul\u003c/em\u003e là một phép toán hai ngôi trên ma trận, tương tự như phép nhân ma trận (có tính kết hợp nhưng không có tính giao hoán) nhưng trong quá trình thực hiện, phép nhân của nhân ma trận thay bằng phép cộng, phép cộng của nhân ma trận thay bằng phép lấy min. Đồng thời, gọi \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e là việc thực hiện phép \u003cem\u003emul\u003c/em\u003e liên tiếp với \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e lần ma trận \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTừ đây, ta khái quát công thức tính như sau:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e)[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e] \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003eC\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e - 1)[\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e] + \u003ci\u003eA\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e])\u003c/span\u003e với \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e bất kỳ trong khoảng \u003cspan class\u003d\"tex-span\"\u003e[1, \u003ci\u003en\u003c/i\u003e]\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNói cách khác, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e) \u003d \u003ci\u003eC\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e - 1)\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emul\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e. Với hệ thức truy hồi này, ta tiếp tục rút ra: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e) \u003d \u003ci\u003eA\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eĐộ phức tạp của mỗi phép \u003cem\u003emul\u003c/em\u003e là \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eDĩ nhiên, với giới hạn đề bài, độ phức tạp \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e * \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e không thể giúp bài toán vượt qua giới hạn 0.25s, vậy nên việc tính toán \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e phải dựa vào kỹ thuật chia để trị trong tính toán lũy thừa.\u003c/p\u003e\u003cp\u003eKhi đó, độ phức tạp sẽ là \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e * \u003ci\u003elog\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e))\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eP/s: Ta có thể nhận thấy, phép \u003cem\u003emul\u003c/em\u003e dùng để tính toán ở bài này chính là cơ sở cho thuật toán tìm đường đi ngắn nhất Floyd-Warshall mà sau này sẽ được học tại môn Toán Rời rạc 2. Bạn đọc có thể tham khảo sơ lược tại \u003ca href\u003d\"https://thuytrangcoding.wordpress.com/2018/03/18/graph-shortestpath-floyd/\"\u003eđây.\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLời giải: \u003ca href\u003d\"https://ideone.com/5UBUw2\"\u003eIdeone.com\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eBài G - Mảng số\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTác giả: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Akikaze\" title\u003d\"Expert Akikaze\"\u003eAkikaze\u003c/a\u003e\u003c/p\u003e\u003cp\u003eEditorial: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Akikaze\" title\u003d\"Expert Akikaze\"\u003eAkikaze\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTags: brute-force, data structures, number theory\u003c/p\u003e\u003cp\u003eHmm, đây là một trong hai bài khó nhất của contest lần này, cùng với bài F. Cái khó của bài này khác với bài F ở chỗ: bài F cần một tư duy out-of-the-box cùng nền tảng thuật toán ở mức trung bình, thì bài này lại đòi hỏi kỹ năng xử lý thuật toán và cấu trúc dữ liệu tương đối cao.\u003c/p\u003e\u003cp\u003eVới những bài yêu cầu xử lý nhiều truy vấn như bài G, các phương pháp xử lý thông thường trên mảng tỏ ra không hiệu quả. Một trong những cách hữu dụng nhất là sử dụng cây phân đoạn (segment trees).\u003c/p\u003e\u003cp\u003eBạn đọc có thể đọc thêm về segment trees tại \u003ca href\u003d\"http://vnoi.info/wiki/algo/data-structures/segment-tree-extend\"\u003etrang tư liệu của VNOI\u003c/a\u003e hoặc \u003ca href\u003d\"https://thuytrangcoding.wordpress.com/2018/02/13/ds-st-basic/\"\u003eblog cá nhân của mình\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eQuay trở lại bài G, ta có thể rút ra một số nhận xét về hàm ZD(x):\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eTa có thể hoàn toàn khởi tạo trước mảng tính \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eZD\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e (với \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003ex\u003c/i\u003e| ≤ 10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e) thông qua kỹ thuật \u003ca href\u003d\"http://vnoi.info/wiki/translate/he/Number-Theory-2#s%C3%A0ng-eratosthenes-sieve-of-eratosthenes\"\u003esàng nguyên tố Eratosthenes\u003c/a\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eMỗi số nguyên \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003ex\u003c/i\u003e| ≤ 10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e) có thể được biến đổi theo hệ thức \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e:  \u003d \u003ci\u003eZD\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e tối đa (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elog\u003c/i\u003e|\u003ci\u003ex\u003c/i\u003e|\u003c/span\u003e) lần cho tới khi \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e và \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eZD\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e bằng nhau (ta tạm gọi một số \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e thỏa mãn \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003eZD\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e là một số thuộc \u003cstrong\u003etrạng thái Z\u003c/strong\u003e).\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eĐầu tiên, ta sẽ xây dựng một cây phân đoạn dùng để biểu diễn mảng số ban đầu. Đồng thời, để rút ngắn thời gian thực hiện các truy vấn loại 1 (truy vấn thay thế), ta sẽ xây dựng thêm cây phân đoạn thứ hai, dùng để đếm số lượng các phần tử trong khoảng đã tiến tới \u003cstrong\u003etrạng thái Z\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eNguyên tắc khi cập nhật của ta sẽ là:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eVới cây phân đoạn \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, ta đi tới nút lá và cập nhật trực tiếp giá trị của phần tử biểu diễn bởi nút đó.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eSau khi cập nhật giá trị ở cây phân đoạn \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, ta thực hiện kiểm tra. Nếu giá trị đó tiến tới \u003cstrong\u003etrạng thái Z\u003c/strong\u003e, ta cộng thêm \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e vào nút lá tương ứng ở cây phân đoạn \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eTa có thể dừng cập nhật một đoạn ngay lập tức nếu tất cả các phần tử của khoảng đó tiến tới \u003cstrong\u003etrạng thái Z\u003c/strong\u003e. Thông tin lưu trên cây phân đoạn \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e sẽ giúp ta giải quyết điều này.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eĐộ phức tạp của thuật toán là \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e * \u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e) + \u003ci\u003em\u003c/i\u003e * \u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e) * \u003ci\u003elog\u003c/i\u003e(\u003ci\u003emax\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)))\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eP/s: Bài G có time limit khá chặt (4s), cho nên với các bộ test có mảng lớn, số lượng truy vấn lớn, đặc biệt là số lượng truy vấn loại 2 lớn, thì thời gian chạy chương trình sẽ bị đội lên khá nhiều với ngôn ngữ C++ (có những lúc lên tới 8-10s).\u003c/p\u003e\u003cp\u003eTa có hai cách để khắc phục:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eInput/Output bằng các câu lệnh của C (\u003ccode\u003escanf\u003c/code\u003e/\u003ccode\u003eprintf\u003c/code\u003e). Trong một số trường hợp xảy ra biên dịch gặp lỗi, đưa thêm thư viện \u003cstrong\u003ecstdio\u003c/strong\u003e (hoặc \u003cstrong\u003estdio.h\u003c/strong\u003e) vào đầu file.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eSử dụng câu lệnh sau ở đầu chương trình: \u003ccode\u003eios_base::sync_with_stdio(false);\u003c/code\u003e. Câu lệnh sẽ tắt việc đồng bộ hóa giữa lệnh input/output của C và C++, giúp các câu lệnh này hoạt động nhanh hơn rất nhiều. Cần lưu ý, sau khi đã khai báo lệnh này, mọi câu lệnh sử dụng hệ input/output của C (\u003ccode\u003escanf\u003c/code\u003e/\u003ccode\u003eprintf\u003c/code\u003e) sẽ gây lỗi Runtime Error tức thì.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eLời giải: \u003ca href\u003d\"https://ideone.com/Aq56Pz\"\u003eIdeone.com\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}