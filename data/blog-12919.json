{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1404333446,"rating":3,"authorHandle":"Kyuubi","modificationTimeSeconds":1404335347,"id":12919,"title":"\u003cp\u003eFinding Hash of Substring [i, j] in O(1) using O(|S|) pre computation\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eGiven a string S of length n characters, is it possible to calculate the Hash of its substring [i, j] (From index i to index j. Inclusive) in O(1) using some form of precomputation ? Maybe a modification of the Rolling Hash ?\u003c/p\u003e\u003ch1\u003eSimilar Problem\u003c/h1\u003e\u003cp\u003e\u003cstrong\u003eProblem Statement\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eI have seen it being used in a similar problem where in a string was given in a compressed form. Meaning, e.g. if the string is \u003ccode\u003e\u0026quot;aaabccdeeee\u0026quot;\u003c/code\u003e then the compressed form is:\u003c/p\u003e \u003cpre\u003e3 a\n1 b\n2 c\n1 d\n4 e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eHow data was stored\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThey are stored in an \u003ccode\u003estr[]\u003c/code\u003e array as : \u003c/p\u003e \u003cpre\u003estr[] \u003d [{\u0027a\u0027,\u00273\u0027}, {\u0027b\u0027,\u00271\u0027}, {\u0027c\u0027,\u00272\u0027}....]\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eHASHING Concept that was used in the solutions\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eAnd programmers had used the following hash concept to find if the given substring is a Palindrome or not. Given a substring of string S as (i,j), they computed the hash of substring \u003cstrong\u003e[i , (i+j)/2]\u003c/strong\u003e and the reverse hash of substring \u003cstrong\u003e[(i+j+2)/2, j]\u003c/strong\u003e and checked if they were equal or not. So if they wanted to check if in string \u003ccode\u003eS \u003d \u0026quot;daabac\u0026quot;\u003c/code\u003e whether substring \u003cem\u003e[1, 5]\u003c/em\u003e is a a palindrome or not, they computed the following :\u003c/p\u003e \u003cpre\u003eh1 \u003d forward_hash(\u0026quot;aa\u0026quot;) \nh2 \u003d reverse_hash(\u0026quot;ba\u0026quot;)\nh1 \u003d\u003d h2\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eCode for the Hashing Concept\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe hash precomputation was done as follows :\u003c/p\u003e \u003cpre\u003e/* Computing the Prefix Hash Table */\npre_hash[0] \u003d 0;\nfor(int i\u003d1;i\u0026lt;\u003dlen(str);i++)\n{\n    pre_hash[i] \u003d pre_hash[i-1]*very_large_prime + str[i].first;\n    pre_hash[i] \u003d pre_hash[i]*very_large_prime + str[i].second;\n}\n\n/* Computing the Suffix Hash Table */\nsuff_hash[0] \u003d 0;\nfor(int i\u003d1;i\u0026lt;\u003dlen(str);i++)\n{\n    suff_hash[i] \u003d suff_hash[i-1]*very_large_prime + str[len(str)-i+1].first;\n    suff_hash[i] \u003d suff_hash[i]*very_large_prime + str[len(str)-i+1].second;\n}\u003c/pre\u003e\u003cp\u003eAnd then the hash was computed using the following functions :\u003c/p\u003e \u003cpre\u003e/* Calculates the Forward hash of substring [i,j] */\nunsigned long long CalculateHash(int i, int j)\n{\n    if(i\u0026gt;j)\n        return -1;\n    unsigned long long ret \u003d pre_hash[j] - POW(very_large_prime, [2*(j-i+1)])*pre_hash[i-1];\n    return ret;\n}\n/* Calculates the reverse hash of substring [i,j] */\nunsigned long long CalculateHash_Reverse(int i, int j)\n{\n    unsigned long long ret \u003d suff_hash[j] - POW(very_large_prime,[2*(j-i+1)])*suff_hash[i-1];\n    return ret;\n}\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eWhat I am trying to do\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eI am looking for a general approach to the above concept. Given a Pattern P, I want to check if the pattern P is present in a string S. I know the index \u003ccode\u003e(i)\u003c/code\u003e to check where it may be present. And I also know the length of pattern P represented as \u003ccode\u003e|P|\u003c/code\u003e. In short I want to check if hash of \u003ccode\u003eS[i, i+|P|]\u003c/code\u003e and hash of \u003ccode\u003eP\u003c/code\u003e match or not in \u003ccode\u003eO(1)\u003c/code\u003e using some form of pre computation on \u003ccode\u003eS\u003c/code\u003e. Is it possible ?\u003c/p\u003e\u003cp\u003e\u003cem\u003eIgnoring the time taken to compute hash of P else it would be \u003ccode\u003eO(1+|P|)\u003c/code\u003e\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e","tags":["hashing","string","string match"]}}