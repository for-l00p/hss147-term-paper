{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1518650145,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1518652501,"id":57772,"title":"\u003cp\u003eМассивы: некоторые приёмы работы (FAQ + простой пример)\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eВ этой записи мы рассмотрим некоторые типичные приёмы работы с массивами, которые могут пригодиться в разных задачах. Ряд этих приёмов будет использован при решении простой задачи. Если вы уже знакомы с массивами, переходите сразу к п.9.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Как и где объявлять массив?\u003c/p\u003e\u003cp\u003eКак и любую другую переменную, массив можно объявить в классе (содержащем \u0026quot;логику\u0026quot;), а можно — внутри какого-либо метода. Если массив используется только внутри этого метода (например, в каких-то вспомогательных целях), то объявить его именно внутри метода, как правило, хорошая идея — когда метод завершит свою работу, память, связанная с этим массивом, будет автоматически очищена. Если же массив используется не в одном методе, то, разумеется, он должен быть объявлен как поле класса. \u003cbr /\u003e Объявление массива состоит из типа элементов массива, квадратных скобок (в количестве, соответствующем размерности массива), а также имени массива. Тип элемента может быть любым, в том числе массивом или объектным типом (например, \u003cem\u003eString\u003c/em\u003e). \u003c/p\u003e\u003cp\u003eПримеры объявления массивов:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint[] a; // одномерный массив целых чисел\ndouble[][] mx; // двумерный массив вещественных чисел\nboolean[] used; // одномерный массив логических значений\nString [] words; // одномерный массив строк\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e. Массив объявили, что делать потом?\u003c/p\u003e\u003cp\u003eОбъявление массива — это заявление о намерениях; прежде, чем к элементам массива можно будет обращаться, необходимо выделить для массива память. Если массив объявлен как поле класса, выделение памяти для него можно провести в конструкторе класса. Если же массив объявлен внутри метода, то все действия с массивом будут происходить только внутри этого метода, поэтому в дальнейшем мы не будем уточнять этот момент. \u003c/p\u003e\u003cp\u003eПримеры выделения памяти под массивы:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003emx \u003d new double[5][3]; // двумерный массив из 5 строк и 3 столбцов\n\nint n \u003d 10;\na \u003d new int[n]; // одномерный массив из 10 элементов\n\nused \u003d new boolean[a.length]; // одномерный массив логических значений, имеющий такую же длину, как и массив a\n\nwords \u003d new String[2*n]; // одномерный массив строк из 20 элементов\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e. Заполнение массива.\u003c/p\u003e\u003cp\u003eКогда под массив выделяется память, то он заполняется \u0026quot;нулевыми значениями\u0026quot; (в том смысле, в каком нулевые значения понимаются в данном типе). Если речь о целых или вещественных числах, то, конечно это \u0026quot;обычные\u0026quot; нули. Массивы логических значений при создании заполняются значением \u003cem\u003efalse\u003c/em\u003e, символьные (char) — символом с кодом \u003cem\u003e0\u003c/em\u003e. При решении задач этим фактом можно пользоваться. \u003c/p\u003e\u003cp\u003eРазумеется, достаточно типична ситуация, когда элементы массива вводятся (с клавиатуры или из файла). Вот, например, как будет выглядеть код для ситуации, когда задается количество элементов массива, после чего они считываются с клавиатуры.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eScanner in \u003d new Scanner(System.in);\nn \u003d in.nextInt();\na \u003d new int[n];\nfor (int i \u003d 0; i \u0026lt; n; i++){\n    a[i] \u003d in.nextInt();\n}\nin.close();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбратите внимание на следующие важные моменты: \u003cbr /\u003e - элементы массива нумеруются с 0; \u003cbr /\u003e - обращение к элементу массива выглядит так: \u003ccode\u003eимя переменной-массива [индекс]\u003c/code\u003e\u003c/p\u003e\u003cp\u003eВ случае двумерного целочисленного массива, например, состоящего из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e строк и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e столбцов, заполнение массива будет выглядеть так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eScanner in \u003d new Scanner(System.in);\nn \u003d in.nextInt();\nm \u003d in.nextInt();\nb \u003d new int[n][m];\nfor (int i \u003d 0; i \u0026lt; n; i++){\n    for (int j \u003d 0; j \u0026lt; m; j++){\n        b[i][j] \u003d in.nextInt();\n    }\n}\nin.close();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКонечно, здесь предполагается, что элементы массива вводятся построчно (т.е. сначала все элементы нулевой строки, затем все элементы первой строки и т.д.)\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e. Проход по массиву (если элементы меняются)\u003c/p\u003e\u003cp\u003eПредположим, что элементы массива должны каким-то образом меняться. Например, предположим, что мы хотим заполнить целочисленный массив \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e элементов числами Фибоначчи (мы считаем, что массив уже объявлен, память под него выделена, все элементы обнулены). \u003c/p\u003e\u003cp\u003eКак, вероятно, вы помните, числа Фибоначчи определяются следующим образом:\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c4/63/c4632b5ea2bd9f6124715991cb463625a954858b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eЭто несложно записать для массива:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ef[0] \u003d f[1] \u003d 1;\nfor (int i \u003d 2; i \u0026lt; n; i++){\n    f[i] \u003d f[i-1] + f[i-2];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбратите внимание: начальное значение переменной цикла — 2, поскольку элементы с индексами 0 и 1 получили значение до цикла.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e. Проход по массиву (без изменения элементов)\u003c/p\u003e\u003cp\u003eПредположим, что нам нужно посчитать, сколько раз в целочисленном массиве \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e длины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e встречается некоторое целое число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e (мы опять же считаем, что все объявления сделаны, память выделена, после чего массив \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e был заполнен). Будем сохранять результат в целочисленной переменной \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint q \u003d 0; \nfor (int elem: a) {\n    if (elem \u003d\u003d b) {\n        q++;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбратите внимание: мы воспользовались специальной формой цикла \u003ccode\u003efor\u003c/code\u003e (эта форма может применяться и к \u003cem\u003eколлекциям\u003c/em\u003e, которые пока не стали предметом нашего рассмотрения). Общий вид \u0026quot;заголовка\u0026quot; такой формы: \u003ccode\u003efor (тип_элемента_массива имя_переменной: имя_массива)\u003c/code\u003e. \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e6\u003c/span\u003e. Вывод элементов массива\u003c/p\u003e\u003cp\u003eВ некоторых задачах требуется преобразовать массив каким-либо образом и вывести результат. Предположим, что нам надо вывести в одну строчку через пробел подряд все элементы одномерного массива \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e длины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Это можно сделать следующим образом:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eboolean first \u003d true;\nfor (int elem: a){\n    if (first) {\n        first \u003d false;\n    }\n    else {\n        System.out.print(\u0027 \u0027);\n    }\n    System.out.print(elem);\n}\nSystem.out.println();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбратите внимание на переменную \u003ccode\u003efirst\u003c/code\u003e. Её задача — обеспечить аккуратный (без лишних пробелов) вывод всех элементов массива. При входе в цикл переменная \u003ccode\u003efirst\u003c/code\u003e имеет значение \u003ccode\u003etrue\u003c/code\u003e, поэтому в соответствующей ветви оператора \u003ccode\u003eif\u003c/code\u003e внутри цикла происходит замена значения \u003ccode\u003efirst\u003c/code\u003e c \u003ccode\u003etrue\u003c/code\u003e на \u003ccode\u003efalse\u003c/code\u003e. На этом выполнение \u003ccode\u003eif\u003c/code\u003e завершается, после чего печатается первый (нулевой) элемент. \u003c/p\u003e\u003cp\u003eНа всех последующих итерациях цикла переменная \u003ccode\u003efirst\u003c/code\u003e имеет значение \u003ccode\u003efalse\u003c/code\u003e, что приводит к печати пробела перед очередным элементом. \u003c/p\u003e\u003cp\u003eНаконец, после цикла стоит вызов \u003ccode\u003eprintln()\u003c/code\u003e, приводящий к переводу строки (это бывает оправданно в некоторых случаях; в том числе при написании соревнований).\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e7\u003c/span\u003e. Существует полезный класс \u003ccode\u003eArrays\u003c/code\u003e, в котором определён ряд статических методов, решающих некоторые типичные при работе с массивами задачи. Настоятельно рекомендуется изучить список его методов (впоследствии мы познакомимся ещё с классом \u003ccode\u003eCollections\u003c/code\u003e, имеющим более широкий набор методов).\u003c/p\u003e\u003cp\u003eКратко скажем о некоторых методах.\u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003eArrays.fill()\u003c/code\u003e может заполнить массив или его часть некоторым заданным значением. При создании все массивы заполняются \u0026quot;нулями\u0026quot; (в смысле их типа данных), иногда же нужно другое.\u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003eArrays.copyOf()\u003c/code\u003e копирует один массив в другой, при необходимости обрезая копируемый или, напротив, дополняя его \u0026quot;нулями\u0026quot;. Метод \u003ccode\u003eArrays.copyOfRange()\u003c/code\u003e делает по сути то же самое, только может копировать массив не целиком, а фрагментом.\u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003eArrays.sort()\u003c/code\u003e сортирует массив так, чтобы его элементы находились в \u0026quot;естественном порядке\u0026quot; (для чисел — по неубыванию, для строк — в лексикографическом порядке). \u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003eArrays.binarySearch()\u003c/code\u003e отыскивает в \u003cem\u003eотсортированном\u003c/em\u003e массиве заданный элемент. Если элемент найден, в качестве результата метода сообщается номер этого элемента, причём если таких элементов несколько, то номер какого из них окажется результатом — неизвестно. Если же элемента в массиве нет, в качестве результата возвращается \u003cspan class\u003d\"tex-span\"\u003e( - (\u003ci\u003einsertionpoint\u003c/i\u003e) - 1)\u003c/span\u003e (в обозначениях документации), где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003einsertionpoint\u003c/i\u003e\u003c/span\u003e — позиция, в которую был бы помещён искомый элемент, если бы мы захотели его вставить в этот массив; де-факто — номер первого элемента, который больше искомого. \u003cbr /\u003e Заметим, что бинарный поиск можно проводить не в целом массиве, а в некотором его подмассиве.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e8\u003c/span\u003e. Если есть вопросы, как сделать какую-то \u0026quot;типичную\u0026quot; операцию с элементами массива — задавайте, пожалуйста, вопросы (в комментариях, в ЛС); по итогам ответов на них, возможно, запись будет обновлена.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e9\u003c/span\u003e. Задачи для отработки простой техники:\u003c/p\u003e\u003cp\u003eТренировка по одномерным массивам (\u003ca href\u003d\"//codeforces.com/group/NSNjESJZns/contest/101730\"\u003eссылка\u003c/a\u003e)\u003c/p\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e10\u003c/span\u003e. \u003cstrong\u003eПример решения задачи\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eЭта задача очень похожа на первую задачу из тренировки. Чтобы сдать задачу в тренировке, потребуются очень небольшие изменения в коде.\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eЗадача \u0026quot;Зачёт\u0026quot;\u003c/em\u003e\u003c/p\u003e\u003cp\u003eГруппа, в которой учится Евлампий, сегодня будет сдавать зачёт. На зачёт будет вынесено \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e задач, занумерованных числами от \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Зачёт продлится \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e минут.\u003c/p\u003e\u003cp\u003eЕвлампий хорошо решает задачи и уверен, что сдаст зачёт. Для каждой задачи \u003cspan class\u003d\"tex-span\"\u003e(#\u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e известно время \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, за которое Евлампий решит эту задачу. \u003c/p\u003e\u003cp\u003eОбычно Евлампий решает задачи подряд, не пропуская ни одной, двигаясь либо \u0026quot;от начала к концу\u0026quot;, либо \u0026quot;от конца к началу\u0026quot;. Сейчас он размышляет, какое \u0026quot;направление\u0026quot; ему следует выбрать, если он хочет решить побольше задач. Учитываться будут только задачи, которые Евлампий решит полностью за отведённое на зачёт время.\u003c/p\u003e\u003cp\u003eВаша задача — определить, следует ли Евлампию решать задачи от начала к концу или же от конца к началу, а также подсчитать, какое количество задач он решит.\u003c/p\u003e\u003cp\u003e\u003cem\u003eВходные данные\u003c/em\u003e\u003c/p\u003e\u003cp\u003eВ первой строке содержатся целые числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(1 ≤ \u003ci\u003en\u003c/i\u003e ≤ 3·10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e,  1 ≤ \u003ci\u003et\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e)\u003c/span\u003e — количество задач и общее время, которое отводится на их решение.\u003c/p\u003e\u003cp\u003eВо второй строке содержатся целые числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(1 ≤ \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e,  \u003ci\u003ej\u003c/i\u003e \u003d 1, 2, ..., \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — время, за которое Евлампий решает задачу \u003cspan class\u003d\"tex-span\"\u003e#\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cem\u003eВыходные данные\u003c/em\u003e\u003c/p\u003e\u003cp\u003eВ первой строке выведите \u003ccode\u003eLeft To Right\u003c/code\u003e, если Евлампию следует решать задачи, двигаясь от начала к концу, и \u003ccode\u003eRight to Left\u003c/code\u003e, если Евлампию следует решать задачи, двигаясь от конца к началу.\u003c/p\u003e\u003cp\u003eВо второй строке выведите, сколько задач он при этом решит.\u003c/p\u003e\u003cp\u003eЕсли существует несколько вариантов ответа, выведите любой.\u003c/p\u003e\u003cp\u003e\u003cem\u003eРешение\u003c/em\u003e\u003c/p\u003e\u003cp\u003eПоясним, почему в этой задаче удобно использовать массив. Если бы Евлампий решал задачи только в направлении \u0026quot;от начала к концу\u0026quot;, то мы могли бы провести все вычисления при чтении данных. Однако у нас есть вторая стратегия Евлампия — решать задачи в направлении \u0026quot;от конца к началу\u0026quot;. И вот для её реализации как раз удобно будет пройти по уже сохранённым данным в обратном направлении.\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Знатоки могут заметить, что для \u0026quot;переворота\u0026quot; массива можно было бы использовать рекурсию — но по своей сути она приводит лишь к \u0026quot;скрытому\u0026quot; использованию массива: все данные будут храниться в стеке. Так что сэкономить на памяти не получится, рекурсия израсходует её больше, поскольку на каждый вызов функции потребуется хранить в стеке не только данные, а запись активации. Так что лучше использовать простую структуру данных. \u003c/small\u003e\u003c/p\u003e\u003cp\u003eТакже обратите внимание, что данные в нашей задаче позволяют обойтись использованием только переменных типа \u003ccode\u003eint\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eИтак, наша задача разбивается на четыре больших шага. Во-первых, нам нужно прочитать данные и сохранить их в массиве. Во-вторых, нужно посчитать, сколько задач решит Евлампий, если будет решать их \u0026quot;от начала к концу\u0026quot;. В-третьих, нужно посчитать, сколько задач решит Евлампий, если будет решать их \u0026quot;от конца к началу\u0026quot;. В-четвёртых, понадобится сравнить два полученных числа, выбрать из них большее и вывести ответ. \u003c/p\u003e\u003cp\u003eПервый шаг проблем вызвать не должен. Поэтому сразу запишем достаточно большой фрагмент кода. В нём описан и запускающий класс \u003ccode\u003eTwoDirections\u003c/code\u003e, и класс \u0027ManyProblems`, в котором будет содержаться \u0026quot;логика\u0026quot; решения. Чтение данных выполним в конструкторе класса, содержащего \u0026quot;логику\u0026quot;.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport java.util.Scanner;\n\npublic class TwoDirections {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass ManyProblems {\n\t\n\tManyProblems() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tt \u003d in.nextInt();\n\t\t\n\t\tp \u003d new int[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\t\tp[i] \u003d in.nextInt();\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\n\tString answer;\n\tint ans;\t\n\n\tint n;\n\tint t;\n\tint[] p;\n\t\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ классе \u003ccode\u003eManyProblems\u003c/code\u003e мы описали переменные \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e (названия взяты из условия), а также переменные для хранения ответа — строковая \u003ccode\u003eanswer\u003c/code\u003e и целочисленная \u003ccode\u003eans\u003c/code\u003e (для количества задач). Также мы организовали чтение переменных \u003ccode\u003en\u003c/code\u003e, \u003ccode\u003et\u003c/code\u003e и \u003ccode\u003ep\u003c/code\u003e в конструкторе. Как несложно видеть, основной фрагмент кода очень похож на тот, что был приведён выше в п.3.\u003c/p\u003e\u003cp\u003eПодсчёт количества задач в двух разных направлениях оформим в виде двух функций, возвращающих соответствующие целочисленные значения. Начнём с функции, которая посчитает количество задач, решённых Евлампием при движении \u0026quot;от начала к концу\u0026quot;.\u003c/p\u003e\u003cp\u003eПриведём код этой функции (\u0026quot;общий вид\u0026quot; программы будет показан ниже).\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tint leftToRight() {\n\t\tint idx \u003d 0;\t\t\n\t\tint currentTime \u003d 0;\n\t\t\n\t\twhile ((idx \u0026lt; n) \u0026amp;\u0026amp; (currentTime + p[idx] \u0026lt;\u003d t)) {\n\t\t\tcurrentTime +\u003d p[idx++];\n\t\t}\n\t\t\n\t\treturn idx;\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПоясним этот код.\u003c/p\u003e\u003cp\u003eПеременная \u003ccode\u003eidx\u003c/code\u003e отвечает за номер очередной рассматриваемой задачи, переменная \u003ccode\u003ecurrentTime\u003c/code\u003e хранит в себе время, которое уже затрачено на решение задач. \u003c/p\u003e\u003cp\u003eЦикл \u003ccode\u003ewhile\u003c/code\u003e следует читать так: \u0026quot;пока имеются задачи и пока остающееся до истечения \u003ccode\u003et\u003c/code\u003e время позволяет решить очередную задачу, увеличим затраченное время на время, за которое мы решим очередную задачу, и перейдём к следующей\u0026quot;.\u003c/p\u003e\u003cp\u003eА теперь более подробно разберём это предложение. \u003c/p\u003e\u003cp\u003eУсловие \u003ccode\u003eidx \u0026lt; n\u003c/code\u003e поставлено в \u003ccode\u003ewhile\u003c/code\u003e первым, поскольку мы для начала должны проверить, что нерешённые задачи ещё остались. Действительно, нельзя исключить вариант, что Евлампий решит вообще все задачи ещё до истечения времени \u003ccode\u003et\u003c/code\u003e. Это значит, что переменная \u003ccode\u003eidx\u003c/code\u003e примет значение \u003ccode\u003en\u003c/code\u003e, и попытка обратиться к элементу массива с таким индексом приведёт к ошибке. Если же условие, контролирующее индекс, записано первым и соединено со следующим условием с помощью \u0026quot;ленивого И\u0026quot;, то следующее условие будет выполняться тогда и только тогда, когда индекс будет корректным. \u003c/p\u003e\u003cp\u003eУсловие \u003ccode\u003ecurrentTime + p[idx] \u0026lt;\u003d t\u003c/code\u003e позволяет проверить, что задача \u003cspan class\u003d\"tex-span\"\u003e#\u003ci\u003eidx\u003c/i\u003e\u003c/span\u003e будет решена до истечения времени \u003ccode\u003et\u003c/code\u003e. Типичная ошибка в подобных задачах состоит в том, что выполняется проверка \u003ccode\u003ecurrentTime \u0026lt;\u003d t\u003c/code\u003e, которая лишь гарантирует, что уже потраченное время не превышает отведённого на зачёт, но никак не проверяет, что очередная задача может быть решена до истечения времени, отведённого на зачёт.\u003c/p\u003e\u003cp\u003eОператор \u003ccode\u003ecurrentTime +\u003d p[idx++]\u003c/code\u003e можно было бы записать развёрнуто следующим образом:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    currentTime \u003d currentTime + p[idx];\n    idx++;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ коде же использована сокращённая форма оператора сложения \u003ccode\u003e+\u003d\u003c/code\u003e, а также постфиксный инкремент. Напомним, что постфиксный инкремент выполняется \u003cstrong\u003eпосле\u003c/strong\u003e вычисления выражения. \u003c/p\u003e\u003cp\u003eНаконец, заметим, что номер первой нерешённой задачи совпадает с количеством решённых задач (поскольку нумерация элементов в массиве начинается с нуля). Поэтому мы могли не вводить какую-либо дополнительную переменную для учёта количества задач, а воспользоваться индексом. \u003c/p\u003e\u003cp\u003eТеперь напишем функцию, вычисляющую, сколько задач решит Евлампий, двигаясь \u0026quot;от конца к началу\u0026quot;. Также сначала приведём код этой функции, а потом прокомментируем его.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tint rightToLeft() {\n\t\tint res \u003d 0; \n\t\tint currentTime \u003d 0;\n\t\t\n\t\tfor (int i \u003d n-1; i \u0026gt;\u003d 0; i--) {\n\t\t\tif (currentTime + p[i] \u0026lt;\u003d t) {\n\t\t\t\tcurrentTime +\u003d p[i];\n\t\t\t\tres++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПеременная \u003ccode\u003eres\u003c/code\u003e использована для хранения количества решённых задач. Конечно, можно было вычислить её через индекс первой нерешённой задачи, однако здесь мы использовали цикл \u003ccode\u003efor\u003c/code\u003e для прохода по массиву, и такой подход к вычислению количества оказался бы чуть менее удобным. \u003c/p\u003e\u003cp\u003eПеременная \u003ccode\u003ecurrentTime\u003c/code\u003e, как и в функции \u003ccode\u003eleftToRight()\u003c/code\u003e, хранит уже потраченное на решение задач время. На всякий случай напомним, что у каждой функции своё пространство имён, и переменные, описанные в одной функции, не имеют отношения к переменным, описанным в другой функции. Каждая из переменных \u003ccode\u003ecurrentTime\u003c/code\u003e \u0026quot;действует\u0026quot; только в \u0026quot;границах\u0026quot; своей функции.\u003c/p\u003e\u003cp\u003eЦикл \u003ccode\u003efor\u003c/code\u003e проходит по элементам массива, начиная с элемента \u003cspan class\u003d\"tex-span\"\u003e#(\u003ci\u003en\u003c/i\u003e - 1)\u003c/span\u003e (последнего) и движется к элементу \u003cspan class\u003d\"tex-span\"\u003e#0\u003c/span\u003e. Уменьшение индекса обеспечивается в секции итерации цикла. В теле цикла каждый раз выполняется проверка, удастся ли Евлампию решить очередную задачу \u003cspan class\u003d\"tex-span\"\u003e#\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, уложившись в отведённое время \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e. Если эта проверка дала положительный ответ, то увеличивается и время, затраченное на решение задач, и их количество. Если же проверка приводит к отрицательному результату, то цикл прерывается при помощи оператора \u003ccode\u003ebreak\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eУсловие в операторе \u003ccode\u003eif\u003c/code\u003e практически не отличается от условия в \u003ccode\u003ewhile\u003c/code\u003e в функции \u003ccode\u003eleftToRight()\u003c/code\u003e, и, наверное, уже не требует дополнительных пояснений. А вот оператор \u003ccode\u003ebreak\u003c/code\u003e гарантирует, что Евлампий будет решать задачи подряд. Действительно, предположим, что у нас имеются следующие входные данные:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e5 45\n15 5 10 20 20\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТогда при движении от конца к началу Евлампий решит пятую и четвёртую задачи, потратив на каждую по 20 минут (итого 40 минут), после чего попытается решить третью задачу, на решение которой ему требуется 10 минут. Как понятно, \u003cspan class\u003d\"tex-span\"\u003e40 + 10 \u0026gt; 45\u003c/span\u003e, и проверка условия в цикле даст отрицательный результат. Если оператора \u003ccode\u003ebreak\u003c/code\u003e не будет, то цикл продолжит выполняться, и очередной задачей станет задача \u003cspan class\u003d\"tex-span\"\u003e#2\u003c/span\u003e, с решением которой Евлампий может справиться за 5 минут. Проверка даст положительный результат, и мы получим неправильный ответ 3 вместо 2.\u003c/p\u003e\u003cp\u003eФункции \u003ccode\u003eleftToRight()\u003c/code\u003e и \u003ccode\u003erightToLeft()\u003c/code\u003e будут вызываться в методе \u003ccode\u003esolve()\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tvoid solve() {\n\t\tanswer \u003d \u0026quot;Left to Right\u0026quot;;\n\t\tans \u003d leftToRight();\n\t\tint b \u003d rightToLeft();\n\t\tif (b \u0026gt; ans) {\n\t\t\tans \u003d b;\n\t\t\tanswer \u003d \u0026quot;Right to Left\u0026quot;;\n\t\t}\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eБолее подробно, в этом методе происходит следующее. Сначала в переменную \u003ccode\u003eanswer\u003c/code\u003e заносится значение \u0026quot;Left to Right\u0026quot;, а в переменную \u003ccode\u003eans\u003c/code\u003e — результат вычисления функции \u003ccode\u003eleftToRight()\u003c/code\u003e. Затем в переменную \u003ccode\u003eb\u003c/code\u003e (локальную для \u003ccode\u003esolve()\u003c/code\u003e) записывается результат вычисления функции \u003ccode\u003erightToLeft()\u003c/code\u003e. Если это значение окажется больше, чем текущее значение \u003ccode\u003eans\u003c/code\u003e, нам придётся изменить и значение \u003ccode\u003eans\u003c/code\u003e, и значение \u003ccode\u003eanswer\u003c/code\u003e (в противном случае изменений не потребуется). \u003c/p\u003e\u003cp\u003eОбратите внимание, что в случае равенства количества задач при решении \u0026quot;от начала к концу\u0026quot; и \u0026quot;от конца к началу\u0026quot;, написанная программа выберет первый вариант. Если в операторе \u003ccode\u003eif\u003c/code\u003e заменить знак \u003ccode\u003e\u0026gt;\u003c/code\u003e на \u003ccode\u003e\u0026gt;\u003d\u003c/code\u003e, то при равенстве будет выбран второй вариант. Впрочем, по условию задачи это не имеет значения. \u003c/p\u003e\u003cp\u003eТеперь осталось вывести ответ и дописать метод \u003ccode\u003emain()\u003c/code\u003e в запускающем классе. Приведём окончательный код программы.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport java.util.Scanner;\n\npublic class TwoDirections {\n\n\tpublic static void main(String[] args) {\n\t\tManyProblems mp \u003d new ManyProblems();\n\t\tmp.solve();\n\t\tmp.print();\n\t}\n\n}\n\nclass ManyProblems {\n\t\n\tManyProblems() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tt \u003d in.nextInt();\n\t\t\n\t\tp \u003d new int[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\t\tp[i] \u003d in.nextInt();\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tint leftToRight() {\n\t\tint idx \u003d 0;\t\t\n\t\tint currentTime \u003d 0;\n\t\t\n\t\twhile ((idx \u0026lt; n) \u0026amp;\u0026amp; (currentTime + p[idx] \u0026lt;\u003d t)) {\n\t\t\tcurrentTime +\u003d p[idx++];\n\t\t}\n\t\t\n\t\treturn idx;\n\t}\n\t\n\tint rightToLeft() {\n\t\tint res \u003d 0; \n\t\tint currentTime \u003d 0;\n\t\t\n\t\tfor (int i \u003d n-1; i \u0026gt;\u003d 0; i--) {\n\t\t\tif (currentTime + p[i] \u0026lt;\u003d t) {\n\t\t\t\tcurrentTime +\u003d p[i];\n\t\t\t\tres++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\t\n\tvoid solve() {\n\t\tanswer \u003d \u0026quot;Left to Right\u0026quot;;\n\t\tans \u003d leftToRight();\n\t\tint b \u003d rightToLeft();\n\t\tif (b \u0026gt; ans) {\n\t\t\tans \u003d b;\n\t\t\tanswer \u003d \u0026quot;Right to Left\u0026quot;;\n\t\t}\n\t}\n\t\n\tvoid print() {\n\t\tSystem.out.println(answer);\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tString answer;\n\tint ans;\n\t\n\tint n;\n\tint t;\n\tint[] p;\n\t\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПротестируйте программу на следующих примерах:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e5 45\n15 10 5 20 20\n\u003c/code\u003e\u003c/pre\u003e \u003cpre\u003e\u003ccode\u003e5 45\n15 5 10 20 20\n\u003c/code\u003e\u003c/pre\u003e \u003cpre\u003e\u003ccode\u003e5 45\n15 5 20 5 20\n\u003c/code\u003e\u003c/pre\u003e \u003cpre\u003e\u003ccode\u003e2 40\n45 35\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПредложите свои примеры тестов и поясните, что именно они должны проверить.\u003c/p\u003e\u003c/div\u003e","tags":["java","arrays"]}}