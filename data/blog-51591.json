{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1492341281,"rating":34,"authorHandle":"RussianCodeCup","modificationTimeSeconds":1492341319,"id":51591,"title":"\u003cp\u003eRussian Code Cup Qual 2 — Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eA. Very Important Persons\u003c/h2\u003e\u003cp\u003eThere are two main ways to solve the problem.\u003c/p\u003e\u003cp\u003eThe first way is to assign guests to seats by diagonals, starting from the seat (1, 1). You should be careful with considering cases \u003ci\u003en\u003c/i\u003e \u0026lt; \u003ci\u003em\u003c/i\u003e and \u003ci\u003em\u003c/i\u003e \u0026lt; \u003ci\u003en\u003c/i\u003e when implementing traversal. \u003c/p\u003e\u003cp\u003eThe second way is a more common solution which however requires more advanced algorithm. Let us run BFS from (1, 1) and assign seats to guests in order they are popped from the queue, starting from the most important one.\u003c/p\u003e\u003ch2\u003eB. Least Common Multiple\u003c/h2\u003e \u003cp\u003eLet \u003ci\u003ep\u003c/i\u003e / \u003ci\u003eq\u003c/i\u003e be divisible by both \u003ci\u003ea\u003c/i\u003e / \u003ci\u003eb\u003c/i\u003e and \u003ci\u003ec\u003c/i\u003e / \u003ci\u003ed\u003c/i\u003e, all fractions are irreducible. So the numbers (\u003ci\u003ep\u003c/i\u003e / \u003ci\u003eq\u003c/i\u003e): (\u003ci\u003ea\u003c/i\u003e / \u003ci\u003eb\u003c/i\u003e) \u003d (\u003ci\u003ep\u003c/i\u003e·\u003ci\u003eb\u003c/i\u003e) / (\u003ci\u003eq\u003c/i\u003e·\u003ci\u003ea\u003c/i\u003e) and (\u003ci\u003ep\u003c/i\u003e / \u003ci\u003eq\u003c/i\u003e): (\u003ci\u003ec\u003c/i\u003e / \u003ci\u003ed\u003c/i\u003e) \u003d (\u003ci\u003ep\u003c/i\u003e·\u003ci\u003ed\u003c/i\u003e) / (\u003ci\u003eq\u003c/i\u003e·\u003ci\u003ec\u003c/i\u003e) are integers.\u003c/p\u003e\u003cp\u003eSince \u003ci\u003ep\u003c/i\u003e·\u003ci\u003eb\u003c/i\u003e is divisible by \u003ci\u003eq\u003c/i\u003e·\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e and \u003ci\u003ea\u003c/i\u003e are relatively prime, then \u003ci\u003ep\u003c/i\u003e is divisible by \u003ci\u003ea\u003c/i\u003e. \u003ci\u003ep\u003c/i\u003e and \u003ci\u003eq\u003c/i\u003e are also relatively prime, so \u003ci\u003eb\u003c/i\u003e is divisible by \u003ci\u003eq\u003c/i\u003e. Similar argument allows to conclude that \u003ci\u003ep\u003c/i\u003e is divisible by \u003ci\u003eс\u003c/i\u003e, and \u003ci\u003ed\u003c/i\u003e is divisible by \u003ci\u003eq\u003c/i\u003e.\u003c/p\u003e\u003cp\u003eTherefore \u003ci\u003ep\u003c/i\u003e is divisible by \u003ci\u003elcm\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e), \u003ci\u003eq\u003c/i\u003e is a divisor of \u003ci\u003egcd\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e, \u003ci\u003ed\u003c/i\u003e). The fraction \u003ci\u003elcm\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e) / \u003ci\u003egcd\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e, \u003ci\u003ed\u003c/i\u003e) is divisible by both \u003ci\u003ea\u003c/i\u003e / \u003ci\u003eb\u003c/i\u003e and \u003ci\u003ec\u003c/i\u003e / \u003ci\u003ed\u003c/i\u003e, and is therefore the smallest such fraction. So the answer is \u003ci\u003elcm\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e) / \u003ci\u003egcd\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e, \u003ci\u003ed\u003c/i\u003e).\u003c/p\u003e\u003ch2\u003eC. Bad Order\u003c/h2\u003e \u003cp\u003eYou have to add numbers to the given array to convert it to a permutation that requires maximal number of swaps when being sorted by selection sort.\u003c/p\u003e\u003cp\u003eFirst suppose that the permutation is fixed. Let us find the number of swaps that selection sort makes. Consider permutation as a set of cycles. Let us consider a cycle that contains the minimal number that occupies wrong position. Length of this cycle is greater than 1. After we make a swap, it is split to two cycles: of length 1, and 1 shorter than its initial length. Therefore the cycle of length \u003ci\u003eL\u003c/i\u003e will be split \u003ci\u003eL\u003c/i\u003e - 1 times, so the number of swaps required is \u003ci\u003en\u003c/i\u003e - \u003ci\u003ec\u003c/i\u003e, where \u003ci\u003ec\u003c/i\u003e is the number of cycles.\u003c/p\u003e\u003cp\u003eTherefore we must add numbers to the given array in such way that the number of cycles in the resulting permutation was minimal possible. To do it consider the given array as a directed graph, if \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d \u003ci\u003ej\u003c/i\u003e, add an edge from \u003ci\u003ei\u003c/i\u003e to \u003ci\u003ej\u003c/i\u003e. The graph is a union of cycles and paths. All cycles in the graph will remain there after we convert the array to a permutation. All paths can be concatenated to a single long cycle (vertices without both incoming and outgoing edges are considered paths of length 0). To do so, order paths arbitrarily, and add an edge from the end of each path to the beginning of the next path. Finally make them a single cycle by adding an edge from the end of the last path to the beginning of the first one.\u003c/p\u003e\u003ch2\u003eD. Red-Black Tree\u003c/h2\u003e \u003cp\u003eFirst you must notice a subtle hint in the first sentence of the statement. It is easy to prove (or find in any data structures textbook) that red-black tree with \u003ci\u003en\u003c/i\u003e vertices has \u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)) black vertices on any path from the root to a leaf. Let us use this fact in our solution.\u003c/p\u003e\u003cp\u003eLet us call a tree almost red-black if its coloring satisfies all constraints of the red-black tree, except that its root is red.\u003c/p\u003e\u003cp\u003eWe can now use dynamic programming to calculate for each subtree the number of ways to color it to become red-black or almost red-black, and to have the number of black vertices on any path from its root to a leaf equal to \u003ci\u003eh\u003c/i\u003e.\u003c/p\u003e\u003cp\u003eLet us denote the described number of ways as \u003ci\u003ed\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e][\u003ci\u003eh\u003c/i\u003e][\u003ci\u003et\u003c/i\u003e], here \u003ci\u003ev\u003c/i\u003e is the vertex, \u003ci\u003eh\u003c/i\u003e is the number of black vertices on any path from \u003ci\u003ev\u003c/i\u003e to a leaf in its subtree, \u003ci\u003et\u003c/i\u003e is the type of coloring, \u003ci\u003et\u003c/i\u003e equal to 0 would, for example, mean that the subtree is red-black, and \u003ci\u003et\u003c/i\u003e equal 1 would mean that the subtree is almost red-black.\u003c/p\u003e\u003cp\u003eNow \u003ci\u003ed\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e][\u003ci\u003eh\u003c/i\u003e][0] is the product for all \u003ci\u003eu\u003c/i\u003e children of \u003ci\u003ev\u003c/i\u003e of values (\u003ci\u003ed\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][\u003ci\u003eh\u003c/i\u003e - 1][0] + \u003ci\u003ed\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][\u003ci\u003eh\u003c/i\u003e - 1][1]). Similarly, \u003ci\u003ed\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e][\u003ci\u003eh\u003c/i\u003e][1] is the product for all \u003ci\u003eu\u003c/i\u003e children of \u003ci\u003ev\u003c/i\u003e of values \u003ci\u003ed\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e][\u003ci\u003eh\u003c/i\u003e][0].\u003c/p\u003e\u003cp\u003eThe answer to the problem is the sum for all \u003ci\u003eh\u003c/i\u003e of values \u003ci\u003ed\u003c/i\u003e[1][\u003ci\u003eh\u003c/i\u003e][0].\u003c/p\u003e\u003cp\u003eSince \u003ci\u003eh\u003c/i\u003e for all valid colorings is limited by \u003ci\u003eC\u003c/i\u003e \u003d \u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)), we can consider the number of colorings be zero if \u003ci\u003eh\u003c/i\u003e \u0026gt; \u003ci\u003eC\u003c/i\u003e.\u003c/p\u003e\u003cp\u003eSo we only need \u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)) states, and \u003ci\u003eO\u003c/i\u003e(1) to calculate the result for each state. The time complexity is \u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)).\u003c/p\u003e\u003ch2\u003eE. Array Study\u003c/h2\u003e \u003cp\u003eSince there are the same constrains to \u003ci\u003en\u003c/i\u003e and \u003ci\u003eq\u003c/i\u003e, let us use \u003ci\u003en\u003c/i\u003e instead of \u003ci\u003emax\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003eq\u003c/i\u003e). Let us make some observations. \u003c/p\u003e\u003cp\u003eObservation one: the answer to the query is the maximal length of [\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e], such that \u003ci\u003epref\u003c/i\u003e\u003csub\u003e\u003ci\u003eL\u003c/i\u003e - 1\u003c/sub\u003e \u003d \u003ci\u003epref\u003c/i\u003e\u003csub\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e, where \u003ci\u003epref\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e + ... + \u003ci\u003ea\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e is the prefix sum of the given array. Let us move from the initial array to the array of prefix sums and for a query [\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e] look for the longest subarray of [\u003ci\u003el\u003c/i\u003e - 1, \u003ci\u003er\u003c/i\u003e] such that \u003ci\u003epref\u003c/i\u003e\u003csub\u003e\u003ci\u003eL\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003epref\u003c/i\u003e\u003csub\u003e\u003ci\u003eR\u003c/i\u003e\u003c/sub\u003e.\u003c/p\u003e\u003cp\u003eObservation two: \u003ci\u003epref\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e are quite small ( - \u003ci\u003en\u003c/i\u003e ≤ \u003ci\u003epref\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003en\u003c/i\u003e).\u003c/p\u003e\u003cp\u003eLet us make use of queries given offline. Our method will be similar to Mo\u0027s algorithm. Split all queries to groups, the \u003ci\u003ei\u003c/i\u003e-th group will contain queries [\u003ci\u003el\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003er\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e] such that \u003ci\u003ei\u003c/i\u003e·\u003ci\u003eK\u003c/i\u003e ≤ \u003ci\u003el\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u0026lt; (\u003ci\u003ei\u003c/i\u003e + 1)·\u003ci\u003eK\u003c/i\u003e (here \u003ci\u003eK\u003c/i\u003e is approximately \u003ci\u003esqrt\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)). In each group sort queries by their right end. Let us solve the problem separately for each group.\u003c/p\u003e\u003cp\u003eConsider the \u003ci\u003ei\u003c/i\u003e-th group, where \u003ci\u003el\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e is in [\u003ci\u003eL\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eR\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e]. Let us consider queries by non-decreasing of \u003ci\u003er\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, and maintain two arrays: \u003ci\u003emostLeft\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e] and \u003ci\u003emostRight\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e] — the first after \u003ci\u003eR\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e and the last before \u003ci\u003er\u003c/i\u003e occurrence of the prefix sum \u003ci\u003ep\u003c/i\u003e. Using these two values, we can find the answer that is subarray of [\u003ci\u003eR\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + 1, \u003ci\u003er\u003c/i\u003e]. To get the complete answer to [\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e] query, let us calculate the answer with the beginning of the required subarray at [\u003ci\u003el\u003c/i\u003e, \u003ci\u003emin\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)] using \u003ci\u003emostRight\u003c/i\u003e array, and take maximum of that value and the optimal subarray for [\u003ci\u003eR\u003c/i\u003e + 1, \u003ci\u003er\u003c/i\u003e].\u003c/p\u003e\u003cp\u003eSo it takes \u003ci\u003eO\u003c/i\u003e(\u003ci\u003eK\u003c/i\u003e·\u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003en\u003c/i\u003e) to answer all queries of one group, here \u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e is the number of queries in that group. Adding up all \u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e / \u003ci\u003eK\u003c/i\u003e) groups, we get the total time complexity \u003ci\u003eO\u003c/i\u003e(\u003ci\u003esum\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e \u003d 1... \u003ci\u003en\u003c/i\u003e / \u003ci\u003eK\u003c/i\u003e: \u003ci\u003eK\u003c/i\u003e·\u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003en\u003c/i\u003e)) \u003d \u003ci\u003eO\u003c/i\u003e(\u003ci\u003eK\u003c/i\u003e·\u003ci\u003esum\u003c/i\u003e(\u003ci\u003ec\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e) + \u003ci\u003en\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e / \u003ci\u003eK\u003c/i\u003e). Setting \u003ci\u003eK\u003c/i\u003e \u003d \u003ci\u003esqrt\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e) we get \u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e·\u003ci\u003esqrt\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)) complexity.\u003c/p\u003e\u003c/div\u003e","tags":[]}}