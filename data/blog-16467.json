{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1424201937,"rating":33,"authorHandle":"rafael859","modificationTimeSeconds":1424271675,"id":16467,"title":"\u003cp\u003eI came up with a nice little problem on computational complexity\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA well-known problem is, given a prime number P, find the next smallest prime number. An algorithm to solve this is to go to P+1, check if it\u0027s prime by checking the divisibility of all numbers from 2 up to floor(sqrt(P+1)) (Because all prime divisors of a number will be smaller or equal to it\u0027s square root), then check the same for P+2, P+3 and so on, until a prime number is found. Prove that the complexity of this algorithm is O(P).\u003c/p\u003e\u003cp\u003eSolution:\u003c/p\u003e\u003cp\u003eAccording to Andrica\u0027s conjecture , for two prime numbers p and q with p \u0026lt; q and no other prime between them (q is the next smallest prime after p), sqrt(q) â€” sqrt(p) \u0026lt; 1 which becomes q \u0026lt; p + 2\\sqrt(p) + 1 and since they are natural numbers, q \u0026lt;\u003d p + 2*sqrt(p). Therefore, the gap between p and q is at most 2*sqrt(p).\u003c/p\u003e\u003cp\u003eThis means that our algorithm will check at most 2*sqrt(p) numbers (or to be more precise, floor(2*sqrt(p)) ). For each number we will check up to its square root, therefore we will do floor(sqrt(p+1)) + floor(sqrt(p+2)) + floor(sqrt(p+3)) + ... + floor(sqrt(p + 2*floor(sqrt(p)))) operations in total. But all the elements are \u0026lt; floor(sqrt(p + p)) \u003d floor(sqrt(2*p)). There are floor(sqrt(2*p)) elements, so the total number of operations is less than floor(sqrt(2*p))*floor(sqrt(2\\p)) \u0026lt;\u003d 2*p. Thus this algorithm will do up to 2*P operations and the complexity will be O(P).\u003c/p\u003e\u003c/div\u003e","tags":["complexity","primes"]}}