{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1432918222,"rating":5,"authorHandle":"jjohn","modificationTimeSeconds":1432918310,"id":18207,"title":"\u003cp\u003eSpoj Helping Jar Jar\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eDear Friends,\u003c/p\u003e\u003cp\u003eI require some assistance concerning to my solution of this \u003ca href\u003d\"http://www.spoj.com/problems/JARJAR/\"\u003eproblem.\u003c/a\u003e I believe my logic is correct, but there are definitely some bugs in the code. My code is located here: \u003ca href\u003d\"http://ideone.com/t97fQ7\"\u003ehttp://ideone.com/t97fQ7\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI will also explain my reasoning behind the solution: dp[a][b]: a set containing all number n such that there exists n numbers from the first a numbers that sum up to b. This set is stored as a long number. Therefore if the x bit in dp[a][b] is 1, then it\u0027s possible to find x such numbers that sum to b. As soon as that is cleared, the problem itself is a typical knapsack problem with the values being updated this way: dp[a][b]\u003d(dp[a-1][b-V[a]] \u0026lt;\u0026lt; 1) OR dp[a-1][b]\u003c/p\u003e\u003cp\u003eThe shift \u0026lt;\u0026lt;1 happens because if we can form b-V[a] with q numbers, then we can form b with those q numbers and the V[a]. \u003c/p\u003e\u003cp\u003eDoes anyone have a clue as to why this code gets NZEC? Thank you in advance\u003c/p\u003e\u003c/div\u003e","tags":["dp","binary","spoj"]}}