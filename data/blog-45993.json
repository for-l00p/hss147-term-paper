{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1468259915,"rating":1,"authorHandle":"Scarlet-FF3300","modificationTimeSeconds":1468260581,"id":45993,"title":"\u003cp\u003eHelp me with money problem (business game)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello, Codeforces!\u003c/p\u003e\u003cp\u003eI am spinning with this problem for half day of thoughts and bugs. I would like to share it here with you so that we can discuss together to find some interesting things (more than a solution!).\u003c/p\u003e\u003cp\u003eLet\u0027s begin.\u003c/p\u003e\u003cp\u003eYou are the player having T dollars, and you will trade on n types of commodities. The game takes place in R turns. Each turn, the price of each type is announced, and you are allowed to buy or sell goods:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eIf you want to buy s[i] products of type-i, you have to pay money. Your bank account will be decreased by s[i] * (P[i] + d), where P[i] is the price of type-i, d is the extra fee in buying. s[i] products that you just bought would be transported to the storage. You cannot have more than C[i] products of type-i in your storage.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf you want to sell s[i] products of type-i, of courses you must have at least s[i] products of type-i in the storage, which will be decreased by s[i]. After that, your bank account is gained by s[i] * (P[i] â€” e), where e is the extra fee in selling.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eWhat is the biggest money in your bank account after all?\u003c/p\u003e\u003cp\u003eNotice: In each turn, the order of buying/selling any types is not important. But make sure that at the end of that turn, your money cannot be negative.\u003c/p\u003e\u003cp\u003eInput:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eThe first line contains 5 non-negative integers n, T, R, d, e.\u003c/li\u003e   \u003cli\u003eThe second line contains n non-negative integers C[1], C[2], ..., C[n]\u003c/li\u003e   \u003cli\u003eThe next R lines, every line consists of n non-negative integers, which are P[1], P[2], ..., P[n] in the turn.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eExample:\u003c/p\u003e\u003cp\u003e3 2 2 1 0\u003c/p\u003e\u003cp\u003e1 1 1\u003c/p\u003e\u003cp\u003e1 1 1\u003c/p\u003e\u003cp\u003e2 3 4\u003c/p\u003e\u003cp\u003eOutput:\u003c/p\u003e\u003cp\u003e4\u003c/p\u003e\u003cp\u003eConstraint:\u003c/p\u003e\u003cp\u003eT \u0026lt;\u003d 10^9\u003c/p\u003e\u003cp\u003ed,e \u0026lt;\u003d 10^6\u003c/p\u003e\u003cp\u003eC[i] \u0026lt;\u003d 20\u003c/p\u003e\u003cp\u003en \u0026lt;\u003d 5\u003c/p\u003e\u003cp\u003eR \u0026lt;\u003d 500\u003c/p\u003e\u003cp\u003eNote: When R \u0026gt; 5, d \u003d e \u003d 0.\u003c/p\u003e\u003cp\u003eThis is \u003ca href\u003d\"http://ideone.com/fE31cJ\"\u003emy code\u003c/a\u003e\u003c/p\u003e\u003cp\u003e(Simple recursive + Greedy)\u003c/p\u003e\u003cp\u003eI will sell when the price is highest, and try to buy when the price is lowest. I am thinking about dynamic programming way, but it seems hard to me.\u003c/p\u003e\u003cp\u003eI cannot figure out any more efficient solution. Any suggestion, ideas, reference sources would be appreciated.\u003c/p\u003e\u003c/div\u003e","tags":[]}}