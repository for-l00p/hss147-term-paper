{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1409480167,"rating":1,"authorHandle":"Eeyore","modificationTimeSeconds":1409496646,"id":13644,"title":"\u003cp\u003eAlternate solution for \u0026quot;Yaroslav and Sequence\u0026quot; (problem 302C)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u0026quot;Yaroslav and Sequence\u0026quot; appears in \u003ca href\u003d\"/contest/302\" title\u003d\"Codeforces Round 182 (Div. 2)\"\u003eCodeforces Round #182 (Div. 2)\u003c/a\u003e as \u003ca href\u003d\"//codeforces.com/contest/302/problem/C\"\u003eproblem C\u003c/a\u003e and in \u003ca href\u003d\"/contest/301\" title\u003d\"Codeforces Round 182 (Div. 1)\"\u003eCodeforces Round #182 (Div. 1)\u003c/a\u003e as \u003ca href\u003d\"//codeforces.com/contest/301/problem/A\"\u003eproblem A\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Sereja\" title\u003d\"Мастер Sereja\"\u003eSereja\u003c/a\u003e\u0027s \u003ca href\u003d\"//codeforces.com/blog/entry/7560\"\u003etutorial\u003c/a\u003e mentions depth-first search, which may well be the fastest way to write a solution. I think of this as a brute-force approach because it explores every possible state of the array. Wait a minute, I hear you saying, won\u0027t that time out? If we have a hundred elements, each one of which can be positive or negative, doesn\u0027t that make 2\u003csup\u003e100\u003c/sup\u003e states? It does if you include the position of each negative value. But if all you care about is the number of negative values, the number of states is linear in \u003cem\u003en\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eWe can disregard the positions of the negative values because if you have an array with exactly \u003cem\u003ex\u003c/em\u003e negative values at some positions, you can transform it into an array with exactly \u003cem\u003ex\u003c/em\u003e negative values at the positions of your choice. To see why this is so, consider the problem of moving a single negative sign to another position. Suppose we have the following state of affairs:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e a  b  c  d  e\n +  ?  ?  ?  -\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe above illustrates a case where \u003cem\u003en\u003c/em\u003e \u003d 3, so we have 2×3 − 1 \u003d 5 values in all. The first element, \u003cem\u003ea\u003c/em\u003e, is positive. The last element, \u003cem\u003ee\u003c/em\u003e, is negative. The remaining values can be negative, positive, or zero. All we care about is transforming the array so that \u003cem\u003ea\u003c/em\u003e is negative, \u003cem\u003ee\u003c/em\u003e is positive, and the remaining values have the same sign as at present. We can accomplish this in two steps.\u003c/p\u003e\u003cp\u003eFirst, we reverse the sign of \u003cem\u003ee\u003c/em\u003e and \u003cem\u003en\u003c/em\u003e−1 \u003d 2 other elements that are not \u003cem\u003ea\u003c/em\u003e. Let\u0027s choose \u003cem\u003ec\u003c/em\u003e and \u003cem\u003ed\u003c/em\u003e to be these two other elements:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e a  b -c -d -e\n +  ?  ?  ?  +\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0027s reverse the sign of \u003cem\u003ea\u003c/em\u003e and the same \u003cem\u003en\u003c/em\u003e−1 elements that we chose before:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e-a  b  c  d -e\n -  ?  ?  ?  +\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd there you have it. In two steps, we can move a negative sign from one position to any other position. If we want to move several negative signs, we can repeat the same sequence of steps for each one. You can probably see how to improve on this by changing the signs of several target elements in each step.\u003c/p\u003e\u003cp\u003eThe upshot is that we don\u0027t have to worry about the positions of the negative values. We\u0027ll just look for an array with the minimal number of negative values, and then we can distribute the minus signs in the most favorable way. Since the overall objective is to achieve the largest possible sum, we\u0027ll assign minus signs to the elements with the smallest absolute values.\u003c/p\u003e\u003cp\u003eLet\u0027s consider the implementation details of the brute-force approach to finding the smallest possible number of negative values. First, we characterize the array with a pair of values:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e(negative, positive)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFor example, the state (3, 1) means that the array has three negative values and one positive value.\u003c/p\u003e\u003cp\u003eNext, we define a recursive function that takes a state and applies the sign-reversal operation in as many ways as possible. If we\u0027re going to reverse the signs of \u003cem\u003en\u003c/em\u003e elements, how many do we draw from the negative elements of the array, how many from the zero elements, and how many from the positive elements? Let\u0027s call these numbers \u003cem\u003ei\u003c/em\u003e, \u003cem\u003ej\u003c/em\u003e, and \u003cem\u003ek\u003c/em\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ei \u003d number of negative elements\nj \u003d number of zero elements\nk \u003d number of positive elements\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt\u0027s clear that \u003cem\u003ei\u003c/em\u003e+\u003ci\u003ej\u003c/i\u003e+\u003ci\u003ek\u003c/i\u003e \u003d \u003cem\u003en\u003c/em\u003e must hold in order for the operation to be valid. Furthermore, each number is constrained by the state of the array. For example, the number of negative elements in the array is an upper bound on the value of \u003cem\u003ei\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eIn \u003ca href\u003d\"//codeforces.com/contest/302/submission/7654985\"\u003emy Python solution\u003c/a\u003e, I iterate over the possibilities as follows:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e    for i in range(min(n, negative)+1):\n        for j in range(min(n-i, zero)+1):\n            k \u003d n-i-j\n            if k \u0026lt;\u003d positive:\n                go(negative-i+k, positive-k+i)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAfter we have visited every possible state, which is to say every possible (\u003ci\u003enegative\u003c/i\u003e, \u003ci\u003epositive\u003c/i\u003e) tuple, we know the minimum number of negative values. The final steps are to change every element in the array to its absolute value, assign the requisite number of negative signs to the smallest values, and compute the sum.\u003c/p\u003e\u003cp\u003eThis approach is straightforward to implement once you see the idea of the state space and figure out how to deal with zero values. However, it resembles every other state-space search. In implementing it, you don\u0027t learn much about the nature of optimal solutions because you\u0027re making the code do all the work.\u003c/p\u003e\u003cp\u003eIf you run the algorithm on a number of test cases, it will become apparent that the solutions have a peculiar nature. It turns out that in the optimal state, an array has no more than one negative value. To see why that\u0027s so, let\u0027s solve an example by hand.\u003c/p\u003e\u003cp\u003eSuppose we have a problem instance that looks like this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e- - - - - - - - - - - + +\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat\u0027s a whole bunch of negative values and a few positive ones. It\u0027s obvious that we can improve the situation by reversing the signs of \u003cem\u003en\u003c/em\u003e negative values. To be precise, we have \u003cem\u003en\u003c/em\u003e \u003d 7, making a total of 2×7 − 1 \u003d 13 values, among which we have 2 pluses and 11 minuses. We can go from 11 minuses to 11−7 \u003d 4 minuses:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e- - - - + + + + + + + + +\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn general, if there are more than \u003cem\u003en\u003c/em\u003e negative values, it makes sense to immediately reverse the sign of \u003cem\u003en\u003c/em\u003e of them. At most there can be 2\u003ci\u003en\u003c/i\u003e−1 negative values, which we can change to 2\u003ci\u003en\u003c/i\u003e−1 − \u003ci\u003en\u003c/i\u003e \u003d \u003cem\u003en\u003c/em\u003e−1 in one step. Thus, we already have an upper bound of \u003cem\u003en\u003c/em\u003e−1 for the minimum number of negative values.\u003c/p\u003e\u003cp\u003eLet\u0027s continue with our example. We have 4 minuses and we\u0027d like to have fewer. First, let\u0027s divide the minuses into two halves. To make this clear visually, let\u0027s rearrange the elements without changing the number of pluses and minuses:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e- - + + + + + + + + + - -\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0027s change the sign of the first \u003cem\u003en\u003c/em\u003e \u003d 7 elements:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e+ + - - - - - + + + + - -\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNotice that there are exactly two plus signs among the first n elements and exactly two minus signs among the last \u003cem\u003en\u003c/em\u003e−1 elements. To see how we can exploit this circumstance, let\u0027s swap the first two and last two elements:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e- - - - - - - + + + + + +\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAll that remains is to reverse the signs of the first \u003cem\u003en\u003c/em\u003e elements:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e+ + + + + + + + + + + + +\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe same strategy can be applied to other numbers of minuses. Given an array with exactly \u003cem\u003ex\u003c/em\u003e minuses where \u003cem\u003ex\u003c/em\u003e ≤ \u003cem\u003en\u003c/em\u003e−1, we reverse the signs of \u003ci\u003ex\u003c/i\u003e/2 minuses along with \u003cem\u003en\u003c/em\u003e − \u003ci\u003ex\u003c/i\u003e/2 pluses. That results in \u003cem\u003en\u003c/em\u003e − \u003ci\u003ex\u003c/i\u003e/2 new minuses, making a total of \u003cem\u003ex\u003c/em\u003e/2 + \u003ci\u003en\u003c/i\u003e − \u003ci\u003ex\u003c/i\u003e/2 \u003d \u003cem\u003en\u003c/em\u003e minuses. One more operation leaves us with an array containing no minuses.\u003c/p\u003e\u003cp\u003eBut that only works if \u003cem\u003ex\u003c/em\u003e is an even number. If \u003cem\u003ex\u003c/em\u003e is odd, what can we do? Suppose \u003cem\u003en\u003c/em\u003e is an odd number. Then \u003cem\u003en\u003c/em\u003e−\u003ci\u003ex\u003c/i\u003e has the opposite parity of \u003cem\u003ex\u003c/em\u003e. We can exploit this fact by reversing the signs of the \u003cem\u003ex\u003c/em\u003e negative numbers and \u003cem\u003en\u003c/em\u003e−\u003ci\u003ex\u003c/i\u003e positive numbers to arrive at \u003cem\u003en\u003c/em\u003e−\u003ci\u003ex\u003c/i\u003e negative numbers. Thus, we can go from an odd number of minuses to an even number of minuses as long as \u003cem\u003en\u003c/em\u003e is odd.\u003c/p\u003e\u003cp\u003eIf \u003cem\u003en\u003c/em\u003e is even and \u003cem\u003ex\u003c/em\u003e is odd, is there anything we can do to get rid of the remaining minus? Yes, we can get rid of it as long as there is at least one zero. That\u0027s because we can let a zero value stand in as a minus, then perform the divide-in-half trick to get rid of the minuses. That work is unnecessary, though. We can keep the lone minus sign and assign it to a zero element, which means that it has no effect on the sum of the array.\u003c/p\u003e\u003cp\u003eIn the end, all that matters is the parity of \u003cem\u003en\u003c/em\u003e and the parity of \u003cem\u003ex\u003c/em\u003e. If \u003cem\u003en\u003c/em\u003e is odd, we can always contrive to make an even number of minuses, which we can then eliminate altogether. If \u003cem\u003en\u003c/em\u003e is even, we have to consider the parity of \u003cem\u003ex\u003c/em\u003e, the number of minuses: if it\u0027s even, we\u0027re fine, and if it\u0027s odd, we end up with a lone minus.\u003c/p\u003e\u003cp\u003eThe \u003ca href\u003d\"//codeforces.com/contest/302/submission/7654962\"\u003eresulting implementation\u003c/a\u003e is much shorter than the brute-force approach, yet its correctness is only apparent if you have thought through the case analysis. If you\u0027re wondering where my code deals with cases where \u003cem\u003ex\u003c/em\u003e ≥ \u003cem\u003en\u003c/em\u003e, it\u0027s implicit in the parity checks. Suppose \u003cem\u003en\u003c/em\u003e is even: then \u003cem\u003ex\u003c/em\u003e−\u003ci\u003en\u003c/i\u003e has the same parity as \u003cem\u003ex\u003c/em\u003e, so we can consider the parity of \u003cem\u003ex\u003c/em\u003e instead of the parity of \u003cem\u003ex\u003c/em\u003e−\u003ci\u003en\u003c/i\u003e. Suppose \u003cem\u003en\u003c/em\u003e is odd: then the parity of \u003cem\u003ex\u003c/em\u003e−\u003ci\u003en\u003c/i\u003e doesn\u0027t matter. To make the last point more evident, observe that we can go from \u003cem\u003ex\u003c/em\u003e−\u003ci\u003en\u003c/i\u003e minuses to \u003cem\u003en\u003c/em\u003e−(\u003ci\u003ex\u003c/i\u003e−\u003ci\u003en\u003c/i\u003e) \u003d 2\u003ci\u003en\u003c/i\u003e−\u003ci\u003ex\u003c/i\u003e minuses with one sign-reversal operation, and that \u003ci\u003ex\u003c/i\u003e−\u003ci\u003en\u003c/i\u003e and 2\u003ci\u003en\u003c/i\u003e−\u003ci\u003ex\u003c/i\u003e have opposite parity when \u003cem\u003en\u003c/em\u003e is odd.\u003c/p\u003e\u003c/div\u003e","tags":["tutorial","brute force","case analysis","302c"]}}