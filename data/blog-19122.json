{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1436294483,"rating":92,"authorHandle":"chubakueno","modificationTimeSeconds":1436294949,"id":19122,"title":"\u003cp\u003ePhilosophy behind \u0026quot;several test cases\u0026quot; and strategy against those problems\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI have always wondered what is the philosophy behind those ICPC problems that don\u0027t specify the number of test cases. What are the problem setters trying to evaluate, and how should I respond? Obviously, enough test cases will TLE out my solution. \u003c/p\u003e\u003cp\u003eOne of the great things about programming contests is choosing the right algo for the right job, say, I wouldn\u0027t go full Fast Fourier Transform if simple convolution gets the job done. So, should I respond to those problems with the best algo I can think of? Should I respond with a provably optimal algo? Or, should I reverse engineer the problem-setter expectations and choose something along those lines?\u003c/p\u003e\u003cp\u003eThis blog is intended for discussion, please don\u0027t understand this as a rant :)\u003c/p\u003e\u003c/div\u003e","tags":["acm icpc"]}}