{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1497591100,"rating":0,"authorHandle":"Nurordinskiy","modificationTimeSeconds":1497591100,"id":52647,"title":"\u003cp\u003eРазбор Задачи Мороженое \u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eРЕШЕНИЕ бинарный поиск\u003c/p\u003e\u003cp\u003eАнализ алгоритма Минимальное расстояние d между соседними ларьками в оптимальной расстановке будем искать бинарным поиском, начиная с интервала [0; 109]. Зафиксируем значение d и выясним, можно ли рассадить мороженщиков по ларькам требуемым образом. В первый (самый левый) ларек посадим продавца. Второго продавца посадим в ларек, находящийся на расстоянии не меньшем d от первого. И так далее. Если всех мороженщиков удалось рассадить по ларькам, то значение d можно попробовать увеличить. Если рассадка продавцов не удалась, то уменьшаем d.\u003c/p\u003e\u003cp\u003eРеализация алгоритма Объявим константы: максимальное количество ларьков MAX и плюс бесконечность INF. Координаты ларьков будем хранить в массиве m.\u003c/p\u003e\u003ch1\u003edefine MAX 10001\u003c/h1\u003e\u003ch1\u003edefine INF 1000000000\u003c/h1\u003e\u003cp\u003eint m[MAX];\u003c/p\u003e\u003cp\u003eФункция Check проверяет, можно ли рассадить продавцов мороженого по ларькам так, чтобы расстояние между ними было не меньше Value. Сделать это можно так. Садим первого продавца в первый ларек. Далее ищем ларек, который находится от первого на расстоянии, не меньшем Value. Садим в него второго продавца. И так далее, пока не рассадим всех продавцов. В переменной stall подсчитываем количество ларьков, в которые удалось посадить продавцов. Если рассадить k мороженщиков по ларькам не удастся (stall \u0026lt; k), то функция Check возвращает 0 (иначе 1).\u003c/p\u003e\u003cp\u003eint Check(int Value) {  int i, stall \u003d 1, len \u003d 0;  for(i \u003d 1; i \u0026lt; n; i++)  {  len +\u003d m[i] — m[i-1];  if (len \u0026gt;\u003d Value) len \u003d 0, stall++;  }  return stall \u0026gt;\u003d k; }\u003c/p\u003e\u003cp\u003eОсновная часть программы. Читаем входные данные.\u003c/p\u003e\u003cp\u003escanf(\u0026quot;%d %d\u0026quot;,\u0026amp;n,\u0026amp;k); for(i \u003d 0; i \u0026lt; n; i++)  scanf(\u0026quot;%d\u0026quot;,\u0026amp;m[i]);\u003c/p\u003e\u003cp\u003eПоскольку k \u0026lt; n, то всегда существует такое расстояние между соседними ларьками, при котором можно рассадить мороженщиков по ларькам. Пусть искомое минимальное расстояние находится в промежутке [Left; Right], изначально представляя собой интервал [0; 109].\u003c/p\u003e\u003cp\u003eLeft \u003d 0; Right \u003d INF; while(Left \u0026lt;\u003d Right) {  int Middle \u003d (Left + Right) / 2;  if (Check(Middle)) Left \u003d Middle + 1; else Right \u003d Middle — 1; }\u003c/p\u003e\u003cp\u003eВыводим искомое минимальное расстояние.\u003c/p\u003e\u003cp\u003eprintf(\u0026quot;%d\\n\u0026quot;,Left-1);\u003c/p\u003e\u003c/div\u003e","tags":[]}}