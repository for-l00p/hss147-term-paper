{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1470587112,"rating":164,"authorHandle":"DarthPrince","modificationTimeSeconds":1470587917,"id":46450,"title":"\u003cp\u003eCodeforces Round #366 (Editorial)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"https://gitlab.com/amirmd76/cf-round-366\"\u003eHere\u003c/a\u003e are the solutions to all problems.\u003c/p\u003e\u003ch3\u003eDiv.2 A\u003c/h3\u003e\u003cp\u003eJust alternatively print \u0026quot;I hate that\u0026quot; and \u0026quot;I love that\u0026quot;, and in the last level change \u0026quot;that\u0026quot; to \u0026quot;it\u0026quot;.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/5f/8c/5f8cd8f2c4122dab970dbff74ee86a36f1b155cb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d6/2e/d62e2a32a67492a176690a6a7c26f5a68aa2a122.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch3\u003eDiv.2 B\u003c/h3\u003e\u003cp\u003eFirst of all, instead of cycles, imagine we have bamboos (paths). A valid move in the game is now taking a path and deleting an edge from it (to form two new paths). So, every player in his move can delete an edge in the graph (with components equal to paths). So, no matter how they play, winner is always determined by the parity of number of edges (because it decreases by 1 each time). Second player wins if and only if the number of edges is even. At first it\u0027s even (0). In a query that adds a cycle (bamboo) with an odd number of vertices, parity and so winner won\u0027t change. When a bamboo with even number of vertices (and so odd number of edges) is added, parity and so the winner will change.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/69/2b/692b7db965f3028b5840ba03cf797fa68f43ca94.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d6/2e/d62e2a32a67492a176690a6a7c26f5a68aa2a122.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch3\u003eA\u003c/h3\u003e\u003cp\u003eConsider a queue \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e for every application and also a queue \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e for the notification bar. When an event of the first type happens, increase the number of unread notifications by 1 and push pair \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is the index of this event among events of the first type, and also push number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to queue \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e]\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWhen a second type event happens, mark all numbers in queue \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e]\u003c/span\u003e and clear this queue (also decreese the number of unread notifications by the number of elements in this queue before clearing).\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/6b/29/6b29c203ba2ac662d4a8c1c020323a4b3fd2f9ea.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eWhen a third type query happens, do the following:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ewhile Q is not empty and Q.front().first \u0026lt;\u003d t:\n\ti \u003d Q.front().first\n\tx \u003d Q.front().second\n\tQ.pop()\n\tif mark[i] is false:\n\t\tmark[i] \u003d true\n\t\te[v].pop()\n\t\tans \u003d ans - 1 // it always contains the number of unread notifications\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut in C++ set works much faster than queue!\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e2/0c/e20cd5d6e1175b7b7d5aabe145ca136896c7644c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch3\u003eB\u003c/h3\u003e\u003cp\u003eReduction to TSP is easy. We need the shortest Hamiltonian path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e. Consider the optimal answer. Its graph is a directed path. Consider the induced graph on first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e chairs. In this subgraph, there are some components. Each components forms a directed path. Among these paths, there are 3 types of paths: \u003c/p\u003e \u003col\u003e   \u003cli\u003eIn the future (in chairs in right side of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e), we can add vertex to both its beginning and its end.\u003c/li\u003e   \u003cli\u003eIn the future (in chairs in right side of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e), we can add vertex to its beginning but not its end (because its end is vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e).\u003c/li\u003e   \u003cli\u003eIn the future (in chairs in right side of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e), we cannot add vertex to its beginning (because its beginning is vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e) but we can add to its end.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/12/84/1284df9cb095b40cf963c20ccd56521a14ac7211.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThere are at most 1 paths of types 2 and 3 (note that a path with beginning \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e and ending \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e can only exist when all chairs are in the subgraph. i.e. induced subgraph on all vertices).\u003c/p\u003e\u003cp\u003eThis gives us a dp approach: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e][\u003ci\u003el\u003c/i\u003e]\u003c/span\u003e is the answer for when in induced subgraph on the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e vertices there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e components of type \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e of type \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e of type \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e. Please note that it contains some informations more than just the answer. For example we count \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e - \u003ci\u003ex\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e when we add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to the dp, not \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e (in the problem statement, when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e). Updating it requires considering all four ways of incoming and outgoing edges to the last vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e (4 ways, because each edge has 2 ways, left or right). You may think its code will be hard, but definitely easier than code of B.\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/17/45/17457d8e7535a42392edd92b0750b88a4fe20959.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch3\u003eC\u003c/h3\u003e\u003cp\u003eBuild a graph. Assume a vertex for each clause. For every variable that appears twice in the clauses, add an edge between clauses it appears in (variables that appear once are corner cases). Every vertex in this graph has degree at most two. So, every component is either a cycle or a path. We want to solve the problem for a path component. Every edge either appear the same in its endpoints or appears differently. Denote a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003c/span\u003e to count the answer. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e is the number of ways to value the edges till \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e vertex in the path so that the last clause(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e\u0027s) value is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e so far (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e is either 0 or 1). Using the last edge to update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e - 1]\u003c/span\u003e is really easy in theory. \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/c0/19/c019db87794341abb802386f4f5a76ca9d5084b2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eCounting the answer for a cycle is practically the same, just that we also need another dimension in our \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003c/span\u003e for the value of the first clause (then we convert it into a path). Handling variables that appear once (edges with one endpoint, this endpoint is always an endpoint of a path component) is also hard coding. And finally we need to merge the answers.\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9e/f7/9ef7bf82ca665829dfe31e13281003de578b9c8b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch3\u003eD\u003c/h3\u003e\u003cp\u003eAssume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e \u0026lt; \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e (if not, just swap the colors). Build a bipartite graph where every vertical line is a vertex in part \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e and every horizontal line is a vertex in part \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e. Now every point(shield) is an edge (between the corresponding vertical and horizontal lines it lies on). We write 1 on an edge if we want to color it in red and 0 if in blue (there may be more than one edge between two vertices). Each constraint says the difference between 0 and 1 edges connected to a certain vertex should be less than or equal to some value. For every vertex, only the constraint with smallest value matters (if there\u0027s no constraint on this vertex, we\u0027ll add one with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003enumber\u003c/i\u003e \u003ci\u003eof\u003c/i\u003e \u003ci\u003eedges\u003c/i\u003e \u003ci\u003econnected\u003c/i\u003e \u003ci\u003eto\u003c/i\u003e \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e). \u003c/p\u003e\u003cp\u003eConsider vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Assume there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e edges connected to it and the constraint with smallest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e on this vertex has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Assume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e will be the number of red (with number 1 written on) edges connected to it at the end. With some algebra, you get that the constraint is fulfilled if and only if \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7d/3e/7d3e596a07b0d7dc8c269c30332e495ba7fe8021.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Denote \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/19/aa/19aa0d6e1e2777cf2c539002a4319218249d0ee5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4d/69/4d69ebe85078090518dc3abc49db8505a3c34b67.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. So \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. This gives us a L-R max-flow approach: aside these vertices, add a source \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e and a sink \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e. For every vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in part \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e, add an edge with minimum and maximum capacity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. For every vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e in part \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e, add an edge with minimum and maximum capacity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e. And finally for every edge \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e - \u003ci\u003eu\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e add an edge from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e with capacity \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e (minimum capacity is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e).\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/dc/bd/dcbd9010faa17418fa2a3244b6c8c07b85521152.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eIf there\u0027s no feasible flow in this network, answer is -1. Otherwise since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e ≤ \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, we want to maximize the number of red points, that is, maximizing total flow from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSince the edges in one layer (from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e) have unit capacities, Dinic\u0027s algorithm works in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a3/a4/a3a4b19d8b58b8a9e204ef608bf0422c858ed927.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (Karzanov\u0027s theorem) and because \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/fc/9a/fc9ae798c640c237961235f7b9149f18f6b89a94.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/92/32/923290a443a7aea7b60b0aba373ac9a4b2e680e9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e Dinic\u0027s algorithm works in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0b/7d/0b7d3635eaa25ed69084ad5bebe74df0e9ca7d66.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e9/30/e93052964131f08a7374d550ec02bb45a0ff090b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch3\u003eE\u003c/h3\u003e\u003cp\u003eFirst, we\u0027re gonna solve the problem for when the given tree is a bamboo (path). For simplifying, assume vertices are numbered from left to right with \u003cspan class\u003d\"tex-span\"\u003e1, 2, .., \u003ci\u003en\u003c/i\u003e\u003c/span\u003e (it\u0027s an array). There are some events (appearing and vanishing). Sort these events in chronological order. At first (time \u003cspan class\u003d\"tex-span\"\u003e - ∞\u003c/span\u003e) no suit is there. Consider a moment of time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e. In time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e, consider all available suits sorted in order of their positions. This gives us a vector \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003et\u003c/i\u003e)\u003c/span\u003e. \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/0b/93/0b9381e69e0720609b9baebd7d8bfeacfeb44658.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eLemma 1:\u003c/strong\u003e If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e are gonna be at the same location (and explode), there\u0027s a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e are both present in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003et\u003c/i\u003e)\u003c/span\u003e and in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003et\u003c/i\u003e)\u003c/span\u003e they\u0027re neighbours.\u003c/p\u003e\u003cp\u003eThis is obvious since if at the moment before they explode there\u0027s another suit between them, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e and that suit will explode (and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e won\u0027t get to the same location).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eLemma 2:\u003c/strong\u003e If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e are present in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003et\u003c/i\u003e)\u003c/span\u003e and in time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e has position less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, then there\u0027s no time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e \u0026gt; \u003ci\u003et\u003c/i\u003e\u003c/span\u003e such that in it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e has position greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThis hold because they move continuously and the moment they wanna pass by each other they explode. \u003c/p\u003e\u003cp\u003eSo this gives us an approach: After sorting the events, process them one by one. consider \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003c/span\u003e is the best answer we\u0027ve got so far (earliest explosion, initially \u003cspan class\u003d\"tex-span\"\u003e∞\u003c/span\u003e). Consider there\u0027s a set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ese\u003c/i\u003e\u003c/span\u003e that contains the current available suits at any time, compared by they positions (so comparing function for this set would be a little complicated, because we always want to compare the suits in the current time, i.e. the time when the current event happens). If at any moment of time, time of event to be processed is greater than or equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003c/span\u003e, we break the loop. When processing events: \u003c/p\u003e\u003cp\u003eFirst of all, because current event\u0027s time is less than current \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003c/span\u003e, elements in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ese\u003c/i\u003e\u003c/span\u003e are still in increasing order of their position due to lemma 2 (because if two elements were gonna switch places, they would explode before this event and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003c/span\u003e would be equal to their explosion time). There are two types of events:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eSuit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e appears. After updating the current moment of time (so \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ese\u003c/i\u003e\u003c/span\u003e\u0027s comparing function can use it), we insert \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ese\u003c/i\u003e\u003c/span\u003e. Then we check \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e with its two neighbours in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ese\u003c/i\u003e\u003c/span\u003e to update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003c/span\u003e (check when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and its neighbours are gonna share the same position).\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eSuit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e vanishes. After updating the current moment of time, we erase \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ese\u003c/i\u003e\u003c/span\u003e and check its two previous neighbours (which are now neighbours to each other) and update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e\u003c/span\u003e by their explosion time.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eThis algorithm will always find the first explosion due to lemma 1 (because the suits that\u0027re gonna explode first are gonna be neighbours at some point).\u003c/p\u003e\u003cp\u003eThis algorithm only works for bamboos. For the original problem, we\u0027ll use heavy-light decompositions. At first, we decompose the path of a suit into heavy-light sub-chains (like \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e sub-chains) and we replace this suit by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e suits, each moving only within a subchain. Now, we solve the problem for each chain (which is a bamboo, and we know how to solve the problem for a bamboo). After replacing each suit, we\u0027ll get \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ff/f7/fff7290de3a3a6f24025f8d9d6b09d238ea89dc7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e suits because \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/62/28/622814f7e282c45f3ee816d8932d7e4bc793ca40.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and we need an extra log for sorting events and using set, so the total time complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e8/cb/e8cb9eb653e82c97ac4d204fa17c1a287763fc7c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eIn implementation to avoid \u003ccode\u003edouble\u003c/code\u003e and floating point bugs, we can use a pair of integers (real numbers).\u003c/p\u003e\u003cp\u003eTime Complexity (more precisely): \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/15/9a/159a0642dba720e21ab5614456eaaf39c3053261.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003c/div\u003e","tags":["codeforces","round","366","editorial","princeofpersia","lastcontest","bye","cf"]}}