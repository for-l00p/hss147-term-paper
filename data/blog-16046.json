{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1422355560,"rating":8,"authorHandle":"isti757","modificationTimeSeconds":1422359655,"id":16046,"title":"\u003cp\u003eTopcoder 647 DIV1 500 question\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI wrote a different solution to Topcoder 647 DIV1 500 problem and can\u0027t understand why is it giving different (larger) results. \u003c/p\u003e\u003cp\u003eI brute force over all the sets of robots and then order each set increasingly by capacity. Then all robots travel together only so much that the robot with the least capacity can come back and compensate all the robots that have still not turned back, such that their capacity is again full. Once the robot has compensated all the others in full, it comes back and we apply the same logic to the robots left.\u003c/p\u003e\u003cp\u003eWhat is wrong with my logic?\u003c/p\u003e\u003cp\u003eHere is the code (note that it doesn\u0027t work for test cases larger than 31 in size):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass CtuRobots {\npublic:\n    double brute(vector\u0026lt;double\u0026gt; \u0026amp;use) {\n        sort(use.begin(), use.end());\n\n        int n \u003d use.size();\n        vector\u0026lt;double\u0026gt; x(use.size(), 0);\n        for(int i \u003d 0; i \u0026lt; n; i++) {\n            // subtract from the current capacity the way back\n            // the rest is guaranteed to be non-negative\n            double cur \u003d use[i];\n            for(int j \u003d 0; j \u0026lt; i; j++)\n                cur -\u003d x[j];\n            assert(cur \u0026gt;\u003d 0.0);\n\n            // split the left over capacity over the robots\n            // that have still not turned back plus 2 times for the current\n            // robot that has to go forward and then back\n            cur /\u003d (n-i+1);\n            x[i] \u003d cur;\n        }\n\n        // the answer is the sum of all the segments\n        double ans \u003d 0;\n        for(int i \u003d 0; i \u0026lt; x.size(); i++)\n            ans +\u003d x[i];\n\n        // check that we actually use all the fuel\n        double chk \u003d 0, sum \u003d 0;\n        for(int i \u003d 0; i \u0026lt; x.size(); i++) {\n            chk +\u003d (use.size()-i)*x[i];\n            sum +\u003d use[i];\n        }\n        assert(abs(2*chk-sum) \u0026lt; 1e-9);\n\n        return ans;\n    }\n\n    double maxDist(int B, vector \u0026lt;int\u0026gt; cost, vector \u0026lt;int\u0026gt; cap) {\n        // brute force solution\n        assert(cost.size() \u0026lt; 32);\n        double brt \u003d 0;\n        for(int i \u003d 0; i \u0026lt; (1 \u0026lt;\u0026lt; cost.size()); i++) {\n            int cur \u003d 0;\n            vector\u0026lt;double\u0026gt; use;\n            for(int j \u003d 0; j \u0026lt; cost.size(); j++) {\n                if(i \u0026amp; (1 \u0026lt;\u0026lt; j)) {\n                    cur +\u003d cost[j];\n                    use.push_back(cap[j]);\n                }\n            }\n            if(cur \u0026lt;\u003d B) {\n                brt \u003d max(brt, brute(use));\n            }\n        }\n\n        // dynamic programming solution\n        for(int i \u003d 0; i \u0026lt; cost.size(); i++) {\n            for(int j \u003d 0; j \u0026lt; i; j++) {\n                if(cap[j] \u0026gt; cap[i]) {\n                    swap(cap[i], cap[j]);\n                    swap(cost[i], cost[j]);\n                }\n            }\n        }\n\n        double dp[111111];\n        for(int i \u003d 0; i \u0026lt;\u003d B; i++)\n            dp[i] \u003d 0;\n\n        for(int i \u003d 0; i \u0026lt; cost.size(); i++) {\n            for(int j \u003d B-cost[i]; j \u0026gt;\u003d 0; j--) {\n                dp[j+cost[i]] \u003d max(dp[j]/3.0+cap[i], dp[j+cost[i]]);\n            }\n        }\n\n        double ans \u003d 0;\n        for(int i \u003d 0; i \u0026lt;\u003d B; i++) {\n            ans \u003d max(ans, dp[i]/2.0);\n        }\n\n        assert(abs(ans-brt) \u0026lt; 1e-9);\n        assert(brt \u0026gt;\u003d ans);\n        return ans;\n    }\n};\n\nint main( int argc, char* argv[] ) {\n    {\n        int costARRAY[] \u003d {50,25};\n        vector \u0026lt;int\u0026gt; cost( costARRAY, costARRAY+ARRSIZE(costARRAY) );\n        int capARRAY[] \u003d {1,1};\n        vector \u0026lt;int\u0026gt; cap( capARRAY, capARRAY+ARRSIZE(capARRAY) );\n        CtuRobots theObject;\n        eq(0, theObject.maxDist(100, cost, cap),0.6666666666666666);\n    }\n    {\n        int costARRAY[] \u003d {23,5,8,20,15};\n        vector \u0026lt;int\u0026gt; cost( costARRAY, costARRAY+ARRSIZE(costARRAY) );\n        int capARRAY[] \u003d {108,30,42,100,94};\n        vector \u0026lt;int\u0026gt; cap( capARRAY, capARRAY+ARRSIZE(capARRAY) );\n        CtuRobots theObject;\n        eq(1, theObject.maxDist(25, cost, cap),55.0);\n    }\n    {\n        int costARRAY[] \u003d {0,0,0,1000,1000,0,1000,0};\n        vector \u0026lt;int\u0026gt; cost( costARRAY, costARRAY+ARRSIZE(costARRAY) );\n        int capARRAY[] \u003d {2039,4819,5923,1577,8749,9182,3652,4918};\n        vector \u0026lt;int\u0026gt; cap( capARRAY, capARRAY+ARRSIZE(capARRAY) );\n        CtuRobots theObject;\n        eq(2, theObject.maxDist(1382, cost, cap),6503.238683127572);\n    }\n    {\n        int costARRAY[] \u003d {185,130,109,1,45,117,127,13,2,37,6,1,2};\n        vector \u0026lt;int\u0026gt; cost( costARRAY, costARRAY+ARRSIZE(costARRAY) );\n        int capARRAY[] \u003d {93,5,278,4,20,54,93,213,103,5,225,32,5};\n        vector \u0026lt;int\u0026gt; cap( capARRAY, capARRAY+ARRSIZE(capARRAY) );\n        CtuRobots theObject;\n        eq(3, theObject.maxDist(209, cost, cap),190.48376771833563);\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["topcoder","unknown error","bug"]}}