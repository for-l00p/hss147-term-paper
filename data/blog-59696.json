{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1527348400,"rating":20,"authorHandle":"JoudZouzou","modificationTimeSeconds":1527348400,"id":59696,"title":"\u003cp\u003e[GYM] Damascus-CPC 2018 — Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eA. Martadella Strikes Again\u003c/h1\u003e\u003cp\u003eif \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e * \u003ci\u003eR\u003c/i\u003e \u0026gt; 2 * \u003ci\u003er\u003c/i\u003e * \u003ci\u003er\u003c/i\u003e\u003c/span\u003e print \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, otherwise print \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e should be \u003cstrong\u003elong long\u003c/strong\u003e or \u003cstrong\u003edouble\u003c/strong\u003e to avoid overflow\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://pastebin.com/1CKZu6yN\"\u003eC++ Code\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eB. Amer and Graphs\u003c/h1\u003e\u003cp\u003eSince the edges are undirected ,we can store the edges \u003cspan class\u003d\"tex-span\"\u003e{\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e}\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eu\u003c/i\u003e ≤ \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e for every edge \u003cspan class\u003d\"tex-span\"\u003e(1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLet\u0027s assign a unique number for every unique edge in the array, then our problem will be reduced to :\u003c/p\u003e\u003cp\u003eFind the number of different segments of the array which have the exact same elements ( same frequencies as well for each element ).\u003c/p\u003e\u003cp\u003eThis problem is a classic hashing problem that can be solved this way :\u003c/p\u003e\u003cp\u003elet\u0027s choose some random large prime numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eMOD\u003c/i\u003e\u003c/span\u003e ,for example \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e \u003d 304933, \u003ci\u003eMOD\u003c/i\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e + 7\u003c/span\u003e.\u003c/p\u003e\u003cp\u003ereplace every element \u003cspan class\u003d\"tex-span\"\u003e{\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e}\u003c/span\u003e from the array with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/sup\u003e%\u003ci\u003eMOD\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003enow the final problem is about finding different segments of the array which have the same sum value \u003cspan class\u003d\"tex-span\"\u003e%\u003ci\u003eMOD\u003c/i\u003e\u003c/span\u003e .\u003c/p\u003e\u003cp\u003eThis solution will get \u0026quot;Wrong Answer\u0026quot;, so you need to do a double-hashing in the same way using other numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003eMOD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eTime Complexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e * \u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e .\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://pastebin.com/KjPfwjXJ\"\u003eC++ Code\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eC. Help Shahhoud\u003c/h1\u003e\u003cp\u003eWe greedily iterate from the sides and when two items need to be reversed we reverse the whole segment that contains them and add one to the final answer\u003c/p\u003e\u003cp\u003eIf they can’t be equal even if we reverse them then it is impossible and answer \u003d -1 .\u003c/p\u003e\u003cp\u003eWe only need to keep a flag for the current state :\u003c/p\u003e\u003cp\u003e0 means the segment between the 2 pointers is not reversed.\u003c/p\u003e\u003cp\u003e1 means the segment between the 2 pointers is reversed.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://pastebin.com/CqE3cngW\"\u003eC++ Code\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eD. Simplified 2048\u003c/h1\u003e\u003cp\u003eThe main idea is that we only need to keep track of the number of active cells and the last strictly increasing sequence of powers from right to left, this is because if we have a cell with number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e and the cell to the right has number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e \u0026gt; \u003ci\u003eX\u003c/i\u003e\u003c/span\u003e , these two cells will never merge and therefore anything to the left of them won\u0027t add anything to the score so we don\u0027t need to keep track of them.\u003c/p\u003e\u003cp\u003eThis leads to a DP Bitmask solution where we store the bitmask of available powers of 2 (they are guaranteed to be strictly increasing from right to left because we ignore any powers that aren\u0027t) and the number of active cells (free cells + number of bits in the mask).\u003c/p\u003e\u003cp\u003eIf the current mask is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emsk\u003c/i\u003e\u003c/span\u003e and a \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e is generated, the new mask will become \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emsk\u003c/i\u003e + 4\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e((\u003ci\u003emsk\u003c/i\u003e)\u003c/span\u003e^\u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003emsk\u003c/i\u003e + 4))\u003c/span\u003e\u003cspan class\u003d\"tex-span\"\u003e - 4\u003c/span\u003e will be added to the score.\u003c/p\u003e\u003cp\u003eWhen a \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e is generated, the new mask will become \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emsk\u003c/i\u003e + 2\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e((\u003ci\u003emsk\u003c/i\u003e)\u003c/span\u003e^\u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003emsk\u003c/i\u003e + 2))\u003c/span\u003e\u003cspan class\u003d\"tex-span\"\u003e - 2\u003c/span\u003e will be added to the score.\u003c/p\u003e\u003cp\u003eThe added score explained above is the score added from all the merge operations that will happen after adding the new number, not only the first one. Merging them all at once will not affect the final answer.\u003c/p\u003e\u003cp\u003e^ is the bitwise XOR operator.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://pastebin.com/nv58e5ik\"\u003eC++ Code\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eE. Floods\u003c/h1\u003e\u003cp\u003eThe answer is the sum of areas of zero or more simple polygons that keep rainwater.\u003c/p\u003e\u003cp\u003eWe will explain an easy way to find these polygons and then calculate their areas.\u003c/p\u003e\u003cp\u003eLook at the picture while reading for better understanding :\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/fb/c8/fbc8ecaf46805ccf60c341622568064dae2917f8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eWe will say that a point is important if it isn\u0027t underwater(red points in the picture ).\u003c/p\u003e\u003cp\u003eWe can easily determine if the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003eth\u003c/i\u003e\u003c/span\u003e point is important if it has the maximum value of y-coordinate from the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e points or the last \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e points of the polyline. \u003c/p\u003e\u003cp\u003eAny other point will have one or more points on it\u0027s left and one or more points on it\u0027s right with larger y-coordinate , so it will be underwater for sure (this point will not be important for us for now).\u003c/p\u003e\u003cp\u003eNow for every important point let us draw a horizontal line to the left (or to the right) to find the intersection point with some segment of the polyline (green points in the picture ).\u003c/p\u003e\u003cp\u003eWe need to handle the 2 cases (when to draw a line to left and when to draw a line to the right).\u003c/p\u003e\u003cp\u003eThe problem now is reduced to calculating the sum of areas of the resulting polygons.\u003c/p\u003e\u003cp\u003eTime Complexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e \u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://pastebin.com/uTP4xaj1\"\u003eC++ Code\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eF. Random Sort\u003c/h1\u003e\u003cp\u003elet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e]\u003c/span\u003e \u003d number of occurences of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e in the array\u003c/p\u003e\u003cp\u003ethe answer is the multiplication of factorial$( cnt[x] )$\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://pastebin.com/D27tH16Y\"\u003eC++ Code\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eG. Weird Requirements\u003c/h1\u003e\u003cp\u003eThe problem asks you to make the minimum number of changes on the array to make GCD of all elements equals to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e and LCM of all elements equals to Y.\u003c/p\u003e\u003cp\u003eFirst of all, let\u0027s count the number of elements that \u003cstrong\u003emust\u003c/strong\u003e be changed and call it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e i.e. the elements where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e isn\u0027t a multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e or a divisor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eGCD\u003c/i\u003e\u003c/span\u003e of a group of numbers is the product of the common prime factors with the lowest power, and the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLCM\u003c/i\u003e\u003c/span\u003e of a group of numbers is the product of all prime factors that appear in the numbers with the highest power.\u003c/p\u003e\u003cp\u003eThere are 5 cases to handle :\u003c/p\u003e\u003cp\u003e1) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAns\u003c/i\u003e \u003d  - 1\u003c/span\u003e: if ( \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e isn\u0027t a multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e ) or ( \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e \u003d 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e ≠ \u003ci\u003eY\u003c/i\u003e\u003c/span\u003e ).\u003c/p\u003e\u003cp\u003e2) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAns\u003c/i\u003e \u003d 0\u003c/span\u003e: if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e \u003d 0\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eGCD\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e) \u003d \u003ci\u003eX\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLCM\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e) \u003d \u003ci\u003eY\u003c/i\u003e\u003c/span\u003e\u003cbr /\u003e for all \u003cspan class\u003d\"tex-span\"\u003e(1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e3 and 4) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAns\u003c/i\u003e \u003d 1\u003c/span\u003e: if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e \u003d 0\u003c/span\u003e and there is an element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e satisfies the following condition or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e \u003d 1\u003c/span\u003e and the element that must be changed satisfies the following condition:\u003c/p\u003e\u003cp\u003eLet\u0027s first factorize both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe element satisfies the condition if after deleting it, each prime factor that appears in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e, must satisfy the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eGCD\u003c/i\u003e\u003c/span\u003e \u003cstrong\u003eOR\u003c/strong\u003e the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLCM\u003c/i\u003e\u003c/span\u003e rule from the note above in at least one of the remaining elements. This way, if either the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLCM\u003c/i\u003e\u003c/span\u003e or the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eGCD\u003c/i\u003e\u003c/span\u003e rule is not satisfied, it can be fixed by changing the deleted element. We can\u0027t fix both the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLCM\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eGCD\u003c/i\u003e\u003c/span\u003e rule for some prime factor by changing one number, unless the power of the prime factor is equal in both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e (this case should also be taken care of).\u003c/p\u003e\u003cp\u003e5) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAns\u003c/i\u003e \u003d \u003ci\u003emax\u003c/i\u003e(2, \u003ci\u003eC\u003c/i\u003e)\u003c/span\u003e: otherwise\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://pastebin.com/ZYPE2rKb\"\u003eC++ Code\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eH. Shahhoud the Chief Judge\u003c/h1\u003e\u003cp\u003eFirst of all, you need to calculate this \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e\u003c/span\u003e :\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e \u003d the number of paths that includes node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe solution has three cases:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003ecase 1:\u003c/strong\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAns\u003c/i\u003e\u003c/span\u003e \u003d 0\u003c/p\u003e\u003cp\u003ecalculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e \u003d sum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e * \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e \u003c/p\u003e\u003cp\u003eif \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e \u003d 0 then the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAns\u003c/i\u003e\u003c/span\u003e \u003d 0.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003ecase 2:\u003c/strong\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAns\u003c/i\u003e\u003c/span\u003e \u003d 1\u003c/p\u003e\u003cp\u003ea node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is a solution if and only if ( \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e mod \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e \u003d 0 )\u003c/p\u003e\u003cp\u003elet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e be the new weight of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003e0 \u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e * \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e + \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e * \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e \u003c/p\u003e\u003cp\u003e\u003d\u0026gt;\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e \u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e / \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e \u003c/p\u003e\u003cp\u003ewhich is an integer\u003c/p\u003e\u003cp\u003e\u003cstrong\u003ecase 3:\u003c/strong\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAns\u003c/i\u003e\u003c/span\u003e \u003d 2\u003c/p\u003e\u003cp\u003efor each pair (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e) if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egcd\u003c/i\u003e\u003c/span\u003e(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e) \u003d 1 then they can be an answer because: \u003c/p\u003e\u003cp\u003e( let\u0027s say that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e are their new weights respectively )\u003c/p\u003e\u003cp\u003e0 \u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e * \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e + \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e * \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e * \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e + \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e * \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003d\u0026gt; \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e*\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e + \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e*\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e \u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e therefore such \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e always exist \u003c/p\u003e\u003cp\u003eand the pair (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e) always exists because:\u003c/p\u003e\u003cp\u003elet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e be a node with biggest possible depth, hence \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is a leaf, and its other\u003c/p\u003e\u003cp\u003esibling is also a leaf (it has a sibling because the tree is binary, and its sibling doesn\u0027t have any children because \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is of maximal depth)\u003c/p\u003e\u003cp\u003enow if we look at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eparentOf\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e)]\u003c/span\u003e :\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e \u003d (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e-1) * 2 + 1 \u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e-1 path ends at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e with two directions + one path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003eparent\u003c/i\u003e]\u003c/span\u003e \u003d \u003cspan class\u003d\"tex-span\"\u003e6\u003ci\u003en\u003c/i\u003e - 11\u003c/span\u003e\u003c/p\u003e\u003cp\u003eand we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egcd\u003c/i\u003e\u003c/span\u003e(\u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e6\u003ci\u003en\u003c/i\u003e - 11\u003c/span\u003e) \u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egcd\u003c/i\u003e\u003c/span\u003e(\u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e6\u003ci\u003en\u003c/i\u003e - 11\u003c/span\u003e — \u003cspan class\u003d\"tex-span\"\u003e3 * (2\u003ci\u003en\u003c/i\u003e - 1)\u003c/span\u003e ) \u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egcd\u003c/i\u003e\u003c/span\u003e(\u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e - 8\u003c/span\u003e) \u003d 1\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e is odd, 8 can be only divided by 2.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://pastebin.com/K43LHbyN\"\u003eC++ Code\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eI. Ildar Yalalov\u003c/h1\u003e\u003cp\u003eThe winning states are:\u003c/p\u003e\u003cp\u003e1) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e is odd and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e is odd.\u003c/p\u003e\u003cp\u003e2) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e is even and at least one of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e is odd.\u003c/p\u003e\u003cp\u003eLet\u0027s look at the optimal strategy for Yalalov in the winning states:\u003c/p\u003e\u003cp\u003e1) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e is odd. In this case, the number of stones removed in each step is always odd (either 1 or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e). This means that the parity of the amount of stones left will flip in each move, so if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e is odd, then there will always be an odd number of stones in Yalalov\u0027s turn, and since the losing state has an even number of stones, Yalalov will never reach the losing state so he wins. Otherwise, he will lose because he always ends up in a state with an even number of stones.\u003c/p\u003e\u003cp\u003e2) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e is even and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e is odd. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e is odd, then the optimal strategy would be to use a move of the first type on the pile with the minimum number of stones, leaving an even number of second type moves, and an odd number of stones for the second player (losing position). The only way for the opponent to leave the losing position is to use a move of the second type, but you can negate the effect of it by using another move of the second type (there is an even number of them). When \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e is even, the best strategy is to use a second type move, leaving your opponent with an even number of stones, and and even number of second type moves, which is also a losing poition.\u003c/p\u003e\u003cp\u003e3) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e is even and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e is even. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e is odd, the best strategy is to use first type moves, unless your opponent uses a second type move, you then also use a second type move to negate it\u0027s effect. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e is even, this is a losing state mentioned above.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://pastebin.com/xzb31Ueg\"\u003eC++ Code\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eJ. Saeed and Folan\u003c/h1\u003e\u003cp\u003eSince \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e is small, you can just simulate all the movements for both Saeed and Folan and add 1 to the answer when their positions are equal. \u003c/p\u003e\u003cp\u003eIn each second, you need to first fix the direction of movement (if the person is currently at position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e then the direction should be right, and if the person is currently at position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e, the direction should be left), then move 1 step in the current direction. \u003c/p\u003e\u003cp\u003eAfter each step, check if the positions are equal.\u003c/p\u003e\u003cp\u003eTime Complexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eK\u003c/i\u003e)\u003c/span\u003e \u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://pastebin.com/NaVTnGPz\"\u003eC++ Code\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eK. Another Shortest Path Problem\u003c/h1\u003e\u003cp\u003eThe first thing to notice is that an undirected connected graph with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e nodes and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e edges has exactly one cycle and each node on this cycle can be a root of a tree.\u003c/p\u003e\u003cp\u003eDelete any edge from the cycle, let\u0027s say it connects nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e with weight \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe resulting graph is a tree. There are 3 cases for the shortest path between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e1) It does not pass through the deleted edge. So the shortest path is equal to the distance between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e in the resulting tree.\u003c/p\u003e\u003cp\u003e2) It passes through the deleted edge from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. So the shortest path is equal to the distance between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e in the tree + the distance from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e in the tree + \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e3) It passes through the deleted edge from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e. So the shortest path is equal to the distance between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in the tree + the distance from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e in the tree + \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSo, in each query, we take the minimum between the previous cases.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eTo find the shortest path between any two nodes in a tree:\u003c/p\u003e\u003cp\u003eFirst, consider any node to be the root, and calculate the distance from each node to the root in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e with a simple dfs.\u003c/p\u003e\u003cp\u003eNext, you can find the distance between any two nodes in a tree in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e using LCA.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edist\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e) \u003d \u003ci\u003edistToRoot\u003c/i\u003e[\u003ci\u003ea\u003c/i\u003e] + \u003ci\u003edistToRoot\u003c/i\u003e[\u003ci\u003eb\u003c/i\u003e] - 2 * \u003ci\u003edistToRoot\u003c/i\u003e[\u003ci\u003eLCA\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)].\u003c/span\u003e\u003c/p\u003e\u003cp\u003eAnother solution finds the cycle and finds the best way to go around the cycle using prefix sum for queries that are in different trees.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://pastebin.com/eXTVBSrY\"\u003eC++ Code for second solution\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eL. V--o_o--V\u003c/h1\u003e\u003cp\u003eComing Soon.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://pastebin.com/wXi0nJ0H\"\u003eC++ Code\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["gym"]}}