{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1525305889,"rating":0,"authorHandle":"lucasturci","modificationTimeSeconds":1525306239,"id":59215,"title":"\u003cp\u003eDFS e BFS\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eDefinições sobre grafos\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eVértice:\u003c/strong\u003e Uma das extremidades da aresta\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eAresta:\u003c/strong\u003e O que liga os vértices\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eGrafo:\u003c/strong\u003e Um conjunto de vértices e arestas que representa algum problema\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eGrau de um Vértice:\u003c/strong\u003e número de arestas que incidem no vértice\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eComponente:\u003c/strong\u003e O conjunto de vértices alcançáveis a partir de um nó\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCaminho:\u003c/strong\u003e Conjunto de arestas e vértices que ligam dois nós do grafo\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCiclo:\u003c/strong\u003e Caminho que começa e termina no mesmo vértice\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eAresta direcional:\u003c/strong\u003e Aresta que sai de um vértice e vai para o outro mas não pode ser usado no sentido contrario\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eAresta bidirecional:\u003c/strong\u003e Aresta que possuí as duas direções\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eGrafo conexo:\u003c/strong\u003e Todos os vértices estão na mesma componente.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eÁrvore:\u003c/strong\u003e Grafo bidirecional, acíclico e conexo OU grafo bidirecional, com |V| — 1 arestas e conexo OU grafo bidirecional em que existe exatamente 1 caminho entre qualquer par de nós. (Todas as definições são equivalentes)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDFS:\u003c/strong\u003e (Depth-First Search ou Busca em Profundidade) é um algoritmo de busca em grafos. Sua complexidade é O(V + E) onde V é o número de vértices e E o número de arestas do grafo.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eBFS:\u003c/strong\u003e (Breadth-First Search ou Busca em Largura) é um algoritmo de busca em grafos que pode ser usado para calcular distâncias mínimas de um vértice de início a todos os outros. Sua complexidade também é O(V + E).\u003c/p\u003e\u003ch3\u003eComo representar um grafo, com lista de adjacências:\u003c/h3\u003e\u003cp\u003e\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;int\u0026gt; edges[N]; //N é o número máximo de vértices do grafo\n\nint main() {\n   edges[1].push_back(2); //significa que existe uma aresta do 1 para o 2\n\n   //E se precisar de uma aresta bidirecional?\n   edges[1].push_back(2);\n   edges[2].push_back(1);\n   \n   //Eh como se fosse duas direcionadas, e representar dessa \n   //forma nao ira afetar os algoritmos de DFS e BFS\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eCódigo DFS:\u003c/h3\u003e\u003cp\u003e\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;int\u0026gt; edges[N];\nint vis[N]; // 0 -\u0026gt; nao visitado, 1 -\u0026gt; visitado\n\nvoid dfs(int u) {\n    vis[u] \u003d 1;\n\n    for(int i \u003d 0; i \u0026lt; edges[u].size(); ++i) {\n        int v \u003d edges[u][i];\n\n        if(vis[v] \u003d\u003d 0) dfs(v);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eCódigo BFS:\u003c/h3\u003e\u003cp\u003e\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;int\u0026gt; edges[N];\nint dist[N]; //-1 -\u0026gt; nao visitado\n\n//realiza a bfs partindo de s\nvoid bfs(int s) {\n    memset(dist, -1, sizeof dist);\n    queue\u0026lt;int\u0026gt; q;\n\n    dist[s] \u003d 0;\n    q.push(s);\n\n    while(q.size()) {\n        int u \u003d q.front();\n        q.pop();\n        \n        for(int i \u003d 0; i \u0026lt; edges[u].size(); ++i) {\n            int v \u003d edges[u][i];\n            if(dist[v] \u003d\u003d -1) {\n                dist[v] \u003d dist[u] + 1; //atualiza a distancia do vertice v\n                q.push(v);\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCreditos ao ex coach mito \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/bssanches\" title\u003d\"Candidate Master bssanches\"\u003ebssanches\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}