{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1512736335,"rating":1,"authorHandle":"acmASCIS","modificationTimeSeconds":1512736335,"id":56236,"title":"\u003cp\u003eWeek06 — Arrays 1D \u0026amp; 2D\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eLet’s say that we want to store a hundred numbers,\u003c/p\u003e\u003cp\u003eOne way of doing that is simply by declaring 100 integers:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint Var1;\nint Var2;\nint Var3;\nint Var4;\nint Var5;\nint Var6;\nint Var7;\nint Var8;\nint Var9;\nint Var10;\nint Var11;\nint Var12;\nint Var13;\nint Var14;\nint Var15;\nint Var16;\nint Var17;\nint Var18;\nint Var19;\nint Var20;\nint Var21;\nint Var22;\nint Var23;\nint Var24;\nint Var25;\nint Var26;\nint Var27;\nint Var28;\nint Var29;\nint Var30;\nint Var31;\nint Var32;\nint Var33;\nint Var34;\nint Var35;\nint Var36;\nint Var37;\nint Var38;\nint Var39;\nint Var40;\nint Var41;\nint Var42;\nint Var43;\nint Var44;\nint Var45;\nint Var46;\nint Var47;\nint Var48;\nint Var49;\nint Var50;\nint Var51;\nint Var52;\nint Var53;\nint Var54;\nint Var55;\nint Var56;\nint Var57;\nint Var58;\nint Var59;\nint Var60;\nint Var61;\nint Var62;\nint Var63;\nint Var64;\nint Var65;\nint Var66;\nint Var67;\nint Var68;\nint Var69;\nint Var70;\nint Var71;\nint Var72;\nint Var73;\nint Var74;\nint Var75;\nint Var76;\nint Var77;\nint Var78;\nint Var79;\nint Var80;\nint Var81;\nint Var82;\nint Var83;\nint Var84;\nint Var85;\nint Var86;\nint Var87;\nint Var88;\nint Var89;\nint Var90;\nint Var91;\nint Var92;\nint Var93;\nint Var94;\nint Var95;\nint Var96;\nint Var97;\nint Var98;\nint Var99;\nint Var100;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut is this a practical way to do so?\u003c/p\u003e\u003cp\u003eOf course the answer is no, that’s why we have arrays.\u003c/p\u003e\u003cp\u003eWhat are arrays? \u003c/p\u003e\u003cp\u003eArrays are set of elements having same data type, allocated after each other in the memory and have a custom size.\u003c/p\u003e\u003cp\u003eThe last example can be done in one line of code using arrays:\u003c/p\u003e\u003cp\u003e\u003ccode\u003eint Var[100];\u003c/code\u003e\u003c/p\u003e\u003cp\u003ebig difference huh?\u003c/p\u003e\u003cp\u003eWhat this line does is simply creating 100 memory sequential integers so when we want to access the third element we access the element which comes after the array beginning (the index 0) by 3 positions (0, 1, 2) which means that the third element is Var[2].\u003c/p\u003e\u003cp\u003eIn general, when we want to access 1st, 2nd, 3rd elements we access them by Var[0], Var[1], Var[2].\u003c/p\u003e\u003cp\u003eNote that we can’t access element out of the array boundary. That is, if the size of array was 100, we can’t access arr[100],arr[101] and so on.\u003c/p\u003e\u003cp\u003eFormally, when we want to declare an array we do it by \u003c/p\u003e\u003cp\u003eData_type array_name[size];\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/e9/c0/e9c0942245ee5c1679b724cf6b317f6555efca85.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eEx:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint student[100];\n\ndouble price[50];\n\nchar name[20];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow, how we can assign a value to the elements of an array:\u003c/p\u003e\u003cp\u003eEx: make an array months where month[i] \u003d number of days in month i.\u003c/p\u003e\u003cp\u003e\u003ccode\u003eint month[12]\u003d{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\u003c/code\u003e\u003c/p\u003e\u003cp\u003eNote that when we want the first month we access it by month[0].\u003c/p\u003e\u003cp\u003eEx2: store 10 values from the user in an array\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint arr[10];\nfor(int i \u003d 0; i \u0026lt; 10 ; i++)\n    cin\u0026gt;\u0026gt;arr[i];\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eTwo Dimensional arrays:\u003c/h2\u003e\u003cp\u003eLet’s say that we want to store a 3*3 Tic-tac-toe board.\u003c/p\u003e\u003cp\u003eWe can easily create 3 arrays each of size 3\u003c/p\u003e \u003cpre\u003e\u003ccode\u003echar row1[3];\nchar row2[3];\nchar row3[3];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut what if we want to store a 500*500 version, will we do the same here?\u003c/p\u003e\u003cp\u003eOf course not, we can use two dimensional arrays (array of arrays/Matrix) to do so.\u003c/p\u003e\u003cp\u003eLike 1D array, 2D array is set of elements having same data type. However 2D array is organized as matrix with a numbers of rows and columns.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/3b/fe/3bfe0ef6b531c05a853649463a497475a5bafbdf.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eNow, we can easily make our 500*500 grid in a one line of code:\u003c/p\u003e\u003cp\u003e\u003ccode\u003echar grid[500][500];\u003c/code\u003e\u003c/p\u003e\u003cp\u003eNote we can access any element in 2D by:\u003c/p\u003e\u003cp\u003eArr[row_index][col_index]\u003c/p\u003e\u003cp\u003eEx: the third element in the first row is equal to arr[0][2].\u003c/p\u003e\u003cp\u003eFormally, we can declare a 2D array by:\u003c/p\u003e\u003cp\u003eData_type array_name[ rows_size ][ columns_size ];\u003c/p\u003e\u003cp\u003eEx: make a 2D array grid with 3 rows and 3 columns and set all elements to “X”.\u003c/p\u003e\u003cp\u003e\u003ccode\u003echar grid[3][3] \u003d { {\u0027X\u0027, \u0027X\u0027, \u0027X\u0027}, {\u0027X\u0027, \u0027X\u0027, \u0027X\u0027}, {\u0027X\u0027, \u0027X\u0027, \u0027X\u0027} };\u003c/code\u003e\u003c/p\u003e\u003cp\u003eEx2: take integer values from user and store them in 4*3 Matrix.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint arr[4][3];\nfor(int row\u003d0; row\u0026lt;4; row++)\n{\n    for(int col\u003d0; col\u0026lt;3; col++)\n    {\n        cin\u0026gt;\u0026gt;arr[row][col];\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}