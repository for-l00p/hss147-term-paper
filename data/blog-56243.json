{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1512757326,"rating":-24,"authorHandle":"BinaryBoy1","modificationTimeSeconds":1512758059,"id":56243,"title":"\u003cp\u003eheap code\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI did it as a heap project hope you enjoy it :)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eYour code here...\nconst int MAXN \u003d 1e5;\n\nstruct heap{\n\tpair \u0026lt;int , long long int \u0026gt; heaptree[ MAXN ];\n\tint vertexplace [ MAXN ] , treesize;\n\tvoid prepare()\n\t{\n\t\ttreesize \u003d 1;\n\t\tfor(int i \u003d 0 ; i \u0026lt; MAXN ; i++)\n\t\t\tvertexplace [ i ] \u003d heaptree[ i ].first \u003d heaptree[ i ].second \u003d -100000;\n\t}\n\tvoid normalize(int a)\n\t{\n\t\twhile(a !\u003d 1)\n\t\t{\n\t\t\tif(heaptree [ a ].second \u0026lt; heaptree [ a / 2 ].second)\n\t\t\t{\n\t\t\t\tswap ( heaptree [ a ] , heaptree[ a / 2 ]);\n\t\t\t\tswap(vertexplace[heaptree [ a ].first ] , vertexplace[ heaptree [ a / 2 ].first]);\n\t\t\t\ta \u003d a / 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tvoid add(int a , long long int b)\n\t{\n\t\tif(vertexplace[ a ] \u003d\u003d -100000)\n\t\t{\n\t\t\theaptree [ treesize ].first \u003d a;\n\t\t\theaptree [ treesize ].second \u003d b;\n\t\t\tvertexplace [ a ] \u003d treesize;\n\t\t\ttreesize++;\n\t\t}\n\t\telse {\n\t\t\theaptree [ vertexplace [ a ] ].second \u003d min ( heaptree [ vertexplace [ a ] ].second , b);\n\t\t}\n\t\tnormalize(vertexplace[ a ]);\n\t}\n\tint get_min()\n\t{\n\t\treturn heaptree [ 1 ].first;\n\t}\n\tlong long int get_minnum()\n\t{\n\t\treturn heaptree [ 1 ].second;\n\t}\n\tvoid erase_min()\n\t{\n\t\tint a \u003d 1;\n\t\tswap(heaptree [ a ] , heaptree [ treesize - 1 ]);\n\t\tif(treesize \u003d\u003d 2)\n\t\t\tswap(heaptree [ a ] , heaptree [ treesize ]);\n\t\ttreesize--;\n\t\twhile(2 * a \u0026lt; treesize)\n\t\t{\n\t\t\tif(heaptree[ a ].second \u0026gt; heaptree[ a * 2 ].second || (heaptree[ a ].second \u0026gt; heaptree[ a * 2 + 1].second \u0026amp;\u0026amp; a * 2 + 1 !\u003d treesize))\n\t\t\t{\n\t\t\t\tif(heaptree [ a * 2 ].second \u0026lt; heaptree[ a * 2 + 1 ].second || a * 2 + 1 \u003d\u003d treesize)\n\t\t\t\t{\n\t\t\t\t\tswap(heaptree [ a * 2 ] , heaptree [ a ]);\n\t\t\t\t\tswap(vertexplace[heaptree [ a ].first ] , vertexplace[ heaptree [ a * 2 ].first]);\n\t\t\t\t\ta \u003d a * 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tswap(heaptree [ a * 2 + 1 ], heaptree [ a ]);\n\t\t\t\t\tswap(vertexplace[heaptree [ a ].first ] , vertexplace[ heaptree [ a * 2 + 1 ].first]);\n\t\t\t\t\ta \u003d a * 2 + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n};\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["#heap","#code"]}}