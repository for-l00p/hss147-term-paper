{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1521820057,"rating":36,"authorHandle":"shash42","modificationTimeSeconds":1521820233,"id":58528,"title":"\u003cp\u003eAmortized Complexity and Rollbacks\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI have read this on various posts on Codeforces (some very old, some a little more recent) that Amortized Complexity algorithms lose this property when we perform rollbacks. An example: \u003ca href\u003d\"//codeforces.com/blog/entry/15296?#comment-310833\"\u003eComment by Retrograd here\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eRollbacks here means storing changes in some data structure and reversing back to the previous state until required.\u003c/p\u003e\u003cp\u003eWhile I would love a general answer, I am specifically asking for DSU Rollbacks with Path Compression. Is there any particular reason why it should not work? Intuitively I\u0027m performing just as many operations as I did to reach the new state to go back to the old state.\u003c/p\u003e\u003cp\u003eAlso some might state that between a Union and the time we rollback to it, there could be a 100 odd queries which would cause path compression. We lose all this data after rollback and have to recompute them for further queries. However I am not sure if this realllly messes up the complexity. Every query is still the same complexity?! Notice that this is rollbacks and not persistent DSU.\u003c/p\u003e\u003cp\u003eWhile I know union by size vs path compression is just \u003cb\u003eNlogN vs N*alpha\u003c/b\u003e, there\u0027s this particular problem that had me interested: \u003ca href\u003d\"https://www.codechef.com/problems/GERALD07\"\u003eCodechef â€” Chef and Graph Queries\u003c/a\u003e. I had implemented an \u003cb\u003eNRootNLogN\u003c/b\u003e solution with Mo\u0027s and DSU Rollbacks with Union by Size which TLE\u0027s despite many small optimizations. On the other hand the \u003ca href\u003d\"https://s3.amazonaws.com/codechef_shared/download/Solutions/2014/March/Tester/GERALD07.cpp\"\u003etester\u0027s solution\u003c/a\u003e does path compression with rollbacks. (Note I am aware a Mos+DSU solution without any rollbacks also exists, and it is quite beautiful but the question isn\u0027t about that). \u003c/p\u003e\u003cp\u003eI am attaching a rough implementation just for the idea:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eint find(int x)\n{\n\tif(par[x]\u003d\u003dx) return x;\n\tstk.push(mp(x, par[x]));\n\tpar[x]\u003dfind(par[x]);\n\treturn par[x];\n}\nvoid uni(int x, int y)\n{\n\tx\u003dfind(x); y\u003dfind(y);\n\tif(sz[y]\u0026gt;sz[x])\n\t{\n\t\tswap(x, y);\n\t}\n\tsz[x]+\u003dsz[y];\n\tsz[y]\u003d0;\n\tsizes.push(stk.size());\n\tstk.push(mp(y, par[y])); //also push the y component size here\n\tpar[y]\u003dx;\n}\nvoid rollback()\n{\n\tint lstsz\u003dsizes.top();\n\tstk.pop();\n\twhile(stk.size()\u0026gt;lstsz)\n\t{\n\t\tpar[stk.top().first]\u003dstk.top().second;\n\t\tstk.pop();\t\n\t}//also adjust the y component size here\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eTo sum it up, if we are really just reversing X operations, why would the complexity be more than 2*X, why do Amortized Algorithms fail on rollbacks. Thanks.\u003c/p\u003e\u003c/div\u003e","tags":["#dsu","amortized","complexity","rollback"]}}