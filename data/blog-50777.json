{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1488529821,"rating":11,"authorHandle":"drazil","modificationTimeSeconds":1488620300,"id":50777,"title":"\u003cp\u003eWeekly Training Farm #26 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e我們發現中文有一些顯示問題，之後會再處理。 The Chinese version has some display issue with latex for now.\u003c/p\u003e\u003cp\u003eA. Numbers\u003c/p\u003e\u003cp\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e \u0026gt; 0\u003c/span\u003e, then there are at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e - 1\u003c/span\u003e integers between the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e-th largest integer and the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e-smallest integer. So the answer would be \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003eX\u003c/i\u003e + \u003ci\u003eD\u003c/i\u003e - 1\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e \u003d 0\u003c/span\u003e, then the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e-th largest integer is the exactly same integer as the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e-smallest integer. So the answer is \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003eX\u003c/i\u003e - 1\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e \u0026lt; 0\u003c/span\u003e, then the case with the largest number of integers would be: the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e-smallest integer is the very next integer larger than the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e-largest integer if sorted ascendingly. So the answer would be \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003eX\u003c/i\u003e - 2\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eOverall, the answer can be expressed as \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003eX\u003c/i\u003e + \u003ci\u003emax\u003c/i\u003e(\u003ci\u003eD\u003c/i\u003e - 1,  - 2)\u003c/span\u003e. Time complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e如果 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e \u0026gt; 0\u003c/span\u003e，則第 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e 大的數跟第 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e 小的數之間最多有 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e - 1\u003c/span\u003e 個數字。所以答案為 $2X + D — 1$。 如果 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e \u003d 0\u003c/span\u003e，則第 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e 大的數跟第 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e 小的數其實是同一個數字。所以答案為 $2X — 1$。 如果 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e \u0026lt; 0\u003c/span\u003e，則最多數字的情況為：如果由小到大排序後，第 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e 小的數恰好排在第 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e 大的數之後。所以答案為 $2X — 2$。\u003c/p\u003e\u003cp\u003e整體而言，答案可以寫成 $2X + \\max(D — 1, -2)$。時間複雜度為 $O(1)$。\u003c/p\u003e\u003cp\u003eB. Power\u003c/p\u003e\u003cp\u003eThere are at most \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e discrete time in the logs so if we can find out how many computers are in use at each time, we can calculate the final answer by summing the cost at each time in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e)\u003c/span\u003e time. In order to find out that number, we could scan through the log and accumulate the number of on events and off events at each time which takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time. After that, just simulate those events time by time to get the number of computers in use at each time.\u003c/p\u003e\u003cp\u003eTime complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003emax\u003c/i\u003e(\u003ci\u003et\u003c/i\u003e))\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e時間的最大值為 \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e，也就是說如果我們可以對每個時間點找出有幾台電腦正在運作中，就可以把每個時間點的花費加總起來而得到最終答案。找出每個時間點有幾台電腦正在運作中的方法為，用 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e 的時間掃描一次紀錄檔，並且統計每個時間點開機了幾次跟關機了幾次。之後就可以按照時間模擬這些開關機的事件以求出對於毎個時間有多少台電腦正在運作。\u003c/p\u003e\u003cp\u003e時間複雜度為 $O(n + max(t))$。\u003c/p\u003e\u003cp\u003eC. Robot and Maze\u003c/p\u003e\u003cp\u003eIn a word, depth first search. But watch out for stepping into visited blocks to avoid looping. Moreover, you need to issue a command to go back to the previous block in the calling stack. You can use no more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eanswer\u003c/i\u003e × 4\u003c/span\u003e moving commands to solve this task.\u003c/p\u003e\u003cp\u003eTime complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eanswer\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e簡而言之，深度優先搜尋(DFS)。必須注意的點是，避免重複踏入相同的格子內造成迴圈。另外，在返回上一層函式的同時必須命令機器人移動一次回到上一層的位置。你可以只使用 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eanswer\u003c/i\u003e × 4\u003c/span\u003e 次移動命令來解這一題。\u003c/p\u003e\u003cp\u003e時間複雜度為 $(answer)$。\u003c/p\u003e\u003cp\u003eD. Combination\u003c/p\u003e\u003cp\u003eFirstly, you have to use inverse modular to deal with the division in the calculations. The combination function is straight forward but there are cases that the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e would become \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e for some intermediate values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e because of the modular operation. One way to handle this is to maintain the current \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e using the form \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sup\u003e × \u003ci\u003er\u003c/i\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is the largest possible integer. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d 0\u003c/span\u003e we know \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e) \u003d \u003ci\u003er\u003c/i\u003e \u003ci\u003emod\u003c/i\u003e \u003ci\u003ep\u003c/i\u003e\u003c/span\u003e, otherwise we know \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e) \u003d 0 \u003ci\u003emod\u003c/i\u003e \u003ci\u003ep\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLet\u0027s consider a scenario to illustrate the meaning of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. The task is to maintain the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003ci\u003emod\u003c/i\u003e 3\u003c/span\u003e with multiple and division operations. Initially \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 2\u003c/span\u003e and the operations are 1.) multiply by \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e then 2.) divide by \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e. If we just simulate each step, we would have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 0\u003c/span\u003e when the first operation is applied and never recover the true value after the second operation. So, with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, we would have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d 0, \u003ci\u003en\u003c/i\u003e \u003d 2\u003c/span\u003e initially. After the first operation we would have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d 1, \u003ci\u003en\u003c/i\u003e \u003d 2\u003c/span\u003e. Since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e ≠ 0\u003c/span\u003e so we would know the answer is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e now. After the second operation, we would have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d 0, \u003ci\u003en\u003c/i\u003e \u003d 2\u003c/span\u003e which preserves the truth that the answer is \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWhen maintaining \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e. There are two operations: multiple and division. To multiple by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, first we find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u0027, \u003ci\u003er\u003c/i\u003e\u0027\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e \u003d \u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u0027\u003c/sup\u003e × \u003ci\u003er\u003c/i\u003e\u0027\u003c/span\u003e, then do \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003ex\u003c/i\u003e + \u003ci\u003ex\u003c/i\u003e\u0027, \u003ci\u003er\u003c/i\u003e \u003d \u003ci\u003er\u003c/i\u003e × \u003ci\u003er\u003c/i\u003e\u0027\u003c/span\u003e. To divide by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, first we find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u0027, \u003ci\u003er\u003c/i\u003e\u0027\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e \u003d \u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u0027\u003c/sup\u003e × \u003ci\u003er\u003c/i\u003e\u0027\u003c/span\u003e, then do \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003ex\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e\u0027, \u003ci\u003er\u003c/i\u003e \u003d \u003ci\u003er\u003c/i\u003e × \u003ci\u003emodular\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003einverse\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003er\u003c/i\u003e\u0027)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTime complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e3/d8/e3d83eb26148fbcdc8dd5803a142f636f436da2d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003e首先，你必須使用 inverse modular 去處理除法的問題。計算組合的方法很直覺，但是這題中會有一些情況下，$C(a + k, b + k)\u003c/p\u003e\u003cp\u003eUnable to parse markup [type\u003dCF_TEX]\u003c/p\u003e 值因為取餘數的關係會變成 \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e。一個處理的方法為，用 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sup\u003e × \u003ci\u003er\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e 是最大可能的整數) 的形式紀錄 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e 的值。如果 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d 0\u003c/span\u003e 我們有 $C(a + k, b + k) \u003d r\\ mod\\ p$，否則有 $C(a + k, b + k) \u003d 0\\ mod\\ p$。\u003cp\u003e時間複雜度為 $O((b + n) \\times [\\log_p(a+n) + \\log(p)])$。\u003c/p\u003e\u003cp\u003eE. Disk Raid\u003c/p\u003e\u003cp\u003eThe key is to use matrix operations inside a segment tree (or similar data structures). In a segment tree, each node will be associated with a range \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e]\u003c/span\u003e. In each node, we store a vector \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003c/span\u003e of size \u003cspan class\u003d\"tex-span\"\u003e1 × (\u003ci\u003en\u003c/i\u003e + 1)\u003c/span\u003e where the element at position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003en\u003c/i\u003e\u003c/span\u003e is the sum of the disk values in the range (i.e. \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/49/9f/499f9b042133eccede888f08b7979795f47de087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e) and the last element is the size of the range (i.e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e - \u003ci\u003eL\u003c/i\u003e + 1\u003c/span\u003e). Each operation can be applied to such vector by a matrix multiplication \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u0027 \u003d \u003ci\u003eV\u003c/i\u003e × \u003ci\u003eM\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eop\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. We\u0027ll describe how to construct such matrix for each operation below. Here we take \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 2\u003c/span\u003e as example.\u003c/p\u003e\u003cp\u003e這題的關鍵為在 segment tree (或類似的結構裡) 使用矩陣運算。在 segment tree 中，毎一個 node 代表一個範圍 \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e]\u003c/span\u003e。在每一個 node 裡面，我們存一個 \u003cspan class\u003d\"tex-span\"\u003e1 × (\u003ci\u003en\u003c/i\u003e + 1)\u003c/span\u003e 的 vector \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003c/span\u003e，\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003c/span\u003e 中位置 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003en\u003c/i\u003e\u003c/span\u003e) 的元素為範圍內硬碟 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e 的值的總和 (也就是 \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/49/9f/499f9b042133eccede888f08b7979795f47de087.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e))，而最後一個元素的值為範圍的大小 (也就是 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e - \u003ci\u003eL\u003c/i\u003e + 1\u003c/span\u003e)。毎一個操作都可以看作為一次矩陣乘法 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u0027 \u003d \u003ci\u003eV\u003c/i\u003e × \u003ci\u003eM\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eop\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e。下面我們會描述要如何構造這些矩陣，以 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 2\u003c/span\u003e 為例。\u003c/p\u003e\u003cp\u003eCopy operation from disk \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e to disk \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e: Copy 操作，從硬碟 \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e 到硬碟 $1$：\u003cbr /\u003e1 1 0\u003cbr /\u003e0 0 0\u003cbr /\u003e0 0 1 \u003c/p\u003e\u003cp\u003eModify operation for disk \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e: Modify 操作，對於硬碟 $0$：\u003cbr /\u003ep1 0 0\u003cbr /\u003e0 1 0\u003cbr /\u003ep2 0 1 \u003c/p\u003e\u003cp\u003eAdvancedModify operation reading from disk \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e and writing to disk \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e: AdvancedModify 操作，從硬碟 \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e 中讀取，寫入硬碟 $1$：\u003cbr /\u003e1 p 0\u003cbr /\u003e0 1 0\u003cbr /\u003e0 0 1 \u003c/p\u003e\u003cp\u003eSwap operation for disk \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e and disk \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e: Swap 操作，交換硬碟 \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e 跟硬碟 $1$：\u003cbr /\u003e0 1 0\u003cbr /\u003e1 0 0\u003cbr /\u003e0 0 1 \u003c/p\u003e\u003cp\u003eUsing the \u003cspan class\u003d\"tex-span\"\u003e32\u003c/span\u003e-bit unsigned integer data type would solve the modular issue natively. Time complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b8/ba/b8bacff52c149ab01a5774f7a3e7a063e0ad5c58.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003e使用 \u003cspan class\u003d\"tex-span\"\u003e32\u003c/span\u003e 位元的無號整數資料結構可以解決取餘數的問題。時間複雜度為 $O(n^3q\\log w)$。\u003c/p\u003e\u003c/div\u003e","tags":[]}}