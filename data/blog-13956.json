{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1411640305,"rating":-14,"authorHandle":"HekpoMaH","modificationTimeSeconds":1411731409,"id":13956,"title":"\u003cp\u003eSegment tree with lazy update.\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eYou are given the following queries over n elements:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eQuery No.1:\u003c/strong\u003e Increase elements between a and b with value c (it\u0027s possible that c is negative).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eQuery No.2:\u003c/strong\u003e Get maximal value of all elements (e.g. max(a[i]) 1\u0026lt;\u003di\u0026lt;\u003dn)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint lazy[1000],mx[1000],idx[1000];\nstruct node{\n   int ll,rr,id;\n   node(int L,int R,int X){\n      ll\u003dL;\n      rr\u003dR;\n      id\u003dX;\n      lazy_update();\n   }\n   node left(){\n      return node(ll,(ll+rr)/2,id*2);\n   }\n   node right(){\n      return node((ll+rr)/2+1,rr,id*2+1);\n   }\n   void lazy_update(){\n      if(lazy[id]\u003d\u003d0)return;\n      mx[id]+\u003dlazy[id];\n      if(ll!\u003drr){\n         lazy[id*2]+\u003dlazy[id];\n         lazy[id*2+1]+\u003dlazy[id];\n      }\n      lazy[id]\u003d0;\n   }\n   void assign_range(int l,int r,int x){\n      lazy_update();\n      if(ll\u0026gt;r||l\u0026gt;rr)return;\n      if(ll\u003d\u003drr){\n         idx[id]\u003dll;\n      }\n      if(l\u0026lt;\u003dll\u0026amp;\u0026amp;rr\u0026lt;\u003dr){\n         lazy[id]+\u003dx;\n         lazy_update();\n         return;\n      }\n      left().assign_range(l,r,x);\n      right().assign_range(l,r,x);\n      if(mx[id*2]\u0026gt;mx[id*2+1]){\n         mx[id]\u003dmx[id*2];\n         idx[id]\u003didx[id*2];\n      }\n      else{\n         mx[id]\u003dmx[id*2+1];\n         idx[id]\u003didx[id*2+1];\n      }\n   }\n   int max_range(int l,int r){\n      if(ll\u0026gt;r||l\u0026gt;rr)return -1e9;\n      lazy_update();\n      if(l\u0026lt;\u003dll\u0026amp;\u0026amp;rr\u0026lt;\u003dr){\n         return mx[id];\n      }\n      int mx1\u003dleft().max_range(l,r);\n      int mx2\u003dright().max_range(l,r);\n      return max(mx1,mx2);\n   }\n};\nint main(){\n   node root(1,6,1);\n   int m;\n   cin\u0026gt;\u0026gt;m;\n   for(int i\u003d1;i\u0026lt;\u003dm;i++){\n      int a,b,c;\n      cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c;\n      root.assign_range(a,b,c);\n      cout\u0026lt;\u0026lt;root.max_range(1,6)\u0026lt;\u0026lt;\u0026quot;\\n\u0026quot;;\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI managed to make a solution with segment trees using \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/kien_coi_1997\" title\u003d\"Master kien_coi_1997\"\u003ekien_coi_1997\u003c/a\u003e style, but it doesn\u0027t work properly. My idea is the following: when a interval (ll,rr) fits in the query interval, increase the maximum with c and update all nodes of the tree up to the root. I\u0027m not sure when I need to put lazy_update and therefore i got WA on the following test case. In the code above after each query of the first type I output the maximal among all elements. \u003c/p\u003e\u003cp\u003e\u003cem\u003e12\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003e1 1 1\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003e2 2 2\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003e3 3 3\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003e4 4 4\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003e5 5 5\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003e6 6 6\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003e1 3 4\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003e3 6 -2\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003e1 2 -2\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003e3 3 -2\u003c/em\u003e \u003c/p\u003e\u003cp\u003e\u003cem\u003e2 5 3\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003e2 4 -2\u003c/em\u003e\u003c/p\u003e\u003cp\u003eIf you write on a sheet of paper the above test, you will see that after the last query my program outputs \u003cstrong\u003e5\u003c/strong\u003e but the answer is \u003cstrong\u003e6\u003c/strong\u003e. Any help will be highly appreciated :\u0026quot;).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eP.S.\u003c/strong\u003e If you are wondering why my code looks a bit \u0026quot;strange\u0026quot;, that\u0027s because it\u0027s a part of the following \u003ca href\u003d\"http://www.math.bas.bg/infos/files/2013-11-24-A3_eng.pdf\"\u003etask\u003c/a\u003e. It is really interesting and I could explain a solution to everyone who wants to hear it.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD.\u003c/strong\u003e The task was solved. The code above was updated.\u003c/p\u003e\u003c/div\u003e","tags":["segment tree","lazy propagation","lazy updates","kien_coi_1997 style","trees"]}}