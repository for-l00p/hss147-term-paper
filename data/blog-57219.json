{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1516370471,"rating":0,"authorHandle":"ValgesMalges","modificationTimeSeconds":1516371314,"id":57219,"title":"\u003cp\u003eWeek 4\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eLast week Hamza Zagha [user:@light] explained some data structures that will help you to solve so many questions and this is his blog to explain them\u003c/p\u003e\u003ch2\u003e- Queue:\u003c/h2\u003e\u003cp\u003eA queue is a FIFO data structure (First In First Out), that stores the data the same order they\u0027re inserted in it, and allows inserting elements and removing them in O(1) complexity. Note that we can only access the \u0026quot;front\u0026quot; element in a queue.\u003c/p\u003e\u003cp\u003eNeeds: \u003ccode\u003e#include \u0026lt;queue\u0026gt;\u003c/code\u003e\u003c/p\u003e\u003cp\u003eDeclaration and functions:\u003c/p\u003e\u003cp\u003e\u003ccode\u003equeue\u0026lt;int\u0026gt; q;\u003c/code\u003e //we can make it of any data type\u003c/p\u003e\u003cp\u003e\u003ccode\u003eq.push(1);\u003c/code\u003e //inserts elements in the queue O(1)\u003c/p\u003e\u003cp\u003e\u003ccode\u003eq.push(2);\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003eq.empty();\u003c/code\u003e //returns a boolean whether it\u0027s empty O(1) (true -\u0026gt; empty/ false -\u0026gt; not empty)\u003c/p\u003e\u003cp\u003e\u003ccode\u003eq.pop();\u003c/code\u003e //removes the first element inserted in the queue O(1) (Be sure it\u0027s not already empty!)\u003c/p\u003e\u003cp\u003e\u003ccode\u003eq.front()\u003c/code\u003e //returns the value of the first element in the queue O(1)\u003c/p\u003e\u003ch2\u003e- Stack:\u003c/h2\u003e\u003cp\u003eA stack is a LIFO data structure (Last In First Out), that stores the data the reversed order they\u0027re inserted in it, and allows inserting elements and removing them in O(1) complexity. Note that we can only access the \u0026quot;top\u0026quot; element in a stack.\u003c/p\u003e\u003cp\u003eNeeds: \u003ccode\u003e#include \u0026lt;stack\u0026gt;\u003c/code\u003e\u003c/p\u003e\u003cp\u003eDeclaration and functions:\u003c/p\u003e\u003cp\u003e\u003ccode\u003estack\u0026lt;int\u0026gt; s;\u003c/code\u003e //we can make it of any data type\u003c/p\u003e\u003cp\u003e\u003ccode\u003es.push(1);\u003c/code\u003e //inserts elements in the stack O(1)\u003c/p\u003e\u003cp\u003e\u003ccode\u003es.push(2);\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003es.empty();\u003c/code\u003e //returns a boolean whether it\u0027s empty O(1) (true -\u0026gt; empty/ false -\u0026gt; not empty)\u003c/p\u003e\u003cp\u003e\u003ccode\u003es.pop();\u003c/code\u003e //removes the last element inserted in the stack O(1) (Be sure it\u0027s not already empty!)\u003c/p\u003e\u003cp\u003e\u003ccode\u003es.top()\u003c/code\u003e //returns the value of the top element in the stack O(1)\u003c/p\u003e\u003ch2\u003e- Priority Queue:\u003c/h2\u003e\u003cp\u003eA priority queue is a data structure, that stores the data in a special way such that it will always give us the maximum element in it. But to be able to do so, the complexity of inserting and erasing elements from it is O(logn). Note that we can only access the \u0026quot;top\u0026quot; element in a priority queue.\u003c/p\u003e\u003cp\u003eNeeds: \u003ccode\u003e#include \u0026lt;queue\u0026gt;\u003c/code\u003e\u003c/p\u003e\u003cp\u003eDeclaration and functions:\u003c/p\u003e\u003cp\u003e\u003ccode\u003epriority_queue\u0026lt;int\u0026gt; pq;\u003c/code\u003e //we can make it of any data type\u003c/p\u003e\u003cp\u003e\u003ccode\u003epq.push(1);\u003c/code\u003e //inserts elements in the queue O(logn)\u003c/p\u003e\u003cp\u003e\u003ccode\u003epq.push(2);\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003epq.empty();\u003c/code\u003e //returns a boolean whether it\u0027s empty O(1) (true -\u0026gt; empty/ false -\u0026gt; not empty)\u003c/p\u003e\u003cp\u003e\u003ccode\u003epq.pop();\u003c/code\u003e //removes the maximum element in the queue O(logn) (Be sure it\u0027s not already empty!)\u003c/p\u003e\u003cp\u003e\u003ccode\u003epq.top()\u003c/code\u003e //returns the value of the maximum element in the queue O(1)\u003c/p\u003e\u003ch2\u003e- Set:\u003c/h2\u003e\u003cp\u003eA set is a data structure that stores the data in it such that at all times, all the elements in it are sorted which can help us in searching for elements using binary search in O(logn), but it has no index so we can\u0027t know whats the 5th element in it or so, and because the way it stores elements, adding and removing elements from it is O(logn). Also note that a set only contains distinct elements, if we want repetitions we can use a \u0026quot;multiset\u0026quot; (read about it). And we can traverse its elements by using an \u0026quot;iterator\u0026quot; (like a pointer) such that from each element we can only access the next or previous element by using ++ or --.\u003c/p\u003e\u003cp\u003eNeeds:\u003ccode\u003e#include \u0026lt;set\u0026gt;\u003c/code\u003e\u003c/p\u003e\u003cp\u003eDeclaration and functions:\u003c/p\u003e\u003cp\u003e\u003ccode\u003eset\u0026lt;int\u0026gt; st;\u003c/code\u003e //we can make it of any data type\u003c/p\u003e\u003cp\u003e\u003ccode\u003eset\u0026lt;int\u0026gt;::iterator it;\u003c/code\u003e //declares an iterator to iterate over the set (now it has garbage value)\u003c/p\u003e\u003cp\u003e\u003ccode\u003est.insert(1);\u003c/code\u003e //inserts elements in the set O(logn)\u003c/p\u003e\u003cp\u003e\u003ccode\u003est.insert(2);\u003c/code\u003e\u003c/p\u003e\u003cp\u003e//O(logn):\u003c/p\u003e\u003cp\u003e\u003ccode\u003eit\u003dst.lower_bound(1)\u003c/code\u003e //returns an iterator to the first element greater than or equal to 1, or st.end() if there\u0027s none\u003c/p\u003e\u003cp\u003e\u003ccode\u003eit\u003dst.upper_bound(1)\u003c/code\u003e //returns an iterator to the first element greater than 1, or st.end() if there\u0027s none\u003c/p\u003e\u003cp\u003e\u003ccode\u003eit\u003dst.find(1)\u003c/code\u003e //returns an iterator to the first element that equals 1, or st.end() if there\u0027s none\u003c/p\u003e\u003cp\u003e\u003ccode\u003est.erase(val);\u003c/code\u003e //removes the element \u0026quot;val\u0026quot; from the set if it\u0027s found O(logn)\u003c/p\u003e\u003cp\u003e\u003ccode\u003est.erase(it);\u003c/code\u003e //removes the element that the iterator it points at O(1), be sure it\u0027s not garbage or st.end()\u003c/p\u003e\u003cp\u003e\u003ccode\u003est.empty();\u003c/code\u003e //returns a boolean whether it\u0027s empty O(1) (true -\u0026gt; empty/ false -\u0026gt; not empty)\u003c/p\u003e\u003cp\u003e\u003ccode\u003est.clear();\u003c/code\u003e //clears the set and removes all the elements in it O(n)\u003c/p\u003e\u003ch2\u003e- Map:\u003c/h2\u003e\u003cp\u003eA map is a data structure that stores the data in it as pairs of keys and values (key,value) which can be of different data types, so the key is used as an index for the map and the value is the value stored in that index. Also it stores the data in a way such that at all times, all the elements in it are sorted which can help us in searching for elements using binary search in O(logn), but it has no index so we can\u0027t know whats the 5th element in it or so, and because the way it stores elements, adding and removing elements from it is O(logn). And we can traverse its elements by using an \u0026quot;iterator\u0026quot; (like a pointer) such that from each element we can only access the next or previous element by using ++ or --.\u003c/p\u003e\u003cp\u003eNeeds: \u003ccode\u003e#include \u0026lt;map\u0026gt;\u003c/code\u003e\u003c/p\u003e\u003cp\u003eDeclaration and functions:\u003c/p\u003e\u003cp\u003e\u003ccode\u003emap\u0026lt;string, int\u0026gt; mp;\u003c/code\u003e //we can make it of any data type\u003c/p\u003e\u003cp\u003e\u003ccode\u003emap\u0026lt;string, int\u0026gt;::iterator it;\u003c/code\u003e //declares an iterator to iterate over the map (now it has garbage value)\u003c/p\u003e\u003cp\u003emp[\u0026quot;Hamza\u0026quot;] \u003d 0; //inserts or edits existing elements in the map O(logn)\u003c/p\u003e\u003cp\u003emp[\u0026quot;Amal\u0026quot;] \u003d 1;\u003c/p\u003e\u003cp\u003emp[\u0026quot;Mariam\u0026quot;] \u003d 2; //Now the map contains: [(\u0026quot;Amal\u0026quot;, 1), (\u0026quot;Hamza\u0026quot;, 0), (\u0026quot;Mariam\u0026quot;, 2)]\u003c/p\u003e\u003cp\u003emp[\u0026quot;Hamza\u0026quot;] \u003d 3; //Now the map contains: [(\u0026quot;Amal\u0026quot;, 1), (\u0026quot;Hamza\u0026quot;, 3), (\u0026quot;Mariam\u0026quot;, 2)]\u003c/p\u003e\u003cp\u003e//O(logn):\u003c/p\u003e\u003cp\u003e\u003ccode\u003eit\u003dmp.lower_bound(\u0026quot;Hamza\u0026quot;)\u003c/code\u003e //returns an iterator to the first element that has a key greater than or equal to \u0026quot;Hamza\u0026quot;, or mp.end() if there\u0027s none\u003c/p\u003e\u003cp\u003e\u003ccode\u003eit\u003dmp.upper_bound(\u0026quot;Hamza\u0026quot;)\u003c/code\u003e //returns an iterator to the first element that has a key greater than \u0026quot;Hamza\u0026quot;, or mp.end() if there\u0027s none\u003c/p\u003e\u003cp\u003e\u003ccode\u003eit\u003dmp.find(\u0026quot;Hamza\u0026quot;)\u003c/code\u003e //returns an iterator to the first element that has a key that equals to \u0026quot;Hamza\u0026quot;, or mp.end() if there\u0027s none\u003c/p\u003e\u003cp\u003e\u003ccode\u003emp.erase(\u0026quot;Hamza\u0026quot;);\u003c/code\u003e //removes the element that has key \u0026quot;Hamza\u0026quot; from the map if it\u0027s found O(logn)\u003c/p\u003e\u003cp\u003e\u003ccode\u003emp.erase(it);\u003c/code\u003e //removes the element that the iterator it points at O(1), be sure it\u0027s not garbage or st.end()\u003c/p\u003e\u003cp\u003e\u003ccode\u003emp.empty();\u003c/code\u003e //returns a boolean whether it\u0027s empty O(1) (true -\u0026gt; empty/ false -\u0026gt; not empty)\u003c/p\u003e\u003cp\u003e\u003ccode\u003emp.clear();\u003c/code\u003e //clears the map and removes all the elements in it O(n)\u003c/p\u003e\u003cp\u003eThat\u0027s all, if you want to learn more you can read about \u0026quot;Multiset\u0026quot; and \u0026quot;Deque\u0026quot; also found in STL! Train well :D\u003c/p\u003e\u003c/div\u003e","tags":[]}}