{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1486987564,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1487534627,"id":50397,"title":"\u003cp\u003eМассивы: некоторые приёмы работы (FAQ)\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eВ этой записи мы рассмотрим некоторые типичные приёмы работы с массивами, которые могут пригодиться в разных задачах.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Как и где объявлять массив?\u003c/p\u003e\u003cp\u003eКак и любую другую переменную, массив можно объявить в классе (содержащем \u0026quot;логику\u0026quot;), а можно — внутри какого-либо метода. Если массив используется только внутри этого метода (например, в каких-то вспомогательных целях), то объявить его именно внутри метода, как правило, хорошая идея — когда метод завершит свою работу, память, связанная с этим массивом, будет автоматически очищена. Если же массив используется не в одном методе, то, разумеется, он должен быть объявлен как поле класса. \u003cbr /\u003e Объявление массива состоит из типа элементов массива, квадратных скобок (в количестве, соответствующем размерности массива), а также имени массива. Тип элемента может быть любым, в том числе массивом или объектным типом (например, \u003cem\u003eString\u003c/em\u003e). \u003c/p\u003e\u003cp\u003eПримеры объявления массивов:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint[] a; // одномерный массив целых чисел\ndouble[][] mx; // двумерный массив вещественных чисел\nboolean[] used; // одномерный массив логических значений\nString [] words; // одномерный массив строк\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e. Массив объявили, что делать потом?\u003c/p\u003e\u003cp\u003eОбъявление массива — это заявление о намерениях; прежде, чем к элементам массива можно будет обращаться, необходимо выделить для массива память. Если массив объявлен как поле класса, выделение памяти для него можно провести в конструкторе класса. Если же массив объявлен внутри метода, то все действия с массивом будут происходить только внутри этого метода, поэтому в дальнейшем мы не будем уточнять этот момент. \u003c/p\u003e\u003cp\u003eПримеры выделения памяти под массивы:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003emx \u003d new double[5][3]; // двумерный массив из 5 строк и 3 столбцов\n\nint n \u003d 10;\na \u003d new int[n]; // одномерный массив из 10 элементов\n\nused \u003d new boolean[a.length]; // одномерный массив логических значений, имеющий такую же длину, как и массив a\n\nwords \u003d new String[2*n]; // одномерный массив строк из 20 элементов\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e. Заполнение массива.\u003c/p\u003e\u003cp\u003eКогда под массив выделяется память, то он заполняется \u0026quot;нулевыми значениями\u0026quot; (в том смысле, в каком нулевые значения понимаются в данном типе). Если речь о целых или вещественных числах, то, конечно это \u0026quot;обычные\u0026quot; нули. Массивы логических значений при создании заполняются значением \u003cem\u003efalse\u003c/em\u003e, символьные (char) — символом с кодом \u003cem\u003e0\u003c/em\u003e. При решении задач этим фактом можно пользоваться. \u003c/p\u003e\u003cp\u003eРазумеется, достаточно типична ситуация, когда элементы массива вводятся (с клавиатуры или из файла). Вот, например, как будет выглядеть код для ситуации, когда задается количество элементов массива, после чего они считываются с клавиатуры.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eScanner in \u003d new Scanner(System.in);\nn \u003d in.nextInt();\na \u003d new int[n];\nfor (int i \u003d 0; i \u0026lt; n; i++){\n    a[i] \u003d in.nextInt();\n}\nin.close();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбратите внимание на следующие важные моменты: \u003cbr /\u003e - элементы массива нумеруются с 0; \u003cbr /\u003e - обращение к элементу массива выглядит так: \u003ccode\u003eимя переменной-массива [индекс]\u003c/code\u003e\u003c/p\u003e\u003cp\u003eВ случае двумерного целочисленного массива, например, состоящего из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e строк и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e столбцов, заполнение массива будет выглядеть так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eScanner in \u003d new Scanner(System.in);\nn \u003d in.nextInt();\nm \u003d in.nextInt();\nb \u003d new int[n][m];\nfor (int i \u003d 0; i \u0026lt; n; i++){\n    for (int j \u003d 0; j \u0026lt; m; j++){\n        b[i][j] \u003d in.nextInt();\n    }\n}\nin.close();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКонечно, здесь предполагается, что элементы массива вводятся построчно (т.е. сначала все элементы нулевой строки, затем все элементы первой строки и т.д.)\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e. Проход по массиву (если элементы меняются)\u003c/p\u003e\u003cp\u003eПредположим, что элементы массива должны каким-то образом меняться. Например, предположим, что мы хотим заполнить целочисленный массив \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e элементов числами Фибоначчи (мы считаем, что массив уже объявлен, память под него выделена, все элементы обнулены). \u003c/p\u003e\u003cp\u003eКак, вероятно, вы помните, числа Фибоначчи определяются следующим образом:\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c4/63/c4632b5ea2bd9f6124715991cb463625a954858b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eЭто несложно записать для массива:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ef[0] \u003d f[1] \u003d 1;\nfor (int i \u003d 2; i \u0026lt; n; i++){\n    f[i] \u003d f[i-1] + f[i-2];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбратите внимание: начальное значение переменной цикла — 2, поскольку элементы с индексами 0 и 1 получили значение до цикла.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e. Проход по массиву (без изменения элементов)\u003c/p\u003e\u003cp\u003eПредположим, что нам нужно посчитать, сколько раз в целочисленном массиве \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e длины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e встречается некоторое целое число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e (мы опять же считаем, что все объявления сделаны, память выделена, после чего массив \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e был заполнен). Будем сохранять результат в целочисленной переменной \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint q \u003d 0; \nfor (int elem: a) {\n    if (elem \u003d\u003d b) {\n        q++;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбратите внимание: мы воспользовались специальной формой цикла \u003ccode\u003efor\u003c/code\u003e (эта форма может применяться и к \u003cem\u003eколлекциям\u003c/em\u003e, которые пока не стали предметом нашего рассмотрения). Общий вид \u0026quot;заголовка\u0026quot; такой формы: \u003ccode\u003efor (тип_элемента_массива имя_переменной: имя_массива)\u003c/code\u003e. \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e6\u003c/span\u003e. Вывод элементов массива\u003c/p\u003e\u003cp\u003eВ некоторых задачах требуется преобразовать массив каким-либо образом и вывести результат. Предположим, что нам надо вывести в одну строчку через пробел подряд все элементы одномерного массива \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e длины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Это можно сделать следующим образом:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eboolean first \u003d true;\nfor (int elem: a){\n    if (first) {\n        first \u003d false;\n    }\n    else {\n        System.out.print(\u0027 \u0027);\n    }\n    System.out.print(elem);\n}\nSystem.out.println();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбратите внимание на переменную \u003ccode\u003efirst\u003c/code\u003e. Её задача — обеспечить аккуратный (без лишних пробелов) вывод всех элементов массива. При входе в цикл переменная \u003ccode\u003efirst\u003c/code\u003e имеет значение \u003ccode\u003etrue\u003c/code\u003e, поэтому в соответствующей ветви оператора \u003ccode\u003eif\u003c/code\u003e внутри цикла происходит замена значения \u003ccode\u003efirst\u003c/code\u003e c \u003ccode\u003etrue\u003c/code\u003e на \u003ccode\u003efalse\u003c/code\u003e. На этом выполнение \u003ccode\u003eif\u003c/code\u003e завершается, после чего печатается первый (нулевой) элемент. \u003c/p\u003e\u003cp\u003eНа всех последующих итерациях цикла переменная \u003ccode\u003efirst\u003c/code\u003e имеет значение \u003ccode\u003efalse\u003c/code\u003e, что приводит к печати пробела перед очередным элементом. \u003c/p\u003e\u003cp\u003eНаконец, после цикла стоит вызов \u003ccode\u003eprintln()\u003c/code\u003e, приводящий к переводу строки (это бывает оправданно в некоторых случаях; в том числе при написании соревнований).\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e7\u003c/span\u003e. Существует полезный класс \u003ccode\u003eArrays\u003c/code\u003e, в котором определён ряд статических методов, решающих некоторые типичные при работе с массивами задачи. Настоятельно рекомендуется изучить список его методов (впоследствии мы познакомимся ещё с классом \u003ccode\u003eCollections\u003c/code\u003e, имеющим более широкий набор методов).\u003c/p\u003e\u003cp\u003eКратко скажем о некоторых методах.\u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003eArrays.fill()\u003c/code\u003e может заполнить массив или его часть некоторым заданным значением. При создании все массивы заполняются \u0026quot;нулями\u0026quot; (в смысле их типа данных), иногда же нужно другое.\u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003eArrays.copyOf()\u003c/code\u003e копирует один массив в другой, при необходимости обрезая копируемый или, напротив, дополняя его \u0026quot;нулями\u0026quot;. Метод \u003ccode\u003eArrays.copyOfRange()\u003c/code\u003e делает по сути то же самое, только может копировать массив не целиком, а фрагментом.\u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003eArrays.sort()\u003c/code\u003e сортирует массив так, чтобы его элементы находились в \u0026quot;естественном порядке\u0026quot; (для чисел — по неубыванию, для строк — в лексикографическом порядке). \u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003eArrays.binarySearch()\u003c/code\u003e отыскивает в \u003cem\u003eотсортированном\u003c/em\u003e массиве заданный элемент. Если элемент найден, в качестве результата метода сообщается номер этого элемента, причём если таких элементов несколько, то номер какого из них окажется результатом — неизвестно. Если же элемента в массиве нет, в качестве результата возвращается \u003cspan class\u003d\"tex-span\"\u003e( - (\u003ci\u003einsertionpoint\u003c/i\u003e) - 1)\u003c/span\u003e (в обозначениях документации), где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003einsertionpoint\u003c/i\u003e\u003c/span\u003e — позиция, в которую был бы помещён искомый элемент, если бы мы захотели его вставить в этот массив; де-факто — номер первого элемента, который больше искомого. \u003cbr /\u003e Заметим, что бинарный поиск можно проводить не в целом массиве, а в некотором его подмассиве.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e8\u003c/span\u003e. Если есть вопросы, как сделать какую-то \u0026quot;типичную\u0026quot; операцию с элементами массива — задавайте, пожалуйста, вопросы (в комментариях, в ЛС); по итогам ответов на них, возможно, запись будет обновлена.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e9\u003c/span\u003e. Задачи для отработки простой техники:\u003c/p\u003e\u003cp\u003eТренировка по одномерным массивам (\u003ca href\u003d\"//codeforces.com/group/40HeBOdG5d/contest/100891\"\u003eссылка\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eА также задачи с acm.timus.ru\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1617\"\u003e1617 Ползуны\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1645\"\u003e1645 Лыжная гонка\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d2005\"\u003e2005 Такси для программистов\u003c/a\u003e\u003c/p\u003e\u003cp\u003eОбратите внимание: в последней задаче нужно работать с двумерными массивами.\u003c/p\u003e\u003c/div\u003e","tags":["java","arrays"]}}