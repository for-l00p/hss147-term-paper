{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1526927333,"rating":-20,"authorHandle":"ASO","modificationTimeSeconds":1526927553,"id":59609,"title":"\u003cp\u003eRuntime error: exit code is -1073741819\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003ewhen i run my code in my os it has no problem but when i run it in custom test in cf and give single even or odd integer above runtime happen is there any one can help me? this program is magic square for all kind of number \u003c/p\u003e\u003ch1\u003einclude \u0026lt;bits/stdc++.h\u0026gt;\u003c/h1\u003e\u003cp\u003eusing namespace std; const int maxn\u003d1e3+100; int jadval[maxn][maxn]; bool used[maxn]; //////////////////////////////////////////////////////////  int** generate_odd_square(int n) {  int value \u003d 0;  int squareSize \u003d n * n;  int c \u003d n / 2, r \u003d 0,i;\u003c/p\u003e \u003cpre\u003eint** result \u003d new int *[1000];\n\nfor(i\u003d0;i\u0026lt;n;i++)\n    result[i] \u003d new int [1000];\n\nwhile (++value \u0026lt;\u003d squareSize) {\n    result[r][c] \u003d value;\n    if (r \u003d\u003d 0) {\n        if (c \u003d\u003d n - 1) {\n            r++;\n        } else {\n            r \u003d n - 1;\n            c++;\n        }\n    } else if (c \u003d\u003d n - 1) {\n        r--;\n        c \u003d 0;\n    } else if (result[r - 1][c + 1] \u003d\u003d 0) {\n        r--;\n\n        c++;\n    } else {\n        r++;\n    }\n}\nreturn result;\u003c/pre\u003e\u003cp\u003e} ////////////////////////////////////////////// void generate_double_even_square(int n){  int counter\u003d1;  fill_n(used,n*n+100,true);  for (int i\u003d0; i\u0026lt;n; i++){  for (int j\u003d0; j\u0026lt;n; j++){  if (i\u0026gt;\u003d0 and i\u0026lt;n/4 and j\u0026lt;n/4 and j\u0026gt;\u003d0)  jadval[i][j]\u003dcounter++;  else  if (i\u0026gt;\u003d(n/4)*3 and i\u0026lt;\u003dn and j\u0026gt;\u003d0 and j\u0026lt;n/4)  jadval[i][j]\u003dcounter++;  else  if (i\u0026gt;\u003d(n/4)*3 and i\u0026lt;\u003dn and j\u0026gt;\u003d(n/4)*3 and j\u0026lt;\u003dn)  jadval[i][j]\u003dcounter++;  else  if (j\u0026gt;\u003d(n/4)*3 and j\u0026lt;\u003dn and i\u0026gt;\u003d0 and i\u0026lt;n/4)  jadval[i][j]\u003dcounter++;  else  if (j\u0026gt;\u003dn/4 and j\u0026lt;(n/4)*3 and i\u0026gt;\u003dn/4 and i\u0026lt;(n/4)*3)  jadval[i][j]\u003dcounter++;  else{  counter++;  used[counter-1]\u003dfalse;  }  }  }  counter\u003dn*n;  for (int i\u003d0; i\u0026lt;n; i++)  for (int j\u003d0; j\u0026lt;n; j++){  if (used[counter]\u003d\u003dtrue)  counter--;  else  jadval[i][j]\u003dcounter--;  }  for (int i\u003d0; i\u0026lt;n; i++){  for (int j\u003d0; j\u0026lt;n; j++)  cout\u0026lt;\u0026lt;jadval[i][j]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;  cout\u0026lt;\u0026lt;endl;  } } ///////////////////////////////////////////////////////// int** generate_single_even_square(int n) {\u003c/p\u003e \u003cpre\u003eint size \u003d n * n;\nint halfN \u003d n / 2;\nint zirmatricSize \u003d size / 4, i;\n\nint** zirmatric \u003d generate_odd_square(halfN);\nint gridFactors[] \u003d {0, 2, 3, 1};\nint** result \u003d new int *[1000];\n\nfor(i\u003d0;i\u0026lt;n;i++)\n    result[i] \u003d new int [1000];\n\nfor (int r \u003d 0; r \u0026lt; n; r++) {\n    for (int c \u003d 0; c \u0026lt; n; c++) {\n        int grid \u003d (r / halfN) * 2 + (c / halfN);\n        result[r][c] \u003d zirmatric[r % halfN][c % halfN];\n        result[r][c] +\u003d gridFactors[grid] * zirmatricSize;\n    }\n}\n\nint nColsLeft \u003d halfN / 2;\nint nColsRight \u003d nColsLeft - 1;\n\nfor (int r \u003d 0; r \u0026lt; halfN; r++)\n    for (int c \u003d 0; c \u0026lt; n; c++) {\n        if (c \u0026lt; nColsLeft || c \u0026gt;\u003d n - nColsRight\n                || (c \u003d\u003d nColsLeft \u0026amp;\u0026amp; r \u003d\u003d nColsLeft)) {\n\n            if (c \u003d\u003d 0 \u0026amp;\u0026amp; r \u003d\u003d nColsLeft)\n                continue;\n\n            int tmp \u003d result[r][c];\n            result[r][c] \u003d result[r + halfN][c];\n            result[r + halfN][c] \u003d tmp;\n        }\n    }\n\nreturn result;\u003c/pre\u003e\u003cp\u003e} int main(){  int n;  cin\u0026gt;\u0026gt;n;  if (n%2\u003d\u003d1){  int **matrice\u003dgenerate_odd_square(n);  for (int i\u003d0; i\u0026lt;n; i++){  for (int j\u003d0; j\u0026lt;n; j++)  cout\u0026lt;\u0026lt;matrice[i][j]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;  cout\u0026lt;\u0026lt;endl;  }  }  else  if (n%4\u003d\u003d0)  generate_double_even_square(n);  else{  int **matrice\u003dgenerate_single_even_square(n);  for (int i\u003d0; i\u0026lt;n; i++){  for (int j\u003d0; j\u0026lt;n; j++)  cout\u0026lt;\u0026lt;matrice[i][j]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;  cout\u0026lt;\u0026lt;endl;  }  }  return 0; }\u003c/p\u003e\u003c/div\u003e","tags":["runtime","-1073741819"]}}