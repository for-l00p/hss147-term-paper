{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1526669007,"rating":24,"authorHandle":"AGrigorii","modificationTimeSeconds":1526815509,"id":59551,"title":"\u003cp\u003eРазбор Codeforces #484 Round (Div. 2)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/982/problem/A\" title\u003d\"Codeforces Round 484 (Div. 2)\"\u003e982A - Row\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSeating is the maximum when it does not exist two ones or three zeros together. It is also necessary to carefully process the ends of the series — it is necessary to check that you can not put a person on the most right or the most left chairs.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/982/problem/B\" title\u003d\"Codeforces Round 484 (Div. 2)\"\u003e982B - Bus of Characters\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eNote that the final introvert-extrovert pairs are uniquely determined, and that using the stack, it is possible to recover which extrovert to which introvert will sit (note that the zeros and ones will form the correct bracket sequence). Then one of the solutions may be as follows:\u003c/p\u003e \u003col\u003e   \u003cli\u003eSort the array of the lengths of the rows in ascending order\u003c/li\u003e   \u003cli\u003eFor each introvert write the number of the next free row and add it to the stack\u003c/li\u003e   \u003cli\u003eFor each extrovert write the last number from the stack and remove it from there\u003c/li\u003e \u003c/ol\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/982/problem/C\" title\u003d\"Codeforces Round 484 (Div. 2)\"\u003e982C - Cut \u0027em all!\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eNote that if there is an edge that can be removed, we can do it without any problem. Let\u0027s consider such edge that in one of the obtained subtrees it is impossible to delete more anything else, and its removal is possible. What happens if we delete it in the tree? Relative to the other end of the edge, the odd-even balance of the subtree has not changed, which means that the edge has not been affected by further deletions. Which means if we remove it, the answer will be better. \u003c/p\u003e\u003cp\u003eThis is followed by a greedy solution: in dfs we count the size of the subtree for each vertex, including the current vertex, and if it is even, then the edge from the parent (if it exists) can be removed.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/982/problem/D\" title\u003d\"Codeforces Round 484 (Div. 2)\"\u003e982D - Shark\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLet\u0027s sort the array and insert the numbers in the sort order from smaller to larger. Using the data structure \u0026quot;disjoint set union\u0026quot; we can easily maintain information about the current number of segments, as well as using the map within the function of union, and information about the current size of segments (locations) too. Then it remains only to update the answer when it\u0027s needed.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/982/problem/E\" title\u003d\"Codeforces Round 484 (Div. 2)\"\u003e982E - Billiard\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eIf you symmetrically reflect a rectangle on the plane relative to its sides, the new trajectory of the ball will be much easier. Linear trajectory if be correct. One possible solution is:\u003c/p\u003e \u003col\u003e   \u003cli\u003eIf the vector is directed at an angle of 90 degrees to the axes, then write the if-s.\u003c/li\u003e   \u003cli\u003eOtherwise, turn the field so that the impact vector becomes \u003cspan class\u003d\"tex-span\"\u003e(1, 1)\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eWrite the equation of the direct motion of the ball: \u003cspan class\u003d\"tex-span\"\u003e – 1·\u003ci\u003ex\u003c/i\u003e + 1·\u003ci\u003ey\u003c/i\u003e + \u003ci\u003eC\u003c/i\u003e \u003d 0\u003c/span\u003e. If we substitute the initial position of the ball, we find the coefficient \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eNote that in the infinite tiling of the plane the coordinates of any holes representable in the form \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e·\u003ci\u003en\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e·\u003ci\u003em\u003c/i\u003e)\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eSubstitute the coordinates of the points in the equation of the line of the ball. The Diophantine equation \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e·\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003eB\u003c/i\u003e·\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u003d \u003ci\u003eC\u003c/i\u003e\u003c/span\u003eis obtained. It is solvable if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e | \u003ci\u003egcd\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e, \u003ci\u003eB\u003c/i\u003e)\u003c/span\u003e. Otherwise, there are no solutions.\u003c/li\u003e   \u003cli\u003eOf all the solutions of this Diophantine equation, we are interested in the smallest on the positive half-axis.\u003c/li\u003e   \u003cli\u003eBy finding \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e it is easy to get the coordinates of the corresponding pocket\u003c/li\u003e   \u003cli\u003eRotate the field back if required.\u003c/li\u003e \u003c/ol\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/982/problem/F\" title\u003d\"Codeforces Round 484 (Div. 2)\"\u003e982F - The Meeting Place Cannot Be Changed\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLet\u0027s assume that solution exists and will looking for solution relying on this assumption. At the end will check found \u0026quot;solution\u0026quot; in linear time, and if it is not real solution, then assumption wasn\u0027t right.\u003c/p\u003e\u003cp\u003eIf solution exists, then intersection (by vertices) of all cycles is not empty. Let\u0027s take any one cycle and call it \u0026quot;main cycle\u0026quot;. Let\u0027s imagine this \u0026quot;main cycle\u0026quot; as circle directed clockwise. And let\u0027s mark all required vertices of intersection of all cycles on this circle (this vertices are the answer).\u003c/p\u003e\u003cp\u003eConsider only cycles which leave \u0026quot;main cycle\u0026quot;, come back to the \u0026quot;main cycle\u0026quot;, and then moves on the \u0026quot;main cycle\u0026quot; to the begining. Every such cycle when comes back to the \u0026quot;main cycle\u0026quot; DOES NOT jump over any marked vertex of the answer, in terms of direction of the \u0026quot;main cycle\u0026quot; (otherwise answer not exists, but we assumed, that it exists) (if cycle comes back to the same vertex, then by definition it jumped over the whole \u0026quot;main cycle\u0026quot;, not 0). Draw the arc from the vertex, where cycle comes back to the \u0026quot;main cycle\u0026quot; till the vertex, where it leaves \u0026quot;main cycle\u0026quot;, in the direction of the \u0026quot;main cycle\u0026quot;. Vertices not covered by this arc can\u0027t be the answer. Intersection of all considered cycles is marked by intersection of all such arcs.\u003c/p\u003e\u003cp\u003eNow was not considered only cycles which some times leave \u0026quot;main cycle\u0026quot; and some times comes back to it. But intersection of such cycle with the \u0026quot;main cycle\u0026quot; is the same as intersection of simple cycles from previous paragraph between adjacent leave/comebacks. Therefore such cycles may be ignored.\u003c/p\u003e\u003cp\u003eFor searching the answer we must mark arcs between leaves/comebacks of the main cycle. We do this by starting dfs from all vertices of the \u0026quot;main cycle\u0026quot; and trying to come back to it as far as possible (distance measured as the number of vertices of the \u0026quot;main cycle\u0026quot; between leave and comeback). As were noticed early, cycles does not jump over the answer. Therefore dfses started between boundaries of the answer are aspires to this boundary in direction of the \u0026quot;main cycle\u0026quot;. Therefore if we selected the most far vertex in one dfs(u) reached from one start point v0, this vertex for dfs(u) reached from other start point v1 will be the most far too. And we can run all dfses with common \u0026quot;used\u0026quot; array, caching the most far vertex in it.\u003c/p\u003e\u003cp\u003eFinally the solution is so: 1) find the \u0026quot;main cycle\u0026quot; and sort vertices in it, 2) start dfses from vertices of the \u0026quot;main cycle\u0026quot; and mark arcs between finish and start, 3) intersect all arcs and take answer from intersection, 4) verify answer by deleting it from graph and trying to find any other cycle, if it founded, then assumption was wrong and solution doesn\u0027t exists else print the answer.\u003c/p\u003e\u003c/div\u003e","tags":[]}}