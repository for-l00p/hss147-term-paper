{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1519649194,"rating":0,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1519649194,"id":58053,"title":"\u003cp\u003eNotes on Codeforces Beta Round #119, Div2- A, B, C, D , E\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/189/problem/A\" title\u003d\"Codeforces Round 119 (Div. 2)\"\u003e189A - Cut Ribbon\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis problem asks to solve an equation \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exa\u003c/i\u003e + \u003ci\u003eyb\u003c/i\u003e + \u003ci\u003ezc\u003c/i\u003e \u003d \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. We can enumerate each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e but calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e directly according to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ezc\u003c/i\u003e \u003d \u003ci\u003en\u003c/i\u003e - \u003ci\u003exa\u003c/i\u003e - \u003ci\u003eyb\u003c/i\u003e\u003c/span\u003e, which gives an algorithm with complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/189/problem/B\" title\u003d\"Codeforces Round 119 (Div. 2)\"\u003e189B - Counting Rhombi\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe key idea is to enumerate all the feasible center points. For each center point with coordinate \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e, it contributes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ew\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e) × \u003ci\u003emin\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e, \u003ci\u003eh\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e to the final result.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/189/problem/C\" title\u003d\"Codeforces Round 119 (Div. 2)\"\u003e189C - Permutations\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe adopt two pointers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e1, \u003ci\u003ep\u003c/i\u003e2\u003c/span\u003e, to point to the position of array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, respectively. Before moving on to the general algorithm, we start with a simple example to obtain some intuitive understanding.\u003c/p\u003e\u003cp\u003eAt first, we try to put the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d \u003ci\u003eb\u003c/i\u003e[0]\u003c/span\u003e to position \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[0] \u003d \u003ci\u003eb\u003c/i\u003e[0]\u003c/span\u003e, we do nothing but try to put the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d \u003ci\u003eb\u003c/i\u003e[1]\u003c/span\u003e to position \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. We continue this until the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]! \u003d \u003ci\u003eb\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e is met, and without loss of generality, we assume that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[0]! \u003d \u003ci\u003eb\u003c/i\u003e[0]\u003c/span\u003e. To accomplish this, we should take out all the elements in array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003en\u003c/i\u003e]\u003c/span\u003e with indices larger than or equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e (remember to count the number of operations), and then we can put \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d \u003ci\u003eb\u003c/i\u003e[0]\u003c/span\u003e to position \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. Well, what should we do with the other elements that have been taken out. In fact, they “have been” put to correct positions. Although our algorithm can not tell their correct positions right now, as we may take out more elements from the end and thus move their positions by some offset, we still have full “observation” and we can completely determine their current correct positions by considering the “future”. \u003c/p\u003e\u003cp\u003eTherefore, we have the following general algorithm. At first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e1 \u003d \u003ci\u003ep\u003c/i\u003e2 \u003d 0\u003c/span\u003e, and we check whether \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e1] \u003d \u003ci\u003eb\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e2]\u003c/span\u003e. If yes, we increase both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e2\u003c/span\u003e by one. Otherwise we check whether the element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d \u003ci\u003eb\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e2]\u003c/span\u003e has been taken out or not. If yes, we increase only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e2\u003c/span\u003e by one; otherwise we take out more elements until \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d \u003ci\u003eb\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e2]\u003c/span\u003e is met, and then increase \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e2\u003c/span\u003e by one. We count the number of operations during this process.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/189/problem/D\" title\u003d\"Codeforces Round 119 (Div. 2)\"\u003e189D - AlgoRace\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFor each type of car, we adopt floyd algorithm to calculate the minimum time it costs to go from city \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to city \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, which is denoted as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e. Then, we use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e to denote the minimum time it costs to go from city \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to city \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e with no more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e changes. The recursive formula is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e] \u003d \u003ci\u003emin\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u0027 ≠ \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e\u0027][\u003ci\u003ek\u003c/i\u003e - 1] + \u003ci\u003et\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e\u0027][\u003ci\u003ej\u003c/i\u003e])\u003c/span\u003e. Note that it is sufficient to calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e up to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, since we have at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e cities, and the optimal path must be a simple path with no loops. Thus, remember to update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e, \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e for the originally given \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/189/problem/E\" title\u003d\"Codeforces Round 119 (Div. 2)\"\u003e189E - Weak Memory\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe main idea is to use binary search to find the optimal \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e, since if there exists some \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u0027\u003c/span\u003e that satisfies the requirements, then any \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e ≥ \u003ci\u003eq\u003c/i\u003e\u0027\u003c/span\u003e must be a feasible answer as well.\u003c/p\u003e\u003cp\u003eFor any \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e that we are testing, we should check whether we can reach the ending point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e from the starting point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e or not. If yes, we further decrease \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e; otherwise we try to increase it and test the next value again. For each test, we can implement SPFA (shortest path faster algorithm) to compute the shortest path distance from any point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, denoted as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e, with complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eE\u003c/i\u003e)\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eE\u003c/i\u003e\u003c/span\u003e is the number of edges. However, we should modify the calculation slightly when we meet a special “volunteer point”. Once we have reached one of such points with index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, we should set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e] \u003d 0\u003c/span\u003e, since the distance is “cleared” at such points. Finally, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edis\u003c/i\u003e[\u003ci\u003et\u003c/i\u003e] ≤ \u003ci\u003eq\u003c/i\u003e\u003c/span\u003e, then the current \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e satisfies the requirements and we should further decrease it; otherwise we increase it for the next test.\u003c/p\u003e\u003c/div\u003e","tags":[]}}