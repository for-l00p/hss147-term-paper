{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1411197131,"rating":77,"authorHandle":"zakharvoit","modificationTimeSeconds":1411214496,"id":13875,"title":"\u003cp\u003eC++ и bounds checking\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eМало кто знает, но компиляторы и стандартная библиотека C++ могут проверять выходы за границы массивов и векторов.\u003c/p\u003e\u003cp\u003eЕсли мы используем gcc и glibc, то следующий код бросит исключение:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#define _GLIBCXX_DEBUG\n\n#include \u0026lt;bits/stdc++.h\u0026gt;\n\nint main() {\n    std::vector \u0026lt;int\u0026gt; a(100);\n    int x \u003d -1;\n    printf(\u0026quot;%d\\n\u0026quot;, a[x]);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eИ мы получим примерно вот такой вывод: \u003ccode\u003e error: attempt to subscript container with out-of-bounds index -1, but          container only holds 100 elements. \u003c/code\u003e\u003c/p\u003e\u003cp\u003eНомер строки мы не узнаем, но лучше, чем ничего. С этим флагом все контейнеры С++ включают проверки на ошибки (кроме C++11 std::array, как я понял). Также можно не писать define прямо в коде, а передавать аргумент компилятору: \u003ccode\u003e g++ -D_GLIBCXX_DEBUG main.cpp -o main \u003c/code\u003e\u003c/p\u003e\u003cp\u003eА что делать с массивами? Для проверки выхода за границы массива предусмотрен флаг -fsanitize\u003dbounds. Правда у меня его gcc(4.7.3) не принял, сказав, что неизвестный флаг, но clang скомпилировал.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nint main() {\n    int a[100];\n    int x \u003d -1;\n    printf(\u0026quot;%d\\n\u0026quot;, a[x]);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКомпилируем вот так: \u003ccode\u003e clang++ main.cpp -fsanitize\u003dbounds -o main \u003c/code\u003e\u003c/p\u003e\u003cp\u003eПри запуске получаем: \u003ccode\u003e test.cpp:6:20: runtime error: index -1 out of bounds for type \u0027int [100] \u003c/code\u003e\u003c/p\u003e\u003cp\u003eЕще более дружелюбный вывод, чем в случае с векторами.\u003c/p\u003e\u003cp\u003eК сожалению c динамическими массивами (int *a \u003d new int[100]) такое не работает, но есть еще флаг -fsanitize\u003dundefined (включает в себя bounds) и -fsanitize\u003dadress, который как раз уронит вариант с динамическим массивом.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD:\u003c/strong\u003e WARNING: Не отсылайте решения с этим макросом в коде, неизбежно получите ТЛ.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD2:\u003c/strong\u003e Чтобы использовать -fsanitize нужен gcc \u0026gt;\u003d4.9 или clang\u003c/p\u003e\u003c/div\u003e","tags":[]}}