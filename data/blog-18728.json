{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1434734471,"rating":2,"authorHandle":"PERNEKHAN","modificationTimeSeconds":1434734471,"id":18728,"title":"\u003cp\u003eПерсистентное Дерево Отрезков\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eЧерез дней 3-4 можете попробовать сдать задачи на персистентку: \u003ca href\u003d\"http://www.spoj.com/problems/DQUERY/en/\"\u003eссылка1\u003c/a\u003e, \u003ca href\u003d\"http://lightoj.com/volume_showproblem.php?problem\u003d1188\"\u003eссылка2\u003c/a\u003e, \u003ca href\u003d\"//codeforces.com/contest/538/problem/F\"\u003eссылка3\u003c/a\u003e, \u003ca href\u003d\"//codeforces.com/gym/100043/attachments/download/53/20102011-vsyerossiyskaya-komandnaya-olimpiada-shkolnikov-po-programmirovaniu-vkoshp-10-ru.pdf\"\u003eЗадача-I\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eНиже код который мы писали на уроке:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;functional\u0026gt;\n#include \u0026lt;numeric\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;sstream\u0026gt;\n\nusing namespace std;\n\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define pii pair\u0026lt;int, int\u0026gt;\n#define pll pair\u0026lt;long long, long long\u0026gt;\n#define y1 stupid_y1\n#define ll long long\n#define forit(it, s) for(__typeof(s.begin()) it \u003d s.begin(); it !\u003d s.end(); it++)\n#define all(a) a.begin(), a.end()\n#define sqr(x) ((x)*(x))\n#define sz(a) (int)a.size()\n#define file \u0026quot;a\u0026quot;\n\nconst int inf \u003d (int)1e9;\nconst double eps \u003d 1e-9;\nconst double pi \u003d acos(-1.0);\n\nstruct node {\n\tint sum;\n\tnode *l, *r;\n\tnode(){\n\t\tl \u003d r \u003d NULL;\n\t\tsum \u003d 0;\n\t}\n\tnode(int _sum){\n\t\tsum \u003d _sum;\n\t\tl \u003d r \u003d NULL;\n\t}\n}*T[100100];\nint a[100100];\nint n;\n\nnode* build(int v, int tl, int tr){\n\tif ( tl \u003d\u003d tr )\n\t\treturn new node(0);\n\tnode *t \u003d new node(0);\n\tint mid \u003d (tl + tr)/2;\n\tt-\u0026gt;l \u003d build(2*v, tl, mid);\n\tt-\u0026gt;r \u003d build(2*v+1, mid+1, tr);\n\tt-\u0026gt;sum \u003d t-\u0026gt;l-\u0026gt;sum + t-\u0026gt;r-\u0026gt;sum;\n\treturn t;\n}\n\nnode* update(node *\u0026amp;t, int v, int tl, int tr, int pos, int val){\n\tif ( tl \u003d\u003d tr ){\n\t\treturn new node(val);\n\t}   \n\tint mid \u003d (tl + tr)/2;\n\tnode *nt \u003d new node(0);\n\tif ( pos \u0026lt;\u003d mid ){\n\t\tnt-\u0026gt;l \u003d update(t-\u0026gt;l, 2*v, tl, mid, pos, val);\n\t\tnt-\u0026gt;r \u003d t-\u0026gt;r;\n   \t}\n   \telse {\n\t\tnt-\u0026gt;r \u003d update(t-\u0026gt;r, 2*v+1, mid+1, tr, pos, val);\n\t\tnt-\u0026gt;l \u003d t-\u0026gt;l;\n   \t}\n   \tnt-\u0026gt;sum \u003d nt-\u0026gt;l-\u0026gt;sum + nt-\u0026gt;r-\u0026gt;sum;\n   \treturn nt;\n}\n\nint get(node *\u0026amp;A, int v, int tl, int tr, int l, int r){\n\tif ( l \u0026gt; tr || r \u0026lt; tl ) return 0;\n\tif (l \u0026lt;\u003d tl \u0026amp;\u0026amp; tr \u0026lt;\u003d r) return A-\u0026gt;sum;\n\tint mid \u003d (tl + tr)/2;\n\treturn get(A-\u0026gt;l, 2*v, tl, mid, l, r) + get(A-\u0026gt;r, 2*v+1, mid+1, tr, l, r);\t\t\n}\n\n\nint main () {\n\t#ifdef LOCAL\n\tfreopen(file\u0026quot;.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\tfreopen(file\u0026quot;.out\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\t#endif\n\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\n\tfor (int i\u003d1;i\u0026lt;\u003dn;i++){\n\t\tscanf(\u0026quot;%d\u0026quot;, a + i);\n\t}\n\n\tT[0] \u003d build(1, 1, n);\n\tmap \u0026lt; int, int \u0026gt; prev;\n\n\tfor (int i\u003d1;i\u0026lt;\u003dn;i++){\n\t\tT[i] \u003d T[i-1];\n\t\tif ( prev[a[i]] )\n\t\t\tT[i] \u003d update(T[i-1], 1, 1, n, prev[a[i]], 0);\n\t\tT[i] \u003d update(T[i], 1, 1, n, i, 1);\n\t\tprev[a[i]] \u003d i;\t\t\n\t}\n\n\tint Q;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;Q);\n\n\tfor (int i\u003d0;i\u0026lt;Q;i++){\n\t\tint l, r;\n\t\tscanf(\u0026quot;%d%d\u0026quot;, \u0026amp;l, \u0026amp;r);\n\t\tnode *A \u003d T[r];\n\t\tprintf(\u0026quot;%d\\n\u0026quot;, get(A, 1, 1, n, l, r));\n\t}\n    \n\n\t#ifdef LOCAL\n\tcerr \u0026lt;\u0026lt; (double)clock() * 1.0 / CLOCKS_PER_SEC \u0026lt;\u0026lt; endl;\n\t#endif\n\n\treturn 0;\n}\n\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["segment tree"]}}