{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1477955085,"rating":222,"authorHandle":"Al.Cash","modificationTimeSeconds":1498651916,"id":48122,"title":"\u003cp\u003eGeometry: 2D points and lines [Tutorial]\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI get an impression that a lot of coders struggle with geometric problems and prefer to avoid them. That\u0027s not much of a surprise, considering that I couldn\u0027t find a good writing explaining the basics and giving useful advice how to proceed. Moreover, some resources obfuscate this beautiful area to the point it\u0027s despised by the readers. I\u0027ll try to change that, but first I\u0027ll mention some of the better resources:\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://geomalgorithms.com/points_and_vectors.html\"\u003egeomalgorithms.com\u003c/a\u003e This is where you can start if you don\u0027t have a basic notion of a vector. Also there are more detailed explanations for some examples I\u0027ll list, but I dislike the implementations.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/blog/entry/6642\"\u003eThis post in Russian\u003c/a\u003e has a link to the code that\u0027s most similar to mine, with some comments (unfortunately, also is Russian) .\u003c/p\u003e\u003ch3\u003ePoint structure and operations\u003c/h3\u003e\u003cp\u003eWithout further ado, I\u0027ll start with my code for the \u003ccode\u003ePoint\u003c/code\u003e structure. Explanations are below, so don\u0027t rush to dive into the code yourself. I don\u0027t like when basic operations take too much space, so formatting is peculiar here. Also I used defines to avoid code repetition. I hope this won\u0027t obscure the ideas too much, and I promise the code will get better once we get to non-trivial functions :)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F\u0026gt;\nstruct Point {\n  F x, y;\n  Point() : x(0), y(0) {}\n  Point(const F\u0026amp; x, const F\u0026amp; y) : x(x), y(y) {}\n\n  void swap(Point\u0026amp; other) { using std::swap; swap(x, other.x); swap(y, other.y); }\n  template \u0026lt;class F1\u0026gt; explicit operator Point\u0026lt;F1\u0026gt; () const {\n    return Point\u0026lt;F1\u0026gt;(static_cast\u0026lt;F1\u0026gt;(x), static_cast\u0026lt;F1\u0026gt;(y)); }\n  template \u0026lt;class F1\u0026gt; Point\u0026amp; operator \u003d (const Point\u0026lt;F1\u0026gt;\u0026amp; other) {\n    x \u003d other.x; y \u003d other.y; return *this; }\n  template \u0026lt;class F1\u0026gt; Point\u0026amp; operator +\u003d (const Point\u0026lt;F1\u0026gt;\u0026amp; other) {\n    x +\u003d other.x; y +\u003d other.y; return *this; }\n  template \u0026lt;class F1\u0026gt; Point\u0026amp; operator -\u003d (const Point\u0026lt;F1\u0026gt;\u0026amp; other) {\n    x -\u003d other.x; y -\u003d other.y; return *this; }\n  template \u0026lt;class F1\u0026gt; Point\u0026amp; operator *\u003d (const F1\u0026amp; factor) {\n    x *\u003d factor; y *\u003d factor; return *this; }\n  template \u0026lt;class F1\u0026gt; Point\u0026amp; operator /\u003d (const F1\u0026amp; factor) {\n    x /\u003d factor; y /\u003d factor; return *this; }\n};\n\ntemplate \u0026lt;class F\u0026gt; int read(Point\u0026lt;F\u0026gt;\u0026amp; point) { return read(point.x, point.y) / 2; }\ntemplate \u0026lt;class F\u0026gt; int write(const Point\u0026lt;F\u0026gt;\u0026amp; point) { return write(point.x, point.y); }\n\ntemplate \u0026lt;class F\u0026gt; istream\u0026amp; operator \u0026gt;\u0026gt; (istream\u0026amp; is, Point\u0026lt;F\u0026gt;\u0026amp; point) {\n  return is \u0026gt;\u0026gt; point.x \u0026gt;\u0026gt; point.y; }\ntemplate \u0026lt;class F\u0026gt; ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream\u0026amp; os, const Point\u0026lt;F\u0026gt;\u0026amp; point) {\n  return os \u0026lt;\u0026lt; point.x \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; point.y; }\n\ntemplate \u0026lt;class F\u0026gt; inline Point\u0026lt;F\u0026gt; makePoint(const F\u0026amp; x, const F\u0026amp; y) { return Point\u0026lt;F\u0026gt;(x, y); }\ntemplate \u0026lt;class F\u0026gt; void swap(Point\u0026lt;F\u0026gt;\u0026amp; lhs, Point\u0026lt;F\u0026gt;\u0026amp; rhs) { lhs.swap(rhs); }\n\n#define FUNC1(name, arg, expr) \\\ntemplate \u0026lt;class F\u0026gt; inline auto name(const arg) -\u0026gt; decltype(expr) { return expr; }\n#define FUNC2(name, arg1, arg2, expr) \\\ntemplate \u0026lt;class F1, class F2\u0026gt; \\\ninline auto name(const arg1, const arg2) -\u0026gt; decltype(expr) { return expr; }\n#define FUNC3(name, arg1, arg2, arg3, expr) \\\ntemplate \u0026lt;class F1, class F2, class F3\u0026gt; \\\ninline auto name(const arg1, const arg2, const arg3) -\u0026gt; decltype(expr) { return expr; }\n\nFUNC1(operator -, Point\u0026lt;F\u0026gt;\u0026amp; point, makePoint(-point.x, -point.y))\nFUNC2(operator +, Point\u0026lt;F1\u0026gt;\u0026amp; lhs, Point\u0026lt;F2\u0026gt;\u0026amp; rhs, makePoint(lhs.x + rhs.x, lhs.y + rhs.y))\nFUNC2(operator -, Point\u0026lt;F1\u0026gt;\u0026amp; lhs, Point\u0026lt;F2\u0026gt;\u0026amp; rhs, makePoint(lhs.x - rhs.x, lhs.y - rhs.y))\nFUNC2(operator *, F1\u0026amp; factor, Point\u0026lt;F2\u0026gt;\u0026amp; rhs, makePoint(factor * rhs.x, factor * rhs.y))\nFUNC2(operator *, Point\u0026lt;F1\u0026gt;\u0026amp; lhs, F2\u0026amp; factor, makePoint(lhs.x * factor, lhs.y * factor))\nFUNC2(operator /, Point\u0026lt;F1\u0026gt;\u0026amp; lhs, F2\u0026amp; factor, makePoint(lhs.x / factor, lhs.y / factor))\n\nFUNC2(operator *, Point\u0026lt;F1\u0026gt;\u0026amp; lhs, Point\u0026lt;F2\u0026gt;\u0026amp; rhs, lhs.x * rhs.x + lhs.y * rhs.y)\nFUNC2(operator ^, Point\u0026lt;F1\u0026gt;\u0026amp; lhs, Point\u0026lt;F2\u0026gt;\u0026amp; rhs, lhs.x * rhs.y - lhs.y * rhs.x)\n\n// \u0026lt; 0 if rhs \u0026lt;- lhs counter-clockwise, 0 if collinear, \u0026gt; 0 if clockwise.\nFUNC2(ccw, Point\u0026lt;F1\u0026gt;\u0026amp; lhs, Point\u0026lt;F2\u0026gt;\u0026amp; rhs, rhs ^ lhs)\nFUNC3(ccw, Point\u0026lt;F1\u0026gt;\u0026amp; lhs, Point\u0026lt;F2\u0026gt;\u0026amp; rhs, Point\u0026lt;F3\u0026gt;\u0026amp; origin, ccw(lhs - origin, rhs - origin))\n\nFUNC2(operator \u003d\u003d, Point\u0026lt;F1\u0026gt;\u0026amp; lhs, Point\u0026lt;F2\u0026gt;\u0026amp; rhs, lhs.x \u003d\u003d rhs.x \u0026amp;\u0026amp; lhs.y \u003d\u003d rhs.y)\nFUNC2(operator !\u003d, Point\u0026lt;F1\u0026gt;\u0026amp; lhs, Point\u0026lt;F2\u0026gt;\u0026amp; rhs, !(lhs \u003d\u003d rhs))\n\nFUNC2(operator \u0026lt;, Point\u0026lt;F1\u0026gt;\u0026amp; lhs, Point\u0026lt;F2\u0026gt;\u0026amp; rhs,\n    lhs.y \u0026lt; rhs.y || (lhs.y \u003d\u003d rhs.y \u0026amp;\u0026amp; lhs.x \u0026lt; rhs.x))\nFUNC2(operator \u0026gt;, Point\u0026lt;F1\u0026gt;\u0026amp; lhs, Point\u0026lt;F2\u0026gt;\u0026amp; rhs, rhs \u0026lt; lhs)\nFUNC2(operator \u0026lt;\u003d, Point\u0026lt;F1\u0026gt;\u0026amp; lhs, Point\u0026lt;F2\u0026gt;\u0026amp; rhs, !(lhs \u0026gt; rhs))\nFUNC2(operator \u0026gt;\u003d, Point\u0026lt;F1\u0026gt;\u0026amp; lhs, Point\u0026lt;F2\u0026gt;\u0026amp; rhs, !(lhs \u0026lt; rhs))\n\n// Angles and rotations (counter-clockwise).\nFUNC1(angle, Point\u0026lt;F\u0026gt;\u0026amp; point, atan2(point.y, point.x))\nFUNC2(angle, Point\u0026lt;F1\u0026gt;\u0026amp; lhs, Point\u0026lt;F2\u0026gt;\u0026amp; rhs, atan2(lhs ^ rhs, lhs * rhs))\nFUNC3(angle, Point\u0026lt;F1\u0026gt;\u0026amp; lhs, Point\u0026lt;F2\u0026gt;\u0026amp; rhs, Point\u0026lt;F3\u0026gt;\u0026amp; origin,\n      angle(lhs - origin, rhs - origin))\nFUNC3(rotate, Point\u0026lt;F1\u0026gt;\u0026amp; point, F2\u0026amp; angleSin, F3\u0026amp; angleCos,\n      makePoint(angleCos * point.x - angleSin * point.y,\n                angleSin * point.x + angleCos * point.y))\nFUNC2(rotate, Point\u0026lt;F1\u0026gt;\u0026amp; point, F2\u0026amp; angle, rotate(point, sin(angle), cos(angle)))\nFUNC3(rotate, Point\u0026lt;F1\u0026gt;\u0026amp; point, F2\u0026amp; angle, Point\u0026lt;F3\u0026gt;\u0026amp; origin,\n      origin + rotate(point - origin, angle))\nFUNC1(perp, Point\u0026lt;F\u0026gt;\u0026amp; point, makePoint(-point.y, point.x))\n\n// Distances.\nFUNC1(abs, Point\u0026lt;F\u0026gt;\u0026amp; point, point * point)\nFUNC1(norm, Point\u0026lt;F\u0026gt;\u0026amp; point, sqrt(abs(point)))\nFUNC2(dist, Point\u0026lt;F1\u0026gt;\u0026amp; lhs, Point\u0026lt;F2\u0026gt;\u0026amp; rhs, norm(lhs - rhs))\nFUNC2(dist2, Point\u0026lt;F1\u0026gt;\u0026amp; lhs, Point\u0026lt;F2\u0026gt;\u0026amp; rhs, abs(lhs - rhs))\nFUNC2(bisector, Point\u0026lt;F1\u0026gt;\u0026amp; lhs, Point\u0026lt;F2\u0026gt;\u0026amp; rhs, lhs * norm(rhs) + rhs * norm(lhs))\n\n#undef FUNC1\n#undef FUNC2\n#undef FUNC3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003ePoint\u003c/code\u003e structure will represent points as well as vectors. Point \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e can be viewed as a vector from the origin \u003cspan class\u003d\"tex-span\"\u003e(0, 0)\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e, so there\u0027s no point to distinguish this notions. And the name \u003ccode\u003evector\u003c/code\u003e is already (inappropriately) taken in C++.\u003c/p\u003e\u003cp\u003e\u003ccode\u003ePoint\u003c/code\u003e was made a template for two reasons:\u003c/p\u003e \u003col\u003e   \u003cli\u003eI like templates. And I\u0027m sure I\u0027m not the first one who thought about writing such template, so probably I can save some effort for somebody.\u003c/li\u003e   \u003cli\u003eIf the input coordinates are integer, most computations can be done in integers, but the result may be real (for example, in line intersection, as we\u0027ll see later). So, it\u0027s useful to have different point types in one program. And here\u0027s the first advice: \u003cstrong\u003edo computations in integers as long as possible\u003c/strong\u003e, for two obvious reasons:\u003c/li\u003e \u003c/ol\u003e \u003cul\u003e   \u003cli\u003ethey are faster;\u003c/li\u003e   \u003cli\u003ethey avoid precision issues.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eFor example, if you need to find the maximum distance between a pair of points and the coordinates are integer, compute and compare squared distances (that are also integer), and take square root only when you output the result. If you need to sort points by angle, it doesn\u0027t mean you have to compute the angles, you\u0027ll see other ways soon. You\u0027ll be surprised how much can be done without resorting to doubles.\u003c/p\u003e\u003cp\u003eTo be fair, recently I found out that \u003ccode\u003edouble\u003c/code\u003e performs better than \u003ccode\u003elong long\u003c/code\u003e under MSVS compiler on \u003ca href\u003d\"http://acm.timus.ru/\"\u003eTimus\u003c/a\u003e, but only if simple operations like \u003ccode\u003e+\u003c/code\u003e, \u003ccode\u003e-\u003c/code\u003e, \u003ccode\u003e*\u003c/code\u003e are used. So, let me rephrase the advice: \u003cstrong\u003eavoid using floating point division, square root, and especially trigonometric functions as much as possible\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eWait, doubles should be compared with epsilon, you might recall. How do I reckon with this in my template code? Fret not, my crestfallen readers, for I have a wrapper around floating point types to do that :) If it\u0027s easier for you, feel free to strip all the templates and insert epsilons like it\u0027s done in the code I linked above.\u003c/p\u003e\u003cp\u003eOK, enough talking about the concept, let\u0027s get to implementation. \u003ccode\u003ePoint\u003c/code\u003e contains two fields \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e with obvious meaning, some utility methods including type conversion and basic vector operations. Next, there are I/O functions, where \u003ccode\u003eread\u003c/code\u003e/\u003ccode\u003ewrite\u003c/code\u003e are used in \u003ca href\u003d\"//codeforces.com/blog/entry/45835\"\u003emy custom I/O\u003c/a\u003e, and more vector operations like addition and multiplication by a scalar. Trailing return type syntax is used to be able to combine points of different types just like primitive built-in types. Now we get to the most important part, operators \u003ccode\u003e*\u003c/code\u003e and \u003ccode\u003e^\u003c/code\u003e (these symbols were selected solely for historical reasons). They both can be expressed using vector coordinates (the formulas written in the code) and using vector lengths and the angle between them.\u003c/p\u003e\u003cp\u003e\u003cimg src\u003d\"/predownloaded/42/b2/42b219c742da188b85d8e2ecf58c7d5e8f10f924.png\" style\u003d\"float: left;max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDot product\u003c/strong\u003e: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e * \u003ci\u003eb\u003c/i\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e \u003d |\u003ci\u003ea\u003c/i\u003e||\u003ci\u003eb\u003c/i\u003e|\u003ci\u003ecos\u003c/i\u003e α.\u003c/span\u003e\u003cbr /\u003e To explain its meaning, lets draw dashed line \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e perpendicular to the vector \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e.\u003cbr /\u003e Cosine properties apply that:\u003cbr /\u003e - if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e * \u003ci\u003eb\u003c/i\u003e \u0026gt; 0\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e points to the same side of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e (as in the picture);\u003cbr /\u003e - if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e * \u003ci\u003eb\u003c/i\u003e \u003d 0\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e is collinear with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e, so it\u0027s perpendicular to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e;\u003cbr /\u003e - if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e * \u003ci\u003eb\u003c/i\u003e \u0026lt; 0\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e points to the opposite side of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e.\u003cbr /\u003e To sum it up, \u003cstrong\u003edot product sign indicates whether two vectors point in about the same direction.\u003c/strong\u003e\u003cbr /\u003e Now let\u0027s look at the absolute value. \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eb\u003c/i\u003e||\u003ci\u003ecos\u003c/i\u003e α| \u003d |\u003ci\u003eOP\u003c/i\u003e|\u003c/span\u003e — the projection of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e onto \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e.\u003cbr /\u003e So, the dot product\u0027s absolute value is the projection length of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e onto \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e times the length of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e.\u003cbr /\u003e Nothing special, just remember that we can find projection length and angle cosine from it.\u003c/p\u003e\u003cp\u003e\u003cimg src\u003d\"/predownloaded/e6/96/e696f56ed9ec22f8f1bc5b1ee22174907953263c.png\" style\u003d\"float: left;max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2D cross product\u003c/strong\u003e: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e ^ \u003ci\u003eb\u003c/i\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e \u003d |\u003ci\u003ea\u003c/i\u003e||\u003ci\u003eb\u003c/i\u003e|\u003ci\u003esin\u003c/i\u003e α.\u003c/span\u003e\u003cbr /\u003e This name is not canon, but I didn\u0027t find a better one.\u003cbr /\u003e Again, for clarity we draw a line, but this time dashed line \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e through the vector \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e.\u003cbr /\u003e Sine properties apply that:\u003cbr /\u003e - if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e ^ \u003ci\u003eb\u003c/i\u003e \u0026gt; 0\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e points to the left side of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e if we\u0027re looking in the direction of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e;\u003cbr /\u003e - if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e ^ \u003ci\u003eb\u003c/i\u003e \u003d 0\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e lies on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e, so it\u0027s collinear with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e;\u003cbr /\u003e - if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e ^ \u003ci\u003eb\u003c/i\u003e \u0026lt; 0\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e points to the right side of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e (as in the picture).\u003cbr /\u003e To sum it up, \u003cstrong\u003e2D cross product indicates whether the shortest turn from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e is in the counter-clockwise direction.\u003c/strong\u003e\u003cbr /\u003e The following function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eccw\u003c/i\u003e\u003c/span\u003e emphasizes this meaning. It acts like a comparator returning negative value if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eOA\u003c/i\u003e\u003c/span\u003e goes before \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eOB\u003c/i\u003e\u003c/span\u003e in the counter-clockwise ordering (the commonly used ordering) and positive value if after. Origin \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e(0, 0)\u003c/span\u003e by default. If you\u0027re having trouble remembering which sign to use, draw vectors \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d (1, 0)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e \u003d (0, 1)\u003c/span\u003e, then it\u0027s easy to compute that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e ^ \u003ci\u003eb\u003c/i\u003e \u003d 1\u003c/span\u003e.\u003cbr /\u003e The absolute value is very important here, because it\u0027s equal to the doubled area of triangle \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eOAB\u003c/i\u003e\u003c/span\u003e. Together with the sign, we get \u003cstrong\u003eoriented area\u003c/strong\u003e, because it changes sign to opposite if we take two vectors in the different order.\u003c/p\u003e\u003cp\u003eAnother important property of these operations is that they are linear with respect to both arguments, dot product is symmetric, while cross product is anti-symmetric, thus:\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/03/87/0387d7014b36a713579fb1122bafd8a8940c717d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eI tried to do my best to explain these operations. \u003cstrong\u003eMake sure you understand dot and 2D cross product.\u003c/strong\u003e They are the main building blocks for all the computational geometry algorithms, one cannot understate their importance. I hope the examples below will help you with that.\u003c/p\u003e\u003cp\u003eNext, I have comparison operators, similar to standard \u003ccode\u003epair\u003c/code\u003e. It\u0027s not substantial which coordinate to compare first, I\u0027ll explain later why I chose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe following functions deal with rotations and, following my advice, shouldn\u0027t be used unless you really have to. \u003ccode\u003eangle\u003c/code\u003e taking one argument finds the \u003ca href\u003d\"http://mathworld.wolfram.com/PolarAngle.html\"\u003epolar angle\u003c/a\u003e of the vector, other versions find the angle between two vectors (\u003cspan class\u003d\"tex-span\"\u003eα\u003c/span\u003e in the pictures above). They are based on the following equations, but avoid special cases when denominator is equal to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e:\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/92/3c/923c05bc51846d4827d9ac774e9cb4801272ee26.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eRotation is performed in the counter-clockwise direction using the well-known formula\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e2/03/e203ed50bf864d4dadccffb6e00efd6f38117560.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eThere\u0027s one special case of rotation presented in function \u003ccode\u003eperp\u003c/code\u003e, which returns vector, perpendicular to the given, by rotating by \u003cspan class\u003d\"tex-span\"\u003eπ / 2\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cimg src\u003d\"/predownloaded/24/50/24505c1a868474c294711c190a9f463e9863af17.png\" style\u003d\"float: right;max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThe last section contains functions to find vector length \u003ccode\u003enorm\u003c/code\u003e (norm is a more mathematical word for vector length), squared length \u003ccode\u003eabs\u003c/code\u003e, and distance between two points. With vector length defined, it\u0027s easy to find the bisector of the angle between two vectors. Recall that two vectors\u0027 sum is the diagonal of parallelogram built on these vectors. If we multiply each vector by the length of the other vector, their length will be equal, and the parallelogram will become a rhombus, where diagonal is also the angle bisector.\u003c/p\u003e\u003cp\u003eWe\u0027ve finished with the basic point and vector operations, and here\u0027s the next advice. \u003cstrong\u003eNever access point coordinates directly.\u003c/strong\u003e Absolutely everything you need can be done using operations we already defined. If you stop thinking in terms of coordinates, and learn to apply operations appropriately, it will become much easier to solve harder problems. You may resort to coordinate access only when you\u0027re experienced at geometry, for optimization purposes.\u003c/p\u003e\u003ch3\u003eExamples\u003c/h3\u003e\u003cp\u003eIn order to apply our knowledge, let\u0027s first define the \u003ccode\u003eLine\u003c/code\u003e structure. Here, the question arises: which line representation to use? The standard widely used equation is written as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAx\u003c/i\u003e + \u003ci\u003eBy\u003c/i\u003e + \u003ci\u003eC\u003c/i\u003e \u003d 0\u003c/span\u003e, but \u003cstrong\u003eI strongly prefer the parametric equation\u003c/strong\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a4/3b/a43bce6db8b8bf83f1b0cdabd586cceba65d6e3d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e is a point on the line, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/16/2d/162dfaf88e317c85e8f444f3e32e55f0eae9549e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is the line direction vector, and parameter \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e takes any real value. The reasons why it\u0027s better:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eit stays the same in higher dimensions;\u003c/li\u003e   \u003cli\u003eit\u0027s easily modified to represent a segment by restricting \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e[0, 1]\u003c/span\u003e, or a ray by taking \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e ≥ 0\u003c/span\u003e;\u003c/li\u003e   \u003cli\u003eit promotes the geometric view of the problem, while the standard one is more algebraic and usually leads to more formulas writing instead of coming up with a clean idea.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eMost problems have points as an input, so you\u0027re free to choose the line equation type. Unfortunately, there are some wicked problems that force you to use the standard equation, so it\u0027s better to familiarize yourself with it as well. But we\u0027ll proceed with parametric one, implemented in the \u003ccode\u003eLine\u003c/code\u003e structure:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F\u0026gt;\nstruct Line {\n  Point\u0026lt;F\u0026gt; a, ab;\n  Line() : a(), ab() {}\n  Line(const Point\u0026lt;F\u0026gt;\u0026amp; a, const Point\u0026lt;F\u0026gt;\u0026amp; b, bool twoPoints \u003d true)\n    : a(a), ab(twoPoints ? b - a : b) {}\n  Line(const F\u0026amp; xa, const F\u0026amp; ya, const F\u0026amp; xb, const F\u0026amp; yb)\n    : a(xa, ya), ab(xb - xa, yb - ya) {}\n\n  void swap(Line\u0026amp; other) { using std::swap; swap(a, other.a); swap(ab, other.ab); }\n  template \u0026lt;class F1\u0026gt; explicit operator Line\u0026lt;F1\u0026gt; () const {\n    return Line\u0026lt;F1\u0026gt;(Point\u0026lt;F1\u0026gt;(a), Point\u0026lt;F1\u0026gt;(ab), false); }\n  template \u0026lt;class F1\u0026gt; Line\u0026amp; operator \u003d (const Line\u0026lt;F1\u0026gt;\u0026amp; other) {\n    a \u003d other.a; ab \u003d other.ab; return *this; }\n\n  Point\u0026lt;F\u0026gt; b() const { return a + ab; }\n  operator bool () const { return ab !\u003d Point\u0026lt;F\u0026gt;(); }\n};\n\ntemplate \u0026lt;class F\u0026gt; int read(Line\u0026lt;F\u0026gt;\u0026amp; line) {\n  int res \u003d read(line.a, line.ab) / 2;\n  return line.ab -\u003d line.a, res;\n}\n\ntemplate \u0026lt;class F\u0026gt;\ninline Line\u0026lt;F\u0026gt; makeLine(const Point\u0026lt;F\u0026gt;\u0026amp; a, const Point\u0026lt;F\u0026gt;\u0026amp; b, bool twoPoints \u003d true) {\n  return Line\u0026lt;F\u0026gt;(a, b, twoPoints);\n}\n\ntemplate \u0026lt;class F\u0026gt; void swap(Line\u0026lt;F\u0026gt;\u0026amp; lhs, Line\u0026lt;F\u0026gt;\u0026amp; rhs) { lhs.swap(rhs); }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe first problem that comes into mind is to check whether the given point lies on the line. 2D cross product can check for vectors collinearity, we already have line direction vector, and we can connect the given point to any point on the line (we use \u003ccode\u003eline.a\u003c/code\u003e because it\u0027s already computed) to get the second vector. Note that I handle degenerate case when line shrinks to a point in most functions.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F1, class F2\u0026gt;\nbool onLine(const Point\u0026lt;F1\u0026gt;\u0026amp; point, const Line\u0026lt;F2\u0026gt;\u0026amp; line) {\n  if (!line) return point \u003d\u003d line.a;\n  return ((point - line.a) ^ line.ab) \u003d\u003d 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src\u003d\"/predownloaded/49/ce/49ce34a34530a5e3fc33d9e39170778444e00793.png\" style\u003d\"float: right;max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eMore interesting question is whether the point lies on the segment. We represent a segment by the same \u003ccode\u003eLine\u003c/code\u003e structure assuming it stores the endpoints. The first part is to check whether the point lies on the line. It doesn\u0027t matter which vectors to use as long as they connect the given point and two points on the line. The second condition with scalar product looks very simple, but what it actually checks is whether the point lies inside the disk built on the segment as a diameter. That\u0027s because \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecos\u003c/i\u003e α ≤ 0\u003c/span\u003e when \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d9/f7/d9f7fae8731b377779f993a1185183dba6959c1b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, and from the properties of \u003ca href\u003d\"https://en.wikipedia.org/wiki/Inscribed_angle\"\u003einscribed angles\u003c/a\u003e this sets a disk. Line and disk intersection is exactly the segment we were interested in.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F1, class F2\u0026gt;\nbool onSegment(const Point\u0026lt;F1\u0026gt;\u0026amp; point, const Line\u0026lt;F2\u0026gt;\u0026amp; seg) {\n  if (!seg) return point \u003d\u003d seg.a;\n  auto vecta \u003d seg.a - point, vectb \u003d seg.b() - point;\n  return (vecta ^ vectb) \u003d\u003d 0 \u0026amp;\u0026amp; (vecta * vectb) \u0026lt;\u003d 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eMoving by increasing difficulty, next we compute some distances. Distance to the line is the length of perpendicular, or the height of triangle (for example triangle \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eABP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e in the picture below). We know how to find triangle area using vector coordinates, on the other hand this area is equal to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/27/5c/275cfc8b4419d75979386057d6a6ca8e7d654498.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Thus, the height is the doubled area divided by the base length.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F1, class F2\u0026gt; using distF \u003d decltype(sqrt(F1() + F2()));\n\ntemplate \u0026lt;class F1, class F2\u0026gt;\ndistF\u0026lt;F1, F2\u0026gt; distLine(const Point\u0026lt;F1\u0026gt;\u0026amp; point, const Line\u0026lt;F2\u0026gt;\u0026amp; line) {\n  if (!line) return dist(point, line.a);\n  return abs((point - line.a) ^ line.ab) / norm(line.ab);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src\u003d\"/predownloaded/68/3b/683b034646fb8ba246bf95aaffcc836369019c3a.png\" style\u003d\"float: right;max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eIf we have a segment, the base of the perpendicular lies inside this segment only if the given point lies between two perpendicular lines through the segment endpoints. Otherwise, the closest point is one of the endpoints. The picture demonstrates 3 cases we have, and it should be clear that scalar product is exactly the tool we need to distinguish these cases.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F1, class F2\u0026gt;\ndistF\u0026lt;F1, F2\u0026gt; distSegment(const Point\u0026lt;F1\u0026gt;\u0026amp; point, const Line\u0026lt;F2\u0026gt;\u0026amp; seg) {\n  if (((point - seg.a) * seg.ab) \u0026lt;\u003d 0) return dist(point, seg.a);\n  if (((point - seg.b()) * seg.ab) \u0026gt;\u003d 0) return dist(point, seg.b());\n  return distLine(point, seg);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn order to find not just the distance, but the projection point itself, let\u0027s recall that we can find projection length with the correct sign using the scalar product: \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e * \u003ci\u003eb\u003c/i\u003e) / |\u003ci\u003ea\u003c/i\u003e|\u003c/span\u003e. All we have to do next is to scale the line direction vector to match this length, we get (notation from the last picture is used):\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f9/75/f9750fe18dbad0f47990423f489f69256cf08a31.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eReflection then can be found using the fact that the projection is the midpoint of the segment connecting the point and its reflection.\u003c/p\u003e\u003cp\u003eNote that the following functions use division to compute the result. Even if all the input coordinates are integer, the output may be real. To enforce the correct type conversion, the output variable is passed by reference and should have the desired floating point type.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F1, class F2, class F3\u0026gt;\nvoid projection(const Point\u0026lt;F1\u0026gt;\u0026amp; point, const Line\u0026lt;F2\u0026gt;\u0026amp; line, Point\u0026lt;F3\u0026gt;\u0026amp; res) {\n  res \u003d line.a;\n  if (line) res +\u003d line.ab * static_cast\u0026lt;F3\u0026gt;((point - line.a) * line.ab) / abs(line.ab);\n}\n\ntemplate \u0026lt;class F1, class F2, class F3\u0026gt;\nvoid reflection(const Point\u0026lt;F1\u0026gt;\u0026amp; point, const Line\u0026lt;F2\u0026gt;\u0026amp; line, Point\u0026lt;F3\u0026gt;\u0026amp; res) {\n  projection(point, line, res);\n  res \u003d 2 * res - point;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eClosest point on the segment to the given point is found going through the same 3 cases as with the distance:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F1, class F2, class F3\u0026gt;\nvoid closest(const Point\u0026lt;F1\u0026gt;\u0026amp; point, const Line\u0026lt;F2\u0026gt;\u0026amp; seg, Point\u0026lt;F3\u0026gt;\u0026amp; res) {\n  if (((point - seg.a) * seg.ab) \u0026lt;\u003d 0) res \u003d seg.a;\n  else if (((point - seg.b()) * seg.ab) \u0026gt;\u003d 0) res \u003d seg.b();\n  else projection(point, seg, res);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src\u003d\"/predownloaded/97/61/97618fee2653f7f1cc9c010ed81bd49db28678ae.png\" style\u003d\"float: right;max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eNow we get to the problem I rarely see coded in the best way: \u003cstrong\u003eline intersection\u003c/strong\u003e.\u003cbr /\u003e First, we assume that lines don\u0027t coincide, so the parallel lines never intersect, or we just don\u0027t care about such case (and it\u0027s often true in practice).\u003cbr /\u003e Every point on line \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAB\u003c/i\u003e\u003c/span\u003e is represented as \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/83/6a/836a44aa53ceb73bfa9e1aa153dbd072d0b43f0d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, and it lies on line \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eCD\u003c/i\u003e\u003c/span\u003e when \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b7/57/b7577cd9dc5457d696222c3c8b14d4debd1775b1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Using linearity, we can solve this equation and get \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/07/8a/078a4ae0d45a5dbef795f06634bded729249ea5c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003cbr /\u003e Similarly, for a point \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7d/c3/7dc31d84b6552da7226c855da7c824b1839c0824.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e that also lies on line \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAB\u003c/i\u003e\u003c/span\u003e, we get \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d4/b2/d4b25075948a13c7b01b9298f4cc2733cd7c2b03.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003cbr /\u003e Note that both denominators are equal, and they become zero when lines are parallel, but we assumed in this case lines don\u0027t intersect. If the denominator is not zero, we just substitute \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/83/6a/836a44aa53ceb73bfa9e1aa153dbd072d0b43f0d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e with a value we found and get the intersection point, that is unique.\u003c/p\u003e\u003cp\u003eWe\u0027re done with line intersection, but what if we need to intersect segments? Intersection point may lie on a line, but not on a segment, in which case we should indicate no intersection. Fortunately, we already have expressions for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, and we need to check that \u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003ei\u003c/i\u003e ≤ 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003ej\u003c/i\u003e ≤ 1\u003c/span\u003e. Instead of doing floating point comparisons, we can check \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/11/f1/11f1995d90c69f83f977c82a6cf7fc4a725512cb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (if the denominator is positive), and similar inequality for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. Because we may need to intersect any combination of open/closed segments, rays and lines, I made a template checker. For example, to intersect a ray with an open segment, call \u003ccode\u003eintersectLines\u0026lt;1, 0, 2, 2\u0026gt;(...)\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003cem\u003eExercise\u003c/em\u003e: it\u0027s easy to see that numerators of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e are the doubled areas of triangles \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eACD\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eACB\u003c/i\u003e\u003c/span\u003e respectively. Prove, that denominator is the doubled area of quadrilateral \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eACBD\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;int TYPE\u0026gt; struct EndpointChecker {};\ntemplate \u0026lt;\u0026gt; struct EndpointChecker\u0026lt;0\u0026gt; {  // no endpoint (ray)\n  template \u0026lt;class F\u0026gt; bool operator ()(const F\u0026amp; a, const F\u0026amp; b) const { return true; }};\ntemplate \u0026lt;\u0026gt; struct EndpointChecker\u0026lt;1\u0026gt; {  // closed endpoint\n  template \u0026lt;class F\u0026gt; bool operator ()(const F\u0026amp; a, const F\u0026amp; b) const { return a \u0026lt;\u003d b; }};\ntemplate \u0026lt;\u0026gt; struct EndpointChecker\u0026lt;2\u0026gt; {  // open endpoint\n  template \u0026lt;class F\u0026gt; bool operator ()(const F\u0026amp; a, const F\u0026amp; b) const { return a \u0026lt; b; }};\n\ntemplate \u0026lt;int LA, int LB, int RA, int RB, class F1, class F2, class F3\u0026gt;\nbool intersectLines(const Line\u0026lt;F1\u0026gt;\u0026amp; lhs, const Line\u0026lt;F2\u0026gt;\u0026amp; rhs, Point\u0026lt;F3\u0026gt;\u0026amp; res) {\n  assert(lhs \u0026amp;\u0026amp; rhs);\n  auto s \u003d lhs.ab ^ rhs.ab;\n  if (s \u003d\u003d 0) return false;\n  auto ls \u003d (rhs.a - lhs.a) ^ rhs.ab;\n  auto rs \u003d (rhs.a - lhs.a) ^ lhs.ab;\n  if (s \u0026lt; 0) s \u003d -s, ls \u003d -ls, rs \u003d -rs;\n  bool intersect \u003d\n    EndpointChecker\u0026lt;LA\u0026gt;()(decltype(ls)(0), ls) \u0026amp;\u0026amp; EndpointChecker\u0026lt;LB\u0026gt;()(ls, s) \u0026amp;\u0026amp;\n    EndpointChecker\u0026lt;RA\u0026gt;()(decltype(rs)(0), rs) \u0026amp;\u0026amp; EndpointChecker\u0026lt;RB\u0026gt;()(rs, s);\n  if (intersect) res \u003d lhs.a + lhs.ab * static_cast\u0026lt;F3\u0026gt;(ls) / s;\n  return intersect;\n}\n\ntemplate \u0026lt;class F1, class F2, class F3\u0026gt;\nbool intersectClosedSegments(const Line\u0026lt;F1\u0026gt;\u0026amp; lhs, const Line\u0026lt;F2\u0026gt;\u0026amp; rhs, Point\u0026lt;F3\u0026gt;\u0026amp; res) {\n  return intersectLines\u0026lt;1, 1, 1, 1\u0026gt;(lhs, rhs, res);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow, we\u0027ll consider closed segment intersection when lines can coincide. The code remains the same, except for \u003ccode\u003es \u003d\u003d 0\u003c/code\u003e case.\u003cbr /\u003e First, we check that segments lie on the same line, not on different parallel lines: \u003ccode\u003els !\u003d 0\u003c/code\u003e.\u003cbr /\u003e Intersection of two segments on 1D line is the segment between their maximum left endpoint and minimum right endpoint. \u003ccode\u003eoperator \u0026lt;\u003c/code\u003e we defined introduces strict ordering on any 2D line, so we can apply the solution from 1D case to find the intersection.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F1, class F2, class F3\u0026gt;\nbool intersectSegments(const Line\u0026lt;F1\u0026gt;\u0026amp; lhs, const Line\u0026lt;F2\u0026gt;\u0026amp; rhs, Line\u0026lt;F3\u0026gt;\u0026amp; res) {\n  auto s \u003d lhs.ab ^ rhs.ab;\n  auto ls \u003d (rhs.a - lhs.a) ^ rhs.ab;\n  if (s \u003d\u003d 0) {\n    if (ls !\u003d 0) return false;\n    auto lhsa \u003d lhs.a, lhsb \u003d lhs.b();\n    auto rhsa \u003d rhs.a, rhsb \u003d rhs.b();\n    if (lhsa \u0026gt; lhsb) swap(lhsa, lhsb);\n    if (rhsa \u0026gt; rhsb) swap(rhsa, rhsb);\n    res \u003d Line\u0026lt;F3\u0026gt;(max(lhsa, rhsa), min(lhsb, rhsb));\n    return res.ab \u0026gt;\u003d Point\u0026lt;F3\u0026gt;();\n  }\n  auto rs \u003d (rhs.a - lhs.a) ^ lhs.ab;\n  if (s \u0026lt; 0) s \u003d -s, ls \u003d -ls, rs \u003d -rs;\n  bool intersect \u003d 0 \u0026lt;\u003d ls \u0026amp;\u0026amp; ls \u0026lt;\u003d s \u0026amp;\u0026amp; 0 \u0026lt;\u003d rs \u0026amp;\u0026amp; rs \u0026lt;\u003d s;\n  if (intersect)\n    res \u003d Line\u0026lt;F3\u0026gt;(lhs.a + lhs.ab * static_cast\u0026lt;F3\u0026gt;(ls) / s, Point\u0026lt;F3\u0026gt;());\n  return intersect;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src\u003d\"/predownloaded/8e/ee/8eee5da99375eb0dc63c0ca252290d64d0864881.png\" style\u003d\"float: right;max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eRemember I promised you to show point sorting by polar angle? The time hast cometh! We will sort the points around the given origin using the predicate \u003ccode\u003eccw\u003c/code\u003e. One doesn\u0027t simply apply it when the points are all around the origin. For example, two points on one line with the origin, but to the different sides of it will be considered equal. Therefore, first we partition the plane in two halves using \u003ccode\u003eoperator \u0026gt;\u003c/code\u003e: one above the origin including horizontal ray to the right (greyed out part), one below including horizontal ray to the left. The shortest rotation angle between two points in one half also lies in that half, so we can sort them separately with the \u003ccode\u003eccw\u003c/code\u003e predicate.\u003c/p\u003e\u003cp\u003eThis example is the reason why I compare two points by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e first. Polar angle is counted starting with the positive direction of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-axis. So, I need to divide the plane into upper and lower halves, not left and right that comparison by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e would produce.\u003c/p\u003e\u003cp\u003eSince we need to know the origin when comparing two points, the comparison cannot be done with a simple function, we need a comparator structure. The implementation actually has two \u003ca href\u003d\"http://en.cppreference.com/w/cpp/algorithm/partition\"\u003epartition\u003c/a\u003e calls. Think why the first one is necessary (it separates points that coincide with the origin).\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class F\u0026gt;\nstruct AngleCompare {\n  const Point\u0026lt;F\u0026gt; origin;\n  const bool zero;\n\n  AngleCompare(const Point\u0026lt;F\u0026gt;\u0026amp; origin \u003d Point\u0026lt;F\u0026gt;())\n    : origin(origin), zero(origin \u003d\u003d Point\u0026lt;F\u0026gt;()) {}\n\n  template \u0026lt;class F1, class F2\u0026gt;\n  bool operator () (const Point\u0026lt;F1\u0026gt;\u0026amp; lhs, const Point\u0026lt;F2\u0026gt;\u0026amp; rhs) const {\n    return zero ? ccw(lhs, rhs) \u0026lt; 0 : ccw(lhs, rhs, origin) \u0026lt; 0;\n  }\n};\n\ntemplate \u0026lt;class Iterator, class F\u0026gt;\nvoid sortByAngle(Iterator first, Iterator last, const Point\u0026lt;F\u0026gt;\u0026amp; origin) {\n  first \u003d partition(first, last, [\u0026amp;origin](const decltype(*first)\u0026amp; point) {\n    return point \u003d\u003d origin; });\n  auto pivot \u003d partition(first, last, [\u0026amp;origin](const decltype(*first)\u0026amp; point) {\n    return point \u0026gt; origin; });\n  AngleCompare\u0026lt;F\u0026gt; acmp(origin);\n  sort(first, pivot, acmp);\n  sort(pivot, last, acmp);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eCoordinates range\u003c/h3\u003e\u003cp\u003eOne important detail to discuss is what data type to use, whether in \u003ccode\u003ePoint\u003c/code\u003e template, or your own more specific implementation. Usually, each coordinate\u0027s absolute value is limited by \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e. Operations that significantly increase this value are those performing multiplication: \u003ccode\u003e*\u003c/code\u003e, \u003ccode\u003e^\u003c/code\u003e, \u003ccode\u003edist2\u003c/code\u003e. In all the examples above, and in most other cases, we apply these operations to at most the difference of two input points. Basically, the largest number we can end up with is the squared distance between points \u003cspan class\u003d\"tex-span\"\u003e( - 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e,  - 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e, 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e)\u003c/span\u003e, which is \u003cspan class\u003d\"tex-span\"\u003e8·10\u003csup class\u003d\"upper-index\"\u003e18\u003c/sup\u003e\u003c/span\u003e, and it fits into \u003ccode\u003elong long\u003c/code\u003e. So, you should be fine if you perform all the multiplications in \u003ccode\u003elong long\u003c/code\u003e type. If the input or the output is real, don\u0027t forget to convert to \u003ccode\u003edouble\u003c/code\u003e or \u003ccode\u003elong double\u003c/code\u003e when necessary.\u003c/p\u003e\u003ch3\u003ePractice\u003c/h3\u003e\u003cp\u003eTheory knowledge is worth nothing without practice, so you should go out there and solve problems! To start with, I recommend this \u003ca href\u003d\"//codeforces.com/gym/100168\"\u003etraining contest\u003c/a\u003e. It incorporates most of the examples I provided. I didn\u0027t analyze any problems with rays, so you\u0027ll have to modify the code to work with them. It\u0027s easy, but I believe it helps to improve geometry understanding. There are also problems comprising standard line equation, and after solving them you\u0027ll know everything you need about this equation. The statements are in Russian, but they are very concise and get straight to the point, so any modern translator should handle them with ease.\u003c/p\u003e\u003c/div\u003e","tags":["geometry","tutorial"]}}