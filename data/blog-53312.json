{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1500105916,"rating":-20,"authorHandle":"Felix_Mate","modificationTimeSeconds":1500105916,"id":53312,"title":"\u003cp\u003eНужны мысли по поводу задач с Timus\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eДолго думал над этими задачами,в итоге так и не решил их. Хотелось бы узнать возможные идеи решений.\u003c/p\u003e\u003cp\u003e1) \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1872\"\u003ehttp://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1872\u003c/a\u003e  Решаю так. Во-первых, жадно ищу решение: сортирую s[]-размер офисов, на каждом шаге делаю срезки отрезков [ai,bi] по s[i] и среди полученных отрезков выбираю для s[i] отрезок с наименьшей длиной. Этому отрезку k ставлю в соответствие s[i]: inv[k]\u003di. Во-вторых, если решение есть, проверяю единственность: строю орграф g[][]. Для каждого s[i] ищу те отрезки j, где aj\u0026lt;\u003ds[i]\u0026lt;\u003dbj и inv[j]!\u003di (каждому отрезку соответствует офис inv[j]). Если условия выполнены\u003d\u0026gt; g[i][inv[j]]\u003dtrue. В-третьих, поверяю наличие цикла в g[][]: он существует \u0026lt;\u003d\u0026gt; решение не единственно.\u003c/p\u003e\u003cp\u003eКод с WA29:\u003c/p\u003e\u003cp\u003econst int nmax \u003d 1005;\u003c/p\u003e\u003cp\u003eint a[nmax], b[nmax], s[nmax], inv[nmax];\u003cbr /\u003e int aa[nmax], bb[nmax], cl[nmax];\u003cbr /\u003e bool used[nmax];\u003cbr /\u003e bool g[nmax][nmax];\u003cbr /\u003e int n, cycle_st; \u003c/p\u003e\u003cp\u003evoid QSort(int L, int R);\u003cbr /\u003e bool Exist();\u003cbr /\u003e bool dfs (int v); \u003c/p\u003e\u003cp\u003eint main()\u003cbr /\u003e {  cin\u0026gt;\u0026gt;n;  for(int i\u003d1;i\u0026lt;\u003dn;i++) cin\u0026gt;\u0026gt;s[i];  QSort(1, n);  for(int i\u003d1;i\u0026lt;\u003dn;i++) cin\u0026gt;\u0026gt;a[i]\u0026gt;\u0026gt;b[i];\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eif(Exist())\n{\n   for(int i\u003d1;i\u0026lt;\u003dn;i++)\n      for(int j\u003d1;j\u0026lt;\u003dn;j++)\n         g[i][j]\u003dfalse;\n\n   for(int i\u003d1;i\u0026lt;\u003dn;i++)\n   {\n      for(int j\u003d1;j\u0026lt;\u003dn;j++)\n      {\n         if(inv[j]\u003d\u003di) continue;\n         g[i][inv[j]]\u003d(a[j]\u0026lt;\u003ds[i] \u0026amp;\u0026amp; s[i]\u0026lt;\u003db[j]);\n      }\n   }\n\n  for(int i\u003d1;i\u0026lt;\u003dn;i++) cl[i]\u003d0;\n   cycle_st \u003d -1;\n   for (int i\u003d1; i\u0026lt;\u003dn; i++)\n       if (dfs(i)) break;\n\n  if (cycle_st!\u003d-1) cout\u0026lt;\u0026lt;\u0026quot;Ask Shiftman for help.\u0026quot;;\n   else\n   {\n         cout\u0026lt;\u0026lt;\u0026quot;Perfect!\u0026quot;\u0026lt;\u0026lt;endl;\n         for(int i\u003d1;i\u0026lt;\u003dn;i++) cout\u0026lt;\u0026lt;inv[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\n   }\n}\nelse cout\u0026lt;\u0026lt;\u0026quot;Let\u0027s search for another office.\u0026quot;;\n\nreturn 0;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e}\u003c/p\u003e\u003cp\u003ebool Exist()\u003cbr /\u003e {\u003cbr /\u003e for(int i\u003d1;i\u0026lt;\u003dn;i++) used[i]\u003dfalse;\u003cbr /\u003e for(int i\u003d1;i\u0026lt;\u003dn;i++) aa[i]\u003da[i], bb[i]\u003db[i]; \u003c/p\u003e\u003cp\u003efor(int i\u003d1;i\u0026lt;\u003dn;i++)\u003cbr /\u003e {\u003cbr /\u003e int k\u003d-1;\u003cbr /\u003e for(int j\u003d1;j\u0026lt;\u003dn;j++)\u003cbr /\u003e {\u003cbr /\u003e if(used[j]) continue;\u003cbr /\u003e if(bb[j]\u0026lt;s[i]) return false;\u003cbr /\u003e if(aa[j]\u0026lt;s[i]) aa[j]\u003ds[i];\u003cbr /\u003e if(aa[j]\u003d\u003ds[i] \u0026amp;\u0026amp; (k\u003d\u003d-1 || bb[k]\u0026gt;bb[j])) k\u003dj;\u003cbr /\u003e }\u003cbr /\u003e if(k\u003d\u003d-1) return false;\u003cbr /\u003e used[k]\u003dtrue;\u003cbr /\u003e inv[k]\u003di; //k-\u0026gt;s[i]\u003cbr /\u003e }\u003cbr /\u003e return true;\u003cbr /\u003e } \u003c/p\u003e\u003cp\u003ebool dfs (int v)\u003cbr /\u003e {\u003cbr /\u003e cl[v] \u003d 1;\u003cbr /\u003e for (int j\u003d1; j\u0026lt;\u003dn; j++)\u003cbr /\u003e {\u003cbr /\u003e int to \u003d j;\u003cbr /\u003e if(!g[v][j]) continue;\u003cbr /\u003e if (cl[to] \u003d\u003d 0)\u003cbr /\u003e {\u003cbr /\u003e if (dfs (to)) return true;\u003cbr /\u003e }\u003cbr /\u003e else if (cl[to] \u003d\u003d 1)\u003cbr /\u003e {\u003cbr /\u003e cycle_st \u003d to;\u003cbr /\u003e return true;\u003cbr /\u003e }\u003cbr /\u003e }\u003cbr /\u003e cl[v] \u003d 2;\u003cbr /\u003e return false;\u003cbr /\u003e } \u003c/p\u003e\u003cp\u003evoid QSort(int L, int R)\u003cbr /\u003e {\u003cbr /\u003e int X\u003ds[(L+R)/2];\u003cbr /\u003e int i\u003dL, j\u003dR;\u003cbr /\u003e while(i\u0026lt;\u003dj)\u003cbr /\u003e {\u003cbr /\u003e while(s[i]\u0026lt;X) i++;\u003cbr /\u003e while(s[j]\u0026gt;X) j--;\u003cbr /\u003e if(i\u0026lt;\u003dj)\u003cbr /\u003e {\u003cbr /\u003e int Y\u003ds[i]; s[i]\u003ds[j]; s[j]\u003dY;\u003cbr /\u003e i++, j--;\u003cbr /\u003e }\u003cbr /\u003e }\u003cbr /\u003e if(L\u0026lt;j) QSort(L,j);\u003cbr /\u003e if(i\u0026lt;R) QSort(i,R);\u003cbr /\u003e } \u003c/p\u003e\u003cp\u003e2)\u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d2055\"\u003ehttp://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d2055\u003c/a\u003e  Решать не решился, поскольку нет ясных мыслей. Насколько понимаю, для начало нужно отсортировать рёбра, затем найти минимальное остовное дерево. Затем на каждом шаге выбрасывать ребро наименьшего веса и вновь искать минимальное остовное дерево(с рёбрами, у которых вес \u0026gt;\u003d веса выброшенного ребра). Непонятно, можно ли быстро искать новое остовное дерево, если уже большая часть была построена.\u003c/p\u003e\u003c/div\u003e","tags":[]}}