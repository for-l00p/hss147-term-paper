{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1521717752,"rating":5,"authorHandle":"danya090699","modificationTimeSeconds":1521722916,"id":58507,"title":"\u003cp\u003eРазбор Week 1\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/group/m4pzPe16rE/contest/206137/problem/A\"\u003eA. Делимость\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eЗаметим, что мы можем сдвигать границы на одно и то же число, кратное k. Сдвинем их так, чтобы оба числа стали положительными. Также заметим, что очень легко посчитать кол-во кратных k на отрезке (0, x], это ⌊x / k⌋. Кол-во кратных k на отрезке [l, r] \u003d кол-во кратных k на отрезке (0, r] — кол-во кратных k на отрезке (0, l-1].\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/group/m4pzPe16rE/contest/206137/problem/B\"\u003eB. 123-последовательность\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eПосчитаем кол-во раз, которое встречается каждое из чисел. Если заменить все числа на x, кол-во операций составит n — (кол-во чисел x), следовательно нам нужно заменить все числа на то, которое чаще всех встречается, чтобы минимизировать замены.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/group/m4pzPe16rE/contest/206137/problem/C\"\u003eC. Полоска\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eНайдём сумму чисел на всём отрезке. Посчитаем суммы на префиксах массива длиной 1, 2, ... n-1. pref[1] \u003d a[1], далее будем считать так: pref[i] \u003d pref[i-1] + a[i]. Выведем кол-во i, для которых pref[i] * 2 \u003d сумма чисел всего массива.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/group/m4pzPe16rE/contest/206137/problem/D\"\u003eD. Флаг\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eСначала проверим выполнение первого условия, пройдясь по каждому горизонтальному ряду. Если оно выполняется на всех рядах, остаётся пройтись по всем соседним парам рядов, и проверить, различается ли цвет там.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/group/m4pzPe16rE/contest/206137/problem/E\"\u003eE. Прямоугольные треугольники\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eБудем перебирать все клетки, в которых стоит \u0027*\u0027, и для каждой считать, сколько треугольников имеют в ней вершину, лежащую у угла в 90 градусов. Остальные 2 вершины будут всегда располагаться так: одна в том же столюце, что и текущая, другая в той же строке. Если каждый раз считать эти величины в лоб, общая асимптотика составит \u003cem\u003eO(n * m * (n + m))\u003c/em\u003e, что приведёт к TL. Преподсчитаем кол-во звёздочек для каждой строки и столбца в массивы horizontal[n] и vertical[m] соответственно. Тогда ответом для каждой клетки (i, j) со \u0027*\u0027 будет (horizontal[i] — 1) * (vertical[j] — 1) (-1, т.к. мы не учитываем саму клетку (i, j)). Общим ответом станет сумма по всем таким клеткам.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/group/m4pzPe16rE/contest/206137/problem/F\"\u003eF. Вор и спички\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eОтсортируем контейнеры по уменьшению b[i], и каждый раз будем забирать все коробки из контейнера, если у нас есть для них место и переходить к следующему, иначе заберём все, для которых есть место и завершим процесс. Удобно поддерживать объём свободного места в отдельной переменной и после обработки каждого контейнера пересчитывать.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/group/m4pzPe16rE/contest/206137/problem/G\"\u003eG. Ресторан\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eПодумаем, какой отрезок следует взять, как самый левый для нашего набора. Взяв отрезок (l, r) у нас останется возможность выбирать все отрезки с левой границей большей или равной r. Теперь очевидно, что нужно взять отрезок с наименьшей правой границей, а затем выполнять это же решение для оставшихся доступными отрезков каждый раз, пока кол-во доступных отрезков не станет равно 0. Если делать это наивным способом, каждый раз перебирая все доступные отрезки и находя среди них отрезок с самой маленькой правой границей, мы получим решение за \u003cem\u003eO(n ^ 2)\u003c/em\u003e, что не уложится в лимит времени. Отсортируем все отрезки по увеличению правой границы и будем перебирать их, добавляя в множество отрезок, когда его левая граница больше или равна правой границе предыдущего взятого отрезка. Это будет работать за \u003cem\u003eO(nlogn + n)\u003c/em\u003e (сортировка + проход по массиву).\u003c/p\u003e\u003c/div\u003e","tags":[]}}