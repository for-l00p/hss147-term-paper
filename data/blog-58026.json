{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1519552813,"rating":0,"authorHandle":"zscoder","modificationTimeSeconds":1519552902,"id":58026,"title":"\u003cp\u003eShort Contest 1 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eA. What Do You Do When You Walk on a Circular Path?\u003c/h2\u003e\u003cp\u003eFind the time required for both directions and check which one is smaller (or see if they are equal). If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u0026lt; \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e then the time required to go from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e clockwise is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. Otherwise, it\u0027s \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e + \u003ci\u003en\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. Remember to use long long as the numbers are large.\u003c/p\u003e\u003ch2\u003eB. What Do You Do to Find Palindromes on a Graph?\u003c/h2\u003e\u003cp\u003eThe key observation is that a palindromic path exist if and only if a palindromic path with \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e edges exist. This is because for any palindromic path with more than \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e edges, we can remove the first and last edge repeatedly until it has \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e edges and it will still be a palindromic path.\u003c/p\u003e\u003cp\u003eTo determine if there is a palindromic path with \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e edges, we just have to check for each vertex, whether there exist two edges from it with the same letter.\u003c/p\u003e\u003cp\u003eTo determine if there is a palindromic path with \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e edges, we just have to check for each edge, whether there exist an edge from one endpoint and an edge from the other endpoint which is not the current edge we\u0027re checking that has the same letter.\u003c/p\u003e\u003ch2\u003eC. What Do You Do When You Don\u0027t Know How to Name the Problem?\u003c/h2\u003e\u003cp\u003eLet\u0027s solve the problem for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e first. The permutation \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e - 1, \u003ci\u003en\u003c/i\u003e - 2, ..., 0)\u003c/span\u003e works (and you can prove that it\u0027s the only solution for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eHow about general \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e? Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e be the smallest integer such that \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e ≤ \u003ci\u003en\u003c/i\u003e \u0026lt; 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/sup\u003e\u003c/span\u003e. Let\u0027s start with the permutation \u003cspan class\u003d\"tex-span\"\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e - 1, 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e - 2, ..., 1, 0, 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e, 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e + 1, ..., \u003ci\u003en\u003c/i\u003e - 1)\u003c/span\u003e. Next, we swap \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e + \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003en\u003c/i\u003e - 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. The first \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e elements still satisfies \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4f/8e/4f8e625fe201f3645ecaf058ad7b2de841361a2c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Additionally, the last \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e elements are now just \u003cspan class\u003d\"tex-span\"\u003e0, 1, 2, ..., \u003ci\u003en\u003c/i\u003e - 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e - 1\u003c/span\u003e. The indices of their positions are \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e, 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e + 1, ..., \u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e. Observe that if we solve the same problem for \u003cspan class\u003d\"tex-span\"\u003e0, 1, 2, ..., \u003ci\u003en\u003c/i\u003e - 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e - 1\u003c/span\u003e with positions \u003cspan class\u003d\"tex-span\"\u003e0, 1, 2, ..., \u003ci\u003en\u003c/i\u003e - 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e - 1\u003c/span\u003e, then the same solution works for positions \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e, 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e + 1, ..., \u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e, since the bit \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e doesn\u0027t matter anymore. Thus, we can recursively solve the same problem for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e for the last \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e elements. This gives an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e solution.\u003c/p\u003e\u003ch2\u003eD. What Do You Do at the End of the World?\u003c/h2\u003e\u003cp\u003eNote that at the end, our screen will only have one element, which is the sum of all initial numbers, as the sum of numbers on the screen is invariant, i.e. doesn\u0027t change after any operation.\u003c/p\u003e\u003cp\u003eKey Claim : Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e denote the sum of cubes of all elements on the screen and let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e denote the current score. Then, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e - 3\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e is invariant, i.e. doesn\u0027t change after any operation.\u003c/p\u003e\u003cp\u003eProof : Suppose we apply an operation on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. Then, the sum of cubes of all elements increases by \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e)\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e - \u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e - \u003ci\u003eb\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e \u003d 3\u003ci\u003eab\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e while the score increases by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eab\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e. Thus, the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e - 3\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e increases by \u003cspan class\u003d\"tex-span\"\u003e3\u003ci\u003eab\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e) - 3\u003ci\u003eab\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e) \u003d 0\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eBefore any operations, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e - 3\u003ci\u003eS\u003c/i\u003e \u003d 1\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e + 2\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e + ... + \u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e and at the end, we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e - 3\u003ci\u003eS\u003c/i\u003e \u003d (1\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e + 2\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e + ... + \u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e - 3\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e. Thus, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/13/fe/13fe8d936b2f9eb043bb3ebb6be76ba2c86a5554.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e always holds no matter how the operations are performed. Thus, it remains to compute this sum. The fastest way is to find \u003ca href\u003d\"https://en.wikipedia.org/wiki/Faulhaber%27s_formula\"\u003eFaulhaber\u0027s Formula\u003c/a\u003e and directly use the formulaes for powers of \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e6\u003c/span\u003e on the page. Note that you can also derive the formulaes using Lagrange Interpolation Formula but it\u0027s overkill here. The strange modulo serves no purpose and it\u0027s merely a red herring. The reason \u003cspan class\u003d\"tex-span\"\u003e1\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e, 2\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e, ..., \u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e was used instead of the simple \u003cspan class\u003d\"tex-span\"\u003e1, 2, ..., \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e was because otherwise the answer can be found on OEIS.\u003c/p\u003e\u003ch2\u003eE. What Do You Do When You Have Maximum and Minimum Operations?\u003c/h2\u003e\u003cp\u003eThere are probably many ways to solve this problem. Firstly, let\u0027s look at an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e solution.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e denotes the number of ways to get the result \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e after the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e moves. With this dp, we can get a simple \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e solution. However, it is too slow to pass.\u003c/p\u003e\u003cp\u003eLet\u0027s look at the state transitions of the dp. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e \u003d \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e. If the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th character is \u0027?\u0027, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e] \u003d \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e - 1][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e ≠ \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/b7/e7b7e312717ffd9abac28bc9d3b29ce609e5c7ff.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eIf the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th character is \u0027M\u0027, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e] \u003d \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e - 1][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e \u0026gt; \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e] \u003d 0\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e \u0026lt; \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/78/67/786748e55181702a8b6da66b42b90ebdd1614780.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. The case when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th character is \u0027m\u0027 is similar.\u003c/p\u003e\u003cp\u003eHow do we update the dp values fast. Note that all these operations can be essentially classified as \u0026quot;Set a range to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e\u0026quot;, \u0026quot;Find the sum of a range\u0026quot; and \u0026quot;Add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to a position\u0026quot;. Thus, we can perform these operations in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e with a segment tree with lazy propogation. Note that in the final solution we won\u0027t store a 2D array for the dp but we just store an array denoting the current row of dp and perform updates on this array to get the next row in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time. The time complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5d/1f/5d1f29f648247e77966a5b1703590aea2a6a75b6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003ch2\u003eF. What Do You Do When You Want to Beat The High Score?\u003c/h2\u003e\u003cp\u003eThis is actually a graph theory problem in disguise.\u003c/p\u003e\u003cp\u003eInstead of erasing the letters, let\u0027s assume we\u0027re tiling rectangles with at least one dimension equal to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e on the grid so that no two tiles overlap, intersect and each tile covers the same letter. For each cell of the grid, label it as V if we used a vertical tile to cover it and H if we used a horizontal tile to cover it (it doesn\u0027t matter which letter you use for a \u003cspan class\u003d\"tex-span\"\u003e1 × 1\u003c/span\u003e tile). The key observation is that the number of tiles we used can be computed by considering the number of adjacent Hs and Vs. More specifically, the number of horizontal tiles used is the number of squares with H such that the square to the right is non-existent or has a different letter with the current square + the number of squares with H such that the square to the right has the same letter as the current square and is labelled with V. Similarly, we can compute the number of vertical tiles.\u003c/p\u003e\u003cp\u003eNow, let\u0027s treat a labelling of Hs and Vs as a cut of a graph. Construct a flow graph where each cell is a vertex. For each cell, if the cell to the right of it has different letter or is non-existent, then connect an edge from this cell to the sink vertex with capacity \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, so that when we put the letter H in this cell it means that we increase our answer by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. If the cell to the right of it has same letter as current square, add an edge from this cell to the cell to the right with capacity \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, so that when the letter H is placed in this square and V is placed in the square to the right of it, then the answer is also increased by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Similarly, for each cell, if the cell below it is non-existent or has different letter as the current cell, we add an edge from the source vertex to the current cell with capacity \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. If the cell below it has the same letter as current cell, we add an edge from the cell below to the current cell with capacity \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFinally, we find the size of the minimum cut of the graph, which is equal to the size of the maximum flow of the graph by max-flow min-cut theorem, and this value is the minimum number of tiles needed to tile the whole board properly.\u003c/p\u003e\u003cp\u003eCodes :\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eA\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;ll, null_type, less\u0026lt;ll\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;ll\u0026gt;::iterator sit;\ntypedef map\u0026lt;ll,ll\u0026gt;::iterator mit;\n\nll distclock(ll n, ll a, ll b)\n{\n\tif(a\u0026lt;b) return b-a;\n\telse return b+n-a;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll n,a,b; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\n\tll d1\u003ddistclock(n,a,b); ll d2\u003ddistclock(n,b,a);\n\tif(d1\u003d\u003dd2) cout\u0026lt;\u0026lt;\u0026quot;either\\n\u0026quot;;\n\telse if(d1\u0026gt;d2) cout\u0026lt;\u0026lt;\u0026quot;anticlockwise\\n\u0026quot;;\n\telse cout\u0026lt;\u0026lt;\u0026quot;clockwise\\n\u0026quot;;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eB\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;ll, null_type, less\u0026lt;ll\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;ll\u0026gt;::iterator sit;\ntypedef map\u0026lt;ll,ll\u0026gt;::iterator mit;\n\nconst int N \u003d 500000;\n\nvector\u0026lt;ii\u0026gt; adj[N+1];\nint cnt[N+1][28];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\n\tvector\u0026lt;ii\u0026gt; edges;\n\tfor(int i\u003d0;i\u0026lt;m;i++)\n\t{\n\t\tint u,v; char c; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v\u0026gt;\u0026gt;c; u--; v--;\n\t\tadj[u].pb(mp(v,c)); adj[v].pb(mp(u,c));\n\t\tcnt[u][c-\u0027a\u0027]++; cnt[v][c-\u0027a\u0027]++;\n\t}\n\t//check for palindrome of length 2\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tfor(int j\u003d0;j\u0026lt;26;j++)\n\t\t{\n\t\t\tif(cnt[i][j]\u0026gt;1)\n\t\t\t{\n\t\t\t\tcout\u0026lt;\u0026lt;\u0026quot;Yes\\n\u0026quot;;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t//check for palindrome of length 3\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v\u003dx.fi; int val\u003dx.se;\n\t\t\tcnt[i][val-\u0027a\u0027]--; cnt[v][val-\u0027a\u0027]--;\n\t\t\tfor(int j\u003d0;j\u0026lt;26;j++)\n\t\t\t{\n\t\t\t\tif(cnt[i][j]\u0026gt;0\u0026amp;\u0026amp;cnt[v][j]\u0026gt;0)\n\t\t\t\t{\n\t\t\t\t\tcout\u0026lt;\u0026lt;\u0026quot;Yes\\n\u0026quot;;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt[i][val-\u0027a\u0027]++; cnt[v][val-\u0027a\u0027]++;\n\t\t}\n\t}\n\tcout\u0026lt;\u0026lt;\u0026quot;No\\n\u0026quot;;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;ll, null_type, less\u0026lt;ll\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;ll\u0026gt;::iterator sit;\ntypedef map\u0026lt;ll,ll\u0026gt;::iterator mit;\n\nvi solve(int n)\n{\n\tif(n\u003d\u003d0) return {};\n\tint k\u003d0;\n\twhile((1\u0026lt;\u0026lt;(k+1))\u0026lt;\u003dn) k++;\n\tvi perm(n);\n\tfor(int i\u003d0;i\u0026lt;(1\u0026lt;\u0026lt;k);i++) perm[i]\u003d(1\u0026lt;\u0026lt;k)-1-i;\n\tfor(int i\u003d0;i\u0026lt;n-(1\u0026lt;\u0026lt;k);i++) perm[(1\u0026lt;\u0026lt;k)-1-i]^\u003d(1\u0026lt;\u0026lt;k);\n\tvi tmp \u003d solve(n-(1\u0026lt;\u0026lt;k));\n\tfor(int i\u003d(1\u0026lt;\u0026lt;k);i\u0026lt;n;i++) perm[i]\u003dtmp[i-(1\u0026lt;\u0026lt;k)];\n\treturn perm;\n}\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin\u0026gt;\u0026gt;n;\n\tvi perm \u003d solve(n);\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tcout\u0026lt;\u0026lt;perm[i];\n\t\tif(i+1\u0026lt;n) cout\u0026lt;\u0026lt;\u0027 \u0027;\n\t}\n\tcout\u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eD\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;ll, null_type, less\u0026lt;ll\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;ll\u0026gt;::iterator sit;\ntypedef map\u0026lt;ll,ll\u0026gt;::iterator mit;\n\nconst int MOD \u003d 924844033;\n\nll add(ll a, ll b)\n{\n\ta+\u003db;\n\ta%\u003dMOD;\n\tif(a\u0026lt;0) a+\u003dMOD;\n\treturn a;\n}\n\nll mult(ll a, ll b)\n{\n\ta%\u003dMOD; b%\u003dMOD;\n\ta*\u003db;\n\ta%\u003dMOD;\n\tif(a\u0026lt;0) a+\u003dMOD;\n\treturn a;\n}\n\nll modpow(ll a, ll b)\n{\n\tll r\u003d1;\n\twhile(b)\n\t{\n\t\tif(b\u0026amp;1) r\u003dmult(r,a);\n\t\ta\u003dmult(a,a); b\u0026gt;\u0026gt;\u003d1;\n\t}\n\treturn r;\n}\n\nll S(ll x)\n{\n\tif(x\u0026lt;\u003d0) return 0;\n\tll cur[8]\u003d{};\n\tcur[0]\u003d1;\n\tfor(int i\u003d1;i\u0026lt;\u003d7;i++) cur[i]\u003dmult(cur[i-1],x);\n\treturn mult(modpow(42,MOD-2), add(6*cur[7]+21*cur[6]+21*cur[5]+cur[1], MOD - 7*cur[3]));\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll n; cin\u0026gt;\u0026gt;n;\n\tll S1 \u003d mult(mult(n, n+1), mult(2*n+1, modpow(6,MOD-2)));\n\tll S2 \u003d S(n);\n\tcout\u0026lt;\u0026lt;mult(add(mult(S1,mult(S1,S1)), MOD - S2), modpow(3, MOD-2))\u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eE\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;ll, null_type, less\u0026lt;ll\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;ll\u0026gt;::iterator sit;\ntypedef map\u0026lt;ll,ll\u0026gt;::iterator mit;\n\nint p[511111];\n\nconst int MOD\u003d1e9+7;\n\nint add(int a, int b)\n{\n\ta+\u003db;\n\twhile(a\u0026gt;\u003dMOD) a-\u003dMOD;\n\treturn a;\n}\n\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\n\nstruct node\n{\n\tint sum;\n\tbool lazy; int v;\n};\n\nnode st[511111*4];\n\nvoid push(int id, int l, int r)\n{\n\tif(st[id].lazy)\n\t{\n\t\tif(r-l\u0026gt;\u003d2)\n\t\t{\n\t\t\tst[id*2].lazy\u003dst[id*2+1].lazy\u003d1;\n\t\t\tst[id*2].v\u003dst[id*2+1].v\u003dst[id].v;\n\t\t}\n\t\tst[id].sum \u003d mult(st[id].v, r - l);\n\t\tst[id].lazy\u003d0;\n\t}\n}\n\nvoid combine(int id)\n{\n\tst[id].sum \u003d add(st[id*2].sum,st[id*2+1].sum);\n}\n\nvoid build(int id, int l, int r)\n{\n\tst[id].lazy\u003dfalse; st[id].v\u003dst[id].sum\u003d0;\n\tif(r-l\u0026lt;2)\n\t{\n\t\tif(l\u003d\u003dp[0]) st[id].sum\u003d1;\n\t\treturn ;\n\t}\n\tint mid\u003d(l+r)\u0026gt;\u0026gt;1; build(id*2,l,mid); build(id*2+1,mid,r);\n\tcombine(id);\n}\n\nvoid update(int id, int l, int r, int ql, int qr, int v)\n{\n\tpush(id,l,r);\n\tif(ql\u0026gt;\u003dr||l\u0026gt;\u003dqr) return ;\n\tif(ql\u0026lt;\u003dl\u0026amp;\u0026amp;r\u0026lt;\u003dqr)\n\t{\n\t\tst[id].lazy\u003d1; st[id].v \u003d v; \n\t\tpush(id,l,r); return ;\n\t}\n\tint mid\u003d(l+r)\u0026gt;\u0026gt;1; update(id*2,l,mid,ql,qr,v); update(id*2+1,mid,r,ql,qr,v);\n\tcombine(id);\n}\n\nint sum(int id, int l, int r, int ql, int qr)\n{\n\tpush(id,l,r);\n\tif(ql\u0026gt;\u003dr||l\u0026gt;\u003dqr) return 0;\n\tif(ql\u0026lt;\u003dl\u0026amp;\u0026amp;r\u0026lt;\u003dqr) return st[id].sum;\n\tint mid\u003d(l+r)\u0026gt;\u0026gt;1;\n\treturn add(sum(id*2,l,mid,ql,qr),sum(id*2+1,mid,r,ql,qr));\n}\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tstring s; int n; cin\u0026gt;\u0026gt;n;\n\tfor(int i\u003d0;i\u0026lt;n;i++) {cin\u0026gt;\u0026gt;p[i]; p[i]--;}\n\tcin\u0026gt;\u0026gt;s;\n\tbuild(1,0,n);\n\tfor(int i\u003d1;i\u0026lt;n;i++)\n\t{\n\t\tchar c \u003d s[i-1]; int v \u003d p[i];\n\t\tif(c\u003d\u003d\u0027M\u0027)\n\t\t{\n\t\t\tint s \u003d sum(1,0,n,0,v);\n\t\t\tupdate(1,0,n,0,v,0); update(1,0,n,v,v+1,add(sum(1,0,n,v,v+1),s));\n\t\t}\n\t\telse if(c\u003d\u003d\u0027m\u0027)\n\t\t{\n\t\t\tint s \u003d sum(1,0,n,v+1,n);\n\t\t\tupdate(1,0,n,v+1,n,0); update(1,0,n,v,v+1,add(sum(1,0,n,v,v+1),s));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint s \u003d sum(1,0,n,0,n);\n\t\t\tupdate(1,0,n,v,v+1,add(sum(1,0,n,v,v+1),s));\n\t\t}\n\t}\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tcout\u0026lt;\u0026lt;sum(1,0,n,i,i+1);\n\t\tif(i+1\u0026lt;n) cout\u0026lt;\u0026lt;\u0027 \u0027;\n\t}\n\tcout\u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eF\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;ll, null_type, less\u0026lt;ll\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;ll\u0026gt;::iterator sit;\ntypedef map\u0026lt;ll,ll\u0026gt;::iterator mit;\n\nconst int N \u003d 111;\nint n,m;\nconst int dx[4] \u003d {1,-1,0,0};\nconst int dy[4] \u003d {0,0,1,-1};\nchar a[N+10][N+10];\n\nbool isvalid(int x, int y)\n{\n\treturn (x\u0026gt;\u003d0\u0026amp;\u0026amp;x\u0026lt;n\u0026amp;\u0026amp;y\u0026gt;\u003d0\u0026amp;\u0026amp;y\u0026lt;m);\n}\n\nconst int MX \u003d N*N+20;\nconst int INF \u003d int(1e9);\nconst int INF2 \u003d int(1e6);\nstruct MaxFlow //by yutaka1999, have to define INF and MX (the Max number of vertices)\n{\n\tstruct edge\n\t{\n\t\tint to,cap,rev;\n\t\tedge(int to\u003d0,int cap\u003d0,int rev\u003d0):to(to),cap(cap),rev(rev){}\n\t};\n\tvector \u0026lt;edge\u0026gt; vec[MX];\n\tint level[MX];\n\tint iter[MX];\n\t\n\tvoid addedge(int s,int t,int c) //adds an edge of cap c to the flow graph\n\t{\n\t\tint S\u003dvec[s].size(),T\u003dvec[t].size();\n\t\tvec[s].push_back(edge(t,c,T));\n\t\tvec[t].push_back(edge(s,0,S));\n\t}\n\tvoid bfs(int s)\n\t{\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue \u0026lt;int\u0026gt; que;\n\t\tlevel[s] \u003d 0;\n\t\tque.push(s);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint v \u003d que.front();que.pop();\n\t\t\tfor(int i\u003d0;i\u0026lt;vec[v].size();i++)\n\t\t\t{\n\t\t\t\tedge\u0026amp;e\u003dvec[v][i];\n\t\t\t\tif (e.cap\u0026gt;0\u0026amp;\u0026amp;level[e.to]\u0026lt;0)\n\t\t\t\t{\n\t\t\t\t\tlevel[e.to]\u003dlevel[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll flow_dfs(int v,int t,ll f)\n\t{\n\t\tif (v\u003d\u003dt) return f;\n\t\tfor(int \u0026amp;i\u003diter[v];i\u0026lt;vec[v].size();i++)\n\t\t{\n\t\t\tedge \u0026amp;e\u003dvec[v][i];\n\t\t\tif (e.cap\u0026gt;0\u0026amp;\u0026amp;level[v]\u0026lt;level[e.to])\n\t\t\t{\n\t\t\t\tll d\u003dflow_dfs(e.to,t,min(f,ll(e.cap)));\n\t\t\t\tif (d\u0026gt;0)\n\t\t\t\t{\n\t\t\t\t\te.cap-\u003dd;\n\t\t\t\t\tvec[e.to][e.rev].cap+\u003dd;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tll maxflow(int s,int t) //finds max flow using dinic from s to t\n\t{\n\t\tll flow \u003d 0;\n\t\twhile(1)\n\t\t{\n\t\t\tbfs(s);\n\t\t\tif (level[t]\u0026lt;0) return flow;\n\t\t\tmemset(iter,0,sizeof(iter));\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tll f\u003dflow_dfs(s,t,INF);\n\t\t\t\tif(f\u003d\u003d0) break;\n\t\t\t\tflow +\u003d f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nint getid(int x, int y)\n{\n\treturn x*m+y;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tfor(int j\u003d0;j\u0026lt;m;j++) cin\u0026gt;\u0026gt;a[i][j];\n\t}\n\tMaxFlow mf;\n\tint s \u003d MX-2; int e \u003d MX-1;\n\tfor(int j\u003d0;j\u0026lt;n;j++)\n\t{\n\t\tfor(int k\u003d0;k\u0026lt;m;k++)\n\t\t{\n\t\t\t//if this is in S-cut\n\t\t\tif(!isvalid(j+dx[2],k+dy[2])||a[j+dx[2]][k+dy[2]]!\u003da[j][k])\n\t\t\t{\n\t\t\t\tmf.addedge(getid(j,k), e, 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmf.addedge(getid(j,k), getid(j+dx[2],k+dy[2]), 1);\n\t\t\t}\n\t\t\t//if this is in T-cut\n\t\t\tif(!isvalid(j+dx[0],k+dy[0])||a[j+dx[0]][k+dy[0]]!\u003da[j][k])\n\t\t\t{\n\t\t\t\tmf.addedge(s, getid(j,k), 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmf.addedge(getid(j+dx[0],k+dy[0]), getid(j,k), 1);\n\t\t\t}\n\t\t}\n\t}\n\tcout\u0026lt;\u0026lt;mf.maxflow(s,e)\u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}