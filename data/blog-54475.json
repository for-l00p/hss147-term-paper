{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1505161552,"rating":0,"authorHandle":"platypus179","modificationTimeSeconds":1505250239,"id":54475,"title":"\u003cp\u003eБинарной грусти пост\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eЭто разбор первого контеста. Он вышел грустным, но мы будем это исправлять.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/group/30wV5Q1WFk/contest/215524/problem/A\"\u003eA. Сахир и нубийский рынок.\u003c/a\u003e\u003c/h4\u003e \u003cul\u003e   \u003cli\u003eМоя посылка: \u003ca href\u003d\"http://vasalf.net/cosh/01-bsearch/A.py.html\"\u003eздесь\u003c/a\u003e\u003c/li\u003e   \u003cli\u003eТвоя посылка: \u003ca href\u003d\"/group/30wV5Q1WFk/contest/215524/submission/30161425\" title\u003d\"Посылка 30161425 от AIshutin\"\u003e30161425\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eРешение ОК, но с кодом ты малость упоролся. У меня было бы претензий, если бы ты в этих структурках не набагал. А так, +2 -- это несерьёзно.\u003c/p\u003e\u003cp\u003eСтарайся сокращать количество мест в коде, в которых ты можешь набагать, можно даже в ущерб идейности. В промышленном коде тебя бы, может быть, похвалили за понятность происходящего в коде, но на олимпиадке очень важно сначала быстро написать код (сравни длину содержательного кода у меня и у себя), а потом не закопаться в дебаге. На командных турах время у компа -- вообще самый ценный ресурс; на личных с этим немного попроще, но всё равно, чем меньше кодишь/дебажишь, тем больше придумываешь и тем меньше у тебя к концу тура остаётся решённых, но несданных задач (самые обидные).\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/group/30wV5Q1WFk/contest/215524/problem/B\"\u003eB. Очень приятно!\u003c/a\u003e\u003c/h4\u003e \u003cul\u003e   \u003cli\u003eМоя посылка: \u003ca href\u003d\"http://vasalf.net/cosh/01-bsearch/B.cpp.html\"\u003eздесь\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eВ задаче надо было сделать интерактивный бинпоиск со странными запросами. Надо было найти две точки из какого-то набора.\u003c/p\u003e\u003cp\u003eНайдём бинпоиском сначала одну, а потом на одном из отрезков, на которые она разбила исходный, найдём вторую. Для того, чтобы на отрезке найти точку, надо уметь переходить от отрезка, содержащего точку, к отрезку, содержащему точку, вдвое меньшей длины. Желательно за один запрос. Например, можно спросить, к какой из точек ближе блюдо какое-то блюдо -- к середине отрезка или к соседней с ней точке. После чего мы можем передвинуть одну из границ понятно куда.\u003c/p\u003e\u003cp\u003eЗдесь есть технические детали. Например, непонятно, на котором из двух отрезков искать вторую точку. Заходит такое: попробовать на одном, что-то найти, проверить, что получилось, если нет -- найти на втором. Для того, чтобы проверить, что получилось найти две точки \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, нужно сделать два запроса: от \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e и от \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eb\u003c/i\u003e, \u003ci\u003ea\u003c/i\u003e)\u003c/span\u003e. Оба вернут \u003ccode\u003e\u0026quot;TAK\u0026quot;\u003c/code\u003e тогда и только тогда, когда обе точки лежат в наборе.\u003c/p\u003e\u003cp\u003eКроме того, стоит потестить на всяких противных тестах, когда есть всего две точки, и они, например, очень близко, или, наоборот, в концах отрезка. Для того, чтобы тестить интерактивы, надо написать свою функцию ответа на запрос. На плюсах это можно делать совсем на изи, написав \u003ccode\u003e#ifdef LOCAL\u003c/code\u003e и в одной ветке одну функцию, а в другой -- другую. Настолько же халявного аналога для питона я не знаю, но что-то похожее придумать можно.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/group/30wV5Q1WFk/contest/215524/problem/C\"\u003eC. Левко и массив.\u003c/a\u003e\u003c/h4\u003e \u003cul\u003e   \u003cli\u003eМоя посылка: \u003ca href\u003d\"http://vasalf.net/cosh/01-bsearch/C.cpp.html\"\u003eздесь\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eОчень странно, что ты её не пробовал сдавать.\u003c/p\u003e\u003cp\u003eСделаем бинпоиск по красоте массива. Нам надо уметь быстро отвечать на вопрос, можно ли за не более чем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e изменений получить \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e)\u003c/span\u003e не более, чем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e\u003c/span\u003e. Напишем динамику, которая посчитает минимальное количество действий, за которое можно достичь требуемой красоты.\u003c/p\u003e\u003cp\u003eЗа \u003ccode\u003edp[i]\u003c/code\u003e обозначим минимальное количество действий, требуемое для того, чтобы пофиксить префикс, заканчивающийся в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-том элементе, при том, что мы \u003cem\u003eне изменяем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-тый элемент\u003c/em\u003e. Пересчитывается за линию: перебираем предыдущий элемент \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, который мы не изменяли. Мы можем изменить элементы с \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/span\u003e по \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/span\u003e тогда и только тогда, когда \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e| ≤ (\u003ci\u003ej\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e - 1) * \u003ci\u003emid\u003c/i\u003e\u003c/span\u003e. В этом случае у нас есть переход. Кроме того, мы всегда можем изменить весь префикс. Ответ в такой динамике находится перебором последнего неизменённого элемента.\u003c/p\u003e\u003cp\u003eРаботает за \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f3/a4/f3a40552b602487e66dafb7e8807f17f0c76925e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/group/30wV5Q1WFk/contest/215524/problem/D\"\u003eD. Империя наносит ответный удар.\u003c/a\u003e\u003c/h4\u003e \u003cul\u003e   \u003cli\u003eМоя посылка: \u003ca href\u003d\"http://vasalf.net/cosh/01-bsearch/D.cpp.html\"\u003eздесь\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eВо-первых, ответ влезает в \u003ccode\u003elong long\u003c/code\u003e, так как \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8b/ba/8bba650442749b696304dbe36fe5d87adcf6c2b4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e -- \u003ca href\u003d\"https://ru.wikipedia.org/wiki/%D0%9C%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%BD%D0%BE%D0%BC%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D1%8D%D1%84%D1%84%D0%B8%D1%86%D0%B8%D0%B5%D0%BD%D1%82\"\u003eмультиномиальный коэффициент\u003c/a\u003e, который точно целый.\u003c/p\u003e\u003cp\u003eВо-вторых, если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e подходит, то \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + 1\u003c/span\u003e -- тем более. Значит, по ответу можно сделать бинпоиск.\u003c/p\u003e\u003cp\u003eНам нужно проверять, делится ли \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e!\u003c/span\u003e на сумму каких-то факториалов. Будем решать задачу для каждого простого делителя отдельно, а простые числа предподсчитаем решетом Эратосфена.\u003c/p\u003e\u003cp\u003eСначала поймём степень вхождения простого числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e в число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e!\u003c/span\u003e. Я утверждаю, что это \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/fc/1e/fc1ece609e398aed2d315d54831242f1b35b1e85.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Действительно, первое слагаемое -- количество чисел от \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, делящихся на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e хотя бы один раз, второе -- хотя бы два раза, и так далее. Если просто для каждого \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, встречающегося в бинпоиске, перебрать простое и его степень, это всё равно выйдет норм по времени (\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/67/d7/67d7834e4dceb6509fb597fb26259f9b0ee0b3c9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e от бинпоиска \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/38/00/38008b826789e6d7acda9d429fa63c0d2eaff945.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e от простого и степени простого).\u003c/p\u003e\u003cp\u003eТеперь научимся находить степень вхождения каждого простого в произведение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e!\u003c/span\u003e. Это мы сделаем один раз ровно там же, где мы считаем решето Эратосфена. Вот мы нашли простое \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e. Теперь пробежимся по всем числам, делящимся на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e. Пусть \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6d/c7/6dc72328938769e4b16db91509afd02d6df10da7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Тогда к степени вхождения \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e нужно прибавить количество \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e таких, что \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≥ \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Это количество можно искать за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e, заранее насчитав суффиксные суммы на массиве, в котором в элементе \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e стоит количество таких \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, что \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. Потом нужно прибавить то же, пройдясь по всем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, таким, что \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b0/8f/b08f7799dc9fdbb60f4678b471144d5795cc415a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, потом то же про \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003c/span\u003e, и так далее. Утверждается, что суммарно эта часть работает за 0.6 секунд на плюсах, что точно укладывается в TL. Можно, конечно, написать строгую асимптотическую оценку на количество операций, но мы не будем.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/group/30wV5Q1WFk/contest/215524/problem/E\"\u003eE. Степное разбиение.\u003c/a\u003e\u003c/h4\u003e \u003cul\u003e   \u003cli\u003eМоя посылка: \u003ca href\u003d\"http://vasalf.net/cosh/01-bsearch/E.cpp.html\"\u003eздесь\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eОбозначим за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e количество единиц во входных данных. Пусть в последовательности могло быть \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u0026lt; \u003ci\u003en\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e элементов. Утверждается, что тогда могло быть и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e. Действительно, раз \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u0026lt; \u003ci\u003en\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, то одна из единиц во входных данных является остатком в степном разбиении, а значит, то число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, остатком которого она является, можно разбить на два числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - 1\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Также понятно, что в последовательности не могло быть больше, чем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e элемент. Отсюда, ответ -- набор чисел \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ek\u003c/i\u003e;\u003ci\u003en\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e]\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e -- минимальное возможное количество элементов в последовательности -- можно найти бинпоиском.\u003c/p\u003e\u003cp\u003eНаучимся проверять, могло ли в последовательности быть ровно \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e\u003c/span\u003e элементов. Для этого жадно расставим все степени двойки, которые можем, по этим \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e\u003c/span\u003e числам. Осталось распределить остатки в разбиении (которые также могли быть степенями двойки). Их отсортируем и будем опять жадно назначать на самую большую степень двойки из имеющихся. Если получилось, то могло, иначе -- нет. Доказывается это как и почти любая жадность -- если сделаем так, хуже не будет.\u003c/p\u003e\u003c/div\u003e","tags":[]}}