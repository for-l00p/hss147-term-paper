{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1485364656,"rating":196,"authorHandle":"HellKitsune","modificationTimeSeconds":1485367882,"id":50010,"title":"\u003cp\u003eEducational Codeforces Round 17 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTask A\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eIf you find all the small divisors of n that are less than sqrt(n), you can find the rest of them dividing n by the small ones.\u003c/p\u003e\u003cp\u003eBy the way, this problem is widely known and googlable :) You can, for example, check out this link: \u003ca href\u003d\"http://stackoverflow.com/questions/26753839/efficiently-getting-all-divisors-of-a-given-number\"\u003ehttp://stackoverflow.com/questions/26753839/efficiently-getting-all-divisors-of-a-given-number\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTask B\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTry coming up either with greedy algorithm or with two pointers algorithm.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSpoiler\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTry to prove the following greedy: in each step we can choose the cheapest remaining mouse. If there is a computer left that has only one type of port suitable for this mouse, plug it there. Else if there is a computer with both types, plug it there. Else discard this mouse.\u003c/p\u003e\u003cp\u003eTry to also come up with the two pointers solution. If you cannot, it is described under the next spoiler.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSpoiler\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eSort all of the USB mouses and all of the PS/2 mouses so that the price is non-descending. Then you will need to buy some prefix of USB mouses and some prefix of PS/2 mouses. Iterate over the number of USB mouses from 0 to their count. Now, the more USB mouses you buy and plug into computers, the less PS/2 mouses you will be able to buy, because the number of computers will only be decreasing. So you should move the first pointer forward, and in every iteration move the second pointer backwards until you reach such amount that it is possible to plug both USB and PC/2 mouses in.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTask C\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTry thinking not about erasing a substring from B, but rather picking some number of characters (possibly zero) from the left, and some from the right.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSpoiler\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTwo pointers\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSpoiler\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFor every prefix of B, count how big of a prefix of A you will require. Call these values p[i]. Put infinity in the cells where even whole A is not enough.\u003c/p\u003e\u003cp\u003eSame for every suffix of B count the length of the required suffix of A. Call these values s[i].\u003c/p\u003e\u003cp\u003eNow try increasing the length of prefix of B, while decreasing the length of the suffix until p[pref_len] + s[suf_len] is less or equal to the length of A.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTask D\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThe toughest thing about this task, is that you can go to the left. Try to come up with something to handle that.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSpoiler\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTry to prove that in optimal solution you don\u0027t need to go more than one cell to the left before coming back.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTask E\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTry to come up with a solution where you iterate over each frequency\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSpoiler\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTry to group stations that will be on the left side in a pair in one vector, and stations that will be on the right side in a pair into another.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSpoiler\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eIterate over each frequncy. Suppose you are now on frequency \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Put all radio stations with frequencly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e in the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eleft\u003c/i\u003e\u003c/span\u003e vector, and all radio stations with frequencies \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e..\u003ci\u003ei\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e into the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eright\u003c/i\u003e\u003c/span\u003e vector. Notice, that the total size of all vectors you get this way is no more than \u003cspan class\u003d\"tex-span\"\u003e(2 * \u003ci\u003ek\u003c/i\u003e + 2) * \u003ci\u003en\u003c/i\u003e\u003c/span\u003e, because every radiostation will be one time in the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eleft\u003c/i\u003e\u003c/span\u003e vector and at most \u003cspan class\u003d\"tex-span\"\u003e2 * \u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e times in the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eright\u003c/i\u003e\u003c/span\u003e vector.\u003c/p\u003e\u003cp\u003eNow we need to calculate the number of possible pairs where left radio station is from vector \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eleft\u003c/i\u003e\u003c/span\u003e and right radio station is from vector \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eright\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSort stations in the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eleft\u003c/i\u003e\u003c/span\u003e vector by position. Sort stations in the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eright\u003c/i\u003e\u003c/span\u003e vector by left bound of their range. Iterate over the stations from the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eleft\u003c/i\u003e\u003c/span\u003e vector. Now, as you do that, larger and larger prefix of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eright\u003c/i\u003e\u003c/span\u003e vector will have stations with their left bound less or equal to the coordinate of the currently processed station from the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eleft\u003c/i\u003e\u003c/span\u003e vector. For each new such station you should add 1 to some RSQ structure (easiest is fenwick tree) to the position of this station. Since positions are up to \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e, you will have to compress the coordinates (for example, use index of station in the sorted order instead of it\u0027s coordinate). Can you see how to query this fenwick tree to get the number of stations that match the currently processed station from the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eleft\u003c/i\u003e\u003c/span\u003e vector?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTask F\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eNo nested spoilers. It\u0027s serious business here!\u003c/p\u003e\u003cp\u003eOne of the possible ways to make your life easier is to count the number of automorphisms of tree \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e. This way you will be able to first calculate the number of labeled matchings of vertices of tree \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e to the vertices of tree \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e, and then divide this number by the number of automorphisms.\u003c/p\u003e\u003cp\u003eAlthough solution that I will describe does not use this! :D\u003c/p\u003e\u003cp\u003eFirst, remember that every automorphism has a fixed point. Either a vertex or an edge. This is called center of the tree, and you can find it by first finding the diameter of the tree. It\u0027s middle vertex (or an edge, if there are two middle vertices) is the center of the tree.\u003c/p\u003e\u003cp\u003eLet\u0027s root T at it\u0027s center. Now let\u0027s enumerate subtrees (rooted ones!) of T in such a way that if two subtress are isomorphic they will receive the same number and vice versa. You can do it in a single dfs processing subtrees bottom-up. These numbers will correspond to different isomorphisms.\u003c/p\u003e\u003cp\u003eNow you can do a dp with memoization to calculate for each subtree of S rooted at some directed edge the number of ways to \u0026quot;attach\u0026quot; each of the isomorphisms from above to this subtree. This can be done by going through all immediate children of the currently processed vertex of S and doing a bitmask DP, where bits are immediate children of the root of currently processed isomophism of T. 1 means it is \u0026quot;attached\u0026quot; to some children in S, 0 means not.\u003c/p\u003e\u003cp\u003eOne of the problems here is that root of current isomorphism of T can have isomorphic children, and if we shuffle how they are attached to children in S we will still receive the same way to cover S with T, so we will calculate some ways twice or more. The solution is to sort children by their isomorphism number and when processing a bitmask, never put 1 to the bit that has a 0 bit to the left that corresponds to the child with the same isomorphism number. This way you will match such children in a fixed order and won\u0027t calculate anything unnecessary.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}