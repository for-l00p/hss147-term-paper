{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1474818287,"rating":0,"authorHandle":"1am","modificationTimeSeconds":1474905396,"id":47355,"title":"\u003cp\u003eDay 9 (9/24)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eUndirected Graphs\u003c/h1\u003e\u003cp\u003eIn undirected graphs, in the input if they tell you node a and node b are connected, that means that there is a path from a -\u0026gt; b and from b -\u0026gt;a. The difference here in the adjacency matrix is that we must push g[a].push_back (b) and g[b].push_back (a).\u003c/p\u003e\u003cp\u003eA tree is an undirected graph that has n nodes that are ALL connected by n-1 edges. That means that the number of edges are just enough to keep all the nodes connected, meaning that there cannot be any possible cycles in a tree.\u003c/p\u003e\u003cp\u003eTo figure out if an undirected graph contains cycles, this can be done through a simple dfs. If we visit somewhere that has already been marked as visited and is NOT the parent that we just came from, then that means that there is a cycle in the graph. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid dfs (int u, int parent){\n\t\n\tvis[u] \u003d true;\n\tfor (int i\u003d0; i\u0026lt;g[u].size(); i++){\n\t\tint v\u003d g[u][i];\n\t\tif (v !\u003dparent \u0026amp;\u0026amp; vis[v]){\n\t\t\tputs(\u0026quot;CYCLE\u0026quot;);\n\t\t\texit (0);\n\t\t}\n\t\tif (v !\u003d parent  \u0026amp;\u0026amp; !vis[v]){\n\t\t\tdfs (v, u);\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRemember, there could be more than one component, so make sure to run a dfs through every node that is still not visited.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (int i\u003d0; i \u0026lt;n; i++){\n\tif (!vis[i]){\n\t\tdfs (i, -1);\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf you are running a dfs through a tree, there is no need for a visited array. That is because we are sure that there is no cycles. So if input states that the given graph is a tree, then the only check needed in our dfs for loop is that the node we are visiting is not the parent we came from.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid dfs (int u, int parent){\n\tfor (int i\u003d0; i\u0026lt;g[u].size(); i++){\n\t\tint v\u003d g[u][i];\n\t\tif (v !\u003d parent){\n\t\t\tdfs (v, u);\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe also only need to run one dfs since we know that the entire graph is connected.\u003c/p\u003e\u003ch1\u003eDirected Graphs\u003c/h1\u003e\u003cp\u003eIn a directed graph, if input states that node a and b are connected, that means that that you can travel from a -\u0026gt; b, but you cannot travel from b -\u0026gt;a ( unless input also says b a in another line).\u003c/p\u003e\u003cp\u003eA DAG (Directed Acyclic Graph) is a directed graph with no cycles. If input says that the given graph is garunteed to be a DAG, then that means there is no cycles and if node a is connected to b, then 100% b is NOT connected to a.\u003c/p\u003e\u003cp\u003eThat helps us a lot, because we now know we can run a dfs through out graph without anyyyy checks, like so:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid dfs (int u){\n\tvis[u] \u003d true;\n\tfor (int i\u003d0; i\u0026lt;g[u].size(); i++){\n\t\tint v\u003d g[u][i];\n\t\tdfs (v);\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTo figure out if a directed graph is a DAG (contains no cycles), you can use a topological sort which will be explained next.\u003c/p\u003e\u003ch1\u003eTopological Sort\u003c/h1\u003e\u003cp\u003eA topological sort or topological ordering of a directed graph is a linear ordering of its nodes such that if there is an edge from u to v, v comes after u in the ordering. This can help us solve problems like finding an order for your courses (knowing that course u is a prerequisite to course v). \u003c/p\u003e\u003cp\u003eThe algorithm works like this: 1. Count the in degree of all nodes 2. Run through all nodes and push into queue the nodes that have an in degree of 0 ( we can start with them) 3. while the queue is not empty, go through all adjacent of front of queue and decrease in degree of them by 1 4. If an adjacent now has an indegree of 0, we can now work with it, so push it into queue\u003c/p\u003e\u003cp\u003eThe order in which we visit the nodes is our topological sort.\u003c/p\u003e\u003cp\u003eNow a topological sort is only possible if the graph is a DAG (has no cycles). Take for example the following cycle.\u003c/p\u003e\u003ccenter\u003e \u003cimg align\u003d\"middle\" height\u003d\"150px\" src\u003d\"/predownloaded/08/55/08559482aed25f7c11833b459f635d10f8cf3c5b.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" width\u003d\"150px\" /\u003e \u003c/center\u003e\u003cp\u003eThe in degree of each node is 1, so there is no where to start the topological sort. Therefore we have three unvisited edges. We can use this fact to figure out if a dag contains cycles. Whilst doing the topological sort, keep a counter of the number of edges visited so far (initially m) and decrease in for loop. If the counter is not zero by the end of the sort, that means there is a cycle and the graph is not a DAG.\u003c/p\u003e\u003cp\u003eHere is the code for it including cycle detection: \u003ca href\u003d\"http://ideone.com/vx9lLX\"\u003ehttp://ideone.com/vx9lLX\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eUnion- Find /Disjoint Set Data Structure (DSU)\u003c/h1\u003e\u003cp\u003eThis data structure is a quick way of finding if two nodes are connected in an undirected graph. We talked about two ways of solving this problem, the first one was running a dfs through every component and assigning each one a number. Now this solution won\u0027t work in questions where the queries are connect and check, like this one: \u003ca href\u003d\"https://uva.onlinejudge.org/index.php?option\u003dcom_onlinejudge\u0026amp;Itemid\u003d8\u0026amp;category\u003d24\u0026amp;page\u003dshow_problem\u0026amp;problem\u003d734\"\u003ehttps://uva.onlinejudge.org/index.php?option\u003dcom_onlinejudge\u0026amp;Itemid\u003d8\u0026amp;category\u003d24\u0026amp;page\u003dshow_problem\u0026amp;problem\u003d734\u003c/a\u003e\u003c/p\u003e\u003cp\u003eHere is the code for it: \u003ca href\u003d\"https://tausiq.wordpress.com/2012/05/19/uva-793-network-connections/\"\u003ehttps://tausiq.wordpress.com/2012/05/19/uva-793-network-connections/\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIt will give TLE if you run a dfs through the graph every time. Therefore the best solution is to use a DSU data structure. For every component, we assign it a parent.\u003c/p\u003e\u003cp\u003eWe we want to join two unconnected nodes together, we simply join their parents, and make one the parent of another. The parent of a component\u0027s parent is itself. That node will be used to represent the entire component. Here is the basic code for it: \u003ca href\u003d\"http://ideone.com/mgHOgk\"\u003ehttp://ideone.com/mgHOgk\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI put question Restructuring Company as a challenge, it can be solved using disjoint set, but there is a trick to it. I will solve it next week inshallah.\u003c/p\u003e\u003cp\u003eGood luck! \u003c/p\u003e\u003c/div\u003e","tags":[]}}