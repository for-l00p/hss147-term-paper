{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1483735125,"rating":-13,"authorHandle":"Iwaskid","modificationTimeSeconds":1483735224,"id":49624,"title":"\u003cp\u003eDoes Dijkstra work on graphs with distances that depend on 2 variables?\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e(First time writing a blog, sorry for any confusions)\u003c/p\u003e\u003cp\u003eNormally, in a shortest-path problem, the distance from one node to another node usually is determined by only one variable (usually the \u0026quot;cost\u0026quot; of that edge), which can be implemented by maintaining a priority queue of nodes based on the values of the edges.\u003c/p\u003e\u003cp\u003eRecently I encountered a USACO Problem (link \u003ca href\u003d\"http://www.usaco.org/index.php?page\u003dviewproblem2\u0026amp;cpid\u003d210\"\u003ehere\u003c/a\u003e: where the cost between an edge depend on two variables: the latency of the pipes, and the minimum capacity of the pipes. While the problem \u003ca href\u003d\"http://www.usaco.org/current/data/sol_mroute.html\"\u003esolution\u003c/a\u003e provided by USACO tells us to consider latency and capacity separately (by iterating over all possible capacities and run Dijkstra on edges that have at least that capacity), I wonder if it is possible to use just one Dijkstra search, while considering both variables at the same time. Here is my code:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;fstream\u0026gt;\n#include\u0026lt;queue\u0026gt;\n#include\u0026lt;math.h\u0026gt;\n#include\u0026lt;functional\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n#include\u0026lt;vector\u0026gt;\nusing namespace std;\n#define mp make_pair\n#define MAX 1e9\nint n, m, x;\nclass sss {\npublic:\n\tdouble lat, cap;\n\tsss(double n1, double n2) {\n\t\tlat \u003d n1, cap \u003d n2;\n\t}\n\tdouble calct() {\n\t\treturn lat + x / cap;\n\t}\n};\nclass cmpsss {\npublic:\n\tbool operator()(pair\u0026lt;sss,int\u0026gt;c1, pair\u0026lt;sss,int\u0026gt;c2) {\n\t\treturn c1.first.calct() \u0026gt; c2.first.calct();\n\t}\n};\nvector\u0026lt;pair\u0026lt;int,pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt;neibs[501];\n\ndouble dist[501];\nvoid dijk() {\n\tfor (int i \u003d 0; i \u0026lt;\u003d n; i++) {\n\t\tdist[i] \u003d MAX;\n\t}\n\tdist[1] \u003d 0;\n\tpriority_queue\u0026lt;pair\u0026lt;sss, int\u0026gt;, vector\u0026lt;pair\u0026lt;sss, int\u0026gt;\u0026gt;, cmpsss\u0026gt; q;\n\tq.push(mp(sss(0, MAX), 1));\n\twhile (!q.empty()) {\n\t\tpair\u0026lt;sss, int\u0026gt; nownode \u003d q.top(); q.pop();\n\t\tint cur \u003d nownode.second;\n\t\tdouble curlat \u003d nownode.first.lat;\n\t\tdouble curcap \u003d nownode.first.cap;\n\t\tif (dist[cur] \u0026lt; nownode.first.calct()\u0026amp;\u0026amp;cur!\u003d1)continue;\n\t\tfor (int i \u003d 0; i \u0026lt; neibs[cur].size(); i++) {\n\t\t\tint next \u003d neibs[cur][i].first;\n\t\t\tdouble nextlat \u003d neibs[cur][i].second.first;\n\t\t\tdouble nextcap \u003d min(int(curcap), neibs[cur][i].second.second);\n\t\t\tif (dist[next] \u0026gt; curlat + nextlat + x / nextcap) {\n\t\t\t\tdist[next] \u003d curlat + nextlat + x / nextcap;\n\t\t\t\tq.push(mp(sss(nextlat, nextcap), next));\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tifstream fin(\u0026quot;mroute.in\u0026quot;);\n\tofstream fout(\u0026quot;mroute.out\u0026quot;);\n\tfin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; x;\n\tfor (int i \u003d 0; i \u0026lt; m; i++) {\n\t\tint node1, node2, cost, cap;\n\t\tfin \u0026gt;\u0026gt; node1 \u0026gt;\u0026gt; node2 \u0026gt;\u0026gt; cost \u0026gt;\u0026gt; cap;\n\t\tneibs[node1].push_back(mp(node2, mp(cost,cap)));\n\t\tneibs[node2].push_back(mp(node1, mp(cost,cap)));\n\t\n\t}\n\tdijk();\n\tfout \u0026lt;\u0026lt; floor(dist[n]) \u0026lt;\u0026lt; endl;\n\treturn 0;\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn my code, I wrote a class called \u003ccode\u003esss\u003c/code\u003e to store both the latency and the capacity. The member function \u003ccode\u003ecalct()\u003c/code\u003e calculates the combined cost of both variables, given the edge. The priority queue compares two nodes using the same function \u003ccode\u003ecalct()\u003c/code\u003e. However, this \u003cstrong\u003edid not work\u003c/strong\u003e when I submitted it online. Is my solution wrong, or Dijkstra just does not work when the cost is determined by two variables? Thanks.\u003c/p\u003e\u003c/div\u003e","tags":["dijkstra","dijkstras validity","shortest path","graph"]}}