{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1429031292,"rating":0,"authorHandle":"robinyu","modificationTimeSeconds":1437414560,"id":17400,"title":"\u003cp\u003eDynamic Programming Problems\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eDynamic programming problems, often abbreviated as DP problems, are problems which, unsurprisingly, require the use of dynamic programming to solve. The concept of \u0026quot;dynamic programming\u0026quot; is not a simple one, and often these kinds of problems end up as one of the harder problems in a problem set. Some dynamic programming problems are usually even combined with graph theory, data structures, divide and conquer, and maths, forming even harder problems. Even most \u0026quot;pure\u0026quot; dynamic programming problems are quite hard in their own right.\u003c/p\u003e\u003cp\u003eDynamic programming is a method of solving a complex problem by breaking it down into smaller, easier sub-problems, until reaching a trivial case. For dynamic programming to be efficient, the sub-problems must be overlapping, that is, the same sub-problems occur multiple times while computing, and there must be an \u0026quot;optimal substructure\u0026quot; — given the optimal answers to smaller sub-problems, one must be able to get the optimal answer to a larger sub-problem. For example, consider the relatively easy dynamic programming problem:\u003c/p\u003e\u003cp\u003e\u003cem\u003eYou have a very long gold bar of length N. Recently, you decided to sell it. But you found out, that you can cut the gold bar and sell it for different prices. In particular, selling a gold bar of length K will give you C\u003csub\u003eK\u003c/sub\u003e dollars. What\u0027s the maximum profit that you can get?\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003e1 ≤ N ≤ 10\u003csup\u003e3\u003c/sup\u003e\u003c/em\u003e\u003cbr /\u003e \u003cem\u003e1 ≤ C\u003csub\u003ei\u003c/sub\u003e ≤ 10\u003csup\u003e6\u003c/sup\u003e\u003c/em\u003e\u003cbr /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eInput:\n5\n5 11 14 18 20\n\nOutput:\n27\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFor the example above, we can cut the gold bar into lengths 2, 2 and 1, and then we can sell them for 11+11+5 \u003d 27 dollars. This way gives us the most profit.\u003c/p\u003e\u003cp\u003eLet\u0027s define a function F(N) which will tell us the maximum profit we can get with a gold bar of length N.\u003c/p\u003e\u003cp\u003eObviously if N \u003d 1, our maximum profit is C\u003csub\u003e1\u003c/sub\u003e. Otherwise, we have two choices:\u003c/p\u003e \u003col\u003e   \u003cli\u003eSell the gold bar for C\u003csub\u003eN\u003c/sub\u003e dollars.\u003c/li\u003e   \u003cli\u003eCut the gold bar somewhere, forming two smaller gold bars with length i and N-i, and get F(i) + F(N-i) dollars.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eWe want the maximum profit, so we take the option which will give the most profit. (Note that the second option actually has more than one option, since there are many places we can cut the gold bar). Also, notice the optimal substructure — given the maximum profit we can get for smaller gold bars, we can calculate the maximum profit for the larger gold bar.\u003c/p\u003e\u003cp\u003eSo, our \u003cem\u003erecursive function\u003c/em\u003e can be defined as such:\u003c/p\u003e\u003cp\u003eF(1) \u003d C\u003csub\u003e1\u003c/sub\u003e\u003cbr /\u003e F(N) \u003d max(C\u003csub\u003eN\u003c/sub\u003e, F(i)+F(N-i) for all 1 ≤ i \u0026lt; N)\u003c/p\u003e\u003cp\u003eIf you run this function on any \u0026quot;medium-size input\u0026quot; (around N \u003d 50), however, you will find that it never seems to end. That is because this function takes O(N \u003cspan class\u003d\"tex-span\"\u003e·\u003c/span\u003e 2\u003csup\u003eN\u003c/sup\u003e) time \u003d \u003cem\u003every inefficient\u003c/em\u003e!\u003c/p\u003e\u003cp\u003eBut notice that we are computing the function for the same parameters over and over! Of course, this function returns the same value for the same parameters, so how about we \u003cem\u003estore the results of the function\u003c/em\u003e somewhere, and then instead of calling the function, we check first if we already have the result. If not, we compute the result and store it, but if we already have the value, there is no need to compute it again.\u003c/p\u003e\u003cp\u003eNow this program only has N different \u0026quot;states\u0026quot;, or different parameters we can pass to the function, as we can only call F(N) with up to N values. Since it takes O(N) time to compute one state, doing that \u0026quot;trick\u0026quot; — which is the heart of dynamic programming — will let our program run in only O(N\u003csup\u003e2\u003c/sup\u003e) time, which is very reasonable for the limit.\u003c/p\u003e\u003cp\u003eTo practice your skill of solving dynamic programming problems, consider solving the following:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/332/B\"\u003e332B - Maximum Absurdity\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/433/B\"\u003e433B - Kuriyama Mirai\u0027s Stones\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/225/C\"\u003e225C - Barcode\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/505/C\"\u003e505C - Mr. Kitayuta, the Treasure Hunter\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/106/D\"\u003e106D - Treasure Island\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/519/D\"\u003e519D - A and B and Interesting Substrings\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/479/E\"\u003e479E - Riding in a Lift\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://www.hackerrank.com/contests/noi-ph-mock/challenges/reverse-trip-to-jerusalem\"\u003eNOI.PH 2014 Mock - Reverse Trip to Jerusalem\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://www.hackerrank.com/contests/noi-ph/challenges/christopher-candy\"\u003eNOI.PH 2014 Eliminations - Christopher\u0027s Candy Chaos\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://www.hackerrank.com/contests/noi-ph/challenges/skwishinese\"\u003eNOI.PH 2014 Eliminations - Skwishinese\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://www.hackerrank.com/contests/noi-ph-finals/challenges/all-for-9-9-for-all\"\u003eNOI.PH 2014 Finals - All for Nine and Nine for All\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://www.hackerrank.com/contests/noi-ph-2015-practice/challenges/lolcuts\"\u003eNOI.PH 2015 Practice - Lolcuts\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://www.hackerrank.com/contests/noi-ph-2015-1/challenges/kambyo-kard\"\u003eNOI.PH 2015 Eliminations (Day 1) - Kambyo Kard\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://www.hackerrank.com/contests/noi-ph-2015-2/challenges/this-problem-is-so-fetch\"\u003eNOI.PH 2015 Eliminations (Day 2) - This Problem Is So Fetch\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://www.hackerrank.com/contests/noi-ph-2015-finals-practice/challenges/ham-path\"\u003eNOI.PH 2015 Finals Practice - Ham Path\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://www.hackerrank.com/contests/cp-entrance-2015/challenges/international-baccalaureate\"\u003eCPEC 2015 - International Baccalaureate\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eNote that dynamic programming is really a hard topic to master, and you should keep practicing it to be good at programming contests. The problems above are the \u0026quot;easier\u0026quot; examples of dynamic programming (which are already quite difficult), and it gets much harder once the dynamic programming approach starts to be mixed with graphs, geometry, and difficult data structures.\u003c/p\u003e\u003c/div\u003e","tags":["dp"]}}