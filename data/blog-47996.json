{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1477424923,"rating":0,"authorHandle":"Fcdkbear","modificationTimeSeconds":1477511514,"id":47996,"title":"\u003cp\u003eРазбор VNTU Training 1 (For second year students!)\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eЗадача А\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЕсть 4 принципиально разных случая:\u003c/p\u003e\u003cp\u003e1) Точки лежат на горизонтальной прямой. Тогда квадрат достраивается просто — находим расстояние между точками и откладываем вертикально от них точки на таком же расстоянии\u003c/p\u003e\u003cp\u003e2) Аналогичный случай с вертикальной прямой\u003c/p\u003e\u003cp\u003e3) Теперь точки точно не лежат на горизонтальной или вертикальной прямой. Если вертикальное расстояние между ними не равно горизонтальному — ответ -1.\u003c/p\u003e\u003cp\u003e4) Иначе же, ответ x1 y2 x2 y1\u003c/p\u003e\u003cp\u003eСложность — O(1).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача B\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВ задаче нужно сделать прям то, что написано в условии — посчитать, сколько у каждой клетки соседей с \u0027o\u0027. Если есть хоть одна клетка с нечетным количеством таких соседей — ответ NO, иначе YES\u003c/p\u003e\u003cp\u003eСложность — O(N*N).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача C\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗадача на динамику. Напишем динамику с состоянием (n; f). Ее суть в следующем: мы стоим в какой-то вершине дерева, нам предстоит еще пройти путь длиной n. Переменная f показывает, проходили ли мы на пути до этой вершины ребро с весом \u0026gt;\u003d d. База динамики очевидна: Если n \u0026lt; 0 — стоит вернуть 0, если n \u003d\u003d 0, то тогда нам нужно вернуть 1 если мы проходили ребро с весом \u0026gt;\u003d d, иначе нам следует вернуть 0. Переходы в динамике — это просто переходы по дереву в какого-то сына. Мы переберем, в какого именно сына мы пойдем, обновим значение n и при необходимости — f. Ответы по всем переходам стоит просуммировать.\u003c/p\u003e\u003cp\u003eСложность — O(n*d)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача D\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗадачу легче всего решить перебором. Переберем все возможные наборы задач (их — \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e) и проверим, выполняется ли для них требуемое свойство. Если да — увеличим ответ на 1.\u003c/p\u003e\u003cp\u003eЛегче всего такой перебор реализовать при помощи рекурсии. Будем поддерживать нашу текущую позицию, текущую сумму, минимум, максимум и количество взятых задач. База — мы посмотрели все задачи. Тогда проверим, выполняется ли интересующее нас условие (используя сумму, минимум, максимум и количество). Если да — вернем 1, иначе 0.\u003c/p\u003e\u003cp\u003eПереход рекурсии — или берем очередную задачу, или пропускаем ее.\u003c/p\u003e\u003cp\u003eСложность — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача Е\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗадача релевантна к теме последней лекции. По факту, в задаче нам дали альтернативное определение двудольного графа :). Проверка на то, является ли граф двудольным (и в случае положительного ответа — разбитие его на доли) делается при помощи bfs/dfs. Детали: \u003ca href\u003d\"http://e-maxx.ru/algo/bipartite_checking\"\u003ehttp://e-maxx.ru/algo/bipartite_checking\u003c/a\u003e\u003c/p\u003e\u003cp\u003eСложность — O(n + m)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача F\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eНужно очень аккуратно перебрать все степени числа k до тех пор, пока эта степень не больше чем r (Таких степеней — O(log(r))). Чтобы проверить, или очередная степень не будет больше, чем r, следует сделать следующее. Пусть наша текущая степень равна p, и мы хотим узнать, правда ли, что p * k \u0026lt;\u003d r. Умножать нельзя, ведь возможно переполнение. Поэтому проверим, или p \u0026lt;\u003d r / k\u003c/p\u003e\u003cp\u003eСложность O(log(R))\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача G\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eДавайте моделировать вид последовательности следующим образом. Пока группа полностью влазит в нашу последовательность — будем \u0026quot;пропускать\u0026quot; ее (просто отнимая от n ее размер). Как только группа перестала полностью влазить в последовательность (или же она влазит полностью, но после нее не будет никаких элементов) — просто выведем n как ответ.\u003c/p\u003e\u003cp\u003eПочему это работает быстро? Утверждается, что мы сделаем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003esqrt\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e отниманий. Действительно, сначала мы отнимем от n 1, потом — 2, потом 3.\u003c/p\u003e\u003cp\u003eДопустим, мы отнимали и в конце получили 0. Сколько отниманий мы сделаем? Имеем следующее уровнение:\u003c/p\u003e\u003cp\u003e1 + 2 + 3 + .. + x \u003d n\u003c/p\u003e\u003cp\u003ex*(x+1) / 2 \u003d n\u003c/p\u003e\u003cp\u003eОтсюда уже легко видеть, что число х — наше количество отниманий — имеет порядок \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003esqrt\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eЕсли мы в конце отниманий получили не 0 — это значит, что мы сделаем только 1 лишнюю операцию, что на сложность не влияет.\u003c/p\u003e\u003cp\u003eИ того, сложность алгоритма — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003esqrt\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача H\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eНаташа знает, что какую строчку она бы не выбрала, Павел выберет из нее минимальный элемент. Соответственно, она выберет строчку с максимальным минимумом. Этот максимальный минимум и есть ответ на задачу.\u003c/p\u003e\u003cp\u003eСложность O(n*m)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача I\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eНам по факту нужно проверять, является ли граф какой-то топологией.\u003c/p\u003e\u003cp\u003eКак это делать:\u003c/p\u003e\u003cp\u003e1) Bus topology. Достаточно проверить, что у васех вершин, кроме двух — по 2 соседа (степень \u003d 2), а у остальных двух вершин — степень \u003d 1.\u003c/p\u003e\u003cp\u003e2) Ring topology. Степень всех вершин должна быть равна 2, но этого недостаточно: представьте себе, например, два кольца вместо одного. Давайте физически пробежимся по кольцу, начиная с нулевой вершины. Необходимо убедиться, что мы снова посетим вершину 0 после n шагов (и при этом не посетим ее раньше).\u003c/p\u003e\u003cp\u003e3) Star topology. Степень всех вершин, кроме одной, должна быть равна 1. Степень той последней вершины должна быть равна n — 1.\u003c/p\u003e\u003cp\u003eЕсли ни одна из этих топологий не подошла — ответ unknown topology.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача J\u003c/strong\u003e Идея решения в том, чтобы действовать жадно. То, что мы можем вообще нчиего не делать, и при этом — Ксюша не заметит записку, позволяет нам делать это. Суть алгоритма описывается фразой: если мы можем передать записку ближе к цели — сделаем это, иначе — просто пропустим ход. \u003c/p\u003e\u003cp\u003eЭтот алгоритм легко реализовать, поддерживая свою текущую позицию, текущий момегнт времени, а так же то, сколько этапов слежки Ксюши мы уже прошли. \u003c/p\u003e\u003cp\u003eЛегко увидеть, что мы сделаем не более чем n+m ходов, значит наша сложность — O(n + m)\u003c/p\u003e\u003c/div\u003e","tags":[]}}