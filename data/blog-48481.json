{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1479577868,"rating":19,"authorHandle":"ebanner","modificationTimeSeconds":1479580838,"id":48481,"title":"\u003cp\u003eEuclid\u0027s Algorithm\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eEvery time I use Euclid\u0027s algorithm, I have to re-convince myself why it works. This blog post will provide an explanation of Euclid\u0027s algorithm so I can refer back to it in the future. Hopefully it will also be useful for others!\u003c/p\u003e\u003cp\u003eEuclid\u0027s algorithm can be expressed in just a single line of python (assuming \u003ccode\u003eb \u0026gt;\u003d a\u003c/code\u003e):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003edef gcd(a, b):\n    return a if b \u003d\u003d 0 else gcd(b, a%b)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe base case of this algorithm is quite reasonable; it says the largest number which divides both any number and \u003ccode\u003e0\u003c/code\u003e is just that number. The recursive step requires a bit more explanation, however. For ease of explanation, consider the following diagram (courtesy of \u003ca href\u003d\"https://en.wikipedia.org/wiki/Euclidean_algorithm\"\u003ewikipedia\u003c/a\u003e):\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Euclid\u0027s Algorithm\" src\u003d\"/predownloaded/91/d6/91d6c2f413f7c5f10146666658eed1e8b8fe9aae.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eSay we are interested in computing \u003ccode\u003egcd(BA, DC)\u003c/code\u003e. One very helpful way to think about recursion is as a black box. What if we had \u003ccode\u003egcd(DC, EA)\u003c/code\u003e? Could we use it to compute \u003ccode\u003egcd(BA, DC)\u003c/code\u003e?\u003c/p\u003e\u003cp\u003eAs an aside, we can think of a number \u003ccode\u003eb\u003c/code\u003e dividing \u003ccode\u003ea\u003c/code\u003e as being able to \u0026quot;stack\u0026quot; columns of length \u003ccode\u003eb\u003c/code\u003e to reach a height of exactly \u003ccode\u003ea\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eLet \u003ccode\u003en \u003d gcd(DC, EA)\u003c/code\u003e. What do we know about \u003ccode\u003en\u003c/code\u003e? Well, by definition \u003ccode\u003en\u003c/code\u003e divides both \u003ccode\u003eDC\u003c/code\u003e and \u003ccode\u003eEA\u003c/code\u003e (and is the largest such number that does so). Because \u003ccode\u003en\u003c/code\u003e divides \u003ccode\u003eDC\u003c/code\u003e, we can stack multiple copies of \u003ccode\u003en\u003c/code\u003e to get up to a height of exactly \u003ccode\u003eDC\u003c/code\u003e. \u003ccode\u003en\u003c/code\u003e also divides \u003ccode\u003eEA\u003c/code\u003e, which is exactly how much height remains to reach \u003ccode\u003eBA\u003c/code\u003e. Hence we can continue the stack to get all the way up to \u003ccode\u003eBA\u003c/code\u003e. Therefore \u003ccode\u003en\u003c/code\u003e dividing \u003ccode\u003eDC\u003c/code\u003e and \u003ccode\u003eEA\u003c/code\u003e implies \u003ccode\u003en\u003c/code\u003e divides \u003ccode\u003eBA\u003c/code\u003e!\u003c/p\u003e\u003c/div\u003e","tags":[]}}