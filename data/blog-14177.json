{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1412788269,"rating":0,"authorHandle":"KrK","modificationTimeSeconds":1412788269,"id":14177,"title":"\u003cp\u003eNulaužk programą\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eNeseniai sprendžiau vieną uždavinį naudodamas \u0026quot;double hashing\u0026quot; metodą. Tačiau jį taikiau neatsargiai ir surasti koliziją buvo palyginus nesunku. Ar galite tai padaryti ir jūs?\u003c/p\u003e\u003cp\u003eŽemiau pateiktas supaprastintas mano programos kodas paliekant tik hashinimo dalį :)\u003c/p\u003e\u003cp\u003e\u003cem\u003ea(n)\u003c/em\u003e ir \u003cem\u003eb(w)\u003c/em\u003e masyvuose yra sveikieji skaičiai, kurie normalizuojami į [1 .. \u003cem\u003eun.size()\u003c/em\u003e]. Ar galėtumėte surasti tokius masyvus, kuriuos pateikus programai, išeitų \u003cem\u003eh1\u003c/em\u003e \u003d \u003cem\u003eh2\u003c/em\u003e, nors masyvai būtų skirtingi?\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair \u0026lt;ll, ll\u0026gt; ii;\n\nconst int Maxn \u003d 200005;\nconst int mod1 \u003d 1000000007;\nconst int mod2 \u003d 1000000009;\n\nll a1 \u003d 37, a2 \u003d 37;\nint n, w;\nint a[Maxn], b[Maxn];\nvector \u0026lt;int\u0026gt; un;\nii h1, h2;\nint res;\n\nint main()\n{\n\tscanf(\u0026quot;%d %d\u0026quot;, \u0026amp;n, \u0026amp;w);\n\tfor (int i \u003d 1; i \u0026lt;\u003d n; i++) {\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]);\n\t        un.push_back(a[i]);\n\t}\n\tfor (int i \u003d 1; i \u0026lt;\u003d w; i++) {\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;b[i]);\n\t\tun.push_back(b[i]);\n\t}\n\tsort(un.begin(), un.end()); un.erase(unique(un.begin(), un.end()), un.end());\n\th1 \u003d ii(0, 0);\n\tfor (int i \u003d 1; i \u0026lt;\u003d n; i++) {\n\t\tint val \u003d lower_bound(un.begin(), un.end(), a[i]) - un.begin() + 1;\n\t\th1 \u003d ii((h1.first * a1 + val) % mod1, (h1.second * a2 + val) % mod2);\n\t}\n        h2 \u003d ii(0, 0);\n        for (int i \u003d 1; i \u0026lt;\u003d w; i++) {\n                int val \u003d lower_bound(un.begin(), un.end(), b[i]) - un.begin() + 1;\n                h2 \u003d ii((h2.first * a1 + val) % mod1, (h2.second * a2 + val) % mod2);\n        }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAtsakymus talpinkite „Pastebin“, kad kiti studentai nenorėdami negalėtų pamatyti atsakymo :) Nuorodas į savo komentarus pateikite grupės komentaruose. \u003c/p\u003e\u003c/div\u003e","tags":["pratimas","ktu"]}}