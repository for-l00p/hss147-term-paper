{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1461432261,"rating":31,"authorHandle":"RussianCodeCup","modificationTimeSeconds":1461432302,"id":44517,"title":"\u003cp\u003eRussian Code Cup 2016 — Warmup Round — Short Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eA. Secret Code\u003c/h2\u003e\u003cp\u003eAll you have to do is just implement the required counting. Identifying correct characters at correct positions is absolutely straightforward. Identifying correct characters at incorrect positions can be, for example, implemented using used[c] array with true values for characters in the secret code and false for other characters.\u003c/p\u003e\u003ch2\u003eB. Chaos\u003c/h2\u003e \u003cp\u003eConsider two maximal numbers of the initial array. The maximal possible value that can be obtained is their average value. \u003c/p\u003e\u003cp\u003eTo prove this, you can see Doc\u0027s moves as removing one number from the board and replacing two other numbers with two copies of their average value. So the average value of two maximal numbers never increases. \u003c/p\u003e\u003cp\u003eThe following strategy allows to get such value in the end: each move remove the minimal number and replace two maximal numbers with two copies of their average values. Starting from the second move the two maximal numbers will be the same and equal to the answer.\u003c/p\u003e\u003ch2\u003eC. New Adventure of Marty and Doc\u003c/h2\u003e \u003cp\u003eYou have to minimize the sum \u003ci\u003eSum\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e \u003d 1..\u003ci\u003en\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e \u003d 1..\u003ci\u003em\u003c/i\u003e, 2·\u003ci\u003ea\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e·(|\u003ci\u003ei\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e| + |\u003ci\u003ej\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e| + 1)). First notice that no term depends on both coordinates, so the sum can be divided to three sums: \u003ci\u003eSum\u003c/i\u003e(2·\u003ci\u003ea\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e), \u003ci\u003eSum\u003c/i\u003e(2·\u003ci\u003ea\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e·|\u003ci\u003ei\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e|) and \u003ci\u003eSum\u003c/i\u003e(2·\u003ci\u003ea\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e·|\u003ci\u003ej\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e|). \u003c/p\u003e\u003cp\u003eThe first sum is constant for the given input, so we need to minimize the second and the third sum which can be done independently by choosing the row and the column. Consider the second sum, it can be proved that the optimal value is achieved if we take \u003ci\u003er\u003c/i\u003e equal to the median of \u003ci\u003eSum\u003c/i\u003e(\u003ci\u003ej\u003c/i\u003e \u003d 1..\u003ci\u003em\u003c/i\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub\u003e1, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e) times 1, \u003ci\u003eSum\u003c/i\u003e(\u003ci\u003ej\u003c/i\u003e \u003d 1..\u003ci\u003em\u003c/i\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub\u003e2, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e) times 2, ..., \u003ci\u003eSum\u003c/i\u003e(\u003ci\u003ej\u003c/i\u003e \u003d 1..\u003ci\u003em\u003c/i\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e) times \u003ci\u003en\u003c/i\u003e. \u003c/p\u003e\u003cp\u003eColumn can be found using the same idea.\u003c/p\u003e\u003ch2\u003eD. Teams Creation\u003c/h2\u003e \u003cp\u003eLet\u0027s use dynamic programming.\u003c/p\u003e\u003cp\u003eSort all skill levels, and for each value find the number of students with such skill level. Note that if the team contains students with skill levels \u003ci\u003el\u003c/i\u003e and \u003ci\u003er\u003c/i\u003e, all students with skill levels \u003ci\u003em\u003c/i\u003e such that \u003ci\u003el\u003c/i\u003e \u0026lt; \u003ci\u003em\u003c/i\u003e \u0026lt; \u003ci\u003er\u003c/i\u003e will also be in the same team. So let us calculate the value \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e][\u003ci\u003ef\u003c/i\u003e] — the number of ways to create \u003ci\u003ej\u003c/i\u003e teams of students with skill levels up to \u003ci\u003ei\u003c/i\u003e, the last team can (f \u003d true) or cannot (f \u003d false) have more students. To make a transition we need additional value \u003ci\u003ef\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003eg\u003c/i\u003e] counts the number of ways to create \u003ci\u003eg\u003c/i\u003e teams of \u003ci\u003ek\u003c/i\u003e students that have the same skill level. Let there be \u003ci\u003ek\u003c/i\u003e students with skill level \u003ci\u003ei\u003c/i\u003e + 1, we iterate over \u003ci\u003eg\u003c/i\u003e from 1 to \u003ci\u003ek\u003c/i\u003e and relax \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e + 1][\u003ci\u003ej\u003c/i\u003e\u0027][\u003ci\u003ef\u003c/i\u003e\u0027] using \u003ci\u003ef\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003eg\u003c/i\u003e]. Note that this takes \u003ci\u003eO\u003c/i\u003e(\u003ci\u003enk\u003c/i\u003e) because the total number of \u003ci\u003eg\u003c/i\u003e attempted for each \u003ci\u003ej\u003c/i\u003e is equal to \u003ci\u003en\u003c/i\u003e.\u003c/p\u003e\u003cp\u003eTo find \u003ci\u003ef\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e][\u003ci\u003eg\u003c/i\u003e] we consider the \u003ci\u003ek\u003c/i\u003e-th student. He is either in the team on his own (\u003ci\u003ef\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e - 1][\u003ci\u003eg\u003c/i\u003e - 1]) or in one of the other teams (\u003ci\u003ef\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e - 1][\u003ci\u003eg\u003c/i\u003e]·\u003ci\u003eg\u003c/i\u003e).\u003c/p\u003e\u003cp\u003eBoth arrays are calculated in time \u003ci\u003eO\u003c/i\u003e(\u003ci\u003enk\u003c/i\u003e), so the time complexity is \u003ci\u003eO\u003c/i\u003e(\u003ci\u003enk\u003c/i\u003e).\u003c/p\u003e\u003ch2\u003eE. Maximal Sum\u003c/h2\u003e \u003cp\u003eLet us sort \u003ci\u003eb\u003c/i\u003e\u003csub\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e in decreasing order. Add values to array \u003ci\u003ea\u003c/i\u003e in decreasing order as well until all numbers greater or equal to the current \u003ci\u003eb\u003c/i\u003e\u003csub\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e is added. Now the array contains only numbers \u003ci\u003ea\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≥ \u003ci\u003eb\u003c/i\u003e\u003csub\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e. After adding the new \u003ci\u003ea\u003c/i\u003e\u003csub\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e use interval tree to find the maximal sum subsegment at the segment (see discussion here, for example, to learn how to do this using interval tree: \u003ca href\u003d\"//codeforces.com/blog/entry/17780?ccid\u003d8ff418bcfbc83019f0417c7e65265a32\"\u003e\u003c/a\u003e\u003ca\u003ehttp://codeforces.com/blog/entry/17780\u003c/a\u003e).\u003c/p\u003e\u003c/div\u003e","tags":[]}}