{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1437773287,"rating":0,"authorHandle":"micklepru","modificationTimeSeconds":1437825911,"id":19423,"title":"\u003cp\u003eBitmask DP doing some magic\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eUPD:\u003c/strong\u003e \u003cem\u003eThank you for your help, sort it out for myself. Hope this may help someone else now.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eHello, Codeforces!\u003c/p\u003e\u003cp\u003eI ask you to help me understanding how does the algorithm work.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/401/D\"\u003eHere is the problem.\u003c/a\u003e Basically we have two integers N and M, we need to find how many numbers obtained by rearranging digits of N are divisible by M.\u003c/p\u003e\u003cp\u003eSo naive solution is just go through all permutations of digits of N and check all of them. That gives us N! operations, which is unacceptably slow. Intuitively, we must go through all permutations anyway. And I am very confused about how do we not.\u003c/p\u003e\u003cp\u003eWe use bitmask DP: \u003ccode\u003edp[i][j]\u003c/code\u003e — amount of numbers, obtained by permutation some digits of N(specified by bitmask i), and remainder after diving it by M is j. For example \u003ccode\u003eN\u003d12345, dp[01101][2]\u003c/code\u003e — amount of numbers, constructed with 2,3,5 (such as 352), and after division by M remainder is 2 (\u003ccode\u003eM\u003d50, 352%50\u003d\u003d2\u003c/code\u003e). For each bitmask i we iterate(variable k) through all unused yet digits(\u003ccode\u003e(i \u0026amp; 1\u0026lt;\u0026lt;k)\u003d\u003d0\u003c/code\u003e) and add it to the end of every permutation(\u003ccode\u003ei | 1\u0026lt;\u0026lt;k\u003c/code\u003e). Old permutations gave remainder j, now it will be \u003ccode\u003e(j*10+N[k])%M\u003c/code\u003e, where N[k] is k-th digit of N. So we increase \u003ccode\u003edp[i | 1\u0026lt;\u0026lt;k][(j*10+N[k])%M]\u003c/code\u003e by \u003ccode\u003edp[i][j]\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eHere is the code to make it easier: \u003ca href\u003d\"/contest/401/submission/12205724\" title\u003d\"Submission 12205724 by micklepru\"\u003e12205724\u003c/a\u003e \u003cem\u003eNote:\u003c/em\u003e \u003ccode\u003etimesRepeat\u003c/code\u003e \u003cem\u003eis used to eliminate duplicate permutations regarding repeated digits in N.\u003c/em\u003e \u003ccode\u003e(i||N[k])\u003c/code\u003e \u003cem\u003eis to get rid of leading zeros\u003c/em\u003e\u003c/p\u003e\u003cp\u003eUsing DP, we descend from N! to (2^N)*N, which gives us accepted.\u003c/p\u003e\u003cp\u003eConsider the solution: seems like we iterate through every permutation. For example, bitmask 0110 can be obtained as 0100 adding third digit to the end or 0010 adding second digit to the end. I cannot understand how are we doing less work, but logically we go over every permutation.\u003c/p\u003e\u003cp\u003eMaybe it is stupid question, but I am really confused. Please help me to sort it out and tell when do we use such method. Can we use it to any kind of permutations?\u003c/p\u003e\u003c/div\u003e","tags":["dp","bitmask","permutations","brute force"]}}