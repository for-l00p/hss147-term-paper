{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1432789666,"rating":-7,"authorHandle":"suraj021","modificationTimeSeconds":1432789666,"id":18169,"title":"\u003cp\u003eBITMASKS — FOR BEGINNERS\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI was having trouble understanding Bitmask, then I found an unknown pdf about Bitmask on google. I would like to help the beginners like me in understanding Bitmasks and their uses. Here we go :\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e#### MOTIVATION\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSuppose you have a set of objects and you want some way to represent which objects to pick and which ones not to\u003cbr /\u003epick. How do you represent that in in a program? More generally, how do you represent a subest of a set?One way is to use a Map to associate with each object a boolean value indicating whether the object is picked. Alternatively,if the object can be indexed by integers, you can use a boolean array. However, this takes up a lot of memory and can be slow due to the overhead of Map and array. If the size of the set is not too large, a bitmask is much more efficient (and convenient)!\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e#### WHAT IS BITMASKS ?\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eBitmasks a.k.a. lightweight, small sets of Booleans (native support in C/C++/Java). An integer is stored in a computer’s memory as a sequence/string of bits. Thus, we can use integers to represent a lightweight small set of Boolean values. All set operations then involve only the bitwise manipulation of the corresponding integer, which makes it a much more efficient choice when compared with the C++ STL vector, bitset, or set options. Such speed is important in competitive programming.\u003c/p\u003e\u003cp\u003eWe know an integer is just a bunch of bits stringed together. The 1st bit will represent whether the 1st object is picked, the 2nd bit will represent whether the 2nd object is picked or not, etc. For example, suppose in a set of 5 objects, we have picked the 1st , 3rd , and 4th object. The bitmask to represent this in binary is 01101 or 13 in decimal (in the notes, the 1 st bit will always be the least significant bit and will always appear at the very right).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e#### MANIPULATING BITMASKS\u003c/strong\u003e\u003c/p\u003e \u003cpre\u003e1. REPRESENTATION: A 32 (or 64)-bit signed integer for up to 32 (or 64) items. ( To avoid issues with the \n    two’s complement representation, use a 32-bit/64-bit signed integer to represent bitmasks of up to\n    30/62 items only, respectively ).\n\n    For example:                          5| 4  | 3 | 2 | 1 | 0   \u0026lt;- 0-based indexing from right\n                                         32| 16 | 8 | 4 | 2 | 1   \u0026lt;- power of 2\n                     A\u003d 34 (base 10) \u003d   1 | 0  | 0 | 0 | 1 | 0   \u0026lt;- in binary\n                                         F | E  | D | C | B | A   \u0026lt;- alternative alphabet label\n   In the example above,the integer A \u003d 34 or 100010 in binary also represents a small set {1, 5} with a\n   0-based indexing scheme in increasing digit significance ( or {B, F} using the alternative alphabet\n   label )because the second and the sixth bits (counting from the right) of A are on ( 1 ).\n\n 2. To multiply/divide an integer by 2: \n                                    We only need to shift the bits in the integer left/right, respectively.\n    Notice that the truncation in the shift right operation automatically rounds the division-by-2 down,\n    e.g. 17/2  \u003d 8.\n\n    For example:         A \u003d 34 (base 10)                  \u003d 100010 (base 2)\n                         A \u003d A \u0026lt;\u0026lt; 1 \u003d A * 2 \u003d 68 (base 10) \u003d 1000100 (base 2)\n                         A \u003d A \u0026gt;\u0026gt; 2 \u003d A / 4 \u003d 17 (base 10) \u003d 10001 (base 2)\n                         A \u003d A \u0026gt;\u0026gt; 1 \u003d A / 2 \u003d 8 (base 10) \u003d 1000 (base 2) \u0026lt;- LSB( Least Significant Bit )is gone\n\n 3. Add the jth object to the subset (set the jth bit from 0 to 1):\n     use the bitwise OR operation A |\u003d (1 \u0026lt;\u0026lt; j).\n\n     For example:     A \u003d 34 (base 10) \u003d 100010 (base 2)\n                      j \u003d 3, 1 \u0026lt;\u0026lt; j    \u003d 001000 \u0026lt;- bit ‘1’ is shifted to the left 3 times\n                                        -------- OR (true if either of the bits is true)\n                      A \u003d 42 (base 10) \u003d 101010 (base 2) // update A to this new value 42\n\n4. Remove the jth object from the subset (set the jth bit from 1 to 0):\n     use the bitwise AND operation A \u0026amp;\u003d ∼(1 \u0026lt;\u0026lt; j).\n\n     For example:         A \u003d 42 (base 10) \u003d 101010 (base 2)\n                          j \u003d 1, ~(1 \u0026lt;\u0026lt; j) \u003d 111101 \u0026lt;- ‘~’ is the bitwise NOT operation\n                                             -------- AND\n                          A \u003d 40 (base 10) \u003d 101000 (base 2) // update A to this new value 40\n\n5. Check whether the jth object is in the subset (check whether jth bit is 1):\n   use the bitwise AND operation T \u003d A \u0026amp; (1 \u0026lt;\u0026lt; j).\n   If T \u003d 0, then the j-th item of the set is off.\n   If T !\u003d 0 (to be precise, T \u003d (1 \u0026lt;\u0026lt; j)), then the j-th item of the set is on.\n\n   For example:    A \u003d 42 (base 10) \u003d 101010 (base 2)\n                   j \u003d 3, 1 \u0026lt;\u0026lt; j    \u003d 001000 \u0026lt;- bit ‘1’ is shifted to the left 3 times\n                                     -------- AND (only true if both bits are true)\n                   T \u003d 8 (base 10)  \u003d 001000 (base 2) -\u0026gt; not zero, the 3rd item is on\n\n6. To toggle (flip the status of) the j-th item of the set:\n   use the bitwise XOR operation A ∧ \u003d (1 \u0026lt;\u0026lt; j).\n\n   For example:       A \u003d 40 (base 10) \u003d 101000 (base 2)\n                      j \u003d 2, (1 \u0026lt;\u0026lt; j)  \u003d 000100 \u0026lt;- bit ‘1’ is shifted to the left 2 times\n                                        -------- XOR \u0026lt;- true if both bits are different\n                      A \u003d 44 (base 10) \u003d 101100 (base 2) // update A to this new value 44\n\n7. To get the value of the least significant bit that is on (first from the right):\n   use T \u003d (A \u0026amp; (-A)).\n\n   For example:     A \u003d  40 (base 10) \u003d 000...000101000 (32 bits, base 2)\n                   -A \u003d -40 (base 10) \u003d 111...111011000 (two’s complement)\n                                       ----------------- AND\n                    T \u003d   8 (base 10) \u003d 000...000001000 (3rd bit from right is on)\n\n8. To turn on all bits in a set of size n: (be careful with overflows)\n   use A \u003d (1 \u0026lt;\u0026lt; n) - 1 ;\n\n9. Iterate through all subsets of a set of size n:\n           for ( x \u003d 0; x \u0026lt; (1 \u0026lt;\u0026lt; n); ++x )  \n\n10. Iterate through all subsets of a subset y (not including empty set):\n             for ( x \u003d y; x \u0026gt; 0; x \u003d ( y \u0026amp; (x-1) ) )\u003c/pre\u003e\u003cp\u003eExample of a subset problem: given a set of numbers, we want to find the sum of all subsets.\u003c/p\u003e\u003cp\u003eSol: This is easy to code using bitmasks. we can use an array to store all the results.\u003c/p\u003e \u003cpre\u003eint sum_of_all_subset ( vector\u0026lt; int \u0026gt; s ){\n            int n \u003d s.size() ;\n            int results[ ( 1 \u0026lt;\u0026lt; n ) ] ;     // ( 1 \u0026lt;\u0026lt; n )\u003d 2^n\n\n         //initialize results to 0\n            memset( results, 0, sizeof( results ) ) ;\n\n        // iterate through all subsets\n\n           for( int i \u003d 0 ; i \u0026lt; ( 1 \u0026lt;\u0026lt; n ) ; ++ i ) {    // for each subset, O(2^n)\n                 for ( int j \u003d 0; j \u0026lt; n ; ++ j ) {       // check membership, O(n)\n                     i f ( ( i \u0026amp; ( 1 \u0026lt;\u0026lt; j ) ) ! \u003d 0 )    // test if bit ‘j’ is turned on in subset ‘i’?\n                          results[i] +\u003d s [j] ;          // if yes, process ‘j’\n                     }\n                 }\n           }\n\n 11. LIMITATIONS:\n     a. Always check the size of the set to determine whether to use an int or long long or not using bitmask at all\n     b. Always use parenthesis to indicate the precedence of operations when doing bitwise operations!\n        When it involves bitwise operators and not putting parenthesis can yield undesirable results!\n\n        For example, let x \u003d 5. Then x - 1 \u0026lt;\u0026lt; 2 \u003d 16, but x - (1 \u0026lt;\u0026lt; 2) \u003d 1\u003c/pre\u003e\u003cp\u003eP.S 1. I apologize for bad formatting.  2. If you find something wrong/inappropriate please correct me.  3. Examples are copied from some text book  4. Can anyone please write a blog on Backtracking , i don\u0027t get flow of control in recursive calls in  backtracking when a certain constraint fails on a configuration ( like in N queens problem ), how does program  backtracks and how control flow takes place then and what happens after that ?\u003c/p\u003e\u003cp\u003eThank You ;\u003c/p\u003e\u003c/div\u003e","tags":["bitmask","bit manipulation","beginners"]}}