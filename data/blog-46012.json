{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1468381001,"rating":1,"authorHandle":"buzzvil","modificationTimeSeconds":1468381187,"id":46012,"title":"\u003cp\u003etricky binary serach loop invariant question\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi all,\u003c/p\u003e\u003cp\u003eI\u0027ve read a lot about binary search and its notorious tricky nature to implement correctly. One thing I learned over time is thinking in loop invariants helps with proving your code\u0027s correctness. I recently solved a problem on binary search and got AC but I fail to see why my code works correctly\u003c/p\u003e\u003cp\u003elink: \u003ca href\u003d\"//codeforces.com/problemset/problem/676/C\"\u003ehttp://codeforces.com/problemset/problem/676/C\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFor this problem, we have to find the longest substring that consists of the same letter (either \u0027a\u0027 or \u0027b\u0027) IF you can change \u0027a\u0027s to \u0027b\u0027s or vice versa up to K times.\u003c/p\u003e\u003cp\u003eI solved the problem separately for \u0027a\u0027s and \u0027b\u0027s, then returned the maximum of two.\u003c/p\u003e\u003cp\u003eLet me elaborate what I did for one letter \u0027a\u0027 (it\u0027s identical for the other character)\u003c/p\u003e\u003cp\u003eIf I had a magic function that tells me \u0026quot;can you find a candidate answer of length L\u0026quot;, what I am looking for is\u003c/p\u003e\u003cp\u003efor given array A of length N\u003c/p\u003e\u003cp\u003eYES, YES, YES, ...., YES, NO, NO, NO, ..., NO\u003c/p\u003e\u003cp\u003eI need to find the last index (or longest length) that says YES.\u003c/p\u003e\u003cp\u003eto find such an index using binary search, I maintain the following loop invariants,\u003c/p\u003e\u003cp\u003e1) l \u0026lt; h and initially, l \u003d 0, h \u003d n\u003c/p\u003e\u003cp\u003e2) call that magic function P, then always, P(l) \u003d True and P(h) \u003d False. put another way, answer lies in interval [l, h)\u003c/p\u003e\u003cp\u003e3) the while loop continues as long as \u0026quot;l + 1 \u0026lt; h\u0026quot;. so, when it terminates, l + 1 \u0026gt;\u003d h, but combined with 1) we know l + 1 \u003d h.\u003c/p\u003e\u003cp\u003e4) because of 2), we know that the answer must be l\u003c/p\u003e\u003cp\u003etranslated to pseduo-code,\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/uvLw0s\"\u003ehttp://ideone.com/uvLw0s\u003c/a\u003e\u003c/p\u003e\u003cp\u003eBut the answer this code gives is always one less than the actual answer. When I return h instead of l (because i\u0027m 1 off), I get AC. But following my lines of logic, I know it must be \u0027l\u0027 that is the answer. Can you guys help me with finding a flaw in my logic?\u003c/p\u003e\u003c/div\u003e","tags":[]}}