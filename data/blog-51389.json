{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1491153464,"rating":-11,"authorHandle":"go_rob","modificationTimeSeconds":1491206235,"id":51389,"title":"\u003cp\u003eInterview Question Help \u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThere are n nodes(1,2.. n) in a \u003ccode\u003eweighted graph\u003c/code\u003e with \u003ccode\u003em (m\u0026gt;n) bi-directional edges\u003c/code\u003e. \u003c/p\u003e\u003cp\u003e\u003ccode\u003eAll weights are positive and there are no multiple edges\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eThere is one \u003ccode\u003efixed origin(Node 1)\u003c/code\u003e. We will always start traveling from the origin. \u003c/p\u003e\u003cp\u003eNow we have to find the \u003ccode\u003enumber of ways to reach each of the nodes(starting from the origin) with minimum cost\u003c/code\u003e.(All paths counted should have the minimum cost to reach that node).\u003c/p\u003e\u003cp\u003eExpected complexity O(m*log(m)).\u003c/p\u003e\u003cp\u003eInput — First line contains n , m .\u003c/p\u003e\u003cp\u003eNext m lines contain u,v,w. \u003d\u0026gt; There is an edge between u and v of weight w(w\u0026gt;0).\u003c/p\u003e\u003cp\u003eOutput — Print n-1 lines one for each node other than origin, containing the number of ways to reach each of the nodes(starting from the origin) with minimum cost.\u003c/p\u003e\u003cp\u003eSample Test -\u003c/p\u003e\u003cp\u003e4 5\u003c/p\u003e\u003cp\u003e1 2 5\u003c/p\u003e\u003cp\u003e1 3 3\u003c/p\u003e\u003cp\u003e3 2 2\u003c/p\u003e\u003cp\u003e3 4 7\u003c/p\u003e\u003cp\u003e2 4 5\u003c/p\u003e\u003cp\u003eOutput — \u003c/p\u003e\u003cp\u003e2\u003c/p\u003e\u003cp\u003e1 \u003c/p\u003e\u003cp\u003e3\u003c/p\u003e\u003cp\u003eHere is my solution, Please check if this will work for all cases, I did modified Dijkstra + DP.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n \n#define N 5001\n#define fi first\n#define se second\n#define MOD 1000000007\n \n#define pb push_back\n \n#define ll long long\n \n#define eps 1.0e-9\n#define inf 1e9 + 5\n#define double long double\n \n#define pp pair\u0026lt;int,int\u0026gt;\n\nvector\u0026lt; pp \u0026gt; adj[N];\nint dis[N],dp[N];\n\nint main()\n{\n  ios::sync_with_stdio(0);\n  int i,j,k,m,n,t;\n  cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\n  for(i\u003d0;i\u0026lt;m;i++)\n  {\n    int u,v,w;\n    cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v\u0026gt;\u0026gt;w;\n    //u--;v--;\n    adj[u].pb({w,v});\n    adj[v].pb({w,v});\n  }\n  priority_queue\u0026lt; pp , vector\u0026lt;pp \u0026gt; , greater\u0026lt;pp\u0026gt; \u0026gt; pq;\n  for(int i\u003d0;i\u0026lt;\u003dn;i++) dis[i] \u003d INT_MAX;\n  dis[1] \u003d 0;\n  dp[1] \u003d 1;\n  pq.push({0,1});\n\n  while(!pq.empty())\n  {\n    pp tp \u003d pq.top();\n    int u \u003d tp.se;\n    int d \u003d tp.fi;\n    pq.pop();\n    if(dis[u]\u0026lt;d) continue;\n\n    for(i\u003d0;i\u0026lt;adj[u].size();i++)\n    {\n      int v \u003d adj[u][i].se;\n      int w \u003d adj[u][i].fi;\n      if(d + w \u0026lt;\u003d dis[v] )\n      {\n        if(dis[v]\u003d\u003dd+w) dp[v] +\u003d dp[u];\n\n        if(d + w \u0026lt; dis[v])\n        {\n          dis[v] \u003d d + w;  \n          dp[v] \u003d dp[u];\n          pq.push({dis[v],v}); \n        }\n      }\n    }\n  }\n  \n  cout\u0026lt;\u0026lt;endl;\n\n  for(int i \u003d 1;i\u0026lt;\u003dn;i++)\n  {\n    cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026quot; dis \u003d \u0026quot;\u0026lt;\u0026lt;dis[i]\u0026lt;\u0026lt;\u0026quot; ways \u003d \u0026quot;\u0026lt;\u0026lt;dp[i]\u0026lt;\u0026lt;endl;\n  }\nreturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["#graph","dijkstra","dynamic programming"]}}