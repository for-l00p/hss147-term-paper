{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1482667215,"rating":95,"authorHandle":"haleyk100198","modificationTimeSeconds":1482671359,"id":49311,"title":"\u003cp\u003e[UNOFFICIAL] Codeforces Round 389 Div.2 problem analysis\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eMerry Christmas everyone\u003c/p\u003e\u003cp\u003eAs the editorials of Technocup rounds usually comes later than expected, I hope that this problem analysis could help out whose wants the questions immediately.\u003c/p\u003e\u003cp\u003eDiv2A: \u003ca href\u003d\"//codeforces.com/problemset/problem/748/A\"\u003eSanta Claus and a Place in a Class\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is a trivial implementation question, by a bit math we could derive that:\u003c/p\u003e\u003cp\u003eNumber of row: (k-1) // (2*m)\u003c/p\u003e\u003cp\u003eNumber of desk: ((k-1) mod (2*m)) // 2\u003c/p\u003e\u003cp\u003e( x // y means the integral part of x/y )\u003c/p\u003e\u003cp\u003eAnd the side of the desk solely depends on the parity of k, as each row has even number of desks.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/752/submission/23288096\"\u003eC++ solution:\u003c/a\u003e\u003c/p\u003e\u003cp\u003eDiv2B: \u003ca href\u003d\"//codeforces.com/problemset/problem/752/B\"\u003eSanta Claus and Keyboard Check\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe could solve the question by saving the status of the keys, i.e. not pressed, swapped in pairs, or confirmed in original position, initially all keys have the not pressed status.\u003c/p\u003e\u003cp\u003eWhen iterating through the pattern, if we’ve found out that the matching of line1[i] and line2[i] different from the current status, we output -1. Finally, we output whose has the swapped status.\u003c/p\u003e\u003cp\u003eOne of the hack cases that have gained a lot of points is by exploiting some codes which does not keep the “confirmed in original position” status, which conflicts against the “swapped in pairs’ status.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/752/submission/23299938\"\u003eC++ solution\u003c/a\u003e\u003c/p\u003e\u003cp\u003eDiv2C: \u003ca href\u003d\"//codeforces.com/problemset/problem/752/C\"\u003eSanta Claus and Robot\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIntuitively, we can tell that if the robot changes the vertical / horizontal direction, then the current position of the robot may lie one of the point.\u003c/p\u003e\u003cp\u003eOne of the way to approach this question is by keeping whether the robot is free to change it’s vertical or horizontal direction without declaring an extra point. Obviously, when a new point is reached, the robot is allowed to change it’s horizontal and vertical direction for once. By greedy we will make use of this “free to change” status and add points only when we must, thus reaching the minimized amount of points.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/752/submission/23290687\"\u003eC++ Solution\u003c/a\u003e\u003c/p\u003e\u003cp\u003eDiv2D: \u003ca href\u003d\"//codeforces.com/problemset/problem/752/D\"\u003eSanta Claus and a Palindrome\u003c/a\u003e\u003c/p\u003e\u003cp\u003eA key observation is that all strings have the same length, therefore if a string: “111 222 333 444 555” is a palindrome, so is “222 111 333 555 444”.\u003c/p\u003e\u003cp\u003eIn order to effectively process the strings, we group the strings and sort their beautiful value (In C++, use std::map\u0026lt;string, vector \u0026gt; does the job.)\u003c/p\u003e\u003cp\u003eNext, we class each string into one of the following conditions:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eThe string itself is not a palindrome We will reverse the string to find it’s “counterpart” (i.e. concatenating the two strings would produce a palindrome). We greedily select the largest pair available from the two groups until it is not profitable.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThe string itself is a palindrome This implies that the string could be used alone (to be placed right at the middle of the final string), or be used twice just as the other case. As the alone string case could only occur once, we shall greedily update the beautiful value of the alone string. This is left as an exercise to the reader.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/752/submission/23293682\"\u003eC++ solution\u003c/a\u003e\u003c/p\u003e\u003cp\u003eDiv2E: \u003ca href\u003d\"//codeforces.com/problemset/problem/752/E\"\u003eSanta Claus and Tangerines\u003c/a\u003e\u003c/p\u003e\u003cp\u003eNote that if we don’t have enough tangerine to spare, we would always to divide the largest ones first.\u003c/p\u003e\u003cp\u003eUsing this fact, we would iterate the joy from 1e7 to 1. If there is enough tangerine, we immediate print that as the answer, the question now reduces to maintaining the amount of tangerines.\u003c/p\u003e\u003cp\u003eWe could maintain it by keeping track of all tangerines that we have already counted, to avoid duplicated calculation of the partial parts of the larger ones, we could use another array to make a mark at (Size+1) / 2, as we the amount of tangerines collected effectively increases only when we also include the tangerines of Size/2.\u003c/p\u003e\u003cp\u003eIf there is no solution even for joy \u003d 1, print joy \u003d -1.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/752/submission/23306634\"\u003eC++ solution\u003c/a\u003e\u003c/p\u003e\u003cp\u003eDiv2F: \u003ca href\u003d\"//codeforces.com/problemset/problem/752/F\"\u003eSanta Clauses and a Soccer Championship\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/700/B\"\u003ehttp://codeforces.com/problemset/problem/700/B\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is an easier version of Div2F. The main idea is to make use of the fact that the most expensive solution will have all its’ path going through the centroid of the tree. Yes, that is exactly what we needed, we could therefore conclude we only need one city to accommodate all teams, don’t be fooled.\u003c/p\u003e\u003cp\u003eRead this editorial, and the discussions in the blog to learn how to find the centroid of the tree for this question.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/blog/entry/46283\"\u003ehttp://codeforces.com/blog/entry/46283\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe rest to do is grouping, we can do that keeping track of the dfs traversal order, which is relatively easy compared to the main dish.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/752/submission/23299132\"\u003eC++ solution\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["round #389","technocup"]}}