{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1519917539,"rating":-5,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1519917539,"id":58105,"title":"\u003cp\u003eNotes on Codeforces Beta Round #120, Div2- A, B, C, D, E\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/190/problem/A\" title\u003d\"Codeforces Round 120 (Div. 2)\"\u003e190A - Vasya and the Bus\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThree cases are sufficient to solve this problem.\u003c/p\u003e\u003cp\u003e1) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e \u003d \u003ci\u003en\u003c/i\u003e \u003d 0\u003c/span\u003e, the answer is “0 0”;\u003c/p\u003e\u003cp\u003e2) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 0, \u003ci\u003em\u003c/i\u003e \u0026gt; 0\u003c/span\u003e, the answer is “Impossible”;\u003c/p\u003e\u003cp\u003e3) none of above, the answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + \u003ci\u003emax\u003c/i\u003e(\u003ci\u003em\u003c/i\u003e - \u003ci\u003en\u003c/i\u003e, 0)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e - 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/190/problem/B\" title\u003d\"Codeforces Round 120 (Div. 2)\"\u003e190B - Surrounded\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWithout loss of generality, we assume that radius \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e1 \u0026gt; \u003ci\u003er\u003c/i\u003e2\u003c/span\u003e and the distance between their centers is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e. The problem can be solved based on the following cases.\u003c/p\u003e\u003cp\u003e1) two circles have at least one common point: the answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e \u003d 0\u003c/span\u003e since it can be put at any one the common point(s).\u003c/p\u003e\u003cp\u003e2) one circle is exactly outside the other one: the answer is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8a/5e/8a5e5d2dcb232db53e48ef83257d24801f0277be.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003e3) one circle is exactly inside the other one: the answer is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b0/e9/b0e901d43c492c00833a06c59d83192280fcbffd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eBesides, one should carefully deal with the precision problem. For instance, when we try to check whether \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e \u0026lt; \u003ci\u003er\u003c/i\u003e1 + \u003ci\u003er\u003c/i\u003e2\u003c/span\u003e holds or not, we should compare \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e1 - \u003ci\u003ex\u003c/i\u003e2) * (\u003ci\u003ex\u003c/i\u003e1 - \u003ci\u003ex\u003c/i\u003e2) + (\u003ci\u003ey\u003c/i\u003e1 - \u003ci\u003ey\u003c/i\u003e2) * (\u003ci\u003ey\u003c/i\u003e1 - \u003ci\u003ey\u003c/i\u003e2) \u0026lt; (\u003ci\u003er\u003c/i\u003e1 + \u003ci\u003er\u003c/i\u003e2) * (\u003ci\u003er\u003c/i\u003e1 + \u003ci\u003er\u003c/i\u003e2)\u003c/span\u003e since only integers are involved here, which gives strictly precise result.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/190/problem/C\" title\u003d\"Codeforces Round 120 (Div. 2)\"\u003e190C - STL\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe can enumerate the type (“pair” or “int”) in the given order one by one, while using a “stack” \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to maintain the current “state”.\u003c/p\u003e\u003cp\u003eIn details, when we meet a “pair”, we output “pair\u0026lt;” and push an integer \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e to the stack. The reason is that if this is a reasonable sequence, then “pair” means a new start and it must be “pair\u0026lt;”. We push \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e to the stack to indicate that we need wait for another two “types” to complete the current “pair”. \u003c/p\u003e\u003cp\u003eOn the other hand, when we meet an “int”, we check whether the “stack” is empty or not. If yes, it means that there must be only one “int” (also implies that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 1\u003c/span\u003e) and zero “pair”, and we only output “int” (note that this case might also occur if it is not a reasonable sequence, for instance “pair int int int”, however we have other methods to tell this, which will be mentioned later). If no, then we take out the top integer in the “stack”. If it is \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e, it means that the current “int” serves as the first part of the last “pair” which is still not completed. Thus, we should output “int,” and set the top integer to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, as we have obtained the first part and only need wait for the second one. If the top integer is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, it means that the current “int” serves as the second part of the last “pair”. Thus, we should output “int\u0026gt;,” and pop out the top integer of the “stack”. Next, notice that the last “pair” has been completed and it may serve as the first part of some other “pair”. Hence, we should further check the top integer of the “stack”, and if it is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, we output “\u0026gt;” to complete the current “pair” and pop out the top integer. We keep the above process until the “stack” is empty or the top integer is \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e, and if the latter case occurs, we should output “,” and set the top integer as \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eAfter finishing the above process, the sequence is reasonable if the following two conditions are fulfilled. The stack is empty and the number of “pair” is strictly one less than that of “int”.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/190/problem/D\" title\u003d\"Codeforces Round 120 (Div. 2)\"\u003e190D - Non-Secret Cypher\u003c/a\u003e\u003c/p\u003e\u003cp\u003eA classical “two pointers” problem. We use one pointer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to point to the starting point while using the second pointer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e \u0026gt; \u003ci\u003es\u003c/i\u003e\u003c/span\u003e) to point to the minimum position so that there exists at least one integer which has appeared exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e times, within the interval \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003es\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e - 1]\u003c/span\u003e. We move these two pointers to find out all such intervals, and for each of them, it contributes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + 1 - \u003ci\u003et\u003c/i\u003e\u003c/span\u003e (index starts from zero) to the final answer.\u003c/p\u003e\u003cp\u003eThe left work is to determine whether for some interval \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003es\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e - 1]\u003c/span\u003e, it can meet the requirements or not. We can use a segment tree which maintains the maximum number of appearance of integers \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e, to accomplish this. Do not forget to compress all the input data to a smaller range so that segment tree is feasible. When we move \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e one step forward, we decrease the number of appearance of integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e[\u003ci\u003es\u003c/i\u003e]\u003c/span\u003e by one in the segment tree and complete the updating of other nodes. When we move \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e one step further, we implement similar updating. The value stored in the root node is just the maximum number of appearance of some integer within the current sliding window.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/190/problem/E\" title\u003d\"Codeforces Round 120 (Div. 2)\"\u003e190E - Counter Attack\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI followed the idea mentioned in tutorials.\u003c/p\u003e\u003cp\u003eAt first, we insert all the node indices into a “set”. Then, we adopt three loops to solve the problem. \u003c/p\u003e\u003cp\u003eloop 1: as long as the “set” is not empty, we always take out the first element and push it to a “queue”. Then we erase it from the “set” and go to loop 2;\u003c/p\u003e\u003cp\u003eloop 2: as long as the “queue” is not empty, we take out the first element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e (remember to pop it out from the “queue”) and go to loop 3;\u003c/p\u003e\u003cp\u003eloop 3: we enumerate every element that is still in the “set” and use binary search to check whether it is connected to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e. If no, we push this element to “queue”, and erase it from the “set” (it seems to be a good idea if we store all these elements first and then erase them when we return back to loop 2).\u003c/p\u003e\u003cp\u003eI think the above algorithm has complexity of order \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003em\u003c/i\u003e + \u003ci\u003en\u003c/i\u003e)\u003ci\u003elogn\u003c/i\u003e\u003c/span\u003e (worst case), which can be computed based on amortized analysis.\u003c/p\u003e\u003c/div\u003e","tags":[]}}