{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1505773212,"rating":134,"authorHandle":"KarlisS","modificationTimeSeconds":1515958929,"id":54610,"title":"\u003cp\u003eCodeforces C++ FAQ\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eFor any of the topics here search codeforces and you will find them discussed multiple times. Upvote from me if anyone counts how many times per month each of these get asked.\u003c/p\u003e\u003ch3\u003e0. Help!!!\u003c/h3\u003e\u003cp\u003eA: Read this blog.\u003c/p\u003e\u003ch3\u003e1. TLE\u003c/h3\u003e\u003ch4\u003e1.1 The code is using STL map/set and std::lower_bound\u003c/h4\u003e\u003cp\u003eA: std::lower_bound is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogn\u003c/i\u003e)\u003c/span\u003e only when used with random access iterators it is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e when used on map/set. Use the map/set member functions lower_bound/upper_bound to get \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogn\u003c/i\u003e)\u003c/span\u003e operations. See \u003ca href\u003d\"http://en.cppreference.com/w/cpp/container/set/lower_bound\"\u003ehttp://en.cppreference.com/w/cpp/container/set/lower_bound\u003c/a\u003e \u003ca href\u003d\"http://en.cppreference.com/w/cpp/algorithm/lower_bound\"\u003ehttp://en.cppreference.com/w/cpp/algorithm/lower_bound\u003c/a\u003e .\u003c/p\u003e\u003ch4\u003e1.2 Why did I get AC after changing comment?\u003c/h4\u003e\u003cp\u003eA: Is the solution that got AC on the edge of time limit? That is probably within measurement mistake. Time limits are usually set with some reserve, something can probably be improved to get a stable AC.\u003c/p\u003e\u003ch3\u003e2. I am getting WA/RTE in Codeforces but it works on my computer/other online service. Codeforces bug. G++ bug. C++XX bug.\u003c/h3\u003e\u003cp\u003eA: Your code relies on undefined behavior or behavior, uses floating numbers incorrectly or is otherwise incorrect. Read here what is undefined behavior \u003ca href\u003d\"http://en.cppreference.com/book/undefined_behavior\"\u003ehttp://en.cppreference.com/book/undefined_behavior\u003c/a\u003e . Continue reading bellow for most common causes.\u003c/p\u003e\u003ch3\u003e3. The code use std::sort/std::set/std::map with custom comparator.\u003c/h3\u003e\u003cp\u003eThe comparator must return false for \u003ccode\u003ecmp(x,x)\u003c/code\u003e. The comparator must be transitive. If \u003ccode\u003ecmp(a,b) \u003d\u003d true\u003c/code\u003e, then \u003ccode\u003ecmp(b,a)\u003c/code\u003e must be false. Read here for more details \u003ca href\u003d\"http://en.cppreference.com/w/cpp/concept/Compare\"\u003ehttp://en.cppreference.com/w/cpp/concept/Compare\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e4. How to write a correct comparator?\u003c/h3\u003e\u003cp\u003eA: See 3.\u003c/p\u003e\u003ch3\u003e5. Why is my code working with std::stable_sort but not with std::sort.\u003c/h3\u003e\u003cp\u003eA: Most likely your camparator doesn\u0027t match requirements in 3. You were lucky that implementation details for std::stable_sort on the input in tests happened to work. It might not work with different tests/version of compiler/implementation of standard library.\u003c/p\u003e\u003ch3\u003e6. The code contains std::pow(10, x).\u003c/h3\u003e\u003cp\u003eA: Don\u0027t use std::pow on integers, it is designed for floating point numbers. Write your own function for getting power of integers. See 9. floating point numbers. \u003c/p\u003e\u003ch3\u003e7. The code contains \u003ccode\u003ei\u0026lt;vec.size()-1\u003c/code\u003e as loop condition.\u003c/h3\u003e\u003cp\u003eA: \u003ccode\u003ev.size()\u003c/code\u003e returns size_t which is an unsigned integer. When the size is 0 it will wrap around to max value for that integer type. If the size can be 0 cast size to signed integer type or write your loop differently. \u003c/p\u003e\u003ch3\u003e8. The code contains \u003ccode\u003estd::ios_base::sync_with_stdio(false)\u003c/code\u003e.\u003c/h3\u003e \u003cul\u003e   \u003cli\u003eRead the documentation of what it does (makes input fast is wrong answer).\u003c/li\u003e   \u003cli\u003eDon\u0027t mix cin/scanf and cout/printf when using \u003ccode\u003eios::base_sync_with_stdio(false)\u003c/code\u003e\u003c/li\u003e \u003c/ul\u003e\u003ch3\u003e9. Floating point numbers\u003c/h3\u003e \u003cul\u003e   \u003cli\u003eRead this \u003ca href\u003d\"https://gcc.gnu.org/bugs/#nonbugs_general\"\u003ehttps://gcc.gnu.org/bugs/#nonbugs_general\u003c/a\u003e\u003c/li\u003e   \u003cli\u003eDo not compare floating point numbers without epsilon (with some rare exceptions)\u003c/li\u003e   \u003cli\u003eDo not assign floating point number to integer without proper rounding\u003c/li\u003e   \u003cli\u003eDo not use standard library functions that are designed for floating point numbers on integers unless you know what you are doing. The result might need rounding even if it mathematically should be a precise integer. Floating point numbers have less significant digits than same size integer.\u003c/li\u003e \u003c/ul\u003e\u003ch3\u003e10. None of the above helped.\u003c/h3\u003e\u003cp\u003eA: Maybe you are accessing outside the size of array or have other bug. Use tools \u003ca href\u003d\"//codeforces.com/blog/entry/15547\"\u003ehttp://codeforces.com/blog/entry/15547\u003c/a\u003e. If you are not capable of compiling your own code it is also possible to use the diagnostic mode at Codeforces \u003ca href\u003d\"//codeforces.com/blog/entry/55902\"\u003ehttp://codeforces.com/blog/entry/55902\u003c/a\u003e but it is strongly recommended to learn doing it yourself.\u003c/p\u003e\u003ch3\u003e11. The result still differs on Codeforces and my computer.\u003c/h3\u003e\u003cp\u003eA: You can use custom invocation to narrow down the cause of difference.\u003c/p\u003e\u003c/div\u003e","tags":["faq","c++","#help"]}}