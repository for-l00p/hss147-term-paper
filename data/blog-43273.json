{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1456088501,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1456095976,"id":43273,"title":"\u003cp\u003eОдномерные массивы: принцип \u0026quot;скользящего окна\u0026quot;\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eНа последней прошедшей лекции мы рассмотрели две типичные задачи с использованием массивов. \u003c/p\u003e\u003cp\u003eВо-первых, это была задача о частичной сортировке, в которой нужно было поместить в левую часть массива элементы, меньшие или равные некоторому значению \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, а в правую часть — большие или равные этому значению. Ее мы решали методом двух указателей (и разобрали довольно подробно).\u003c/p\u003e\u003cp\u003eВо-вторых, это была задача о жемчужинах разной стоимости, нанизанных на нитку, которых можно было взять ровно \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e штук из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, притом подряд, и мы хотели выбрать такие \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e штук, которые стоили бы суммарно дороже всего. Метод, которым мы решали эту задачу, часто называют методом \u0026quot;скользящего окна\u0026quot;. Это не общеупотребительное название, так что поясним чуть подробнее. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eНас может интересовать некоторая \u0026quot;обобщенная\u0026quot; информация о подотрезках массива. Например, есть массив, в котором ежедневно записывается расход воды (можете предполагать, что это данные, автоматически формируемые счётчиком). Эти записи велись в течение года, а теперь нас интересует максимальный расход за неделю. \u003c/p\u003e\u003cp\u003eПонятно, что мы должны посчитать сумму за каждые семь подряд идущих дней и найти максимум среди таких значений. Также понятно, что после подсчета суммы за первые семь дней последующие вычисления можно вести по принципу \u0026quot;вычтем самый ранний день, учтённый в текущей сумме, и добавим новый\u0026quot;. Можно представить себе, что у нас есть \u0026quot;окно\u0026quot; длиной в семь элементов, которое мы на каждом шаге сдвигаем на один элемент (потому и \u0026quot;скользящее окно\u0026quot;). \u003c/p\u003e\u003cp\u003eРазумеется, у этой техники есть и другие варианты — например, когда длина окна не фиксируется, а может меняться в зависимости от некоторых факторов. \u003c/p\u003e\u003cp\u003eРассмотрим следующую задачу. \u003c/p\u003e\u003cp\u003e\u003cem\u003e\u003cstrong\u003eПримечание.\u003c/strong\u003e Эта задача похожа на задачу о жемчужинах. Однако следует заметить, что в задаче о жемчужинах нас интересовала лишь максимальная суммарная стоимость, в предлагаемой ниже задаче требуется фиксировать дополнительную информацию.\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача 5.\u003c/strong\u003e \u003c/p\u003e\u003cp\u003eПетя посещает курсы интенсивного изучения иностранного языка. Каждый день преподаватель выставляет оценку — excellent, good или satisfactory. Ради простоты будем считать, что это 5, 4 и 3 (двоек не бывает по причине высокой заинтересованности учащихся в результате). \u003c/p\u003e\u003cp\u003eПетя хочет похвалиться другу Васе своей успеваемостью. С начала курсов прошло \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e дней, а на экране ноутбука одновременно можно показать оценки за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e подряд идущих дней. Петя хотел бы показать лучшие (с его точки зрения) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e дней — те \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e дней, в течение которых он получил больше всего оценок 5. Если можно выбрать \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e таких дней не единственным способом, Петя хотел бы показать те \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e дней, в течение которых он получил меньше оценок 3. Если и в этом случае можно выбрать \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e дней несколькими способами, подойдёт любой ответ. \u003c/p\u003e\u003cp\u003eВ первой строке входных данных будут содержаться целые числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(1 ≤ \u003ci\u003em\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e ≤ 1000)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eВо второй строке будет содержаться \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e целых чисел (3, 4, 5) через пробел — оценки, полученные Петей в соответствующие дни.\u003c/p\u003e\u003cp\u003eВ качестве ответа выведите в первой строке номер дня, с которого Петя должен начинать показывать свои результаты, а во второй строке — количество пятёрок и троек, которые увидит Вася. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eРешение\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eСоздадим в проекте \u003ccode\u003epractice01\u003c/code\u003e класс \u003ccode\u003eProblem05\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003epackage practice01;\n\npublic class Problem05 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОпишем класс \u003ccode\u003eCourses\u003c/code\u003e, объявив в нём переменные \u003ccode\u003en\u003c/code\u003e, \u003ccode\u003em\u003c/code\u003e и \u003ccode\u003emarks\u003c/code\u003e — массив оценок. Организуем в конструкторе этого класса считывание всех данных со стандартного ввода (практически аналогично тому, как это было сделано в задаче 4 в предыдущей записи):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003epackage practice01;\n\nimport java.util.Scanner;\n\npublic class Problem05 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass Courses {\n\t\n\tCourses() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tm \u003d in.nextInt();\n\t\t\n\t\tmarks \u003d new int[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t\tmarks[i] \u003d in.nextInt();\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tint n;\n\tint m;\n\tint [] marks;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТеперь заметим следующее. Если бы нам было достаточно просто найти максимальное количество оценок 5, которые получил Петя за какие-либо \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e дней — нам было бы достаточно поддерживать их количество при переходе к следующему элементу массива. Однако Петя хотел бы указать начальную позицию, с которой он будет демонстрировать Васе свои успехи. Поэтому заведём дополнительный массив \u003ccode\u003estart\u003c/code\u003e, в котором и будем хранить количество отличных оценок, которые Петя может показать, если начнет показывать именно с позиции \u003ccode\u003estart[i]\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eОднако только этого массива нам всё же недостаточно — ведь Петя хочет показать такие \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e дней, в которые он не просто получил больше всего пятёрок, но в которые (при равном максимально возможном количестве пятёрок) он еще и получил меньше всего троек. Поэтому заведём ещё массив \u003ccode\u003eworst\u003c/code\u003e, в котором будем хранить количество троек, полученных в течение соответствующих \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e дней. \u003c/p\u003e\u003cp\u003eТакже напишем метод \u003ccode\u003eprepare()\u003c/code\u003e, в котором выделим память под массивы \u003ccode\u003estart\u003c/code\u003e и \u003ccode\u003eworst\u003c/code\u003e, а также посчитаем количество пятёрок и троек в первые \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e дней (это будут нулевые элементы указанных массивов):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\nimport java.util.Scanner;\n\npublic class Problem05 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass Courses {\n\t\n\tCourses() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tm \u003d in.nextInt();\n\t\t\n\t\tmarks \u003d new int[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t\tmarks[i] \u003d in.nextInt();\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tvoid prepare() {\n\t\tstart \u003d new int[n-m];\n\t\tworst \u003d new int[n-m];\n\t\t\n\t\tfor (int i \u003d 0; i \u0026lt; m; i++){\n\t\t\tswitch(marks[i]) {\n\t\t\tcase 3: worst[0]++; break;\n\t\t\tcase 5: start[0]++; break;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint n;\n\tint m;\n\tint [] marks;\n\t\n\tint[] start;\n\tint[] worst;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТеперь напишем метод solve(), который и реализует логику \u0026quot;скольжения\u0026quot;: проверяем, какой элемент мы убираем из рассмотрения, и при необходимости изменяем значения величин, отвечающих за пятёрки или тройки; затем проверяем добавляемый элемент. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\nimport java.util.Scanner;\n\npublic class Problem05 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass Courses {\n\t\n\tCourses() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tm \u003d in.nextInt();\n\t\t\n\t\tmarks \u003d new int[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t\tmarks[i] \u003d in.nextInt();\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tvoid prepare() {\n\t\tstart \u003d new int[n-m+1];\n\t\tworst \u003d new int[n-m+1];\n\t\t\n\t\tfor (int i \u003d 0; i \u0026lt; m; i++){\n\t\t\tswitch(marks[i]) {\n\t\t\tcase 3: worst[0]++; break;\n\t\t\tcase 5: start[0]++; break;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid solve() {\n\t\t\n\t\tfor (int i \u003d m; i \u0026lt; n; i++){\n\t\t\tstart[i-m+1] \u003d start[i-m];\n\t\t\tworst[i-m+1] \u003d worst[i-m];\n\t\t\t\n\t\t\tswitch(marks[i-m]) {\n\t\t\tcase 3: worst[i-m+1]--; break;\n\t\t\tcase 5: start[i-m+1]--; break;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(marks[i]){\n\t\t\tcase 3: worst[i-m+1]++; break;\n\t\t\tcase 5: start[i-m+1]++; break;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\t\n\t}\n\t\n\tint n;\n\tint m;\n\tint [] marks;\n\t\n\tint[] start;\n\tint[] worst;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбратите внимание, что для оценки \u003ccode\u003emarks[i]\u003c/code\u003e мы записываем результат в \u003ccode\u003estart[i-m+1]\u003c/code\u003e и \u003ccode\u003eworst[i-m+1]\u003c/code\u003e: эта оценка будет последней для анализируемых нами \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e дней, а массивы \u003ccode\u003estart\u003c/code\u003e и \u003ccode\u003eworst\u003c/code\u003e хранят количество соответствующих оценок, начиная с некоторого дня \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003esolve()\u003c/code\u003e пока ещё не завершён: ведь теперь нам нужно найти максимальное значение в массиве \u003ccode\u003estart\u003c/code\u003e, а при равных значениях сохранять то, для которого соответствующее значение в массиве \u003ccode\u003eworst\u003c/code\u003e меньше. Номер соответствующего дня будем хранить в переменной \u003ccode\u003etheBestDay\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eДопишем этот фрагмент в метод \u003ccode\u003esolve()\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\nimport java.util.Scanner;\n\npublic class Problem05 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass Courses {\n\t\n\tCourses() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tm \u003d in.nextInt();\n\t\t\n\t\tmarks \u003d new int[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t\tmarks[i] \u003d in.nextInt();\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tvoid prepare() {\n\t\tstart \u003d new int[n-m+1];\n\t\tworst \u003d new int[n-m+1];\n\t\t\n\t\tfor (int i \u003d 0; i \u0026lt; m; i++){\n\t\t\tswitch(marks[i]) {\n\t\t\tcase 3: worst[0]++; break;\n\t\t\tcase 5: start[0]++; break;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid solve() {\n\t\t\n\t\tfor (int i \u003d m; i \u0026lt; n; i++){\n\t\t\tstart[i-m+1] \u003d start[i-m];\n\t\t\tworst[i-m+1] \u003d worst[i-m];\n\t\t\t\n\t\t\tswitch(marks[i-m]) {\n\t\t\tcase 3: worst[i-m+1]--; break;\n\t\t\tcase 5: start[i-m+1]--; break;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(marks[i]){\n\t\t\tcase 3: worst[i-m+1]++; break;\n\t\t\tcase 5: start[i-m+1]++; break;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\ttheBestDay \u003d 0; \n\t\t\n\t\tfor (int i \u003d 1; i \u0026lt; n-m+1; i++){\n\t\t\tif (start[i] \u0026gt; start[theBestDay]) {\n\t\t\t\ttheBestDay \u003d i;\n\t\t\t}\n\t\t\telse if (start[i] \u003d\u003d start[theBestDay]){\n\t\t\t\tif (worst[i] \u0026lt; worst[theBestDay]) {\n\t\t\t\t\ttheBestDay \u003d i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tint n;\n\tint m;\n\tint [] marks;\n\t\n\tint[] start;\n\tint[] worst;\n\t\n\tint theBestDay;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВсё, что нам осталось написать в классе \u003ccode\u003eCourses\u003c/code\u003e — это метод \u003ccode\u003eprint\u003c/code\u003e, выводящий ответ. Вероятно, он не нуждается в комментариях, кроме лишь того, что при выводе мы добавляем к номеру дня единицу, чтобы поддержать 1-based нумерацию:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\nimport java.util.Scanner;\n\npublic class Problem05 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass Courses {\n\t\n\tCourses() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tm \u003d in.nextInt();\n\t\t\n\t\tmarks \u003d new int[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t\tmarks[i] \u003d in.nextInt();\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tvoid prepare() {\n\t\tstart \u003d new int[n-m+1];\n\t\tworst \u003d new int[n-m+1];\n\t\t\n\t\tfor (int i \u003d 0; i \u0026lt; m; i++){\n\t\t\tswitch(marks[i]) {\n\t\t\tcase 3: worst[0]++; break;\n\t\t\tcase 5: start[0]++; break;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid solve() {\n\t\t\n\t\tfor (int i \u003d m; i \u0026lt; n; i++){\n\t\t\tstart[i-m+1] \u003d start[i-m];\n\t\t\tworst[i-m+1] \u003d worst[i-m];\n\t\t\t\n\t\t\tswitch(marks[i-m]) {\n\t\t\tcase 3: worst[i-m+1]--; break;\n\t\t\tcase 5: start[i-m+1]--; break;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(marks[i]){\n\t\t\tcase 3: worst[i-m+1]++; break;\n\t\t\tcase 5: start[i-m+1]++; break;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\ttheBestDay \u003d 0; \n\t\t\n\t\tfor (int i \u003d 1; i \u0026lt; n-m+1; i++){\n\t\t\tif (start[i] \u0026gt; start[theBestDay]) {\n\t\t\t\ttheBestDay \u003d i;\n\t\t\t}\n\t\t\telse if (start[i] \u003d\u003d start[theBestDay]){\n\t\t\t\tif (worst[i] \u0026lt; worst[theBestDay]) {\n\t\t\t\t\ttheBestDay \u003d i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tvoid print() {\n\t\tSystem.out.println(theBestDay+1);\n\t\tSystem.out.println(start[theBestDay] + \u0026quot; \u0026quot; + worst[theBestDay]);\n\t}\n\t\n\tint n;\n\tint m;\n\tint [] marks;\n\t\n\tint[] start;\n\tint[] worst;\n\t\n\tint theBestDay;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНаконец, запишем код в методе \u003ccode\u003emain()\u003c/code\u003e класса \u003ccode\u003eProblem05\u003c/code\u003e. Итоговый код будет иметь следующий вид:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage practice01;\n\nimport java.util.Scanner;\n\npublic class Problem05 {\n\n\tpublic static void main(String[] args) {\n\t\tCourses courses \u003d new Courses();\n\t\tcourses.prepare();\n\t\tcourses.solve();\n\t\tcourses.print();\n\t}\n\n}\n\nclass Courses {\n\t\n\tCourses() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tm \u003d in.nextInt();\n\t\t\n\t\tmarks \u003d new int[n];\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++){\n\t\t\tmarks[i] \u003d in.nextInt();\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tvoid prepare() {\n\t\tstart \u003d new int[n-m+1];\n\t\tworst \u003d new int[n-m+1];\n\t\t\n\t\tfor (int i \u003d 0; i \u0026lt; m; i++){\n\t\t\tswitch(marks[i]) {\n\t\t\tcase 3: worst[0]++; break;\n\t\t\tcase 5: start[0]++; break;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid solve() {\n\t\t\n\t\tfor (int i \u003d m; i \u0026lt; n; i++){\n\t\t\tstart[i-m+1] \u003d start[i-m];\n\t\t\tworst[i-m+1] \u003d worst[i-m];\n\t\t\t\n\t\t\tswitch(marks[i-m]) {\n\t\t\tcase 3: worst[i-m+1]--; break;\n\t\t\tcase 5: start[i-m+1]--; break;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(marks[i]){\n\t\t\tcase 3: worst[i-m+1]++; break;\n\t\t\tcase 5: start[i-m+1]++; break;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\ttheBestDay \u003d 0; \n\t\t\n\t\tfor (int i \u003d 1; i \u0026lt; n-m+1; i++){\n\t\t\tif (start[i] \u0026gt; start[theBestDay]) {\n\t\t\t\ttheBestDay \u003d i;\n\t\t\t}\n\t\t\telse if (start[i] \u003d\u003d start[theBestDay]){\n\t\t\t\tif (worst[i] \u0026lt; worst[theBestDay]) {\n\t\t\t\t\ttheBestDay \u003d i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tvoid print() {\n\t\tSystem.out.println(theBestDay+1);\n\t\tSystem.out.println(start[theBestDay] + \u0026quot; \u0026quot; + worst[theBestDay]);\n\t}\n\t\n\tint n;\n\tint m;\n\tint [] marks;\n\t\n\tint[] start;\n\tint[] worst;\n\t\n\tint theBestDay;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПротестируйте полученное решение на следующих наборах данных:\u003c/p\u003e\u003cp\u003e\u003ccode\u003e 20 7 \u003c/code\u003e \u003cbr /\u003e \u003ccode\u003e 4 3 5 5 3 5 3 3 4 4 4 5 5 4 4 3 4 5 3 5 \u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003e 20 7 \u003c/code\u003e \u003cbr /\u003e \u003ccode\u003e 4 3 5 4 3 5 4 3 5 4 3 5 5 4 4 3 4 5 3 5 \u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003e 20 7 \u003c/code\u003e \u003cbr /\u003e \u003ccode\u003e 4 3 5 5 3 5 3 3 5 4 4 5 5 4 4 3 4 5 3 5 \u003c/code\u003e\u003c/p\u003e\u003cp\u003eПредложите свои тесты.\u003c/p\u003e\u003ch4\u003eЗадачи для решения в аудитории и дома:\u003c/h4\u003e\u003cp\u003e\u003cem\u003e(Напоминание: при сдаче задачи в тестирующую систему не забудьте закомментировать строку с \u003ccode\u003epackage\u003c/code\u003e)\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/group/fozojLMqYc/contest/100898\"\u003eТренировочное соревнование (одномерные массивы — 2)\u003c/a\u003e \u003c/p\u003e\u003cp\u003eА также задачи с acm.timus.ru\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1370\"\u003e1370 Волшебник\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1021\"\u003e1021 Таинство суммы\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1998\"\u003e1998 Старый падаван\u003c/a\u003e\u003c/p\u003e\u003cp\u003eНебольшие подсказки:\u003c/p\u003e\u003cp\u003eВ задаче 1021 следует воспользоваться тем фактом, что оба массива упорядочены.\u003c/p\u003e\u003cp\u003eЗадача 1998, вероятно, заметно сложнее двух предыдущих задач.\u003c/p\u003e\u003c/div\u003e","tags":["массив","скользящее окно","java"]}}