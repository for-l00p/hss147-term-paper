{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1513916288,"rating":2,"authorHandle":"usernameson","modificationTimeSeconds":1513917268,"id":56538,"title":"\u003cp\u003eWhy does this work?\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eSomehow I managed to solve \u003ca href\u003d\"/contest/901/problem/B\" title\u003d\"Codeforces Round 453 (Div. 1)\"\u003e901B - GCD of Polynomials\u003c/a\u003e however I don\u0027t know why my solution works. My idea was to pick two random polynomials of degrees n and n-1 check how many steps it takes to find the gcd and return the polynomials if the answer is n. However doing the gcd over \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6e/ce/6ece13164cd2c69727570dcc813c1b53bbe99d95.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is a pain because of fractions. If you try to avoid them by multiplication by denominators things overflow pretty quickly. \u003c/p\u003e\u003cp\u003eSo I decided to pick a prime and do gcds over the finite field \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. The strange thing is with a medium sized prime like 1009 the algorithm took more steps over this field than over \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6e/ce/6ece13164cd2c69727570dcc813c1b53bbe99d95.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Then I tried using the prime 43 just to see what would happen, since it worked on the case where 1009 gave an incorrect answer. Surprisingly using 43 worked for all the cases. Anyone know of a special relationship between the number of steps the Euclidean algorithm for polynomials takes over \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6e/ce/6ece13164cd2c69727570dcc813c1b53bbe99d95.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e for a given prime \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e?\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n \nusing namespace std;\n//polynomial division over the finite field F_p\nvector\u0026lt;int\u0026gt; pdivFF(vector\u0026lt;int\u0026gt; p1, vector\u0026lt;int\u0026gt; p2, vector\u0026lt;int\u0026gt;\u0026amp; inv, int prime){\n    auto p1ff\u003dmodify(p1,prime), p2ff\u003dmodify(p2,prime);\n    int degp1\u003d0, degp2\u003d0;\n    int sz\u003dp1.size();\n    for(int i\u003d0; i\u0026lt;sz; i++){\n        if(p1ff[i]) degp1\u003di;\n        if(p2ff[i]) degp2\u003di;\n    }\n    int shift\u003ddegp1-degp2;\n    if(shift\u0026gt;1){\n        return vector\u0026lt;int\u0026gt;(sz,0);\n    }\n    auto rem\u003dp1ff;\n    while(shift\u0026gt;\u003d0){\n        int mult\u003drem[degp2+shift]*inv[p2ff[degp2]];\n        for(int i\u003ddegp2; i\u0026gt;\u003d0; i--){\n            rem[i+shift]-\u003dp2ff[i]*mult;\n        }\n        shift--;\n    }\n    return modify(rem, prime);\n    \n}\n\n//count number of steps to find the gcd over F_p\nint stepCtFF(vector\u0026lt;int\u0026gt; p1, vector\u0026lt;int\u0026gt; p2, vector\u0026lt;int\u0026gt;\u0026amp; inv, int prime){\n    int ans\u003d0;\n    int sz\u003dp1.size();\n    vector\u0026lt;int\u0026gt; noRem(sz, 0);\n    while(p2!\u003dnoRem){\n        auto rem\u003dpdivFF(p1,p2, inv, prime);\n        p1\u003dp2;\n        p2\u003drem;\n        ans++;       \n    }\n    return ans;\n}\nint main() {\n    \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n   \n    int n;\n    cin\u0026gt;\u0026gt;n;\n    \n    vector\u0026lt;int\u0026gt; p1(n+1,0), p2(n+1,0);\n    p1[n]\u003d1, p2[n-1]\u003d1;\n    srand(time(0));\n    \n    default_random_engine gen;\n    uniform_int_distribution\u0026lt;int\u0026gt; dist(-1,1);\n    \n    //choose a prime and create the inverse table\n    int prime\u003d41;\n    vector\u0026lt;int\u0026gt; inv(prime,0);\n    for(int i\u003d1; i\u0026lt;prime; i++){\n        for(int j\u003d1; j\u0026lt;prime; j++){\n            if(i*j%prime\u003d\u003d1) inv[i]\u003dj, inv[j]\u003di;\n        }\n    }\n    \n    //generate random polynomials until we have one that takes n steps to find the gcd over F_p\n    while(stepCtFF(p1,p2, inv, prime)!\u003dn){\n        generate(p1.begin(), p1.begin()+n-1, [\u0026amp;dist, \u0026amp;gen](){return dist(gen);});\n        generate(p2.begin(), p2.begin()+n-2, [\u0026amp;dist, \u0026amp;gen](){return dist(gen);});\n        \n    }\n    \n    cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl;\n    for(int i:p1) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\n    cout\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;n-1\u0026lt;\u0026lt;endl;\n    for(int i\u003d0; i\u0026lt;n; i++){\n        cout\u0026lt;\u0026lt;p2[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\n    }\n   \n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["#number theory","constructive algorithms","polynomials"]}}