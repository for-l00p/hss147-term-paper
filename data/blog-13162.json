{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1406128943,"rating":6,"authorHandle":"opening","modificationTimeSeconds":1406129004,"id":13162,"title":"\u003cp\u003eA very interesting solution of problem SRM 569 div1 500pt \u0026quot;TheJediTest\u0026quot;\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eIn topcoder Arena, I find a pretty interesting solution to the problem, SRM 567 div1 medium \u0026quot;TheJediTest\u0026quot;.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://community.topcoder.com/stat?c\u003dproblem_statement\u0026amp;pm\u003d12265\u0026amp;rd\u003d15489\"\u003eProblem_Link\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe solution is given by \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/ftiasch\" title\u003d\"Grandmaster ftiasch\"\u003eftiasch\u003c/a\u003e\u003c/p\u003e\u003cp\u003eMost of the solutions are bases on a greedy algorithm, but this one seems like based on some graph theory. Could someone tell me how this solution works? Thanks!\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epublic class TheJediTest {\n\tfinal static long INF \u003d (long)1e18;\n\n\tpublic int minimumSupervisors(int[] students, int m) {\n\t\tint n \u003d students.length;\n\t\tlong[][] graph \u003d new long[n+1][n+1];\n\t\tfor(int i\u003d0; i\u0026lt;\u003dn; ++i) {\n\t\t\tfor(int j\u003d0; j\u0026lt;\u003dn; ++j)\n\t\t\t\tgraph[i][j] \u003d INF;\n\t\t}\n\t\t\n\t\tfor(int i\u003d0; i\u0026lt;n; ++i)\n\t\t\tgraph[i][i+1] \u003d 0;\n\n\t\tfor(int i\u003d0; i\u0026lt;n; ++i) {\n\t\t\tlong sum \u003d 0;\n\t\t\tfor(int j\u003di; j\u0026lt;n; ++j) {\n\t\t\t\tsum +\u003d students[j];\n\t\t\t\tint l \u003d Math.min(i-1, 0);\n\t\t\t\tint r \u003d Math.max(j+1, n-1) + 1;\n\t\t\t\tgraph[l][r] \u003d Math.min(graph[l][r], (sum + m - 1)/m * -1);\n\t\t\t}\n\t\t}\n\t\tfor(int k\u003d0; k\u0026lt;\u003dn; ++k)\n\t\t\tfor(int i\u003d0; i\u0026lt;\u003dn; ++i)\n\t\t\t\tfor(int j\u003d0; j\u0026lt;\u003dn; ++j)\n\t\t\t\t\tgraph[i][j] \u003d Math.min(graph[i][j], graph[i][k] + graph[k][j]);\n\n\t\treturn -(int)graph[0][n];\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["topcoder","graph"]}}