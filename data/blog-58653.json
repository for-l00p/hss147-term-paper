{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1522440994,"rating":-11,"authorHandle":"eidan","modificationTimeSeconds":1522450554,"id":58653,"title":"\u003cp\u003eSorting and comparing 2D points in counter-clockwise order\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI have now bumped into several geometry problems that require clockwise 2D point sorting relative to a specific center, \u003ca href\u003d\"https://www.codechef.com/DEC17/problems/REDBLUE/\"\u003ehere\u003c/a\u003e is an example. The key to solving this task is to implement a comparator function, with this header:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ebool operator\u0026lt;(const Point \u0026amp;a, const Point \u0026amp;b);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe function should return true iff \u003cem\u003ePoint a\u003c/em\u003e goes before \u003cem\u003ePoint b\u003c/em\u003e in counter-clockwise order (with a defined center-point). If we correctly implement this function, we can do countless things, such as sorting points, handling sets and maps of points, applying binary search, etc.\u003c/p\u003e\u003cp\u003eI have researched and found out there is not really a simple, short, easy-to-remember implementation for this function out there. That\u0027s why I decided to share mine in this blog.\u003c/p\u003e\u003cp\u003eFirst of all, you obviously need a \u003cem\u003ePoint\u003c/em\u003e template. If you aren\u0027t familiar with this, read \u003ca href\u003d\"//codeforces.com/blog/entry/48122\"\u003ethis\u003c/a\u003e blog. \u003c/p\u003e\u003cp\u003eI only included dot product and z-coordinate of cross product, since that\u0027s the only two functions we will be needing. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003estruct Point{\n    ll x, y;\n    Point(){}\n    Point(ll x, ll y): x(x), y(y){}\n};\n\nll operator%(const Point \u0026amp;a, const Point \u0026amp;b){//z-coordinate of cross product\n    return a.x * b.y - a.y * b.x;\n}\nll operator*(const Point \u0026amp;a, const Point \u0026amp;b){//dot product\n    return a.x * b.x + a.y * b.y;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThese functions are basic in geometry. Now, without loss of generality, suppose our center is the origin \u003cem\u003e(0, 0)\u003c/em\u003e (if not, just make points relative to your center). We also need a starting reference, since points could be all around the center. Let\u0027s call this point \u003cem\u003eu\u003c/em\u003e, and suppose it\u0027s value is \u003cem\u003e(0, 1)\u003c/em\u003e (again, without loss of generality). \u003c/p\u003e\u003cp\u003eThis is what you need:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003econst Point u(0, 1);\nbool A(const Point \u0026amp;p){\n    return u % p \u0026gt; 0 || (u % p \u003d\u003d 0 \u0026amp;\u0026amp; u * p \u0026gt; 0);\n}\nbool operator\u0026lt;(const Point \u0026amp;a, const Point \u0026amp;b){\n    return (A(a) \u003d\u003d A(b) \u0026amp;\u0026amp; a % b \u0026gt; 0) || (A(a) \u0026amp;\u0026amp; !A(b));\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat\u0027s it. Those two one-liners will work correctly for any two points different than the origin.\u003c/p\u003e\u003cp\u003eHope it was helpful. Happy coding!\u003c/p\u003e\u003c/div\u003e","tags":["#geometry"]}}