{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1508685894,"rating":-3,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1508685894,"id":55341,"title":"\u003cp\u003eNotes on Codeforces Beta Round #86, Div2-A, B, C, D, E\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/114/problem/A\" title\u003d\"Codeforces Beta Round 86 (Div. 2 Only)\"\u003e114A - Cifera\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe keep dividing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e until \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e is not a multiple of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e any more, and then check whether \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e is reduced to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e or not.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/114/problem/B\" title\u003d\"Codeforces Beta Round 86 (Div. 2 Only)\"\u003e114B - PFAST Inc.\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAs \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is limited up to \u003cspan class\u003d\"tex-span\"\u003e16\u003c/span\u003e, we can use bitmask to enumerate all the feasible combinations and check whether they can form a group or not. The total complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e × \u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/114/problem/C\" title\u003d\"Codeforces Beta Round 86 (Div. 2 Only)\"\u003e114C - Grammar Lessons\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is a straightforward implementation problem. For each given string, we need to check the following conditions.\u003c/p\u003e\u003cp\u003e1) all the words end with the required suffix\u003c/p\u003e\u003cp\u003e2) all the words have the same gender\u003c/p\u003e\u003cp\u003e3) all the words appear in the required order\u003c/p\u003e\u003cp\u003e4) there is exactly one noun word\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/114/problem/D\" title\u003d\"Codeforces Beta Round 86 (Div. 2 Only)\"\u003e114D - Petr#\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe idea is to previously calculate all the positions of the required prefix and suffix. Then, we enumerate every pair of feasible combination, and find out all the different substrings.\u003c/p\u003e\u003cp\u003eTherefore, the main task is how to determine whether two strings are the same or not. I did not come up with a good solution, however I studied the other accepted codes. \u003c/p\u003e\u003cp\u003eI found that they adopt an “unsigned long long int” variable \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, initialized with zero value, and compute \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003ex\u003c/i\u003e × \u003ci\u003eprime\u003c/i\u003e + \u003ci\u003es\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eprime\u003c/i\u003e\u003c/span\u003e is a prime integer. I think this means to transform or map the string to an integer, like hash table. However, I did not figure out how could this guarantee that no two strings are mapped to the same integer, since we have at most \u003cspan class\u003d\"tex-span\"\u003e26\u003csup class\u003d\"upper-index\"\u003e2000\u003c/sup\u003e\u003c/span\u003e different strings but only \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e64\u003c/sup\u003e\u003c/span\u003e integers. Although for some substring of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e, we can in fact only have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e different ones, which is quite small compared with \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e64\u003c/sup\u003e\u003c/span\u003e, but this still can not guarantee that no collisions occur...\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/114/problem/E\" title\u003d\"Codeforces Beta Round 86 (Div. 2 Only)\"\u003e114E - Double Happiness\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThere is a standard solution, referred to as “sieve function”, to this problem. Using “bitset” can also solve the memory problem. Instead of testing each prime integer, we can enumerate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, and then test whether the result of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e + \u003ci\u003eb\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e is prime or not. The complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eab\u003c/i\u003e) \u003d \u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. To further decrease the constant of complexity, for each value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, we can start enumerating the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + 1\u003c/span\u003e, with increment step of \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e. The reason is that if both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e are even or odd, the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e + \u003ci\u003eb\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e must be an even integer, and thus is definitely not a prime integer.\u003c/p\u003e\u003c/div\u003e","tags":[]}}