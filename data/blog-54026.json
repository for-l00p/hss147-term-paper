{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1503583872,"rating":4,"authorHandle":"Hamzqq9","modificationTimeSeconds":1503583872,"id":54026,"title":"\u003cp\u003eSeviye Tespit Sınavı Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eA\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eipucu 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTam kare sayılar iki sayının çarpımı ile elde edilirler.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eİpucu 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eİki sayı arasındaki sayıların kökleri bu iki sayının kökleri arasındadır.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eÇözüm\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003col\u003e   \u003cli\u003eve 2. sayının köklerini alırız. Mantıken bu kökü alınmış sayılar arasındaki sayıların karesi 1. ve 2. sayı arasında olacaktır. yani cevabımız bu iki sayının kökleri arasındaki sayıların adetidir.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eZaman Karmaşıklığı : O( Q * LOG( sayı ) )\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eB\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eİpucu 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTek sayıların en büyük tek çarpanı kendileridir.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eİpucu 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eÇift sayıların en büyük tek çarpanları içindeki 2 çarpanlarının gitmesi sonucu ortaya çıkar.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eÇözüm\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eÖncelikle tek sayıların en büyük tek çarpanı kendileri olduğundan iki sayı arasındaki tek sayıların toplamını bulacağız. 1. sayı a 2. sayı b olsun. O zaman a ve b arasındaki tek sayıların toplamı 1 den b ye kadar olan tek sayıların toplamı — 1 den a-1 e kadar olan tek sayıların toplamı şeklinde bulunabilir. Peki çift sayıların durumunu nasıl halledeceğiz? Onun içinse 2. ipucunda bahsettiğim yolu kullanacağız yani 2 nin tüm üslerini deneyeceğiz ve a yı ve b yi 2 nin üslerine böleceğiz. yeni a ile yeni b arasındaki tek sayıların toplamını bulmak ise soruyu çözecektir. Çünkü eğer ben bir sayıyı 2 nin üssüne böldüğümde tek sayı oluyorsa o zaman en büyük çarpanına ulaşmışım demektir.\u003c/p\u003e\u003cp\u003eZaman Karmaşıklığı : O( Q * LOG( 10^9 ) )\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eC\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eİpucu 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eprefix sum ( Ön toplam ) kullanarak soruyu çözeceğiz.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eİpucu 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003e2D prefix sumdaki ekleme çıkarma işlemlerinin benzeri yapılacak.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eÇözüm\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eBurada 3D prefix sum kullanılarak belli bölgedeki eşya sayısına O(1) de ulaşabilir ve soruyu çözebiliriz. 3D prefix toplamda dp[i][j][k]\u003ddp[i-1][j][k]+dp[i][j-1][k]+dp[i][j][k-1]-dp[i-1][j-1][k]-dp[i-1][j][k-1]-dp[i][j-1][k-1]+dp[i-1][j-1][k-1] yöntemi ile 1,1,1 kordinatından i,j,k kordinatına kadar olan eşyaların sayısını hesaplayabiliriz. Bu yönteme içerme-dışarma ile varabilirsiniz ve genellemeler yapabilirsiniz. İki kordinat arasındaki eşya sayısına da prefix sum larda olduğu gibi çıkarma işlemi ile ulaşabilirsiniz. erişimde ise a,b,c kordinatları ile i,j,k kordinatları arasındaki eşya sayısına ulaşmayı şöyle gösteririz: dp[i][j][k]-dp[a-1][j][k]-dp[i][b-1][k]-dp[i][j][c-1]+dp[a-1][b-1][k]+dp[a-1][j][c-1]+dp[i][b-1][c-1]-dp[a-1][b-1][c-1].\u003c/p\u003e\u003cp\u003eZaman Karmaşıklığı : O(N^3)\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eD\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eİpucu 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eGcd mizin 1 den büyük olması gerektiğinden ve asal olmayan sayıları denemektense asal sayıları denemek işimizi kolaylaştıracaktır. Çünkü sonuçta cevap için gcd 6 olsun. gcd yi 2 yada 3 alsak da aynı cevaba varırız.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eİpucu 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eBurada gcd yi deneyeceğiz ve 2*10^6 ya kadar asal sayıları bilmemiz gerekiyor bunu hızlı bir şekilde sieve kullanarak bulabiliriz.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eİpucu 3\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTüm asal sayıları tek tek deneyemeyeceğimize göre ve sieve yaparken üzerinden geçtiğimiz sayıların bizim elimizdeki sayılar olabilmesi sebebi ile sieve yaparken aynı zamanda cevabı bulacağız.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eÇözüm\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eBurada gcdmizi asal sayılar yapacağız ve bunları deneyceğiz. Ama teker teker denemek yerine sieve yazarken asal olmayan sayıları markladığımızda mantıken elimizdeki sayıların bazıları marklanacak. Yani eğer bu sayı elimde ise o zaman gcdmin şuanki asal olması durumunda bu sayıyı alabilirim. Böylelikle her asal sayı için o asal sayıya bölünen sayılara bakıp eğer elimde o sayı varsa o asal sayının gcd olması durumundaki cevabı artırıyorum. Unutmamak gerekir ki elimizde o asal sayıdan da olabilir. Onu da halledersiniz.\u003c/p\u003e\u003cp\u003eZaman Karmaşıklığı : O(NloglogN)\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eE\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eİpucu 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eDinamik programlama kullanılacak ve çözüm N^3 zaman karmaşıklığında olacak.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eİpucu 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003e1 den H derinliğine kadar oluşabilecek ağaç sayılarından sadece H derinliğindeki ağaçların sayısına nasıl ulaşabilirim?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eÇözüm\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eBurada dp[I][J] bize J derinliğindeyim ve bu alt ağaçta J tane node kullanabilirim Kaç farklı şekilde derinliği H dan küçük eşit ağaç oluşturabilirim in cevabını versin. Bu durumun cevabı: elimdeki I node den 0 tanesini sol I tanesini sağ çocuğa veririm + elimdeki I node den 1 tanesini sol I-1 tanesini sağ çocuğa veririm + ... + elimdeki I node den I tanesini sol 0 tanesini sağ çocuğa veririm in toplamıdır. yani dp[I][J] \u003d dp[0][J+1] * dp[I][J+1] + dp[1][J+1] * dp[I-1][J+1] + ... + dp[I][J+1] * dp[0][J+1] in cevabıdır. Peki Bu cevaptan sadece H derinliğindekileri nasıl bulurum? Bunun için de soruyu H için çözüyoruz ve H-1 için çözüp H için olan çözümden H-1 için olan çözümü çıkartıyoruz. Yani 1 den H derinliğine kadar olan BST sayısından 1 den H-1 e kadar olan BST sayısını çıkarınca elimizde sadece H derinliğindeki BST sayısı kalıyor. Mod işlemlerini halledersiniz.\u003c/p\u003e\u003cp\u003eZaman Karmaşıklığı : O(N^3)\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eF\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eİpucu 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eAcaba Heap ( Priority Queue ) ile soruyu çözebilirmiyim?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eİpucu 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eİki tane Heap olsa biri max biri min heap yani biri en küçük diğeri ise en büyük elemanı sunsun. Buradan çözüme varabilir miyim?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eÇözüm\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eİki heap olacak. Biri max biri min heap. Bu iki heap veledleri öyle bir şekilde tutacak ki veledler sortlu olacak. Böylelikle ortanca velede ulaşabileceğim. Bunu yaparken de aşağıdaki işlemleri yapıyoruz. 1) gelen veledi max heap e at. 2) max heap ile min heap arasındaki size ( eleman sayısı ) farkı 2 den büyükse o zaman max heap teki en büyük veledi min heap e atıyoruz. ( Her zaman max heap min heap den size olarak büyük eşit olacak olacak) 3) eğer şuanki veled sayısı tek ise max heapin en büyük elemanı, değilse max ve min heapin en büyük elemanlarının ortalaması cevabımız olacaktır.\u003c/p\u003e\u003cp\u003eZaman Karmşıklığı: O(NlogN)\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}