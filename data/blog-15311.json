{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1419209635,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1419209814,"id":15311,"title":"\u003cp\u003eОбщая структура программы на Java\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eВ \u003ca href\u003d\"http://codeforces.ru/group/t4gy0Ot4NY/blog/entry/448\"\u003eпредыдущей записи\u003c/a\u003e рассказывалось, как создать простейшую программу на Java в среде Eclipse. Посмотрим на эту программу внимательно и проанализируем её составляющие. \u003c/p\u003e\u003cp\u003e\u003cem\u003eСразу скажем, что этот анализ будет совершенно неформальным и не придерживающимся строгости определений и описаний. Его цель — обрисовать структуру программы на Java в самых общих чертах.\u003c/em\u003e \u003cbr /\u003e \u003cbr /\u003e Напомним, что наша первая программа считывала с клавиатуры два вещественных числа, складывала их и выводила результат на экран. Также приведем ещё раз текст этой программы, в котором для удобства занумерованы строки.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e01\tpackage first;\n02\n03\tpublic class AplusB {\n04\n05\t\tpublic static void main(String[] args) {\n06\t\t\tABsumma absum \u003d new ABSumma();\n07\t\t\tabsum.print();\n08\t\t}\n09\n10\t}\n11\n12\tclass ABsumma {\n13\n14\t\tABsumma() {\n15\t\t\tScanner in \u003d new Scanner(System.in);\n16\t\t\tin.useLocale(Locale.US);\n17\t\t\ta \u003d in.nextDouble();\n18\t\t\tb \u003d in.nextDouble();\n19\t\t\tin.close();\n20\t\t}\n21\n22\t\tdouble solve() {\n23\t\t\tdouble res \u003d a + b; \n24\t\t\treturn res;\n25\t\t}\n26\n27\t\tvoid print() {\n28\t\t\tdouble c \u003d solve();\n29\t\t\tSystem.out.println(c);\n30\t\t}\n31\n32\t\tdouble a;\n33\t\tdouble b;\n34\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e1\u003c/strong\u003e. В строке 01 указано имя пакета. Пакет можно считать структурной единицей, способной содержать один или несколько Java-классов. Эти классы могут находиться как в одном, так и в нескольких файлах. Также пакеты могут содержать другие пакеты.\u003c/p\u003e\u003cp\u003eГруппировка классов в пакеты решает несколько задач. \u003cbr /\u003e Во-первых, как правило, в пакет объединяются классы, которые имеют некоторое общее «логическое» назначение. Например, в одном пакете могут содержаться составляющие какого-то большого проекта. Также в один пакет могут быть объединены классы, обеспечивающие реализацию каких-либо сходных действий. Примером тому являются пакеты java.io (классы, организующие ввод / вывод), javax.swing (классы, содержащие иерархию платформенно-независимых компонентов для графического интерфейса пользователя) и ряд других. \u003cbr /\u003e Во-вторых, пакеты избавляют программиста от забот об уникальности имён классов: полное имя каждого класса начинается с имени пакета, а уникальность имени пакета обеспечить значительно проще. Можно сказать, что пакеты обеспечивают пространства имён: в одном пространстве все имена должны быть уникальны, а в разных пространствах они могут быть совпадающими (с точностью до имени пакета). \u003c/p\u003e\u003cp\u003eВообще говоря, можно не указывать пакет в программе — в этом случае Java включает класс в так называемый пакет по умолчанию (default package). Нужно помнить, что все классы рабочей области среды, которые не включены в собственный пакет, будут включаться в один и тот же пакет по умолчанию. Это далеко не всегда удобно. \u003c/p\u003e\u003cp\u003eВместе с тем есть довод «за» использование пакета по умолчанию — многие проверяющие системы (в частности, те, которые используются на Codeforces, на Timus) требуют, чтобы программы на Java, отправляемые на проверку, не использовали собственный пакет. Чтобы Ваша программа была помещена в пакет по умолчанию, нужно при создании класса (п.4 в первой записи) не указывать никакого имени пакета (в строке Package; если же это поле диалогового окна оказалось автоматически заполненным — то очистить его). \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2\u003c/strong\u003e. Строки с 03 по 10 содержат описание класса \u003ccode\u003eAplusB\u003c/code\u003e, а строки с 12 по 34 — описание класса \u003ccode\u003eABSumma\u003c/code\u003e. Класс — это основная структурная единица языка Java. Можно сказать, что класс — это совокупность некоторых данных (именуемых полями) и методов их обработки. Никакие данные и методы не могут существовать вне классов. \u003c/p\u003e\u003cp\u003e\u003cem\u003eКонечно, если в том есть необходимость, методы могут обрабатывать и данные, не принадлежащие классу. Классы, фактически, тоже вносят свою лепту в реализацию пространств имён: внутри класса имена обязаны быть уникальными, но в разных классах могут содержаться методы и данные с одинаковыми именами.\u003c/em\u003e \u003c/p\u003e\u003cp\u003eСами по себе классы являются в некотором смысле «схемами», «чертежами», по которым создаются объекты — экземпляры этих классов. Данные внутри каждого объекта считаются уникальными, характеризующими этот конкретный объект. Не очень часто, но возникает необходимость включать в состав класса какие-то данные, которые не меняются от объекта к объекту. Например, число \u003cspan class\u003d\"tex-span\"\u003eπ\u003c/span\u003e включено в состав класса \u003ccode\u003ejava.lang.Math\u003c/code\u003e (и обозначено в нём \u003ccode\u003ePI\u003c/code\u003e). \u003c/p\u003e\u003cp\u003eМетоды, входящие в состав класса, можно классифицировать по-разному, и в том числе по их «отношению» к данным. Если метод обращается только к данным, которые не меняются от объекта к объекту, то нет необходимости создавать экземпляр объекта для вызова этого метода. В случае же, когда метод обращается к данным, характеризующим конкретный объект, обязательно нужно создать объект и лишь потом вызывать из этого объекта этот метод. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e3\u003c/strong\u003e. Обратите внимание, что класс \u003ccode\u003eAplusB\u003c/code\u003e объявлен с модификатором \u003cstrong\u003epublic\u003c/strong\u003e (строка 03), а у класса \u003ccode\u003eABSumma\u003c/code\u003e такого модификатора нет. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e03\tpublic class AplusB {\n...\n\n12\tclass ABsumma {\n...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВ каждом файле может быть и должен быть ровно один класс, объявленный с модификатором \u003cstrong\u003epublic\u003c/strong\u003e. Имя этого класса должно в точности совпадать с именем файла, в котором этот класс содержится.\u003c/p\u003e\u003cp\u003eТакже в файле может содержаться сколько угодно классов, не имеющих модификатора \u003cstrong\u003epublic\u003c/strong\u003e (в том числе их может и не быть в файле вовсе). \u003cbr /\u003e Важно то, что при обращении к пакету доступны будут только \u003cstrong\u003epublic\u003c/strong\u003e-классы; все остальные классы пакета решают вспомогательные задачи (таким образом можно, к примеру, скрыть реализацию каких-то методов, которая в дальнейшем может быть пересмотрена). \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e4\u003c/strong\u003e. Строка 05 содержит объявление специального метода \u003ccode\u003emain()\u003c/code\u003e. \u003c/p\u003e\u003cp\u003e\u003cem\u003eЗдесь и далее мы всегда будем писать после имени метода круглые скобки, чтобы визуально отличать имя метода от имени переменной или класса. Параметры в скобках будут указываться лишь тогда, когда нужно избежать двусмысленности и т.п.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eЭтот метод позволяет виртуальной машине Java (JVM, Java Virtual Machine) запускать Вашу программу на выполнение.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e05\t\tpublic static void main(String[] args) {\n...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗаголовок этого метода (если более точно, сигнатура — т. е. заголовок вкупе со списком параметров) предопределён и не может меняться: JVM будет отыскивать в Вашей программе именно этот заголовок (мы не говорим об апплетах), после чего будет исполнять то, что записано в теле этого метода, в том порядке, в котором это записано. В частности, в нашем случае в теле метода \u003ccode\u003emain()\u003c/code\u003e записаны два действия: создать объект класса \u003ccode\u003eABSumma\u003c/code\u003e с именем \u003ccode\u003eabsum\u003c/code\u003e и вызвать метод \u003ccode\u003eprint()\u003c/code\u003e этого объекта (вызовом метода называют обращение к этому методу).\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e05\t\tpublic static void main(String[] args) {\n06\t\t\tABsumma absum \u003d new ABSumma();\n07\t\t\tabsum.print();\n08\t\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНо прежде чем обсуждать, что произойдет при выполнении этих действий, скажем еще несколько слов про метод \u003ccode\u003emain()\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eВо-первых, он может быть помещен в класс с любым именем (причём необязательно даже, чтобы этот класс имел модификатор \u003cstrong\u003epublic\u003c/strong\u003e, но пока мы не будем обсуждать такие тонкости). \u003c/p\u003e\u003cp\u003eВо-вторых, он имеет модификатор \u003cstrong\u003epublic\u003c/strong\u003e — это делает его доступным «вне собственного пакета» (в том числе доступным для JVM). \u003c/p\u003e\u003cp\u003eВ третьих, он помечен как \u003cstrong\u003estatic\u003c/strong\u003e — и это значит, что он может вызываться без создания экземпляра класса, в который он помещён. \u003c/p\u003e\u003cp\u003e\u003cem\u003eВероятно, здесь нужно более подробное пояснение. \u003cbr /\u003e Чуть выше мы говорили, что если метод обращается только к данным, которые не меняются от объекта к объекту (или не обращается вовсе ни к каким данным), то нет необходимости создавать для вызова этого метода объект. Такие методы могут быть помечены модификатором \u003cstrong\u003estatic\u003c/strong\u003e. Если Вы попытаетесь внутри \u003cstrong\u003estatic\u003c/strong\u003e-метода обратиться к каким-либо данным, которые зависят от объекта, среда разработки (Eclipse, да и любая другая) сообщит Вам об ошибке. \u003cbr /\u003e В нашем случае всё выглядит достаточно просто: в классе \u003ccode\u003eAplusB\u003c/code\u003e вообще не объявлены никакие поля, так что он содержит единственный метод \u003ccode\u003emain()\u003c/code\u003e. Вся «содержательная логика» программы вынесена в класс \u003ccode\u003eABSumma\u003c/code\u003e, экземпляр которого создается внутри \u003ccode\u003emain()\u003c/code\u003e и над которым опять же внутри \u003ccode\u003emain()\u003c/code\u003e выполняются какие-то действия.\u003c/em\u003e \u003c/p\u003e\u003cp\u003eВ-четвёртых, перед именем метода \u003ccode\u003emain()\u003c/code\u003e указан тип \u003cstrong\u003evoid\u003c/strong\u003e. Вы уже знакомы с этим типом и знаете, что метод такого типа не возвращает никакого значения (т. е. просто выполняет свою работу). \u003c/p\u003e\u003cp\u003eНаконец, \u003ccode\u003emain()\u003c/code\u003e — это имя метода, а \u003ccode\u003eString[] args\u003c/code\u003e — список параметров, которые этот метод может «принимать извне». Поскольку этот метод «общается» с JVM, то и параметры в него могут попадать при вызове исполняющейся программы в командной строке. Эти параметры имеют самый общий вид — массив строк (массив здесь следует понимать как индексированный список строк). Разумеется, передавать какие-либо параметры в метод \u003ccode\u003emain()\u003c/code\u003e совершенно не обязательно (разве что этого потребует логика программы, но в ближайшее время мы с такими программами не столкнёмся). \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e5\u003c/strong\u003e. Теперь посмотрим внимательно на класс \u003ccode\u003eABSumma\u003c/code\u003e. В строках 32 и 33 содержатся описания двух полей этого класса — вещественных переменных \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e32\t\tdouble a;\n33\t\tdouble b;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eНикаких других данных этот класс не содержит. Однако он содержит три метода. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e6\u003c/strong\u003e. Первый из них — конструктор. Конструктор класса всегда называется так же, как и сам класс. \u003c/p\u003e\u003cp\u003e\u003cem\u003eУ одного класса может быть несколько конструкторов, но в этом случае они должны отличаться списком параметров. Вообще говоря, можно и не описывать никаких конструкторов в классе — в этом случае создание экземпляра такого класса обеспечит конструктор класса Object, который является предком по отношению к любому классу Java. Однако чаще всего есть действия, которые имеет смысл выполнить именно в конструкторе.\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e14\t\tABsumma() {\n15\t\t\tScanner in \u003d new Scanner(System.in);\n16\t\t\tin.useLocale(Locale.US);\n17\t\t\ta \u003d in.nextDouble();\n18\t\t\tb \u003d in.nextDouble();\n19\t\t\tin.close();\n20\t\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПодробное описание того, что происходит в конструкторе, Вы можете найти в п.~8 предыдущей записи. Здесь же мы кратко скажем, что конструктор решает задачу инициализации (установки начальных значений) для полей \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e посредством чтения соответствующих значений со стандартного потока ввода (клавиатуры). \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e7\u003c/strong\u003e. Метод \u003ccode\u003esolve()\u003c/code\u003e класса \u003ccode\u003eABSumma\u003c/code\u003e возвращает вещественное значение, равное сумме полей \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e. Заметим, что такая реализация — не единственно возможная; ниже мы покажем, как можно изменить класс \u003ccode\u003eABSumma\u003c/code\u003e. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e22\t\tdouble solve() {\n23\t\t\tdouble res \u003d a + b; \n24\t\t\treturn res;\n25\t\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбратите внимание, что этот метод не имеет параметров: данные, которыми он оперирует, описаны в классе, и поэтому он «знает об их существовании». Что же касается переменной \u003ccode\u003eres\u003c/code\u003e, то она объявлена внутри метода \u003ccode\u003esolve()\u003c/code\u003e и существует только внутри него. Вы не можете обратиться к этой переменной из другого метода, однако в другом методе Вы можете объявить \u003cem\u003eдругую\u003c/em\u003e переменную с \u003cem\u003eтаким же\u003c/em\u003e именем (если Вы подумали о концепции пространств имён, Вы совершенно правы). \u003cbr /\u003e Поскольку метод имеет тип \u003cem\u003edouble\u003c/em\u003e, то он обязан вернуть (по завершении своего выполнения) некоторое вещественное число. Именно это и происходит в строке 24: оператор \u003ccode\u003ereturn\u003c/code\u003e указывает, что именно должно быть возвращено в качестве результата выполнения метода. \u003c/p\u003e\u003cp\u003eЗаметим, что оператор \u003ccode\u003ereturn\u003c/code\u003e действует «немедленно»; если после него будут записаны ещё какие-либо операторы, они никогда не будут выполнены — как только в ходе выполнения метода произойдёт обращение к оператору \u003ccode\u003ereturn\u003c/code\u003e, выполнение метода будет прервано.\u003c/p\u003e\u003cp\u003e\u003cem\u003eВообще говоря, оператор \u003ccode\u003ereturn\u003c/code\u003e без операнда (значения, которое следует возвратить) может использоваться и в \u003cstrong\u003evoid\u003c/strong\u003e-методах, если в этом есть необходимость.\u003c/em\u003e \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e8\u003c/strong\u003e. Наконец, в методе \u003ccode\u003eprint()\u003c/code\u003e, который отвечает за печать результата, сначала описывается вещественная переменная \u003ccode\u003ec\u003c/code\u003e, которой присваивается значение, возвращаемое методом \u003ccode\u003esolve()\u003c/code\u003e. Затем значение этой переменной выводится на экран стандартными средствами. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e27\t\tvoid print() {\n28\t\t\tdouble c \u003d solve();\n29\t\t\tSystem.out.println(c);\n30\t\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e9\u003c/strong\u003e. Теперь «соберём» всё вместе — вернёмся к методу \u003ccode\u003emain()\u003c/code\u003e класса \u003ccode\u003eAplusB\u003c/code\u003e. \u003cbr /\u003e Как мы уже говорили, в первой строке тела метода (она же строка 06) происходит создание экземпляра класса \u003ccode\u003eABSumma\u003c/code\u003e, который назван \u003ccode\u003eabsum\u003c/code\u003e. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e05\t\tpublic static void main(String[] args) {\n06\t\t\tABsumma absum \u003d new ABSumma();\n07\t\t\tabsum.print();\n08\t\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЭто делается при помощи оператора \u003ccode\u003enew\u003c/code\u003e, за которым следует обращение к конструктору класса \u003ccode\u003eABSumma\u003c/code\u003e. Вызов конструктора приводит к обращению к строкам 15 — 19 (выполняется код, записанный в них). \u003cbr /\u003e Далее, в строке 07 вызывается метод \u003ccode\u003eprint()\u003c/code\u003e объекта \u003ccode\u003eabsum\u003c/code\u003e. Этот вызов приводит к обращению к строкам 28 — 29. \u003cbr /\u003e В строке 28 вызывается метод \u003ccode\u003esolve()\u003c/code\u003e (этого же объекта \u003ccode\u003eabsum\u003c/code\u003e) — т. е. выполняются строки 23 — 24. Когда вычисление завершено, переменная \u003ccode\u003ec\u003c/code\u003e получает значение суммы полей \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e. После этого выполняется уже строка 29. \u003c/p\u003e\u003cp\u003e\u003cem\u003eЗаметим, что объявление переменной \u003ccode\u003ec\u003c/code\u003e было в некотором смысле «излишеством»: тело метода \u003ccode\u003eprint()\u003c/code\u003e вполне могло уместиться в одной строке: \u003ccode\u003eSystem.out.println(solve())\u003c/code\u003e.\u003c/em\u003e \u003c/p\u003e\u003cp\u003eЗавершение выполнения метода \u003ccode\u003eprint()\u003c/code\u003e, который является последним, вызванным в методе \u003ccode\u003emain()\u003c/code\u003e, означает и завершение выполнения программы. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e10\u003c/strong\u003e. А сейчас продемонстрируем, как можно было ещё написать эту программу. Мы оставим прежним наименование пакета, а вместо классов \u003ccode\u003eAplusB\u003c/code\u003e и \u003ccode\u003eABSumma\u003c/code\u003e напишем классы \u003ccode\u003eAplusB2\u003c/code\u003e и \u003ccode\u003eABSumma2\u003c/code\u003e (Вы можете создать новый класс в пакете \u003ccode\u003efirst\u003c/code\u003e, назвать его \u003ccode\u003eAplusB2\u003c/code\u003e и воспроизвести этот код):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e01\tpackage first;\n02\n03\tpublic class AplusB2 {\n04\n05\t\tpublic static void main(String[] args) {\n06\t\t\tABsumma2 absum \u003d new ABSumma2();\n07\t\t\tabsum.solve();\n08\t\t\tabsum.print();\n09\t\t}\n10\n11\t}\n12\n13\tclass ABsumma2 {\n14\n15\t\tABsumma2() {\n16\t\t\tScanner in \u003d new Scanner(System.in);\n17\t\t\tin.useLocale(Locale.US);\n18\t\t\ta \u003d in.nextDouble();\n19\t\t\tb \u003d in.nextDouble();\n20\t\t\tin.close();\n21\t\t}\n22\n23\t\tvoid solve() {\n24\t\t\tres \u003d a + b; \n25\t\t}\n26\n27\t\tvoid print() {\n28\t\t\tSystem.out.println(res);\n29\t\t}\n30\n31\t\tdouble a;\n32\t\tdouble b;\n33\t\tdouble res;\n34\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПосмотрите внимательно, в чём состоит отличие класса \u003ccode\u003eABSumma2\u003c/code\u003e от \u003ccode\u003eABSumma\u003c/code\u003e. Во-первых, в классе \u003ccode\u003eABSumma2\u003c/code\u003e появилось поле с именем \u003ccode\u003eres\u003c/code\u003e (строка 33). К полю можно обращаться из любого метода, и это используется как в методе \u003ccode\u003esolve()\u003c/code\u003e (строка 24; в переменную \u003ccode\u003eres\u003c/code\u003e сразу же записывается результат вычислений), так и в методе \u003ccode\u003eprint()\u003c/code\u003e (строка 28; переменная \u003ccode\u003eres\u003c/code\u003e сразу же печатается). \u003cbr /\u003e Поскольку методу \u003ccode\u003esolve()\u003c/code\u003e нет необходимости возвращать значение, то в качестве типа этого метода теперь указан \u003cstrong\u003evoid\u003c/strong\u003e. \u003c/p\u003e\u003cp\u003eМетод \u003ccode\u003emain()\u003c/code\u003e класса \u003ccode\u003eAplusB2\u003c/code\u003e по сравнению с методом \u003ccode\u003emain()\u003c/code\u003e класса \u003ccode\u003eAplusB\u003c/code\u003e также претерпел изменения: перед строкой 08 (вызовом метода \u003ccode\u003eprint()\u003c/code\u003e) появилась строка 07 — вызов метода \u003ccode\u003esolve()\u003c/code\u003e. Если не выполнить вызов метода \u003ccode\u003esolve()\u003c/code\u003e \u003cem\u003eперед\u003c/em\u003e методом \u003ccode\u003eprint()\u003c/code\u003e, то в качестве ответа при любых значениях \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e будет напечатано 0.0.\u003c/p\u003e\u003cp\u003e\u003cem\u003eПо умолчанию все переменные, которым ещё не присвоено никакого значения, считаются установленными в 0 в смысле того типа, к которому они относятся. Если переменная целая — её значением будет считаться 0, если вещественная — 0.0, если булева — \u003ccode\u003efalse\u003c/code\u003e.\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e","tags":["структура программы","для начинающих","java"]}}