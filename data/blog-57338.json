{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1516933280,"rating":38,"authorHandle":"Malomalomalomalo","modificationTimeSeconds":1517021534,"id":57338,"title":"\u003cp\u003eUnderstanding Disjoint Set Structures\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eAgain, Im writing this both to help others and test myself so I will try to explain everything at a basic level. Any feedback is appreciated.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eDisjoint Set(DS) data structures are representations of sets (which are all disjoint, sharing no elements) with certain functions:\u003c/p\u003e\u003cp\u003eFindSet(x): finds the set of element x\u003cbr /\u003e UniteSets(x,y): unites the sets x and y\u003cbr /\u003e MakeSet(x): makes a set with element x\u003cbr /\u003e \u003cstrong\u003e\u003cem\u003eDisunion(list)\u003c/em\u003e\u003c/strong\u003e: removes all elements from other sets and makes a new set with these elements\u003cbr /\u003e (Note: the disunion operation is not as commonly used as the other operations and is not implemented efficiently, with an O(n) runtime.)\u003c/p\u003e\u003cp\u003eDS is used in various algorithms, such as Kruskal\u0027s minimum spanning tree finder.\u003c/p\u003e\u003cp\u003eThis post will proceed with a naive implementation, and then progress to an efficient solution.\u003c/p\u003e \u003ch2\u003eThe Naive Solution\u003c/h2\u003e\u003cp\u003eWe construct a forest (group of disjoint trees). Each element has a parent node and a list of children. (The list of children can be omitted if we are not intending to disunite sets.)\u003c/p\u003e\u003cp\u003eDefine P(x): a function which maps an element to its \u0026quot;parent\u0026quot; element. In each set there will be exactly one parent, and P(parent) \u003d parent, this is how a set is referred to.\u003c/p\u003e\u003cp\u003eEach element e starts as being in its own set, with P(e)\u003de. We can make an element easily with this element, and we can unite two sets X,Y with the following method.\u003c/p\u003e\u003cp\u003eGiven two elements x,y, iterate P on each until P(x)\u003dx, P(y)\u003dy. Then set P(x)\u003dy and add x to y\u0027s children. Now all elements that were children of x are children of y, so we have successfully united the two sets.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"img1\" src\u003d\"/predownloaded/64/57/6457b58f5857706a3710bf786f6cecfb12abf3ae.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eTo disunite two sets, iterate through every node N (from farthest from root to root) that we are intending to breakaway. Change P of N\u0027s children to P(N) unless N\u003dP(N) and N has more than one child or P(N) is going to be removed as well. If N\u003dP(N)\u0026amp; N has more than one child (if it had one it could be removed with no consequence) instead make one of P(N)\u0027s children the root. (Make sure not to select a child that is going to be removed, if all children are going to be removed go one level deeper.) If P(N) is going to be moved, repeat the procedure for P(N), with all of N\u0027s children included under P(N). As every node is processed at most once, the runtime is O(N(cost of removing from children + cost of adding to children)+(cost of building the new set, or n^2)).\u003c/p\u003e\u003cp\u003eLets look at their runtimes:\u003cbr /\u003e FindSet : O(n), as in worst case the structure is a linked list.\u003cbr /\u003e UniteSets: O(n), as its runtime is determined by two FindSet calls.\u003cbr /\u003e MakeSet: O(1).\u003cbr /\u003e Disunion: O(n(cost of removing from children + cost of adding to children)+ n^2). Don\u0027t get too caught up memorizing the above algorithm, it is unwieldy and slow compared to the actual solution.\u003cbr /\u003e\u003c/p\u003e \u003ch2\u003eOptimization 1: Balanced Trees with log N height\u003c/h2\u003e\u003cp\u003eLooking at the first version of our DS one possible optimization becomes appearant. Our DS is a forest, so if all the trees were balanced, with a height of log N (something like a binary tree) then both FindSet and, as a result, UniteSets, will take O(log N) time.\u003c/p\u003e\u003cp\u003eAs we build our sets from singular elements, our tree structure is determined by UniteSets. This points to potentially editing UniteSets to improve our runtime. Instead of arbitarily combining two sets, we can be smarter. Notice the height of the resulting tree is max(height(x)+1,height(y)) as height(x) and height(y)-1 are the heights of the two subtrees of root y after unification. Looking at this equation we notice some inefficency, if height(x)\u0026gt;height(y) then the height of the resulting tree is greater than if x became the new root. Thus, if we choose the taller tree\u0027s root as the final root, we have a more efficent solution.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"img2\" src\u003d\"/predownloaded/0f/09/0f09077976b27ff972b8a086cd099d0e307e5223.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eIt turns out that this makes the tree\u0027s have a height of O(log N). Let the current maximum height of the whole DS be h. To increase h, we need to combine a tree with height h with another tree of height h (otherwise the max height wouldn\u0027t change.) Thus, a tree of height h+1 requires the sum of the elements in the trees of height h. Thus we get a recurrence, # of nodes in tree of height h+1 \u003d 2*# of nodes in tree of height h. As it takes 2^n nodes to form a tree of height n, the height of a tree with N nodes is log N.\u003c/p\u003e\u003cp\u003eLets look at the updated runtimes:\u003cbr /\u003e FindSet : O(log n), as in worst case the structure is a binary tree.\u003cbr /\u003e UniteSets: O(log n), as its runtime is determined by two FindSet calls.\u003cbr /\u003e MakeSet: O(1).\u003cbr /\u003e Disunion: O(n(cost of removing from children + cost of adding to children)).\u003cbr /\u003e\u003c/p\u003e \u003ch2\u003eOptimization 2: Path Compression\u003c/h2\u003e\u003cp\u003eThe runtimes with optimization 1 are pretty good (Disunion will always be O(n) at worst as removing n arbitrary nodes requires touching all n nodes), but can we make them better? With path compression, we can make them even faster (and decrease the memory needed.) However, this heuristic makes analyzing the runtimes kind of complicated based on what you are using the DS for.\u003c/p\u003e\u003cp\u003eThe inspiration for this optimization comes from inefficency in FindSet, namely that calling FindSet(x) with the same x multiple times still requires iterating up the tree. This inspires a dp solution, where we memoize the final parent of x. Then, realize that we kind of already do that with P. Instead of creating a seperate array, we can just update P.\u003c/p\u003e\u003cp\u003eWhen we do path compression we do just that, for every node n from x to the root, set P(n)\u003droot. That way, each of the nodes on the root are only 1 step from finding their parent. For these nodes FindSet becomes O(1).\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"img3\" src\u003d\"/predownloaded/32/4b/324b5a317afe8645c60b2a3aaa0451fd857dd961.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThe above image shows path compression after calling findSet(1).\u003c/p\u003e\u003cp\u003eWhen we unite this set with other sets the distance from these nodes to their root could increase again, and thus our O(1) time progressively becomes ruined. Regardless, allowing path compression results in a much flatter tree, and thus on average reduces the runtime.\u003c/p\u003e\u003cp\u003eNote that with path compression, we can improve our disunion algorithm. We no longer need to store the children of each node. To disunion, run FindSet on every node in order to compress every node. This makes every tree have a height of two. Removing most nodes is now trivial, as they are leaves. Removing the roots is a little harder, but this can be accomplished intelligently. After compressing all the nodes, we again look at every node, and if a we process a node that is not a root whose parent is being disunioned and a root, instead make the non-root node the new root. Then, all the trees have a root that is not being removed (unless the whole tree is being removed, in which case we don\u0027t have to worry about it). After compressing all the nodes again, all disunioned nodes can be removed trivially and heights can be recalculated.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"img4\" src\u003d\"/predownloaded/f9/69/f9695e146a61847575adced9fdabffee53dba7f1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eLets look at our final runtimes:\u003cbr /\u003e FindSet : O(α(n)) (This and UniteSets\u0027 worst case is the reverse Ackermann function, as uniting two sets with path compression shortens the trees every union. This is effectively constant.)\u003cbr /\u003e UniteSets: O(α(n))\u003cbr /\u003e MakeSet: O(1).\u003cbr /\u003e Disunion: O(n).\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eAll with O(n) space!\u003c/p\u003e \u003ch2\u003eImplementation\u003c/h2\u003e\u003cp\u003eThis implementation (especially disunion) isn\u0027t the most efficient/consise as readability has been emphasized. Also note that MakeSet has not been included as it doesn\u0027t even require a method proper, just setting par[x]\u003dx. All the methods function as described above. par[x]\u003d parent of x, rnk[x] \u003d height of x (aka rank of x, notice that by default a set of height h has a rnk of h-1). Disunion functions by removing all elements with rm[x]\u003d1, and setting their par to nroot. \u003c/p\u003e\u003cpre\u003e \u003ccode class\u003d\"prettyprint\"\u003e #include \u0026lt;bits/stdc++.h\u0026gt;\u003cbr /\u003e #define MAXN 100000\u003cbr /\u003e using namespace std;\u003cbr /\u003e int par[MAXN],rnk[MAXN],N;\u003cbr /\u003e bool rm[MAXN];\u003cbr /\u003e\u003cp\u003eint getPar(int x){\u003cbr /\u003e  if(par[x]\u003d\u003dx)return x;\u003cbr /\u003e  par[x]\u003dgetPar(par[x]);\u003cbr /\u003e  return par[x];\u003cbr /\u003e }\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eint unitePar(int x,int y){\u003cbr /\u003e  int p1\u003dgetPar(x),p2\u003dgetPar(y);\u003cbr /\u003e  if(rnk[p1]\u0026gt;rnk[p2]){\u003cbr /\u003e    par[p2]\u003dp1;\u003cbr /\u003e    rnk[p1]\u003drnk[p2]+1;\u003cbr /\u003e  }\u003cbr /\u003e  else{\u003cbr /\u003e    par[p1]\u003dp2;\u003cbr /\u003e    rnk[p2]\u003dmax(rnk[p2],rnk[p1]+1);\u003cbr /\u003e  }\u003cbr /\u003e }\u003cbr /\u003e\u003c/p\u003e\u003cp\u003evoid disunion(int nroot){\u003cbr /\u003e  int p;\u003cbr /\u003e  for(int i\u003d0;i\u0026lt;N;++i)getPar(i);\u003cbr /\u003e  for(int i\u003d0;i\u0026lt;N;++i){\u003cbr /\u003e   p\u003dgetPar(i);\u003cbr /\u003e   if(rm[p]\u0026amp;\u0026amp;!rm[i]){\u003cbr /\u003e    par[p]\u003di;\u003cbr /\u003e    par[i]\u003di;\u003cbr /\u003e   }\u003cbr /\u003e  }\u003cbr /\u003e  for(int i\u003d0;i\u0026lt;N;++i)getPar(i);\u003cbr /\u003e  for(int i\u003d0;i\u0026lt;N;++i){\u003cbr /\u003e   if(rm[i]){\u003cbr /\u003e    par[i]\u003dnroot;\u003cbr /\u003e    rm[i]\u003d0;\u003cbr /\u003e   }\u003cbr /\u003e  }\u003cbr /\u003e  memset(rnk,0,sizeof(rnk));\u003cbr /\u003e  for(int i\u003d0;i\u0026lt;N;++i){\u003cbr /\u003e   p\u003dgetPar(i);\u003cbr /\u003e   if(p!\u003di)rnk[p]\u003d1;\u003cbr /\u003e  }\u003cbr /\u003e }\u003cbr /\u003e \u003c/p\u003e\u003c/code\u003e \u003c/pre\u003e\u003cp\u003eEdit: fixed the final runtimes of findset and unitesets, thanks to farmersrice for pointing this out\u003c/p\u003e\u003c/div\u003e","tags":["#dsu","#tutorial","#implementation"]}}