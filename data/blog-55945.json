{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1511328497,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1514371171,"id":55945,"title":"\u003cp\u003eЗадачи на использование циклов — часть I (Обновлено!)\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eТеперь учимся применять циклы. Снова несколько простых задач с Timus (и некоторые советы по их решению), немного теории и пример решения задачи. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eСписок задач\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗадача 1991 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1991\"\u003eБитва у болота\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЗадача 1607 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1607\"\u003eТакси\u003c/a\u003e (можно и без циклов)\u003c/p\u003e\u003cp\u003eЗадача 1131 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1131\"\u003eКопирование\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЗадача 1502 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1502\"\u003eТочки домино\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЗадача 1139 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1139\"\u003eГородские кварталы\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eНекоторые небесполезные советы\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eРешения первой и второй задачи выглядят весьма прямолинейно. А вот третья, четвёртая и пятая наверняка потребуют \u0026quot;размышлений на листочке\u0026quot;. \u003c/p\u003e\u003cp\u003eЕсли пытаться \u0026quot;пошагово воспроизвести процесс копирования\u0026quot; в задаче 1131, можно легко получить вердикт \u003cem\u003eTime Limit on test ...\u003c/em\u003e, свидетельствующий о том, что ваш алгоритм работает чересчур долго. Так что попробуйте сначала представить процесс \u0026quot;на бумаге\u0026quot;, понять, что он делится на две стадии, и каждая из этих стадий должна быть описана отдельно.\u003c/p\u003e\u003cp\u003eПри решении задачи 1502 полезно вывести некоторые формулы и воспользоваться ими (конечно, велик соблазн заставить компьютер считать всё, но об эффективности программы забывать не стоит). И ещё вам определённо понадобится использовать \u003ccode\u003elong\u003c/code\u003e вместо \u003ccode\u003eint\u003c/code\u003e для хранения ответа (числа могут оказаться слишком большими).\u003c/p\u003e\u003cp\u003eА при решении задачи 1139 вам определённо может пригодиться описанный ниже алгоритм.\u003c/p\u003e\u003cp\u003eДля двух целых чисел \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e можно определить их наибольший общий делитель. Его обозначают либо \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eGCD\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e (от \u003cem\u003eGreat Common Divisor\u003c/em\u003e), либо \u003cem\u003eНОД(a,b)\u003c/em\u003e (сокращая русское название до аббревиатуры). Для вычисления \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eGCD\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e обычно используют алгоритм Евклида. Если вдруг вы забыли его, напомним, что состоит он в следующем. \u003cbr /\u003e 1. Если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, ответом является любое из этих чисел. Если одно из чисел равно нулю, ответом является другое число. \u003cbr /\u003e 2. Если же это не так, выберем большее из этих чисел (пусть это будет \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, иначе — поменяем числа местами). Сделаем замену: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/18/1a/181a0fa9a73e079340b421e100ce716ec77ffaeb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (где \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ef/a8/efa8f0891cb15bc0e4b503f090f6c8d8b1d9d6b4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e — взятие остатка от деления). После этого вернёмся к п.1.\u003c/p\u003e\u003cp\u003eКонечно, можно найти наибольший общий делитель и другими способами, но этот, пожалуй, наиболее эффективен. \u003c/p\u003e\u003cp\u003eПодумайте, как доказать, что это корректный способ вычисления наибольшего общего делителя. Если не очень получается, можно прочитать про этот алгоритм в Википедии или \u003ca href\u003d\"http://e-maxx.ru/algo/euclid_algorithm\"\u003eздесь\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eИ ещё один совет — если какая-то задача (кроме первой) долго не получается, попробуйте порешать задачи из части II — некоторые из них могут оказаться проще (сложность задачи — это весьма субъективная величина).\u003c/p\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCинтаксис циклических операторов\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eПростой \u003cstrong\u003e\u003ci\u003eцикл с предусловием\u003c/i\u003e\u003c/strong\u003e выглядит так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003ewhile (\u0026lt;условие\u0026gt;) {\n   \u0026lt;операторы\u0026gt;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eУсловие — это логическое выражение, т.е. оно может принимать значение \u003ccode\u003etrue\u003c/code\u003e или \u003ccode\u003efalse\u003c/code\u003e. Обратите внимание, что условие обязательно заключать в круглые скобки, а каждый оператор должен завершаться точкой с запятой. Если оператор один, то фигурные скобки можно не писать (это относится и к другим циклам, которые описаны ниже).\u003c/p\u003e\u003cp\u003eКак работает этот цикл? \u003cbr /\u003e 1. Выполняется проверка условия. \u003cbr /\u003e 2. Если условие истинно (\u003ccode\u003etrue\u003c/code\u003e), то выполняются записанные в теле цикла операторы. Когда будут выполнены все операторы, возвращаемся к п.1. Если условие ложно (\u003ccode\u003efalse\u003c/code\u003e), то осуществляется переход к оператору, следующему непосредственно за циклом.\u003c/p\u003e\u003cp\u003eПрактический вывод из этого описания состоит в том, что в теле цикла должны присутствовать операторы, меняющие условие цикла (иначе цикл будет работать бесконечно, а в большинстве случаев это не нужно).\u003c/p\u003e\u003cp\u003eИногда бывает удобно выполнять первую итерацию цикла без проверки условия. В этом случае может оказаться полезен \u003cstrong\u003e\u003ci\u003eцикл с постусловием\u003c/i\u003e\u003c/strong\u003e. Он выглядит так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003edo {\n   \u0026lt;операторы\u0026gt;\n}\nwhile (\u0026lt;условие\u0026gt;) \n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКак работает этот цикл? \u003cbr /\u003e 1. Выполняются операторы, записанные в теле цикла. \u003cbr /\u003e 2. Выполняется проверка условия. Если условие истинно (\u003ccode\u003etrue\u003c/code\u003e), то возвращаемся к п.1. Если условие ложно (\u003ccode\u003efalse\u003c/code\u003e), то осуществляется переход к оператору, следующему непосредственно за циклом.\u003c/p\u003e\u003cp\u003eЕщё один цикл с предусловием — цикл \u003ccode\u003efor\u003c/code\u003e. Он имеет более сложную структуру, нежели \u003ccode\u003ewhile\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003efor (\u0026lt;секция инициализации\u0026gt;; \u0026lt;условие\u0026gt;; \u0026lt;секция итерации\u0026gt;){\n    \u0026lt;операторы\u0026gt;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eУсловие имеет тот же смысл, что и в предыдущих циклах. \u003c/p\u003e\u003cp\u003eСекция инициализации может содержать операторы присваивания значений каким-либо переменным, которые могут быть совмещены с объявлениями этих переменных. Если переменные объявлены в секции инициализации, то по завершении цикла они прекратят свое существование. В частности, это означает, что имена переменных можно будет использовать повторно — однако лучше не злоупотреблять такой возможностью. Вполне допустимо, например, использовать \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e или \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e в качестве счётчиков в нескольких независимых циклах. \u003c/p\u003e\u003cp\u003eСекция итерации может содержать операторы присваивания, изменяющие какие-либо переменные. \u003c/p\u003e\u003cp\u003eЕсли секции инициализации и итерации содержат несколько операторов присваивания, они разделяются запятыми. (На самом деле есть ряд тонких моментов, но представляется, что на этапе первого знакомства с циклами их можно опустить).\u003c/p\u003e\u003cp\u003eЛюбая из секций цикла \u003ccode\u003efor\u003c/code\u003e может быть пустой (причём пустыми могут быть и две, и даже все три секции одновременно). Однако точки с запятыми при этом всё равно должны ставиться (они разграничивают секции и потому необходимы). \u003c/p\u003e\u003cp\u003eЦикл \u003ccode\u003efor\u003c/code\u003e работает следующим образом: \u003cbr /\u003e 0. Однократно выполняются операторы секции инициализации (если есть). \u003cbr /\u003e 1. Проверяется условие. Если оно истинно, то выполняются операторы тела цикла, если же ложно — цикл завершается, управление передается оператору, следующему за циклом. \u003cbr /\u003e 2. После выполнения операторов тела цикла выполняются операторы секции итерации (если есть). После этого происходит переход к п.1\u003c/p\u003e\u003cp\u003eВажно отметить, что работа всех циклов описана в предположении, что в теле цикла нет операторов \u003ccode\u003ebreak\u003c/code\u003e или \u003ccode\u003econtinue\u003c/code\u003e, которые меняют \u0026quot;естественный ход\u0026quot; цикла. Оператор \u003ccode\u003ebreak\u003c/code\u003e прерывает исполнение цикла в том месте, где он записан; управление передается оператору, следующему за циклом. Оператор \u003ccode\u003econtinue\u003c/code\u003e прерывает текущую итерацию цикла и передает управление в заголовок цикла. \u003c/p\u003e\u003cp\u003eИ оператор \u003ccode\u003ebreak\u003c/code\u003e, и оператор \u003ccode\u003econtinue\u003c/code\u003e могут использоваться вместе с \u003cem\u003eметкой\u003c/em\u003e. Метка — это некоторая последовательность символов, подчиняющаяся тем же правилам, что и имя переменной. Метка может быть расположена перед заголовком какого-либо цикла. В этом случае, если после \u003ccode\u003ebreak\u003c/code\u003e будет указана эта же метка, то прерван будет именно этот цикл. Если же метка будет указана после \u003ccode\u003econtinue\u003c/code\u003e, то, соответственно, управление будет передано именно в этот заголовок цикла. Общее правило состоит в том, что передавать управление можно только изнутри наружу — т.е. оператор \u003ccode\u003ebreak\u003c/code\u003e или \u003ccode\u003econtinue\u003c/code\u003e, используемый с меткой, должен находиться внутри того цикла, который отмечен меткой (например, допустимо, чтобы оператор \u003ccode\u003ebreak\u003c/code\u003e находился внутри цикла, вложенного в другой цикл, и прерывал именно этот другой цикл). \u003c/p\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eПример решения задачи\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eВ этом разделе циклы используются в разных ситуациях. Одной из типичных ситуаций является необходимость обработки данных при вводе, и сначала мы рассмотрим достаточно простую задачу, иллюстрирующую такую ситуацию.\u003c/p\u003e\u003cp\u003eНо сначала — совет, который, возможно, покажется вам странным. \u003c/p\u003e\u003cp\u003eПрочтите условие задачи и пролистайте этот длинный текст до того места, где приводится решение целиком. Вы уже достаточно знакомы с синтаксисом, чтобы прочесть его. Если решение кажется вам понятным, попробуйте написать решение самой первой задачи из списка. Если решение не показалось понятным или же не получается написать решение первой задачи — тогда приступайте к чтению текста. В тексте явно выделены три подзадачи, так что если вам непонятна только одна из них, попробуйте сначала прочесть фрагмент текста, относящийся непосредственно к ней. \u003c/p\u003e\u003cp\u003eКогда будете читать текст, не надо стремиться запомнить все эти пространные рассуждения. Вполне достаточно понять, почему программа написана именно таким образом. Если какие-то моменты стали понятными — нет ничего плохого в том, чтобы пропустить какие-то абзацы. Этот текст в значительной мере является \u0026quot;сборником\u0026quot; ответов на вопросы начинающих программистов, и не все эти вопросы возникнут у вас. Однако если они всё-таки возникнут, есть надежда, что вы сможете найти ответ в нижеследующем рассказе. Ну а если не сможете — задавайте вопросы в комментариях или личных сообщениях.\u003c/p\u003e\u003cp\u003eКонечно, если вас не пугают длинные тексты, да и просто есть настроение — читайте всё подряд. Но помните, что научиться решать задачи можно только решая задачи, а не читая про то, как их надо решать.\u003c/p\u003e\u003cp\u003e\u003ci\u003eЗадача \u0026quot;О решении задач\u0026quot;\u003c/i\u003e\u003c/p\u003e\u003cp\u003eКеша готовился к экзамену в течение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e дней. Каждый день он записывал количество задач, которое ему удалось решить. Теперь у него есть последовательность чисел \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e , и он хочет узнать, во-первых, сколько всего задач он решил, во-вторых, максимальное количество задач, которое он смог решить за один день, и, в-третьих, количество дней, в которые он решал максимальное количество задач.\u003c/p\u003e\u003cp\u003e\u003ci\u003eВходные данные\u003c/i\u003e\u003c/p\u003e\u003cp\u003eВ первой строке содержится целое число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(1 ≤ \u003ci\u003en\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e)\u003c/span\u003e — количество дней, в течение которых Кеша готовился к экзамену. \u003c/p\u003e\u003cp\u003eВо второй строке содержится \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e целых чисел \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(0 ≤ \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ 1000, \u003ci\u003ei\u003c/i\u003e \u003d 1, 2, ..., \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — количество решённых в день \u003cspan class\u003d\"tex-span\"\u003e#\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e задач.\u003c/p\u003e\u003cp\u003e\u003ci\u003eВыходные данные\u003c/i\u003e\u003c/p\u003e\u003cp\u003eВыведите целые числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e — общее количество решённых задач, максимальное количество задач, которое удалось решить Кеше в течение одного дня, и количество дней, в которые он решал максимальное количество задач.\u003c/p\u003e\u003cp\u003e\u003cem\u003eРешение\u003c/em\u003e\u003c/p\u003e\u003cp\u003eОпишем постановку задачи чуть более формально. Для последовательности целых неотрицательных чисел \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e нужно посчитать сумму элементов, найти максимальный элемент и посчитать, сколько раз максимальный элемент встречается в последовательности.\u003c/p\u003e\u003cp\u003eМы будем писать программу \u0026quot;по частям\u0026quot;: сначала научимся подсчитывать сумму элементов, затем дополним программу так, чтобы находить максимальный элемент, а уже после этого будем решать задачу подсчёта количества максимальных элементов. Такой подход использован из \u0026quot;методических\u0026quot; соображений, чтобы по отдельности пояснить каждое из действий. Если вы чётко представляете себе каждое из действий, нет необходимости писать программу \u0026quot;в несколько проходов\u0026quot;. \u003c/p\u003e\u003cp\u003eСоздайте новый проект с названием \u003ccode\u003eproblemssolving\u003c/code\u003e, в нём — класс \u003ccode\u003eProblemsSolving\u003c/code\u003e (он будет \u0026quot;запускающим\u0026quot;). Не забудьте поставить галочку, автоматически формирующую в классе функцию \u003ccode\u003emain()\u003c/code\u003e. Также можно удалить имя пакета в строке \u003ccode\u003ePackage\u003c/code\u003e (если не удалите — ничего страшного, эту задачу мы не будем сдавать в проверяющие системы, а при локальной работе нет разницы, работаете вы с именованным пакетом или с пакетом по умолчанию). \u003c/p\u003e \u003cpre\u003e\u003ccode\u003epublic class ProblemsSolving {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eСледующий шаг — создание класса, содержащего \u0026quot;логику\u0026quot;. Назовите его \u003ccode\u003eProblemsDay\u003c/code\u003e. Входные данные — целое число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e и последовательность из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e чисел \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Поскольку \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e заранее неизвестно и может быть велико (до \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e), то объявить такое количество переменных \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e нереально (да и бессмысленно). \u003cbr /\u003e \u003cem\u003eЕсли вы изучали программирование на каком-либо другом языке, то можете предположить, что здесь была бы уместна структура данных, способная хранить перенумерованный набор элементов (обычно такая структура называется \u0026quot;массив\u0026quot; или \u0026quot;список\u0026quot;). Но, во-первых, мы ещё не изучали такие структуры данных в Java, и, во-вторых, как мы увидим из решения, нет необходимости хранить все элементы последовательности.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eПоэтому в классе мы опишем только переменную \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, а работу с последовательностью данных обсудим чуть позже. Выходными данными будут три целых числа, и такие переменные мы тоже опишем в классе. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003epublic class ProblemsSolving {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass ProblemsDay {\n\t\n\t\n\tint n;\n\tint s;\n\tint z;\n\tint d;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003csmall\u003e \u003cem\u003e\u003cb\u003eЗамечание\u003c/b\u003e\u003c/em\u003e. \u003c/small\u003e \u003cbr /\u003e \u003csmall\u003e Мы пока не слишком много внимания уделяли типам данных: если целое — значит,\u003ccode\u003eint\u003c/code\u003e, если вещественное — \u003ccode\u003edouble\u003c/code\u003e, если строка — \u003ccode\u003eString\u003c/code\u003e, если булево значение — \u003ccode\u003eboolean\u003c/code\u003e (кажется, его и вовсе ещё не использовали). Впрочем, задачи были подобраны таким образом, чтобы задумываться об этом не приходилось. Однако тип данных с точки зрения компьютера — это ещё и количество байтов, которое отводится для его записи. Для записи величины типа \u003ccode\u003eint\u003c/code\u003e отводится 4 байта, поэтому \u0026quot;без потерь\u0026quot; могут быть записаны числа примерно от \u003cspan class\u003d\"tex-span\"\u003e - 2·10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e до \u003cspan class\u003d\"tex-span\"\u003e2·10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e (от \u003cspan class\u003d\"tex-span\"\u003e - 2147483648\u003c/span\u003e до \u003cspan class\u003d\"tex-span\"\u003e2147483647\u003c/span\u003e, если точно). \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e В этой задаче нужно посчитать общее количество решённых задач. Чтобы понять, какое максимальное число может получиться в ответе, предположим, что Кеша решал задачи в течение максимально возможного по условию количества дней \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e, при этом каждый день он решал максимально возможное по условию количество задач, т.е. все \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e были равны \u003cspan class\u003d\"tex-span\"\u003e1000\u003c/span\u003e. В этом случае \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e8\u003c/sup\u003e\u003c/span\u003e, что вполне помещается в тип \u003ccode\u003eint\u003c/code\u003e, и, значит, его можно использовать. Если бы условие допускало, например, что Кеша может решать до \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e задач в день, то мы получили бы верхнюю оценку для \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e10\u003c/sup\u003e\u003c/span\u003e. Такое число не может быть корректно записано в типе \u003ccode\u003eint\u003c/code\u003e, и нужно было бы использовать тип \u003ccode\u003elong\u003c/code\u003e. \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Этот вопрос более подробно обсуждается в записи \u0026quot;Как решать задачи: несколько рекомендаций — часть 2\u0026quot; в разделе \u0026quot;Анализ ограничений\u0026quot;. \u003c/small\u003e\u003c/p\u003e\u003cp\u003eДля ввода данных мы, как и всегда, будем использовать объект класса \u003ccode\u003eScanner\u003c/code\u003e. Однако теперь мы опишем его в классе, а не в конструкторе, как раньше. Дело в том, что этот объект понадобится нам не только в конструкторе, но и в методе \u003ccode\u003esolve()\u003c/code\u003e, поскольку чтение и обработку последовательности \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e мы будем выполнять именно в этом методе. Создавать объект мы по-прежнему будем в конструкторе, а вот завершать работу с ним — в конце метода \u003ccode\u003esolve()\u003c/code\u003e. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass ProblemsDay {\n\t\n\tProblemsDay() {\n\t\tin \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t}\n\t\n\tvoid solve() {\n\t\t\n\t\tin.close();\n\t}\n\t\n\t\n\tScanner in;\n\t\n\tint n;\n\tint s;\n\tint z;\n\tint d;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТеперь обсудим, как организовать \u003cem\u003e\u003cb\u003eподсчёт общего количества решённых задач\u003c/b\u003e\u003c/em\u003e. \u003c/p\u003e\u003cp\u003eКак действовал бы человек, если бы ему последовательно называли какие-то числа, сказав, что в конце спросят их общую сумму? Конечно, он не пытался бы запомнить их все и только потом сложить. Он запомнил бы первое число; затем, когда ему назвали бы второе — прибавил бы второе к первому и запомнил бы сумму. Первое число после этого помнить ему уже не нужно. Точно так же он поступил бы, когда ему назвали бы третье число: прибавил бы его к сумме первого и второго и запомнил бы результат. \u003c/p\u003e\u003cp\u003eМожно сказать, что для каждого очередного числа последовательность действий выглядит следующим образом: \u003cbr /\u003e \u003cem\u003eуслышал очередное число — прибавил это число к уже имеющейся сумме — запомнил результат\u003c/em\u003e \u003cbr /\u003e После того как все \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e чисел будут названы, их сумма будет известна. \u003c/p\u003e\u003cp\u003eЕдинственный момент, который требует небольшой коррекции, — в нашем пояснении человек запоминал первое число, а не прибавлял его к уже имеющейся сумме. Чтобы действия с первым числом не отличались от действий со всеми остальными числами, мы можем считать, что исходно имеющаяся сумма была равна нулю (добавление нуля к любому числу не изменит это число). \u003c/p\u003e\u003cp\u003eКак, наверное, понятно, имеющейся суммой в нашем случае будет переменная \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, а \u0026quot;услышал число\u0026quot; будет означать, что мы прочитали очередное введённое с клавиатуры число.\u003c/p\u003e\u003cp\u003eДля записи повторяющихся действий воспользуемся циклом \u003ccode\u003efor\u003c/code\u003e. Поскольку изменения вносились только в метод \u003ccode\u003esolve()\u003c/code\u003e, приведён только его код. Ниже (после фрагмента программы) — подробные пояснения записи.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tvoid solve() {\n\t\ts \u003d 0;\n\t\tfor (int i \u003d 1; i \u0026lt;\u003d n; i++) {\n\t\t\tint p \u003d in.nextInt();\n\t\t\ts \u003d s + p;\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eИтак, \u003ccode\u003es \u003d 0\u003c/code\u003e — это как раз отражение того факта, что исходно имеющаяся сумма должна быть равна нулю. Далее записан оператор цикла \u003ccode\u003efor\u003c/code\u003e. В его секции инициализации объявляется переменная \u003ccode\u003ei\u003c/code\u003e: \u003ccode\u003eint i \u003d 1\u003c/code\u003e. Эта переменная будет выполнять роль индекса для переменной \u003ccode\u003ep\u003c/code\u003e, а по завершении цикла прекратит своё существование. Секция условия показывает, что цикл будет выполняться, пока значение \u003ccode\u003ei\u003c/code\u003e будет оставаться в пределах отрезка \u003ccode\u003e[1..n]\u003c/code\u003e. Секция итерации содержит оператор инкремента, увеличивающий значение \u003ccode\u003ei\u003c/code\u003e на единицу. \u003c/p\u003e\u003cp\u003eВообще говоря, условия, содержащие \u0026quot;составной знак\u0026quot; (\u003ccode\u003e\u0026lt;\u003d\u003c/code\u003e) считаются менее удачным решением, чем условия, содержащие \u0026quot;простой\u0026quot; знак. Поэтому во многих руководствах по программированию (и по стилю кода) рекомендуют при возможности использовать именно знаки \u003ccode\u003e\u0026lt;\u003c/code\u003e и \u003ccode\u003e\u0026gt;\u003c/code\u003e вместо \u003ccode\u003e\u0026lt;\u003d\u003c/code\u003e и \u003ccode\u003e\u0026gt;\u003d\u003c/code\u003e. В нашей программе мы могли бы, например, написать так: \u003ccode\u003ei \u0026lt; n+1\u003c/code\u003e. Однако вряд ли это хороший подход: рекомендации не использовать составные знаки обосновывают именно тем, что знак \u003ccode\u003e\u003d\u003c/code\u003e можно забыть поставить. Но точно так же можно забыть поставить и \u003ccode\u003e+1\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eВпрочем, есть способ сделать всё \u0026quot;красиво\u0026quot;: нужно начать нумерацию с 0. Тогда последний элемент будет иметь номер не \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, а \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e, и условие можно будет записать как \u003ccode\u003ei \u0026lt; n\u003c/code\u003e. Конечно, поначалу это может выглядеть непривычно, но в очень многих языках программирования нумерацию элементов принято начинать с нуля. Поэтому немного отредактируем написанное.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tvoid solve() {\n\t\ts \u003d 0;\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\t\tint p \u003d in.nextInt();\n\t\t\ts \u003d s + p;\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eИ, конечно, продолжим обсуждение цикла \u003ccode\u003efor\u003c/code\u003e. Напомним, что в цикле сначала единожды выполняется секция итерации — в нашем случае объявляется переменная \u003ccode\u003ei\u003c/code\u003e, которой при объявлении сразу же присваивается нулевое значение. Затем повторяется следующий набор действий: \u003cem\u003eпроверка условия — операторы тела цикла — секция итерации\u003c/em\u003e — до тех пор, пока условие выполняется. Когда оно перестанет выполняться, программа переходит к оператору, следующему за циклом (в нашем случае это \u003ccode\u003ein.close()\u003c/code\u003e).\u003c/p\u003e\u003cp\u003eВ теле цикла сейчас у нас записаны (пока) два оператора. Первый из них, \u003ccode\u003eint p \u003d in.nextInt()\u003c/code\u003e, объявляет целочисленную переменную \u003ccode\u003ep\u003c/code\u003e и сразу же присваивает ей значение, прочитанное из входного потока данных объектом \u003ccode\u003ein\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eЧтобы понять, как это работает, представьте себе, что все числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e записаны подряд на полоске бумаги. По этой полоске бумаги двигается \u0026quot;окошко\u0026quot; (вы наверняка видели календари, в которых текущее число выделяется перемещаемой пластиковой рамкой). Метод \u003ccode\u003enextInt()\u003c/code\u003e каждый раз перемещает окошко на один \u0026quot;шаг\u0026quot; — на следующее число. \u003c/p\u003e\u003cp\u003eНа первой итерации цикла сначала будет выполнена проверка условия \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Поскольку \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u003d 0\u003c/span\u003e, а \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e по условию должно быть равно хотя бы \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, первая итерация будет выполняться всегда. После проверки условия управление будет передано телу цикла. \u003c/p\u003e\u003cp\u003eВ теле цикла будет создана переменная \u003ccode\u003ep\u003c/code\u003e, и в неё будет записано значение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e. Создание переменной подразумевает выделение памяти для хранения её значения и назначение имени этой области памяти. Мы уже упоминали, что переменная типа \u003ccode\u003eint\u003c/code\u003e нуждается в 4 байтах памяти для хранения значения. Поэтому будет выделена область памяти размером 4 байта, которой будет назначено имя \u003ccode\u003ep\u003c/code\u003e. Однако это имя будет привязано именно к этой области памяти только на этой итерации цикла. Это отвечает нашему описанию человека, суммирующего числа: услышав очередное число, он помнит его — но лишь до тех пор, пока не прибавит его к имеющейся сумме. Дальше ему достаточно помнить только результат. \u003c/p\u003e\u003cp\u003eКогда очередное значение из входного потока прочитано, нужно прибавить его к (уже имеющейся сумме) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e. Это делает оператор \u003ccode\u003es \u003d s + p\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eНапомним (на всякий случай), как работает оператор присваивания. Сначала вычисляется адрес области памяти, в которую должен быть помещён результат. Этот адрес вычисляется по имени \u003ccode\u003es\u003c/code\u003e, с которым связана область памяти. Затем вычисляется значение выражения в правой части оператора присваивания: происходит обращение сначала к области памяти, связанной с именем \u003ccode\u003es\u003c/code\u003e, и чтение значения, записанного в этой области; затем происходит обращение к области памяти, связанной с именем \u003ccode\u003ep\u003c/code\u003e, и чтение значения, записанного в этой области. После чего прочитанные значения складываются (на этом этапе задействованы регистры процессора, именно в них временно хранится результат), и результат помещается по адресу, вычисленному на первом этапе. Поскольку адрес результата связан с переменной \u003ccode\u003es\u003c/code\u003e, прежнее значение, которое там было (до сложения) затирается, а на его место записывается новое значение. \u003c/p\u003e\u003cp\u003eБольше в теле цикла операторов нет, и управление переходит к секции итерации. Значение переменной \u003ccode\u003ei\u003c/code\u003e увеличивается на 1 и становится равным 1. На этом первая итерация завершена. \u003c/p\u003e\u003cp\u003eВторая (и любая последующая) итерация будет отличаться от первой лишь тем, что в создаваемую переменную \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e будет прочитываться уже не \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, а \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e (или другое значение, соответствующее номеру итерации). И, конечно, в какой-то момент значение i станет равным \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, после чего условие \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003en\u003c/i\u003e\u003c/span\u003e перестанет выполняться. Цикл завершится, а в переменной \u003ccode\u003es\u003c/code\u003e будет храниться общее количество решённых Кешей задач.\u003c/p\u003e\u003cp\u003eРассмотрим, как работает написанный нами цикл, на примере. Пусть входные данные таковы (Кеша решал задачи в течение 8 дней, во второй строке приведено количество решённых задач для каждого из дней):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e8\n4 2 4 7 5 7 7 3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВероятно, проще всего составить таблицу пошаговой трассировки. Обратите внимание, что мы указываем значение переменной \u003ccode\u003ei\u003c/code\u003e в начале итерации; после выполнения тела цикла выполняется ещё и оператор из секции итерации, увеличивающий значение \u003ccode\u003ei\u003c/code\u003e на 1.\u003c/p\u003e \u003ctable\u003e   \u003ctbody\u003e\u003ctr\u003e     \u003cth\u003e Номер итерации \u003c/th\u003e     \u003cth\u003e i \u003c/th\u003e     \u003cth\u003e p \u003c/th\u003e     \u003cth\u003e s \u003c/th\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e До цикла \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e 0 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 1 \u003c/td\u003e     \u003ctd\u003e 0 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 2 \u003c/td\u003e     \u003ctd\u003e 1 \u003c/td\u003e     \u003ctd\u003e 2 \u003c/td\u003e     \u003ctd\u003e 6 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 3 \u003c/td\u003e     \u003ctd\u003e 2 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 10 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 3 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 17 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 5 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 5 \u003c/td\u003e     \u003ctd\u003e 22 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 6 \u003c/td\u003e     \u003ctd\u003e 5 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 29 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 6 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 36 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 8 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 3 \u003c/td\u003e     \u003ctd\u003e 39 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e После цикла \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e 39 \u003c/td\u003e   \u003c/tr\u003e  \u003c/tbody\u003e\u003c/table\u003e\u003cp\u003eВ конце последней, восьмой, итерации значение \u003ccode\u003ei\u003c/code\u003e станет равным 8, и условие цикла \u003ccode\u003ei \u0026lt; n\u003c/code\u003e при \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 8\u003c/span\u003e перестанет выполняться. \u003c/p\u003e\u003cp\u003eСледует отметить, что значения в столбце \u0026quot;Номер итерации\u0026quot;, вообще говоря, излишни: их можно заменить значениями \u003ccode\u003ei\u003c/code\u003e (пусть и отличающимися на 1, но что мешает установить нумерацию итераций с 0?).\u003c/p\u003e\u003cp\u003eПеред тем как перейти к поиску максимума, напишем метод \u003ccode\u003eprint()\u003c/code\u003e: действительно, суммарное количество задач мы уже можем вывести.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tvoid solve() {\n\t\ts \u003d 0;\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\t\tint p \u003d in.nextInt();\n\t\t\ts \u003d s + p;\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tvoid print() {\n\t\tSystem.out.println(s);\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eСледующая подзадача, которую мы будем решать — поиск в последовательности максимального элемента или, в терминах задачи, \u003cem\u003e\u003cb\u003eпоиск максимального количества задач, решённых в течение одного дня\u003c/b\u003e\u003c/em\u003e. \u003c/p\u003e\u003cp\u003eВажный момент — мы не можем прочитать входные данные (или их часть) ещё раз. Это означает, что для поиска максимального элемента в последовательности нам придётся воспользоваться уже написанным циклом \u003ccode\u003efor\u003c/code\u003e, дополнив его тело соответствующими операторами. Конечно, какие-то операторы понадобится добавить до цикла.\u003c/p\u003e\u003cp\u003eКак и в предыдущий раз, попробуем представить себе действия человека, которому последовательно называют некоторые числа, предупредив, что в конце он должен сообщить максимальное из названных чисел. \u003c/p\u003e\u003cp\u003eКогда человеку называют первое число, он запомнит его, и будет считать максимальным — среди всех названных. Когда человеку называют второе число — он сравнит его с первым и запомнит большее из них. Точно так же он будет поступать и со всеми последующими числами. Т.е. его действия можно описать так: \u003cem\u003eуслышал очередное число — сравнил с максимальным среди названных ранее — запомнил максимальное из двух сравниваемых\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eИ вновь нам нужно скорректировать описанную последовательность действий так, чтобы она работала и для первого названного числа. Получается, что человек должен \u0026quot;помнить\u0026quot; какое-то число, которое гарантированно меньше, чем первое названное число — потому что ему нужно будет выбрать максимум из этих двух чисел, и этим максимумом должно оказаться именно первое названное число. \u003c/p\u003e\u003cp\u003eПо условию задачи \u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ 1000\u003c/span\u003e, так что в качестве исходного значения максимума нам подойдёт любое отрицательное число. \u003c/p\u003e\u003cp\u003e\u003csmall\u003e Вообще говоря, можно использовать в качестве исходного значения максимума и 0, но у отрицательного числа есть важное преимущество. Если в качестве ответа мы получим 0, это может просто означать, что Кеша не решил ни одной задачи за весь срок подготовки к экзамену (что в принципе возможно). А вот если в качестве ответа мы получим отрицательное число, это будет свидетельствовать, что наша программа не выполнила поиск максимума. Похожий подход — инициализировать переменную значением, которое она не может и не должна принимать при нормальном выполнении программы — может оказаться весьма полезен и в ряде других ситуаций. \u003c/small\u003e\u003c/p\u003e\u003cp\u003eДля хранения максимума будем использовать переменную \u003ccode\u003ez\u003c/code\u003e (как и предлагалось в условии задачи). Доработанный код будет выглядеть следующим образом:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e        void solve() {\n\t\ts \u003d 0;\n\t\tz \u003d -1;\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\t\tint p \u003d in.nextInt();\n\t\t\ts \u003d s + p;\n\t\t\tif (p \u0026gt; z) {\n\t\t\t\tz \u003d p;\n\t\t\t}\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tvoid print() {\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(z);\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКак можно видеть, \u003ccode\u003ez\u003c/code\u003e инициализируется значением \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e, после чего на каждой итерации цикла происходит её сравнение с очередным прочитанным из входных данных значением. Если прочитанное значение оказывается больше максимума из уже прочитанных, максимум из прочитанных перезаписывается.\u003c/p\u003e\u003cp\u003eДополним таблицу пошаговой трассировки:\u003c/p\u003e \u003ctable\u003e   \u003ctbody\u003e\u003ctr\u003e     \u003cth\u003e Номер итерации \u003c/th\u003e     \u003cth\u003e i \u003c/th\u003e     \u003cth\u003e p \u003c/th\u003e     \u003cth\u003e s \u003c/th\u003e     \u003cth\u003e z \u003c/th\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e До цикла \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e 0 \u003c/td\u003e     \u003ctd\u003e -1 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 1 \u003c/td\u003e     \u003ctd\u003e 0 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 2 \u003c/td\u003e     \u003ctd\u003e 1 \u003c/td\u003e     \u003ctd\u003e 2 \u003c/td\u003e     \u003ctd\u003e 6 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 3 \u003c/td\u003e     \u003ctd\u003e 2 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 10 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 3 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 17 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 5 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 5 \u003c/td\u003e     \u003ctd\u003e 22 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 6 \u003c/td\u003e     \u003ctd\u003e 5 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 29 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 6 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 36 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 8 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 3 \u003c/td\u003e     \u003ctd\u003e 39 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e После цикла \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e 39 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e   \u003c/tr\u003e  \u003c/tbody\u003e\u003c/table\u003e\u003cp\u003eКак можно видеть, уже на четвёртой итерации \u003ccode\u003ez\u003c/code\u003e обретёт свое окончательное значение. Ни на одной из итераций, начиная с пятой, условие \u003ccode\u003ep \u0026gt; z\u003c/code\u003e выполняться уже не будет.\u003c/p\u003e\u003cp\u003eНаконец, рассмотрим последнюю подзадачу — \u003cem\u003e\u003cb\u003eподсчет количества дней, в каждый из которых Кеша решал максимальное количество задач\u003c/b\u003e\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eСнова обсудим, как действовал бы человек, которому последовательно называют числа, а в конце просят назвать не только максимальное из них, но и количество раз, которое оно встретилось в последовательности.\u003c/p\u003e\u003cp\u003eВозможно, сейчас тот случай, когда на конкретном примере разобраться будет проще. Рассмотрим наш \u0026quot;тестовый пример\u0026quot;\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e8\n4 2 4 7 5 7 7 3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЕщё у нас есть переменная \u003ccode\u003ez\u003c/code\u003e, начальное значение которой задано как \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e, и переменная \u003ccode\u003ed\u003c/code\u003e, в которой мы будем хранить ответ на вопрос подзадачи (пока мы её никак не использовали и не инициализировали). \u003c/p\u003e\u003cp\u003eТакже мы сформулировали последовательность действий при поиске максимума: \u003cbr /\u003e \u003cem\u003eуслышал очередное число — сравнил с максимальным среди названных ранее — запомнил максимальное из двух сравниваемых\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eИтак, человеку называют число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u003d 4\u003c/span\u003e. Он сравнивает его с \u003ccode\u003ez \u003d -1\u003c/code\u003e (которое он помнит), и, поскольку \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u0026gt; \u003ci\u003ez\u003c/i\u003e\u003c/span\u003e, запоминает значение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e в переменной \u003ccode\u003ez\u003c/code\u003e. Это значение встретилось человеку впервые, и оно самое большое среди уже названных. Человек не знает, какие числа ему будут называть в дальнейшем, поэтому может сделать предположение, что число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u003d 4\u003c/span\u003e и есть максимальное во всей последовательности. В таком случае ему придётся сосчитать, сколько раз в последовательности ему встретится число \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eХранить количество максимальных значений он будет в переменной \u003ccode\u003ed\u003c/code\u003e, и в настоящий момент это количество равно \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e: действительно, мы впервые встретили такое число. \u003c/p\u003e\u003cp\u003eДалее человеку называют число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u003d 2\u003c/span\u003e. Он сравнивает его с \u003ccode\u003ez \u003d 4\u003c/code\u003e, и тут уже сравнение не в пользу \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e. В результате сравнения не меняется ни максимум, ни количество максимальных значений.\u003c/p\u003e\u003cp\u003eТеперь подошла очередь \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e \u003d 4\u003c/span\u003e. При сравнении условие \u003ccode\u003ep \u0026gt; z\u003c/code\u003e не выполняется, т.е. значение максимума меняться не должно (и это правильно). Однако количество максимальных значений должно измениться, ведь \u003ccode\u003ep \u003d\u003d z\u003c/code\u003e. Поэтому нам необходимо рассматривать ещё случай равенства очередного числа и максимума: если это так, то следует увеличить значение \u003ccode\u003ed\u003c/code\u003e на единицу (и \u003ccode\u003ed\u003c/code\u003e станет равным 2).\u003c/p\u003e\u003cp\u003eЗатем человеку называют число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e4\u003c/sub\u003e \u003d 7\u003c/span\u003e. Выполняется условие \u003ccode\u003ep \u0026gt; z\u003c/code\u003e, и это значит, что, во-первых, необходимо обновить максимум (\u003ccode\u003ez \u003d p\u003c/code\u003e), и, во-вторых, снова установить \u003ccode\u003ed\u003c/code\u003e равным \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e (чисел, равных \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e4\u003c/sub\u003e\u003c/span\u003e, в последовательности ещё не было).\u003c/p\u003e\u003cp\u003eЧисло \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e5\u003c/sub\u003e \u003d 5\u003c/span\u003e не приводит к каким-либо изменениям: оно не больше и не равно текущего максимума. А вот число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e6\u003c/sub\u003e \u003d 7\u003c/span\u003e изменит величину \u003ccode\u003ed\u003c/code\u003e: это второе значение, равное \u003cspan class\u003d\"tex-span\"\u003e7\u003c/span\u003e, встреченное в последовательности. Число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e7\u003c/sub\u003e \u003d 7\u003c/span\u003e увеличит \u003ccode\u003ed\u003c/code\u003e ещё на единицу, а число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e8\u003c/sub\u003e \u003d 3\u003c/span\u003e, как и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e5\u003c/sub\u003e\u003c/span\u003e, никаких изменений не вызовет.\u003c/p\u003e\u003cp\u003eИз наших рассуждений следует, что инициализировать \u003ccode\u003ed\u003c/code\u003e каким-либо значением необязательно. В принципе можно этого и не делать — переменные класса Java по умолчанию инициализирует \u0026quot;нулевым\u0026quot; значением (\u0026quot;нулевым\u0026quot; — поскольку ноль с точки зрения типа, отличного от \u003ccode\u003eint\u003c/code\u003e или \u003ccode\u003edouble\u003c/code\u003e, может выглядеть не как \u003ccode\u003e0\u003c/code\u003e; к примеру, переменные типа \u003ccode\u003eboolean\u003c/code\u003e по умолчанию получат значение \u003ccode\u003efalse\u003c/code\u003e). Результат \u003ccode\u003e0\u003c/code\u003e будет свидетельствовать об ошибке в программе: понятно, что максимальное значение должно встретиться как минимум один раз. Однако он не так \u0026quot;бросается в глаза\u0026quot;, как, например, \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e. Поэтому будет лучше, если в качестве начального значения \u003ccode\u003ed\u003c/code\u003e мы будем использовать не просто \u0026quot;заведомо невозможное\u0026quot;, но и \u0026quot;заметно ошибочное\u0026quot; значение \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Есть ещё важный довод в пользу инициализации переменных вручную вместо использования значений по умолчанию. \u003cbr /\u003e Если подходить к анализу нашего кода формально, присваивания значения величине \u003ccode\u003ed\u003c/code\u003e может и не произойти. Мы выбрали начальное значение \u003ccode\u003ez\u003c/code\u003e, исходя из ограничений в задаче (которые, как мы надеемся, соблюдаются в тестах). Но формально величины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e могут принимать любые значения, допустимые с точки зрения типа \u003ccode\u003eint\u003c/code\u003e. Если начальное значение \u003ccode\u003ez\u003c/code\u003e окажется большим (или равным), чем максимальное значение в последовательности \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, то условие \u003ccode\u003ep \u0026gt; z\u003c/code\u003e не выполнится ни разу, и переменная \u003ccode\u003ed\u003c/code\u003e не получит никакого \u0026quot;реального\u0026quot; значения. \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Заметим также, что значения по умолчанию не присваиваются переменным, которые объявлены внутри методов. Мы пока не рассматриваем подробно языковые тонкости; достаточно запомнить, что в большинстве случаев инициализировать переменные полезно, а если на этом настаивает компилятор — то и необходимо. \u003c/small\u003e\u003c/p\u003e\u003cp\u003eТеперь мы готовы записать доработанный код методов \u003ccode\u003esolve()\u003c/code\u003e и \u003ccode\u003eprint()\u003c/code\u003e. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\tvoid solve() {\n\t\ts \u003d 0;\n\t\tz \u003d -1;\n\t\td \u003d -1;\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\t\tint p \u003d in.nextInt();\n\t\t\ts \u003d s + p;\n\t\t\tif (p \u0026gt; z) {\n\t\t\t\tz \u003d p;\n\t\t\t\td \u003d 1;\n\t\t\t}\n\t\t\telse if (p \u003d\u003d z) {\n\t\t\t\td++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tvoid print() {\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(z);\n\t\tSystem.out.println(d);\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОбратите внимание, что сравнение \u003ccode\u003ep \u003d\u003d z\u003c/code\u003e мы записали в ветви \u003ccode\u003eelse\u003c/code\u003e. Если вы опустите \u003ccode\u003eelse\u003c/code\u003e, получите неправильный результат. Если сначала сработает условие \u003ccode\u003ep \u0026gt; z\u003c/code\u003e, то \u003ccode\u003ez\u003c/code\u003e получит в качестве значения именно \u003ccode\u003ep\u003c/code\u003e. Второй условный оператор (в отсутствие \u003ccode\u003eelse\u003c/code\u003e) будет выполняться независимо — и выполнится, поскольку после срабатывания первого \u003ccode\u003eif\u003c/code\u003e условие \u003ccode\u003ep \u003d\u003d z\u003c/code\u003e верное. В итоге \u003ccode\u003ed\u003c/code\u003e получит значение \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Да, конечно, можно записать правильный код с двумя независимыми \u003ccode\u003eif\u003c/code\u003e. Для этого следует при изменении максимального значения присваивать \u003ccode\u003ed\u003c/code\u003e не единицу, а ноль: \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e\u003c/small\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\t\t\tif (p \u0026gt; z) {\n\t\t\t\tz \u003d p;\n\t\t\t\td \u003d 0;\n\t\t\t}\n\t\t\tif (p \u003d\u003d z) {\n\t\t\t\td++;\n\t\t\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003csmall\u003e Однако этот \u0026quot;финт\u0026quot; похож на ситуацию, когда не все блоки \u003ccode\u003ecase\u003c/code\u003e оператора \u003ccode\u003eswitch\u003c/code\u003e завершаются оператором \u003ccode\u003ebreak\u003c/code\u003e. Такой подход может быть полезен, но он определённо проигрывает в \u0026quot;читабельности\u0026quot; (а, значит, в таком коде труднее найти ошибку). Общее правило таково, что пересечения \u0026quot;ветвей\u0026quot; в программе в большинстве случаев следует избегать. \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Так что если хочется сделать операторы \u003ccode\u003eif\u003c/code\u003e \u0026quot;независимыми\u0026quot;, придётся поменять порядок действий: \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e\u003c/small\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\t\t\tif (p \u003d\u003d z) {\n\t\t\t\td++;\n\t\t\t}\n\t\t\tif (p \u0026gt; z) {\n\t\t\t\tz \u003d p;\n\t\t\t\td \u003d 1;\n\t\t\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003csmall\u003e Воспринимается ли такой код лучше, чем предложенный в основном тексте — решать вам. \u003c/small\u003e\u003c/p\u003e\u003cp\u003eДля полноты картины приведём полную версию таблицы пошаговой трассировки.\u003c/p\u003e \u003ctable\u003e   \u003ctbody\u003e\u003ctr\u003e     \u003cth\u003e Номер итерации \u003c/th\u003e     \u003cth\u003e i \u003c/th\u003e     \u003cth\u003e p \u003c/th\u003e     \u003cth\u003e s \u003c/th\u003e     \u003cth\u003e z \u003c/th\u003e     \u003cth\u003e d \u003c/th\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e До цикла \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e 0 \u003c/td\u003e     \u003ctd\u003e -1 \u003c/td\u003e     \u003ctd\u003e -1 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 1 \u003c/td\u003e     \u003ctd\u003e 0 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 1 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 2 \u003c/td\u003e     \u003ctd\u003e 1 \u003c/td\u003e     \u003ctd\u003e 2 \u003c/td\u003e     \u003ctd\u003e 6 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 1 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 3 \u003c/td\u003e     \u003ctd\u003e 2 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 10 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 2 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 3 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 17 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 1 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 5 \u003c/td\u003e     \u003ctd\u003e 4 \u003c/td\u003e     \u003ctd\u003e 5 \u003c/td\u003e     \u003ctd\u003e 22 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 1 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 6 \u003c/td\u003e     \u003ctd\u003e 5 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 29 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 2 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 6 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 36 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 3 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e 8 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 3 \u003c/td\u003e     \u003ctd\u003e 39 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 3 \u003c/td\u003e   \u003c/tr\u003e    \u003ctr\u003e     \u003ctd\u003e После цикла \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e не существует \u003c/td\u003e     \u003ctd\u003e 39 \u003c/td\u003e     \u003ctd\u003e 7 \u003c/td\u003e     \u003ctd\u003e 3 \u003c/td\u003e   \u003c/tr\u003e  \u003c/tbody\u003e\u003c/table\u003e\u003cp\u003eТакже приведём \u003cstrong\u003eполный текст\u003c/strong\u003e программы, решающей задачу.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport java.util.Scanner;\n\npublic class ProblemsSolving {\n\n\tpublic static void main(String[] args) {\n\t\tProblemsDay pr \u003d new ProblemsDay();\n\t\tpr.solve();\n\t\tpr.print();\n\t}\n\n}\n\nclass ProblemsDay {\n\t\n\tProblemsDay() {\n\t\tin \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t}\n\t\n\tvoid solve() {\n\t\ts \u003d 0;\n\t\tz \u003d -1;\n\t\td \u003d -1;\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\t\tint p \u003d in.nextInt();\n\t\t\ts \u003d s + p;\n\t\t\tif (p \u0026gt; z) {\n\t\t\t\tz \u003d p;\n\t\t\t\td \u003d 1;\n\t\t\t}\n\t\t\telse if (p \u003d\u003d z) {\n\t\t\t\td++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tvoid print() {\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(z);\n\t\tSystem.out.println(d);\n\t}\n\t\n\t\n\tScanner in;\n\t\n\tint n;\n\tint s;\n\tint z;\n\tint d;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eДля тестирования программы можно использовать следующий набор тестов.\u003c/p\u003e\u003cp\u003e\u003cem\u003eВходные данные\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e8\n4 2 4 7 5 7 4 3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eВыходные данные\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e36\n7\n2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eКомментарий\u003c/em\u003e \u003cbr /\u003e Число, которое однажды становится максимальным, но потом перестаёт им быть, встречается в последовательности большее количество раз, чем \u0026quot;настоящий\u0026quot; максимум.\u003c/p\u003e\u003cp\u003e\u003cem\u003eВходные данные\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e8\n7 2 4 4 5 7 4 3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eВыходные данные\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e36\n7\n2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eКомментарий\u003c/em\u003e \u003cbr /\u003e Максимум встречается в последовательности на первом месте, нужно убедиться, что первое число обрабатывается корректно.\u003c/p\u003e\u003cp\u003e\u003cem\u003eВходные данные\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e8\n7 2 4 4 5 7 4 7\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eВыходные данные\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e40\n7\n3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eКомментарий\u003c/em\u003e \u003cbr /\u003e Максимум встречается в последовательности и на последнем месте, нужно убедиться, что последнее число обрабатывается корректно.\u003c/p\u003e\u003cp\u003e\u003cem\u003eВходные данные\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e3\n1000 1000 1000\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eВыходные данные\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e3000\n1000\n3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eКомментарий\u003c/em\u003e \u003cbr /\u003e Последовательность состоит только из максимумов.\u003c/p\u003e\u003cp\u003e\u003cem\u003eВходные данные\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e1\n0\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eВыходные данные\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e0\n0\n1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eКомментарий\u003c/em\u003e \u003cbr /\u003e В последовательности содержится один элемент (он же максимум).\u003c/p\u003e\u003cp\u003eПопробуйте придумать свои тестовые примеры (и обязательно сформулируйте, что именно они проверяют), чтобы убедиться в правильной работе программы.\u003c/p\u003e\u003c/div\u003e","tags":["java","циклы"]}}