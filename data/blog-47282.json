{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1474592660,"rating":44,"authorHandle":"AlexanderBolshakov","modificationTimeSeconds":1474592660,"id":47282,"title":"\u003cp\u003eСоздание многомерного std::vector с использованием Variadic Templates из C++11\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eЯ недавно решил закодить \u003ca href\u003d\"//codeforces.com/blog/entry/46744?locale\u003dru#comment-315881\"\u003eодну задачу\u003c/a\u003e, а т.к. я уже отучился от привычки использовать глобальные массивы с фиксированным размером, пришлось нагородить вот такую некрасивую штуку: \u003ccode\u003evector\u0026lt;vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026gt; visited(n, vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;(n, vector\u0026lt;char\u0026gt;(n, false)));\u003c/code\u003e. Потом я вспомнил, что в современном C++ ничто не мешает сделать создание подобных векторов заметно более удобным, поэтому я реализовал вот это:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;vector\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n\ntemplate\u0026lt;typename T, size_t nDimensions\u0026gt;\nstruct VectorType\n{\n\ttypedef std::vector\u0026lt;typename VectorType\u0026lt;T, nDimensions - 1\u0026gt;::Type\u0026gt; Type;\n};\n\ntemplate\u0026lt;typename T\u0026gt;\nstruct VectorType\u0026lt;T, 0\u0026gt;\n{\n\ttypedef T Type;\n};\n\ntemplate\u0026lt;typename T\u0026gt;\nstruct MVector\n{\n\tstatic typename VectorType\u0026lt;T, 0\u0026gt;::Type create();\n\n\ttemplate\u0026lt;typename SizeType, typename... SizeTypes\u0026gt;\n\tstatic typename VectorType\u0026lt;T, 1 + sizeof...(SizeTypes)\u0026gt;::Type create(SizeType sz, SizeTypes... sizes);\n};\n\ntemplate\u0026lt;typename T\u0026gt;\ntypename VectorType\u0026lt;T, 0\u0026gt;::Type MVector\u0026lt;T\u0026gt;::create()\n{\n\treturn typename VectorType\u0026lt;T, 0\u0026gt;::Type();\n}\n\n\ntemplate\u0026lt;typename T\u0026gt;\ntemplate\u0026lt;typename SizeType, typename... SizeTypes\u0026gt;\ntypename VectorType\u0026lt;T, 1 + sizeof...(SizeTypes)\u0026gt;::Type MVector\u0026lt;T\u0026gt;::create(SizeType sz, SizeTypes... sizes)\n{\n\treturn typename VectorType\u0026lt;T, 1 + sizeof...(SizeTypes)\u0026gt;::Type(sz, create(sizes...));\n}\n\n\nint main()\n{\n\tint n, m;\n\tstd::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\n\tauto matrix \u003d MVector\u0026lt;int\u0026gt;::create(n, m);\n\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\tfor (int j \u003d 0; j \u0026lt; m; j++) {\n\t\t\tstd::cin \u0026gt;\u0026gt; matrix[i][j];\n\t\t}\n\t}\n\n\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\tfor (int j \u003d 0; j \u0026lt; m; j++) {\n\t\t\tstd::cout \u0026lt;\u0026lt; matrix[i][j] \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n\t\t}\n\t\tstd::cout \u0026lt;\u0026lt; std::endl;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}