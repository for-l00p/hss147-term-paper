{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1494596507,"rating":4,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1494644978,"id":51943,"title":"\u003cp\u003eSolutions to Codeforces Beta Round #42, A, B, C, D, E(Amortized Analysis)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA. Football\u003c/p\u003e\u003cp\u003eThis is one feasible solution. We can use the \u0026quot;map\u0026lt;string, int\u0026gt;\u0026quot; provided by C++ to record the number of goals for each team. Moreover, we should also store the name of the two teams, i.e., the two strings (note that it is likely to have only one string appearing in the input). Then, we just compare the number of goals for each team and output the answer.\u003c/p\u003e\u003cp\u003eB. Letter\u003c/p\u003e\u003cp\u003eWe can use \u0026quot;getline(cin,s)\u0026quot; provided by C++ to deal with a string containing blank space as input. We first deal with the input s1 and use the \u0026quot;hash\u0026quot; idea to record the number of letters that have appeared. Note that the blank space should not be considered as the problem requires. Then, we deal with the input s2 and similarly adopt the \u0026quot;hash\u0026quot; idea to record the number of letters appearing in s2. Finally, for each letter that has appeared in s2, we check whether s1 has provided enough such a letter or not.\u003c/p\u003e\u003cp\u003eC. Lucky Tickets\u003c/p\u003e\u003cp\u003eFor an integer, it is divisible by 3 if and only if the sum of its digits is divisible by 3. A simple proof is that we write the integer as \u003c/p\u003e\u003cp\u003eA\u003da0*10^0+a1*10^1+...an*10^n\u003c/p\u003e\u003cp\u003e\u003da1*(10^1-1)+a2*(10^2-1)+...an*(10^n-1)+(a0+a1+a2+...an)\u003c/p\u003e\u003cp\u003eIt is obvious that a1*(10^1-1)+a2*(10^2-1)+...an*(10^n-1) is divisible by 3 and thus the conclusion is straightforward.\u003c/p\u003e\u003cp\u003eTherefore, we can count the number of tickets that are divisible by 3 as x, and the number of tickets divided by 3 resulting in a remainder 1 and 2 as y and z, respectively. The answer is x/2+min(y,z), where \u0026quot;/\u0026quot; is integer division.\u003c/p\u003e\u003cp\u003eD. Journey\u003c/p\u003e\u003cp\u003eOne can first prove that if both n and m are odd integers, we can definitely not return back to (1,1) without using any teleporter. The proof is based on painting colors. We first paint (1,1) with black and the next cell that we move to with white. Then, for the following steps, we just paint the cells with black and white in an alternative manner. As we visit each cell exactly once except for (1,1), this means that if we successfully achieve this goal, the last cell we reach must be painted with white color, which is contradictory with the fact that we have painted (1,1) with black color. Furthermore, we can always construct a feasible route for the case where at least one of n and m is an even number, and thus the solution can be summarized as follows:\u003c/p\u003e\u003cp\u003e1) Both n and m are odd integers. We start from (1,1) and visit all the cells in the first row and then the second row and so on. At last, we will always reach the cell (n,m), and by building a teleporter at cell (n,m) we can return back to (1,1);\u003c/p\u003e\u003cp\u003e2) At least one of n and m is an even integer. Without loss of generality, assume that n is an even number. We start from (1,1) and move on to (1,m). Then, we visit all the cells in the second row except for (2,1), i.e., we will reach cell (2,2). Next, we go to (3,2) and move on until we reach (3,m). In a word, we just visit the cells row by row but leaving the first column unvisited. Finally, we will surely arrive at (n,2). By visiting the first column, we just return back to (1,1) without using any teleporter.\u003c/p\u003e\u003cp\u003eNote that there exist several special cases. One case is (n\u003d1, m\u0026gt;2), or (m\u003d1, n\u0026gt;2). For this case, we have to build a teleporter at cell (n,m) and then can return back to (1,1). Another case is (n\u003d1,m\u003d2), or (n\u003d2,m\u003d1), where no teleporter is necessary.\u003c/p\u003e\u003cp\u003eE. Race\u003c/p\u003e\u003cp\u003eAs both n is not quite large, we can count the number of \u0026quot;lead\u0026quot; for every two cars, which contributes O(n^2) complexity. For the i-th car and j-th car, we adopt two pointers pi and pj to enumerate (or scan) their time segments independently. Moveover, we adopt a \u0026quot;flag\u0026quot; to denote which car is leading over another one. We first find out the shortest time segment T for the current pi and pj, and use it to compute the current distance of the two cars. Then, we compare which car is leading over another one and update the number of \u0026quot;lead\u0026quot; accordingly. Finally, we should decrease the two time segments with T, and if any of them is reduced to zero, we just add pi or pj by 1 so that we move on to check the next time segment. As these operations will change the original values of time segments, we should backup them before implementing such operations so that when we deal with another two cars, the time segments are not \u0026quot;zero\u0026quot;. By some simple amortized analysis, the total complexity is O(n^2*k).\u003c/p\u003e\u003cp\u003eI think for this problem, the most difficult step is how to \u0026quot;scan\u0026quot; any two time segments in an efficient and correct manner.\u003c/p\u003e\u003c/div\u003e","tags":[]}}