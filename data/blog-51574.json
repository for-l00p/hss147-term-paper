{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1492176631,"rating":0,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1492176631,"id":51574,"title":"\u003cp\u003eSolutions to Codeforces Beta Round #35, A, B, C, D\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA. Shell Game\u003c/p\u003e\u003cp\u003eThe solution is straightforward by swapping the integers as required by the problem.\u003c/p\u003e\u003cp\u003eB. Warehouse\u003c/p\u003e\u003cp\u003eThe warehouse can be viewed as a two-dimensional array. If \u0027+1\u0027 is met, we just enumerate the positions from the given one to the final one in the order required by the problem, and put the drink into the first empty box if there exist any. If \u0027-1\u0027 is met, we can enumerate from the first position to the final one, and if any one that has the same ID is found, we just output the corresponding position; otherwise output \u0026quot;-1 -1\u0026quot;.\u003c/p\u003e\u003cp\u003eC. Fire Again\u003c/p\u003e\u003cp\u003eSuppose that the position at which the fire begins is denoted as (f1,f2). Then, for any position (r,c), the fire gets to it after time |r-f1|+|c-f2|, which is referred to as Manhattan Distance as far as I consider. Therefore, we can first enumerate the positions where fire starts, and for each such position, we enumerate every feasible position and calculate the time when the fire arrives at it. As all the fires start at the same time, we should only record the shortest time when the fire gets to some position during the above enumerating process. Finally, we enumerate all the positions again and find out which is the last one that the fires reach. The total complexity is O(NMK).\u003c/p\u003e\u003cp\u003eLater, I noticed that some people used another simpler method. The formula |r-f1|+|c-f2| in fact has shed some light on this idea. It can be observed that the first term |r-f1| and the second one |c-f2| are independent of each other. Therefore, it is not necessary to enumerate positions \u0026quot;r\u0026quot; and \u0026quot;c\u0026quot; at the same time, but can be implemented respectively. In other words, we can first enumerate \u0026quot;r\u0026quot; and record the time when the fire gets to it, and then repeat this for \u0026quot;c\u0026quot;. Finally, we find out the largest \u0026quot;r\u0026quot; and \u0026quot;c\u0026quot;, and combine them as the position, which serves as the answer.\u003c/p\u003e\u003cp\u003eD. Animals\u003c/p\u003e\u003cp\u003eAs provided by the problem, c[1],c[2],...,c[n] denotes the food that an animal eats every day if it arrives at the farm on the i-th day. We can further calculate the total amount of food that an animal eats if it joins the farm, which can be written as f[1],f[2],....,f[n], where f[i]\u003dc[i]*(n-i+1). As the problem asks to find out the maximum number of animals that can join the farm, it is equivalent to maximizing the number of terms in the sum f[i1]+f[i2]...+f[im] under the condition that f[i1]+f[i2]...+f[im]\u0026lt;\u003dX. Therefore, we can first sort f[1],f[2],....,f[n] in an increasing order of their values. Then, we enumerate from the first one and count the number at the same time until the sum exactly exceeds X. The number just serves as the answer.\u003c/p\u003e\u003c/div\u003e","tags":["manhattan distance","sorting"]}}