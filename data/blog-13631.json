{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1409395599,"rating":-15,"authorHandle":"NelsonMondialu","modificationTimeSeconds":1409439720,"id":13631,"title":"\u003cp\u003eCodeforces Round #264 Tutorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/463/problem/A\" title\u003d\"Codeforces Round 264 (Div. 2)\"\u003e463A - Caisa and Sugar\u003c/a\u003e. This is a simple implementation problem.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/3UrmLQ\"\u003eSample solution.\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/463/problem/B\" title\u003d\"Codeforces Round 264 (Div. 2)\"\u003e463B - Caisa and Pylons\u003c/a\u003e. We have to use greedy method. Start from the first element and pass all the elements in order(also update by the energy).When energy \u0026lt; 0, add abs(energy) to solution and energy becomes 0 or we can find the answer by binary search.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/buuUUm\"\u003eSample solution.\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/463/problem/C\" title\u003d\"Codeforces Round 264 (Div. 2)\"\u003e463C - Gargari and Bishops\u003c/a\u003e. We preprocess the sum for all the diagonals(principals and secondary diagonals) in two arrays(so that for every element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e we can find sum of elements which are attacked in O(1) time).Also for avoiding the intersection,we need to find two cells so that for one the sum of row and column is even and for the other one the sum of row and column is odd.Finally,we analyze every cell ,we see if the sum of row and column is even or odd,and update that two positions(solutions).\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/yBx3so\"\u003eSample solution.\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/463/problem/D\" title\u003d\"Codeforces Round 264 (Div. 2)\"\u003e463D - Gargari and Permutations\u003c/a\u003e.We can build a directed acyclic graph with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e nodes.If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e is after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e in all vectors then we add in graph edge (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e,\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e).Now we have to find the longest path in this graph. Another way is using dp.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/HMF1CeDq\"\u003eSample solution with graph.\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/zZZG8y\"\u003eSample solution with dp.\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/463/problem/E\" title\u003d\"Codeforces Round 264 (Div. 2)\"\u003e463E - Caisa and Tree\u003c/a\u003e. We use an array of dynamic stacks for every prime factor.We start a DFS from node 1.For node 1 we decompose its value in prime factors and push it to every prime factor\u0027s stack.To answer the question for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e,we need to see the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e belongs to the chain from 1 to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e) that has a common prime factor with x,so the stacks will help us to see the earliest update(so the nearest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e). For every \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e ,we decompose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to prime factors,look in the array and see the earliest update of the prime factors\u0027 stacks(if exists,of course). Also when we get back to fathers recursively,we need to pop from the prime factors\u0027 stacks. For every update we have to start dfs again.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/AlivM9\"\u003eSample solution.\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}