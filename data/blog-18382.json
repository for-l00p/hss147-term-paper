{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1433677687,"rating":16,"authorHandle":"marat.snowbear","modificationTimeSeconds":1434375889,"id":18382,"title":"\u003cp\u003eAndrew Stankevich Contest 2 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/gym/100197\"\u003eContest Link\u003c/a\u003e\u003c/h3\u003e\u003cp\u003e    \u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/group/qo1icaI3vI/contest/100197/problem/A\" title\u003d\"2003-2004 Summer Petrozavodsk Camp, Andrew Stankevich Contest 2 (ASC 2)\"\u003e100197A - Non Absorbing DFA\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThis problem can be solved using DP. I will explain the top-down approach.\u003c/p\u003e\u003cp\u003eImagine we have a string \u0026quot;???...??\u0026quot; of length N. We can put any valid character from the given alphabet set. Let our dp state be, \u003ccode\u003edp ( left, dfaState )\u003c/code\u003e, where left indicates the amount of \u0026quot;?\u0026quot; we still have that we didn\u0027t assign any characters to and dfaState is the current state of DFA. Now, we can assign any of given characters to this \u0026quot;?\u0026quot;. So let us run a loop over the possible characters.\u003c/p\u003e\u003cp\u003eFor each character, c, from the input set, two things can happen.\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003ccode\u003eX[dfaState][c] \u003d 0\u003c/code\u003e. In this case, we simply assign the current \u0026quot;?\u0026quot; as c, and move to next dp state of \u003ccode\u003edp ( left-1, phi[dfaState][c] )\u003c/code\u003e.\u003c/li\u003e   \u003cli\u003e\u003ccode\u003eX[state][c] \u003d 1\u003c/code\u003e. In this case, the string does not get shorter when we change state in DFA. Instead, just our current state changes. Notice that it is possible to fall in a cycle from this state. So two things can happen from this dp state. Either we fall into a cycle, or we get out eventually by reaching such a state where \u003ccode\u003eX[finalState][c] \u003d 0\u003c/code\u003e.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eSo, in each dp state, we will simply count number of valid ways we can reach the end of the string. For each character c, when case 1, we just add \u003ccode\u003edp ( left-1, phi[dfaState][c] )\u003c/code\u003e and when case 2, if we don\u0027t fall in cycle, we add \u003ccode\u003edp ( left-1, phi[finalState][c] )\u003c/code\u003e. If we fall in cycle, then we will never reach an empty string, so we add 0 for this case.\u003c/p\u003e\u003cp\u003eWhen we have no more \u0026quot;?\u0026quot;, that is left is 0, if dfaState is a terminal state then we managed to build a string of length N that will be accepted by the DFA.\u003c/p\u003e\u003cp\u003eWhether the {dfaState,c} combination will fall in cycle or not can be precalculated. I used a dfs with memoization to make it faster.\u003c/p\u003e\u003cp\u003eUsing top-down approach gave me TLE. I had to convert it to forward DP. Also, we need to use Bigint. The Bigint library I use was heavily overloaded with different functions, which resulted in TLE. After fixing all these, I got AC with really narrow margin ( In CF 466ms out of 500ms and in SGU 0.249s / 0.250s ). So be careful guys.\u003c/p\u003e\u003cp\u003eHere is my implementation — \u003ca href\u003d\"http://ideone.com/NeCNWf\"\u003ehttp://ideone.com/NeCNWf\u003c/a\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/group/qo1icaI3vI/contest/100197/problem/B\" title\u003d\"2003-2004 Summer Petrozavodsk Camp, Andrew Stankevich Contest 2 (ASC 2)\"\u003e100197B - The Towers of Hanoi Revisited\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eFirst, lets see how to solve the standard Tower of Hanoi problem with 3 pegs and n discs and how we arrive at the formula \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e - 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, 3)\u003c/span\u003e be the minimum number of steps required to move n discs when there are 3 pegs in all. First we move the top n-1 discs to the 2nd peg, then we shift the largest disc from the first peg to the third, and finally we move the n-1 discs from the 2nd peg onto the third one. If done optimally this should take us \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e - 1, 3) + 1 + \u003ci\u003edp\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e - 1, 3)\u003c/span\u003e steps in all. In other words, we get the recurrence \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, 3) \u003d 2.\u003ci\u003edp\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e - 1, 3) + 1\u003c/span\u003e. A quick calculation reveals that this leads to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, 3) \u003d 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e - 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow, lets move to the general case with m pegs. Lets call \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e as the minimum number of steps to solve the problem with n discs and m pegs. How can we change our recurrence above to reflect that we now have multiple pegs. Initially with 3 pegs we always moved n-1 discs because if we moved any less then it would not be possible to move the remaining discs directly from the first peg to the last peg. However, now we are not limited by any such bound. So we:-\u003c/p\u003e\u003cp\u003e1) Move any arbitrary number, say k, of discs from the first peg to the second one. We can use all m pegs, hence \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e steps used.\u003c/p\u003e\u003cp\u003e2) Then we move the remaining discs on the first peg to the last peg. We cannot use the one peg occupied with the first k discs so it takes us \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e - 1)\u003c/span\u003e steps.\u003c/p\u003e\u003cp\u003e3) Finally we move the discs on the second peg to the last peg. We can use all pegs again so \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e steps.\u003c/p\u003e\u003cp\u003eWe can iterate over all k and find out which one gives us the best answer. So our recurrence becomes:\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1c/35/1c358d876a8abd46d0546eca470d906ffdeec144.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eSo we have now figured out how many steps we will take. Lets figure out what those steps are. Since we already have our dp table filled in. We just define a recursive function that traces out the path taken by our dp and prints it out. So for example if I tell my function to move 5 discs using 4 pegs it finds out the optimal k for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(5, 4)\u003c/span\u003e and then calls itself to first move k discs using 4 pegs, then k-1 discs using 3 pegs, and then k discs onto the final peg.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/1awn5dKY\"\u003eLink\u003c/a\u003e to my implementation.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/group/qo1icaI3vI/contest/100197/problem/C\" title\u003d\"2003-2004 Summer Petrozavodsk Camp, Andrew Stankevich Contest 2 (ASC 2)\"\u003e100197C - Hyperhuffman\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eWhen merging two subtrees, we increase the distance (from the root) of the leaves under those subtrees by 1.\u003c/p\u003e\u003cp\u003eNow,lets say, U.fre \u003d total number of occurrences(leaf) under subtree rooted at U.\u003c/p\u003e\u003cp\u003eU.res \u003d total cost(summation of distance * number of occurrences of the leaves) at the subtree.\u003c/p\u003e\u003cp\u003eNow if we merge two subtrees U and V, the merged node information will be,\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emerged\u003c/i\u003e.\u003ci\u003efre\u003c/i\u003e \u003d \u003ci\u003eU\u003c/i\u003e.\u003ci\u003efre\u003c/i\u003e + \u003ci\u003eV\u003c/i\u003e.\u003ci\u003efre\u003c/i\u003e.\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emerged\u003c/i\u003e.\u003ci\u003eres\u003c/i\u003e \u003d \u003ci\u003eU\u003c/i\u003e.\u003ci\u003eres\u003c/i\u003e + \u003ci\u003eV\u003c/i\u003e.\u003ci\u003eres\u003c/i\u003e + \u003ci\u003emerged\u003c/i\u003e.\u003ci\u003efre\u003c/i\u003e.\u003c/span\u003e\u003c/p\u003e\u003cp\u003eWhy? Assume, there were 3 leaves under U and 2 leaves under V. So we can write,\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eU\u003c/i\u003e.\u003ci\u003eres\u003c/i\u003e \u003d (\u003ci\u003eF\u003c/i\u003e1 * \u003ci\u003eC\u003c/i\u003e1 + \u003ci\u003eF\u003c/i\u003e2 * \u003ci\u003eC\u003c/i\u003e2 + \u003ci\u003eF\u003c/i\u003e3 * \u003ci\u003eC\u003c/i\u003e3)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e.\u003ci\u003eres\u003c/i\u003e \u003d (\u003ci\u003eF\u003c/i\u003e4 * \u003ci\u003eC\u003c/i\u003e4 + \u003ci\u003eF\u003c/i\u003e5 * \u003ci\u003eC\u003c/i\u003e5)\u003c/span\u003e \u003c/p\u003e\u003cp\u003ehere \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eFi\u003c/i\u003e\u003c/span\u003e is the number of occurrences of ith leaf and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eCi\u003c/i\u003e\u003c/span\u003e is the cost(distance) of ith leaf (why costs are different? cause leaves may be at different levels). after merging costs will be increased by 1, so,\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emerged\u003c/i\u003e.\u003ci\u003eres\u003c/i\u003e \u003d \u003ci\u003eF\u003c/i\u003e1 * (\u003ci\u003eC\u003c/i\u003e1 + 1) + \u003ci\u003eF\u003c/i\u003e2 * (\u003ci\u003eC\u003c/i\u003e2 + 1) + \u003ci\u003eF\u003c/i\u003e3 * (\u003ci\u003eC\u003c/i\u003e3 + 1) + \u003ci\u003eF\u003c/i\u003e4 * (\u003ci\u003eC\u003c/i\u003e4 + 1) + \u003ci\u003eF\u003c/i\u003e5 * (\u003ci\u003eC\u003c/i\u003e5 + 1)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e \u003d  \u0026gt; (\u003ci\u003eF\u003c/i\u003e1 * \u003ci\u003eC\u003c/i\u003e1 + \u003ci\u003eF\u003c/i\u003e2 * \u003ci\u003eC\u003c/i\u003e2 + \u003ci\u003eF\u003c/i\u003e3 * \u003ci\u003eC\u003c/i\u003e3) + (\u003ci\u003eF\u003c/i\u003e4 * \u003ci\u003eC\u003c/i\u003e4 + \u003ci\u003eF\u003c/i\u003e5 * \u003ci\u003eC\u003c/i\u003e5) + (\u003ci\u003eF\u003c/i\u003e1 + \u003ci\u003eF\u003c/i\u003e2 + \u003ci\u003eF\u003c/i\u003e3 + \u003ci\u003eF\u003c/i\u003e4 + \u003ci\u003eF\u003c/i\u003e5)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e \u003d  \u0026gt; \u003ci\u003eU\u003c/i\u003e.\u003ci\u003eres\u003c/i\u003e + \u003ci\u003eV\u003c/i\u003e.\u003ci\u003eres\u003c/i\u003e + \u003ci\u003emerged\u003c/i\u003e.\u003ci\u003efre\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eTo maintain the overall process of extracting two current least(number of occurrences) nodes and inserting the merged one, we can use min heap structure. Using min heap we will get a complexity of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNLogN\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eHere is my implementation:\u003ca href\u003d\"http://ideone.com/BNYAb7\"\u003ecode\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI have used STL priority_queue. One thing worth noting is, to use priority_queue as min heap we have to overload the operator \u0027\u0026lt;\u0027.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/group/qo1icaI3vI/contest/100197/problem/D\" title\u003d\"2003-2004 Summer Petrozavodsk Camp, Andrew Stankevich Contest 2 (ASC 2)\"\u003e100197D - Little Jumper\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eWith basic calculus we can get the following:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eIf the jump is made on the distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e with the minimal speed, then on the distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e the height will be \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/99/1e/991e2896792cfe587b4606173ba336b25207732d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf there is a hole between heights \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e, then the minimal possible speed will be achived if the hole is passed on the height \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003emax\u003c/i\u003e(\u003ci\u003eh\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e), \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThat speed will be equal to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/27/ac/27acf170ed61469035b8dc03a524311e11f2887c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eUsing those formulas for both jumps we can get the minimum required speed as a function of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e, and it\u0027s unimodal, so ternary search can be used to find the answer.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003ch3\u003e\u003ca href\u003d\"/group/qo1icaI3vI/contest/100197/problem/E\" title\u003d\"2003-2004 Summer Petrozavodsk Camp, Andrew Stankevich Contest 2 (ASC 2)\"\u003e100197E - Quantization Problem\u003c/a\u003e\u003c/h3\u003e\u003ch3\u003e\u003ca href\u003d\"/group/qo1icaI3vI/contest/100197/problem/F\" title\u003d\"2003-2004 Summer Petrozavodsk Camp, Andrew Stankevich Contest 2 (ASC 2)\"\u003e100197F - Roads\u003c/a\u003e\u003c/h3\u003e\u003cp\u003ePaved roads must form one of minimum spanning trees, and from Kruskal\u0027s algorithm you can see that in every cycle country roads must cost not less than any paved road. Obviously there is no need to decrease country roads costs and increase paved road costs, so let\u0027s decrease paved roads costs by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≥ 0\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003eN\u003c/i\u003e - 1\u003c/span\u003e) and increase country roads costs by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≥ 0\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003eM\u003c/i\u003e - \u003ci\u003eN\u003c/i\u003e + 1\u003c/span\u003e). Every country road forms a fundamental cycle with paved roads, and for each paved one we can get an inequality \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e - \u003ci\u003en\u003c/i\u003e + 1\u003c/sub\u003e + \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e ≥ \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eij\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. The goal is to minimize \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9f/05/9f050e3a73f938a11387c018079446319aa1c83c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, and we\u0027ve got an instance of maximum weight matching in a bipartite graph problem (minimum weight in this case, just negate all costs), which can be solved by Hungarian algorithm in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eM\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e time.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/group/qo1icaI3vI/contest/100197/problem/G\" title\u003d\"2003-2004 Summer Petrozavodsk Camp, Andrew Stankevich Contest 2 (ASC 2)\"\u003e100197G - Robbers\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eClassical Knapsack problem. Notice that, according to \u003ccode\u003eXi/Y\u003c/code\u003e ratio, some robbers will get integer share and some fraction. But it is not possible to give fraction of a coin to someone. So we have to provide integer coins to the robbers. \u003c/p\u003e\u003cp\u003eThe robbers who are getting integer amount already, they are ok. We don\u0027t have to change them. The ones who are getting fraction are causing problems. So, initially, lets floor each of the fractions and assign them to corresponding robbers while adding the fraction part of the floating point to a variable \u0026quot;extra\u0026quot;. The summation of all fraction parts will be an integer. \u003c/p\u003e\u003cp\u003eWe are now going to distribute the extra coins to robbers. If there were P robbers with fraction coins at beginning, then value of extra will be less than P. So it is sufficient and better to distribute among the P robbers only. It is also better to give at most 1 coin to each of the P robbers. Otherwise, the fairness would increase unnecessarily. \u003c/p\u003e\u003cp\u003eSo, it boils down to following. Each robber will either get \u003ccode\u003efloor(Xi*M/Y)\u003c/code\u003e coins or \u003ccode\u003efloor(Xi*M/Y) + 1\u003c/code\u003e coins. Just do a 0/1 knapsack dp, while trying to minimize the fairness. I used the following state:\u003ccode\u003edp ( current robber, number of coins left to distribute )\u003c/code\u003e. Complexity was O(N*M).\u003c/p\u003e\u003cp\u003eAlso, avoid using double when calculating fairness. It might give MLE ( didn\u0027t try with double ). Notice that \u003ccode\u003e|Xi/Y − Ki/M|\u003c/code\u003e can be written as \u003ccode\u003e|(M*Xi-Y*ki)/(YM)|\u003c/code\u003e. So minimizing \u003ccode\u003e|(M*Xi-Y*ki)|\u003c/code\u003e is enough. Also, since the value of ki is \u003ccode\u003efloor(Xi*M/Y)\u003c/code\u003e coins or \u003ccode\u003efloor(Xi*M/Y) + 1\u003c/code\u003e, value of \u003ccode\u003e(M*Xi-Y*ki)\u003c/code\u003e will be \u0026lt; Y. So using \u003ccode\u003eint\u003c/code\u003e is enough.\u003c/p\u003e\u003cp\u003eUPD: There is no need to do a DP, as it is known exactly how many \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e values you need to increase by 1. So it\u0027s enough to do the following:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eset \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d ⌊ \u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003ci\u003eM\u003c/i\u003e / \u003ci\u003eY\u003c/i\u003e⌋\u003c/span\u003e;\u003c/li\u003e   \u003cli\u003efind how many coins we need to add: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7e/61/7e61d84f6695d09077308830cdee669d6046df3e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e;\u003c/li\u003e   \u003cli\u003esort robbers by \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/99/0f/990f4920322a4d7648104f4c2cca11027990c79f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (or by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003ci\u003eY\u003c/i\u003e - \u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e after removing constants);\u003c/li\u003e   \u003cli\u003eincrease \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e by 1 for the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e of them.\u003c/li\u003e \u003c/ul\u003e\u003ch3\u003e\u003ca href\u003d\"/group/qo1icaI3vI/contest/100197/problem/H\" title\u003d\"2003-2004 Summer Petrozavodsk Camp, Andrew Stankevich Contest 2 (ASC 2)\"\u003e100197H - Tickets\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eAn application of Burnside\u0027s lemma. Tickets obtained by shifting or rotating by 180 degrees (90 when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e \u003d \u003ci\u003eM\u003c/i\u003e\u003c/span\u003e) result in the same tore. For every such transformation calculate the number of cycles \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e in the resulting permutation and add \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e to the result. After that divide it by the total number of transformations and get the answer. As there are up to 400 cycles, bignum arithmetic is needed.\u003c/p\u003e\u003c/div\u003e","tags":[]}}