{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1418738323,"rating":22,"authorHandle":"diego_v1","modificationTimeSeconds":1418831683,"id":15188,"title":"\u003cp\u003eUSACO December 2014 — Gold Tutorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eProblem 1 — Guard Mark:\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe \u0026quot;\u003cspan class\u003d\"tex-span\"\u003e2 ≤ \u003ci\u003eN\u003c/i\u003e ≤ 20\u003c/span\u003e\u0026quot; constraint immediately suggests a DP + Bitmask solution. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eDP\u003c/i\u003e[\u003ci\u003em\u003c/i\u003e]\u003c/span\u003e be the maximum safety factor we can achieve with mask \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e. The transition will be as follows: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eDP\u003c/i\u003e[\u003ci\u003em\u003c/i\u003e + 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sup\u003e] \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003eStr\u003c/i\u003e[\u003ci\u003eb\u003c/i\u003e], \u003ci\u003eDP\u003c/i\u003e[\u003ci\u003em\u003c/i\u003e] - \u003ci\u003eW\u003c/i\u003e[\u003ci\u003eb\u003c/i\u003e])\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eStr\u003c/i\u003e[\u003ci\u003eb\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e[\u003ci\u003eb\u003c/i\u003e]\u003c/span\u003e are the strength and weight of cow \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, respectively, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e is a bit that\u0027s off in the current mask \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e. Initially, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eDP\u003c/i\u003e[0] \u003d \u003ci\u003eINF\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eDP\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d  - \u003ci\u003eINF\u003c/i\u003e\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e in the range \u003cspan class\u003d\"tex-span\"\u003e[1, 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sup\u003e - 1]\u003c/span\u003e. Our answer will be the maximum among all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eDP\u003c/i\u003e[\u003ci\u003em\u003c/i\u003e]\u003c/span\u003e such that the sum of heights of all the cows included in mask \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e ≥ \u003ci\u003eH\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem 2 — Marathon:\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e be the distance to go from checkpoint \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/span\u003e to checkpoint \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e be the distance we save by skipping checkpoint \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e (that is, go from checkpoint \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/span\u003e to checkpoint \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e, skipping \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e). Naturally, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e[1]\u003c/span\u003e will be zero, as well as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e[1]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e[\u003ci\u003eN\u003c/i\u003e]\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003equerydist\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e be the sum of all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e in the range \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003equerysave\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e be the maximum among all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e in the range \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e, then to answer a \u0026quot;Q L R\u0026quot; query, we would do \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003equerydist\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e + 1, \u003ci\u003er\u003c/i\u003e) - \u003ci\u003equerysave\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e + 1, \u003ci\u003er\u003c/i\u003e - 1)\u003c/span\u003e. We can manage these queries with a segment tree with two satellite data in each node.\u003c/p\u003e\u003cp\u003eFinally, when we receive an update query to checkpoint \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, we would need to properly update data for checkpoints \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/span\u003e through \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem 3 — Cow Jog:\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe first thing we must think about is \u0026quot;When do two cows cross each other if they are on the same lane?\u0026quot;. They will cross when one cow\u0027s starting point is behind the other cow\u0027s, but its finishing point is farther than the other cow\u0027s. That is, if we represent the cows\u0027 covered points with a segment, one cow\u0027s segment will be completely contained within the other cow\u0027s segment.\u003c/p\u003e\u003cp\u003eNow, how do we know exactly how many lanes we will need? Well, let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e be the lane that cow \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e runs in. Initially, we set all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e to 0 and then we process all cows by starting point in the following way: Suppose we\u0027re currently processing cow \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e and the current cow\u0027s segment is completely contained within some other cows\u0027 segments. Among all those other cows, let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e be the maximum of all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e. Then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e[\u003ci\u003ec\u003c/i\u003e] \u003d \u003ci\u003em\u003c/i\u003e + 1\u003c/span\u003e. If the current cow\u0027s segment is not contained in any other segment, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e will be zero.\u003c/p\u003e\u003cp\u003eAnother thing we must deal with is how to calculate those values efficiently. We can do it with a BIT or a Segment Tree after compressing the finishing points of all cows (BIT is probably the easiest way). Since the cows will be processed by starting point, when we process cow \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e, we know that all segments we\u0027ve encountered so far, will have a starting point lower than the current cow\u0027s segment, so all we need to worry about is their ending points and the lanes they are assigned. We can have a Range Maximum Query using a BIT that stores the maximum lane number for each segment ending point. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003equery\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e be the maximum lane number for all segments which have an ending point equal or higher than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eupdate\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003el\u003c/i\u003e)\u003c/span\u003e be the update routine to set ending point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to lane \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e in the BIT. Then to process a certain cow \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e, all we must do is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eupdate\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e, \u003ci\u003equery\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e) + 1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFinally, our answer will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003equery\u003c/i\u003e(1)\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e","tags":[]}}