{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1412628611,"rating":85,"authorHandle":"tacklemore","modificationTimeSeconds":1412748851,"id":14145,"title":"\u003cp\u003eAn O(n) solution of Codeforces #271 E\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eFirst let\u0027s write a naive O(n^2) dynamic programming :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (int i \u003d 1; i \u0026lt;\u003d n; i++) {\n\td[i] \u003d 1;\n\tfor (int j \u003d 1; j \u0026lt; i; j++) \n\t  if (abs(a[i] - a[j]) \u0026gt;\u003d k \u0026amp;\u0026amp; d[j] + 1 \u0026gt; d[i]) \n\t     d[i] \u003d d[j] + 1;\n}\n\u003c/code\u003e\u003c/pre\u003e \u003cp\u003e Array d can be splitted into blocks(same value of d[i]). Let\u0027s consider second sample test, for example. \u003cbr /\u003e h \u003d [2, 1, 3, 6, 9, 11, 7, 3, 20, 18] \u003cbr /\u003e d \u003d [1, 1, 1, 2, 3, 3, 4, 5, 6, 6] \u003cbr /\u003e Blocks: \u003cbr /\u003e h: |2 1 3| 6| 9 11| 7| 3| 20 18| \u003cbr /\u003e d: |1 1 1| 2 | 3 3| 4| 5| 6 6|. \u003cbr /\u003e \u003c/p\u003e\u003cp\u003eHow can we optimize our DP? Well, after drawing samples on the paper one can notice that we are interested \u003cb\u003e only in two largest blocks \u003c/b\u003e (two blocks that have \u003cb\u003e the largest value of d \u003c/b\u003e) at every moment (I will call them first and second). Let me show you exactly what I mean. We want to calculate d[i]. How can we do it? We either jump from the pillar that belongs to \u003cb\u003e second \u003c/b\u003e block and then d[i] is d[second] + 1 or we jump from the pillar of the \u003cb\u003e first \u003c/b\u003e block and d[i] \u003d d[first] + 1 which equals to d[second]. But there is one more option. What if we can\u0027t get to i-th pillar from the two largest blocks..? Then we say we aren\u0027t interested in calculating d[i] because it is less than the values of d in our blocks. It can be strictly proved that we can avoid jumping to the i-th pillar, but take pillars from our blocks instead, by ananlyzing cases(h[i] is the largest among two blocks, smallest or inbetween).\u003cbr /\u003eSo, the question is how can we check whether we can jump from the block to the current pillar. Just keep two variables id1 and id2 for every block, where id1 is position of the minima(smallest height) and maxima position in the block. After processing i-th pillar update id\u0027s. \u003c/p\u003e\u003cp\u003eThere\u0027s a tricky case when d \u003d 0(I was a bit surprised when I got ML 83 on the contest, lol ), then the answer in n. Hope you liked the solution. Good luck! \u003d) \u003c/p\u003e\u003c/div\u003e","tags":[]}}