{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1520900317,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1525463247,"id":58337,"title":"\u003cp\u003eСтруктуры данных (Collection API)\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eМассивы, конечно, являются достаточно мощным инструментом, позволяющим организовать хранение данных. Однако современные языки программирования (и в том числе Java) содержат более гибкие конструкции. В Java их обычно называют коллекциями.\u003c/p\u003e\u003cp\u003eЗадачи на использование коллекций — \u003ca href\u003d\"//codeforces.com/group/vttlHWo2Li/contest/101756\"\u003eздесь\u003c/a\u003e. Упорядочение по сложности присутствует, хотя местами не гарантируется. Возможно, имеет смысл ознакомиться со следующим блогом, описывающим работу с большими объемами входных и выходных данных. \u003cbr /\u003e\u003c/p\u003e\u003ch4\u003eКоллекции\u003c/h4\u003e\u003cp\u003eПод коллекцией будем понимать некоторое хранилище данных, обладающее (по меньшей мере) следующими возможностями:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eв (существующую) коллекцию можно добавлять элементы;\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eиз (существующей) коллекции можно удалять элементы;\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eвсе элементы коллекции могут быть перечислены (в каком-либо порядке);\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eколлекция может сообщить, сколько в ней содержится элементов (или то, что она пуста);\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eколлекция может сообщить, содержится ли в ней некоторый элемент.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eНа самом деле этот список не полон, однако для наших целей его пока хватит. \u003c/p\u003e\u003cp\u003eЕщё в самой первой версии языка (1.0) существовали классы Vector (и его наследник Stack) и Hashtable, которые позволяли решать разные задачи хранения и обработки данных. Однако уже в версии 1.2 появился значительно более продуманный набор классов, получивший название Java Collection Framework, который постепенно пополняется. Именно эти классы и рекомендуется использовать; классы \u003ccode\u003eVector\u003c/code\u003e и \u003ccode\u003eHashtable\u003c/code\u003e в этот набор включены не были из-за наличия кода, необходимого для поддержания совместимости с ранними версиями. \u003c/p\u003e\u003cp\u003eВпрочем, и \u0026quot;старые\u0026quot;, и \u0026quot;новые\u0026quot; классы умели хранить в себе только объекты класса Object. Конечно, поскольку класс Object является предком всех классов в Java, в коллекции можно было помещать любые объекты. Однако при обращении к элементу из коллекции было необходимо вручную выполнять приведение его типа к фактическому. Помимо того, что это выглядело \u0026quot;некрасиво\u0026quot;, в коллекцию могли попасть объекты разных типов, и приведение типа могло послужить причиной ошибки, возникающей во время выполнения.\u003c/p\u003e\u003cp\u003eЭта проблема стала решаться в Java 1.5. Начиная с этой версии Java все классы-коллекции стало возможным параметризовывать теми или иными типами (в настоящий момент параметризация допускается практически везде, где это возможно), что улучшило качество кода. Правда, опять же с целью совместимости с уже существующим кодом, параметризация реализована так, что \u0026quot;в глубинах кода\u0026quot; информация о типах теряется (и это делает невозможным некоторые \u0026quot;естественно выглядящие\u0026quot; действия). Тем не менее, для большинства задач реализация может считаться вполне удовлетворительной. \u003c/p\u003e\u003cp\u003eJava Collection Framework (JCF) посвящен \u003ca href\u003d\"http://docs.oracle.com/javase/tutorial/collections/index.html\"\u003eотдельный раздел\u003c/a\u003e Tutorials. Настоятельно рекомендуется обращаться не только к документации по конкретным классам, но и к этому ресурсу (как минимум, в нём вы найдете весьма содержательные примеры). \u003c/p\u003e\u003cp\u003eНо прежде, чем мы перейдем к рассмотрению классов, сделаем небольшое отступление. Нам потребуется понятие интерфейса, с которым мы пока еще не сталкивались. В дальнейшем мы будем довольно подробно изучать внутреннее устройство и классов, и интерфейсов, а пока ограничимся пояснением (и чуть позже — прокомментированными примерами).\u003c/p\u003e\u003cp\u003eСлово \u0026quot;интерфейс\u0026quot; является многозначным. Например, принято говорить о \u0026quot;пользовательском интерфейсе\u0026quot;, \u0026quot;графическом интерфейсе\u0026quot;, \u0026quot;аппаратном интерфейсе\u0026quot;... Интерфейс USB (вероятно, всем знакомый) позволяет подключать к компьютеру самые разные устройства — и модули памяти (флеш-карты), и устройства ввода (мыши, клавиатуры и т.п.), и устройства вывода (принтеры), и многое другое. Устройство должно \u0026quot;просто\u0026quot; иметь штекер, который вставляется в соответствующий разъем, а уж какие задачи оно будет решать при взаимодействии с компьютером — зависит от реализации. \u003c/p\u003e\u003cp\u003eИнтерфейсы в программировании имеют похожее назначение: их задача — предоставить \u0026quot;протокол общения\u0026quot;, не вдаваясь в детали реализации. Т.е. в интерфейсе содержатся заголовки методов, а классы, реализующие этот интерфейс, обязаны реализовать все его методы. Интерфейс гарантирует универсальность: одинаковые названия методов, одинаковый набор и порядок аргументов в них. При реализации интерфейсы (как и классы) могут быть параметризованы.\u003c/p\u003e\u003cp\u003eВ JCF каждый из классов реализует либо один из интерфейсов-наследников интерфейса \u003ccode\u003eCollection\u003c/code\u003e (а именно, \u003ccode\u003eList\u003c/code\u003e, \u003ccode\u003eQueue\u003c/code\u003e, \u003ccode\u003eDeque\u003c/code\u003e, \u003ccode\u003eSet\u003c/code\u003e или \u003ccode\u003eSortedSet\u003c/code\u003e, который наследует \u003ccode\u003eSet\u003c/code\u003e), либо интерфейс Map или его интерфейс-наследник \u003ccode\u003eSortedMap\u003c/code\u003e. \u003ca href\u003d\"https://docs.oracle.com/javase/tutorial/collections/implementations/index.html\"\u003eЗдесь\u003c/a\u003e можно посмотреть таблицу, демонстрирующую, какие интерфейсы какими коллекциями реализуются (в этой таблице перечислены все доступные в настоящий момент коллекции).\u003c/p\u003e\u003cp\u003eПриведем краткий обзор некоторых структур данных, являющихся коллекциями.\u003c/p\u003e\u003cp\u003e\u003ccode\u003eArrayList\u003c/code\u003e реализует интерфейс \u003ccode\u003eList\u003c/code\u003e и может пониматься как динамический массив, поскольку допускает добавление и удаление элементов. С обычным массивом проделать такое нельзя, можно только выделить память заново (с помощью оператора \u003ccode\u003enew\u003c/code\u003e), при этом уже имеющиеся элементы не будут сохранены. Конечно, нужно понимать, что добавление элемента в динамический массив или удаление элемента из динамического массива сопряжено с определенными накладными расходами. Поэтому частое обращение к этим операциям может привести к замедлению работы программы. В документации \u003ca href\u003d\"https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html\"\u003eговорится\u003c/a\u003e, что операция добавления выполняется за \u003cem\u003eамортизированное константное время\u003c/em\u003e (т.е. на добавление \u003ccode\u003en\u003c/code\u003e элементов будет затрачено время порядка \u003ccode\u003eO(n)\u003c/code\u003e, но время добавления для конкретного элемента может находиться в диапазоне от 0 до этой величины). Обращение к элементу, хранящемуся в \u003ccode\u003eArrayList\u003c/code\u003e, осуществляется за константное время (как и в случае обычного массива).\u003c/p\u003e\u003cp\u003e\u003ccode\u003eLinkedList\u003c/code\u003e реализует два интерфейса — упоминавшийся выше интерфейс \u003ccode\u003eList\u003c/code\u003e и интерфейс \u003ccode\u003eDeque\u003c/code\u003e. Однако внутри он устроен совсем не так, как \u003ccode\u003eArrayList\u003c/code\u003e: де-факто \u003ccode\u003eLinkedList\u003c/code\u003e является двусвязным списком, что обеспечивает быстрое удаление и добавление элементов. Однако любые операции, требующие обращения к элементу по индексу, будут приводить к последовательному просмотру списка с начала или с конца (в отличие от \u003ccode\u003eArrayList\u003c/code\u003e). Такие операции могут сильно замедлить работу вашей программы. Интерфейс \u003ccode\u003eDeque\u003c/code\u003e также допускает добавление и удаление элементов, но только в конец или начало списка. Но есть и неэффективные операции: удаление некоторого (конкретного) элемента, удаление первого (или последнего) вхождения некоторого элемента, проверка наличия элемента. \u003c/p\u003e\u003cp\u003eУлучшенной версией реализации интерфейса \u003ccode\u003eDeque\u003c/code\u003e является класс \u003ccode\u003eArrayDeque\u003c/code\u003e, который большинство операций выполняет за амортизированное константное время; исключение составляют некоторые операции удаления и массовые операции (\u003ca href\u003d\"https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html\"\u003eдокументация\u003c/a\u003e). Обратите внимание, что интерфейс \u003ccode\u003eList\u003c/code\u003e этот класс не поддерживает (так что способа обратиться к элементу по индексу в нем попросту нет). Однако, поскольку частой ситуацией является именно добавление и удаление элементов в конец (или начало) списка (при организации стека или очереди, например), то возможность обращаться к произвольному элементу списка может быть излишней и вполне компенсируется быстродействием. \u003c/p\u003e\u003cp\u003e\u003ccode\u003eTreeSet\u003c/code\u003e по своей сути упорядоченное множество. В нем могут храниться элементы, для которых определена операция сравнения (т.е. про любые два элемента того типа, которым параметризовано множество, можно сказать, что один больше другого, один меньше другого или же один равен другому). Для ряда предопределенных классов (в частности, \u003ccode\u003eInteger\u003c/code\u003e, \u003ccode\u003eString\u003c/code\u003e) операции сравнения определены. Если же вы будете хранить в множестве объекты класса, определенного вами, то либо ваш класс должен реализовывать интерфейс \u003ccode\u003eComparable\u003c/code\u003e, либо при создании экземпляра \u003ccode\u003eTreeSet\u003c/code\u003e ему следует передать компаратор (экземпляр класса \u003ccode\u003eComparator\u003c/code\u003e), который обеспечит корректное сравнение элементов. \u003c/p\u003e\u003cp\u003eИ операции добавления, и операции доступа к элементам имеют асимптотику \u003ccode\u003eO(log n)\u003c/code\u003e (внутри \u003ccode\u003eTreeSet\u003c/code\u003e в действительности лежит \u003ccode\u003eTreeMap\u003c/code\u003e, реализованный как красно-черное дерево). Заметим, что метод \u003ccode\u003eadd\u003c/code\u003e, добавляющий элемент в множество, возвращает логическое значение: \u003ccode\u003etrue\u003c/code\u003e, если элемент был добавлен, и \u003ccode\u003efalse\u003c/code\u003e, если такой элемент в множестве уже присутствовал. \u003c/p\u003e\u003cp\u003e\u003ccode\u003eHashSet\u003c/code\u003e также является множеством, но порядок элементов в нем не гарантирован (подобно \u003ccode\u003eTreeSet\u003c/code\u003e внутри \u003ccode\u003eHashSet\u003c/code\u003e лежит \u003ccode\u003eHashMap\u003c/code\u003e, реализованный посредством хеш-таблиц). Чтобы хранить объекты в \u003ccode\u003eHashSet\u003c/code\u003e, достаточно уметь отвечать на вопрос, равны они или нет (т.е. достаточно подходящей реализации метода \u003ccode\u003eequals()\u003c/code\u003e; впрочем, изменение \u003ccode\u003eequals()\u003c/code\u003e влечет за собой необходимость переопределить и \u003ccode\u003ehashCode()\u003c/code\u003e). Реализация \u003ccode\u003eHashSet\u003c/code\u003e обеспечивает для базовых операций (обращение к элементу и помещение элемента в множество) константное время выполнения; так что при прочих равных \u003ccode\u003eHashSet\u003c/code\u003e будет работать быстрее, нежели \u003ccode\u003eTreeSet\u003c/code\u003e (и если упорядоченность элементов не требуется, разумно предпочесть именно эту реализацию множества).\u003c/p\u003e\u003cp\u003e\u003ccode\u003eTreeMap\u003c/code\u003e, уже упоминавшийся в связи с \u003ccode\u003eTreeSet\u003c/code\u003e, представляет собой коллекцию, хранящую пары \u003cem\u003e(ключ, значение)\u003c/em\u003e , упорядоченные по ключу. Ключ должен быть уникальным: \u003ccode\u003eTreeMap\u003c/code\u003e не может содержать две (или более) пары с одинаковыми ключами. Одинаковые значения допустимы в любых количествах. Тип ключа в \u003ccode\u003eTreeMap\u003c/code\u003e должен допускать сравнение значений: для двух значений этого типа должно быть всегда возможно установить, какое из них при упорядочении должно встретиться раньше, а какое позже (или же что они равны). Это значит, что для ключей либо должен быть реализован интерфейс \u003ccode\u003eComparable\u003c/code\u003e, либо при создании \u003ccode\u003eTreeMap\u003c/code\u003e потребуется указать компаратор, обеспечивающий сравнение ключей.\u003c/p\u003e\u003cp\u003e\u003ccode\u003eHashMap\u003c/code\u003e также хранит пары \u003cem\u003e(ключ, значение)\u003c/em\u003e , однако эти пары не являются упорядоченными. Ключ, как и в \u003ccode\u003eTreeMap\u003c/code\u003e, должен быть уникальным, но достаточно уметь устанавливать для двух ключей, равны они или различны (т.е. (пере)определить метод \u003ccode\u003eequals\u003c/code\u003e). \u003c/p\u003e\u003cp\u003eОбратите внимание, что ни \u003ccode\u003eTreeMap\u003c/code\u003e, ни \u003ccode\u003eHashMap\u003c/code\u003e, ни основанные на них коллекции-множества, не могут сообщать информацию, на какой \u003cem\u003eпозиции\u003c/em\u003e находится тот или иной элемент. Однако с задачей перечисления всех содержащихся в них элементов эти коллекции отлично справляются (а \u003ccode\u003eTreeMap\u003c/code\u003e / \u003ccode\u003eTreeSet\u003c/code\u003e еще и перечислят все элементы в заданном порядке ключей).\u003c/p\u003e\u003cp\u003eКраткое представление о коллекциях может дать также \u003ca href\u003d\"https://compscicenter.ru/media/slides/java_2013_autumn/2013_10_21_java_2013_autumn.pdf\"\u003eпрезентация А.Владыкина\u003c/a\u003e.\u003c/p\u003e\u003ch4\u003eИнтерфейсы \u003ccode\u003eComparable\u003c/code\u003e и \u003ccode\u003eComparator\u003c/code\u003e\u003c/h4\u003e\u003cp\u003eИнтерфейс \u003ccode\u003eComparable\u003c/code\u003e содержит единственный метод \u003ccode\u003epublic int compareTo(T p)\u003c/code\u003e, где \u003ccode\u003eT\u003c/code\u003e — тип, параметризующий интерфейс, а параметр \u003ccode\u003ep\u003c/code\u003e — объект этого типа. Сравнение производится с текущим объектом, возвращены могут быть значения \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e — если текущий объект следует считать предшествующим \u003ccode\u003ep\u003c/code\u003e, \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e — если, напротив, объект \u003ccode\u003ep\u003c/code\u003e должен предшествовать текущему объекту, и \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e — если объекты считаются равными.\u003c/p\u003e\u003cp\u003eПриведем примеры работы с интерфейсом \u003ccode\u003eComparable\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eПусть имеется класс \u003ccode\u003ePoint\u003c/code\u003e, описывающий точку с целочисленными координатами на плоскости. Предположим, что нужно упорядочить точки по координате \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e (от меньшей к большей), а при равенстве координат \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e — по координате \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, но в обратном направлении — от большей к меньшей. Реализуем в этом классе интерфейс \u003ccode\u003eComparable\u003c/code\u003e, позволяющий упорядочить точки именно так.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass Point implements Comparable\u0026lt;Point\u0026gt;{\n    int x;\n    int y;\n  \n    Point(int x, int y) {\n        this.x \u003d x;\n        this.y \u003d y;\n    }\n\n    public int compareTo(Point p) {\n        if (x \u0026lt; p.x) return -1;\n        if (x \u0026gt; p.x) return 1;\n        if (y \u0026gt; p.y) return -1;\n        if (y \u0026lt; p.y) return 1;\n        return 0;\n    }\n\n    public String toString() {\n        return \u0026quot;(\u0026quot; + x + \u0026quot;, \u0026quot; + y + \u0026quot;)\u0026quot;;\n    }\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЕсли теперь мы опишем множество точек как \u003ccode\u003eTreeSet\u0026lt;Point\u0026gt;\u003c/code\u003e, то при итерировании по нему получим точки именно в описанном порядке.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eTreeSet\u0026lt;Point\u0026gt; tsp \u003d new TreeSet\u0026lt;\u0026gt;();\n\ntsp.add(new Point(5, 3));\ntsp.add(new Point(-4, 8));\ntsp.add(new Point(0, -2));\ntsp.add(new Point(7, 5));\ntsp.add(new Point(0, 3));\ntsp.add(new Point(-4, -11));\ntsp.add(new Point(0, 0));\n\nfor (Point pt: tsp) {\n    System.out.println(pt);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВывод:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e(-4, 8)\n(-4, -11)\n(0, 3)\n(0, 0)\n(0, -2)\n(5, 3)\n(7, 5)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eИнтерфейс \u003ccode\u003eComparator\u003c/code\u003e также содержит единственный метод. Это метод \u003ccode\u003epublic int compare(T p1, T p2)\u003c/code\u003e, где \u003ccode\u003eT\u003c/code\u003e — тип, параметризующий интерфейс, а \u003ccode\u003ep1\u003c/code\u003e и \u003ccode\u003ep2\u003c/code\u003e — объекты этого типа, для которых и определяется отношение предшествования. Если метод возвращает значение \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e, то объект \u003ccode\u003ep1\u003c/code\u003e предшествует объекту \u003ccode\u003ep2\u003c/code\u003e, если метод возвращает значение \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, то, напротив, объект \u003ccode\u003ep2\u003c/code\u003e предшествует объекту \u003ccode\u003ep1\u003c/code\u003e; наконец, если метод возвращает значение 0, объекты считаются равными. \u003c/p\u003e\u003cp\u003eПродемонстрируем, как можно использовать этот интерфейс. Опишем класс \u003ccode\u003ePoint2\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass Point2 {\n    int x;\n    int y;\n  \n    Point2(int x, int y) {\n        this.x \u003d x;\n        this.y \u003d y;\n    }\n\n    public String toString() {\n        return \u0026quot;(\u0026quot; + x + \u0026quot;, \u0026quot; + y + \u0026quot;)\u0026quot;;\n    }\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЕсли теперь мы напишем фрагмент кода, создающий множество (аналогичный фрагменту кода выше), то ни на этапе написания кода, ни даже на этапе компиляции ошибок выявлено не будет.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eTreeSet\u0026lt;Point2\u0026gt; tsp2 \u003d new TreeSet\u0026lt;\u0026gt;();\n\ntsp2.add(new Point2(5, 3));\ntsp2.add(new Point2(-4, 8));\ntsp2.add(new Point2(0, -2));\ntsp2.add(new Point2(7, 5));\ntsp2.add(new Point2(0, 3));\ntsp2.add(new Point2(-4, -11));\ntsp2.add(new Point2(0, 0));\n\nfor (Point pt: tsp) {\n    System.out.println(pt);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОднако при попытке запустить этот код на выполнение будет получено сообщение \u003ccode\u003ePoint2 cannot be cast to java.lang.Comparable\u003c/code\u003e. К ошибке приведет первый же вызов метода \u003ccode\u003eadd\u003c/code\u003e. Чтобы исправить ситуацию, опишем класс, реализующий интерфейс \u003ccode\u003eComparator\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eclass CmpPoints implements Comparator\u0026lt;Point2\u0026gt;{\n\t\n\tpublic int compare (Point2 p1, Point2 p2) {\n\t\tif (p1.x \u0026lt; p2.x) return -1;\n\t\tif (p1.x \u0026gt; p2.x) return 1;\n\t\tif (p1.y \u0026gt; p2.y) return -1;\n\t\tif (p1.y \u0026lt; p2.y) return 1;\n\t\treturn 0;\n\t}\n\t\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПри создании коллекции \u003ccode\u003etsp2\u003c/code\u003e передадим в качестве параметра экземпляр этого класса:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eTreeSet\u0026lt;Point2\u0026gt; tsp2 \u003d new TreeSet\u0026lt;\u0026gt;(new CmpPoints());\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЭто единственное изменение, которое потребуется внести, чтобы код выше стал работоспособным и выдавал на выходе те же результаты, что и код для класса \u003ccode\u003ePoint\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eЗаметим, что оба интерфейса — и \u003ccode\u003eComparable\u003c/code\u003e, и \u003ccode\u003eComparator\u003c/code\u003e — являются функциональными, что означает возможность использовать лямбда-выражения вместо их явной записи. Подробнее о функциональных интерфейсах и лямбда-выражениях мы будем говорить позже; впрочем, в примере решения задачи (ниже) мы покажем, как использовать лямбда-выражения вместо создания объекта класса, реализующего интерфейс \u003ccode\u003eComparator\u003c/code\u003e. \u003c/p\u003e\u003ch4\u003eКласс \u003ccode\u003eCollections\u003c/code\u003e\u003c/h4\u003e\u003cp\u003eВозможно, вы помните о классе \u003ccode\u003eArrays\u003c/code\u003e, содержащем ряд полезных методов для работы с массивами. Для коллекций также описан подобный класс — класс \u003ccode\u003eCollections\u003c/code\u003e, определяющий набор методов, которые могут быть применены к классам из \u003ccode\u003eCollections Framework\u003c/code\u003e. Рекомендуется ознакомиться с \u003ca href\u003d\"https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html\"\u003eдокументацией\u003c/a\u003e по этому классу.\u003c/p\u003e\u003cp\u003eМы упомянем лишь один метод — \u003ccode\u003eCollections.sort()\u003c/code\u003e, который может принимать в качестве своего параметра объект, реализующий интерфейс \u003ccode\u003eList\u003c/code\u003e (в этом случае сортировка происходит \u0026quot;от меньшего к большему в естественном порядке\u0026quot; — \u003ca href\u003d\"https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html\"\u003enatural ordering\u003c/a\u003e), либо наряду с объектом, реализующим интерфейс \u003ccode\u003eList\u003c/code\u003e, еще и объект, реализующий интерфейс \u003ccode\u003eComparator\u003c/code\u003e (который и обеспечивает упорядочение коллекции). \u003c/p\u003e\u003ch4\u003eПример работы с коллекциями\u003c/h4\u003e\u003cp\u003eЧтобы продемонстрировать работу с коллекциями, рассмотрим следующую задачу.\u003c/p\u003e\u003cp\u003e\u003cem\u003eЗадача \u0026quot;Зачет-2\u0026quot;\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eЕсть \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e студентов, планирующих сдать зачет. Для каждого студента \u003cspan class\u003d\"tex-span\"\u003e#\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e известен момент времени \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, в который он планирует прийти, и количество времени \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, которое ему потребуется на подготовку к ответу. Есть еще одно обстоятельство — готовиться к ответу студенты могут только в аудитории, а одновременно в аудитории может разместиться не более \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e человек. \u003c/p\u003e\u003cp\u003eПроцесс сдачи зачета происходит следующим образом: студент \u003cspan class\u003d\"tex-span\"\u003e#\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e приходит в момент времени \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e и либо заходит в аудиторию и начинает готовиться к ответу, либо ожидает возможности зайти в аудиторию. Студенты заходят в аудиторию в том порядке, в котором они приходили (т.е. если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sub\u003e \u0026lt; \u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sub\u003e\u003c/span\u003e, то студент \u003cspan class\u003d\"tex-span\"\u003e#\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e зайдет в аудиторию раньше студента \u003cspan class\u003d\"tex-span\"\u003e#\u003ci\u003ej\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e); если же одновременно пришли несколько студентов, то первым в аудиторию войдет студент с меньшим порядковым номером.\u003c/p\u003e\u003cp\u003eКогда студент оказывается в аудитории, он сразу приступает к подготовке ответа. Как только он закончил подготовку, он либо идет отвечать (если нет очереди и преподаватель не слушает другого студента), либо занимает очередь, чтобы идти отвечать. Студенты занимают очередь в том порядке, в котором они завершили подготовку. Если два (или больше) студента завершили подготовку одновременно, то первым займет очередь тот, кто раньше вошел в аудиторию.\u003c/p\u003e\u003cp\u003eБудем считать, что ответ студента занимает ровно одну единицу времени. \u003c/p\u003e\u003cp\u003eВаша задача — определить для каждого студента, в какой момент времени для него завершится сдача зачета (т.е. в какой момент он покинет аудиторию). \u003c/p\u003e\u003cp\u003e\u003cem\u003eВходные данные\u003c/em\u003e\u003c/p\u003e\u003cp\u003eВ первой строке содержатся целые числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e — количество студентов, планирующих сдать зачет, и максимальное количество студентов, которое помещается в аудитории.\u003c/p\u003e\u003cp\u003eВ каждой из следующих \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e строк содержится по два целых числа \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — момент времени, в который студент \u003cspan class\u003d\"tex-span\"\u003e#\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e планирует прийти, и количество времени, которое ему потребуется, чтобы подготовиться к ответу. \u003c/p\u003e\u003cp\u003e\u003cem\u003eВыходные данные\u003c/em\u003e\u003c/p\u003e\u003cp\u003eВыведите \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e целых чисел \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — момент времени, в который студент \u003cspan class\u003d\"tex-span\"\u003e#\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e покинет аудиторию.\u003c/p\u003e\u003cp\u003e\u003cem\u003eРешение\u003c/em\u003e\u003c/p\u003e\u003cp\u003eЧтобы получить ответ, нужно будет выполнить симуляцию процесса. Обсудим, какие структуры данных понадобятся для решения этой задачи. \u003c/p\u003e\u003cp\u003eНесложно понять, что выполнять симуляцию следует на упорядоченных входных данных (никаких гарантий относительно упорядоченности не дается, следовательно, рассчитывать на это нельзя). Получить упорядоченные входные данные можно, по крайней мере, двумя способами: во-первых, поместить все входные данные в список (или даже массив), а затем выполнить его сортировку, во-вторых, сразу помещать данные в сортирующую структуру (\u003ccode\u003eTreeSet\u003c/code\u003e / \u003ccode\u003eTreeMap\u003c/code\u003e). Мы воспользуемся первым способом, и вот почему. Сортирующая структура при помещении в нее очередного элемента (почти всегда) претерпевает изменения, перестройку, на которые требуется некоторое время. Список же формируется \u0026quot;как есть\u0026quot;, после чего его однократно сортируют. Разумеется, на сортировку также потребуется некоторое время, но чаще всего (эмпирическое наблюдение) количество перемещений элементов при этом будет меньшим. Поскольку после сортировки в наш список элементы более добавляться не будут, то этот подход может быть чуть эффективнее использования сортирующей структуры. Что же касается сортирующих структур, они уместны в ситуациях, когда операции над структурой данных перемежаются с добавлением / удалением элементов.\u003c/p\u003e\u003cp\u003eКак мы уже сказали, можно использовать список, а можно — массив. Разница в этом случае будет состоять в том, из какого класса будет вызываться метод \u003ccode\u003esort()\u003c/code\u003e: из \u003ccode\u003eCollections\u003c/code\u003e или из \u003ccode\u003eArrays\u003c/code\u003e. \u003c/p\u003e\u003cp\u003e\u003csmall\u003e Метод сортировки в обоих классах реализует алгоритм Timsort (его автор — Tim Peters), являющийся гибридным алгоритмом, использующим как идеи сортировки слияниями, так и идеи сортировки вставками. Однако реализацией алгоритма в классе \u003ccode\u003eCollections\u003c/code\u003e и в классе \u003ccode\u003eArrays\u003c/code\u003e занимались разные команды. Метод сортировки в классе \u003ccode\u003eArrays\u003c/code\u003e был реализован с недочетами, и можно подобрать такую последовательность данных, которая \u0026quot;заставит\u0026quot; этот метод работать долго (квадратичное по отношению к количеству элементов время). Сразу оговоримся, что найти такую последовательность совсем не просто; более того, например, последовательность, приводящая к неэффективному поведению метода в Java 1.6, отличается от последовательности, приводящей к неэффективному поведению метода в Java 1.7 (баг пытаются исправить, но пока он существует). Проблем с реализацией метода сортировки в классе \u003ccode\u003eCollections\u003c/code\u003e не наблюдается, и это один из доводов за его использование. \u003c/small\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class DemoExam {\n\n\tpublic static void main(String[] args) {\n\t\tExam exam \u003d new Exam();\n\t\texam.prepare();\n\t\texam.solve();\n\t\texam.print();\n\t}\n\n}\n\nclass Exam {\n\t\n\tstatic class Student {\n\t\t\n\t\tStudent(int num, int t, int p){\n\t\t\tthis.num \u003d num;\n\t\t\tthis.t \u003d t;\n\t\t\tthis.p \u003d p;\n\t\t\tat \u003d -1;\n\t\t\tf \u003d -1;\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\treturn \u0026quot;[\u0026quot; + num + \u0026quot;: \u0026quot; + t + \u0026quot; -\u0026gt; \u0026quot; + at + \u0026quot; (\u0026quot; + p + \u0026quot;) \u0026quot; + \u0026quot; -\u0026gt; \u0026quot; + f + \u0026quot;]\u0026quot;;\n\t\t}\t\t\t\t\n\t\t\n\t\tint num;\n\t\tlong t;\n\t\tint p;\n\t\tlong at; // time in aud.\n\t\tlong f;\n\t}\n\t\n\tExam() {\n\t\tin \u003d new Scanner(System.in);\n\t\tn \u003d in.nextInt();\n\t\tk \u003d in.nextInt();\n\t\tsts \u003d new ArrayList\u0026lt;\u0026gt;(n);\n\t\tfor (int i \u003d 0; i \u0026lt; n; i++) {\n\t\t\tint t \u003d in.nextInt();\n\t\t\tint p \u003d in.nextInt();\n\t\t\tsts.add(new Student(i+1, t, p));\n\t\t}\n\t\tin.close();\n\t}\n\t\n\tvoid prepare() {\n\t\tCollections.sort(sts, (s1, s2) -\u0026gt; {\n\t\t\tif (s1.t \u0026lt; s2.t) return -1;\n\t\t\tif (s1.t \u0026gt; s2.t) return 1;\n\t\t\tif (s1.num \u0026lt; s2.num) return -1;\n\t\t\tif (s1.num \u0026gt; s2.num) return 1;\n\t\t\treturn 0;\n\t\t});\n\t}\n\t\n\tvoid solve() {\n\t\tTreeSet\u0026lt;Student\u0026gt; tss \u003d new TreeSet\u0026lt;\u0026gt;((s1, s2) -\u0026gt;  {\n\t\t\tif (s1.at + s1.p \u0026lt; s2.at + s2.p) return -1;\n\t\t\tif (s1.at + s1.p \u0026gt; s2.at + s2.p) return 1;\n\t\t\tif (s1.at \u0026lt; s2.at) return -1;\n\t\t\tif (s1.at \u0026gt; s2.at) return 1;\n\t\t\tif (s1.num \u0026lt; s2.num) return -1;\n\t\t\tif (s1.num \u0026gt; s2.num) return 1;\n\t\t\treturn 0;\n\t\t});\n\t\t\n\t\tfin \u003d new ArrayList\u0026lt;\u0026gt;(n);\n\t\ttimer \u003d 0;\n\t\t\n\t\tfor (Student s: sts) {\n\t\t\tif (tss.size() \u0026lt; k) {\n\t\t\t\ts.at \u003d s.t;\n\t\t\t\ttss.add(s);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tStudent sout \u003d tss.pollFirst();\n\t\t\t\tsout.f \u003d sout.at + sout.p;\n\t\t\t\tif (sout.f \u0026lt; timer) {\n\t\t\t\t\tsout.f \u003d timer;\n\t\t\t\t}\n\t\t\t\tsout.f +\u003d 1;\n\t\t\t\ttimer \u003d sout.f;\n\t\t\t\tfin.add(sout);\n\t\t\t\t\n\t\t\t\ts.at \u003d Math.max(s.t, timer);\n\t\t\t\ttss.add(s);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (Student sout: tss) {\t\t\t\n\t\t\tsout.f \u003d sout.at + sout.p;\n\t\t\tif (sout.f \u0026lt; timer) {\n\t\t\t\tsout.f \u003d timer;\n\t\t\t}\n\t\t\tsout.f +\u003d 1;\n\t\t\ttimer \u003d sout.f;\n\t\t\tfin.add(sout);\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tvoid print() {\n\t\tCollections.sort(fin, (s1, s2) -\u0026gt; {\n\t\t\tif (s1.num \u0026lt; s2.num) return -1;\n\t\t\tif (s1.num \u0026gt; s2.num) return 1;\n\t\t\treturn 0;\n\t\t});\n\t\t\n\t\tfor (Student s: fin) {\n\t\t\tSystem.out.println(s.f);\n\t\t}\n\t}\n\t\n\tlong timer;\n\tint n;\n\tint k;\n\tArrayList\u0026lt;Student\u0026gt; sts;\n\tArrayList\u0026lt;Student\u0026gt; fin;\n\t\n\tScanner in;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eКраткие комментарии к решению\u003c/em\u003e\u003c/p\u003e\u003cp\u003eСписок \u003ccode\u003ests\u003c/code\u003e изначально заполняется сведениями о студентах в порядке их упоминания в исходных данных. Затем (в методе \u003ccode\u003eprepare()\u003c/code\u003e выполняется сортировка согласно описанию в условии задачи (в аудиторию раньше будет заходить тот, кто раньше пришел; если студенты пришли одновременно — тот, у кого меньше порядковый номер).\u003c/p\u003e\u003cp\u003eВ методе \u003ccode\u003esolve()\u003c/code\u003e создается множество с компаратором, обеспечивающим порядок отвечающих студентов (тот, кто раньше подготовился, раньше идет отвечать; из подготовившихся одновременно раньше пойдет отвечать тот, кто раньше вошел в аудиторию; если же студенты одновременно вошли в аудиторию и одновременно завершили подготовку к ответу, раньше пойдет отвечать тот, у кого меньше порядковый номер).\u003c/p\u003e\u003cp\u003eЗатем осуществляется перебор студентов в порядке их прихода (именно в таком порядке сейчас содержит их список \u003ccode\u003ests\u003c/code\u003e). При выборке очередного студента из списка \u003ccode\u003ests\u003c/code\u003e выполняется проверка, имеются ли еще свободные места в аудитории. Если такие места есть, то очередной студент сразу отправляется в аудиторию (и время его входа в аудиторию равно времени его прихода). Если же мест в аудитории нет, то нужно определить первого, кто выйдет из аудитории. Компаратор, с которым было создано множество, обеспечивает корректное формирование очереди внутри аудитории. Поэтому достаточно извлечь \u0026quot;первый\u0026quot; элемент множества.\u003c/p\u003e\u003cp\u003eОднако, поскольку каждый студент отвечает ненулевое время, нельзя просто посчитать момент его выхода из аудитории как сумму момента времени, в который он вошел в аудиторию, и количества времени, которое он готовился к ответу: вполне возможно, он ожидал, пока ответят другие студенты. Контроль времени с учетом такой задержки осуществляется с помощью переменной \u003ccode\u003etimer\u003c/code\u003e. В этой переменной хранится момент времени, в который последний из уже сдавших зачет студентов покинул аудиторию. Как понятно, это наиболее ранний момент времени, в который очередной студент сможет пойти отвечать. Поэтому, если студент подготовился раньше, ему придется подождать именно до этого момента. \u003c/p\u003e\u003cp\u003eПосле того как очередной сдавший зачет студент покинул аудиторию, в нее может войти очередной ожидающий студент. Время его входа в аудиторию будет максимумом из двух величин — момента времени, в который он пришел, и момента времени, когда из аудитории вышел очередной сдавший зачет студент.\u003c/p\u003e\u003cp\u003e\u003csmall\u003e \u003ci\u003e Можно было не вводить переменную \u003ccode\u003etimer\u003c/code\u003e и обращаться к полю \u003ccode\u003ef\u003c/code\u003e последнего объекта в списке \u003ccode\u003efin\u003c/code\u003e; это решение несколько неудобно тем, что первоначально список \u003ccode\u003efin\u003c/code\u003e пуст, и либо нужно добавить в него фиктивный объект, либо обойти эту ситуацию с помощью соответствующего условия. \u003c/i\u003e \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e \u003ci\u003e Список \u003ccode\u003efin\u003c/code\u003e, вообще говоря, является \u0026quot;лишним\u0026quot;. Поскольку и в списке \u003ccode\u003ests\u003c/code\u003e, и в множестве \u003ccode\u003etss\u003c/code\u003e, и в списке \u003ccode\u003efin\u003c/code\u003e фигурируют одни и те же объекты, то для получения ответа достаточно отсортировать нужным образом исходный список \u003ccode\u003ests\u003c/code\u003e. \u003c/i\u003e \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003eПример входных данных\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e14 5\n120 10\n50 30\n10 40\n20 30\n25 55\n40 40\n100 5\n100 25\n90 35\n120 10\n95 25\n90 40\n105 25\n110 15\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eПример выходных данных\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e138\n83\n51\n52\n81\n82\n106\n127\n126\n139\n121\n131\n132\n137\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКонечно, приведенный выше код не является единственно возможным решением, существуют и другие способы.\u003c/p\u003e\u003c/div\u003e","tags":["java","collections"]}}