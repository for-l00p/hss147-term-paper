{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1488195924,"rating":16,"authorHandle":"drazil","modificationTimeSeconds":1488196496,"id":50707,"title":"\u003cp\u003eWeekly training farm 23 editorial (drazil part)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eSorry for the delay but here is the (partial) editorial of 23rd weekly training farm.\u003c/p\u003e\u003cp\u003eI set up \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e problems (B, E, F) in this contest.\u003c/p\u003e\u003cp\u003eHere is the link to the contest: \u003ca href\u003d\"//codeforces.com/group/gRkn7bDfsN/contest/211543\"\u003ehttp://codeforces.com/group/gRkn7bDfsN/contest/211543\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003c/p\u003e\u003cp\u003eB. cut down\u003c/p\u003e\u003cp\u003eThe idea of the problem is from this deep learning paper: Martins, André FT, and Ramón Fernandez Astudillo. \u0026quot;From softmax to sparsemax: A sparse model of attention and multi-label classification.\u0026quot; CoRR, abs/1602.02068 (2016). You can read the paper here: \u003ca href\u003d\"https://arxiv.org/abs/1602.02068\"\u003ehttps://arxiv.org/abs/1602.02068\u003c/a\u003e\u003c/p\u003e\u003cp\u003eYou can use binary search to find the answer in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/44/4f/444f5650f8f9de80540894d0bf33cb667ec90df3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time. But what if I ask you to output the exact answer (in the form of division of two integers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e / \u003ci\u003eq\u003c/i\u003e\u003c/span\u003e) instead of a floating point number? That problem can be solved in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/44/4f/444f5650f8f9de80540894d0bf33cb667ec90df3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time, too! Actually, if the input is sorted, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e time is sufficient for the problem!\u003c/p\u003e\u003cp\u003eLet\u0027s consider a simplified problem first, can you check if there is a valid \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e satisfying \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e \u0026lt; \u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e? The solution is to assume that such \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e exists which implies \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/7b/327bd776db68859dfc3a577064fc020a6fe92fcd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, then verify if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e is less than the smallest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTo solve the original problem, we need one more observation: After sorting \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e in descending order, we have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/01/ea/01eae54999862cc1e5e7ac715b93ba01c7e18b6e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is the largest number that the above simplified problem is true. So we can maintain a partial sum to find the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e and the answer in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e time after sorting.\u003c/p\u003e\u003cp\u003eFurthermore, the original problem can be solved in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e time overall (even with unsorted input) using linear selection algorithm!\u003c/p\u003e\u003cp\u003eE. tree split\u003c/p\u003e\u003cp\u003eThis problem is equivalent to: Is there a way to remove some edges in a tree so that the remaining forest is consists of \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e vertices trees?\u003c/p\u003e\u003cp\u003eRemoving an edge in the given tree splits all vertices into two trees. Let\u0027s denote the number of the vertices in the two resulting trees as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e. The key observation is that if both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e is a multiple of \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e for an edge, then this edge needs to be removed. Moreover, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e is a multiple of \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e must be a multiple of \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e! So a dfs on the vertices maintaining the number of visited vertices can count the number of edges to remove in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e time.\u003c/p\u003e\u003cp\u003eFinally, we just need to check if removing those edges will result in a forest of exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e trees. This can be assured if the number of edges removed is equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eF. Strings\u003c/p\u003e\u003cp\u003eThe key observation is that although we allow indirect comparison, direct comparisons is still required for every pair of vocabularies to ensure a unique order. In addition, to compare two strings we just need to define the order of the first different character of the two strings. So we can brute force every pair of vocabularies and find out the set of the characters need to be defined in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e time. The size of such set would be the answer since any permutation of this set of characters would work.\u003c/p\u003e\u003c/div\u003e","tags":[]}}