{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1465808031,"rating":41,"authorHandle":"Endagorion","modificationTimeSeconds":1465826220,"id":45395,"title":"\u003cp\u003eYandex.Algorithm 2016, third elimination round editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI hope you\u0027ve enjoyed the problems! Please ask your questions and report flaws in the comments.\u003c/p\u003e\u003ch3\u003eProblem A\u003c/h3\u003e\u003cp\u003eFirst insight is that two spells are always enough. Why? Let\u0027s freeze all leftbound penguins at point \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e - 9\u003c/sup\u003e\u003c/span\u003e and all rightbound penguins at point \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSo the only problem is to determine when only one spell is enough. If that holds, there should exist a point which all penguins will cross at some moment. Let\u0027s put this point at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003c/sub\u003e + \u003c/span\u003e~--- rightmost point among penguins\u0027 coordinates which run to the right. Now all rightbound penguins will cross this point. If there is a leftbound penguin which doesn\u0027t cross \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003c/sub\u003e + \u003c/span\u003e then its coordinate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003c/sub\u003e - \u003c/span\u003e must be less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003c/sub\u003e + \u003c/span\u003e. But in this case there are two penguins running away from each other~--- clearly one spell will not suffice.\u003c/p\u003e\u003cp\u003eSo, the easiest and most effective solution is to find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003c/sub\u003e + \u003c/span\u003e~--- the location of rightmost rightbound penguin, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003c/sub\u003e - \u003c/span\u003e~--- the location of leftmost leftbound penguin, and check if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003c/sub\u003e -  \u0026lt; \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003c/sub\u003e + \u003c/span\u003e. If that holds, the answer is 2, otherwise it\u0027s 1. This can be easily done in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. Other approaches include checking for all pairs of penguins if they run away from each other in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e, or more effeciently using sorts in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003ch3\u003eProblem B\u003c/h3\u003e\u003cp\u003eLet\u0027s divide all configurations by leftmost turned-on bulb. Suppose the leftmost turned-in bulb is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e - 1 ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e, then the bulbs \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e, \\ldots \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e can be turned on or off in any combinations, so the number of such configurations is \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e - 1 \u0026gt; \u003ci\u003en\u003c/i\u003e\u003c/span\u003e, then the ``free\u0027\u0027 bulbs are limited by the end of the line, and the number of configurations is \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. There is also one combination when all bulbs are off.\u003c/p\u003e\u003cp\u003eThese quantities can be summed up in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e if one uses binary modulo exponentation of 2, or in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e if the powers of 2 are precomputed with DP. It can also be shown (by summing the geometric progression which you can try to do yourself) that the answer is always equal to \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e + 2)2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/sup\u003e\u003c/span\u003e, this number can be computed in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c8/0f/c80f1bdb215a673d522522dd243b7f4585063777.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003ch3\u003eProblem C\u003c/h3\u003e\u003cp\u003eLet\u0027s come up with a straightforward solution first. We will just simulate the battles and keep the current value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e. How many iterations we will have to make? And more importantly, how can we tell if the answer is \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e or we just didn\u0027t do enough battles yet?\u003c/p\u003e\u003cp\u003eTo answer that, let\u0027s keep track of values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e before all battles with the first opponent. If some value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e repeats twice, then the whole process is looped and the answer is \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e. On the other hand, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e \u0026gt; \u003ci\u003eA\u003c/i\u003e\u003c/span\u003e (the largest possible value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, that is, \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e) we will surely win all battles. So the maximal number of iterations is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e + 1)\u003c/span\u003e (since no value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e ≤ \u003ci\u003eA\u003c/i\u003e\u003c/span\u003e can repeat twice).\u003c/p\u003e\u003cp\u003eThis is still too much for straightforward simulation (\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ab/aa/abaa69c86f5acb1f53772905ba6c714de07be745.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e battles). How can we optimize that? Let us find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003eM\u003c/i\u003e)\u003c/span\u003e~--- the number of first lost battle for each value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e at the start that does not exceed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e. This can be done in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e)\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e\u0027s at the same time using the fact that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003eM\u003c/i\u003e)\u003c/span\u003e does not decrease. Indeed, suppose we know \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003eM\u003c/i\u003e)\u003c/span\u003e and also \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(\u003ci\u003eM\u003c/i\u003e)\u003c/span\u003e~--- our power before battling the last opponent. If the starting power were \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e + 1\u003c/span\u003e, at this point our power would be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(\u003ci\u003eM\u003c/i\u003e) + 1\u003c/span\u003e. If this is still not enough to win opponent \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003eM\u003c/i\u003e)\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003eM\u003c/i\u003e + 1) \u003d \u003ci\u003ef\u003c/i\u003e(\u003ci\u003eM\u003c/i\u003e)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(\u003ci\u003eM\u003c/i\u003e + 1) \u003d \u003ci\u003eg\u003c/i\u003e(\u003ci\u003eM\u003c/i\u003e) + 1\u003c/span\u003e. Otherwise, we proceed to following opponents updating \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003eM\u003c/i\u003e + 1)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e(\u003ci\u003eM\u003c/i\u003e + 1)\u003c/span\u003e accordingly until we lose or win them all. Notice that the total number of increases of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003eM\u003c/i\u003e)\u003c/span\u003e is at exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, thus the complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eUsing values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003eM\u003c/i\u003e)\u003c/span\u003e we can emulate the battles much more quickly: for given \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e find the first lost battle, add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003eM\u003c/i\u003e)\u003c/span\u003e to the total number of battles, update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(0, \u003ci\u003eg\u003c/i\u003e(\u003ci\u003eM\u003c/i\u003e) - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e, proceed until we win everyone or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e repeats. This optimization leads to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003eA\u003c/i\u003e)\u003c/span\u003e solution.\u003c/p\u003e\u003cp\u003eThere is another tempting idea for this problem which turns out to be wrong. If you have trouble with WA3, consider this case:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e4 2\n0 5 0\n6 0 3\n7 0 6\n8 0 4\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eProblem D\u003c/h3\u003e\u003cp\u003eLet\u0027s call a position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e \\emph{interesting} if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecolor\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) ≠ \u003ci\u003ecolor\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e - 1)\u003c/span\u003e. If we find two interesting positions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026lt; \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e so that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecolor\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d ... \u003d \u003ci\u003ecolor\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e - 1)\u003c/span\u003e, then the answer is equal \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eHow can we find a single interesting position? Suppose we have two arbitrary positions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u0026lt; \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecolor\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e) ≠ \u003ci\u003ecolor\u003c/i\u003e(\u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e. Then we can find an interesting position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u0026lt; \u003ci\u003ex\u003c/i\u003e ≤ \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e using binary search: let \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/28/40/28401176fdb3a5cc8e725779ebc35b059a6b69d0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecolor\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e) ≠ \u003ci\u003ecolor\u003c/i\u003e(\u003ci\u003ec\u003c/i\u003e)\u003c/span\u003e update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e, otherwise update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e. At some point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e \u003d 1\u003c/span\u003e and we\u0027re done. Denote this resulting position as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eOkay, how to find two positions of different colors first? Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e be the maximal possible value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. Consider a segment of length, say, \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e. The colors inside this segment have to be distributed \\emph{almost evenly}, so after trying several random cells we will find two different colors with high probability.\u003c/p\u003e\u003cp\u003eThere are several possible options what to do after we have obtained two interesting positions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. We can use the fact that either the segment \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, \\ldots, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e - 1\u003c/span\u003e is same-colored, or it has at least \u003cspan class\u003d\"tex-span\"\u003e1 / 3\u003c/span\u003e of the cells with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecolor\u003c/i\u003e! \u003d \u003ci\u003ecolor\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e, so we can try random cells until we find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecolor\u003c/i\u003e(\u003ci\u003ez\u003c/i\u003e) ≠ \u003ci\u003ecolor\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e, and then we can shrink the segment to either \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ez\u003c/i\u003e)\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ez\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e), \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, whichever\u0027s shorter. Length of the segment shrinks at least two times after each iteration (in fact, it shrinks even faster).\u003c/p\u003e\u003cp\u003eAnother approach is to note that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e divides \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e for all interesting positions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. Thus we can obtain several interesting positions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e for random values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, and find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e\u003c/span\u003e~--- GCD of their differences. Clearly, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/98/0f/980fe698aa0de5ae42ddbd0c647b89f2b3fb5bc1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. It can also be shown that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eG\u003c/i\u003e \u003d \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e with high probability is the number of positions is, say, at least 50; it is a bit harder to analyze though, but the general idea is that while it\u0027s hard to determine the exact distribution of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e, it is \\emph{not that bad}, so it is improbable for many values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e to be, say, multiples of \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e apart.\u003c/p\u003e\u003cp\u003eI want to describe another, much simpler solution by \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Chmel_Tolstiy\" title\u003d\"Grandmaster Chmel_Tolstiy\"\u003eChmel_Tolstiy\u003c/a\u003e. Let\u0027s find the smallest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecolor\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e) ≠ \u003ci\u003ecolor\u003c/i\u003e(0)\u003c/span\u003e. It is easy to prove that there is exactly one change color between these two positions, so its position can be found with binary search as before. Do the same way in negative direction and find another closest color change, output the difference. This solution turned out to be most popular among contestants (but less popular among the testers).\u003c/p\u003e\u003ch3\u003eProblem E\u003c/h3\u003e\u003cp\u003eLet\u0027s find out how to check if the answer is at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e and binary search on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eLet\u0027s make an arbitrary vertex the root of the tree. Note that if the subtree of any vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e contains even number of outposts then no paths can come out of the subtree (since their number must be even, but at most one path can pass through an edge). Similarly, if there is an odd number of outposts then one path must come out of the subtree. Consider all children of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e: each of their subtrees will either yield a single path or nothing. We have to match the resulting paths between each other and choose at most one of them to yield to the parent. Naturally, our intention is to make the unmatched path as short as possible while making suring that in each pair of matched paths their total length does not exceed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e. We can also note that the answer is never \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e since we can always match the paths if we ignore their lengths.\u003c/p\u003e\u003cp\u003eConsider the case when we have to match an even number of paths. Let\u0027s say we have an array of even length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, \\ldots, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, and want to make pairs of its elements such that sum in each pair does not exceed \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e. It can be shown that the optimal way is to sort the array and then match \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003ci\u003ek\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e, and so on. Indeed, consider that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e is not matched with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e but with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is matched with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Let\u0027s rematch them as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Since the array is sorted, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and the maximum sum won\u0027t increase after rematching. Drop the elements \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and proceed until we obtain the matching \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003ci\u003ek\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e, \\ldots.\u003c/p\u003e\u003cp\u003eNow we want to match an odd number of paths while minimizing the unmatched path length. This can be done with binary search on unmatched length and checking if the rest of the paths can be matched using previous approach. Another approach is greedy: take the maximal element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, find maximal element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e ≤ \u003ci\u003eD\u003c/i\u003e\u003c/span\u003e, erase them both. If there is no such \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e must be unmatched. Finally, check if there is at most one unmatched element. All these approaches take \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9a/a2/9aa280f9dd4fe453aaeb8a38785f026769bb0161.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time for a vertex with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e children, but the real time depends hugely on the actual approach (say, using std::set or TreeSet is much slower than sorts and binary searches).\u003c/p\u003e\u003cp\u003eThe total complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/39/ce/39ce43e4c5d5454f175598a4b24969367b8ef926.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e is maximal possible answer value.\u003c/p\u003e\u003ch3\u003eProblem F\u003c/h3\u003e\u003cp\u003eConsider all possible values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e such that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/da/2e/da2e0d0f4319648eb7ca78746dfc8d023ee588db.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Let\u0027s arrange them in a table, roughly like this (second sample, O stands for possible value, . for impossible):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e  0 1 2\n0 O O .\n1 O . .\n2 . . .\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen can one determine the numbers? Consider the position \u003cspan class\u003d\"tex-span\"\u003e(0, 1)\u003c/span\u003e: the person with number 2 knows that the only possible pair is \u003cspan class\u003d\"tex-span\"\u003e(0, 1)\u003c/span\u003e, so he can answer it. In general, once there is only one possible value in some row or some column this value is removed on this day since one person can deduce the other number. So, after day 1, the table becomes (X stands for no longer possible value):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e  0 1 2\n0 O X .\n1 X . .\n2 . . .\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow position \u003cspan class\u003d\"tex-span\"\u003e(0, 0)\u003c/span\u003e can be solved on day 2 according to our rule. One can see that in the third sample the only solvable positions are \u003cspan class\u003d\"tex-span\"\u003e(0, 2)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(2, 0)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIt is tempting to look for a simple formula, but behaviour of how positions are resolved turns out to be complex (for example, try \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e \u003d {5, 13, 20}\u003c/span\u003e). We should look for a way to simulate the process efficiently.\u003c/p\u003e\u003cp\u003eFirst, note that there will be at most \u003cspan class\u003d\"tex-span\"\u003e2(\u003ci\u003eA\u003c/i\u003e + 1)\u003c/span\u003e resolved positions, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e is the maximal element of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e. Indeed, each resolved position leaves a new empty row or a column. Thus, the process will terminate quite quickly, but the total number of possible initial positions is too large to choose resolved positions straightforwardly.\u003c/p\u003e\u003cp\u003eThere are few possible optimization. For one, suppose we have the data structure with following operations: initialize with a set of numbers, remove a single number, once there is a single number in the set, find it. Let\u0027s store this kind of structure for each row and column, now the process can be simulated easily. The simplest way to implement this structure is to store a pair (sum of numbers, count of numbers). Moreover, all the structures can be initialized at once in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e)\u003c/span\u003e time using prefix sums and prefix counts.\u003c/p\u003e\u003cp\u003eAnother idea: if there are three consecutive numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 2\u003c/sub\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 2\u003c/sub\u003e ≤ \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e + 1\u003c/span\u003e, then all positions with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e \u0026lt; \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e will be unsolvable. If we drop all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u0026lt; \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, the sum of the rest elements of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e)\u003c/span\u003e, which allows for a simple simulation.\u003c/p\u003e\u003c/div\u003e","tags":["yandex algorithm","2016","editorial"]}}