{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1487648535,"rating":82,"authorHandle":"pimenta","modificationTimeSeconds":1488036521,"id":50554,"title":"\u003cp\u003eTwo versions of the offline square root decomposition for dynamic minimum spanning tree\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eIntroduction\u003c/h3\u003e\u003cp\u003eIt\u0027s been around 18 months since dynamic minimum spanning tree first crossed my way and yesterday I\u0027ve finally understood the offline square root decomposition for this problem. I think this solution is somehow explained \u003ca href\u003d\"//codeforces.com/blog/entry/16967\"\u003ehere\u003c/a\u003e, but I also think it can be explained in a better way. This is the goal of this post. I\u0027ll explain how to solve two versions of the problem.\u003c/p\u003e\u003ch3\u003eAcknowledgments\u003c/h3\u003e\u003cp\u003eI\u0027d like to thank \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/thiagocarvp\" title\u003d\"Expert thiagocarvp\"\u003ethiagocarvp\u003c/a\u003e for explaining me the solution to the first version and \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/victoragnez\" title\u003d\"Candidate Master victoragnez\"\u003evictoragnez\u003c/a\u003e for explaining me the solution to the second version.\u003c/p\u003e\u003ch3\u003eFirst version\u003c/h3\u003e\u003ch4\u003eProblem statement\u003c/h4\u003e\u003cp\u003eFirst, you\u0027re given a connected graph with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e vertices and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e weighted edges. And then a sequence of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e new edges is added to the graph. For each of these \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e new edges, output the weight of a minimum spanning tree considering only this and the previous edges. For example, take \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e \u003d {1, 2}\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eE\u003c/i\u003e \u003d {({1, 2}, 5)}\u003c/span\u003e and the sequence \u003cspan class\u003d\"tex-span\"\u003e(({1, 2}, 7), ({1, 2}, 3))\u003c/span\u003e, i.e., \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 2\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e \u003d 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e \u003d 2\u003c/span\u003e. The answers are 5 and 3, respectively.\u003c/p\u003e\u003ch4\u003eNaive approach\u003c/h4\u003e\u003cp\u003eLet\u0027s try to answer the queries online. First, build a MST for the initial graph. All we can do with new edges is try to improve the current MST, i.e., the MST can only become lighter, never heavier. It\u0027s not hard to see that the required procedure is the following greedy algorithm.\u003c/p\u003e\u003cp\u003eThere are only two possibilities for a new edge \u003cspan class\u003d\"tex-span\"\u003e({\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e}, \u003ci\u003ew\u003c/i\u003e)\u003c/span\u003e:\u003c/p\u003e \u003col\u003e   \u003cli\u003eAn edge between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is already present in the MST. In this case, just update its weight taking the minimum between the new and the old weight.\u003c/li\u003e   \u003cli\u003eThere\u0027s no edge between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in the current MST. In this case, the new edge will create a cycle. Then just remove the heaviest edge from this cycle.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eThe first situation can be easily handled in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b7/d7/b7d723a5f42c4314167c2d7094c1a432d6cf0605.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e using maps. The second, however, takes more effort. A simple DFS could find and remove the heaviest edge of the cycle, but it would cost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e operations, resulting in a total running time of at least \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e2/59/e259b7ac70f3fe8d26922cf2be14acf614b5bb26.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e operations in the worst case. Alternatively, it\u0027s possible to augment a \u003ca href\u003d\"https://courses.csail.mit.edu/6.851/spring12/scribe/L19.pdf\"\u003elink cut tree\u003c/a\u003e to do all this work in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b7/d7/b7d723a5f42c4314167c2d7094c1a432d6cf0605.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e per new edge, resulting in a much better \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a6/d0/a6d01dbd0f65a11de4597d60790fc6c360bf811e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e running time.\u003c/p\u003e\u003cp\u003eSo the naive approach is either too slow (DFS), or too much code (link cut tree).\u003c/p\u003e\u003ch4\u003eSolution\u003c/h4\u003e\u003cp\u003eThe naive approach might be hard to apply, but it certainly helps us to make an important observation:\u003c/p\u003e\u003cp\u003e\u003cem\u003eTwo consecutive MSTs will differ in at most one edge.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eIn other words, the changes in the solution are very small from one query to the next. And we are going to take advantage of this property, like many popular offline algorithms do. In particular, we\u0027ll do something like the square root decomposition of \u003ca href\u003d\"http://www.geeksforgeeks.org/mos-algorithm-query-square-root-decomposition-set-1-introduction/\"\u003eMo\u0027s algorithm\u003c/a\u003e. Usually, this property is achieved by sorting the queries in a special way, like Mo\u0027s algorithm itself requires. In our case, we have just noticed that this is not necessary. Hence, we\u0027ll process the queries in a very straightforward way (and I keep asking myself what took me so long to understand this beautiful algorithm!).\u003c/p\u003e\u003cp\u003eThe observation is used as follows. We\u0027ll split the queries in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/db/32db1127ebe513f1f747c2fc33bc4f0a6c619cc5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e consecutive blocks of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/db/32db1127ebe513f1f747c2fc33bc4f0a6c619cc5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e consecutive queries. If we compute the edges that simultaneously belong to all the MSTs of one block, we\u0027ll be able to reduce the size of the graph for which we should compute minimum spanning trees. In other words, we\u0027re going to run \u003ca href\u003d\"http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/\"\u003eKruskal\u0027s algorithm\u003c/a\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e times, once per new edge, but it will run for much smaller graphs. Let\u0027s see the details.\u003c/p\u003e\u003cp\u003eFirst, imagine the MST \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e computed right after adding the edge \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th query. Now, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003c/span\u003e belongs to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, consider \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/22/0d/220d9b63c93d8369485101e9a75c3ef9c18c3e4e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. What does it look like? Sure, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u0027\u003c/span\u003e is a forest with two trees (components). And if we condense these two components, we\u0027ll get a much smaller graph with precisely two vertices and no edges. Right now, this much smaller graph do not seems to be useful, but let\u0027s see what happens if we consider this situation for not only one, but for a block of new edges.\u003c/p\u003e\u003cp\u003eNow, imagine the MST \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e computed right after adding all the edges of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th block \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. The graph \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f5/b0/f5b08acf169b0262bcc1ce4b3b713e810b0b5bb1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is a minimum spanning forest with at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/db/32db1127ebe513f1f747c2fc33bc4f0a6c619cc5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e components, because the removal of an edge increases the number of components in exactly one and we are considering the removal of at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ff/b0/ffb03ed92aa5df133ff71c52a8cfc6c3e1f48d0f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e edges. Therefore, a condensation would produce a set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e of at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/db/32db1127ebe513f1f747c2fc33bc4f0a6c619cc5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e vertices. Let\u0027s write \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e to denote the total sum of the weights of the condensed edges (the internal edges of the components).\u003c/p\u003e\u003cp\u003eConsider a MST for the set \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e that uses only the edges added \u003cstrong\u003ebefore\u003c/strong\u003e the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th block. This MST will have at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e2/a3/e2a3e665cda78c8442747df02ffe37026ff51fdc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e edges. If we use the edges of this MST to initialize and maintain a multiset \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e of edges, we can insert a new edge in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e and run Kruskal\u0027s algorithm \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/db/32db1127ebe513f1f747c2fc33bc4f0a6c619cc5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e times, once per query. Over all blocks, we\u0027ll run Kruskal\u0027s algorithm \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e times for graphs with at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f7/5d/f75dad9424c868af733cfbfd11c249faacf2746c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e vertices and edges. For the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e-th query, we should output \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e + \u003ci\u003eY\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is the total sum of the weights of the edges chosen by Kruskal\u0027s algorithm.\u003c/p\u003e\u003cp\u003eIn a step-by-step description, the algorithm is as follows:\u003c/p\u003e \u003col\u003e   \u003cli\u003eStore the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e initial edges in a multiset \u003ccode\u003eedges\u003c/code\u003e.\u003c/li\u003e   \u003cli\u003eCompute \u003ccode\u003elarge\u003c/code\u003e, an array with the edges of a MST for the initial \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e edges (Kruskal\u0027s for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e edges).\u003c/li\u003e   \u003cli\u003eFor each block \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e:\u003c/li\u003e   \u003cli\u003e   \u003col\u003e     \u003cli\u003eCreate an empty array \u003ccode\u003einitial\u003c/code\u003e and swap the contents with \u003ccode\u003elarge\u003c/code\u003e.\u003c/li\u003e   \u003c/ol\u003e\u003c/li\u003e   \u003cli\u003e   \u003col\u003e     \u003cli\u003eInsert edges \u003ccode\u003ee[i]\u003c/code\u003e in the multiset \u003ccode\u003eedges\u003c/code\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003er\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003c/ol\u003e\u003c/li\u003e   \u003cli\u003e   \u003col\u003e     \u003cli\u003eRecompute \u003ccode\u003elarge\u003c/code\u003e for the new state of \u003ccode\u003eedges\u003c/code\u003e (Kruskal\u0027s for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003em\u003c/i\u003e + \u003ci\u003eq\u003c/i\u003e)\u003c/span\u003e edges).\u003c/li\u003e   \u003c/ol\u003e\u003c/li\u003e   \u003cli\u003e   \u003col\u003e     \u003cli\u003eUse \u003ccode\u003elarge\u003c/code\u003e to find the forest and condense its components (using a DSU, for example) and to find the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003c/ol\u003e\u003c/li\u003e   \u003cli\u003e   \u003col\u003e     \u003cli\u003eCreate a multiset \u003ccode\u003eM\u003c/code\u003e of edges and use \u003ccode\u003einitial\u003c/code\u003e and the condensed components to fill it with at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e2/a3/e2a3e665cda78c8442747df02ffe37026ff51fdc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e edges.\u003c/li\u003e   \u003c/ol\u003e\u003c/li\u003e   \u003cli\u003e   \u003col\u003e     \u003cli\u003eFor each edge \u003ccode\u003ee[i]\u003c/code\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003er\u003c/i\u003e\u003c/span\u003e:\u003c/li\u003e   \u003c/ol\u003e\u003c/li\u003e   \u003cli\u003e   \u003col\u003e     \u003cli\u003e     \u003col\u003e       \u003cli\u003eInsert \u003ccode\u003ee[i]\u003c/code\u003e in \u003ccode\u003eM\u003c/code\u003e.\u003c/li\u003e     \u003c/ol\u003e\u003c/li\u003e   \u003c/ol\u003e\u003c/li\u003e   \u003cli\u003e   \u003col\u003e     \u003cli\u003e     \u003col\u003e       \u003cli\u003eCompute Kruskal\u0027s minimum weight \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e for the multiset \u003ccode\u003eM\u003c/code\u003e and output \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e + \u003ci\u003eY\u003c/i\u003e\u003c/span\u003e (Kruskal\u0027s for \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f7/5d/f75dad9424c868af733cfbfd11c249faacf2746c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e edges).\u003c/li\u003e     \u003c/ol\u003e\u003c/li\u003e   \u003c/ol\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eWe run Kruskal\u0027s algorithm \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f7/5d/f75dad9424c868af733cfbfd11c249faacf2746c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e times for a graph with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003em\u003c/i\u003e + \u003ci\u003eq\u003c/i\u003e)\u003c/span\u003e edges and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e times for a graph with \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f7/5d/f75dad9424c868af733cfbfd11c249faacf2746c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e edges, so the total running time is around \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/38/3e/383e7229b12c51dbcbf2bbc3ae3dac8d9ba0b776.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, if we have a fast DSU implementation.\u003c/p\u003e\u003cp\u003eHere is my AC implementation for \u003ca href\u003d\"//codeforces.com/gym/101047/problem/I\"\u003ethis problem\u003c/a\u003e:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\n// problem: http://codeforces.com/gym/101047/problem/I\n// tutorial: http://codeforces.com/blog/entry/50554\n\nconst int N \u003d 3e4+5;\n\nstruct edge {\n  int u,v,w,id;\n  edge() : id(0) {}\n  bool operator\u0026lt;(const edge\u0026amp; o) const { return w \u0026lt; o.w; }\n  void read() { scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;u,\u0026amp;v,\u0026amp;w); }\n};\n\n// lazy dsu\nstruct dsu {\n  int mark[N], p[N], pass;\n  dsu() : pass(1) {}\n  void reset() { pass++; }\n  int Find(int x) {\n    if (mark[x] !\u003d pass) {\n      mark[x] \u003d pass;\n      p[x] \u003d x;\n    }\n    return p[x] \u003d\u003d x ? x : p[x] \u003d Find(p[x]);\n  }\n  void Union(int x, int y) { p[Find(x)] \u003d Find(y); }\n};\n\nint kruskal(const multiset\u0026lt;edge\u0026gt;\u0026amp; edges, vector\u0026lt;edge\u0026gt;* mst \u003d nullptr) {\n  static dsu uf;\n  uf.reset();\n  int ans \u003d 0;\n  for (auto\u0026amp; e : edges) if (uf.Find(e.u) !\u003d uf.Find(e.v)) {\n    uf.Union(e.u,e.v);\n    if (mst) mst-\u0026gt;push_back(e);\n    ans +\u003d e.w;\n  }\n  return ans;\n}\n\nint main() {\n  int t;\n  scanf(\u0026quot;%d\u0026quot;,\u0026amp;t);\n  while (t--) {\n    // input\n    int n,m,q;\n    scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;m,\u0026amp;q);\n    multiset\u0026lt;edge\u0026gt; edges;\n    for (int i \u003d 1; i \u0026lt;\u003d m; i++) {\n      edge e;\n      e.read();\n      edges.insert(e);\n    }\n    static edge query[N];\n    for (int i \u003d 1; i \u0026lt;\u003d q; i++) {\n      query[i].read();\n      query[i].id \u003d i;\n    }\n    // initial large mst\n    vector\u0026lt;edge\u0026gt; largemst;\n    kruskal(edges,\u0026amp;largemst);\n    // answer each block\n    for (int l \u003d 1, b \u003d sqrt(q)+1; l \u0026lt;\u003d q; l +\u003d b) {\n      int r \u003d min(l+b-1,q);\n      // current large mst is the initial mst for the queries of this block\n      vector\u0026lt;edge\u0026gt; initial;\n      largemst.swap(initial);\n      // compute next large mst\n      for (int i \u003d l; i \u0026lt;\u003d r; i++) edges.insert(query[i]);\n      kruskal(edges,\u0026amp;largemst);\n      // compute forest\n      static dsu uf;\n      uf.reset();\n      int forest \u003d 0;\n      for (auto\u0026amp; e : largemst) if (e.id \u0026lt; l) {\n        uf.Union(e.u,e.v);\n        forest +\u003d e.w;\n      }\n      // compute initial compressed mst\n      multiset\u0026lt;edge\u0026gt; eds;\n      for (auto\u0026amp; e : initial) if (uf.Find(e.u) !\u003d uf.Find(e.v)) {\n        auto tmp \u003d e;\n        tmp.u \u003d uf.Find(e.u), tmp.v \u003d uf.Find(e.v);\n        eds.insert(tmp);\n      }\n      // answer each query\n      for (int i \u003d l; i \u0026lt;\u003d r; i++) {\n        auto tmp \u003d query[i];\n        tmp.u \u003d uf.Find(tmp.u), tmp.v \u003d uf.Find(tmp.v);\n        eds.insert(tmp);\n        printf(\u0026quot;%d\\n\u0026quot;,forest+kruskal(eds));\n      }\n    }\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003eSecond version\u003c/h3\u003e\u003ch4\u003eProblem statement\u003c/h4\u003e\u003cp\u003eAgain, you\u0027re first given a connected graph with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e vertices and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e weighted edges. This time, the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th query is a pair \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003em\u003c/i\u003e\u003c/span\u003e and you should output the weight of a minimum spanning tree after making \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e(\u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e) \u003d \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e permanently (until a new update for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ee\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is required). For example, take \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e \u003d {1, 2, 3}\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eE\u003c/i\u003e \u003d (({1, 2}, 5), ({2, 3}, 6), ({3, 1}, 7))\u003c/span\u003e and the updates \u003cspan class\u003d\"tex-span\"\u003e(1, 8)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(2, 9)\u003c/span\u003e. The answers are 13 and 15, respectively.\u003c/p\u003e\u003ch4\u003eSolution\u003c/h4\u003e\u003cp\u003eI\u0027ll assume that you have read the solution to the first version, which is simpler, but the core idea is the same: we\u0027ll somehow compute the edges that will remain unchanged thourgh a block of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/db/32db1127ebe513f1f747c2fc33bc4f0a6c619cc5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e consecutive updates and will belong to all the minimum spanning trees of this block. Again, the remaining graph will have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f7/5d/f75dad9424c868af733cfbfd11c249faacf2746c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e vertices and edges, so we\u0027ll compute the answer for each query in the same time complexity as before.\u003c/p\u003e\u003cp\u003eFirst, we should reduce the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e edges to around \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e edges using Kruskal. In this phase, we should consider only the edges that won\u0027t be updated in this block. Let\u0027s refer to these edges as \u003cem\u003enon-updated\u003c/em\u003e. In the end, the graph will not be necessarily connected, but the purpose here is only to \u003cem\u003ediscard the edges that we know for sure that won\u0027t be present in any of the MSTs of this block.\u003c/em\u003e Let\u0027s call the edges selected by this phase as \u003cem\u003epossibly useful edges\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eNow, we should \u003cem\u003esplit the possibly useful edges in two disjoint sets:\u003c/em\u003e the at least \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c6/5e/c65e094b25256e1549bc08aed8991af797206bce.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cem\u003ecertainly useful edges\u003c/em\u003e that will be present for sure in all the MSTs of this block and the at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/db/32db1127ebe513f1f747c2fc33bc4f0a6c619cc5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cem\u003eremaining possibly useful edges\u003c/em\u003e to be considered by the \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/db/32db1127ebe513f1f747c2fc33bc4f0a6c619cc5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e Kruskals of this block. For this, we\u0027ll just run Kruskal one more time, except that the DSU should be initialized with a special procedure. This procedure is simply to call the union operation for each \u003cem\u003eupdated edge\u003c/em\u003e (the \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/db/32db1127ebe513f1f747c2fc33bc4f0a6c619cc5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e edges that will be updated in this block). After this initialization, this DSU will clearly have at least \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c6/5e/c65e094b25256e1549bc08aed8991af797206bce.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e components, which means that this second execution of Kruskal will have to connect at least \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c6/5e/c65e094b25256e1549bc08aed8991af797206bce.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e components to make the graph fully connected (this time the graph will end connected for sure!). The edges selected by Kruskal\u0027s algorithm are the certainly useful ones, while the discarded are the remaining possibly useful ones.\u003c/p\u003e\u003cp\u003eAlong with the specially initialized DSU of the previous Kruskal, you can build a second one using only the certainly useful edges. This second DSU represents the condensation of the forest.\u003c/p\u003e\u003cp\u003eAt last, build a set with the \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/db/32db1127ebe513f1f747c2fc33bc4f0a6c619cc5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e remaining possibly useful edges and the \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/db/32db1127ebe513f1f747c2fc33bc4f0a6c619cc5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e updated edges. Use and maintain this set to process the queries. For each update, remove the updated edge from this set, update its weight and insert it again, then run Kruskal\u0027s algorithm over this sorted set of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f7/5d/f75dad9424c868af733cfbfd11c249faacf2746c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e edges. You can also maintain a larger set with all the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e edges during the updates and across all blocks.\u003c/p\u003e\u003cp\u003eHere is my AC implementation for \u003ca href\u003d\"//codeforces.com/gym/101246/problem/L\"\u003ethis problem\u003c/a\u003e:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\n// problem: http://codeforces.com/gym/101246/problem/L\n// tutorial: http://codeforces.com/blog/entry/50554\n\nconst int N \u003d 4e4+5;\n\n// input\nint n,m,u[N],v[N],w[N],e[N],c[N];\n\n// set comparison\nstruct cmp {bool operator()(int i, int j) { return w[i]!\u003dw[j]?w[i]\u0026lt;w[j]:i\u0026lt;j; }};\ntypedef set\u0026lt;int,cmp\u0026gt; edgeset;\n\n// lazy flag\nstruct {\n  int mark[N],pass;\n  void init() { pass++; }\n  bool get(int i) { return mark[i] \u003d\u003d pass; }\n  void set(int i) { mark[i] \u003d pass; }\n} flag;\n\n// lazy dsu\nstruct dsu {\n  int mark[N],pass,p[N];\n  void init() { pass++; }\n  int Find(int x) { prop(x); return p[x]\u003d\u003dx?x:p[x]\u003dFind(p[x]); }\n  bool Union(int x, int y) {\n    x \u003d Find(x), y \u003d Find(y);\n    if (x \u003d\u003d y) return false;\n    p[x] \u003d y;\n    return true;\n  }\n  void prop(int x) {\n    if (mark[x] \u003d\u003d pass) return;\n    mark[x] \u003d pass;\n    p[x] \u003d x;\n  }\n} d1, d2;\n\nint main() {\n#ifdef ONLINE_JUDGE\n  freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n  freopen(\u0026quot;output.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\n#endif\n  // input\n  scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\n  edgeset large;\n  for (int i \u003d 1; i \u0026lt;\u003d m; i++) {\n    scanf(\u0026quot;%d%d%d\u0026quot;,u+i,v+i,w+i);\n    large.insert(i);\n  }\n  int t;\n  scanf(\u0026quot;%d\u0026quot;,\u0026amp;t);\n  for(int i \u003d 1; i \u0026lt;\u003d t; i++) scanf(\u0026quot;%d%d\u0026quot;,e+i,c+i);\n  // for each block of sqrt(t) updates\n  for (int l \u003d 1, b \u003d sqrt(t); l \u0026lt;\u003d t; l +\u003d b) {\n    int r \u003d min(l+b-1,t);\n    // mark updated edges, initialize first dsu and initialize small set\n    flag.init();\n    d1.init();\n    edgeset sml;\n    for (int i \u003d l; i \u0026lt;\u003d r; i++) {\n      flag.set(e[i]), d1.Union(u[e[i]],v[e[i]]), sml.insert(e[i]);\n    }\n    // select O(n) possibly useful from non-updated edges\n    static int idx[N]; int cnt \u003d 0;\n    d2.init();\n    for (int i : large) if (!flag.get(i) \u0026amp;\u0026amp; d2.Union(u[i],v[i])) idx[++cnt] \u003d i;\n    // select certainly useful from non-updated edges and fill small set\n    d2.init();\n    int forest \u003d 0;\n    for (int i \u003d 1; i \u0026lt;\u003d cnt; i++) {\n      if (d1.Union(u[idx[i]],v[idx[i]])) { // certainly useful, O(n) edges\n        d2.Union(u[idx[i]],v[idx[i]]);\n        forest +\u003d w[idx[i]];\n      }\n      else sml.insert(idx[i]); // possibly useful, O(sqrt(t)) edges\n    }\n    // answer queries\n    for (int i \u003d l; i \u0026lt;\u003d r; i++) {\n      // update sets\n      large.erase(e[i]);\n      sml.erase(e[i]);\n      w[e[i]] \u003d c[i];\n      large.insert(e[i]);\n      sml.insert(e[i]);\n      // kruskal\n      d1.init();\n      int mst \u003d 0;\n      for (int i : sml) if (d1.Union(d2.Find(u[i]),d2.Find(v[i]))) mst +\u003d w[i];\n      printf(\u0026quot;%d\\n\u0026quot;,forest+mst);\n    }\n  }\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003eConclusion\u003c/h3\u003e\u003cp\u003eI hope this post can be useful for others. Constructive criticism and related problems to solve are welcome in the comments!\u003c/p\u003e\u003c/div\u003e","tags":["dynamic mst","sqrt-decomposition","minimum spanning tree"]}}