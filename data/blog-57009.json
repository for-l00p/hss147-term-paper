{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1515507674,"rating":3,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1515597193,"id":57009,"title":"\u003cp\u003eNotes on Codeforces Beta Round #106, Div2- A, B, C, D (dfs with memorization), E (kmp algorithm)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/149/problem/A\" title\u003d\"Codeforces Round 106 (Div. 2)\"\u003e149A - Business trip\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst we sort the array in a decreasing order, and calculate the prefix sum. Then, we find the prefix sum with the minimum index that is not less than the target value.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/149/problem/B\" title\u003d\"Codeforces Round 106 (Div. 2)\"\u003e149B - Martian Clock\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAt first, we find the largest integer in the given sequence, denoted as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Then, we start testing from base \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e + 1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e70\u003c/span\u003e (it is sufficiently safe to choose any integer that is larger than \u003cspan class\u003d\"tex-span\"\u003e60\u003c/span\u003e). If there is no feasible base, the answer is 0. If \u003cspan class\u003d\"tex-span\"\u003e70\u003c/span\u003e is also a feasible base, the answer is -1 since there must be infinite bases that satisfy the requirements.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/149/problem/C\" title\u003d\"Codeforces Round 106 (Div. 2)\"\u003e149C - Division into Teams\u003c/a\u003e\u003c/p\u003e\u003cp\u003eSuppose that all the elements are sorted as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u0026lt; \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u0026lt; ... \u0026lt; \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is even, we can divide them into two groups consisting of \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e, ...\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e4\u003c/sub\u003e, ...\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e, respectively. The proof is that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e - |(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e4\u003c/sub\u003e + ...) - (\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e + ...)| \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 2\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 3\u003c/sub\u003e - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 4\u003c/sub\u003e + ... + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ≥ 0\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is odd, we can divide them into two groups consisting of \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e5\u003c/sub\u003e, ...\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e4\u003c/sub\u003e, ...\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e)\u003c/span\u003e, respectively. The proof is similar if one computes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e - |(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e5\u003c/sub\u003e + ...) - (\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e4\u003c/sub\u003e + ...)|\u003c/span\u003e, and thus omitted here.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/149/problem/D\" title\u003d\"Codeforces Round 106 (Div. 2)\"\u003e149D - Coloring Brackets\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe main idea is DFS with memorization (I learned from turotials). \u003c/p\u003e\u003cp\u003eWe can build a function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edfs\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e1, \u003ci\u003ec\u003c/i\u003e2)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e\u003c/span\u003e are the left and right border of the range that we are considering, inculsively, while \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ec\u003c/i\u003e1, \u003ci\u003ec\u003c/i\u003e2)\u003c/span\u003e are the colors for the brackets at the two borders. Before implementing dfs, we should calculate for each “(”, which “)” matches with it. Note that for the overall sequence, we can divide it into multiple independent subsequences with smaller size. For instance, “(())()()” can be first divided into “(())” and “()()”, and the second part can be further divided into two parts “()” and “()”. This is similar to the idea of divide and conquer, i.e., we divide the original problem into subproblems with smaller size, and solve them seperately, and finally combine their solutions together to obtain the solution to the original problem. This is in fact how our dfs function works. However, trivial dfs leads to TLE due to the huge number of nodes to visit, and thus we should adopt another array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e][\u003ci\u003er\u003c/i\u003e][\u003ci\u003ec\u003c/i\u003e1][\u003ci\u003ec\u003c/i\u003e2]\u003c/span\u003e to store the results that we have obtained to reduce the consumed time.\u003c/p\u003e\u003cp\u003eHere are some key issues involved in dfs function. \u003c/p\u003e\u003cp\u003e1) if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e][\u003ci\u003er\u003c/i\u003e][\u003ci\u003ec\u003c/i\u003e1][\u003ci\u003ec\u003c/i\u003e2]\u003c/span\u003e already has a value, we immediately return it;\u003c/p\u003e\u003cp\u003e2) if positions \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e correspond to a matched “( )”, we recursively call function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edfs\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e + 1, \u003ci\u003er\u003c/i\u003e - 1, \u003ci\u003ec\u003c/i\u003e3, \u003ci\u003ec\u003c/i\u003e4)\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e3\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e4\u003c/span\u003e denote the feasible colors for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e + 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e - 1\u003c/span\u003e. Then, by some simple computation, we can obtain the answer. A special case is that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d \u003ci\u003er\u003c/i\u003e - 1\u003c/span\u003e and the answer can be immediately obtained;\u003c/p\u003e\u003cp\u003e3) if brackets at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e do not match, we find the position at which the bracket matches with that one at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e, denoted as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e (this implies that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e + 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e forms another independent subproblem with smaller size), and then recursively call dfs to compute \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003em\u003c/i\u003e + 1, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e, respectively.\u003c/p\u003e\u003cp\u003e4) due to the given constraints, some of the combination of colors are infrasible, and thus should not be considered.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/149/problem/E\" title\u003d\"Codeforces Round 106 (Div. 2)\"\u003e149E - Martian Strings\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis problem can be solved based on the well known KMP algorithm.\u003c/p\u003e\u003cp\u003eFor each of the given small strings, we implement KMP algorithm. During this process, for every prefix substring, we store the minimum index at which it is found in the longer string. Furthermore, we reverse both the long and small string and repeat the above process again. Note that the “reversal” version in fact calculates the maximum index at which every suffix string is found in the long string. Thus, we divide the small string at different positions to obtain a prefix and a suffix, and check that if the minimum index of the prefix does not exceed the maximum index of the suffix, then the current small string can be seen.\u003c/p\u003e\u003c/div\u003e","tags":[]}}