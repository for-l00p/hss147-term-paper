{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1492417957,"rating":3,"authorHandle":"Messi","modificationTimeSeconds":1492420040,"id":51607,"title":"\u003cp\u003eРазбор контеста на динамическое программирование\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eЗадача А. Лестница\u003c/h1\u003e\u003cp\u003eВ этой задаче надо взобраться на самый верх лестницы набрав максимальную сумму. У нас будет массив dp, где dp[i] будет хранить ответ для первых i чисел. К i-ому элементу можем прийти с позиций (i — 1) или (i — 2), то есть dp[i] \u003d max(dp[i — 1], dp[i — 2]) + a[i].\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eРешение задачи A...\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n\nusing namespace std;\n\nint n, a[200], d[200];\nint main(){\n    freopen(\u0026quot;ladder.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n    freopen(\u0026quot;ladder.out\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n    cin \u0026gt;\u0026gt; n;\n    for (int i \u003d 1; i \u0026lt;\u003d n; i++)\n        cin \u0026gt;\u0026gt; a[i];\n    d[0] \u003d 0;\n    d[1] \u003d a[1];\n    d[2] \u003d max(a[2], a[2] + a[1]);\n\n    for (int i \u003d 3; i \u0026lt;\u003d n; i++)\n       d[i] \u003d max(d[i - 2] + a[i], d[i - 1] + a[i]); \n    cout \u0026lt;\u0026lt; d[n];\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch1\u003eЗадача B. Зайчик\u003c/h1\u003e\u003cp\u003eВ этой задаче надо добраться с 1-ой клетки до n клетки посетив максимальное количество клеток с травой. У нас будет массив boolean массив used, где used[i] возвращает true, если мы можем посетить клетку i, иначе возвращает false. А также, будет массив dp, где dp[i] будет хранить ответ для первых i клеток.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eРешение задачи B...\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n\nusing namespace std;\n\nconst int maxn \u003d 2e3;\n\nstring s;\nbool used[maxn];\nint dp[maxn];\n\nint main() {\n    freopen(\u0026quot;lepus.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n    freopen(\u0026quot;lepus.out\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n    int n;\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s;\n    \n    if (s[0] \u003d\u003d \u0027.\u0027)\n        used[0] \u003d true;\n    else {\n        used[0] \u003d true;\n        dp[0] \u003d 1;\n    }\n    \n    for (int i \u003d 0; i \u0026lt; n; ++i) \n        if (used[i]) {\n            for (int j \u003d 1; j \u0026lt;\u003d 5; j +\u003d 2)\n                if (i + j \u0026lt; n \u0026amp;\u0026amp; (s[i + j] \u003d\u003d \u0027\u0026quot;\u0027 || s[i + j] \u003d\u003d \u0027.\u0027)) {\n                    used[i + j] \u003d true;\n                    int x \u003d 0;\n                    if (s[i + j] \u003d\u003d \u0027\u0026quot;\u0027)\n                        x \u003d 1;\n                    dp[i + j] \u003d max(dp[i + j], dp[i] + x);\n                }\n        }\n    \n    if (!used[n - 1])\n        cout \u0026lt;\u0026lt; -1;\n    else\n        cout \u0026lt;\u0026lt; dp[n - 1];\n        \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch1\u003eЗадача C. Ход конём\u003c/h1\u003e\u003cp\u003eВ этой задаче шахматный конь находиться в клетке (1, 1). Нам надо найти: сколькими способами конь может дойти до клетки (n, m). Шахматный конь может двигаться с клетки (i, j):  1. на клетку (i + 2, j + 1)  2. на клетку (i + 1, j + 2).\u003c/p\u003e\u003cp\u003eУ нас будет массив dp[][], где dp[i][j] будет хранить количество способов дойти до клетки (i, j). Наша динамика будет смотреть вперед, то есть если мы знаем ответ для dp[i][j], то мы можем обновить ответ для dp[i + 2][j + 1] и dp[i + 1][j + 2].\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eРешение задачи C...\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n\nusing namespace std;\n\nconst int maxn \u003d 51;\n\nint n, m;\nlong long dp[maxn][maxn];\n\nint main() {\n    freopen(\u0026quot;knight.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n    freopen(\u0026quot;knight.out\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n    dp[1][1] \u003d 1;\n    for (int i \u003d 1; i \u0026lt;\u003d n; ++i)\n    for (int j \u003d 1; j \u0026lt;\u003d m; ++j) {\n        if (i + 1 \u0026lt;\u003d n \u0026amp;\u0026amp; j + 2 \u0026lt;\u003d m)\n            dp[i + 1][j + 2] +\u003d dp[i][j];\n        if (i + 2 \u0026lt;\u003d n \u0026amp;\u0026amp; j + 1 \u0026lt;\u003d m)\n            dp[i + 2][j + 1] +\u003d dp[i][j];\n    }\n        \n    cout \u0026lt;\u0026lt; dp[n][m];\n        \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch1\u003eЗадача D. Стоимость маршрута\u003c/h1\u003e\u003cp\u003eНа левом-нижнем углу шахматной доски стоит король и где в каждой клетке доски написано целое число. Король должен дойти до клетки в правом-верхнем углу набрав минимальную сумму. В начале давайте, перевернем массив по строкам, то есть swapнем i-ую строку с n-i строкой. После этого король будет стоять на левом-верхнем, и он должен дойти до правого нижнего. Пусть у нас будет массив dp[i][j], который будет хранить ответ для клетки (i, j). Рассмотрим, несколько вариантов переходов в динамики:\u003c/p\u003e \u003cpre\u003e1. До клетки (1, j) можем прийти только от клетки (1, j - 1) \u003d\u0026gt; dp[1][j] \u003d dp[1][j - 1] + a[i][j]\n\n2. До клетки (i, 1) можем прийти только от клетки (i - 1, 1) \u003d\u0026gt; dp[i][1] \u003d dp[i - 1][1] + a[i][j]\n\n3. До клетки (i, j) можем прийти от клеток (i, j - 1), (i - 1, j) и (i - 1, j - 1) \u003d\u0026gt; dp[i][j] \u003d max(dp[i - 1][j - 1], max(dp[i - 1][j], dp[i][j - 1])) + a[i][j]\u003c/pre\u003e \u003cpre\u003e\u003ccode\u003eРешение задачи D...\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n\nusing namespace std;\n\nconst int maxn \u003d 51;\n\nint n, m;\nlong long dp[maxn][maxn], a[maxn][maxn];\n\nint main() {\n    freopen(\u0026quot;king2.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n    freopen(\u0026quot;king2.out\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n    for (int i \u003d 8; i \u0026gt;\u003d 1; --i)\n    for (int j \u003d 1; j \u0026lt;\u003d 8; ++j)\n        cin \u0026gt;\u0026gt; a[i][j];\n    \n    dp[1][1] \u003d a[1][1];\n    \n    for (int j \u003d 2; j \u0026lt;\u003d 8; ++j)\n        dp[1][j] \u003d dp[1][j - 1] + a[1][j];\n    \n    for (int i \u003d 2; i \u0026lt;\u003d 8; ++i)\n        dp[i][1] \u003d dp[i - 1][1] + a[i][1];\n    \n    for (int i \u003d 2; i \u0026lt;\u003d 8; ++i)\n    for (int j \u003d 2; j \u0026lt;\u003d 8; ++j) {\n        dp[i][j] \u003d min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + a[i][j];\n    }\n        \n    cout \u0026lt;\u0026lt; dp[8][8];\n        \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["dp","knapsack"]}}