{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1469196568,"rating":-20,"authorHandle":"Noble_Mushtak","modificationTimeSeconds":1469213534,"id":46205,"title":"\u003cp\u003eNumber of Empty Subgrids of a Grid\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThere\u0027s this \u003ca href\u003d\"http://www.drdobbs.com/database/the-maximal-rectangle-problem/184410529\"\u003ereally good article on how to find the maximal empty subgrid of a grid\u003c/a\u003e so one might wonder, \u0026quot;How do we find the number of empty subgrids of a grid?\u0026quot; I first saw the answer to the second question in \u003ca href\u003d\"https://discuss.codechef.com/questions/83092/chsgmnts-unofficial-editorial?page\u003d1#83105\"\u003ethis solution to CHSGMNTS on CodeChef\u003c/a\u003e by lohit_97 (found on \u003ca href\u003d\"https://www.codechef.com/users/lohit_97\"\u003eCodeChef\u003c/a\u003e and on \u003ca href\u003d\"//www.codeforces.com/profile/lohit_97\"\u003eCodeForces\u003c/a\u003e), so thanks to them for the following algorithm!\u003c/p\u003e\u003cp\u003eFirst, here is a more formalized way of saying the problem:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eThe first line of input contains two integers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ewidth\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eheight\u003c/i\u003e\u003c/span\u003e (where \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ewidth\u003c/i\u003e, \u003ci\u003eheight\u003c/i\u003e ≤ 1000\u003c/span\u003e).\u003c/li\u003e   \u003cli\u003eThe next \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eheight\u003c/i\u003e\u003c/span\u003e lines of input contain \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ewidth\u003c/i\u003e\u003c/span\u003e integers that fit into \u003ccode\u003elong\u003c/code\u003e in C/C++.\u003c/li\u003e   \u003cli\u003eLet \u003ccode\u003ematrix[i][j]\u003c/code\u003e be the integer number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e on row number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eFind the number of tuples \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e, \u003ci\u003ed\u003c/i\u003e)\u003c/span\u003e such that \u003ccode\u003ematrix[i][j]\u003c/code\u003e is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e ≤ \u003ci\u003ej\u003c/i\u003e ≤ \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThe way we can solve this problem is by keeping an array \u003ccode\u003eemptyToLeft[i][j]\u003c/code\u003e which is the maximum number such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003c/span\u003e\u003ccode\u003eemptyToLeft[i][j]\u003c/code\u003e\u003cspan class\u003d\"tex-span\"\u003e \u0026lt; \u003ci\u003ex\u003c/i\u003e ≤ \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e implies \u003ccode\u003ematrix[x][j]\u003c/code\u003e is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. (If \u003ccode\u003ematrix[i][j]\u003c/code\u003e is not \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, then we just set \u003ccode\u003eemptyToLeft[i][j]\u003c/code\u003e to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e to make the inequality always false.)\u003c/p\u003e\u003cp\u003eOnce we have that, we loop through each column \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and in each column, we make a stack and a \u003ccode\u003etempAnswer \u003d 0\u003c/code\u003e. In the bottom of a stack, we start with \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e and as we loop through each row \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, each row is popped on and some rows are popped off in order to preserve the property that between two consecutive stack elements \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e is directly above \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u0026lt; \u003ci\u003ey\u003c/i\u003e ≤ \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e implies \u003ccode\u003eemptyToLeft[i][y]\u003c/code\u003e\u003cspan class\u003d\"tex-span\"\u003e ≥ \u003c/span\u003e\u003ccode\u003eemptyToLeft[i][b]\u003c/code\u003e. By the definition of \u003ccode\u003eemptyToLeft\u003c/code\u003e, this means \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - \u003c/span\u003e\u003ccode\u003eemptyToLeft[i][b]\u003c/code\u003e\u003cspan class\u003d\"tex-span\"\u003e \u0026lt; \u003ci\u003ex\u003c/i\u003e ≤ \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u0026lt; \u003ci\u003ey\u003c/i\u003e ≤ \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e implies \u003ccode\u003ematrix[x][y]\u003c/code\u003e is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. Thus, all such \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ec\u003c/i\u003e, \u003ci\u003ed\u003c/i\u003e)\u003c/span\u003e in the tuple \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e, \u003ci\u003ed\u003c/i\u003e)\u003c/span\u003e is an answer. Therefore, two consecutive stack elements \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e give us \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eb\u003c/i\u003e - \u003ci\u003ea\u003c/i\u003e) * \u003c/span\u003e\u003ccode\u003eemptyToLeft[i][b]\u003c/code\u003e answers, so we add that to \u003ccode\u003etempAnswer\u003c/code\u003e when we add \u003ccode\u003eb\u003c/code\u003e to the stack and subtract that from \u003ccode\u003etempAnswer\u003c/code\u003e when we pop \u003ccode\u003eb\u003c/code\u003e off. Finally, the answer is simply the sum of all \u003ccode\u003etempAnswer\u003c/code\u003es across all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eHere is the C code for this algorithm:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#define REPEAT(token, num) for (token \u003d 0; token \u0026lt; num; token++)\n\ntypedef long num_cells;\ntypedef long cell;\ntypedef long long num_matrices;\n\ncell matrix[1000][1000];\nnum_cells width, height, emptyToLeft[1000][1000], stack[1000], stackLength;\nnum_matrices answer, tempAnswer;\n\nint main() {\n    num_cells i, j, prevToLeft;\n    //Get the input for the matrix:\n    scanf(\u0026quot;%li %li\u0026quot;, \u0026amp;width, \u0026amp;height);\n    REPEAT(j, height) REPEAT(i, width) scanf(\u0026quot;%li\u0026quot;, matrix[i]+j);\n\n    //Create emptyToLeft by looping through the rows:\n    REPEAT(j, height) {\n        //This is the previous emptyToLeft, which starts out at 0 because at the beginning of a row, there are no elements to the left.\n        prevToLeft \u003d 0;\n        //Loop through each column:\n        REPEAT(i, width) {\n            //If matrix[i][j] !\u003d 0, then emptyToLeft[i][j] \u003d 0.\n            if (matrix[i][j]) emptyToLeft[i][j] \u003d 0;\n            //Otherwise, add one to prevToLeft.\n            else emptyToLeft[i][j] \u003d prevToLeft+1;\n            //Also, update prevToLeft:\n            prevToLeft \u003d emptyToLeft[i][j];\n        }\n    }\n\n    REPEAT(i, width) {\n        //For each column, create a stack with -1 at the bottom.\n        stack[0] \u003d -1, stackLength \u003d 1;\n        //Also, reset tempAnswer:\n        tempAnswer \u003d 0;\n        //Loop through each row:\n        REPEAT(j, height) {\n            //If emptyToLeft[i][stack[stackLength-1]] \u0026gt;\u003d emptyToLeft[i][j], then putting j onto the stack will violate the stack property, so we need to pop the stack:\n            while (stack[stackLength-1] !\u003d -1 \u0026amp;\u0026amp; emptyToLeft[i][stack[stackLength-1]] \u0026gt;\u003d emptyToLeft[i][j]) {\n                //Update tempAnswer now that we are going to pop the stack:\n                //Note that here, stack[stackLength-1] is described as b above while stack[stackLength-2] is a.\n                tempAnswer -\u003d (stack[stackLength-1]-stack[stackLength-2])*emptyToLeft[i][stack[stackLength-1]];\n                //Pop the stack:\n                stackLength--;\n            }\n            //Add the current row to the stack and update tempAnswer accordingly.\n            stack[stackLength++] \u003d j;\n            tempAnswer +\u003d (stack[stackLength-1]-stack[stackLength-2])*emptyToLeft[i][stack[stackLength-1]];\n            //Finally, add tempAnswer to answer across all i, j.\n            answer +\u003d tempAnswer;\n        }\n    }\n    //Print the answer:\n    printf(\u0026quot;%lli\\n\u0026quot;, answer);\n    \n    exit(0);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNotice that we have a \u003ccode\u003ewhile\u003c/code\u003e loop inside of the \u003ccode\u003ej\u003c/code\u003e loop, giving us a third inner loop and thus possibly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eheight\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003ci\u003ewidth\u003c/i\u003e)\u003c/span\u003e complexity. However, each run of the while loop pops an element off the stack and we only add an element to the stack for each \u003ccode\u003ej\u003c/code\u003e, meaning overall, for one \u003ccode\u003ei\u003c/code\u003e, we can do at most \u003ccode\u003eheight\u003c/code\u003e pops. Thus, the \u003ccode\u003ej\u003c/code\u003e loop is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eheight\u003c/i\u003e)\u003c/span\u003e for each \u003ccode\u003ei\u003c/code\u003e and the \u003ccode\u003ewhile\u003c/code\u003e loop is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eheight\u003c/i\u003e)\u003c/span\u003e for each \u003ccode\u003ei\u003c/code\u003e, which gives us \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eheight\u003c/i\u003e·\u003ci\u003ewidth\u003c/i\u003e)\u003c/span\u003e complexity for this problem.\u003c/p\u003e\u003c/div\u003e","tags":["dynamic programming","subarray","counting"]}}