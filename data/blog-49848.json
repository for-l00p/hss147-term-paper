{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1484746634,"rating":15,"authorHandle":"drazil","modificationTimeSeconds":1484836133,"id":49848,"title":"\u003cp\u003eEditorial of Weekly Training Farm 21\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eUpdate\u003c/strong\u003e Editorial of PF is published.\u003c/p\u003e\u003cp\u003ePA\u003c/p\u003e\u003cp\u003eThis is a relatively simple problem. We only need to check if the sum of the lengths is larger than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e times \u003cspan class\u003d\"tex-span\"\u003e60\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e簡單題。判斷所有的歌曲長度加起來有沒有大於 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e 的 \u003cspan class\u003d\"tex-span\"\u003e60\u003c/span\u003e 倍。\u003c/p\u003e\u003cp\u003ePB\u003c/p\u003e\u003cp\u003eThis problem is asking the index of the very next Fibonacci number. The takeaway point is that there is only a small amount of Fibonacci numbers in the range of 32-bits integer. Also, overflow needs to be considered if you choose to use 32-bits integer instead of 64-bits data types.\u003c/p\u003e\u003cp\u003e這題是在問下一個費波那契數列中數字是第幾個。一個小重點是 32 位元整數範圍內的費波那契數列很稀少。另外如果使用 32 位元非 64 位元資料型態的話，那必須考慮溢位的問題。\u003c/p\u003e\u003cp\u003ePC\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://en.wikipedia.org/wiki/Great-circle_distance\"\u003ehttps://en.wikipedia.org/wiki/Great-circle_distance\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://zh.wikipedia.org/wiki/大圓距離\"\u003ehttps://zh.wikipedia.org/wiki/大圓距離\u003c/a\u003e\u003c/p\u003e\u003cp\u003ePD\u003c/p\u003e\u003cp\u003eWe binary search the answer. To check if time \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e is sufficient, we check the maximum flow of the following new constructed graph:\u003c/p\u003e\u003cp\u003eFirstly, we split every vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in the original graph into \u003cspan class\u003d\"tex-span\"\u003e2 × \u003ci\u003et\u003c/i\u003e\u003c/span\u003e vertices in the new graph \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e, \u003ci\u003edir\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e where \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/29/7c29a6b1c7c23fcae79a5c685162400db0e6b1b6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e is the time index starting from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Then, we construct the following capacity 1 directional edges:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e, \u003ci\u003ein\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e) → (\u003ci\u003ev\u003c/i\u003e, \u003ci\u003eout\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003et\u003c/i\u003e ≤ \u003ci\u003eT\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003esource to all \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e, \u003ci\u003ein\u003c/i\u003e, 1)\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e which has an airplane initially.\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e, \u003ci\u003eout\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e to sink for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e which is a runway and all \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003et\u003c/i\u003e ≤ \u003ci\u003eT\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eout\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e - 1) → (\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ein\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eout\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e - 1) → (\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ein\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e2 ≤ \u003ci\u003et\u003c/i\u003e ≤ \u003ci\u003eT\u003c/i\u003e\u003c/span\u003e and all \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e pairs having an edge in the original graph.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThe time complexity of each flow using dinic is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eTE\u003c/i\u003e)\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eE\u003c/i\u003e\u003c/span\u003e is the number of edges since we have at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e units of flow. We have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eE\u003c/i\u003e) \u003d \u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eT\u003c/i\u003e) \u003d \u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e, along with the complexity of binary search the overall complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c3/82/c382679cf9a0b3ec041e3f87f467b5ac876b5150.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003e我們可以用二分搜尋來找答案。對於每個可能的答案 $T$，我們可以用以下的方法建立一個新的圖並檢查它的最大流：\u003c/p\u003e\u003cp\u003e首先，對於每個原始圖裡面的點 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e，我們在新圖裡建立 \u003cspan class\u003d\"tex-span\"\u003e2 × \u003ci\u003et\u003c/i\u003e\u003c/span\u003e 個點 \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e, \u003ci\u003edir\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e，\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/29/7c29a6b1c7c23fcae79a5c685162400db0e6b1b6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e 以及 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e 代表從 \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e 開始的時間點。 接下來，我們用以下的方法建邊：\u003c/p\u003e \u003cul\u003e   \u003cli\u003e對於所有的 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e 以及 \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003et\u003c/i\u003e ≤ \u003ci\u003eT\u003c/i\u003e\u003c/span\u003e 建立 \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e, \u003ci\u003ein\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e) → (\u003ci\u003ev\u003c/i\u003e, \u003ci\u003eout\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e 的邊。\u003c/li\u003e   \u003cli\u003e對於所有一開始有飛機的 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e 建立 source 到 \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e, \u003ci\u003ein\u003c/i\u003e, 1)\u003c/span\u003e 的邊。\u003c/li\u003e   \u003cli\u003e對於所有代表跑到的 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e 以及所有 \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003et\u003c/i\u003e ≤ \u003ci\u003eT\u003c/i\u003e\u003c/span\u003e 建立 \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e, \u003ci\u003eout\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e 到 sink 的邊。\u003c/li\u003e   \u003cli\u003e對於所有 \u003cspan class\u003d\"tex-span\"\u003e2 ≤ \u003ci\u003et\u003c/i\u003e ≤ \u003ci\u003eT\u003c/i\u003e\u003c/span\u003e 以及所有原始圖中的邊 \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e 建立 \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eout\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e - 1) → (\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ein\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e 以及 \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eout\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e - 1) → (\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ein\u003c/i\u003e, \u003ci\u003et\u003c/i\u003e)\u003c/span\u003e 的邊。\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e用 dinic 做最大流的話，因為我們最多只有 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e 單位的流，所以時間複雜度是 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eTE\u003c/i\u003e)\u003c/span\u003e，這裡的 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eE\u003c/i\u003e\u003c/span\u003e 是邊的數量。我們有 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eE\u003c/i\u003e) \u003d \u003ci\u003eO\u003c/i\u003e(\u003ci\u003enm\u003c/i\u003e)\u003c/span\u003e 以及 $O(T) \u003d O(n)$，加上二分搜尋的時間複雜度，總複雜度會是 $O(n^2m\\log{n})$。\u003c/p\u003e\u003cp\u003ePE\u003c/p\u003e\u003cp\u003eJudging from the scale of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e algorithm is sufficient. So it\u0027s not hard to guess that doing flood fill to check for each room\u0027s size would be the last step. Follow that instinct we need to do discretization in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e to prepare for the flood fill. That turns out to be possible. One way of discretization is to create a \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003en\u003c/i\u003e × 2\u003ci\u003en\u003c/i\u003e\u003c/span\u003e map. Observed that there is only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e walls, we can use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time to register each wall on the map.\u003c/p\u003e\u003cp\u003eWe must be careful to not count those non-enclosed areas. This may be done by carefully designed flood fill (e.g. special return value when out of bound) or by mark out the outside area before doing the flood fill.\u003c/p\u003e\u003cp\u003eAn \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003ci\u003en\u003c/i\u003e × 2\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e algorithm could pass the tests but we can solve this task in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e × \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e instead. The key observation is that the x values we need to consider are the ones which have vertical lines on it. So, only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e x values and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e y values need to be considered during the discretization. I was planned to make \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003ci\u003en\u003c/i\u003e × 2\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e solutions TLE but Dreamoon stopped me.\u003c/p\u003e\u003cp\u003e從 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e 的大小我們可以知道 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e 的演算法足以通過。可以猜到最後一步可以用 flood fill 的方法來枚舉每個房間。依據這個直覺，我們可以得出必須要在 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e 的時間內離散化的結論。事實上這是可行的，甚至因為只有 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e 道牆壁，所以我們對於每道牆壁可以花 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e 的時間來把它轉化到離散的地圖上。\u003c/p\u003e\u003cp\u003e我們要小心不要數到那些沒有被完整包圍的區域，一個可能的方法是在 flood fill 的時候小心處理 (例如在超出邊界時採用不同的回傳值)，另外一個方法是在開始 flood fill 前先把所有外圍的區域標記起來。\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003ci\u003en\u003c/i\u003e × 2\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e 的演算法可以通過測試，不過其實我們可以做到 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e × \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e。一個關鍵的觀察是，我們只需要考慮那些有垂直牆壁的 x 座標，所以我們在離散化時所考慮的 x 跟 y 座標可以只有 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e 個。我本來想讓 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003ci\u003en\u003c/i\u003e × 2\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e 的作法 TLE，但是 Dreamoon 阻止了我。\u003c/p\u003e\u003cp\u003ePF\u003c/p\u003e\u003cp\u003eFirst, let\u0027s consider a simpler task: We have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e1\u003c/span\u003e pieces with \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e unit of weight and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e2\u003c/span\u003e pieces of \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e units of weight without any order (i.e. you can reorder them as much as you want). How many round trips are needed? This task can be greedily solved in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e by putting \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e first. Another variation of this task is that given \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e1\u003c/span\u003e pieces with \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e unit of weight and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e2\u003c/span\u003e pieces of \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e units of weight without any order and the truck is loaded \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e units of weight currently. What is the minimum number of round trips required if the load in the trunk can not be pulled out? This task can also be solved in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e in a similar way.\u003c/p\u003e\u003cp\u003eLet\u0027s consider a DP solution to the original problem. The table looks like DP[pos][c1][c2] where pos is the position of the current piece of baggage and c1, c2 is the number of \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e weight and \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e weight pieces that have been pulled out already. Each entry of DP[pos][c1][c2] stores the minimum wasted truck space of that state.\u003c/p\u003e\u003cp\u003eWe need to consider three kinds of transitions:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003epull out the current piece: dpt[pos][c1 + (current_weight \u003d\u003d 1)][c2 + (current_weight \u003d\u003d 2)] \u003d dpt[pos — 1][c1][c2]\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eload the current piece to the trunk (if possible): dpt[pos][c1][c2] \u003d dpt[pos — 1][c1][c2]\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eMake the current piece to be the first piece of next round trip: dpt[pos][c1][c2] \u003d dpt[pos — 1][c1][c2] + current_truck_free_space\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eNote that when doing the DP we need to know the current free space of the truck, we can obtain this value by the simpler task mentioned earlier.\u003c/p\u003e\u003cp\u003eFinally we check DP[n][c1][c2] for every c1 and c2 values. We pick the minimum c1 + c2 among those states require the optimal number of trips (again the simpler task can be utilized to find the number of trips needed). The time complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e首先，讓我們考慮一個比較簡單的子題目：我們有 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e1\u003c/span\u003e 個 \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e 單位重量的行李跟 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e2\u003c/span\u003e 個 \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e 單位重量的行李，如果不考慮順序(也就是你可以任意安排順序)，請問至少要多少趟才載的完？這個子題目可以貪心的用 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e 的時間解掉，只要優先載運 \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e 單位重量的行李就好了。另外一個難一點的子題目：給定 \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e 單位重量的行李數量跟 \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e 單位重量的行李數量，也不考慮順序，並且此時車內已經有 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e 單位重量且不可抽出的行李，請問至少要多少趟才載的完？這個子題目也可以用 \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e 以類似的方法解掉。\u003c/p\u003e\u003cp\u003e對於原來的問題，我們考慮一個 DP，DP[pos][c1][c2]。pos 代表現在要處理的行李編號，而 c1 及 c2 分別代表已經被拉出來的 \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e 跟 \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e 單位重量的行李件數。DP[pos][c1][c2] 的數值代表這個狀態中最少需要浪費掉多少的卡車空間。\u003c/p\u003e\u003cp\u003e考慮三種轉移：\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003e把目前行李拉出來： dpt[pos][c1 + (current_weight \u003d\u003d 1)][c2 + (current_weight \u003d\u003d 2)] \u003d dpt[pos — 1][c1][c2]\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e如果可以的話把目前行李裝上車： dpt[pos][c1][c2] \u003d dpt[pos — 1][c1][c2]\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e把目前行李當成下一趟的第一件行李： dpt[pos][c1][c2] \u003d dpt[pos — 1][c1][c2] + current_truck_free_space\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003e在 DP 的過程中我們必須知道目前的狀態中，卡車還剩下多少空間，上面提到的子問題可以幫助我們計算這個值。\u003c/p\u003e\u003cp\u003e最後，對於所有 c1 及 c2 的值，我們檢查 DP[n][c1][c2] 去求答案。答案即為滿足最少趟數(趟數也可以用子問題求得)的狀態中， c1 + c2 最小的那一個。總時間複雜度為 $O(n^3)$。\u003c/p\u003e\u003c/div\u003e","tags":[]}}