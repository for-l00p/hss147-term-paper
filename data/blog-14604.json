{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1415217226,"rating":0,"authorHandle":"catlak_profesor_mfb","modificationTimeSeconds":1415220617,"id":14604,"title":"\u003cp\u003eCounting problem\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eYou are given N numbers in range 1 and 10^18. You should count the number pairs, which have at least one digit in common in their decimal notation and the position of the digits doesn\u0027t matter. \u003cbr /\u003e  example input: \u003cbr /\u003e 8 (N)\u003cbr /\u003e 13 51 35 43 \u003cbr /\u003e output:\u003cbr /\u003e 5 (13,51),(51,35),(35,43),(51,35),(35,43) \u003cbr /\u003e The problem can be solved easily with a complexity of (2^10)*(2^10)(there are at most 10 different digits in a number). We have an array of size 2^10. We find the digits that a number contains for every number. Then we put the numbers, who contain the same set of digits in the same bucket. If a number contains digit 0 it is put in the bucket whose least significant bit is set, for digit 1, the buckets second least significant bit should be etc. After this, you can loop over the buckets like this:\u003cbr /\u003e for(int i\u003d0;i\u0026lt;1\u0026lt;\u0026lt;N;i++)\u003cbr /\u003e for(int j\u003d0;j\u0026lt;1\u0026lt;\u0026lt;N;j++)\u003cbr /\u003e if(i\u0026amp;j) //we should actually add a special case when i equals to j but anyway.\u003cbr /\u003e ans+\u003dbucket[i]*bucket[j];\u003cbr /\u003e But my question is that could we do this in a better complexity?\u003cbr /\u003e I got an idea but I cant compute the bucket version it uses faster than 2^20. Here it is: If we could convert the array we computed above into this:\u003cbr /\u003e If a number contains digit 1, it should be put in every bucket whose bit for digit 1 is set. The same thing also applies to the other digits. Then we could compute the number of pairs with the inclusion\u0026amp;exclusion principle. We would just have a 2^N loop and if it has an odd number of set bits, we add it to the answer, if it doesnt, we subtract it from the answer. Actually I got an idea to compute the new array but it doesnt quite work. Some numbers get counted more than once. To fix it I have to use inclusion exclusion principle again. But then the complexity increases to 2^20 again. The wrong version follows:\u003cbr /\u003e for(int i\u003d(1\u0026lt;\u0026lt;N)-1;i;i--)\u003cbr /\u003e for(int j\u003di;j;j\u0026amp;\u003dj-1)\u003cbr /\u003e bucket[(j\u0026amp;-j)^i]+\u003dbucket[i];\u003cbr /\u003e Could you please find a better way to solve this problem?\u003cbr /\u003e Thanks in advance.\u003cbr /\u003e \u003c/p\u003e\u003c/div\u003e","tags":["combinatorics","counting"]}}