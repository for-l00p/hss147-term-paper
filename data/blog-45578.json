{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1466517438,"rating":294,"authorHandle":"dumbass","modificationTimeSeconds":1483520360,"id":45578,"title":"\u003cp\u003eParallel Binary Search [tutorial]\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"https://www.dropbox.com/s/cndim2lv872dzen/parallel-binary-search.pdf?dl\u003d0\"\u003eClick here to download the pdf\u003c/a\u003e\u003c/p\u003e\u003ch2\u003ePre Requisites\u003c/h2\u003e\u003cp\u003eBinary Search — How it works and where can it be applied!\u003c/p\u003e\u003ch2\u003eMotivation Problem\u003c/h2\u003e\u003cp\u003eWe aim to solve this problem : \u003ca href\u003d\"http://www.spoj.com/problems/METEORS/\"\u003eMeteors\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe question simply states :\u003c/p\u003e\u003cp\u003eThere are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e member states and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e sectors. Each sector is owned by a member state. There are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e queries, each of which denote the amount of meteor shower in a \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e]\u003c/span\u003e range of sectors on that day. The \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eth\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e member state wants to collect \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ereqd\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e meteors over all its sectors. For every member state, what is the minimum number of days it would have to wait to collect atleast the required amount of meteors?\u003c/p\u003e\u003ch2\u003eSolution\u003c/h2\u003e\u003cp\u003eThe naive solution here is to do a binary search for each of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e member states. We can update in a range using segment trees with lazy propagation for each query. The time complexity of such a solution would be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e * \u003ci\u003elogQ\u003c/i\u003e * \u003ci\u003eQ\u003c/i\u003e * \u003ci\u003elogM\u003c/i\u003e)\u003c/span\u003e. But this one will easily TLE.\u003c/p\u003e\u003cp\u003eLet\u0027s see if there\u0027s something we are overdoing. For every member state, the binary search applies all the queries until a point multiple times! For example, the first value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e\u003c/span\u003e in the binary search is same for all member states, but we are unnecessarily applying this update everytime, instead of somehow caching it.\u003c/p\u003e\u003cp\u003eLet\u0027s do all of these \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e binary searches in a slightly different fashion. Suppose, in every step we group member states by the range of their binary search. In the first step, all member states lie in range \u003cspan class\u003d\"tex-span\"\u003e[1, \u003ci\u003eQ\u003c/i\u003e]\u003c/span\u003e. In the second step, some lie in range \u003cspan class\u003d\"tex-span\"\u003e[1, \u003ci\u003eQ\u003c/i\u003e / 2]\u003c/span\u003e while some lie in range \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eQ\u003c/i\u003e / 2, \u003ci\u003eQ\u003c/i\u003e]\u003c/span\u003e depending on whether the binary search predicate is satisfied. In the third step, the ranges would be \u003cspan class\u003d\"tex-span\"\u003e[1, \u003ci\u003eQ\u003c/i\u003e / 4]\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eQ\u003c/i\u003e / 4, \u003ci\u003eQ\u003c/i\u003e / 2]\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eQ\u003c/i\u003e / 2, 3\u003ci\u003eQ\u003c/i\u003e / 4]\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e[3\u003ci\u003eQ\u003c/i\u003e / 4, \u003ci\u003eQ\u003c/i\u003e]\u003c/span\u003e. So after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elogQ\u003c/i\u003e\u003c/span\u003e steps, every range is a single point, denoting the answer for that member state. Also, for each step running the simulation of all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e queries once is sufficient since it can cater to all the member states. This is pretty effective as we can get our answer in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e * \u003ci\u003elogQ\u003c/i\u003e\u003c/span\u003e simulations rather than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e * \u003ci\u003eQ\u003c/i\u003e * \u003ci\u003elogQ\u003c/i\u003e\u003c/span\u003e simulations. Since each simulation is effectively \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogM\u003c/i\u003e)\u003c/span\u003e, we can now solve this problem in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eQ\u003c/i\u003e * \u003ci\u003elogQ\u003c/i\u003e * \u003ci\u003elogM\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u0026quot;A cool way to visualize this is to think of a binary search tree. Suppose we are doing standard binary search, and we reject the right interval — this can be thought of as moving left in the tree. Similarly, if we reject the left interval, we are moving right in the tree.\u003c/p\u003e\u003cp\u003eSo what Parallel Binary Search does is move one step down in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e binary search trees simultaneously in one \u0026quot;sweep\u0026quot;, taking \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e  *  \u003ci\u003eX\u003c/i\u003e)\u003c/span\u003e time, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e is dependent on the problem and the data structures used in it. Since the height of each tree is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLogN\u003c/i\u003e\u003c/span\u003e, the complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e  *  \u003ci\u003eX\u003c/i\u003e  *  \u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e.\u0026quot; — \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/rekt_n00b\" title\u003d\"Candidate Master rekt_n00b\"\u003erekt_n00b\u003c/a\u003e\u003c/p\u003e\u003ch2\u003eImplementation\u003c/h2\u003e\u003cp\u003eWe would need the following data structures in our implementation :\u003c/p\u003e \u003col\u003e   \u003cli\u003elinked list for every member state, denoting the sectors he owns.\u003c/li\u003e   \u003cli\u003earrays \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e denoting range of binary search for each member state.\u003c/li\u003e   \u003cli\u003erange update and query structure for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e queries.\u003c/li\u003e   \u003cli\u003elinked list \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003echeck\u003c/i\u003e\u003c/span\u003e for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e\u003c/span\u003e value of current ranges of binary search. For every \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e\u003c/span\u003e value, store the member states that need to be checked.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eThe implementation is actually pretty straight forward once you get the idea. For every step in the simulation, we do the following :\u003c/p\u003e \u003col\u003e   \u003cli\u003eClear range tree, and update the linked lists for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e\u003c/span\u003e values.\u003c/li\u003e   \u003cli\u003eRun every query sequentially and check if the linked list for this query is empty or not. If not, check for the member states in the linked list and update their binary search interval accordingly.\u003c/li\u003e \u003c/ol\u003e\u003ch2\u003ePseudo Code\u003c/h2\u003e \u003cpre\u003e\u003ccode\u003efor all logQ steps:\n    clear range tree and linked list check\n    for all member states i:\n        if L[i] !\u003d R[i]:\n            mid \u003d (L[i] + R[i]) / 2\n            insert i in check[mid]\n    for all queries q:\n        apply(q)\n        for all member states m in check[q]:\n            if m has requirements fulfilled:\n                R[m] \u003d q\n            else:\n                L[m] \u003d q + 1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn this code, the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eapply\u003c/i\u003e()\u003c/span\u003e function applies the current update, i.e. , it executes the range update on segment tree. Also to check if the requirements are fulfilled, one needs to traverse over all the sectors owner by that member state and find out the sum. In case you still have doubts, go over to the next section and see my code for this problem.\u003c/p\u003e\u003ch2\u003eProblems to try\u003c/h2\u003e \u003col\u003e   \u003cli\u003e\u003ca href\u003d\"http://www.spoj.com/problems/METEORS/\"\u003eMeteors\u003c/a\u003e — \u003ca href\u003d\"http://ideone.com/tTO9bD\"\u003eMy AC Solution\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://www.hackerearth.com/may-circuits/algorithm/make-n00b_land-great-again-circuits/\"\u003eMake n00b land great again\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"https://www.hackerrank.com/contests/may-world-codesprint/challenges/davaro-and-travelling\"\u003eTravel in HackerLand\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://community.topcoder.com/stat?c\u003dproblem_statement\u0026amp;pm\u003d14088\"\u003eSRM 675 Div1 500\u003c/a\u003e\u003c/li\u003e \u003c/ol\u003e\u003ch2\u003eConclusion\u003c/h2\u003e\u003cp\u003eI heard about this topic pretty recently, but was unable to find any good tutorial. I picked up this trick from some comments on codeforces blog on Meteors problem. Alternate solutions to the mentioned problems are also welcome, almost every question on parallel binary search can also be solved with some persistent data structure, unless there is a memory constraint. Feel free to point out errors, or make this tutorial better in any way! \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eHappy Coding!\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e","tags":["parallel binary search","binary search","speed up","lol"]}}