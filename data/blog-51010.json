{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1489652468,"rating":138,"authorHandle":"joisino","modificationTimeSeconds":1490874123,"id":51010,"title":"\u003cp\u003eJapanese Olympiad in Informatics (JOI) Spring Camp 2017\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello Codeforces!\u003c/p\u003e\u003cp\u003eJapanese Olympiad in Informatics Spring Camp 2017 will be held from Mar. 19 to Mar. 25.\u003c/p\u003e\u003cp\u003eThere will be four online mirror contests during the camp. \u003c/p\u003e \u003cul\u003e   \u003cli\u003eday1 : \u003ca href\u003d\"https://www.timeanddate.com/worldclock/fixedtime.html?day\u003d20\u0026amp;month\u003d3\u0026amp;year\u003d2017\u0026amp;hour\u003d00\u0026amp;min\u003d30\u0026amp;sec\u003d00\"\u003eMar. 20 (00:30 — 05:30 GMT)\u003c/a\u003e\u003c/li\u003e   \u003cli\u003eday2 : \u003ca href\u003d\"https://www.timeanddate.com/worldclock/fixedtime.html?day\u003d21\u0026amp;month\u003d3\u0026amp;year\u003d2017\u0026amp;hour\u003d00\u0026amp;min\u003d30\u0026amp;sec\u003d00\"\u003eMar. 21 (00:30 — 05:30 GMT)\u003c/a\u003e\u003c/li\u003e   \u003cli\u003eday3 : \u003ca href\u003d\"https://www.timeanddate.com/worldclock/fixedtime.html?day\u003d22\u0026amp;month\u003d3\u0026amp;year\u003d2017\u0026amp;hour\u003d00\u0026amp;min\u003d30\u0026amp;sec\u003d00\"\u003eMar. 22 (00:30 — 05:30 GMT)\u003c/a\u003e\u003c/li\u003e   \u003cli\u003eday4 : \u003ca href\u003d\"https://www.timeanddate.com/worldclock/fixedtime.html?day\u003d23\u0026amp;month\u003d3\u0026amp;year\u003d2017\u0026amp;hour\u003d00\u0026amp;min\u003d30\u0026amp;sec\u003d00\"\u003eMar. 23 (00:30 — 05:30 GMT)\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThe contest duration is 5 hours and there are 3 to 4 problems in each day. Problem statements will be provided both in Japanese and English this year.\u003c/p\u003e\u003cp\u003eThere might be unusual tasks such as output-only tasks, optimization tasks, reactive tasks and communication tasks, just like International Olympiad in Informatics (IOI).\u003c/p\u003e\u003cp\u003eDetails are available in \u003ca href\u003d\"http://cms.ioi-jp.org/joi-sp-2017/index-en.html\"\u003econtest information\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eGood luck and have fun!\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD1:\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eWe will use \u003ca href\u003d\"https://cms-dev.github.io/\"\u003eCMS\u003c/a\u003e (customized version) on our server to hold the contests. The registration URL will be announced just before the first contest.\u003c/p\u003e\u003cp\u003eProviding English statements is our first trial for this year, so there aren\u0027t past English problems. If you try past problems with Google Translate, you can get them from \u003ca href\u003d\"https://www.ioi-jp.org/camp/index.html\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD2:\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eRegistration is available now.\u003c/p\u003e \u003cul\u003e   \u003cli\u003eContest page : \u003ca href\u003d\"http://cms.ioi-jp.org/contest/\"\u003ehttp://cms.ioi-jp.org/contest/\u003c/a\u003e\u003c/li\u003e   \u003cli\u003eRanging : \u003ca href\u003d\"http://cms.ioi-jp.org/ranking/\"\u003ehttp://cms.ioi-jp.org/ranking/\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eUPD3:\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe contests are over. The judge is open now. You can submit your codes in the contest page.\u003c/p\u003e\u003cp\u003eUnofficial Simple Editorial:\u003c/p\u003e \u003cul\u003e   \u003cli\u003ecultivation: East and West wind have almost the same effect. You don\u0027t have to consider the order. The essential value is the sum of the number of east and west wind. The candidates of this value are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e. You can easily calculate how many north wind and south wind needed to fill each column. The number of the essential columns are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e. So you can solve this by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e with precalculate.\u003c/li\u003e   \u003cli\u003eport facility: Let\u0027s assume the containers nodes and make edges between the nodes which can\u0027t put on the same area. If this graph is bipartite, The answer is 2^(#connected compornent). Otherwise, the answer is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. First, count the connected component. Sort containers and use Segmenttree, then you can BFS with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e. You can check wheather the graph is bipartite by just simulating the transportation.\u003c/li\u003e   \u003cli\u003esparklers: The first insights are you can do binary search the answer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, no two persons don\u0027t have to burn sparklers simultaneously and burning sparklers looks like an interval. If you can merge \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e - 1]\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e + 1, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e) / \u003ci\u003ev\u003c/i\u003e ≤ (\u003ci\u003er\u003c/i\u003e - \u003ci\u003el\u003c/i\u003e)\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e, then you can merge \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e. You can do some greedy algorithm to check you can merge \u003cspan class\u003d\"tex-span\"\u003e[0, \u003ci\u003en\u003c/i\u003e)\u003c/span\u003e\u003c/li\u003e   \u003cli\u003earranging tickets: Open the circle at point 0. You can use binary search by determining the answer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e. You don\u0027t have to flip the interval \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e]\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ec\u003c/i\u003e, \u003ci\u003ed\u003c/i\u003e]\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u0026lt; \u003ci\u003eb\u003c/i\u003e \u0026lt; \u003ci\u003ec\u003c/i\u003e \u0026lt; \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e. So Filipped interval share some point t. Let\u0027s determin t and the number of flipped interval n. Actually, the candidate of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003em\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003em\u003c/i\u003e + 1\u003c/span\u003e. ( \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is the sum of initial passengers through point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e), the candidate of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e is leftmost and rightmost argmax \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. You can greedily determin flipped intervals.\u003c/li\u003e   \u003cli\u003ebroken device: Divide bits into groups of size 3. There is a code of 3bits that translate 2 bit if intact, 1bit if 1 bit lost, 0 bit if more bits lost.\u003c/li\u003e   \u003cli\u003erailway trip: If you make edges to adjacent greater stations, It looks like a tree. You can use doubling to answer queries quickly.\u003c/li\u003e   \u003cli\u003ecoach: Sort refilling points by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003ci\u003emodT\u003c/i\u003e\u003c/span\u003e and passengers by by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e together. Each adjacent refilling points can purge passengers between them from the back. You can do DP and you can fasten DP by convex hull trick.\u003c/li\u003e   \u003cli\u003elong mansion: Let Llink_i be the rightmost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e s.t. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e ≤ \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Rlink_i is alike. Then JOI-kun can\u0027t go out from \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e iff \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLlink\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e \u0026lt; \u003ci\u003el\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e \u0026lt; \u003ci\u003eRlink\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLret\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be min{ l | Llink_r \u0026lt; l and r \u0026lt; Rlink_r }. Then JOI-kun can\u0027t go from L to R iff there exists \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e s.t. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e ≤ \u003ci\u003er\u003c/i\u003e \u0026lt; \u003ci\u003eR\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLret\u003c/i\u003e[\u003ci\u003er\u003c/i\u003e] ≤ \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. You can use segtree to speed it up.\u003c/li\u003e   \u003cli\u003enatural park: Let\u0027s consider the case of tree. You can add node one by one. First, you can determin wheter the node connects currect tree directly. If Yes, Number the tree nodes BFS order, then you can binary search which node connects the node directly. If No, binary serch a node between this node and the current tree, and solve recursively. In the case of general graph, you can solve with almost the same solution.\u003c/li\u003e   \u003cli\u003eabduction 2: Memoize. If you speed up finding the street with sparse table, you can get AC. Time complexity analysis is a little complicated. This margin is too narrow to contain. If you want to know, you shold read the Japanese editorial slide.\u003c/li\u003e   \u003cli\u003ecity: Index the nodes by euler-tour order. Encode nodes by pair of the id and interval length. Sum of the number of the descendants of each nodes are at most 18 N. So most of the lengths are very small. Representing length like \u003cspan class\u003d\"tex-span\"\u003e1.05\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e ( if you can\u0027t, add dummy nodes ) is very efficient in this case.\u003c/li\u003e   \u003cli\u003edragon 2: Sort points by the angles from X. sweep them by the angle. Use segtrees or BITs to manage current points by the order of the angle from Y. You can now answer queries efficiently. Sqrt decompose queries by the size, you can solve with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNsqrtQlogN\u003c/i\u003e)\u003c/span\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eUPD4:\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe score distribution and official editorial slides (Japanese) are distributed.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://www.ioi-jp.org/camp/2017/2017-sp-tasks/index.html\"\u003ehttps://www.ioi-jp.org/camp/2017/2017-sp-tasks/index.html\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}