{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1406584332,"rating":22,"authorHandle":"ErdemKirez","modificationTimeSeconds":1421005228,"id":13225,"title":"\u003cp\u003eCute LIS Implementation\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi everyone! I want to share a very cute LIS(Longest Increasing Subsequence) implementation.\u003c/p\u003e\u003cp\u003eI found it on \u003ca href\u003d\"http://comscigate.com/Books/contests/icpc.pdf\"\u003ehere.\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAlso thanks to \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/mnbvmar\" title\u003d\"Master mnbvmar\"\u003emnbvmar\u003c/a\u003e for improve the implementation.\u003c/p\u003e\u003cp\u003eBut this assumes no duplicates in array.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eset \u0026lt; int \u0026gt; s;\nset \u0026lt; int \u0026gt; :: iterator it;\n\n...\n\nFOR(i, 1, n)\n{\n    s.insert(a[i]);\n    \n    it \u003d s.upper_bound(a[i]);\n\n    if(it !\u003d s.end())\n        s.erase(it);\n}\n\ncout \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo I changed it to multiset, for duplicate.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003emultiset \u0026lt; int \u0026gt; s;\nmultiset \u0026lt; int \u0026gt; :: iterator it;\n\n...\n\nFOR(i, 1, n)\n{\n    s.insert(a[i]);\n    \n    it \u003d s.upper_bound(a[i]);\n    \n    if(it !\u003d s.end())\n        s.erase(it);\n}\n\ncout \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThere are seems work, and it\u0027s easy to proof them.\u003c/p\u003e\u003cp\u003eThanks for your reading :)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD :\u003c/strong\u003e I just found a similar approach for Longest Strictly Increasing Subsequence.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003emultiset \u0026lt; int \u0026gt; s;\nmultiset \u0026lt; int \u0026gt; :: iterator it;\n\n...\n\nFOR(i, 1, n)\n{\n    s.insert(a[i]);\n\n    it \u003d s.lower_bound(a[i]);\n\n    it++;\n\n    if(it !\u003d s.end())\n        s.erase(it);\n}\n\ncout \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eUPD2 :\u003c/strong\u003e You can solve \u003ca href\u003d\"http://www.spoj.com/problems/LMIS/\"\u003eLMIS\u003c/a\u003e(LIS) and \u003ca href\u003d\"http://www.spoj.com/problems/ELIS/\"\u003eELIS\u003c/a\u003e(LSIS) with this approach.\u003c/p\u003e\u003c/div\u003e","tags":["lis","set","multiset"]}}