{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1457004235,"rating":78,"authorHandle":"halyavin","modificationTimeSeconds":1457035160,"id":43538,"title":"\u003cp\u003eEducational Codeforces Round 9 Challenge Overview.\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e632A — Grandma Laura and Apples\u003c/h2\u003e\u003cp\u003eThere were no successful challenges for this problem. Thumbs up to everyone! I did find a couple of C/C++ solutions with uninitialized local variables though. Fortunately for them, the top of the stack is filled with zeros in the current testing system and compiler didn\u0027t decide to place uninitialized local variables in the register.\u003c/p\u003e\u003ch2\u003e632B — Alice, Bob, Two Teams\u003c/h2\u003e\u003cp\u003eThere was quite a variety of off-by-one errors in this problem. My most successful test was\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e2\n1 1\nBB\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSome solutions just have to flip something. The were also 2 challenges where solution got TL due to slow input.\u003c/p\u003e\u003cp\u003eThe most crazy uninitialized variable prize for this problem goes to \u003ca href\u003d\"/contest/632/submission/16447719\" title\u003d\"Submission 16447719 by SuSpiciO\"\u003e16447719\u003c/a\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ell n;\nv b(n);\n\ncin \u0026gt;\u0026gt; n;\n\nforn(i, n)\n{\n    cin \u0026gt;\u0026gt; b[i];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhat is the size of vector \u003ccode\u003eb\u003c/code\u003e? Definitely not \u003ccode\u003en\u003c/code\u003e. Fortunately for the author, it can\u0027t be challenged. Undefined behavior can work in your favor too. BTW, thanks to Codeforces for custom invocation feature. This is my go to tool when I need to know the value of an uninitialized variable.\u003c/p\u003e\u003ch2\u003e632C — The Smallest String Concatenation\u003c/h2\u003e\u003cp\u003eMost challenges in this problem were anti-quicksort tests for Free Pascal solutions. One person used normal sorting with lexicographical order followed by bubble sort using the correct order. Turned out this is not fast enough on certain tests. Understandably, not everyone knows how to use custom comparator. You can learn C++98 and C++11 way of doing this in the example section here: \u003ca href\u003d\"http://en.cppreference.com/w/cpp/algorithm/sort\"\u003estd::sort\u003c/a\u003e. I tried to challenge 2 C/C++ solutions with qsort() but both of them fit in the time limit despite spending O(\u003ci\u003en\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e) time for sorting. \u003c/p\u003e\u003ch2\u003e632D — Longest Subsequence\u003c/h2\u003e\u003cp\u003eMost challenges in this problem used test with the zero answer like:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e1 1\n2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI am surprised that this test was missing in the author test set. The other half of the challenges were caused by \u003ccode\u003em\u003c/code\u003e being bounded by only 438056 instead of 1000000 in the author test set. Some solutions were not fast enough and exceeded time limit for the largest value of \u003ccode\u003em\u003c/code\u003e. Also, some solutions didn\u0027t merge equal numbers in the input and were challenged by the test with all ones. Spending O(\u003ci\u003em\u003c/i\u003e) time for each one in the input doesn\u0027t fit in the time limit. There were also a couple challenges were authors initialized answer (\u003ci\u003ek\u003csub\u003emax\u003c/sub\u003e\u003c/i\u003e) with 1 instead of 0 while calculating LCM with the maximum answer. So in the case of single number in the input, they used default value of LCM equal to 1. This fails for the test with the different answer like this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e1 3\n2\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e632E — Thief in a Shop\u003c/h2\u003e\u003cp\u003eLet us denote \u003ci\u003ea\u003c/i\u003e the maximum number in the input. One solution tried to used normal O(\u003ci\u003ek\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e\u003ci\u003ean\u003c/i\u003e) dynamic programming approach (calculate the set of all sums of k numbers from a set of sums of k — 1 numbers) to this problem but with the twist: consecutive sums were compressed to a single interval. This worked very well on the author test set until it was challenged (not by me) with the test where all numbers are divisible by 3. One more solution were too close to the time limit and were hacked by random large test. \u003c/p\u003e\u003cp\u003eI challenged all solutions which used FFT over remainders by modulo \u003ci\u003ep\u003c/i\u003e with a single power step. All I needed is to construct a test where the number of ways to get the same sum is divisible by \u003ci\u003ep\u003c/i\u003e. I used the test of the form 1, 2, \u003ci\u003eN\u003c/i\u003e-\u003ci\u003ei\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e, \u003ci\u003eN\u003c/i\u003e-\u003ci\u003ei\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e, ... , \u003ci\u003eN\u003c/i\u003e-\u003ci\u003ei\u003c/i\u003e\u003csub\u003e2\u003ci\u003eD\u003c/i\u003e\u003c/sub\u003e. The sum \u003ci\u003eN\u003c/i\u003e + \u003ci\u003ek\u003c/i\u003e in this test can be represented in C\u003csup\u003e\u003ci\u003ei\u003c/i\u003e\u003csub\u003e1\u003c/sub\u003e\u003c/sup\u003e\u003csub\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e+C\u003csup\u003e\u003ci\u003ei\u003c/i\u003e\u003csub\u003e2\u003c/sub\u003e\u003c/sup\u003e\u003csub\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e+...+C\u003csup\u003e\u003ci\u003ei\u003c/i\u003e\u003csub\u003e2\u003ci\u003eD\u003c/i\u003e\u003c/sub\u003e\u003c/sup\u003e\u003csub\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e ways as a sum of \u003ci\u003ek\u003c/i\u003e+1 numbers where C is binomial coefficient. So I just need to find the set of binomial coefficients which sum is divisible by \u003ci\u003ep\u003c/i\u003e. How did I do that? Why I use even number of binomial coefficients? \u003ci\u003eMeet\u003c/i\u003e me \u003ci\u003ein the middle\u003c/i\u003e here, I can\u0027t tell you everything.\u003c/p\u003e\u003cp\u003eUnfortunately, there were no way to challenge dynamic programming solutions. These solutions first subtract the minimum number from the rest of them. This step reduces the problem to a case where the first number is zero. Since zeros doesn\u0027t influence sums, we now need to calculate all the sums of no more than \u003ci\u003ek\u003c/i\u003e of non-zero numbers. Our dynamic programming will store for each sum the least number of non-zero numbers needed to get it. We will add non-zero numbers one by one. Each time we need O(\u003ci\u003eak\u003c/i\u003e) time to recalculate dynamic programming values. Recalculation should be done from small sums to large so that the current non-zero number could be used multiple times. After \u003ci\u003en-1\u003c/i\u003e steps we choose all sums with values less than or equal to \u003ci\u003ek\u003c/i\u003e. The time complexity of this algorithm is O(\u003ci\u003eakn\u003c/i\u003e).\u003c/p\u003e\u003ch2\u003e632F — Magic Matrix\u003c/h2\u003e\u003cp\u003eA lot of solutions for this problem just randomly choose triplets \u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e and check condition from the problem statement. They can be challenged by the graph where all edges have length 2 except a single triangle which contains 2 edges of length 0 and 1 edge of length 1. This triangle is the only triplet which doesn\u0027t satisfy magic matrix conditions in this graph. A couple solutions tried to optimize the full search by excluding some triplets using various conditions but these optimizations doesn\u0027t improve the worst time complexity of O(\u003ci\u003en\u003c/i\u003e\u003csup\u003e3\u003c/sup\u003e). A couple solutions only checked triplets with \u003ci\u003ei\u003c/i\u003e \u003d 0 and a couple more only checked some naive properties like all maximum values in rows are equal to each other.\u003c/p\u003e\u003cp\u003eThe prize for the most confusing undefined behavior goes to \u003ca href\u003d\"/contest/632/submission/16449526\" title\u003d\"Submission 16449526 by duyboy135\"\u003e16449526\u003c/a\u003e. What the first \u003ccode\u003esolve\u003c/code\u003e function returns at the end? Does it even matter? Experimentally, I figured out that it is simply missing \u003ccode\u003ereturn true\u003c/code\u003e. I couldn\u0027t challenge it but it failed system tests. I don\u0027t know whether it was caused by undefined behavior or some other error though.\u003c/p\u003e\u003cp\u003ePS If I missed some interesting challenge, post it in the comments.\u003c/p\u003e\u003c/div\u003e","tags":["educational round 9","challenge"]}}