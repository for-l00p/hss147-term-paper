{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1500467958,"rating":0,"authorHandle":"BaqablH","modificationTimeSeconds":1500650111,"id":53381,"title":"\u003cp\u003eConcurs Dilluns\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem A: Taymyr is calling you\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eTenieu dues opcions: a) Iterar sobre els dies i anar comptant aquells que fossin múltiples de \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e i \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\nusing namespace std;\n\nint main(){\n\tint n, m, z;\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; z;\n\tint ans \u003d 0;\n\tfor (int i \u003d 1; i \u0026lt;\u003d z; ++i){\n\t\tif (i%m \u003d\u003d 0 and i%n \u003d\u003d 0) ++ans;\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eb) Calcular \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emcm\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e. La resposta simplement era la divisió entera \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/62/66/6266b695da9b7ba295501e6a37bf2342e4a02cd5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. (Recordeu que \u003cspan class\u003d\"tex-span\"\u003e⌊ \u003ci\u003ex\u003c/i\u003e⌋\u003c/span\u003e representa l\u0027enter més gran que sigui més petit o igual que \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\nusing namespace std;\n\nint mcd (int a, int b){\n\tif (b \u003d\u003d 0) return a;\n\telse return mcd(b, a%b);\n}\n\nint mcm (int a, int b){\n\treturn a*b/mcd(a,b);\n}\n\nint main(){\n\tint n, m, z;\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; z;\n\tcout \u0026lt;\u0026lt; z/mcm(n,m) \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem B: A Serial Killer\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eSimplement guardeu les dues strings del principi (les dues víctimes potencials), i per cada parell de strings que us vagin donant aneu reemplaçant la víctima potencial del primer string per la del segon.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\nusing namespace std;\n\nint main(){\n\tstring a, b;\n\tcin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\tint n;\n\tcin \u0026gt;\u0026gt; n;\n\tfor (int i \u003d 0; i \u0026lt; n; ++i){\n\t\tcout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl;\n\t\tstring c, d;\n\t\tcin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d;\n\t\tif (c \u003d\u003d a) a \u003d d;\n\t\telse b \u003d d;\n\t}\n\tcout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem C: Treasure Hunt\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eMireu el desplaçament \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eX\u003c/i\u003e, \u003ci\u003eY\u003c/i\u003e)\u003c/span\u003e que heu de fer per a anar des del capità fins al tresor. Si \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e o \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e no divideixen \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e i \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e, respectivament, és impossible arribar-hi. Altrament, és relativament fàcil veure que només s\u0027hi pot arribar si \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eX\u003c/i\u003e / \u003ci\u003ex\u003c/i\u003e) + (\u003ci\u003eY\u003c/i\u003e / \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e és parell.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\nusing namespace std;\n\nint main(){\n    int a, b, A, B, x, y;\n    cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n    int X \u003d a - A;\n    int Y \u003d b - B;\n    if (X%x !\u003d 0 or Y%y !\u003d 0) {\n        cout \u0026lt;\u0026lt; \u0026quot;NO\u0026quot; \u0026lt;\u0026lt; endl;\n        return 0;\n    }\n    int i \u003d X/x;\n    int j \u003d Y/y;\n\tif ((i+j)%2 \u003d\u003d 0) cout \u0026lt;\u0026lt; \u0026quot;YES\u0026quot; \u0026lt;\u0026lt; endl;\n\telse cout \u0026lt;\u0026lt; \u0026quot;NO\u0026quot; \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem D: Makes And The Product\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eBusqueu els tres elements més petits que hi ha a l\u0027array (ordenant-lo, per exemple). Aquests us donaran el producte mínim. Si el nombre \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e hi apareix \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e cops a l\u0027array, i \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e cops en multiconjunt dels tres elements més petits (la diferència entre un multiconjunt i un conjunt és el que el primer pot tenir elements repetits i el segon no), la resposta serà el producte dels \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/37/bd/37bd8c719dbbf3d6519248e75af85d95bfecbddf.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, mutiplicant sobre aquells valors de \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e tals que algun dels tres elements més petits és \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. I sí, era el problema complicat...\u003c/p\u003e\u003cp\u003eEn el codi \u003ccode\u003ecomb (n, k)\u003c/code\u003e retorna \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bc/e4/bce44f221b563fc5894d1dce40cdc38e225529dc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, computat ràpidament ja que \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e és com a molt \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e, i usant long longs, i l\u0027expressió \u003ccode\u003e(v[0] \u003d\u003d v[i]) + (v[1] \u003d\u003d v[i]) + (v[2] \u003d\u003d v[i])\u003c/code\u003e diu quants elements, d\u0027entre els més petits, són iguals a \u003ccode\u003ev[i]\u003c/code\u003e. Penseu per què ;)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\nusing namespace std;\n\nlong long int comb (int n, int k){\n\tlong long int a \u003d 1;\n\tfor (int j \u003d 0; j \u0026lt; k; ++j) a *\u003d (n-j);\n    for (int j \u003d 1; j \u0026lt;\u003d k; ++j) a /\u003d j;\n    return a;\n}\n\nint main(){\n    int n;\n    cin \u0026gt;\u0026gt; n;\n    vector \u0026lt;int\u0026gt; v(n);\n    for (int i \u003d 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; v[i];\n    sort(v.begin(), v.end());\n    \n    long long ans \u003d 1;\n    for (int i \u003d 0; i \u0026lt; 3; ++i){\n        if (i \u003d\u003d 0 or v[i] !\u003d v[i-1]){\n            int c \u003d 1;\n            while (i+c \u0026lt; v.size() and v[i+c] \u003d\u003d v[i]) ++c;\n            \n            ans *\u003d comb(c, (v[0] \u003d\u003d v[i]) + (v[1] \u003d\u003d v[i]) + (v[2] \u003d\u003d v[i]));\n        }\n    }\n    cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem E: Table Tennis Game 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eÉs senzill veure que només hi ha dos casos en que el joc és impossible: Si ambdós jugadors no tenen punts suficients com per a haver completat un set, o bé un no els té, i l\u0027altre no té un nombre de punts múltiple de \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\nusing namespace std;\n\nint main(){\n\tint k, a, b;\n\tcin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\tif (a \u0026lt; b) swap(a, b);\n\tif (a \u0026lt; k and b \u0026lt; k){\n\t\tcout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl;\n\t\treturn 0;\n\t}\n\tif (a%k !\u003d 0 and b/k \u003d\u003d 0){\n\t\tcout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl;\n\t\treturn 0;\n\t}\n\tcout \u0026lt;\u0026lt; a/k + b/k \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}