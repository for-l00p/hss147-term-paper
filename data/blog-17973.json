{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1432020606,"rating":13,"authorHandle":"bholagabbar","modificationTimeSeconds":1443207805,"id":17973,"title":"\u003cp\u003eBitMasking \u0026amp; Subset Listing for Absolute Beginners\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI happened to write an answer on Quora yesterday for \u003cstrong\u003e\u0027How to list all the subsets of a set where elements need not be necessarily unique\u0027\u003c/strong\u003e. \u003ca href\u003d\"http://qr.ae/fwOCc\"\u003ehttp://qr.ae/fwOCc\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThough several tutorials already exist, here is my \u0027simplified\u0027 version solving the above problem using bitmasking because personally, I was really confused when i learnt this first. Also, this is my first attempt at writing something. Please feel free to comment/criticize and please upvote if you liked the explanation :)\u003c/p\u003e\u003cp\u003eMore than often, problems where you feel the answer can be found after brute forcing through all the subsets, have smarter and more efficient solutions using Dynamic Programming. Have a look at an Introduction to the Knapsack Problem and Dynamic Programming: \u003ca href\u003d\"http://www.cs.rit.edu/~zjb/courses/800/lec7.pdf\"\u003ehttp://www.cs.rit.edu/~zjb/courses/800/lec7.pdf\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThat aside, if n is reasonably small, you CAN use BruteForce and list down all the subsets in the process. As mentioned, we will use the technique of BitMasking.\u003c/p\u003e\u003cp\u003eAlright, so lets start by trying to solve the above problem and we\u0027ll learn the concept through that. The question essentially boils down to \u003cstrong\u003eFinding the Power Set of a given Set\u003c/strong\u003e. The set here may contain multiple elements. The term \u0027Multiset\u0027 is more appropriate...but well, lets just stick to set.\u003c/p\u003e\u003cp\u003eFirst of all, we \u003cstrong\u003eClaim\u003c/strong\u003e that :\u003c/p\u003e\u003cp\u003e\u003cem\u003e\u003cstrong\u003e\u0026quot;If we list down all the binary numbers from 0 to (2^n)-1 , we get ALL the possible combinations of selecting n items\u0026quot;\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eLets verify for n\u003d3\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e000: None of the values in the set chosen\u003c/p\u003e\u003cp\u003e001: 1st chosen, 2nd and 3rd items left out\u003c/p\u003e\u003cp\u003e010: 2nd chosen, 1st and 3rd items left out\u003c/p\u003e\u003cp\u003e011: 1st and 2rd item chosen, 3rd one left out.\u003c/p\u003e\u003cp\u003e...\u003c/p\u003e\u003cp\u003e111: All 3 items chosen\u003c/p\u003e\u003cp\u003eThis way, we have listed the 2^n ways of obtaining all the subsets from a set of n numbers. Unique or not, does not matter because the index of every element we are dealing with is unique.\u003c/p\u003e\u003cp\u003eNow for the computation part, the core idea is to brute force through every bit of every number from 0-2^n-1 and check for the set bits of each number. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eAlgorithm:\u003c/strong\u003e\u003c/p\u003e \u003col\u003e   \u003cli\u003eRun a loop for \u0027i\u0027 for all numbers from 0 to 2^(n-1).\u003c/li\u003e   \u003cli\u003eWhen inside this loop, run a loop for \u0027j\u0027 from 0 to n-1 inclusive\u003c/li\u003e   \u003cli\u003eInside this loop, check if the \u0027j\u0027th bit is SET(equal to 1) for the number \u0027i\u0027.\u003c/li\u003e   \u003cli\u003eIf it is, then we include this element in our \u0027i\u0027th subset\u003c/li\u003e   \u003cli\u003eDone.\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eI was very confused when I learnt this the first time, so let me demonstrate with a small example: say for i\u003d3, the binary representation is 011. When we run the inner loop from 1 to n for i which is currently 3, here\u0027s what we are actially doing.\u003c/p\u003e \u003col\u003e   \u003cli\u003eIs the right most (LSB) bit set? Yes. So Include it. [01x]\u003c/li\u003e   \u003cli\u003eIs the middle bit set? Yes. So Include it. [0x1]\u003c/li\u003e   \u003cli\u003eIs the last (MSB) bit set? No. So Leave it out. [x11]\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eWhat we are essentially doing is that \u003cem\u003e\u003cstrong\u003eFor every iteration of \u0027j\u0027, we are \u0027masking\u0027 all the bits in \u0027i\u0027 except for the bit at the \u0027j\u0027th position\u003c/strong\u003e\u003c/em\u003e. Hence the name \u003cstrong\u003eBitMasking\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eWe use the BitWise \u0027\u0026lt;\u0026lt;\u0027 operator for shifting the bit to be checked each time in j. (We are taking the BitWise \u0027\u0026amp;\u0027 operation of 1 and x. If it is 1, it is SET since in boolean algebra, only 1.1\u003d1)\u003c/p\u003e\u003cp\u003eHere\u0027s a code snippet in \u003cstrong\u003ePython\u003c/strong\u003e. \u003c/p\u003e\u003cp\u003eCode:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003en\u003deval(input(\u0026quot;Enter n: \u0026quot;)) # keep sub 20-ish max\nfor i in range(0,(2**n)):# loop from 0 to (2^n)-1\n    cursub\u003d\u0026quot;Current Subset Contains Elements: \u0026quot;\n    for j in range(0,n):\n        if((1\u0026lt;\u0026lt;j) \u0026amp; i \u0026gt;0): #Checking if jth bit in i is set\n            cursub+\u003d(str(j+1)+\u0026quot; \u0026quot;)   \n    print (cursub)\nprint (\u0026quot;All \u0026quot;, (2**n),\u0026quot; Subsets printed\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eObviously, what the point of just listing down the subset? You would want to perform certain operations on say the selected bits/elements of that given set. For this, naturally, we maintain an arraay of n elements. So, for example, your task it to find the product of every element of each subset. In this case we maintain a number temp\u003d1 before every ith iteration. Whenever you encounter a set bit in a number, multiply the element at that number, e.i array[i] with temp. At the end of every iteration, you get your desired result.\u003c/p\u003e\u003cp\u003eCode in action: \u003ca href\u003d\"http://ideone.com/8vfz4U\"\u003ehttp://ideone.com/8vfz4U\u003c/a\u003e\u003c/p\u003e\u003cp\u003eProblems you can try: \u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://www.codechef.com/problems/MARCHA1/\"\u003ehttp://www.codechef.com/problems/MARCHA1/\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/550/B\"\u003ehttp://codeforces.com/problemset/problem/550/B\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["bitmasking","brute force","subset","simple"]}}