{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1433424424,"rating":8,"authorHandle":"Sehnsucht","modificationTimeSeconds":1433433625,"id":18320,"title":"\u003cp\u003eАномалия в \u0026quot;запуске\u0026quot; Codeforces\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eПытаюсь впихнуть \u003cs\u003eневпихуемое\u003c/s\u003e задачу на битмаски, где можно брать либо 1 либо 2 предмета, с TL до 4000ms\u003cbr /\u003e Пока смотрю, сколько времени будет работать максимальный тест. Вот тут код:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint main() {\n    int p \u003d 24;     // Кол-во предметов максимум\n    int al \u003d (1 \u0026lt;\u0026lt; p);      // Кол-во масок, \u0026quot;1\u0026quot; - предмет под i-тым битом уже взят\n    int vec[1 \u0026lt;\u0026lt; 24];    // Ответы к подзадачам\n    int vec2[1 \u0026lt;\u0026lt; 24];\n    int inf \u003d 1000000005;\n    fill(vec, vec + al, inf);\n    vector\u0026lt;int\u0026gt; kek;\n    vec[0] \u003d 0;\n    for(int z \u003d 1; z \u0026lt; al; z++) {\n        // Вместо перебора 24 * (24 - 1) / 2 значений перебираем\n        // места, где есть биты\n        kek.clear();\n        for(int ss \u003d 0; ss \u0026lt; 24; ss++)\n            if(z \u0026amp; (1 \u0026lt;\u0026lt; ss))\n                kek.push_back(ss);\n\n        // Оптимальный ответ\n        int last \u003d inf;\n\n        for(int a \u003d 0; a \u0026lt; kek.size(); a++) {\n            int az \u003d z - (1 \u0026lt;\u0026lt; kek[a]);\n            if(last \u0026gt; vec[az] + 1)\n                last \u003d vec[az] + 1;\n            for(int b \u003d a + 1; b \u0026lt; kek.size(); b++) {\n                int bz \u003d az - (1 \u0026lt;\u0026lt; kek[b]);\n                if(last \u0026gt; vec[bz] + 2)\n                    last \u003d vec[bz] + 2;\n            }\n        }\n\n        //vec[z] \u003d last;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eПредполагается, что в переменной last сохраняется оптимальный ответ (конечно, не просто vec[xx]+2, а по нужной формуле расстояний между предметами kek[a] и kek[b])\u003cbr /\u003e Запуск codeforces этого кода в GNU C++ работает за \u003cstrong\u003e1309ms\u003c/strong\u003e (погрешность +-15ms)\u003cbr /\u003e Если раскомментировать строку \u0026quot;vec[z] \u003d last;\u0026quot; это работает за \u003cstrong\u003e4040ms\u003c/strong\u003e\u003cbr /\u003e Наконец, если завести новый массив vec2 и заменить строку на \u0026quot;vec2[z] \u003d last;\u0026quot;, это работает практически за то же время что в первый раз — \u003cstrong\u003eот 1294ms до 1310ms\u003c/strong\u003e\u003cbr /\u003e\u003cbr /\u003e Вот это прикол! Какое его научное обоснование?\u003c/p\u003e\u003c/div\u003e","tags":[]}}