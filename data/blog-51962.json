{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1494677697,"rating":126,"authorHandle":"zscoder","modificationTimeSeconds":1494677697,"id":51962,"title":"\u003cp\u003eTinkoff Challenge — Final Round Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eBank Robbery\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eAuthor : \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/zscoder\" title\u003d\"Гроссмейстер zscoder\"\u003ezscoder\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is a simple implementation problem. We iterate through all banknotes one by one and check if Oleg can take each of them. If a banknote is at position \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, then Oleg can take it if and only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e \u0026lt; \u003ci\u003ex\u003c/i\u003e \u0026lt; \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e. This can be checked in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time. Thus, the total complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. Note that the information on the starting position of Oleg is useless here.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;ll\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint a, b, c; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c;\n\tint n; cin\u0026gt;\u0026gt;n;\n\tint ans\u003d0;\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tint x; cin\u0026gt;\u0026gt;x;\n\t\tif(x\u0026gt;b\u0026amp;\u0026amp;x\u0026lt;c) ans++;\n\t}\n\tcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCutting Carrot\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eAuthor : \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/zscoder\" title\u003d\"Гроссмейстер zscoder\"\u003ezscoder\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s find the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e explicitly. Suppose we make the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th cut and distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e from the apex. Then, the ratio of similitude of the isosceles triangle with apex equal to the apex of the carrot and the base equal to the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th cut and the whole carrot is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/60/36/6036d2213bc63aee45445768356e98dc089b7306.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Since the area of this smaller isosceles triangle is the sum of areas of the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e pieces, which is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/78/b8/78b8821fd29fc862818b3ec518d740e50a45ee10.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e of the whole carrot. Thus, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/96/12/961291645791ff9ec9b7eb8bc80fd316ebbdaef1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, which is equivalent to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f1/e9/f1e9ec88cd2b61c35e0d2b0720406e2606430d61.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Thus, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bb/84/bb84c4eb00125418247af391ecb8b7364899c9a9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e and we can find each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time. The total complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;ll\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll n, h; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;h;\n\tfor(int i\u003d1;i\u0026lt;\u003dn-1;i++)\n\t{\n\t\tcout\u0026lt;\u0026lt;fixed\u0026lt;\u0026lt;setprecision(12)\u0026lt;\u0026lt;sqrt(ld(i)/ld(n))*ld(h);\n\t\tif(i\u0026lt;n-1) cout\u0026lt;\u0026lt;\u0027 \u0027;\n\t}\t\n\tcout\u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eNaming Company\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eAuthor : \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/zscoder\" title\u003d\"Гроссмейстер zscoder\"\u003ezscoder\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst, it is clear that Oleg will place \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e5/d4/e5d4018d45a31f94e9f6085ba2379d80ca762b3b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e letters and Igor will place \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6d/7e/6d7e26fd9640549ef91531adbe73696736f42cd9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e letters. Next, it is clear that Oleg and Igor will both choose their smallest and biggest letters respectively to place in the final string. Thus, we now consider that Oleg places his smallest \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e5/d4/e5d4018d45a31f94e9f6085ba2379d80ca762b3b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e letters and Igor places his largest \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6d/7e/6d7e26fd9640549ef91531adbe73696736f42cd9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e letters.\u003c/p\u003e\u003cp\u003eConsider the following greedy strategy. When it\u0027s Oleg\u0027s turn, he will replace the frontmost question mark with his smallest letter. When it\u0027s Igor\u0027s turn, he will replace the frontmost question mark with his largest letter. At first glance, you might think that this works. However, there\u0027s another case that we haven\u0027t considered.\u003c/p\u003e\u003cp\u003eSuppose Oleg has the letters \u003cspan class\u003d\"tex-span\"\u003e{\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e, \u003ci\u003ez\u003c/i\u003e}\u003c/span\u003e and Igor has the letters \u003c/p\u003e\u003cp\u003eUnable to parse markup [type\u003dCF_TEX]\u003c/p\u003e. According to our previous strategy, Oleg will place x as the first letter. However, that\u0027s not optimal. He can place his letters at the back and force Igor to place the first letter. The reason is because the largest letter of Igor is not larger than the smallest letter of Oleg. Thus, it is beneficial for Oleg to place his letters at the back and force Igor to place his letters in front.\u003cp\u003eSo, what exactly will the final string look like? We\u0027ll look at the moves one by one. If at some point Oleg\u0027s smallest letter is still strictly smaller than Igor\u0027s largest letter, then both player must put their smallest (largest if it\u0027s Igor) letter as the frontmost letter. Why? Suppose not, then on the next turn the other player will occupy that spot with their best (smallest if Oleg, largest if Igor) letter, and the resulting string will be worse for the current player. This proves that greedy is correct in this case.\u003c/p\u003e\u003cp\u003eNow, what if Oleg\u0027s smallest letter is not smaller than Igor\u0027s largest letter. In this case, both players will want to force the other player to place their own letter at the beginning of the string. It can be proven that in this case, each person will place their current worst (largest if Oleg, smallest if Igor) letter at the back of the string in the optimal strategy. Thus, we can calculate the final string starting from this point and after that reverse this part and combine it with the first part of the string where both players greedily place their best letters in the beginning.\u003c/p\u003e\u003cp\u003eTime Complexity : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003eMany people failed on pretest 6 initially because they didn\u0027t consider the second case.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;ll\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tstring ansl;\n\tstring ansr;\n\tstring s,t;\n\tcin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t;\n\tsort(s.begin(),s.end());\n\tsort(t.begin(),t.end());\n\treverse(t.begin(),t.end());\n\tint n \u003d s.length();\n\tdeque\u0026lt;char\u0026gt; a,b;\n\tfor(int i\u003d0;i\u0026lt;(n+1)/2;i++)\n\t{\n\t\ta.pb(s[i]);\n\t}\n\tfor(int i\u003d0;i\u0026lt;n/2;i++)\n\t{\n\t\tb.pb(t[i]);\n\t}\n\tbool mode\u003d0;\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tif(i\u0026amp;1)\n\t\t{\n\t\t\tif(!a.empty()\u0026amp;\u0026amp;a[0]\u0026gt;\u003db[0])\n\t\t\t{\n\t\t\t\tmode\u003d1;\n\t\t\t}\n\t\t\tif(mode)\n\t\t\t{\n\t\t\t\tansr+\u003db.back();\n\t\t\t\tb.pop_back();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tansl+\u003db[0];\n\t\t\t\tb.pop_front();\n\t\t\t}\n\t\t}\n\t\telse //P1\u0027s turn\n\t\t{\n\t\t\tif(!b.empty()\u0026amp;\u0026amp;a[0]\u0026gt;\u003db[0])\n\t\t\t{\n\t\t\t\tmode\u003d1;\n\t\t\t}\n\t\t\tif(mode)\n\t\t\t{\n\t\t\t\tansr+\u003da.back();\n\t\t\t\ta.pop_back();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tansl+\u003da[0];\n\t\t\t\ta.pop_front();\n\t\t\t}\n\t\t}\n\t}\n\treverse(ansr.begin(),ansr.end());\n\tansl+\u003dansr;\n\tcout\u0026lt;\u0026lt;ansl\u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eLabelling Cities\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eAuthor : \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/AnonymousBunny\" title\u003d\"Кандидат в мастера AnonymousBunny\"\u003eAnonymousBunny\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAdd each vertex to its own adjacency list. Now, we claim that if it is possible to label the cities to satisfy the problem conditions, then it is possible to do so so that for every two cities with the same adjacency list, they\u0027re labelled with the same number.\u003c/p\u003e\u003cp\u003eIndeed, if they have the same adjacency list, they must be neighbours. Thus, the difference between their labels is at most \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Suppose we label the first vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e with number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and the second vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e with the number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e. Note that since their adjacency lists are equal, a vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is a neighbour of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e iff it\u0027s a neighbour of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. Thus, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e can\u0027t have neighbours with labels \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 2\u003c/span\u003e, or else it will contradict the condition. Thus, all neighbours of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e have labels \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e. Thus, we can safely change the label of the second vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and the conditions will still hold.\u003c/p\u003e\u003cp\u003eThus, we can sort the set of adjacency lists of each vertex, and then group the vertices with the same adjacency list together. Suppose there are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e such groups. For simplicity, we can create a new graph where each group represent a vertex of the new graph. Connect two groups \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e if and only if there exist some vertex in group \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e that connects to a vertex in group \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. Note that the graph will have at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003em\u003c/i\u003e)\u003c/span\u003e edges. Now, if a vertex has degree \u003cspan class\u003d\"tex-span\"\u003e ≥ 3\u003c/span\u003e, we can\u0027t assign a number to that vertex properly, as one of its neighbours will not have a label which have a difference \u003cspan class\u003d\"tex-span\"\u003e ≤ 1\u003c/span\u003e from it. Thus, all vertices in the new graph must have degree \u003cspan class\u003d\"tex-span\"\u003e ≤ 2\u003c/span\u003e. Since it\u0027s connected, it must be either a cycle or a path. However, it can be easily seen that there is no labelling if it\u0027s a cycle. Thus, it must be a path. Now, we can just assign the labels to the graph from one end of the path to the other end by the numbers \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Finally, the label of a vertex is simply the label of its group.\u003c/p\u003e\u003cp\u003eThis solution can be implemented in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ae/c7/aec7b46970a8ec230adde350fa8a1633f6330852.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;int,int\u0026gt; ii;\ntypedef vector\u0026lt;ll\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int N \u003d 300000;\n\npair\u0026lt;vi,int\u0026gt; adj[N+2];\nint ans[N+2];\nint lab[N+2];\nint lab2[N+2];\nset\u0026lt;int\u0026gt; adj2[N+2];\nvector\u0026lt;ii\u0026gt; edges;\n\nstruct DSU\n{\n\tint S;\n\t\n\tstruct node\n\t{\n\t\tint p; ll sum;\n\t};\n\tvector\u0026lt;node\u0026gt; dsu;\n\t\n\tDSU(int n)\n\t{\n\t\tS \u003d n;\n\t\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t\t{\n\t\t\tnode tmp;\n\t\t\ttmp.p \u003d i; tmp.sum \u003d 0;\n\t\t\tdsu.pb(tmp);\n\t\t}\n\t}\n\t\n\tvoid reset(int n)\n\t{\n\t\tdsu.clear();\n\t\tS \u003d n;\n\t\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t\t{\n\t\t\tnode tmp;\n\t\t\ttmp.p \u003d i; tmp.sum \u003d 0;\n\t\t\tdsu.pb(tmp);\n\t\t}\n\t}\n\t\n\tint rt(int u)\n\t{\n\t\tif(dsu[u].p \u003d\u003d u) return u;\n\t\tdsu[u].p \u003d rt(dsu[u].p);\n\t\treturn dsu[u].p;\n\t}\n\t\n\tvoid merge(int u, int v)\n\t{\n\t\tu \u003d rt(u); v \u003d rt(v);\n\t\tif(u \u003d\u003d v) return ;\n\t\tif(rand()\u0026amp;1) swap(u, v);\n\t\tdsu[v].p \u003d u;\n\t\tdsu[u].sum +\u003d dsu[v].sum;\n\t}\n\t\n\tbool sameset(int u, int v)\n\t{\n\t\tif(rt(u) \u003d\u003d rt(v)) return true;\n\t\treturn false;\n\t}\n\t\n\tll getstat(int u)\n\t{\n\t\treturn dsu[rt(u)].sum;\n\t}\n};\n\ndeque\u0026lt;int\u0026gt; chain;\n\nvoid dfs(int u, int p, bool type)\n{\n\tif(type) chain.pb(u);\n\telse chain.push_front(u);\n\tint c\u003d0;\n\tfor(sit it \u003d adj2[u].begin(); it !\u003d adj2[u].end(); it++)\n\t{\n\t\tint v \u003d (*it);\n\t\tif(v\u003d\u003dp) continue;\n\t\tif(p!\u003d-1)\n\t\t{\n\t\t\tdfs(v,u,type);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdfs(v,u,c);\n\t\t\tc++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\t//ios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, m; scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;n, \u0026amp;m);\n\tfor(int i \u003d 0; i \u0026lt; m; i++)\n\t{\n\t\tint u, v; scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;u, \u0026amp;v);\n\t\tu--; v--;\n\t\tadj[u].fi.pb(v);\n\t\tadj[v].fi.pb(u);\n\t\tedges.pb(mp(u,v));\n\t}\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tadj[i].fi.pb(i);\n\t\tadj[i].se \u003d i;\n\t\tsort(adj[i].fi.begin(),adj[i].fi.end());\n\t}\n\tsort(adj,adj+n);\n\tint cnt \u003d 1;\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tif(i\u003d\u003d0) \n\t\t{\n\t\t\tlab[adj[i].se] \u003d cnt;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(adj[i].fi\u003d\u003dadj[i-1].fi)\n\t\t\t{\n\t\t\t\tlab[adj[i].se]\u003dcnt;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlab[adj[i].se]\u003d++cnt;\n\t\t\t}\n\t\t}\n\t}\n\tif(cnt\u003d\u003d1)\n\t{\n\t\tprintf(\u0026quot;YES\\n\u0026quot;);\n\t\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t\t{\n\t\t\tprintf(\u0026quot;%d \u0026quot;,lab[i]);\n\t\t}\n\t\tprintf(\u0026quot;\\n\u0026quot;);\n\t\treturn 0;\n\t}\n\tDSU dsu(cnt+1);\n\tfor(int i \u003d 0; i \u0026lt; m; i++)\n\t{\n\t\tint u \u003d edges[i].fi; int v \u003d edges[i].se;\n\t\tif(lab[u]!\u003dlab[v])\n\t\t{\n\t\t\tadj2[lab[u]].insert(lab[v]);\n\t\t\tadj2[lab[v]].insert(lab[u]);\n\t\t\tdsu.merge(lab[u],lab[v]);\n\t\t}\n\t}\n\tbool pos \u003d 1;\n\tfor(int i \u003d 1; i \u0026lt;\u003d cnt; i++)\n\t{\n\t\tif(dsu.rt(i)!\u003ddsu.rt(1))\n\t\t{\n\t\t\tpos\u003d0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!pos)\n\t{\n\t\tprintf(\u0026quot;NO\\n\u0026quot;);\n\t\treturn 0;\n\t}\n\tint d1 \u003d 0;\n\tfor(int i \u003d 1; i \u0026lt;\u003d cnt; i++)\n\t{\n\t\tif(adj2[i].size()\u0026gt;2)\n\t\t{\n\t\t\tprintf(\u0026quot;NO\\n\u0026quot;);\n\t\t\treturn 0;\n\t\t}\n\t\tif(adj2[i].size()\u003d\u003d1) d1++;\n\t\telse assert(adj2[i].size()\u003d\u003d2);\n\t}\n\tif(d1\u003d\u003d2)\n\t{\n\t\tprintf(\u0026quot;YES\\n\u0026quot;);\n\t\tdfs(1,-1,0);\n\t\tfor(int i \u003d 0; i \u0026lt; chain.size(); i++)\n\t\t{\n\t\t\tlab2[chain[i]] \u003d i+1;\n\t\t}\n\t\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t\t{\n\t\t\tprintf(\u0026quot;%d \u0026quot;,lab2[lab[i]]);\n\t\t}\n\t\tprintf(\u0026quot;\\n\u0026quot;);\n\t}\n\telse\n\t{\n\t\tprintf(\u0026quot;NO\\n\u0026quot;);\n\t\treturn 0;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eChoosing Carrot\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eAuthor : \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/zscoder\" title\u003d\"Гроссмейстер zscoder\"\u003ezscoder\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst, we solve the problem when no one has any extra turns.\u003c/p\u003e\u003cp\u003eSuppose we\u0027re binary searching the answer. Let all the numbers \u003cspan class\u003d\"tex-span\"\u003e ≥ \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e be equal to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and all the numbers \u003cspan class\u003d\"tex-span\"\u003e \u0026lt; \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e be equal to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. Both players can remove one number from one end of the row. The goal of the first player is to let the remaining number be \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and the goal of the second player is to leave \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e in the end. If the first player can win, this means that the answer is at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Thus, we first try to solve this simpler problem.\u003c/p\u003e\u003cp\u003eWe claim that the first player wins if and only if :\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is even and one of the two middle numbers is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is odd, the middle digit is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and at least one of the digits beside the middle digit is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e (unless \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 1\u003c/span\u003e, for which first players wins when the only carrot is labelled \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e)\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eIndeed, once we deduce this, we can easily prove this by induction on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. The proof is just doing casework and considering all possible moves.\u003c/p\u003e\u003cp\u003eOnce we have this fact, we realize we don\u0027t actually have to binary search the answer. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is even, the answer is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3f/70/3f70d854a06d9c72c19391d22798f1b94a60a64a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e while if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≥ 3\u003c/span\u003e is odd, the answer is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5f/75/5f75e0d04f5248def44d08f904a08a48213ef1c5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. (If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 1\u003c/span\u003e then the answer is obviously \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e.)\u003c/p\u003e\u003cp\u003eNow, we have to take extra moves into account. Fortunately, it\u0027s not very difficult. Having \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e extra moves just means that Player \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e can choose to start the game in any subsegment of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Thus, we just have to compute the maximum answer for all subsegments of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003ek\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e. With the formula above, you can find all the answers in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e time or even \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5d/1f/5d1f29f648247e77966a5b1703590aea2a6a75b6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time if you use sparse table for range maximum query.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;ll\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nint a[300001];\nint ans[300001];\nint b[300001];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin\u0026gt;\u0026gt;n;\n\tint mx\u003d0;\n\tfor(int i\u003d0;i\u0026lt;n;i++) \n\t{\n\t\tcin\u0026gt;\u0026gt;a[i];\n\t\tmx\u003dmax(mx,a[i]);\n\t}\n\tfor(int i\u003d0;i\u0026lt;n-2;i++)\n\t{\n\t\tb[i]\u003dmin(a[i+1],max(a[i],a[i+2]));\n\t}\n\tans[n-1]\u003dmx;\n\tint odd\u003dn;int even\u003dn;\n\tif(n\u0026amp;1) even\u003dn-1;\n\telse odd\u003dn-1;\n\tmx\u003d0;\n\tfor(int i\u003deven;i\u0026gt;\u003d2;i-\u003d2)\n\t{\n\t\tint l \u003d (i-1)/2; int r\u003dn-i/2;\n\t\tassert(l\u0026lt;\u003dr);\n\t\tmx\u003dmax(mx,max(a[l],a[r]));\n\t\tif(i\u003d\u003deven)\n\t\t{\n\t\t\tassert(r-l\u0026lt;\u003d2);\n\t\t\tif(r-l\u003d\u003d2)\n\t\t\t{\n\t\t\t\tmx\u003dmax(mx,a[l+1]);\n\t\t\t}\n\t\t}\n\t\tans[n-i]\u003dmx;\n\t}\n\tmx\u003d0;\n\tfor(int i\u003dodd;i\u0026gt;\u003d3;i-\u003d2)\n\t{\n\t\tint l \u003d i/2-1; int r\u003dn-2-i/2;\n\t\tassert(l\u0026lt;\u003dr);\n\t\tif(i\u003d\u003dodd) assert(r-l\u0026lt;\u003d1);\n\t\tmx\u003dmax(mx,max(b[l],b[r]));\n\t\tans[n-i]\u003dmx;\n\t}\n\tfor(int i\u003d0;i\u0026lt;n;i++)\n\t{\n\t\tcout\u0026lt;\u0026lt;ans[i];\n\t\tif(i\u0026lt;n-1) cout\u0026lt;\u0026lt;\u0027 \u0027;\n\t}\n\tcout\u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eLeha and security system\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eAuthor : \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/hloya_ygrt\" title\u003d\"Мастер hloya_ygrt\"\u003ehloya_ygrt\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe use a segment tree to solve this problem. For each node, it is sufficient to store two arrays : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e, denoting the total contribution of the digit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e in the current segment (if a digit is in the tens digit then it contributes \u003cspan class\u003d\"tex-span\"\u003e10\u003c/span\u003e to the sum and etc...), and also \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enxt\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e, what all the digits \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e in the current segment are changed to.\u003c/p\u003e\u003cp\u003eMaintaining these arrays is quite straightforward with lazy propogation. When we push an update down a node, we need to update the nxt array of the children. First, we change \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003est\u003c/i\u003e[\u003ci\u003eid\u003c/i\u003e].\u003ci\u003enxt\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e]\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, where the current update is to change all digits \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. Then, we change \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003est\u003c/i\u003e[\u003ci\u003eid\u003c/i\u003e * 2].\u003ci\u003enxt\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003est\u003c/i\u003e[\u003ci\u003eid\u003c/i\u003e].\u003ci\u003enxt\u003c/i\u003e[\u003ci\u003est\u003c/i\u003e[\u003ci\u003eid\u003c/i\u003e * 2].\u003ci\u003enxt\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]]\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003est\u003c/i\u003e[\u003ci\u003eid\u003c/i\u003e]\u003c/span\u003e is the current node and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003est\u003c/i\u003e[\u003ci\u003eid\u003c/i\u003e * 2]\u003c/span\u003e is one of the children nodes. (Do the same for the right children). You can see the code if you need more details. Finally, update the sum array of the current segment.\u003c/p\u003e\u003cp\u003eThe total complexity of the code is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/da/16/da16e3b2104b5a5fadea42844324199c035a035d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, which is fast enough.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\nconst int N \u003d 100000;\nint a[N+1][10];\n\nstruct node\n{\n\tint nxt[10];\n\tll sum[10];\n};\n\nnode st[N*4+1];\n\nvoid combine(int id)\n{\n\tfor(int i \u003d 0; i \u0026lt; 10; i++)\n\t{\n\t\tst[id].sum[i]\u003dst[id*2].sum[i]+st[id*2+1].sum[i];\n\t}\n}\n\nvoid build(int id, int l, int r)\n{\n\tif(r-l\u0026lt;2)\n\t{\n\t\tfor(int i \u003d 0; i \u0026lt; 10; i++) st[id].sum[i]\u003da[l][i];\n\t\tfor(int i \u003d 0; i \u0026lt; 10; i++)\n\t\t{\n\t\t\tst[id].nxt[i] \u003d i;\n\t\t}\n\t\treturn ;\n\t}\n\tfor(int i \u003d 0; i \u0026lt; 10; i++)\n\t{\n\t\tst[id].nxt[i] \u003d i;\n\t}\n\tint mid\u003d(l+r)\u0026gt;\u0026gt;1;\n\tbuild(id*2,l,mid);\n\tbuild(id*2+1,mid,r);\n\tcombine(id);\n}\n\nint nxt1[10];\nint nxt2[10];\nll sum[10];\n\nvoid push(int id, int l, int r)\n{\n\tmemset(sum,0,sizeof(sum));\n\tif(r-l\u0026gt;\u003d2)\n\t{\n\t\tfor(int i \u003d 0; i \u0026lt; 10; i++)\n\t\t{\n\t\t\tnxt1[i] \u003d st[id].nxt[st[id*2].nxt[i]];\n\t\t\tnxt2[i] \u003d st[id].nxt[st[id*2+1].nxt[i]];\n\t\t}\n\t\tfor(int i\u003d0;i\u0026lt;10;i++)\n\t\t{\n\t\t\tst[id*2].nxt[i]\u003dnxt1[i];\n\t\t\tst[id*2+1].nxt[i]\u003dnxt2[i];\n\t\t}\n\t}\n\tfor(int i\u003d0;i\u0026lt;10;i++)\n\t{\n\t\tsum[st[id].nxt[i]]+\u003dst[id].sum[i];\n\t}\n\tfor(int i\u003d0;i\u0026lt;10;i++) \n\t{\n\t\tst[id].sum[i]\u003dsum[i];\n\t\tst[id].nxt[i]\u003di;\n\t}\n}\n\nvoid update(int id, int l, int r, int ql, int qr, int u, int v)\n{\n\tpush(id,l,r);\n\tif(ql\u0026gt;\u003dr||l\u0026gt;\u003dqr) return ;\n\tif(ql\u0026lt;\u003dl\u0026amp;\u0026amp;r\u0026lt;\u003dqr)\n\t{\n\t\tst[id].nxt[u]\u003dv;\n\t\tpush(id,l,r);\n\t\treturn ;\n\t}\n\tint mid\u003d(l+r)\u0026gt;\u0026gt;1;\n\tupdate(id*2,l,mid,ql,qr,u,v);\n\tupdate(id*2+1,mid,r,ql,qr,u,v);\n\tcombine(id);\n}\n\nll query(int id, int l, int r, int ql, int qr)\n{\n\tpush(id,l,r);\n\tif(ql\u0026gt;\u003dr||l\u0026gt;\u003dqr) return 0;\n\tif(ql\u0026lt;\u003dl\u0026amp;\u0026amp;r\u0026lt;\u003dqr)\n\t{\n\t\tll sum\u003d0;\n\t\tfor(int i\u003d1;i\u0026lt;10;i++)\n\t\t{\n\t\t\tsum+\u003dll(i)*st[id].sum[i];\n\t\t}\n\t\treturn sum;\n\t}\n\tint mid\u003d(l+r)\u0026gt;\u0026gt;1;\n\treturn (query(id*2,l,mid,ql,qr)+query(id*2+1,mid,r,ql,qr));\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q;\n\tfor(int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tint x; cin\u0026gt;\u0026gt;x;\n\t\tint cur\u003d1;\n\t\tfor(int j \u003d 0; j \u0026lt; 9; j++)\n\t\t{\n\t\t\ta[i][x%10] +\u003d cur;\n\t\t\tx/\u003d10;\n\t\t\tcur*\u003d10;\n\t\t\tif(x\u003d\u003d0) break;\n\t\t}\n\t}\n\tbuild(1,0,n);\n\tfor(int i \u003d 0; i \u0026lt; q; i++)\n\t{\n\t\tint type;\n\t\tcin\u0026gt;\u0026gt;type;\n\t\tif(type\u003d\u003d1)\n\t\t{\n\t\t\tint l,r,u,v;\n\t\t\tcin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v;\n\t\t\tl--; r--;\n\t\t\tupdate(1,0,n,l,r+1,u,v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r;\n\t\t\tl--; r--;\n\t\t\tll sum \u003d query(1,0,n,l,r+1);\n\t\t\tcout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eReplace All\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eAuthor : \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/zscoder\" title\u003d\"Гроссмейстер zscoder\"\u003ezscoder\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst, we solve the problem when there\u0027re no question marks, i.e. we find a way to calculate the number of good pairs of strings fast for a constant pair of strings \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eCall a pair of strings \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eS\u003c/i\u003e, \u003ci\u003eT\u003c/i\u003e)\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eS\u003c/i\u003e| ≤ |\u003ci\u003eT\u003c/i\u003e|\u003c/span\u003e coprime if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u003d \u003ci\u003eT\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e is a prefix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e, and if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e \u003d \u003ci\u003eS\u003c/i\u003e + \u003ci\u003eX\u003c/i\u003e\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eX\u003c/i\u003e, \u003ci\u003eS\u003c/i\u003e)\u003c/span\u003e is also coprime. \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eS\u003c/i\u003e, \u003ci\u003eT\u003c/i\u003e)\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eS\u003c/i\u003e| \u0026gt; |\u003ci\u003eT\u003c/i\u003e|\u003c/span\u003e is coprime iff \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eT\u003c/i\u003e, \u003ci\u003eS\u003c/i\u003e)\u003c/span\u003e is coprime.\u003c/p\u003e\u003cp\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e \u003d \u003ci\u003eB\u003c/i\u003e\u003c/span\u003e, then all possible strings work. Thus, we assume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e ≠ \u003ci\u003eB\u003c/i\u003e\u003c/span\u003e from now on. We remove the longest common prefix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e. Thus, we can assume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[0] ≠ \u003ci\u003eB\u003c/i\u003e[0]\u003c/span\u003e. Thus, either \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e is a prefix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e is a prefix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e. WLOG, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e is a prefix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e \u003d \u003ci\u003eS\u003c/i\u003e + \u003ci\u003eX\u003c/i\u003e\u003c/span\u003e. Now, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e consists of only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e. Using this, we can prove by induction on \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eS\u003c/i\u003e| + |\u003ci\u003eT\u003c/i\u003e|\u003c/span\u003e that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e must be coprime.\u003c/p\u003e\u003cp\u003eOne important property of coprime strings is that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e + \u003ci\u003eT\u003c/i\u003e \u003d \u003ci\u003eT\u003c/i\u003e + \u003ci\u003eS\u003c/i\u003e\u003c/span\u003e holds. (again induction works here)\u003c/p\u003e\u003cp\u003eNow, since the strings \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e needs to be coprime, we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e + \u003ci\u003eT\u003c/i\u003e \u003d \u003ci\u003eT\u003c/i\u003e + \u003ci\u003eS\u003c/i\u003e\u003c/span\u003e. This allows us to swap any neighbouring Ss and Ts (or \u0027A\u0027s and \u0027B\u0027s) in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e, as the resulting strings will still be equal. Thus, swapping repeatedly allows us to sort the strings A and B. (the \u0027A\u0027s appear in front and \u0027B\u0027s appear at the back) Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e denote the number of As and Bs in the first string and second string respectively. If \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e) \u0026gt; (\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e, then the answer is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. We\u0027ll handle the case \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e) \u003d (\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e later. Now, assume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e \u0026gt; \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e \u0026lt; \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Thus, we have to solve the equation \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e copies of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e \u003d \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e copies of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow, let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e \u003d \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, then the solution is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u003d \u003ci\u003eT\u003c/i\u003e\u003c/span\u003e. Otherwise, assume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026gt; \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. Then, \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eS\u003c/i\u003e| \u0026lt; |\u003ci\u003eT\u003c/i\u003e|\u003c/span\u003e. So, by comparing, we again have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e \u003d \u003ci\u003eS\u003c/i\u003e + \u003ci\u003eX\u003c/i\u003e\u003c/span\u003e, for some nonempty binary string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e. Note that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e must be coprime too, so we can sort the second string as well. We cancel off the Ss on both sides to get \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e)\u003ci\u003eS\u003c/i\u003e \u003d \u003ci\u003eyX\u003c/i\u003e\u003c/span\u003e. Thus, this means that if \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eS\u003c/i\u003e, \u003ci\u003eT\u003c/i\u003e)\u003c/span\u003e is a solution for \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eS\u003c/i\u003e, \u003ci\u003eX\u003c/i\u003e)\u003c/span\u003e is a solution for \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e. Note that repeating this process will eventually lead us to \u003cspan class\u003d\"tex-span\"\u003e(1, 1)\u003c/span\u003e. (this process is similar to Euclidean Algorithm)\u003c/p\u003e\u003cp\u003eThe answer for \u003cspan class\u003d\"tex-span\"\u003e(1, 1)\u003c/span\u003e is the number of solutions to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u003d \u003ci\u003eT\u003c/i\u003e\u003c/span\u003e. Let\u0027s denote the solution here as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e. Doing some backtracking, we realize that the answer for \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e is equal to (X....X (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e times), X...X (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e times)). Note that we still have the condition \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eS\u003c/i\u003e|, |\u003ci\u003eT\u003c/i\u003e| ≤ \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, so we can translate this to an appropriate condition on the length of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e and the answer is simply the number of binary strings of length not exceeding the maximum possible length of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eThe only case that remains is that \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e) \u003d (\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e. In this case, any pair of coprime strings \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e will work. Thus, our task reduces to calculating the number of coprime pair of strings with length not exceeding \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eWe claim that the number of coprime pair of strings \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eS\u003c/i\u003e, \u003ci\u003eT\u003c/i\u003e)\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eS\u003c/i\u003e| \u003d \u003ci\u003ep\u003c/i\u003e, |\u003ci\u003eT\u003c/i\u003e| \u003d \u003ci\u003eq\u003c/i\u003e\u003c/span\u003e is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/b6/32b612539af049da0a891c783713d0706844b95a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e \u003d \u003ci\u003eq\u003c/i\u003e\u003c/span\u003e the claim is obviously true. Otherwise, we can induct on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e + \u003ci\u003eq\u003c/i\u003e\u003c/span\u003e agin. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e \u0026gt; \u003ci\u003ep\u003c/i\u003e\u003c/span\u003e, we can write \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e \u003d \u003ci\u003eS\u003c/i\u003e + \u003ci\u003eX\u003c/i\u003e\u003c/span\u003e and then the number of coprime pairs of \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eS\u003c/i\u003e, \u003ci\u003eT\u003c/i\u003e)\u003c/span\u003e is equal to the number of coprime pairs of \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eS\u003c/i\u003e, \u003ci\u003eX\u003c/i\u003e)\u003c/span\u003e, which by induction is equal to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8b/3e/8b3ed234dead9ef07def8cf11de9d27a677c7101.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. This proves the claim.\u003c/p\u003e\u003cp\u003eThus, we just need to compute the sum of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/b6/32b612539af049da0a891c783713d0706844b95a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for all \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ep\u003c/i\u003e, \u003ci\u003eq\u003c/i\u003e ≤ \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIndeed, since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e ≤ 3·10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e, it is enough to count the number of pairs \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ep\u003c/i\u003e, \u003ci\u003eq\u003c/i\u003e)\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egcd\u003c/i\u003e \u003d \u003ci\u003eg\u003c/i\u003e\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eHowever, this is quite easy. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecnt\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e denote the number of pairs \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ep\u003c/i\u003e, \u003ci\u003eq\u003c/i\u003e)\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e are both divisible by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e denote the number of pairs \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ep\u003c/i\u003e, \u003ci\u003eq\u003c/i\u003e)\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egcd\u003c/i\u003e \u003d \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Then, \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1d/cc/1dcc3da73320dc0fa683a97767a4c1910bc49081.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Thus, this can be computed in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5d/1f/5d1f29f648247e77966a5b1703590aea2a6a75b6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eNow, we need to find out how to calculate the sum of all these values on two strings \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e with question marks. Handle the case when the two strings become equal separately.\u003c/p\u003e\u003cp\u003eLet\u0027s first make a summary of the number of good pairs of strings for constant strings \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e. In fact, note that the formulaes above only depends on \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e, the difference between the number of As in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e, and the difference between the number of Bs in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e (note that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e can be negative)\u003c/p\u003e\u003cp\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e \u003d 0\u003c/span\u003e, then the answer is the sum of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/b6/32b612539af049da0a891c783713d0706844b95a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for all \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ep\u003c/i\u003e, \u003ci\u003eq\u003c/i\u003e ≤ \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, which as we have just saw can be precomputed in time. \u003c/p\u003e\u003cp\u003eOtherwise, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e ≥ 0\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e ≤ 0\u003c/span\u003e, then there are no good pair of strings.\u003c/p\u003e\u003cp\u003eFinally, in other cases, let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e \u003d |\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e|, \u003ci\u003eq\u003c/i\u003e \u003d |\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e|\u003c/span\u003e. Then, the answer is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/64/37/6437fac81d441ccbccd50fb49a8146ea64a9e610.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eThis also means that we can compute the answer if we know \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e very fast. (worst case is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/66/6c/666cc239bd9595b8818555e063d8d8b69ad0cda0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e)\u003c/p\u003e\u003cp\u003eNow, suppose in the strings \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e, we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e question marks respectively. Additionally, suppose the current difference between the number of As and Bs of these strings is \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ep\u003c/i\u003e, \u003ci\u003eq\u003c/i\u003e)\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eIf we choose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e of the question marks from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e to be replaced with As, then the difference between As and Bs in the strings become \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ep\u003c/i\u003e + \u003ci\u003ex\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e, \u003ci\u003eq\u003c/i\u003e + (\u003ci\u003ea\u003c/i\u003e - \u003ci\u003eb\u003c/i\u003e) - (\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e))\u003c/span\u003e. Let\u0027s denote \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e + \u003ci\u003ea\u003c/i\u003e - \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e for simplicity. Thus, the difference is now written as \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ep\u003c/i\u003e + (\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e), \u003ci\u003eq\u003c/i\u003e - (\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e))\u003c/span\u003e. The values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e can be any integer in the range \u003cspan class\u003d\"tex-span\"\u003e[0, \u003ci\u003ea\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e[0, \u003ci\u003eb\u003c/i\u003e]\u003c/span\u003e respectively. Suppose for all \u003cspan class\u003d\"tex-span\"\u003e - \u003ci\u003eb\u003c/i\u003e ≤ \u003ci\u003ed\u003c/i\u003e ≤ \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, we know how many ways to assign the question marks have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e \u003d \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e. Then, we can iterate through all the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003es one by one and compute the answer fast for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThus, the final hurdle is to calculate the number of ways to obtain \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e \u003d \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e for all possible \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e so that \u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003ex\u003c/i\u003e ≤ \u003ci\u003ea\u003c/i\u003e, 0 ≤ \u003ci\u003ey\u003c/i\u003e ≤ \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. This is just the sum of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1d/52/1d52f69d68606585c638d1ed4b8b5ea5041bbf6d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e for all \u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003ex\u003c/i\u003e ≤ \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e. However, this is equal to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d8/eb/d8ebe016c17de0bd2329e8c501d1625a5b869082.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, as the number of ways to choose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e + \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e objects from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e objects is the same as the sum of the product of the number of ways to choose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e objects from the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e objects and the number of ways to choose \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e + \u003ci\u003ed\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e objects from the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e objects for all \u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003ea\u003c/i\u003e ≤ \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Thus, this value can be computed in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e with precomputed factorials and inverse factorials (or you can maintain this value when we iterate through all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eFinally, don\u0027t forget to take care of the cases where it is possible for both strings to be equal.\u003c/p\u003e\u003cp\u003eThe time complexity of the solution is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/22/c2/22c27cd7d2223c8f7703d7832bb699fd19ff852f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;\n#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair\u0026lt;ll,ll\u0026gt; ii;\ntypedef vector\u0026lt;ll\u0026gt; vi;\ntypedef long double ld; \ntypedef tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; pbds;\ntypedef set\u0026lt;int\u0026gt;::iterator sit;\ntypedef map\u0026lt;int,int\u0026gt;::iterator mit;\ntypedef vector\u0026lt;int\u0026gt;::iterator vit;\n\nconst int MOD \u003d 1e9 + 7;\n\nstruct NumberTheory\n{\n\tvector\u0026lt;ll\u0026gt; primes;\n\tvector\u0026lt;bool\u0026gt; prime;\n\tvector\u0026lt;ll\u0026gt; totient;\n\tvector\u0026lt;ll\u0026gt; sumdiv;\n\tvector\u0026lt;ll\u0026gt; bigdiv;\n\tvoid Sieve(ll n)\n\t{\n\t\tprime.assign(n+1, 1);\n\t\tprime[1] \u003d false;\n\t\tfor(ll i \u003d 2; i \u0026lt;\u003d n; i++)\n\t\t{\n\t\t\tif(prime[i])\n\t\t\t{\n\t\t\t\tprimes.pb(i);\n\t\t\t\tfor(ll j \u003d i*2; j \u0026lt;\u003d n; j +\u003d i)\n\t\t\t\t{\n\t\t\t\t\tprime[j] \u003d false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll phi(ll x)\n\t{\n\t\tmap\u0026lt;ll,ll\u0026gt; pf;\n\t\tll num \u003d 1; ll num2 \u003d x;\n\t\tfor(ll i \u003d 0; primes[i]*primes[i] \u0026lt;\u003d x; i++)\n\t\t{\n\t\t\tif(x%primes[i]\u003d\u003d0)\n\t\t\t{\n\t\t\t\tnum2/\u003dprimes[i];\n\t\t\t\tnum*\u003d(primes[i]-1);\n\t\t\t}\n\t\t\twhile(x%primes[i]\u003d\u003d0)\n\t\t\t{\n\t\t\t\tx/\u003dprimes[i];\n\t\t\t\tpf[primes[i]]++;\n\t\t\t}\n\t\t}\n\t\tif(x\u0026gt;1)\n\t\t{\n\t\t\tpf[x]++; num2/\u003dx; num*\u003d(x-1);\n\t\t}\n\t\tx \u003d 1;\n\t\tnum*\u003dnum2;\n\t\treturn num;\n\t}\n\t\n\tbool isprime(ll x)\n\t{\n\t\tif(x\u003d\u003d1) return false;\n\t\tfor(ll i \u003d 0; primes[i]*primes[i] \u0026lt;\u003d x; i++)\n\t\t{\n\t\t\tif(x%primes[i]\u003d\u003d0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid SievePhi(ll n)\n\t{\n\t\ttotient.resize(n+1);\n\t\tfor (int i \u003d 1; i \u0026lt;\u003d n; ++i) totient[i] \u003d i;\n\t\tfor (int i \u003d 2; i \u0026lt;\u003d n; ++i)\n\t\t{\n\t\t\tif (totient[i] \u003d\u003d i)\n\t\t\t{\n\t\t\t\tfor (int j \u003d i; j \u0026lt;\u003d n; j +\u003d i)\n\t\t\t\t{\n\t\t\t\t\ttotient[j] -\u003d totient[j] / i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid SieveSumDiv(ll n)\n\t{\n\t\tsumdiv.resize(n+1);\n\t\tfor(int i \u003d 1; i \u0026lt;\u003d n; ++i)\n\t\t{\n\t\t\tfor(int j \u003d i; j \u0026lt;\u003d n; j +\u003d i)\n\t\t\t{\n\t\t\t\tsumdiv[j] +\u003d i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll getPhi(ll n)\n\t{\n\t\treturn totient[n];\n\t}\n\t\n\tll getSumDiv(ll n)\n\t{\n\t\treturn sumdiv[n];\n\t}\n\t\n\tll modpow(ll a, ll b, ll mod)\n\t{\n\t\tll r \u003d 1;\n\t\tif(b \u0026lt; 0) b +\u003d mod*100000LL;\n\t\twhile(b)\n\t\t{\n\t\t\tif(b\u0026amp;1) r \u003d (r*a)%mod;\n\t\t\ta \u003d (a*a)%mod;\n\t\t\tb\u0026gt;\u0026gt;\u003d1;\n\t\t}\n\t\treturn r;\n\t}\n\t\n\tll inv(ll a, ll mod)\n\t{\n\t\treturn modpow(a, mod - 2, mod);\n\t}\n\t\n\tll invgeneral(ll a, ll mod)\n\t{\n\t\tll ph \u003d phi(mod);\n\t\tph--;\n\t\treturn modpow(a, ph, mod);\n\t}\n\t\n\tvoid getpf(vector\u0026lt;ii\u0026gt;\u0026amp; pf, ll n)\n\t{\n\t\tfor(ll i \u003d 0; primes[i]*primes[i] \u0026lt;\u003d n; i++)\n\t\t{\n\t\t\tint cnt \u003d 0;\n\t\t\twhile(n%primes[i]\u003d\u003d0)\n\t\t\t{\n\t\t\t\tn/\u003dprimes[i]; cnt++;\n\t\t\t}\n\t\t\tif(cnt\u0026gt;0) pf.pb(ii(primes[i], cnt));\n\t\t}\n\t\tif(n\u0026gt;1)\n\t\t{\n\t\t\tpf.pb(ii(n, 1));\n\t\t}\n\t}\n\n\t//ll op;\n\tvoid getDiv(vector\u0026lt;ll\u0026gt;\u0026amp; div, vector\u0026lt;ii\u0026gt;\u0026amp; pf, ll n, int i)\n\t{\n\t\t//op++;\n\t\tll x, k;\n\t\tif(i \u0026gt;\u003d pf.size()) return ;\n\t\tx \u003d n;\n\t\tfor(k \u003d 0; k \u0026lt;\u003d pf[i].se; k++)\n\t\t{\n\t\t\tif(i\u003d\u003dint(pf.size())-1) div.pb(x);\n\t\t\tgetDiv(div, pf, x, i + 1);\n\t\t\tx *\u003d pf[i].fi;\n\t\t}\n\t}\n};\n\nNumberTheory nt;\n\nll modpow(ll a, ll b)\n{\n\tll r \u003d 1;\n\twhile(b)\n\t{\n\t\tif(b\u0026amp;1) r\u003d(r*a)%MOD;\n\t\ta\u003d(a*a)%MOD;\n\t\tb\u0026gt;\u0026gt;\u003d1;\n\t}\n\treturn r;\n}\n\nll inv(ll a)\n{\n\treturn modpow(a,MOD-2);\n}\n\nll n;\nll cnt[300001];\nll mob[300001];\n\nll mobius(ll x)\n{\n\tint cc \u003d 0;\n\tfor(int i\u003d0;nt.primes[i]*nt.primes[i]\u0026lt;\u003dx;i++)\n\t{\n\t\tint z\u003d0;\n\t\twhile(x%nt.primes[i]\u003d\u003d0)\n\t\t{\n\t\t\tz++;\n\t\t\tx/\u003dnt.primes[i];\n\t\t}\n\t\tif(z\u0026gt;\u003d2) return 0;\n\t\tif(z\u0026gt;0) cc++;\n\t}\n\tif(x\u0026gt;1) cc++;\n\tif(cc\u0026amp;1) return -1;\n\telse return 1;\n}\n\nll solve(ll x, ll y)\n{\n\tif(x\u003d\u003d0\u0026amp;\u0026amp;y\u003d\u003d0)\n\t{\n\t\tfor(int i\u003d1;i\u0026lt;\u003dn;i++)\n\t\t{\n\t\t\tcnt[i]\u003dll(n/i)*ll(n/i);\n\t\t}\n\t\tfor(int i\u003d1;i\u0026lt;\u003dn;i++)\n\t\t{\n\t\t\tfor(int j\u003d2*i;j\u0026lt;\u003dn;j+\u003di)\n\t\t\t{\n\t\t\t\tcnt[i]+\u003dmob[j/i]*cnt[j];\n\t\t\t}\n\t\t}\t\n\t\tll ans \u003d 0;\n\t\tll cur \u003d 2;\n\t\tfor(int i\u003d1;i\u0026lt;\u003dn;i++)\n\t\t{\n\t\t\tcnt[i]%\u003dMOD;\n\t\t\tif(cnt[i]\u0026lt;0) cnt[i]+\u003dMOD;\n\t\t\t//cerr\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0027 \u0027\u0026lt;\u0026lt;cnt[i]\u0026lt;\u0026lt;\u0027\\n\u0027;\n\t\t\tans\u003d(ans+(cur*cnt[i])%MOD)%MOD;\n\t\t\tif(ans\u0026lt;0) ans+\u003dMOD;\n\t\t\tcur\u003d(cur*2)%MOD;\n\t\t\tif(cur\u0026lt;0) cur+\u003dMOD;\n\t\t}\n\t\treturn ans;\n\t}\n\telse if(x\u0026gt;\u003d0\u0026amp;\u0026amp;y\u0026gt;\u003d0)\n\t{\n\t\treturn 0;\n\t}\n\telse if(x\u0026lt;\u003d0\u0026amp;\u0026amp;y\u0026lt;\u003d0)\n\t{\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tx\u003dabs(x); y\u003dabs(y);\n\t\tll g \u003d __gcd(x,y);\n\t\tx/\u003dg; y/\u003dg;\n\t\tll k \u003d n/max(x,y);\n\t\tll ans \u003d modpow(2,k+1)+MOD-2;\n\t\twhile(ans\u0026gt;\u003dMOD) ans-\u003dMOD;\n\t\treturn ans;\n\t}\n}\n\nll fact[600001];\nll ifact[600001];\nll inverse[600001];\n\nll choose(ll n, ll r)\n{\n\tif(r\u003d\u003d0) return 1;\n\tll ans \u003d fact[n];\n\tans\u003d(ans*ifact[r])%MOD;\n\tans\u003d(ans*ifact[n-r])%MOD;\n\tif(ans\u0026lt;0) ans+\u003dMOD;\n\treturn ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tstring s, t;\n\tcin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t;\n\tcin\u0026gt;\u0026gt;n;\n\tfact[0]\u003d1; ifact[0]\u003d1;\n\tfor(int i\u003d1;i\u0026lt;\u003d600000;i++)\n\t{\n\t\tfact[i]\u003d(fact[i-1]*i)%MOD;\n\t\tif(fact[i]\u0026lt;0) fact[i]+\u003dMOD;\n\t\tifact[i]\u003dinv(fact[i]);\n\t\tinverse[i]\u003dinv(i);\n\t}\n\tnt.Sieve(300001);\n\tfor(int i\u003d2;i\u0026lt;\u003dn;i++)\n\t{\n\t\tmob[i]\u003dmobius(i);\n\t}\n\tll sa, sb, sc; //sa \u003d # of As in s, sb \u003d # of Bs in s, sc \u003d # of ?s in s\n\tll ta, tb, tc;\n\tsa\u003dsb\u003dsc\u003dta\u003dtb\u003dtc\u003d0;\n\tll same \u003d 1; //number of ways to fill in ?s such that |S| \u003d |T|\n\tif(s.length()!\u003dt.length()) same\u003d0;\n\telse\n\t{\n\t\tfor(int i\u003d0;i\u0026lt;s.length();i++)\n\t\t{\n\t\t\tif(s[i]\u003d\u003d\u0027?\u0027\u0026amp;\u0026amp;t[i]\u003d\u003d\u0027?\u0027) same\u003d(same*2)%MOD;\n\t\t\telse if(s[i]\u003d\u003d\u0027?\u0027||t[i]\u003d\u003d\u0027?\u0027)\n\t\t\t{\n\t\t\t\t\n\t\t\t}\n\t\t\telse if(s[i]\u003d\u003dt[i])\n\t\t\t{\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsame\u003d0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i\u003d0;i\u0026lt;s.length();i++)\n\t{\n\t\tif(s[i]\u003d\u003d\u0027A\u0027) sa++;\n\t\telse if(s[i]\u003d\u003d\u0027B\u0027) sb++;\n\t\telse sc++;\n\t}\n\tfor(int i\u003d0;i\u0026lt;t.length();i++)\n\t{\n\t\tif(t[i]\u003d\u003d\u0027A\u0027) ta++;\n\t\telse if(t[i]\u003d\u003d\u0027B\u0027) tb++;\n\t\telse tc++;\n\t}\n\tll ans \u003d 0;\n\tll c \u003d 1;\n\tint cntt\u003d0;\n\tfor(ll i \u003d sa - ta - tc; i \u0026lt;\u003d sa - ta + sc; i++)\n\t{\n\t\tif(i\u003d\u003d0)\n\t\t{\n\t\t\tll cc \u003d (c-same)%MOD;\n\t\t\tif(cc\u0026lt;0) cc+\u003dMOD;\n\t\t\tans\u003d(ans+(cc*solve(i,sa+sb+sc-ta-tb-tc-i))%MOD)%MOD;\n\t\t\tll tmp \u003d modpow(2,n+1)+MOD-2;\n\t\t\twhile(tmp\u0026gt;\u003dMOD) tmp-\u003dMOD;\n\t\t\ttmp\u003d(tmp*tmp)%MOD;\n\t\t\tans\u003d(ans+(same*tmp)%MOD)%MOD;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans\u003d(ans+(c*solve(i,sa+sb+sc-ta-tb-tc-i))%MOD)%MOD;\n\t\t}\n\t\tif(ans\u0026lt;0) ans+\u003dMOD;\n\t\tc\u003d(c*inverse[cntt+1])%MOD;\n\t\tc\u003d(c*(sc+tc-cntt))%MOD;\n\t\tif(c\u0026lt;0) c+\u003dMOD;\n\t\tcntt++;\n\t}\n\tcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["tinkoff","editorial"]}}