{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1526865221,"rating":135,"authorHandle":"alkurmtl","modificationTimeSeconds":1526867016,"id":59599,"title":"\u003cp\u003eNew powerful optimization technique\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eIn this blog I will tell you about recently invented powerful optimization technique, which can be applied to almost any problem and lets you solve it easily. Further I assume that you\u0027re already familiar with finding maximum flow in networks. If not, there\u0027re many tutorials avaible on Internet. For example, you can read \u003ca href\u003d\"https://www.topcoder.com/community/data-science/data-science-tutorials/maximum-flow-section-1/\"\u003ethis\u003c/a\u003e fabulous article on Topcoder.\u003c/p\u003e\u003cp\u003eIt\u0027s based on \u003ca href\u003d\"http://www.cs.princeton.edu/courses/archive/fall06/cos528/handouts/Goldberg-Rao.pdf\"\u003eGoldberg-Rao algorithm\u003c/a\u003e for finding maximum flow. Its time complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5e/67/5e67abc247a9717058b3dd1991c982a678e8da07.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eU\u003c/i\u003e\u003c/span\u003e is maximum capacity in network.\u003c/p\u003e\u003cp\u003eConsider any network with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e edges and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e vertices. Any reasonable programmer would merge parallel edges to one edge, summing their capacities, because it obviously reduces running time of algorithm. However, to reduce running time even more, \u003cstrong\u003ewe will not delete parallel edges\u003c/strong\u003e. Even more, \u003cstrong\u003ewe will add more of them\u003c/strong\u003e! Let\u0027s add parallel edges from sink to source. Obviously, added edges don\u0027t affect max flow. But how many edges we need to add? Just enough for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e to become more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e, and the more the better! Now let\u0027s look back at time complexity of Goldberg-Rao algorithm. It involves \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b1/a4/b1a481df17d5f03bbccc40aba2e68abe20e33c39.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e factor, and since we ensured that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e \u0026gt; \u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e, using basic school maths we can prove that this factor is negative. And because all other factors are positive, overall time complexity is negative, which means \u003cstrong\u003efinding max flow in our network runs in negative time\u003c/strong\u003e!\u003c/p\u003e\u003cp\u003eLet\u0027s introduce a subroutine called \u003cem\u003etimelapse\u003c/em\u003e, which will every time we call it find max flow in arbitrary network satisfying condition \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e \u0026gt; \u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e using Goldber-Rao algorithm. Since its time complexity is negative, we can win some time once we need it just by calling it!\u003c/p\u003e\u003cp\u003eNow there\u0027re some applications of this optimization.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e1. Squeezing submissions in time limit.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThis one is pretty straight forward. Once running time of your submission is quite close to time limit, you just call \u003cem\u003etimelapse\u003c/em\u003e, which gives you some time to finish execution and print calculated answer.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2. Early submit tactic\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThis one is a bit more tricky. Let\u0027s notice that nothing restricts us from having negative running time of the whole submission. So, let\u0027s call \u003cem\u003etimelapse\u003c/em\u003e a lot of times at the beginning of your code. If you rewind time to the start of the contest, your submission will be accepted at 00:00, which means you can submit all problems you can solve at the first minute of contest and \u003cstrong\u003eget zero time penalty\u003c/strong\u003e! Just imagine how unbeateable you will be. However, you have to be careful to not to rewind time too much back. Otherwise your submission will get stuck at 80\u0027s when computers were so slow that other part of your code would run for a few years.\u003c/p\u003e\u003cp\u003eThank you for reading my tutorial. Feel free to discuss this technique in comments and share your ideas and applications of it!\u003c/p\u003e\u003c/div\u003e","tags":["max flow","optimization","weaver"]}}