{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1460065108,"rating":0,"authorHandle":"dorellin","modificationTimeSeconds":1460069542,"id":44243,"title":"\u003cp\u003eSoluções Aula 5\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eEsse post vai ser breve porque estou sem tempo. \u003c/p\u003e\u003cp\u003ePra quem tentou fazer os problemas da Aula 5, aqui vão as soluções (marcamos para discutir as soluções algum outro dia):\u003c/p\u003e\u003ch2\u003eJörmundgander\u003c/h2\u003e\u003cp\u003eA solução era uma DFS à partir da posição inicial — 0,0.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nconst int N \u003d 1001;\nstring in[N];\n\nbool vis[N][N];\n\nint dir[4][2] \u003d { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\nint n;\n\nvoid dfs (int x, int y) {\n    if (vis[x][y]) return;\n    vis[x][y] \u003d true;\n    for (int d \u003d 0; d \u0026lt; 4; ++d) {\n        int nx \u003d x + dir[d][0];\n        int ny \u003d y + dir[d][1];\n        if (nx \u0026lt; 0 or ny \u0026lt; 0 or nx \u0026gt;\u003d n or ny \u0026gt;\u003d n) continue;\n        if (in[nx][ny] \u003d\u003d \u0027x\u0027) continue;\n        dfs (nx, ny);\n    }\n}\n\nint main (void) {\n    cin \u0026gt;\u0026gt; n;\n    for (int i \u003d 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; in[i];\n    if (in[0][0] !\u003d \u0027x\u0027) dfs (0, 0);\n    if (vis[n-1][n-1]) cout \u0026lt;\u0026lt; \u0026quot;Odin\u0026quot;;\n    else cout \u0026lt;\u0026lt; \u0026quot;Ragnarok\u0026quot; \u0026lt;\u0026lt; endl;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eYggdrasil\u003c/h2\u003e\u003cp\u003eAlgumas pessoas conseguiram AC com um código errado. Aqui vai a solução correta — também uma DFS. Infelizmente os casos de teste estavam fracos. ):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nconst int N \u003d 100000;\nvector \u0026lt;int\u0026gt; g[N];\n\nbool good \u003d true;\n\nint solve (int x, int p) {\n\tif (g[x].size() \u003d\u003d 2) {\n\t\tif (x) return 1;\n\t\telse return -1;\n\t}\t\n\tint bal \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; g[x].size(); ++i) {\n\t\tint v \u003d g[x][i];\n\t\tif (v !\u003d p) bal +\u003d solve (v, x);\n\t}\t\n\tif (abs(bal) \u0026gt; 2) good \u003d false;\n\treturn bal;\n}\n\nint main (void) {\n\tint n;\n\tcin \u0026gt;\u0026gt; n;\n\tfor (int i \u003d 0; i \u0026lt; n-1; ++i) {\n\t\tint a, b;\n\t\tcin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\t\n\tsolve(0, -1);\n\tif (good) cout \u0026lt;\u0026lt; \u0026quot;N\\n\u0026quot;;\n\telse cout \u0026lt;\u0026lt; \u0026quot;S\\n\u0026quot;;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eVallhala\u003c/h2\u003e\u003cp\u003eNovamente, bastava fazer uma DFS. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nconst int G \u003d 10000;\nconst int V \u003d 1000;\nvector\u0026lt;int\u0026gt; g[G+V];\nint vis[G + V];\nint peso[G];\nint v, n, r;\n\nvoid dfs (int x) {\n\tvis[x] \u003d 1;\n\tif (x \u0026gt;\u003d v) {\n\t\tr +\u003d peso[x-v];\n\t}\n\tfor (int i \u003d 0; i \u0026lt; g[x].size(); ++i) \n\t\tif (!vis[g[x][i]]) dfs(g[x][i]);\n}\n\nint main (void) {\n\tcin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; n;\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) {\n\t\tint b, e; cin \u0026gt;\u0026gt; e;\n\t\tfor (int j \u003d 0; j \u0026lt; e; ++j) {\n\t\t\tcin \u0026gt;\u0026gt; b; \n\t\t\tg[b].push_back(v + i);\n\t\t}\n\t}\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; peso[i];\n\tfor (int i \u003d 0; i \u0026lt; v; ++i) {\n\t\tr \u003d 0;\n\t\tdfs(i);\n\t\tcout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl;\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eNifflhein\u003c/h2\u003e\u003cp\u003ePara resolver esse problema, bastava notar que se é possível chegar do início ao fim no tempo T, é possível chegar em todos os tempos menores que T. Isso nos permite utilizar uma busca binária — e, em cada tempo, usar somente os portões já abertos até esse tempo. Para ver se há caminho basta usar uma DFS.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nconst int N \u003d 1001;\nvector\u0026lt;int\u0026gt; g[N], o[N];\nint vis[N];\n\nint reach (int x, int T) {\n\tvis[x] \u003d 1;\t\n\tfor (int i \u003d 0; i \u0026lt; g[x].size(); ++i) {\n\t\tint y \u003d g[x][i];\n\t\tif (!vis[y] and o[x][i] \u0026lt;\u003d T) reach(y, T);\n\t}\n}\n\nint main (void) {\n\tint n, m;\n\tscanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m);\n\tfor (int i \u003d 0; i \u0026lt; m; ++i) {\n\t\tint a, b, t;\n\t\tscanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;a, \u0026amp;b, \u0026amp;t);\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t\to[a].push_back(t);\n\t\to[b].push_back(t);\n\t}\n\n\tint lo \u003d 0, hi \u003d 1e9;\n\twhile (lo \u0026lt; hi) {\n\t\tint mi \u003d (lo + hi)/2;\n\t\tmemset(vis, 0, sizeof vis);\n\t\treach (0, mi);\n\t\tif (vis[n-1]) hi \u003d mi;\n\t\telse lo \u003d mi + 1;\n\t}\n\tcout \u0026lt;\u0026lt; lo \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eÆgir\u003c/h2\u003e\u003cp\u003ePara resolver esse problema, bastava utilizar várias DFS. Cada DFS marcaria todas as posições de uma mesma ilha. Se passarmos pela matriz procurando as ilhas ainda não marcadas, basta contar quantas vezes isso ocorre. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n\nint dir[4][2] \u003d { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };\n\nusing namespace std;\n\nconst int N \u003d 1001;\nchar in[N][N];\nint vis[N][N];\nint n;\n\nbool inside (int i, int j) {\n\treturn i \u0026gt;\u003d 0 and j \u0026gt;\u003d 0 and i \u0026lt; n and j \u0026lt; n;\n}\n\nint dfs (int i, int j) {\n\tvis[i][j] \u003d 1;\n\tfor (int k \u003d 0; k \u0026lt; 4; ++k) {\n\t\tint ni \u003d i + dir[k][0];\n\t\tint nj \u003d j + dir[k][1];\n\t\tif (inside(ni, nj) and !vis[ni][nj] and in[ni][nj] \u003d\u003d \u0027.\u0027) {\n\t\t\tdfs(ni, nj);\n\t\t}\n\t}\n}\n\nint main (void) {\n\tcin \u0026gt;\u0026gt; n;\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; in[i];\n\tmemset (vis, 0, sizeof vis);\n\tint res \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) {\n\t\tfor (int j \u003d 0; j \u0026lt; n; ++j) {\n\t\t\tif (!vis[i][j] and in[i][j] \u003d\u003d \u0027.\u0027) {\n\t\t\t\tres++; \n\t\t\t\tdfs(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eÓðr e Freyja\u003c/h2\u003e\u003cp\u003eDesafio ;)\u003c/p\u003e\u003c/div\u003e","tags":[]}}