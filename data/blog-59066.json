{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1524434228,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1524439399,"id":59066,"title":"\u003cp\u003eПостроение графика функции средствами JavaFX\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003eЧасть 0. Коротко об архитектуре JavaFX\u003c/h4\u003e\u003cp\u003eВ течение длительного времени графический интерфейс в Java приложениях реализовывался средствами фреймворка Swing. Проект Swing перестал развиваться, и теперь основной фреймворк для создания графических интерфейсов — JavaFX (с версии 2.0; первые версии были не слишком удачны и подверглись очень существенной переделке; так что будьте внимательны при выборе литературы). У этого фреймворка есть, конечно, и некоторые «минусы» (с точки зрения начинающих разработчиков особенно), но, представляется, что «плюсов» в итоге всё-таки окажется больше. \u003c/p\u003e\u003cp\u003eЗаметим, что у Oracle существуют планы отказаться от обновлений JavaFX в составе JDK (и вообще отказаться от каких бы то ни было пакетов, ориентированных на десктопы). Однако, поскольку равноценной замены при этом не предлагается, JavaFX, по-видимому, будет использоваться (и, возможно, развиваться в составе OpenJDK или отдельного проекта). \u003cbr /\u003e До последних версий JDK на сайте Oracle был доступен JavaFX Scene Builder, который можно было использовать подобно Палитре компонентов Swing. Однако в настоящий момент это дополнение перенесено в архив, замены ему не предложено (по крайней мере, пока). Архитектура приложения JavaFX отличается от архитектуры приложения Swing. Приложения Swing опирались на контейнер JFrame; JavaFX-приложения расширяют класс Application (из пакета javafx.application). Точкой входа этого класса является метод start(). Единственным параметром этого метода является GUI-контейнер верхнего уровня — объект класса Stage. Код простейшего JavaFX приложения будет рассмотрен в следующих разделах. \u003c/p\u003e\u003cp\u003eВ контейнере Stage могут помещаться сцены (Scene), причём сцен может быть несколько, но одновременно отображаться будет только одна. Сцена содержит граф сцены (scene graph) — набор всех элементов, составляющих пользовательский интерфейс. Эти элементы (к ним относятся группы (group), менеджеры расположения (layout manager), управляющие элементы (control) и фигуры (shape)) являются узлами (node) этого графа. \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 1. Архитектура JavaFX приложения\" src\u003d\"/predownloaded/67/fe/67fef1d283080fb71c6cfce9bd5d47fbf12d3bff.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 1. Архитектура JavaFX приложения\u003c/p\u003e\u003cp\u003eВ графе сцены существует корневой (родительский) узел, другие узлы являются его дочерними узлами (циклов в этом графе нет). Некоторые из этих дочерних узлов, в свою очередь, могут быть родительскими узлами для каких-либо других узлов; некоторые — являются концевыми в своей цепочке (листьями). Следует понимать, что дочерние узлы являются таковыми по «принадлежности»: например, корневым узлом может быть некоторый менеджер расположения, который служит контейнером для каких-то управляющих элементов (кнопок, текстовых полей и т.п.). Конечно, это никоим образом не значит, что класс кнопки является наследником класса менеджера расположения. \u003c/p\u003e\u003cp\u003eИными словами, отношения parent / child и ancestor / descendant отображают разные связи. Родительский объект по отношению к дочернему объекту несёт ответственность за передачу сообщений о происходящих событиях. Класс-предок обеспечивает наличие некоторых общих полей и методов в своих наследниках.\u003c/p\u003e\u003cp\u003e\u003cem\u003eПоясним чуть более подробно сказанное выше.\u003c/em\u003e \u003c/p\u003e\u003cp\u003e\u003csmall\u003e Наследование (если совсем «упрощённо») понимается как расширение функциональности класса. Допустим, у нас есть класс «Средство передвижения на колёсах». Такое описание подходит и для велосипеда, и для автомобиля, и для тележки. Конечно, мы можем в качестве поля (свойства) класса использовать «количество колёс», однако попытка описать в одном классе какие-то специфические для разных средств передвижения свойства приведёт к необходимости хранить информацию, которой в реальности может и не быть. Например, «объём двигателя» — важная информация для автомобиля, но в случае с велосипедом такое поле попросту останется пустым. Выполнять каждый раз множество проверок, чтобы узнать, к каким именно полям обращаться — плохая идея; такой подход чреват ошибками, отыскать которые будет весьма непросто. Потому и была придумана концепция наследования. Можно создать два класса-наследника: «Средство передвижения на колёсах с двигателем» и «Средство передвижения на колёсах на мускульной тяге». В свою очередь, среди двигателей можно выделить двигатели внутреннего сгорания и электродвигатели. Получается, что определяя класс-наследник, мы добавляем какие-то новые спецификации, существенные именно для представителей этого класса, но неприменимые к произвольно выбранному представителю класса-предка. \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Представитель класса, или объект класса, содержит в себе конкретные значения всех спецификаций, определённых в этом классе. Т.е. класс в некотором роде «чертёж», по которому изготавливается любой объект этого класса. \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e В отличие от отношений ancestor / descendant, которые устанавливаются между классами, отношения parent / child устанавливаются между объектами. В предыдущей лабораторной работе создавался объект класса JFrame, который служил контейнером для текстовых полей и кнопок. Когда пользователь нажимает на кнопку на экране, то сигнал об этом сначала приходит операционной системе. Операционная система анализирует, каким окнам принадлежит точка, в которой произошло событие «щелчок мышкой», и определяет то, которое было активно (т. е. находилось выше других). После этого информация о щелчке мышкой передается этому окну и оно, в свою очередь, разбирается, какому объекту следует передать информацию дальше. Таким путём информация о событии добирается до «целевого» объекта, который вызывает свой метод-обработчик этого события. Как можно понять, наличие общего предка у «целевого» объекта и содержащего его «контейнера» совершенно необязательно. \u003c/small\u003e\u003c/p\u003e\u003cp\u003eСделаем ещё одно замечание. Вероятно, было бы правильно переводить stage как «сцена» (в смысле — физическая сцена, в некотором смысле «театральные подмостки»), а scene — как «эпизод» (т. е. сцена — но уже в смысле театральной постановки, элемент спектакля). Но терминология пока складывается таким образом, что слово «сцена» является именно переводом Scene, а устоявшегося перевода для Stage нет (используются скорее описательные его характеристики, например, «контейнер верхнего уровня»). Поэтому во избежание путаницы будем, по возможности, использовать английскую терминологию. \u003c/p\u003e\u003ch4\u003eЧасть 1. Создаём проект\u003c/h4\u003e\u003cp\u003eСоздайте новый проект как проект Java FX. Для этого выберите в меню File | New Project, в появившемся диалоговом окне выделите категорию JavaFX, а в ней проект Java FX Application.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 2. Выбор JavaFX проекта\" src\u003d\"/predownloaded/71/02/7102a0f19569418f595cd3d67aee712adf6e64b1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 2. Выбор JavaFX проекта\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 3. Настройки проекта \" src\u003d\"/predownloaded/31/b5/31b53c860a6bcd1c674a8c2f0cb7373523fb1bd2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 3. Настройки проекта\u003c/p\u003e\u003cp\u003eНазовите проект jfxFunctionGraphic. Все остальные настройки, за исключением Project Location (и связанной с ним Project Folder) должны быть такими, как показано на рис. 3 (фактически они установлены по умолчанию, не нужно их менять). Что касается Project Location, рекомендуется установить в качестве его значения какую-либо папку на Вашем диске W. В отличие от Eclipse, NetBeans не поддерживает концепцию «рабочего пространства» (workspace), в котором содержатся несколько проектов. Так что для каждого проекта надо создавать свою собственную папку. Возможно, Вам покажется удобным создать «общую» папку для всех папок, содержащих проекты NetBeans. \u003c/p\u003e\u003cp\u003eПосле того как Вы нажмёте кнопку Finish, Вы увидите заготовку проекта (номера строк могут не совпадать, поэтому сверяйте описание с приведённым ниже рисунком). Вероятно, поскольку JavaFX ещё достаточно новая технология (и, к тому же, не устоявшаяся — различия между первой и второй версией значительны; так что лучше не углубляться в изучение первой версии), разработчики сочли необходимым создавать проект по умолчанию непустым. Поэтому поясним, что делает код в методе start() «автоматически созданного» приложения.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 4. Код демонстрационного приложения, созданный NetBeans \" src\u003d\"/predownloaded/68/52/68522ff8211d4166d832eba2136d3e3e691b85bc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 4. Код демонстрационного приложения, созданный NetBeans\u003c/p\u003e\u003cp\u003eКонечно, Вы можете просто запустить проект и увидеть, что произойдёт; конечно, этот код будет для нас не более чем образцом; и тем не менее потратим немного времени на то, чтобы изучить его более детально. Начнём с метода start().\u003c/p\u003e\u003cp\u003eСтроки 24 и 25 (см. рис. 4) могут быть прочитаны легко: создается объект btn класса Button, после чего на кнопку «наносится» надпись (методом setText()). \u003c/p\u003e\u003cp\u003eСтроки с 26 по 32 демонстируют создание обработчика событий. Метод setOnAction присоединяет этот обработчик события к кнопке btn. Обработчик события создается как наследник класса EventHandler, параметризуемого типом ActionEvent. Обратите внимание, что при этом не происходит объявление нового типа: используется техника анонимных вложенных классов. \u003c/p\u003e\u003cp\u003eБолее подробно: в качестве параметра в метод setOnAction нужно передать экземпляр обработчика события. Можно было бы действовать «традиционным» образом: описать некоторый класс-наследник класса EventHandler, создать объект этого класса и передать этот объект в качестве параметра в setOnAction. Однако если такой объект предполагается использовать «разово», то можно сделать запись более короткой, «пожертвовав» именем класса-обработчика события (мы не сможем обратиться к нему из какого-либо другого метода). \u003c/p\u003e\u003cp\u003eВ анонимном внутреннем классе собственно объявление класса фактически помещено в вызов конструктора (new) его базового класса. В объявлении при этом могут содержаться один или несколько методов, но не может содержаться конструктор (что логично: у нас нет имени, по которому можно было бы обратиться к конструктору). \u003c/p\u003e\u003cp\u003eВ нашем случае единственным методом, который определён в новом классе (точнее, переопределён, поскольку присутствует в базовом классе, и об этом свидетельствует комментарий специального вида @Override), является метод handle(). Строка 30 является телом этого метода; при его вызове в консоли будет напечатано “Hello, world!”. \u003c/p\u003e\u003cp\u003eПосле создания кнопки создаётся объект класса StackPane с именем root. StackPane — один из наиболее просто устроенных менеджеров расположения. Он умеет помещать дочерние (по отношению к нему) объекты в стек (стопкой, снизу вверх). Впрочем, пока у нас будет единственный объект, выбор менеджера расположения не существен. Список дочерних объектов («детей») объекта root может быть получен методом getChildren(), после чего методом add() в него добавляется вновь созданная кнопка (строка 35). \u003c/p\u003e\u003cp\u003eМенеджер размещения root будет корневым узлом сцены scene (объект типа Scene, строка 37). При создании сцены задаётся не только корневой узел, но и размеры окна приложения (в пикселях).\u003c/p\u003e\u003cp\u003eНаконец, когда сцена готова, можно присоединить её к объекту primaryStage и разрешить ему отобразить эту сцену. Три действия с объектом primaryStage, описанные в строках 39 – 41, являются типичными: устанавливаем заголовок объекта класса Stage, затем устанавливаем для него сцену, после чего вызываем метод show().\u003c/p\u003e\u003cp\u003eРассмотрение метода start() на этом завершим и перейдём к рассмотрению метода main(). В отличие от start(), его код весьма краток. \u003c/p\u003e\u003cp\u003eМетод main() (хорошо знакомый Вам по консольным приложениям) выполняет здесь лишь функцию запуска (вызывает метод launch()). Метод launch() является методом, определённым в классе Application; в качестве параметров может принимать либо объект класса Application (или его наследника) и массив строк (обычно параметров командной строки), либо только массив строк. В нашем примере этот массив строк де-факто будет пустым (даже если бы это было не так — мы не запланировали выполнения каких-либо действий с ним). Запустите приложение, созданное Netbeans «по умолчанию». Вы увидите небольшое окно с кнопкой посередине (рис. 5) (менеджер расположения StackPane центрирует свои дочерние объекты). \u003c/p\u003e\u003cp\u003e\u003cimg src\u003d\"/predownloaded/dd/c5/ddc5c96036d57a0b0120fc91e60d98395b60a7c6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 5. Приложение JavaFX «по умолчанию»\u003c/p\u003e\u003cp\u003eНажмите кнопку и посмотрите на вывод (во вкладке Output Netbeans) (рис. 6). \u003c/p\u003e\u003cp\u003e\u003cimg src\u003d\"/predownloaded/1c/72/1c728f041c83e4839523775e2d38645ef694e4b1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 6. Вывод «Hello World!»\u003c/p\u003e\u003cp\u003eПосле сообщений системы (в том числе о запуске на выполнение jar-файла) появится строка “Hello World” (если Вы нажмёте на кнопку несколько раз, будет выведено соответствующее количество строк). Завершите выполнение приложения. \u003c/p\u003e\u003cp\u003eЗаймёмся теперь разработкой нашего приложения. Закомментируйте строки с 24 по 35. Для этого выделите их, как показано на рис. 7, и нажмите кнопку Comment (показана красной стрелкой). \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 7. Применение комментария к нескольким строкам\" src\u003d\"/predownloaded/84/d6/84d6262876ecfbeea28b341b3c4f9a2157037224.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 7. Применение комментария к нескольким строкам\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 8. Результат применения комментария \" src\u003d\"/predownloaded/1f/86/1f868ce3b6660fbbee586310de192f39b0fcd2b5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 8. Результат применения комментария\u003c/p\u003e\u003cp\u003eПосле выполнения этой операции каждая из выделенных строк будет помечена как «однострочный комментарий» (рис. 8) (двойной слэш предписывает компилятору считать комментарием всё, начиная с этого двойного слэша и до конца текущей строки). \u003c/p\u003e\u003cp\u003eРазумеется, теперь переменная root среде неизвестна, и компилятор показывает на ошибку в строке 37 (рис. 8). Но эту ошибку мы сейчас исправим, дописав строку с объявлением нового менеджера расположения — объекта класса BorderPane (рис .9) (этот класс понадобится импортировать — среда предложит вариант import javafx.scene.layout.BorderPane, и с ним нужно согласиться). Именно этот менеджер теперь будет носить имя root (давать такое имя менеджеру расположения совершенно необязательно, но удобно). Также поменяем заголовок окна на «График функции». \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 9. Новый менеджер расположения \" src\u003d\"/predownloaded/80/3d/803dab7c7f98b0f018bafd7b9fba5b043f558d6a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 9. Новый менеджер расположения\u003c/p\u003e\u003cp\u003eМенеджер расположения BorderPane умеет размещать свои дочерние объекты слева, справа, вверху, внизу и в центре (т. е. у него имеется пять зон размещения; рисунок с этими зонами (рис. 10) заимствован из документации Oracle по классу BorderPane). \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 10. Зоны размещения BorderPane\" src\u003d\"/predownloaded/17/be/17be94f4dae505a7e88fab7254a04539c9072332.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 10. Зоны размещения BorderPane\u003c/p\u003e\u003cp\u003eРазумеется, заполнять все зоны размещения необязательно. Нас пока будет интересовать только верхняя зона: мы планируем поместить в эту зону панель инструментов. Панель инструментов будет выглядеть довольно традиционно: набор небольших кнопок с информативными рисунками. Пока такая панель будет призвана заменить нам (главное / горизонтальное) меню. \u003c/p\u003e\u003cp\u003eКонечно, можно поместить кнопки непосредственно в Top-зону. Однако более логично сформировать панель инструментов как отдельный контейнер. В нашем случае вполне достаточно, чтобы контейнер умел располагать свои дочерние объекты в один ряд горизонтально. Поэтому мы можем воспользоваться достаточно простым менеджером расположения HBox. \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис.11. Настройки HBox\" src\u003d\"/predownloaded/93/a7/93a7cffc30a673c37e9ab6670d317c050087dc78.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 11. Настройки HBox\u003c/p\u003e\u003cp\u003eКонструктор HBox может быть вызван как без параметров, так и с единственным параметром, задающим расстояние между дочерними объектами (spacing). Мы воспользуемся вторым способом; расстояние зададим равным 10 (см. рис. 11).\u003c/p\u003e\u003cp\u003eМетод setPadding() задаёт отступы от содержимого (на рис. 11 обведено пунктиром), которое будет помещено в taskbar. В конструкторе объекта Insets отступы перечисляются в следующем порядке: сверху, справа, снизу, слева (можете представлять себе, что мы обходим содержимое по часовой стрелке, начиная с её «полуденного» положения). Зададим также предпочитаемую высоту содержимого (50). Установим выравнивание панели taskbar, указав способ TOP_LEFT (остальные варианты Вы можете прочесть в документации класса Pos). После этого добавим (пока пустую) панель инструментов в верхнюю часть контейнера root (метод setTop()). То, что у нас получится, Вы можете видеть на рис. 12.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 12. Настраиваем панель инструментов \" src\u003d\"/predownloaded/c4/58/c4582fc578d64949e7029399f13dbf7a2a89be9a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 12. Настраиваем панель инструментов\u003c/p\u003e\u003cp\u003e\u003cem\u003eЗамечание о документации.\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Документацию по классам Java 8 SE можно найти здесь: \u003ca href\u003d\"https://docs.oracle.com/javase/8/docs/api/\"\u003ehttps://docs.oracle.com/javase/8/docs/api/\u003c/a\u003e, а документацию по JavaFX 8 — здесь: \u003ca href\u003d\"http://docs.oracle.com/javase/8/javafx/api/toc.htm\"\u003ehttp://docs.oracle.com/javase/8/javafx/api/toc.htm\u003c/a\u003e. \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Если Вас заинтересует «общая картина» — рекомендуется изучить рисунок по ссылке \u003ca href\u003d\"https://docs.oracle.com/javase/8/docs/\"\u003ehttps://docs.oracle.com/javase/8/docs/\u003c/a\u003e (в частности, он позволит Вам составить впечатление о взаимосвязи и взаимоотношении между JDK и JRE). \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Для дальнейшей работы существенно понимать, что все используемые «визуальные элементы» будут из библиотеки JavaFX, и импортировать их надо именно из пакетов, название которых начинается с javafx. JavaFX не единственная графическая библиотека, используемая в Java. В предыдущей лабораторной работе Вы познакомились с библиотекой Swing; в основе же графических компонентов лежит библиотека AWT, которая поначалу была единственным способом работать в Java с графикой. Эта библиотека содержит низкоуровневые, «тяжеловесные» компоненты, в то время как Swing и JavaFX оперируют «легковесными» компонентами, являющимися надстройками над компонентами AWT. Использование новых библиотек и легковесных компонент делает работу программиста существенно проще, так как предоставляет пути решения ряда типичных задач. \u003c/small\u003e\u003c/p\u003e\u003cp\u003eТеперь добавим собственно «кнопку с картинкой» — изображением функции, при нажатии на которую будет рисоваться график функции. Такую картинку можно нарисовать самостоятельно в любом графическом редакторе. Размер картинки должен быть достаточно маленьким: «классический размер» кнопки на панели инструментов составляет всего 16 x 16 пикселей. \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 13. Рисунки для кнопки панели инструментов \" src\u003d\"/predownloaded/72/f1/72f13517fa6f1f700dd602809b42ff799b062015.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 13. Рисунки для кнопки панели инструментов\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Если Вы не хотите рисовать сами, ниже помещены два рисунка по отдельности: размером 32 x 32 пикселя (icon1.png) и размером 20 x 20 пикселей (icon2.png). Можете выбрать тот, который Вам понравится и (при желании) «доработать» его. \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 13 A. Рисунок для кнопки 32х32\" src\u003d\"/predownloaded/75/35/753574caeae34c11870c40b93b218179c3b13313.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 13 A. Рисунок для кнопки 32х32\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 13 B. Рисунок для кнопки 20х20 \" src\u003d\"/predownloaded/68/51/6851218c89a2bc8a88040a4978ce9a7d79b8d14a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 13 B. Рисунок для кнопки 20х20\u003c/p\u003e\u003cp\u003eФайл с картинкой нужно поместить в каталог проекта — непосредственно в папку jfxFunctionGraphic. Файлы проекта всегда можно увидеть, переключившись из режима Projects в режим Files (рис. 14). Обратите внимание, что рисунки можно предварительно просматривать в расположенной ниже панели навигатора (размер рисунков в пикселях также отображается). \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 14. Файлы проекта (добавлены файлы рисунков icon1.png и icon2.png) \" src\u003d\"/predownloaded/ae/6d/ae6d25da6376b29d7a91870952f36af59db3e94f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 14. Файлы проекта (добавлены файлы рисунков icon1.png и icon2.png)\u003c/p\u003e\u003cp\u003eТеперь опишем метод создания «кнопки». Сразу скажем, что эта кнопка не будет «настоящей» (т. е. мы не будем создавать её как представителя класса Button); эта кнопка будет просто рисунком, к которому мы присоединим соответствующий обработчик события. Кнопка должна стать узлом сцены, поэтому метод должен возвращать тип Node. На рис. 15 приведён код, создающий «заготовку» такой кнопки.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 15. Метод createButton \" src\u003d\"/predownloaded/66/5b/665b79c30e119aaf45220175354809120439f3d2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 15. Метод createButton\u003c/p\u003e\u003cp\u003eПоясним этот код. Метод входит в класс JfxFunctionGraphic; объявлен с директивой видимости private, что означает, что обратиться к этому методу нельзя будет ни из класса-наследника JfxFunctionGraphic, ни (тем более) из какого-либо другого класса. Вообще говоря, у нас не предполагается ни наследования от JfxFunctionGraphic, ни обращения из других классов, так что в какой-то мере использование этой директивы видимости «избыточно». Вместе с тем оно соответствует «правилам хорошего тона», исключающим обращение к таким методам извне класса. \u003c/p\u003e\u003cp\u003eВ качестве параметра метода заявлена строка — имя рисунка на кнопке. Эта строка передается в конструктор класса Image (а вызов этого конструктора, в свою очередь, становится параметром конструктора класса ImageView). Само поле node также помечено как final (что тоже в некотором смысле скорее «правило хорошего тона»: эта переменная не должна изменяться внутри метода).\u003c/p\u003e\u003cp\u003eImage поддерживает (в настоящий момент) следующие форматы файлов: bmp, gif, jpeg, png. Конструктор Image() может принимать в качестве параметра как поток, так и URL (Uniforme Resourse Locator, единый указатель ресурса; подробно о нём можно прочесть, например, в Википедии \u003ca\u003ehttps://ru.wikipedia.org/wiki/URL)\u003c/a\u003e. Обратите внимание: «file:» в конструкторе Image указывает, что ресурс является локальным файлом; а поскольку рисунок находится в текущей рабочей директории, достаточно указать только имя файла (в противном случае следовало бы указать абсолютный или относительный путь к файлу).\u003c/p\u003e\u003cp\u003eЗаметим также, что существуют варианты конструктора Image(), которые позволяют преобразовывать рисунок к нужному размеру (подробности — в документации данного класса). \u003c/p\u003e\u003cp\u003eЛегко догадаться, что эта кнопка пока ничего не делает: действительно, всё, что мы пока написали — это загрузка рисунка. Впрочем, мы уже можем добавить кнопку-узел в менеджер размещения taskbar (рис. 16), после чего запустить приложение. \u003c/p\u003e\u003cp\u003e\u003cimg src\u003d\"/predownloaded/ea/e7/eae795e6d9bfe64ab45317454ca4de148788e4a3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 16. Вызов метода createButton добавляет «кнопку» в taskbar\u003c/p\u003e\u003cp\u003eЕсли запустить приложение, рисунок не будет реагировать на какие-либо нажатия мышкой (разумеется, графика тоже не будет), но «общий вид» уже можно будет оценить (рис. 17). Завершите выполнение приложения (нажмите на красный крестик в правом верхнем углу), чтобы продолжить работу над программой.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 17. Так будет выглядеть наше приложение \" src\u003d\"/predownloaded/d6/b1/d6b155aac41f55b20621d860dbce92781ecb0810.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 17. Так будет выглядеть наше приложение\u003c/p\u003e\u003cp\u003eЗаймёмся теперь собственно построением графика. Для этого мы используем компонент Chart и, поскольку этот компонент будет единственным в своей части окна приложения, воспользуемся простым менеджером размещения StackPane. Опишем переменную view типа StackPane в классе (нам потребуется использовать её более, чем в одном методе, поэтому мы не можем описать её в методе start(), как это было сделано в демонстрационном приложении). Удобно сделать это в самом конце описания класса (последняя фигурная скобка на рисунке закрывает описание класса).\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 18. Объявление переменной view \" src\u003d\"/predownloaded/03/c2/03c2899424f64503517353b4396d2e5546709946.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 18. Объявление переменной view\u003c/p\u003e\u003cp\u003eТеперь дополним метод start() строками, отвечающими за создание этого менеджера размещения и присоединение его к центральной области менеджера размещения root. Чтобы сразу можно было увидеть результат, добавим пока в список узлов нового менеджера размещения текст-заглушку (надеемся, Вы не забываете импортировать все необходимые классы).\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 19. Создание нового менеджера размещения\" src\u003d\"/predownloaded/a5/af/a5af484a2ae4bc6a13c7b7a2f5a4b78e77936d42.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 19. Создание нового менеджера размещения\u003c/p\u003e\u003cp\u003eПрежде чем вновь запустить приложение, внесем еще одно изменение в код: «покрасим» окно приложения. Конечно, Вы можете выбрать любой понравившийся Вам цвет. \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 20. Перекрасим окно приложения в голубой цвет \" src\u003d\"/predownloaded/59/8a/598a64ce30513b122f129d965da6102d643458e0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 20. Перекрасим окно приложения в голубой цвет\u003c/p\u003e\u003cp\u003eТеперь после запуска приложение будет выглядеть следующим образом:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 21. Приложение в результате внесённых изменений. \" src\u003d\"/predownloaded/a1/91/a191f532b4c2ce4e4a7012eef433ba637c02e4d8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 21. Приложение в результате внесённых изменений.\u003c/p\u003e\u003cp\u003eОднако делать оно по-прежнему ничего не «умеет». Для начала «научим» его рисовать оси координат. Нам потребуется модифицировать метод createButton(), после чего изменить код добавления кнопки-иконки в менеджер размещения. Начнём с метода createButton(): добавим в его список параметров второй параметр, отвечающий за выполнение кнопкой некоторого действия при нажатии на неё. \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 22. Изменённый метод createButton() \" src\u003d\"/predownloaded/65/b3/65b3fcbf4144448eaa6d48560293113a0beced3a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 22. Изменённый метод createButton()\u003c/p\u003e\u003cp\u003eНа рисунке красным выделены внесённые изменения в первоначальный метод. Обратите внимание, что после модификации метода createButton() среда укажет на ошибку в строке, содержащей вызов этого метода — taskbar.getChildren().add(createButton(\u0026quot;icon2.png\u0026quot;)). Это нормально, поскольку в вызове указан только один параметр, а теперь в методе их два. На следующем шаге мы исправим вызов метода, а пока прокомментируем только что написанный код. \u003c/p\u003e\u003cp\u003eВ качестве второго параметра в заголовке метода мы указали параметр action типа Runnable. Интерфейс Runnable() содержит единственный метод run(), который может выполняться «бесконечно». Существуют задачи, в которых некоторое действие нужно выполнять постоянно: например, отображать температуру воздуха или показывать «бегущую строку». Такие задачи решаются при помощи потоков (в смысле класса Thread). Отображение графика также относится к этим задачам: действительно, мы можем изменить размеры окна, изменить какие-то другие параметры — и это должно для графика стать поводом перерисоваться.\u003c/p\u003e\u003cp\u003eОднако использовать класс-наследник класса Thread получается далеко не всегда. Вторая возможность использовать потоки заключается в том, чтобы реализовать в имеющемся у нас классе интерфейс Runnable. Экземпляр класса, реализующего интерфейс Runnable, можно запустить средствами класса Thread как поток. Таким образом, использование параметра типа Runnable является более общим подходом, даже если мы имеем возможность использовать в качестве параметра класс Thread (или его наследника). \u003c/p\u003e\u003cp\u003eСлово final перед параметром означает, что внутри метода параметр не получит какого-либо значения. Поскольку описание действия кнопки «приходит» извне, представляется правильным запретить какие-либо изменения. \u003c/p\u003e\u003cp\u003eТеперь разберём шесть новых строк в теле метода. Здесь мы вновь встречаем анонимный класс (среда предлагает преобразовать его в лямбда-выражение, но мы пока не станем этого делать: новой информации и терминологии более чем достаточно). \u003c/p\u003e\u003cp\u003eИтак, для узла node мы хотим установить реакцию на событие щелчка мышью (по нему). Это можно сделать с помощью метода setOnMouseClicked(). В качестве параметра этому методу нужно передать обработчик события мыши. Чтобы создать такой обработчик, нам понадобится наследник класса EventHandler (event — событие, handler — обработчик), притом параметризованный именно событиями мыши (MouseEvent; в предыдущем случае у нас был ActionEvent). Однако, поскольку экземпляр такого класса нам требуется только один и использоваться он будет ровно в одном месте кода, мы не описываем класс-наследник непосредственно, а используем технику анонимных классов. А именно, мы вызываем конструктор интересующего нас в качестве класса-предка параметризованного класса и непосредственно в этом конструкторе описываем тот метод, который и будет обрабатывать событие мыши — метод handle(). Этот метод описан в классе-предке, поэтому мы помечаем его как @Override и в точности соблюдаем его исходную сигнатуру. Единственной строкой в теле этого метода будет вызов метода run() параметра action. \u003c/p\u003e\u003cp\u003eНаша следующая задача — отредактировать вызов метода createButton() при добавлении узла в менеджер размещения. Однако перед этим нам потребуется написать еще один небольшой метод, также отвечающий за обновление изображения. Он будет сначала удалять существующий узел (т. е. собственно график) из менеджера размещения view, а затем вновь добавлять его). Назовём этот метод changeView(). Можно написать его после метода createButton() (как и показано на рис. 23). В качестве единственного параметра он получает узел node. В теле метода сначала вызывается метод clear() для списка дочерних объектов менеджера размещения view, а затем узел, переданный в качестве параметра, добавляется в список дочерних объектов view с помощью метода add(). \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 23. Метод changeView() \" src\u003d\"/predownloaded/fd/18/fd18d6d47eaba3baad8452caa160b7ebf9949f43.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 23. Метод changeView()\u003c/p\u003e\u003cp\u003eТеперь всё готово, чтобы отредактировать код вызова метода createButton(). После модификации он должен выглядеть как на рис. 24:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 24. Отредактированный вызов метода createButton() \" src\u003d\"/predownloaded/4e/36/4e36bedd5d79373a20e8fb2e49f16a41aadda2b2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 24. Отредактированный вызов метода createButton()\u003c/p\u003e\u003cp\u003eПосмотрим внимательно на этот код. Как можно видеть, и здесь мы снова воспользовались анонимным классом. Действительно, нам было необходимо добавить в вызов метода createButton() параметр типа Runnable. Для этого мы непосредственно в вызове метода создаем экземпляр класса, реализующего интерфейс Runnable. Как мы уже говорили, в интерфейсе Runnable описан единственный метод run(), и именно его мы переопределяем.\u003c/p\u003e\u003cp\u003eВ этом методе сначала создаются два объекта класса NumberAxis («говорящее название» — числовая ось). Затем мы создаем объект chart класса LineChart, передавая в его конструктор только что созданные оси координат. Затем устанавливаем в качестве заголовка графика «Line Chart» (впоследствии заменим), а также расставляем метки на оси. Последняя строка метода run как раз и есть вызов метода changeView().\u003c/p\u003e\u003cp\u003eЗапустите приложение на выполнение и нажмите на иконку. Вы сможете увидеть координатные оси, надписи на них, а также надпись на графике. \u003c/p\u003e\u003cp\u003eПопробуйте растянуть или уменьшить окно, в котором отображается график. Вероятно, Вы даже заметите плавную перерисовку осей координат. Однако количество делений на осях при этом меняется не очень значительно (т.е. график будет просто масштабироваться; чтобы увидеть его в другом диапазоне, потребуются некоторые дополнительные действия). \u003c/p\u003e\u003cp\u003eТо, как должно сейчас выглядеть приложение, показано на рис. 25.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 25. Вид приложения с координатными осями (после нажатия на кнопку-иконку) \" src\u003d\"/predownloaded/01/1f/011fbe6a65b5e0f5cb6347f00259cf9f5b71b0c0.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 25. Вид приложения с координатными осями (после нажатия на кнопку-иконку)\u003c/p\u003e\u003cp\u003eТеперь добавим к коду, строящему оси координат, еще и код, рисующий график какой-нибудь функции. Ради примера пусть это будет функция sin(x).\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 26. Код, отвечающий за отрисовку графика \" src\u003d\"/predownloaded/0b/69/0b695c98fc687a118785b3f013e1c1eba7793718.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 26. Код, отвечающий за отрисовку графика\u003c/p\u003e\u003cp\u003eПоясним новый фрагмент кода (как можно видеть, мы добавили его сразу после установки меток на координатных осях и непосредственно перед перерисовкой методом changeView()).\u003c/p\u003e\u003cp\u003eВо-первых, мы создаем «серию» данных. Объект series создается как представитель статического класса XYChart.Series. Заметим, что XYChart — класс-предок по отношению к классу LineChart. \u003c/p\u003e\u003cp\u003e\u003cem\u003eВложенные классы\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e Поясним, что такое статический класс. Когда мы описываем некоторый класс, мы фактически группируем с его помощью какие-либо данные и методы их обработки. Однако может сложиться такая ситуация, что внутри класса тоже нужно сгруппировать некоторые данные. Например, если бы мы описывали человека, мы могли бы группировать его паспортные данные: ведь серия, номер, дата и место выдачи паспорта не имеют смысла по отдельности, а описывают некий совокупный объект (в нашем случае — документ). Вместе с тем может оказаться, что вне «большого класса» (правильно называть его внешним классом) такая группировка данных особого смысла не имеет, она значима только в контексте «большого класса». Именно в таких ситуациях имеет смысл объявить класс внутри класса (синтаксис позволяет любую глубину вложенности). \u003c/small\u003e\u003c/p\u003e\u003cp\u003e\u003csmall\u003e В зависимости от того, как будут использоваться данные такого вложенного (nested) класса, он называется либо внутренним (inner), либо статическим (static). Если кратко, объект внутреннего класса привязан к объекту внешнего класса (как в нашем примере с паспортными данными, объект «Паспорт» будет соответствовать конкретному объекту «Человек»), а объект статического класса лишь отражает способ группировки данных; в данной ситуации — способ образования данных, которые будут отображаться на графике. \u003c/small\u003e\u003c/p\u003e\u003cp\u003eИтак, сначала мы создаем пустой набор (серию) данных, после чего приступаем к его заполнению. Выберем диапазон по оси OX, для которого мы хотим построить график. Пусть это будет отрезок \u003cspan class\u003d\"tex-span\"\u003e[ - 2·π,  2·π]\u003c/span\u003e. График на этом отрезке мы будем строить по 50 точкам (именно за количество точек отвечает переменная steps). Разумеется, Вы можете попробовать использовать большее количество точек, но ставить слишком большое число не стоит.\u003c/p\u003e\u003cp\u003eЗатем мы определяем шаг графика dx, после чего для каждой точки, начиная с lowX и отстоящей от предшествующей ей точки на dx, добавим в список данных очередную точку для графика. Для добавления мы воспользуемся конструктором другого статического класса XYChart.Data (отвечающего за «одиночное» значение). В качестве параметров конструктору этого класса можно передать пару чисел, и он сформирует из них точку для отображения на графике. \u003c/p\u003e\u003cp\u003eВ цикле for как раз и формируется набор данных series, который потом добавляется к данным графика chart (метод getData() унаследован классом LineChart от класса XYChart). После этого происходит отрисовка графика. \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/ff/7c/ff7c702ec4104a1d40c8095b1d160f2b98497969.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 27 График функции sin(x)\u003c/p\u003e\u003cp\u003eНа рис. 27 показан график, который сформируется после запуска приложения и нажатия на кнопку-иконку. Разумеется, Вы можете растягивать окно приложения или уменьшать его и наблюдать за изменениями графика. \u003c/p\u003e\u003cp\u003eНаша следующая задача — сделать так, чтобы можно было выбирать, график какой функции мы хотим увидеть. Поскольку мы не планируем писать распознаватель формул (по крайней мере, в ближайшее время), ограничимся несколькими заранее предусмотренными вариантами: а именно \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esin\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ecos\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e\u003c/span\u003e. Чтобы выбирать из них, создадим раскрывающийся список. Этот список тоже будет узлом нашей сцены, поэтому напишем метод createComboBox(). Его можно поместить в самом конце класса:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 28. Метод, создающий кнопку с выпадающим списком\" src\u003d\"/predownloaded/5c/0a/5c0a9434d0fe8aba862b993513576705f5d699d3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 28. Метод, создающий кнопку с выпадающим списком\u003c/p\u003e\u003cp\u003eПоясним код этого метода. Сначала мы создаем объект cb — с помощью конструктора по умолчанию класса ComboBox, параметризованного String (т. е. это значит, что элементами выпадающего списка будут строки; это не единственная возможность для выпадающего списка, подробнее можно посмотреть в документации, в частности, можно использовать рисунки для обозначения его пунктов).\u003c/p\u003e\u003cp\u003eВ следующей строке мы обращаемся к списку элементов (методом getItems()) и добавляем к этому списку (исходно он пуст) строки, которые собственно списком и должны стать. Мы используем метод addAll(), чтобы добавить сразу все четыре строки. Заметим, что в список элементы будут внесены (и занумерованы) в точности так, как они перечислены в методе.\u003c/p\u003e\u003cp\u003eЗатем мы указываем, что «изначальным» выбором будет первый элемент списка. Для этого мы сначала обращаемся к «модели выбора» (в нашем случае эта модель означает, что выбирать можно только один элемент; множественный выбор не предусмотрен), после чего вызываем метод выбора первого элемента. \u003c/p\u003e\u003cp\u003eТеперь можно «возвратить» вновь созданный объект cb в качестве результата этого метода и вызвать метод, чтобы создать кнопку:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 29. Вызов метода создания кнопки с выпадающим списком \" src\u003d\"/predownloaded/4e/9f/4e9fac4c97f6c9c4c34a34ecd460cb9a5d18dbbc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 29. Вызов метода создания кнопки с выпадающим списком\u003c/p\u003e\u003cp\u003eВызов метода мы помещаем перед вызовом метода создания кнопки-иконки; в этом случае менеджер размещения поместит кнопку с выпадающим списком левее. Сейчас уже можно запустить приложение и удостовериться, что кнопка есть. Правда, пока она ничего не делает (хотя выбрать функцию можно).\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 30. Раскрывающийся список уже есть, но на графике функции это пока не отражается \" src\u003d\"/predownloaded/4b/39/4b390901d736a013b6c569515bff227236c40033.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 30. Раскрывающийся список уже есть, но на графике функции это пока не отражается\u003c/p\u003e\u003cp\u003eТеперь, чтобы наше приложение было способно нарисовать график интересующей нас функции, мы должны научиться подставлять эту функцию вместо sin(x) в код, генерирующий серию данных. Начиная с версии 1.7 в Java появился удобный механизм, позволяющий достаточно легко решать такие задачи (и не только, но об этом мы будем говорить позже) — это функциональные интерфейсы и лямбда-выражения. Мы пока ограничимся пояснением тех элементов, которые будем использовать. \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 31. Объявление переменных cmbFunc и func \" src\u003d\"/predownloaded/53/00/53001214871f6b4380b4fd06aca8e30bdc85fa60.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 31. Объявление переменных cmbFunc и func\u003c/p\u003e\u003cp\u003eОбъявим (в конце класса) две переменные: cmbFunc и func. Переменная func имеет тип DoubleUnaryOperator, который фактически описывает функцию, принимающую единственное вещественное значение и возвращающую также единственное вещественное значение (при необходимости Вы могли бы и сами определить такой или подобный тип, но для наиболее распространенных вариантов функций типы уже определены в стандартной библиотеке, поэтому мы используем готовый вариант). Переменная cmbFunc — массив элементов типа DoubleUnaryOperator. Мы планируем использовать эти переменные следующим образом: в массиве будут храниться все возможные функции, а в func — та, которая в текущий момент будет выбрана. \u003c/p\u003e\u003cp\u003eРазумеется, массив cmbFunc нужно заполнить заранее. Вполне логично сделать это в методе создания кнопки с раскрывающимся списком.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 32. Инициализация переменных cmbFunc и func \" src\u003d\"/predownloaded/9a/76/9a76abcca61eb5ea7265b9855bf471c20cc053ec.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 32. Инициализация переменных cmbFunc и func\u003c/p\u003e\u003cp\u003eКак можно видеть, сначала мы выделяем память под массив из четырех объектов, после чего заполняем их. Здесь Вы видите весьма необычный синтаксис. Пока скажем следующее: если некоторая функция объявлена в классе Java (в данном случае речь о классе Math), то к ней можно обратиться через двойное двоеточие (именно как к функции; нам не нужно здесь вычислять какое-то конкретное значение синуса, требуется именно способ вычисления). Если же функцию нужно записать самостоятельно, то используется стрелка (она состоит из двух символов), выполняющая роль символа отображения (показывает, каким образом из значения x будет получено значение функции от x). Наконец, после инициализации массива мы инициализируем переменную func, устанавливая ее равной нулевому элементу массива. Впрочем, этого еще недостаточно для работы: мы должны обеспечить изменение значения переменной func при выборе того или иного элемента списка. Для этого нужно присоединить к нашей кнопке обработчик события:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 33. Устанавливаем обработчик события \" src\u003d\"/predownloaded/1b/b7/1bb7a8da82c5821d752fe1178392271570d0c3fd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 33. Устанавливаем обработчик события\u003c/p\u003e\u003cp\u003eВоспользуемся уже знакомой нам техникой анонимных классов: создадим непосредственно в методе setOnAction(), устанавливающем реакцию кнопки на действие выбора, экземпляр анонимного класса с обработчиком, изменяющим значение переменной func. С помощью метода getSelectedIndex() определим индекс выбранного элемента в списке и обратимся по этому индексу к элементу массива cmbFunc. Обратите внимание, что за соответствие элементов списка и элементов массива cmbFunc полностью отвечает программист: никакого механизма «автоматического согласования» не предусмотрено (и сделать это каким-то простым образом не получится: в отображаемом списке используются строки, а в массиве функций — элементы типа DoubleUnaryOperator).\u003c/p\u003e\u003cp\u003eТеперь мы можем использовать переменную func при формировании данных для графика:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 34. Использование func вместо sin(x) \" src\u003d\"/predownloaded/b2/9c/b29c298ac3e132ce4d6c08aaa0bbdc02db4f4bf2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 34. Использование func вместо sin(x)\u003c/p\u003e\u003cp\u003eТеперь наше приложение может строить разные графики. Например, построим параболу:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"Рис. 35. График параболы \" src\u003d\"/predownloaded/64/72/647284a7bcf5bd6c9f1cdc163b793d235119c727.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eРис. 35. График функции \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eЗадание для самостоятельного выполнения (все пункты обязательны для всех).\u003c/p\u003e\u003cp\u003e1. Как можно видеть на последнем рисунке, в приложении в качестве подписи к графику отображается sin(x). Измените приложение таким образом, чтобы под графиком отображалась именно та функция, которая на нем изображена. Допускается и такой вариант: убрать подпись под графиком и добавить название функции на место надписи Line Chart.\u003c/p\u003e\u003cp\u003e\u003cem\u003eРекомендация\u003c/em\u003e: поместите строковые наименования функций в массив или список ArrayList (в последнем случае можно будет передавать такой список в метод addAll() при заполнении элементов раскрывающегося списка). \u003c/p\u003e\u003cp\u003e2. Верхнее и нижнее значение переменной x жёстко задано в тексте программы. Добавьте два текстовых поля, с помощью которых можно задавать верхнее и нижнее значение x, и две метки, поясняющие их назначение.\u003c/p\u003e\u003cp\u003e\u003cem\u003eРекомендация\u003c/em\u003e: воспользуйтесь классами TextField и Label из пакета javafx. Для создания экземпляров объектов таких классов потребуется написать методы, подобные createComboBox(). Разумеется, писать отдельный метод на каждый экземпляр TextField и на каждый экземпляр Label нет необходимости; подумайте, как обойтись одним методом.\u003c/p\u003e\u003cp\u003eРазмещение элементов — на Ваш вкус; не забывайте, что исходно мы использовали менеджер размещения с пятью областями, а заняли пока только две из них (верхнюю и центральную). \u003c/p\u003e\u003cp\u003e3. Выбор из нескольких функций, конечно, более интересен, чем рисование графика единственной заданной функции. Однако мы можем ещё разнообразить выбор пользователя.\u003c/p\u003e\u003cp\u003eПусть функция будет иметь вид: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b2/fd/b2fd35afa725a6e8a05a4fa7201a7d20703e63a9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eКоэффициенты \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e — вещественные числа (ввод с помощью TextField), степени \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e\u003c/span\u003e — целые (Вы можете «запретить» пользователю вводить вещественные числа с помощью регулярных выражений или же вовсе предоставить ему несколько вариантов с помощью ComboBox вместо TextField). Также добавьте метки (Label), поясняющие назначение полей. \u003c/p\u003e\u003cp\u003eЧто же касается функций \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e — это «стандартные» функции, которые пользователь выбирает из раскрывающегося списка. За основу возьмите список, который уже присутствует в лабораторной работе, и дополните его хотя бы одной функцией из класса Math и хотя бы одной функцией, которую Вы определите самостоятельно. \u003c/p\u003e\u003cp\u003eПользователь может «собрать» собственную функцию, а затем, нажав на кнопку отрисовки, получить ее график. \u003c/p\u003e\u003cp\u003eКроме того, под графиком (или над графиком — см. задание 1) должна отображаться строка, показывающая, какая именно функция изображена на графике. \u003c/p\u003e\u003cp\u003e\u003cem\u003eРекомендация\u003c/em\u003e: подумайте, можете ли Вы воспользоваться уже существующим методом createComboBox() для всех функций, а также уже написанным в п.2. методом создания текстового поля для коэффициентов (и, возможно, степеней).\u003c/p\u003e\u003c/div\u003e","tags":["javafx","function graph"]}}