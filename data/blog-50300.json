{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1486468622,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1486468622,"id":50300,"title":"\u003cp\u003eСоздание проекта в Eclipse\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cem\u003e(текст не совсем новый: описывалось на примере Eclipse Luna для Windows, затем был немного подправлен, для других версий и ОС могут быть некоторые отличия)\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003e(предполагается, что у Вас установлен пакет JDK последней версии, скачан и развернут Eclipse — он доступен как в виде zip-архива, так и в виде инсталлятора для Windows)\u003c/em\u003e\u003c/p\u003e\u003cp\u003e1. Запускаем интегрированную среду разработки (IDE) Eclipse. При запуске появляется диалоговое окно, предлагающее выбрать рабочую область (Workspace). \u003cbr /\u003e\u003cbr /\u003e Рабочая область позволяет организовывать Ваши проекты, в частности, обеспечивая при их создании одинаковые настройки. Проекты, размещённые в одной рабочей области, отображаются в среде разработки, могут быть открыты и запущены, как только потребуется. Между рабочими областями можно переключаться, но это происходит не мгновенно. Скорее всего, на первое время Вам будет достаточно одной рабочей области. Создайте её на Вашем диске W (в университетской сети); на Вашем компьютере Вы можете поместить её там, где Вам удобно. Лучше избегать использования кириллических символов, пробелов и иных спецсимволов при именовании каталогов. \u003cbr /\u003e\u003cbr /\u003e IDE Eclipse обычно предлагает выбрать ту рабочую область, которая использовалась последней. Если Вы уже создавали рабочую область (на W:), достаточно удостовериться, что выбрана именно она. Если же нет (или по каким-либо причинам Вы решили создать новую область), то воспользуйтесь кнопкой \u003cem\u003e\u003cstrong\u003eBrowse\u003c/strong\u003e\u003c/em\u003e в диалоговом окне и с помощью окна \u003cem\u003eОбзор папок\u003c/em\u003e создайте новую папку, которая и станет новой рабочей областью. \u003cbr /\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e2. Если рабочая область уже существует и настроена, этот пункт можно пропустить. Иначе — в пункте горизонтального меню \u003cem\u003eWindow\u003c/em\u003e выберите пункт \u003cem\u003ePreferences\u003c/em\u003e (это верно для ОС семейства Windows, в других ОС упоминающиеся здесь и далее пункты меню могут располагаться иначе). В открывшемся окне раскройте пункт \u003cem\u003eJava\u003c/em\u003e и выберите \u003cem\u003eInstalled JREs\u003c/em\u003e. \u003cbr /\u003e\u003cbr /\u003e Посмотрите, какая JRE (Java Runtime Environment) установлена как основная (она отмечена галочкой). Если это jdk 1.8 — то ничего делать не нужно, можно закрыть окно настроек. Если же это jre 1.8 — то нужно сделать основной JRE jdk (если не сделать — «неприятности» могут быть самыми разными: например, eclipse сообщит Вам, что ему неизвестен какой-либо класс и т.п.). \u003cbr /\u003e\u003cbr /\u003e Если у Вас стоит jdk или jre с меньшим номером — 1.6, 1.7 — в первую очередь проверьте версию Eclipse. Версию 1.8 Eclipse поддерживает, начиная с версии Luna (следующие версии — Mars, Neon), и крайне желательно, чтобы у Вас стояли именно jdk 1.8 и наиболее новый Eclipse. Это свободно распространяемые продукты, Вы можете скачать jdk отсюда: \u003ca href\u003d\"http://www.oracle.com/technetwork/java/javase/downloads/index.html?ssSourceSiteId\u003docomen\"\u003ehttp://www.oracle.com/technetwork/java/javase/downloads/index.html?ssSourceSiteId\u003docomen\u003c/a\u003e (Вам нужно именно JDK), а Eclipse — отсюда: \u003ca href\u003d\"http://www.eclipse.org/downloads/\"\u003ehttp://www.eclipse.org/downloads/\u003c/a\u003e (вероятно, на данный момент лучший выбор — для Java-разработчиков, дополнительные функции скорее будут помехой). \u003cbr /\u003e\u003cbr /\u003e Если jdk 1.8 отсутствует в списке Installed JREs (но при этом установлена у Вас на компьютере), следует нажать кнопку \u003cem\u003e\u003cstrong\u003eAdd...\u003c/strong\u003e\u003c/em\u003e, в появившемся диалоговом окне выбрать Standard VM (обычно она выбрана по умолчанию) и нажать кнопку \u003cem\u003e\u003cem\u003eNext\u003c/em\u003e\u003c/em\u003e. Затем, в следующем диалоговом окне нажать кнопку \u003cem\u003e\u003cstrong\u003eDirectory...\u003c/strong\u003e\u003c/em\u003e , после чего в окне \u003cem\u003eОбзор папок\u003c/em\u003e найти, где размещена нужная JDK. Скорее всего, путь к ней будет выглядеть примерно так: \u003cbr /\u003e\u003cbr /\u003e \u003ccode\u003eC:\\Program Files\\Java\\jdk1.8.0_65\u003c/code\u003e \u003cbr /\u003e\u003cbr /\u003e Когда jdk 1.8 появится в списке, пометьте её галочкой. Другие jdk и jre можно (при желании) удалить из списка с помощью кнопки \u003cem\u003e\u003cstrong\u003eRemove\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\u003cp\u003e3. Теперь создадим новый проект: \u003cem\u003eFile | New | Java Project\u003c/em\u003e. В первом диалоговом окне нужно указать имя проекта. Лучше всего, если Вы будете называть проект содержательным именем, начиная с маленькой буквы, и будете использовать при этом только латинские буквы, цифры и символы подчеркивания. Например, \u003ccode\u003eproblem_5_18\u003c/code\u003e, \u003ccode\u003ezadanie_2_4\u003c/code\u003e. \u003cbr /\u003e\u003cbr /\u003e При создании проекта удостоверьтесь, что в пункте \u0027Use an execution environment JRE\u0027 указана именно JavaSE-1.8. В этом окне ничего менять не нужно, нажмите кнопку \u003cem\u003e\u003cstrong\u003eFinish\u003c/strong\u003e\u003c/em\u003e. В результате будет создана структура папок: папка с именем проекта и внутри неё папка \u003ccode\u003esrc\u003c/code\u003e. Также в состав проекта будет включена \u003ccode\u003eJRE System Library (JavaSE-1.8)\u003c/code\u003e. \u003c/p\u003e\u003cp\u003e4. Создадим собственно файл для размещения в нем текста программы. Проще всего это сделать, щелкнув правой клавишей мыши на папке \u003ccode\u003esrc\u003c/code\u003e внутри проекта и в появившемся контекстном меню выбрав \u003cem\u003eNew | Class\u003c/em\u003e. \u003cbr /\u003e\u003cbr /\u003e В открывшемся диалоговом окне будут установлены значения \u003ccode\u003eSource folder\u003c/code\u003e и \u003ccode\u003ePackage\u003c/code\u003e. Менять \u003ccode\u003eSource folder\u003c/code\u003e не нужно; что же касается \u003ccode\u003ePackage\u003c/code\u003e — большинство проверяющих систем (online judge) требуют, чтобы файлы содержались в default-пакете. Конечно, использование собственных пакетов позволит (в перспективе) лучше структурировать Ваши программы, а первую строчку программы вида \u003ccode\u003epackage packname\u003c/code\u003e можно просто удалить перед тем, как отправлять решение на проверку. Впрочем, пока Вы вряд ли будете писать программы со сложной структурой, так что значение в строке \u003ccode\u003ePackage\u003c/code\u003e (по умолчанию совпадающее с именем проекта) можно просто удалить, оставив эту строку пустой. В этом случае будет создан именно пакет default, в который и будет помещен файл с исходным кодом. \u003cbr /\u003e Ваша задача — указать имя класса в поле \u003ccode\u003eName\u003c/code\u003e. По соглашению имена классов в Java начинаются с заглавной буквы, могут содержать также строчные и заглавные буквы, символы подчеркивания и цифры (и некоторые иные символы; Java успешно работает, например, с кириллическими символами, но могут возникнуть проблемы при переносе такой программы с одного компьютера на другой, поэтому рекомендуется всё же остановиться на классическом \u0026quot;наборе\u0026quot;). Постарайтесь давать классам содержательные названия (например, \u003ccode\u003eChess\u003c/code\u003e или \u003ccode\u003eShakhmaty\u003c/code\u003e). \u003cbr /\u003e\u003cbr /\u003e Также рекомендуется поставить галочку в пункте \u003ccode\u003epublic static void main(String[] args)\u003c/code\u003e. Конечно, уметь писать заголовок этого метода обязательно нужно, но поначалу можно избегать ошибок таким образом. \u003cbr /\u003e\u003cbr /\u003e Нажмите кнопку \u003cem\u003e\u003cstrong\u003eFinish\u003c/strong\u003e\u003c/em\u003e. В папке \u003ccode\u003esrc\u003c/code\u003e появится значок пакета, а в нём — имя файла. Сам же файл откроется в редакторе среды Eclipse. \u003cbr /\u003e\u003cbr /\u003e Он будет выглядеть приблизительно так: \u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage first;\n\npublic class AplusB {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e5. Представляется, что поначалу лучше придерживаться какой-то «единой архитектуры приложения». Поэтому предлагается делать следующее. Класс, который мы только что создали, будем рассматривать как «оболочку для запуска». А для реализации «логики» напишем отдельный класс. \u003cbr /\u003e\u003cbr /\u003e Сделаем это на примере задачи «сложить два вещественных числа A и B». \u003cbr /\u003e\u003cbr /\u003e Напечатайте в редакторе, отступив строчку после последней закрывающей фигурной скобки, с новой строки \u003ccode\u003eclass ABSumma {\u003c/code\u003e и нажмите \u003cem\u003eEnter\u003c/em\u003e. Eclipse завершит объявление класса закрывающей фигурной скобкой автоматически. У Вас должно получиться следующее (здесь и далее приводится полный текст программы на текущий момент, чтобы Вы могли видеть расположение ее составляющих):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage first;\n\npublic class AplusB {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass ABSumma {\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e6. Каждый класс имеет конструктор. Даже если Вы не напишете конструктор явным образом, у класса он все равно будет — унаследованный от «всеобщего предка» класса Object. Конструктор позволяет сделать ряд полезных вещей: установить начальные значения для каких-то переменных, выполнить чтение данных с клавиатуры и т.п. \u003cbr /\u003e\u003cbr /\u003e Можно считать, что конструктор имеет то же имя, что и класс. Но поскольку это метод, он снабжён круглыми скобками. Есть другая точка зрения — что конструктор не имеет имени, но возвращает значение типа класса, в котором он содержится. Она менее популярна, хотя логически выглядит вполне обоснованной. \u003cbr /\u003e\u003cbr /\u003e Напечатайте в новом классе \u003ccode\u003eABSumma () {\u003c/code\u003e и нажмите \u003cem\u003eEnter\u003c/em\u003e. У Вас получится следующее:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage first;\n\npublic class AplusB {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass ABSumma {\n\n\tABSumma() {\n\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e7. В конструкторе мы будем выполнять чтение вещественных переменных \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e. Для этого нам понадобится их объявить. Эти переменные будут использоваться не только в конструкторе, но и в методе, вычисляющем сумму. Поэтому их нужно объявить в классе, а не в конструкторе — тогда они будут доступны всем методам. Объявления можно писать в любом месте класса, но чаще всего это делают либо в начале класса, либо в конце (как показано ниже). \u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage first;\n\npublic class AplusB {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass ABSumma {\n\n\tABSumma() {\n\n\t}\n\n\tdouble a;\n\tdouble b;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e8. А вот чтение данных с клавиатуры мы выполним в конструкторе, поэтому переменная, которая позволит нам это сделать, будет объявлена внутри него (и когда конструктор завершит свою работу, эта переменная также прекратит свое существование). \u003cbr /\u003e\u003cbr /\u003e Для чтения данных с клавиатуры мы воспользуемся классом \u003ccode\u003eScanner\u003c/code\u003e. Сначала мы создадим экземпляр класса \u003ccode\u003eScanner\u003c/code\u003e и передадим ему в качестве параметра \u003ccode\u003eSystem.in\u003c/code\u003e — так называемый стандартный поток ввода (т.е. с клавиатуры).\u003c/p\u003e\u003cp\u003eКласс \u003ccode\u003eScanner\u003c/code\u003e содержится в одном из пакетов JDK, а именно в \u003ccode\u003ejava.util\u003c/code\u003e, и его нужно будет импортировать. Проще всего позволить системе сделать это автоматически. Наберите \u003ccode\u003eScan\u003c/code\u003e в первой строке кода конструктора и подождите некоторое время (или нажмите \u003cem\u003eCtrl\u003c/em\u003e + \u003cem\u003eSpace\u003c/em\u003e) — и среда предложит варианты, среди которых будет завершение ввода как \u003ccode\u003eScanner\u003c/code\u003e именно из нужного пакета. Выберите этот вариант, и предложение импорта добавится выше объявления класса \u003ccode\u003eAplusB\u003c/code\u003e. \u003cbr /\u003e\u003cbr /\u003e Ещё один важный момент связан с локализацией ОС и Вашего приложения. По умолчанию корректным разделителем целой и дробной частей числа будет считаться тот, который установлен в операционной системе. Однако в «мире программирования» обычно используется «англоязычный» вариант разделителя — т. е. десятичная точка. Поэтому перед чтением чисел мы укажем, что хотим использовать региональные настройки US или UK. Это делается с помощью метода \u003ccode\u003euseLocal()\u003c/code\u003e класса \u003ccode\u003eScanner\u003c/code\u003e, в качестве параметра указывается \u003ccode\u003eLocale.US\u003c/code\u003e. Класс \u003ccode\u003eLocale\u003c/code\u003e также нужно будет импортировать. \u003cbr /\u003e\u003cbr /\u003e После этого воспользуемся методом чтения вещественного числа \u003ccode\u003enextDouble()\u003c/code\u003e и прочитаем значения \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e. Мы предполагаем, что тот, кто будет вводить значения, не ошибается, и введет именно два вещественных числа (а не строки, например; конечно, можно предусмотреть и защиту от ошибок, но пока мы этим заниматься не будем). \u003cbr /\u003e\u003cbr /\u003e По завершении чтения закроем экземпляр класса \u003ccode\u003eScanner\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage first;\n\nimport java.util.Locale;\nimport java.util.Scanner;\n\npublic class AplusB {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass ABSumma {\n\n\tABSumma() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tin.useLocale(Locale.US);\n\t\ta \u003d in.nextDouble();\n\t\tb \u003d in.nextDouble();\n\t\tin.close();\n\t}\n\n\tdouble a;\n\tdouble b;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e9. Теперь напишем метод, складывающий два вещественных числа \u003cem\u003e(конечно, это \u0026quot;архитектурное излишество\u0026quot;, но мы хотим продемонстрировать разные возможности на одном очень простом примере)\u003c/em\u003e. Этот метод будет называться \u003ccode\u003esum(double x, double y)\u003c/code\u003e, он будет иметь два вещественных параметра и будет возвращать в качестве результата своей работы сумму чисел \u003ccode\u003ex\u003c/code\u003e и \u003ccode\u003ey\u003c/code\u003e — т. е. вещественное число. Поэтому для метода \u003ccode\u003esum()\u003c/code\u003e мы укажем тип \u003ccode\u003edouble\u003c/code\u003e, а в самом методе нужно будет написать оператор \u003ccode\u003ereturn \u0026lt;имя или значение\u0026gt;\u003c/code\u003e, который, собственно, и вернёт значение из метода (при его вызове). \u003c/p\u003e\u003cp\u003eОтметим, что имена параметров существенны только внутри метода; так что если нам потребовалось бы описать ещё какой-либо метод (даже с параметрами другого типа), мы также могли бы использовать обозначения \u003ccode\u003ex\u003c/code\u003e и \u003ccode\u003ey\u003c/code\u003e. Для описания же метода важно то, какого типа параметры и в каком порядке он эти параметры принимает. Параметры перечисляются через запятую, сначала указывается тип параметра, затем его имя. Список параметров вкупе с именем метода обычно называют \u003cem\u003eсигнатурой метода\u003c/em\u003e. \u003c/p\u003e\u003cp\u003e\u003cem\u003eВ ряде языков, и в Java в том числе, допускается наличие методов с одинаковыми именами, но с существенно различающимися сигнатурами. Например, можно описать метод \u003ccode\u003emeth(String p, int q)\u003c/code\u003e и метод \u003ccode\u003emeth(double p, double q)\u003c/code\u003e одновременно. А вот добавить к ним ещё метод \u003ccode\u003emeth(int p, int q)\u003c/code\u003e уже не выйдет: если мы будем обращаться к методу как \u003ccode\u003emeth(1, 2)\u003c/code\u003e, невозможно однозначно указать, хотим ли мы использовать метод с вещественными или с целыми параметрами. Опять же в дальнейшем мы будем более детально обсуждать этот вопрос. И обратите внимание: в сигнатуру метода \u003cstrong\u003eне входит\u003c/strong\u003e возвращаемый этим методом тип.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eВ методе \u003ccode\u003esum()\u003c/code\u003e мы объявим переменную \u003ccode\u003eres\u003c/code\u003e вещественного типа, поместим в неё сумму \u003ccode\u003ex\u003c/code\u003e и \u003ccode\u003ey\u003c/code\u003e, после чего вернём её значение с помощью \u003ccode\u003ereturn\u003c/code\u003e. У Вас получится следующее:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage first;\n\nimport java.util.Locale;\nimport java.util.Scanner;\n\npublic class AplusB {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass ABSumma {\n\n\tABSumma() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tin.useLocale(Locale.US);\n\t\ta \u003d in.nextDouble();\n\t\tb \u003d in.nextDouble();\n\t\tin.close();\n\t}\n\n\tdouble sum(double x, double y) {\n\t\tdouble res \u003d x + y; \n\t\treturn res;\n\t}\n\n\tdouble a;\n\tdouble b;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e10. Следующим нашим шагом будет написание метода \u003ccode\u003esolve()\u003c/code\u003e: именно он будет отвечать за решение нашей задачи. А результат — сумму чисел — мы поместим в переменную \u003ccode\u003es\u003c/code\u003e вещественного типа. Эту переменную мы также опишем в классе \u003ccode\u003eABSumma\u003c/code\u003e, поскольку планируем ее использовать еще и в другом методе, отвечающем за вывод результата на печать. Поскольку метод \u003ccode\u003esolve()\u003c/code\u003e будет просто обновлять значение переменной \u003ccode\u003es\u003c/code\u003e, он не будет возвращать какого-либо значения и может быть объявлен с типом \u003ccode\u003evoid\u003c/code\u003e (дословно с английского — пустой). Это избавляет нас от необходимости использовать оператор \u003ccode\u003ereturn\u003c/code\u003e для выхода из метода (метод просто выполнится строчка за строчкой и завершит свою работу). \u003c/p\u003e\u003cp\u003e\u003cem\u003eБывают ситуации, в которых есть необходимость использовать оператор \u003ccode\u003ereturn\u003c/code\u003e для выхода из метода, не возвращающего значения. В дальнейшем мы будем обсуждать такие ситуации и писать соответствующие методы.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eКроме того, у метода \u003ccode\u003esolve()\u003c/code\u003e не будет параметров: они попросту не нужны, так как все используемые им переменные являются частью класса \u003ccode\u003eABSumma\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eСобственно, метод \u003ccode\u003esolve()\u003c/code\u003e не будет выполнять какой-то сложной работы: в нашей программе он просто иллюстрирует вызов одного метода внутри другого. Обратите внимание на то, как записывается вызов метода: на место так называемых формальных параметров \u003ccode\u003ex\u003c/code\u003e и \u003ccode\u003ey\u003c/code\u003e подставляются фактические — \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e. Формальные параметры нужны лишь для обозначения тех или иных данных внутри метода: для заголовка метода существенно, сколько параметров принимает метод, какого они типа и в каком порядке записаны. Так что \u003ccode\u003ex\u003c/code\u003e и \u003ccode\u003ey\u003c/code\u003e нужны нам лишь затем, чтобы описать сложение двух вещественных чисел. А вот при вызове вместо \u0026quot;абстрактных\u0026quot; двух вещественных чисел будут использованы значения, записанные в полях \u003ccode\u003ea\u003c/code\u003e и \u003ccode\u003eb\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eТеперь Ваш код должен выглядеть так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage first;\n\nimport java.util.Locale;\nimport java.util.Scanner;\n\npublic class AplusB {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass ABSumma {\n\n\tABsumma() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tin.useLocale(Locale.US);\n\t\ta \u003d in.nextDouble();\n\t\tb \u003d in.nextDouble();\n\t\tin.close();\n\t}\n\n\tdouble sum(double x, double y) {\n\t\tdouble res \u003d x + y; \n\t\treturn res;\n\t}\n\n\tvoid solve() {\t\t\n\t\ts \u003d sum(a, b);\n\t}\n\n\tdouble a;\n\tdouble b;\n\tdouble s;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e11. Теперь напишем метод \u003ccode\u003eprint()\u003c/code\u003e, который будет печатать результат. Этот метод, подобно \u003ccode\u003esolve()\u003c/code\u003e, не будет возвращать никакого значения, поэтому его типом будет \u003ccode\u003evoid\u003c/code\u003e. Для печати мы обратимся к стандартному потоку вывода \u003ccode\u003eSystem.out\u003c/code\u003e (вывод на экран) и его методу \u003ccode\u003eprintln()\u003c/code\u003e (заметим, что метод \u003ccode\u003eprint()\u003c/code\u003e у \u003ccode\u003eSystem.out\u003c/code\u003e (и у других потоков вывода) отличается от метода \u003ccode\u003eprintln()\u003c/code\u003e тем, что не переводит курсор на следующую строку). \u003cbr /\u003e\u003cbr /\u003e У Вас должно получиться следующее:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage first;\n\nimport java.util.Locale;\nimport java.util.Scanner;\n\npublic class AplusB {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n\nclass ABSumma {\n\n\tABSumma() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tin.useLocale(Locale.US);\n\t\ta \u003d in.nextDouble();\n\t\tb \u003d in.nextDouble();\n\t\tin.close();\n\t}\n\n\tdouble sum(double x, double y) {\n\t\tdouble res \u003d x + y; \n\t\treturn res;\n\t}\n\n\tvoid solve() {\t\t\n\t\ts \u003d sum(a, b);\n\t}\n\n\tvoid print() {\n\t\tSystem.out.println(s);\n\t}\n\n\tdouble a;\n\tdouble b;\n\tdouble s;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗаметим, что допустимо было, например, сразу написать \u003ccode\u003eSystem.out.println(sum(a, b))\u003c/code\u003e (и вообще обойтись без метода \u003ccode\u003esolve()\u003c/code\u003e и переменной \u003ccode\u003es\u003c/code\u003e). \u003c/p\u003e\u003cp\u003e12. Последнее, что мы теперь напишем в нашей программе — это собственно код метода \u003ccode\u003emain()\u003c/code\u003e, который и обеспечит работу нашего класса \u003ccode\u003eABSumma\u003c/code\u003e. Фактически, мы должны создать экземпляр класса \u003ccode\u003eABSumma\u003c/code\u003e, после чего вызвать сначала его метода \u003ccode\u003esolve()\u003c/code\u003e, а затем — метод \u003ccode\u003eprint()\u003c/code\u003e. Разумеется, в Ваших приложениях могут быть другие методы, которые также будет необходимо вызвать. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003epackage first;\n\nimport java.util.Locale;\nimport java.util.Scanner;\n\npublic class AplusB {\n\n\tpublic static void main(String[] args) {\n\t\tABSumma absum \u003d new ABSumma();\n\t\tabsum.solve();\n\t\tabsum.print();\n\t}\n\n}\n\nclass ABSumma {\n\n\tABSumma() {\n\t\tScanner in \u003d new Scanner(System.in);\n\t\tin.useLocale(Locale.US);\n\t\ta \u003d in.nextDouble();\n\t\tb \u003d in.nextDouble();\n\t\tin.close();\n\t}\n\n\tdouble sum(double x, double y) {\n\t\tdouble res \u003d x + y; \n\t\treturn res;\n\t}\n\n\tvoid solve() {\t\t\n\t\ts \u003d sum(a, b);\n\t}\n\n\tvoid print() {\n\t\tSystem.out.println(s);\n\t}\n\n\tdouble a;\n\tdouble b;\n\tdouble s;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e13. В меню \u003cem\u003eWindow | Show View\u003c/em\u003e выберите \u003cem\u003eConsole\u003c/em\u003e (внизу будет отображено окно с соответствующим названием). В этом окне Вы будете вводить данные и просматривать полученный результат. \u003cbr /\u003e\u003cbr /\u003e Запустите проект на выполнение (либо кнопка F11 на клавиатуре, либо белая стрелка в зеленом круге на панели инструментов Eclipse). При первом запуске появится окно, в котором будет сообщаться, что некоторые файлы не сохранены. Если Вы поставите галочку в этом окне, файлы всегда будут сохраняться перед запуском. Это стоит сделать :) \u003cbr /\u003e\u003cbr /\u003e Если Вы все сделали правильно, программа внешне себя никак проявлять не будет. Разве что Вы обратите внимание на красный квадратик в окне Console. Введите через пробел два вещественных числа (с разделителем точка), нажмите \u003cem\u003eEnter\u003c/em\u003e и посмотрите на полученный результат. Он должен быть правильным :)\u003c/p\u003e\u003c/div\u003e","tags":["java","eclipse"]}}