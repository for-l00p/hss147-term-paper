{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1477440387,"rating":0,"authorHandle":"fwiefw.a","modificationTimeSeconds":1477440425,"id":47998,"title":"\u003cp\u003eРазбор переборной тренировки\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/group/R55e3SudNH/contest/209421/problem/A\"\u003eЗадача A\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eПереберем день \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e, в который мы продаем бочонок. Если получаемая выгода (равная \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sub\u003e – \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e + 1\u003c/sub\u003e – \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e) превышает текущую максимальную выгоду (которая изначально равна 0 — можно не продавать бочонок), обновим последнюю.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/group/R55e3SudNH/contest/209421/problem/B\"\u003eЗадача B\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eВо-первых, можно было заметить, что нет смысла изменять высоту всех деревьев (всегда можно оставить первому изначальную высоту). Тогда перебирается номер дерева, которое мы не трогаем, а остальные деревья подгоняются под нужную высоту. При таком решении важно было не забыть, что высота дерева не может быть неположительна, и отсекать такие случаи. Время работы этого решения — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eВо-вторых, можно было заметить, что нет смысла увеличивать высоту первого дерева. Тогда можно перебрать все возможные его высоты, асимптотика такого решения — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e·\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eПри ограничениях, данных в задаче, оба решения работают приблизительно одно время.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/group/R55e3SudNH/contest/209421/problem/C\"\u003eЗадача C\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eВсего задач не больше 15, поэтому можно просто перебрать все возможные поднаборы задач и посмотреть, какие из них подходят под требования. \u003c/p\u003e\u003cp\u003eРешение рекурсией выглядит примерно так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ebool selected[n];\nvoid bruteforce(int k) {\n    if(k \u0026lt; n) {\n        selected[k] \u003d 0; \n        bruteforce(k+1); //перебор вариантов, где k-тая задача не взята\n        selected[k] \u003d 1;\n        bruteforce(k+1); //перебор вариантов, где k-тая задача взята\n    } else {\n        //проверяем, подходит ли набор задач под условия\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eВремя работы такого решения — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e·\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e (множитель \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e берется из-за проверки набора задач на соответствие условию).\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/group/R55e3SudNH/contest/209421/problem/D\"\u003eЗадача D\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eКогда \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003edx\u003c/i\u003e| \u0026gt; \u003ci\u003en\u003c/i\u003e – 1\u003c/span\u003e или \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003edy\u003c/i\u003e| \u0026gt; \u003ci\u003en\u003c/i\u003e – 1\u003c/span\u003e, то ход фигуры, как бы она ни стояла, будет вылезать за пределы доски, поэтому такие ходы не имеет смысла рассматривать. Остается \u003cspan class\u003d\"tex-span\"\u003e(2\u003ci\u003en\u003c/i\u003e – 1)\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e возможных ходов, переберем их все.\u003c/p\u003e\u003cp\u003eКогда мы рассматриваем очередной ход, переберем все клетки доски, на которых стоят фигуры. Если соответствующая ходу клетка не вылезает за доску и по условию не должна быть побита, то такого хода фигура делать не может. В противном случае будем считать, что такой ход возможен.\u003c/p\u003e\u003cp\u003eТеперь, после проверки того, какие ходы возможны, осталось посмотреть, не осталось ли на доске непобитых клеток, которые должны быть таковыми. Это можно легко сделать, если отмечать действительно побитые клетки в процессе перебора ходов.\u003c/p\u003e\u003cp\u003eАсимптотика — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/group/R55e3SudNH/contest/209421/problem/E\"\u003eЗадача E\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eЗафиксируем координаты одной точки, переберем все возможные перестановки координат остальных семи. Не нужно писать 7 вложенных циклов, это лучше сделать рекурсией:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;int\u0026gt; x[8];\nvoid bruteforce(int k) { \n    if(k \u0026lt; 8) {\n        do {\n            bruteforce(k+1);\n        } while(next_permutation(x[k].begin(), x[k].end()));\n    } else {\n        //проверям, получился ли куб\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eСодержательная часть задачи — проверка того, что 8 точек образуют куб. Проверить это можно, например, так. Найдем длину ребра куба \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e — наименьшее из попарных расстояний. Тогда все точки должны разбиться на две группы, в каждой из которых все попарные расстояния равны \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/df/67/df67c158a33d9a6efb71123977ae4f0bed4aac54.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (одна из таких групп отмечена на рисунке), то есть каждая из точек должна являться вершиной одного из двух правильных тетраэдров.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/61/8c/618c8c5ea8723de57c38b206844ac7844d3b8d57.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eПосле этого еще нужно убедиться, что тетраэдры расположены друг относительно друга как надо. Один из способов это сделать — проверить, что для каждой вершины одного тетраэдра есть три вершины другого на расстоянии \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eОписанный перебор имеет асимптотику \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a2/9e/a29e3a26d634a23ed6e2077de24d8931cd762428.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e — размерность (в нашем случае 3), а \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e — количество точек (у нас 8). \u003cspan class\u003d\"tex-span\"\u003e(3!)\u003csup class\u003d\"upper-index\"\u003e7\u003c/sup\u003e·8\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e ≈ 2·10\u003csup class\u003d\"upper-index\"\u003e7\u003c/sup\u003e\u003c/span\u003e, так что при аккуратной реализации в TL решение должно влезать.\u003c/p\u003e\u003c/div\u003e","tags":[]}}