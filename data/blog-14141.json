{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1412613079,"rating":5,"authorHandle":"Enchom","modificationTimeSeconds":1412621704,"id":14141,"title":"\u003cp\u003eTraining Contest #1 (Easy) Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003e\u003cstrong\u003eA. Gift for Vanessa\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eЗа изненада задачата се оказа доста по-трудна от колкото очаквах. Цялата идея на задачата беше базирана на \u003ca href\u003d\"http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\"\u003eРешето на Ератостен\u003c/a\u003e. В задачата се иска от начално множество числа да се преброят тройките {a,b,c} такива, че b дели a и c дели b. Използваме следната идея : За всяко число преброяваме делителите му и делимите му измежду останалите числа, използвайки Решето на Ератостен. В началото попълваме масива Exists[], като Exists[i]\u003dtrue ако числото i е измежду началните. В такъв случай следният код смята исканата от нас информация.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (i\u003d1;i\u0026lt;\u003dMAXVAL;i++)\n{\n    for (j\u003di+i;j\u0026lt;\u003dMAXVAL;j+\u003di)\n    {\n        if (Exists[i] \u0026amp;\u0026amp; Exists[j])\n        {    \n            Divisors[j]++;\n            Dividers[i]++;\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eСлед като имаме тази информация, то фиксираме всяко число да е средното измежду тройка числа. Очевидно тройките, в които числото K е средно са Divisors[K]*Dividers[K]. Това ни позволява да сметнем общия брой тройки за линейно време след като имаме сметната информацията.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eАнализ на сложността\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eОчевидно сложността на алгоритъма е доминирана от сложността на Решето на Ератостен. Сега ще покажем сложността на алгоритъма подробно, може да скипнете следващите няколко реда ако искате да видите направо крайната сложност. \u003c/p\u003e\u003cp\u003eНека разгледаме гореописаният код на Решето на Ератостен за MAXVAL\u003dN числа. На i-тата итерация на външния цикъл, вътрешния изпълнява \u003cstrong\u003eN/i\u003c/strong\u003e итерации. Следователно общата сложност на алгоритъма е (допускайки, че N клони към безкрайност)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e(N/1)+(N/2)+(N/3)+...+(N/N) \u003d N * (1/1+1/2+1/3+...+1/N) \u003d N * \u003ca href\u003d\"http://en.wikipedia.org/wiki/Harmonic_number\"\u003eHn\u003c/a\u003e \u003d N * (\u003ca href\u003d\"http://en.wikipedia.org/wiki/Natural_logarithm\"\u003eln N\u003c/a\u003e — \u003ca href\u003d\"http://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant\"\u003eγ\u003c/a\u003e) \u003d O(N ln N) \u003d O(N log N)\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eСледователно сложността на цялото ни решение е \u003cstrong\u003eO(MaxVal log MaxVal + N)\u003c/strong\u003e\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003eB. Gift for Karev\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eТова бе по лесната задача в темата. Лесно се забелязва метода на динамичното оптимиране. Лесен стейт, който можем да измислим е F[i][j] — колко редици с дължина i и последно число j има. Лесно се вижда как се попълва динамичното :\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eif (j!\u003d0)\nF[i][j]\u003dF[i-1][j-1]\nelse\nF[i][j]\u003dF[i-1][0]+F[i-1][1]+F[i-1][2]+...F[i-1][k-1]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТова решение е O(N^2). За да решим цялата задача трябва да забележим, че щом F[i][j]\u003dF[i-1][j-1], то имаме невероятно много стейтове с еднакви стойности.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eF[i][j]\u003dF[i-1][j-1]\u003dF[i-2][j-2]\u003d...\u003dF[i-j][0]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОт това следва\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eF[i][0]\u003dF[i-1][0]+F[i-2][0]+F[i-3][0]+F[i-k][0]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eСледователно можем да премахнем вторият стейт и да пресмятаме динамичното \u003c/p\u003e \u003cpre\u003e\u003ccode\u003eF[i]\u003dF[i-1]+F[i-2]+F[i-3]...F[i-k]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eОтговорът на задачата е в F[n+1]. За да пресмятаме стейтовете ефективно можем да поддържаме префиксни суми.\u003c/p\u003e\u003c/div\u003e","tags":[]}}