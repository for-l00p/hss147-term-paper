{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1459864427,"rating":0,"authorHandle":"zscoder","modificationTimeSeconds":1460040917,"id":44197,"title":"\u003cp\u003eMock MCO Contest Brief Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003eProblem A. Congkak\u003c/h2\u003e\u003ch3\u003eEasy\u003c/h3\u003e\u003cp\u003eThe constraints are small, so just simulating the process could pass this subtask.\u003c/p\u003e\u003ch3\u003eMedium\u003c/h3\u003e\u003cp\u003eWe keep track of the number of balls in each hole. For each move, note that by taking \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e balls we\u0027re going through the circles \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d4/36/d4366fbd5e0b486c7ea5876373c57c9764e4b7fa.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e times and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/68/22/6822c41bcb2306df2549347e41059d2e69930526.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e more steps. Thus, we can update the number of balls in each hole in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. Doing this for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e moves gives an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enk\u003c/i\u003e)\u003c/span\u003e solution.\u003c/p\u003e\u003ch3\u003eHard\u003c/h3\u003e\u003cp\u003eFor this subtask, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e can go up to a million, so the solution from the last subtask is clearly too slow. The key is to note that for every move, we\u0027re doing a range increment on the number of balls in each hole. Combining with the observation in the previous paragraph, we can construct a Fenwick Tree that holds the values of the number of balls in each hole, and for each move we do a suitable range update on the Fenwick Tree. Finally, to get the number of balls in a hole, we query the Fenwick Tree. Time Complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5e/03/5e0371fd1829a31a99af4a455770cf5aeeac5e05.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003ch2\u003eProblem B. Maze\u003c/h2\u003e\u003ch3\u003eEasy\u003c/h3\u003e\u003cp\u003eSince the digits are either \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, the cost of moving between same digits is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. Thus, the only thing we need to worry about is whether the endpoint can be reached. We can model the grid as a graph with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003erc\u003c/i\u003e\u003c/span\u003e vertices. Connect two vertices if and only if you can get from one to the other directly. (i.e. none of them should contain the digit 0 and both tiles should be adjacent) Finally, run a BFS (or even DFS) on the graph starting from the starting point to see if the ending point is reachable. If it\u0027s reachable, output \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. Else, output \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003eMedium\u003c/h3\u003e\u003cp\u003eThis time, there might be a cost by moving from one vertex to the other. Thus, we add weights to each edge. The weight is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e if the digits in the corresponding cells are distinct and \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e otherwise. (Note that if one of the cells contains the digit \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e the edge should not exist) Then, run Dijkstra\u0027s algorithm on the resulting graph.\u003c/p\u003e\u003ch3\u003eHard\u003c/h3\u003e\u003cp\u003eWe will use BFS. However, if the edge has weight \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, instead of pushing the neighbouring vertex (with distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e) into the back of the queue, we push it to the front of the queue, so it gets processed before the vertices that are of distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e + 1\u003c/span\u003e. It is easy to see that this works by the properties of BFS. Now, we still need to insert vertices in front of the queue. To do this, we use C++ STL deque, instead of the usual queue.\u003c/p\u003e\u003ch2\u003eProblem C. Test Data\u003c/h2\u003e\u003ch3\u003eEasy\u003c/h3\u003e\u003cp\u003eWe have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 0\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 1\u003c/span\u003e for this subtask. This is a giveaway subtask. If the prefix string already has the desired answer, just output the prefix string. Otherwise, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 0\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, then we have no solutions, since appending any more characters results in the same answer. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 1\u003c/span\u003e for some \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, then we keep append letter \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e until the resulting string has the desired value. \u003c/p\u003e\u003ch3\u003eMedium\u003c/h3\u003e\u003cp\u003eThis time, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is equal for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Now, for this subtask, no matter which letter we append, the answer is still the same. So, we just need to know the number of letters required. Suppose we have a string of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. Then, the value of the string will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e(\u003ci\u003ek\u003c/i\u003e - 1)\u003c/span\u003e. Note that the value is the same modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is replaced with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e\u003c/span\u003e. Thus, we just need to keep appending a character to the string and stop when we have appended \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e letters or we have reached our desired answer. If after appending \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e characters the value is never the desired answer, output \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003eHard\u003c/h3\u003e\u003cp\u003eConstruct a graph where the vertices are \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is one of the \u003cspan class\u003d\"tex-span\"\u003e26\u003c/span\u003e letters and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e is one of the possible remainders modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e. Then, calculate the result from the given prefix. Start from the appropriate vertex. Connect two edges \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ec\u003c/i\u003e, \u003ci\u003ed\u003c/i\u003e)\u003c/span\u003e if by appending letter \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e you change the value from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e. Then, run a BFS on the graph and keep track of the vertices encountered. Time complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eM\u003c/i\u003e(26)\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch2\u003eProblem D. Beautiful Subarrays\u003c/h2\u003e\u003ch3\u003eEasy\u003c/h3\u003e\u003cp\u003eSince \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≤ 100\u003c/span\u003e, we can iterate through all possible ranges. For each possible range, we xor all the numbers in range, and increment the counter if the resulting value is at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. Time complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003eMedium\u003c/h3\u003e\u003cp\u003eNow, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≤ 3000\u003c/span\u003e. We precompute the prefix xors of the array, i.e. \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ce/9e/ce9e8d2fdb6d31aaf48fe08ed7ed93416190d18d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e)\u003c/span\u003e be the xor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e + 1\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Then, note that since \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/33/d2/33d28bfebacbb85c8a67f3978fbc1eea016b6faf.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, we have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/81/1e/811ed960b6c16d71615f0d0e4ac9bc069f527c15.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3c/29/3c29fbe467ae38e1053e66026f9bb0a991dc9d93.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. So, we iterate through all possible ranges, but this time we can compute the xor of all elements in range in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e. Thus, the complexity reduces to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003eHard\u003c/h3\u003e\u003cp\u003eNow, we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e. Clearly, an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e solution will TLE. The idea is to iterate through the ranges \u0026quot;from left to right\u0026quot;. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eX\u003c/i\u003e(1, \u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e. Then, we start from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e. We go from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. When we\u0027re at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, we find the number of prefix xors \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e such that \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/19/88/198828dcc1a8ba411d7a1d80d47fb3b29c320bd5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. We can look at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e bit-by-bit in its binary representation, and find whether the corresponding bit of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e must be \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e (or both) to satisfy \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/19/88/198828dcc1a8ba411d7a1d80d47fb3b29c320bd5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e \u0026lt; \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. We can do this by storing all the iterated prefixes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e into a data structure like trie. Every time we insert a new prefix, we go through the tree, and head to the right if the corresponding bit is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, and left if the corresponding bit is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, then we go to the next bit of the number, until we reach an empty node (in which case we create a new node) or a leaf. For each node we keep track of the number of inserted numbers that go through the part of the trie from root to that node. Now, each query can now be interpreted as a root-to-leaf scan. If the corresponding bit of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, it means that every children of the (if the current bit of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, then it\u0027s the left, otherwise it\u0027s the right) children can be taken, so we add the value stored at the node as the answer, and move down to the other children, until we hit a leaf. Similarly for when the bit of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, except you don\u0027t add the answer for the other child, and immediately move down the trie. Overall, the time complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f6/66/f666017684a4eeedf0dd3cf6711315062a6e869e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003ch2\u003eProblem E. Magic Cups\u003c/h2\u003e\u003ch3\u003eEasy\u003c/h3\u003e\u003cp\u003eThe constraints are small. This means that naively simulating the operations can pass this subtask, as it takes only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNQ\u003c/i\u003e)\u003c/span\u003e time.\u003c/p\u003e\u003ch3\u003eMedium\u003c/h3\u003e\u003cp\u003e(Apparently for some reason that I can\u0027t explain, naively simulating the operations can pass this subtask even with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e, \u003ci\u003eQ\u003c/i\u003e ≤ 10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e, even with the worst possible test case. I have no idea why those solutions wouldn\u0027t TLE, even after setting all queries as \u003cspan class\u003d\"tex-span\"\u003e[1, \u003ci\u003en\u003c/i\u003e]\u003c/span\u003e. Below is the intended solution.)\u003c/p\u003e\u003cp\u003eNote that we only have query of the second type. How do we answer them effectively. Each query is effectively querying the sum of all numbers that are at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in a range \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e. We can\u0027t do dp, because there are too many possible \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is too large. To solve this, we use Mo\u0027s algorithm (or sqrt decomposition on the queries). We store a Fenwick Tree that supports range update and for each query for element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, it returns the sum of the current elements that are \u003cspan class\u003d\"tex-span\"\u003e ≤ \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Then, inserting and removing an element for Mo\u0027s algorithm is just updating the Fenwick Tree and answering the query is just querying the Fenwick Tree at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. Time Complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8a/c8/8ac8add38cf8d78d1f3c42d5f668d0dee99e9d42.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003ch3\u003eHard\u003c/h3\u003e\u003cp\u003eNow, we have to answer the queries online. We will use sqrt decomposition again, not on the queries, but on the elements of the array itself. Divide the array into blocks of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4e/5c/4e5c9f371024ad4e1f5b0f2dfeb967ffe7cb5f4e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. For each block store a Fenwick Tree just like the previous subtask. In addition, store a counter \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e. For each update on \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e, if we go from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e. If we\u0027re in the middle of a block, we just update the elements of the block naively (and updating the values in the corresponding Fenwick). When we encounter a complete block, instead of iterating over the entire block, we increment the counter \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e (modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e, of course). Now, for each query, we iterate through the blocks again. If we\u0027re in the middle of a block, we add the values accordingly. If we\u0027re in an entire block, instead of finding the sum of elements from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, we need to find the sum of elements from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e + 1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e + \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e (modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e). This can be done using our Fenwick Tree. \u003c/p\u003e\u003cp\u003eWhat should our Fenwick Tree store? Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e be the number of times \u003cspan class\u003d\"tex-span\"\u003e1, 2, ..., \u003ci\u003eM\u003c/i\u003e\u003c/span\u003e occured in the blocked. Then, the each bsae element of the Fenwick should be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ... + \u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Then, it can be proved that each desired query can be reduced to the sums and differences of the query results of the tree. Details are omitted.\u003c/p\u003e\u003cp\u003eOverall, the time complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1d/a8/1da8242ad35b3216a5b2fa3f022140dd16f8d097.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch2\u003eProblem F. Divisor Tree — Revisited\u003c/h2\u003e\u003ch3\u003eEasy\u003c/h3\u003e\u003cp\u003eSince the constraints are so small, for each update just update the corresponding node and for each query do some sort of dp with dfs starting from one end of the query to the other. Time Complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eQn\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003eMedium\u003c/h3\u003e\u003cp\u003eSince there are only queries of type \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e, we only need to worry about our original tree. To answer the query, we first do a root-to-leaf dp of the tree storing the powers of \u003cspan class\u003d\"tex-span\"\u003e2, 3, 5, 7\u003c/span\u003e in the prime factorization of the current number. Then, for each query, the path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is just the path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLCA\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLCA\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLCA\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e is the lower common ancestor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. The answer to each of these paths can be calculated using the dp values obtained and the query can be answered in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e or \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e with Sparse Table LCA. The total time complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6c/a2/6ca26c32eeafdfd4cf35ca439db2e4b329ccc1d5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e or \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/90/99/909912bcd432c09a16832f042812268055a7fcab.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e depending on implementation.\u003c/p\u003e\u003ch3\u003eHard\u003c/h3\u003e\u003cp\u003eNow, we need to answer the queries online. Consider the heavy-light decomposition of the graph. For each chain, we store a segment tree, that can support single element update and range query (in this case we use sum). For each node, store \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e5\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e7\u003c/sub\u003e)\u003c/span\u003e, the exponents of \u003cspan class\u003d\"tex-span\"\u003e2, 3, 5, 7\u003c/span\u003e in the current number respectively. (Note that there will not be other prime factors since we limit the weights and updates to single digits only). Using Heavy-Light Decomposition, we can easily answer the queries by considering each separate chain and combine the answers. The complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/59/c4/59c494adbef79bd9fe3847f942df4710e03ae071.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eTop Scorers :\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003e\u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/phobos\" title\u003d\"Candidate Master phobos\"\u003ephobos\u003c/a\u003e 100-100-100-35-0-40 \u003d 375\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/computer_\" title\u003d\"Specialist computer_\"\u003ecomputer_\u003c/a\u003e 100-100-0-0-0-0 \u003d 200\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003ca class\u003d\"rated-user user-green\" href\u003d\"/profile/hahaXD\" title\u003d\"Pupil hahaXD\"\u003ehahaXD\u003c/a\u003e 30-100-15-35-20-0 \u003d 200\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003c/div\u003e","tags":[]}}