{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1507064883,"rating":3,"authorHandle":"mohamedeltair","modificationTimeSeconds":1507064883,"id":54940,"title":"\u003cp\u003eSum of numbers less/greater than x in a given interval (l,r) with update operations ?\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eAs the title says, there are these two types of queries. number of values (n) \u0026lt;\u003d 100000 and number of queries \u0026lt;\u003d 200000, the solution that came to my mind is using a segment tree, where each node of the segment tree is an AVL tree that stores the elements of the segment tree node interval in ascending order, and each node of any AVL tree will store the sum of elements of the subtree rooted at this node.\u003c/p\u003e\u003cp\u003eSo if I need to update an element (write a new value to it), I go to the segment tree nodes whose intervals contain the position of the element (log(n) nodes) and update the AVL tree of each of these nodes (each update is log(n)), so in total (log(n))^2.\u003c/p\u003e\u003cp\u003eAnd if I want sum of numbers less than x in interval l to r, I do a query operation so that when the segment tree node is totally inside l to r, I use the AVL tree of this node to get sum of elements less than x in log(n) complexity, and the higher level segment tree nodes will return the summation of these lower level segment tree nodes\u0027 sums (so in total (log(n))^2).\u003c/p\u003e\u003cp\u003eIf number of queries/updates is Q, their complexity becomes Q*(log(n))^2. am I walking in the right path or is there something wrong in this approach ?\u003c/p\u003e\u003c/div\u003e","tags":[]}}