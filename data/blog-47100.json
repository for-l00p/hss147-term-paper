{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1473824920,"rating":9,"authorHandle":"tsaebeht","modificationTimeSeconds":1473825000,"id":47100,"title":"\u003cp\u003euse of trie to count number of inversions\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define MAX_NUMBER_OF_NODES 10000000\n#define endl \u0027\\n\u0027\n#define f0(i, n) for(int i\u003d0; i\u0026lt;n; i++)\ntypedef long long int ll;\n\nll trie[MAX_NUMBER_OF_NODES][2]\u003d{0};\nll store[MAX_NUMBER_OF_NODES][2]\u003d{0};\nll nxt \u003d 1;\nll count1\u003d0;\n// Each row represents a node\n// Numbers in that row represent the nxt node to which it is connected\n// That number will be our nxt row\n\nvoid insrt(int n) {\n\tll t \u003d 1;\n\tint z\u003d31;\n\tfor(int i \u003d 0; i \u0026lt; 32; i++) {\n\t\tint p \u003d ((1\u0026lt;\u0026lt;z)\u0026amp;n)?1:0;\n\t\t//cout\u0026lt;\u0026lt;p;\n\t\tz--;\n\t\tstore[t][p]++;\n\t\t//cout\u0026lt;\u0026lt;store[t][p]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\n\t\tif(trie[t][p] \u003d\u003d 0) {\n\t\t\tnxt++;\n\t\t\ttrie[t][p] \u003d nxt;\n\t\t} \n\t\tif(p\u003d\u003d0) {\n\t\t\tcount1 +\u003d store[t][1];\n\t\t}\n\t\tt \u003d trie[t][p];\n\t}\n}\n\nint main () {\n\tint t;\n\tcin\u0026gt;\u0026gt;t;\n\twhile(t--) {\n\t\tfor(int i\u003d0; i\u0026lt;\u003dnxt; i++) {\n\t\t\ttrie[i][0]\u003d0;\n\t\t\ttrie[i][1]\u003d0;\n\t\t\tstore[i][0]\u003d0;\n\t\t\tstore[i][1]\u003d0;\n\t\t}\n\t\tnxt\u003d1;\n\t\tcount1\u003d0;\n\t\tint n;\n\t\tcin\u0026gt;\u0026gt;n;\n\t\tint a[n];\n\t\tf0(i, n) { \n\t\t\tcin\u0026gt;\u0026gt;a[i];\n\t\t\tinsrt(a[i]);\n\t\t}\n\t\t//f0(i, 6) insrt (a[i]);\n\t\tcout\u0026lt;\u0026lt;count1\u0026lt;\u0026lt;endl;\t\n\t}\n\t\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e// the following code is a solutoin the problem INVCNT on spoj. // the basic idea is to maintain a trie with count of each node in the trie. // for inversions if we have a 1 at current node then we are sure that the number(which we are inserting //currently) is greater than the other already inserted numbers which have the same prefix as the current //number upto the current node but have 0 at current node. we maintain a count of such nodes or numbers.\u003c/p\u003e\u003c/div\u003e","tags":["tries","trie","inversions"]}}