{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1499770109,"rating":0,"authorHandle":"Nicksechko","modificationTimeSeconds":1499778154,"id":53230,"title":"\u003cp\u003eЛикБез№4: Разбор задач\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003e\u003ca href\u003d\"//codeforces.com/group/JQLXw0DLrR/contest/214566/problem/A\"\u003eЗадача A: Помощь маме.\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eЭто простая задача на дих. Для тех кто не совсем уверен в том что он правильно напишет можно было искать в векторе с помощью lower_bound(int (lower_bound(a.begin(), a.end(), x) — a.begin())). И еще для гарантии посмотреть 10 соседних элементов, что бы уже наверняка.\u003c/p\u003e\u003cp\u003eАсимптотика \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e * \u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e на сортировку и дих, 2 в константу.\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"//codeforces.com/group/JQLXw0DLrR/contest/214566/problem/B\"\u003eЗадача B: Моряк в магазине.\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eВ это задаче мы бы хотели вам показать сортировку подсчётом(когда вы просто считаете сколько какого элемента). Но оказалось что и дих проходит. Тогда мы решили усложнить задачу добавив массив префикс сумм, который вам необходим для ответов на запрос. Так же можно решать с помощью сортировки и диха по границам, но тогда надо будет писать аккуратно и всячески ускорять, то есть геморойно.\u003c/p\u003e\u003cp\u003eАсимптотика \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e. Так как все действия линейны.\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"//codeforces.com/group/JQLXw0DLrR/contest/214566/problem/C\"\u003eЗадача C: Banking Mania.\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eЭто несложная безыдейная задача на реализацию. Надо сделать прям то, что написано в условии. Тут есть много решений. Авторское решение подразумевало создать структуру из чисел и написать к ней компаратор. А также не забыть про ведущие нули. Хотя есть более простые решения, тот кто разбираются в строках, мог создать структуру строк и, зная что строки тоже можно сравнивать, и они сравниваются хорошо, написать компаратор, и не заморачиваться в ведущими нулями, ведь в строках они сохраняются. А те кому лень писать компаратор и не лень написать pair\u0026lt;pair\u0026lt;pair\u0026lt;pair\u0026lt;...(ведь для пар в системе уже написаны компараторы) могли и так сделать.\u003c/p\u003e\u003cp\u003eАсимптотика \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e * \u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e на сортировку.\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"//codeforces.com/group/JQLXw0DLrR/contest/214566/problem/D\"\u003eЗадача D: Are You Ready???\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eЭта задача очень-очень полезна, ведь в ней используются такие очень важные штуки, которые очень часто вам будут вам встречаться, как бинарный поиск по ответу и метод двух указателей. Поэтому и разбор достаточно подробный.\u003c/p\u003e\u003cp\u003eПри решении этой задачи полезно сначала научится решать следующую задачу: по известному максимальному числу дисбаланса необходимо определить, сколько отрядов можно сформировать с таким ограничением. \u003c/p\u003e\u003cp\u003eЭта задача решается следующим образом: отсортируем массив по неубыванию элементов. Для удобства назовём этот массив \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e. Солдатов в отряды будем набирать с использованием жадного алгоритма, т.е. если человека можно записать в отряд, то будем записывать его в эту отряд. Несложно показать, что пропуск какого-либо человека и замена его более высоким никогда не улучшит решение (но может ухудшить).\u003c/p\u003e\u003cp\u003eВоспользуемся методом двух указателей. Введём два указателя \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eend\u003c/i\u003e\u003c/span\u003e (это указатели на элементы отсортированного массива -- обыкновенные целые числа, индексы элементов), которые будут указывать на самого слабого и самого сильного солдата в формируемом отряде. Вначале, указатели \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eend\u003c/i\u003e\u003c/span\u003e указывают на человека с номером \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Если разница сил следующего человека (с номером \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eend\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e + \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e) и первого человека в формируемом отряде не превышает максимального допустимого числа неудобства -- добавляем солдата с этим номером в отряд (т.е. увеличиваем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eend\u003c/i\u003e\u003c/span\u003e на \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e). Если же разница роста превысила максимально допустимое значение дисбаланса -- будем увеличивать номер самого слабого солдата в отряде на \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e до тех пор, пока \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eend\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e - \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e превышает максимальное число дисбаланса. Если в какой-то момент при выполнении этих операций количество солдат в формируемом отряде стало равно \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e (количество солдат в укомплектованном отряде), то увеличиваем счётчик сформированных отрядов на \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e и продолжаем формирование отрядов со следующего человека (т.е. присваиваем переменным \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estart\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eend\u003c/i\u003e\u003c/span\u003e значение \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eend\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e + \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e). Такая функция за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e(ведь каждый указатель сдвинется не более \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e раз) операций сможет подсчитать количество отрядов, которые можно сформировать при заданном максимальном числе дисбаланса.\u003c/p\u003e\u003cp\u003eДля решения задачи осталось написать всего лишь несколько строк -- реализацию бинарного поиска по ответу. Суть его заключается в следующем: обозначим за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eleft\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eright\u003c/i\u003e\u003c/span\u003e границы области поиска ответа (максимального числа дисбаланса). В начале \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eleft\u003c/i\u003e\u003c/span\u003e равно \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e (это нужно для случая, когда все солдаты имеют одинаковую силу), а \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eright\u003c/i\u003e\u003c/span\u003e -- силе самого сильного солдата минус сила самого слабого солдата (обозначим его за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, такая граница нужна в случае, если необходимо отправить всех солдатов в одну отряд).\u003c/p\u003e\u003cp\u003eВозьмём среднее значение между \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eleft\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eright\u003c/i\u003e\u003c/span\u003e: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e \u003d \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eleft\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e + \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eright\u003c/i\u003e) / 2\u003c/span\u003e. Подсчитаем количество отрядов, которое можно сформировать с максимальным числом дисбаланса, равным \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e\u003c/span\u003e. Если количество бригад оказалось меньше, чем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e, то, логично, что при меньшем числе неудобства бригад получится ещё меньше и искать стоит только между числами \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e + \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eright\u003c/i\u003e\u003c/span\u003e. Т.е. левую границу поиска необходимо заменить на число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e + \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. В противном случае (если число сформированных бригад оказалось больше либо равным \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e) заменяем правую границу поиска на \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emid\u003c/i\u003e\u003c/span\u003e. Повторять эти действия необходимо до тех пор, пока \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eleft\u003c/i\u003e\u003c/span\u003e не станет равным \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eright\u003c/i\u003e\u003c/span\u003e (т.е. наш поиск сойдётся на одном числе). Это число и является ответов на задачу. Общая сложность алгоритма составит \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e * \u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e + \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e * \u003ci\u003elogb\u003c/i\u003e)\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e — разница сил между самым сильным и самым слабым солдатом.\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"//codeforces.com/group/JQLXw0DLrR/contest/214566/problem/E\"\u003eЗадача E: Pinohol.\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eДля того, чтобы решить данную задачу, нужно понять, что эта формула нужна чтобы вас запутать.\u003c/p\u003e\u003cp\u003eДавайте перепишем её:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e * \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e4\u003c/sub\u003e * (\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e6\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e5\u003c/sub\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003eЯ думаю никто не будет отрицать, что эта та же самая формула.\u003c/p\u003e\u003cp\u003eТеперь решить задачу довольно просто. Давайте предпросчитаем все возможные значения правой части, запишем их в массив и отсортируем его. Давайте переберём все возможные значения левой части(пусть на каком то шаге оно равно \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e), и для каждого значения \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e найдём в нашем массиве при помощи бинарного поиска количество элементов равных \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Это сделать тоже несложно, это количество элементов \u003cspan class\u003d\"tex-span\"\u003e \u0026gt; \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e минус количество элементов \u003cspan class\u003d\"tex-span\"\u003e \u0026gt;  \u003d \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e (upper_bound — lower_bound), и добавить это количество к ответу. Ну тот, кто такой крутой, и умеет пользоваться Map или Set могли воспользоваться ими, но бинарный поиск работает быстрее, но асимптотика всё равно остаётся \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e * \u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"//codeforces.com/group/JQLXw0DLrR/contest/214566/problem/F\"\u003eЗадача F: AfterParty.\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eЭта задача на довольно специфический и не очень приятный на C++ вещественный бинарный поиск по ответу. Почему он специфический и не очень приятный именно на C++, потому что вещественный тип данных C++, реализован не самым лучшим образом, и очень часто возникают различного рода проблемы, в которых виновато не ваше решение, поэтому к таким вещам надо относиться очень аккуратно. \u003c/p\u003e\u003cp\u003eНо идея решения довольно проста, давайте бинарным поиском по ответу переберём уровень воды в ответе. А теперь пройдёмся по всем сосудам, посчитаем какой объём воды будет в каждом при таком уровне воды и просуммируем, если суммарный объём меньше чем число \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003c/span\u003e, то сдвигаем левую границу, а иначе правую. Выводим ответ с заданной точностью. Вся сложность это задачи, это умение аккуратно работать с вещественным типом данных. Асимптотика решения \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e * \u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"//codeforces.com/group/JQLXw0DLrR/contest/214566/problem/N\"\u003eЗадача N: Amruash.\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eЭто очень идейная задача на умение пихать задачи в ТЛ.\u003c/p\u003e\u003cp\u003eРассмотрим какой-то единичный бит в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e. Если соответствующий бит в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e равен \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e, то мы можем их поменять местами, уменьшив \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e и увеличив \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e. При этом их сумма и xor не изменятся. Отсюда можно сделать вывод, что если какой-то бит равен единице в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e то он будет равен единице и в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e. Отсюда \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e  \u003d \u003ci\u003eX\u003c/i\u003e  +  \u003ci\u003eB\u003c/i\u003e\u003c/span\u003e. Учитывая, что \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e  +  \u003ci\u003eY\u003c/i\u003e  \u003d  \u003ci\u003eX\u003c/i\u003e  +  \u003ci\u003eX\u003c/i\u003e  +  \u003ci\u003eB\u003c/i\u003e  \u003d  \u003ci\u003eA\u003c/i\u003e\u003c/span\u003e,  получаем следующие формулы для нахождения \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e  \u003d  (\u003ci\u003eA\u003c/i\u003e  -  \u003ci\u003eB\u003c/i\u003e)  /  2\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e  \u003d  \u003ci\u003eX\u003c/i\u003e  +  \u003ci\u003eB\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eСледует также учесть, что если выполняется хотя бы один из следующих пунктов:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e  \u0026lt;  \u003ci\u003eB\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e имеют разную четность\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eXand\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e  -  \u003ci\u003eX\u003c/i\u003e) ≠ \u003ci\u003eX\u003c/i\u003e\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eand\u003c/i\u003e\u003c/span\u003e — побитовое \u0026quot;и\u0026quot;\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eто ответа не существует и следует вывести -1.\u003c/p\u003e\u003cp\u003eНо без ускорения это получает только 80 баллов. Чтобы получить 100 надо было ещё ускорить ввод-вывод при помощи scanf и printf, и отсылать не на компиляторе C++14. Почему это ускоряет работу программы которая должна считать много данных. Ответ: просто scanf И printf читают данные быстрее, чем cin и cout где-то в \u003cspan class\u003d\"tex-span\"\u003e1.5\u003c/span\u003e раза, ведь они заранее знают какой тип данный им надо считать, а cin и cout ещё тратят время на его определение. Но это так не работает на C++14, там cin и cout быстрее, чем scanf и printf, я не знаю почему, но printf и scanf на C++ или C++11, всё равно быстрее cin и cout в C++14. \u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"//codeforces.com/group/JQLXw0DLrR/contest/214566/problem/R\"\u003eЗадача R: Каникулы моряка.\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eВ этой задаче необходимо только пояснить условие, но это я сделаю позже, пока постарайтесь найти все 3 намёка на то что требуется в задаче(возможно хватит 1, а дальше на скиле). Где то во второй половине задачи есть фраза \u0026quot;Но в прочем это не важно\u0026quot;, после нее начинается \u0026quot;условие\u0026quot; задачи. Это остаётся вам в качестве челенджа. Если никто не решит, то 1 августа мы расскажем решение и все намёки на него.\u003c/p\u003e\u003c/div\u003e","tags":[]}}