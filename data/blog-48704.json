{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1480431959,"rating":16,"authorHandle":"mjhun","modificationTimeSeconds":1480438319,"id":48704,"title":"\u003cp\u003eIs floating point arithmetic deterministic?\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA couple of days ago, I was trying to solve \u003ca href\u003d\"/contest/739/problem/E\" title\u003d\"Codeforces Round 381 (Div. 1)\"\u003e739E - Gosha is hunting\u003c/a\u003e. My approach was similar than that of the \u003ca href\u003d\"//codeforces.com/blog/entry/48582\"\u003eeditorial\u003c/a\u003e . My first submission (\u003ca href\u003d\"/contest/739/submission/22589895\" title\u003d\"Submission 22589895 by mjhun\"\u003e22589895\u003c/a\u003e) gave WA. After a while struggling to find what was wrong, I looked the case that was failing. I tested it on my computer but it gave the right answer!\u003c/p\u003e\u003cp\u003eAfter some debugging in Ideone (which gave the same answer as Codeforces), I realized that the problem was this: Somewhere in my code I insert into a set a \u003ccode\u003epair\u0026lt;double,int\u0026gt;\u003c/code\u003e , where the double is the result of some operation (line 35).\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eca.insert(mp((1-p[j].snd)*p[j].fst,j));\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDuring execution I may move that pair to another set called \u003ccode\u003ewa\u003c/code\u003e, and somewhere else I erase some value from one of these sets (lines 62-68).\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eif(wa.count(mp((1-p[j].snd)*p[j].fst,j))){\n\t...\n\twa.erase(mp((1-p[j].snd)*p[j].fst,j));\n}\nelse {\n\tca.erase(mp((1-p[j].snd)*p[j].fst,j));\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhat was happening is that it wasn\u0027t erasing when it should. Then I created an auxiliary \u003ccode\u003edouble\u003c/code\u003e array \u003ccode\u003ekk\u003c/code\u003e, where I store the value before inserting it into the set, and from which I read when I want to erase it from the set. This solved the problem (submission \u003ca href\u003d\"/contest/739/submission/22590238\" title\u003d\"Submission 22590238 by mjhun\"\u003e22590238\u003c/a\u003e: AC).\u003c/p\u003e\u003cp\u003eSo, the thing is: The operation \u003ccode\u003e(1-p[j].snd)*p[j].fst\u003c/code\u003e wasn\u0027t giving the same result as before, even though it\u0027s done with the exact same values and the exact same order than before. Just to be sure, I did another submission, which (before erasing from the set) asserted that the computed value is exactly the value stored in the auxiliary array (submission \u003ca href\u003d\"/contest/739/submission/22601078\" title\u003d\"Submission 22601078 by mjhun\"\u003e22601078\u003c/a\u003e: RTE, so: the assertion failed).\u003c/p\u003e\u003cp\u003eI thought that floating point operations are supposed to be deterministic (they should give the same result, given that they are made with the same values, in the same order and on the same platform), as they were on my computer.\u003c/p\u003e\u003cp\u003eIt may be that I\u0027m mistaken, that there is some other error in my code which I didn\u0027t realize, or that there is some problem with the compiler (maybe an optimization bug). I thought that probably someone here could help me understand what is going on.\u003c/p\u003e\u003c/div\u003e","tags":["floating-point"]}}