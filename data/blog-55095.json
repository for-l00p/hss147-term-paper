{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1507558285,"rating":-5,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1507558563,"id":55095,"title":"\u003cp\u003eNotes on Codeforces Beta Round #82, A, B, C, D\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/106/problem/A\" title\u003d\"Codeforces Beta Round 82 (Div. 2)\"\u003e106A - Card Game\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAs the problem requires, we first check the suits of the given two cards. If they have the same suit, then we compare their ranks; otherwise we check whether the first card is the the trump card or not.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/106/problem/B\" title\u003d\"Codeforces Beta Round 82 (Div. 2)\"\u003e106B - Choosing Laptop\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe can adopt a double loop to eliminate all the outdated laptops. Next, we find the cheapest one as the answer.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/106/problem/C\" title\u003d\"Codeforces Beta Round 82 (Div. 2)\"\u003e106C - Buns\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAt first, I tried to solve it based on greedy algorithm. However, it turns out that such a greedy algorithm fails since all the involved numbers are integers...\u003c/p\u003e\u003cp\u003eWell, this is essentially a backpack problem, if we implement some equivalent transformation. More specifically, it is a multiple-backpack problem, one can also check the one in \u003ca href\u003d\"/contest/95/problem/E\" title\u003d\"Codeforces Beta Round 77 (Div. 1 Only)\"\u003e95E - Lucky Country\u003c/a\u003e, which is also solved based on multiple-backpack.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/106/problem/D\" title\u003d\"Codeforces Beta Round 82 (Div. 2)\"\u003e106D - Treasure Island\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe solution is straightforward implementation. However, trivial implementation ends up with TLE. To avoid this, for each position, we should calculate in previous the farthest position that we can reach when we move to any one of the four directions. This can be computed by using DP algorithm with complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003emn\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e","tags":[]}}