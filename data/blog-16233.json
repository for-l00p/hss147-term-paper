{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1423156182,"rating":8,"authorHandle":"magieNoire","modificationTimeSeconds":1423308944,"id":16233,"title":"\u003cp\u003eWeekly training #1: Data strucures (Summary)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi everyone, that was a very short week (time fly as they say). Today, was the end of the first training. I hope that everyone enjoyed this long contest, and has learnt from it. We will give you free days until next week, time to prepare for the next round (DP), discuss problems (here), and internalise what you have learnt.\u003c/p\u003e\u003cp\u003eYour feedback is also as important as your participation. I am open to all suggestions. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eD-Query:\u003c/strong\u003e\u003cbr /\u003e Lets start by analysing what a D-query really means. From the problem statement, it is the number of distinct elements in a range \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e]\u003c/span\u003e.\u003cbr /\u003e e.g: \u003cspan class\u003d\"tex-span\"\u003e117843\u003c/span\u003e, the answer for this segment is \u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e, because 1 and 7 are repeated twice, so we should add them just once.\u003c/p\u003e\u003cp\u003e\u003cem\u003eThe main observation\u003c/em\u003e is that we only need the last positions of all elements before the end of the segment.\u003cbr /\u003e For the above example:  \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elastIdx\u003c/i\u003e[1] \u003d 2\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elastIdx\u003c/i\u003e[7] \u003d 5\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elastIdx\u003c/i\u003e[8] \u003d 4\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elastIdx\u003c/i\u003e[4] \u003d 6\u003c/span\u003e, and finally \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elastIdx\u003c/i\u003e[3] \u003d 7\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSo if we can mark those positions, answering the query would be to count the number of those special positions.\u003cbr /\u003e \u003cstrong\u003eNote:\u003c/strong\u003e Each time we encounter a number, we see if it has been already visited, if so we delete the last mark left by this number if exists -- because it won\u0027t useful to us any more, and then mark the current position.\u003c/p\u003e\u003cp\u003eYou can see that we are able to answer a D-query \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003eL\u003c/i\u003e, \u003ci\u003eR\u003c/i\u003e]\u003c/span\u003e after processing the elements before R. So, one solution is to start from the beginning, apply the reasoning above for the current position, and before moving to the next iteration, see if we have a D-query with an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e equal to our actual position. If yes, we can answer it by summing the marked positions from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e. To count those marked position effectively, one can use a \u003ca href\u003d\"http://community.topcoder.com/tc?module\u003dStatic\u0026amp;d1\u003dtutorials\u0026amp;d2\u003dbinaryIndexedTrees\"\u003efenwick tree\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCube Stacking:\u003c/strong\u003e \u003cbr /\u003e Given \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e cubes labelled from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, and an initial start with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e stacks containing each one cube. Determine the the result of the following queries.\u003cbr /\u003e  1. \u003cstrong\u003eQuery 1\u003c/strong\u003e: move the stack containing cube X on top of the stack containing cube Y.\u003cbr /\u003e  2. \u003cstrong\u003eQuery 2:\u003c/strong\u003e count the number of cubes on the stack with cube X that are under the cube X and output that value.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eFor Query 1, we need somehow to localise each cube in which stack it is at specific moments. Disjoint sets are the fastest way for doing so. \u003c/p\u003e\u003cp\u003eBut how to solve the problem for query 2 ? Keep the number of cubes under each one, and then update that count after each Query 1 ? This will not fit in the time limit.\u003c/p\u003e\u003cp\u003eLet\u0027s try now another method. How about knowing the depth of each cube in a stack? Aha !! Because if we know the size of a stack and the current depth a cube then answering Query 2 becomes easy. This reminds us of the rank property somehow. But, still it is not the final solution, but we are closer know.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s try to tweak the path compression property for \u003ca href\u003d\"http://community.topcoder.com/tc?module\u003dStatic\u0026amp;d1\u003dtutorials\u0026amp;d2\u003ddisjointDataStructure\"\u003eDSU\u003c/a\u003e so to know the depth of each cube. At the beginning, each cube has depth \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e (I will call it rank from know on), and size \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. After a Query of type 1, we merge two stacks, say \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e will be on top of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. The \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e of the stack \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e ((the cube at the top)), will have now \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003erank\u003c/i\u003e[\u003ci\u003eroot\u003c/i\u003e] \u003d \u003ci\u003esizeofstackR\u003c/i\u003e\u003c/span\u003e, and the size of the new stack will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esizeofstackL\u003c/i\u003e + \u003ci\u003esizeofstackR\u003c/i\u003e\u003c/span\u003e.\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eNow for cubes under the old \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e, we already know their \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003erank\u003c/i\u003e\u003c/span\u003e relative to their \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eparents\u003c/i\u003e\u003c/span\u003e. Thus, it is easy now to update their depth, because the depth of all those cubes will be equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003erank\u003c/i\u003e\u003c/span\u003e of their \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eparents\u003c/i\u003e\u003c/span\u003e and their actual \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eranks\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/17/e3/17e30ce5690f2855b5b91e80f9b71f0e2c7ea6d7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e In the image there is an error, I added the right stack on the top of the left one. Sorry for the inconvenience.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eFoot Note:\u003c/strong\u003e Some feedback about my small editorials is welcome. What was explained well ? what I didn\u0027t explain well (or not at all)? And how can I ameliorate them next time ?\u003c/p\u003e\u003c/div\u003e","tags":["training"]}}