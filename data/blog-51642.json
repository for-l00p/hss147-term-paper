{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1492709936,"rating":39,"authorHandle":"prophet_ov_darkness","modificationTimeSeconds":1492793117,"id":51642,"title":"\u003cp\u003e[GYM] 2017 Bangladesh National High School Programming Contest ( National Round, Senior Group ), NHSPC 2017 Tutorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eTutorials are written by corresponding problem authors. I\u0027m just assembling all those tutorials in one place.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/101353/problem/A\" title\u003d\"2017 Bangladesh National High School Programming Contest ( National Round, Senior Group ), NHSPC 2017\"\u003e101353A - Charm Is Not Always Enough\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eProblem Author: \u003ca class\u003d\"rated-user user-green\" href\u003d\"/profile/raida_ash\" title\u003d\"Pupil raida_ash\"\u003eraida_ash\u003c/a\u003e, Tester: \u003ca class\u003d\"rated-user user-gray\" href\u003d\"/profile/khairat\" title\u003d\"Newbie khairat\"\u003ekhairat\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIt is a simple ad-hoc problem. We can solve it in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d1/49/d149e37848c7f7e231f2f79fcfe74bfa4ddab02a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Simply iterate over all the bottles and add the amount of liquid spilled to the answer.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem Author\u0027s Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n \nmain()\n{\n    //freopen(\u0026quot;in1.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n    //freopen(\u0026quot;out1.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\n    int n,m,c[100005],t;\n    long long int ans;\n    scanf(\u0026quot;%d\u0026quot;,\u0026amp;t);\n    while(t--)\n    {\n        ans \u003d 0;\n        scanf(\u0026quot;%d %d\u0026quot;,\u0026amp;n,\u0026amp;m);\n        for (int i\u003d0; i\u0026lt;n; i++)\n        {\n            scanf(\u0026quot;%d\u0026quot;,\u0026amp;c[i]);\n            ans +\u003d ceil((double)((c[i]*1.0)/m))*m - c[i];\n        }\n        printf(\u0026quot;%lld\\n\u0026quot;,ans);\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/101353/problem/B\" title\u003d\"2017 Bangladesh National High School Programming Contest ( National Round, Senior Group ), NHSPC 2017\"\u003e101353B - Max and Alexis Plan to Conquer the World\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eProblem Author: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/tanzon0xA5\" title\u003d\"Candidate Master tanzon0xA5\"\u003etanzon0xA5\u003c/a\u003e, Tester: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/s_h_shahin\" title\u003d\"Expert s_h_shahin\"\u003es_h_shahin\u003c/a\u003e, \u003ca class\u003d\"rated-user user-gray\" href\u003d\"/profile/shapnil092\" title\u003d\"Newbie shapnil092\"\u003eshapnil092\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe number of kittens is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e initially and rate of increase in the number of kittens is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e%\u003c/span\u003e per year. Let\u0027s divide \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e100\u003c/span\u003e and then we can use the formula of \u003ca href\u003d\"https://en.wikipedia.org/wiki/Compound_interest\"\u003ecompound interest\u003c/a\u003e here to get that after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e years, the number of kittens will be: \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e × (1 + \u003ci\u003eR\u003c/i\u003e)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eNow we can do a binary search over \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e to find out which is the lowest value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e that satisfies the following equation:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e × (1 + \u003ci\u003eR\u003c/i\u003e)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/sup\u003e ≥ \u003ci\u003eP\u003c/i\u003e\u003c/span\u003e ( Where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e is the required number of kittens given as input )\u003c/p\u003e\u003cp\u003eSo the time complexity is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/33/29/3329438784c291cc28edcbdb04df3cad2530d255.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Now if you take the highest end of your binary search range too large, then you will get TLE as you can see the range you take has direct effect on the complexity. You can do some calculation to find that answer can never be more than around \u003cspan class\u003d\"tex-span\"\u003e5000\u003c/span\u003e for the given constraints.\u003c/p\u003e\u003cp\u003eAnother way to solve the problem would be to use a direct formula. From the above formula, we can come to this:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e × (1 + \u003ci\u003eR\u003c/i\u003e)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/sup\u003e ≥ \u003ci\u003eP\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a5/10/a510494ccdf6a9f02ceb70094ae59521819d88b5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f1/07/f1070d8f901d00390c1af3d8b9770af847cf1fd2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/06/b4/06b40fca446f70464d781f7e900a3532a3fe1c11.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/9b/bb/9bbb9099266dbd4db41d0416bfe550fb28753431.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eSo now we can get the minimum value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e from this formula. But you have to be careful with the calculations and take care of the cases specially where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e ≤ \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e i.e. the answer is \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem Author\u0027s Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\ntypedef long long int LL;\ndouble N, R, P;\n#define D(x)        cerr \u0026lt;\u0026lt; #x \u0026quot; \u003d \u0026quot; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl\ninline double bigMod(double a, int n)\n{\n    double x \u003d a, ret \u003d 1;\n    while(n)\n    {\n        int currentBit \u003d n\u0026amp;1;\n        if(currentBit)\n            ret *\u003d x;\n        x*\u003dx;\n        n \u003d n\u0026gt;\u0026gt;1;\n    }\n    return ret;\n}\n\ninline bool ok(int x)\n{\n    double total \u003d N*bigMod(1+R, x);\n//    double total \u003d N*pow(1+R, x);\n    if(total \u0026gt;\u003d P)\n        return true;\n    else\n        return false;\n}\ninline int solve()\n{\n    int lo \u003d 0, hi \u003d 5000, mid;\n    while(lo \u0026lt; hi)\n    {\n        mid \u003d (lo+hi)/2;\n        if(ok(mid))\n            hi \u003d mid;\n        else\n            lo \u003d mid+1;\n    }\n    return lo;\n}\nint main()\n{\n//    freopen(\u0026quot;input_subtask_2.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n//    freopen(\u0026quot;output_subtask_2.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\n//    freopen(\u0026quot;input_subtask_1.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n//    freopen(\u0026quot;out.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n//    cout \u0026lt;\u0026lt; 5e5 * log2(5000) * log2(5000) /1e8 \u0026lt;\u0026lt; endl;\n//    cout \u0026lt;\u0026lt; 5e5 * 3000 /1e8 \u0026lt;\u0026lt; endl;\n    int i, j, cs, t;\n    assert(scanf(\u0026quot;%d\u0026quot;,\u0026amp;t) \u003d\u003d 1);\n    assert(1 \u0026lt;\u003d t);\n    assert(t \u0026lt;\u003d 250000);\n    for(cs \u003d 1; cs\u0026lt;\u003dt; cs++)\n    {\n        assert(scanf(\u0026quot;%lf %lf %lf\u0026quot;,\u0026amp;N,\u0026amp;R,\u0026amp;P) \u003d\u003d 3);\n\n        assert(1 \u0026lt;\u003d N);\n        assert(N \u0026lt;\u003d 1000000000);\n\n        assert(1 \u0026lt;\u003d R);\n        assert(R \u0026lt;\u003d 100);\n\n        assert(1 \u0026lt;\u003d P);\n        assert(P \u0026lt;\u003d 10000000000000000000ULL);\n\n        R/\u003d100;\n//        solve();\n        printf(\u0026quot;Case %d: %d\\n\u0026quot;,cs,solve());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/101353/problem/C\" title\u003d\"2017 Bangladesh National High School Programming Contest ( National Round, Senior Group ), NHSPC 2017\"\u003e101353C - Being Common is Too Mainstream\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eProblem Author: \u003ca class\u003d\"rated-user user-green\" href\u003d\"/profile/nafisiham\" title\u003d\"Pupil nafisiham\"\u003enafisiham\u003c/a\u003e, Tester: \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/De_La_Grandi_Mephstophls\" title\u003d\"Specialist De_La_Grandi_Mephstophls\"\u003eDe_La_Grandi_Mephstophls\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe problem setter’s and the alternate writer’s solution are nearly same, and it is not the best but an easy way to solve this problem.\u003c/p\u003e\u003cp\u003eThe naïve solution is to keep calculating GCD of every set of numbers that can be taken and keep dividing the elements of the sets by those GCDs until, there remain some co-prime numbers. The answer is their product. Actually, we are trying to divide every number with whatever common divisor it shares with any other number.\u003c/p\u003e\u003cp\u003eSo, for every prime divisor, its remaining exponent will be the absolute difference between its highest and second highest exponent in any number. For subtasks 2 and 3 a fairly small array of primes sufficed.\u003c/p\u003e\u003cp\u003eFor subtask 1, naïve approach was taken using Euclidean algorithm. \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem Author\u0027s Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define mod 1000000001\nint pi[1011] \u003d {0}, in[100005] \u003d {0};\nint powp(int n, int p)\n{\n    int x \u003d 0;\n    while(n%p \u003d\u003d 0)\n    {\n        n/\u003dp;\n        x++;\n    }\n    return x;\n}\nunsigned long long gcd(unsigned long long a, unsigned long long b)\n{\n    if (a \u003d\u003d 0)\n        return b;\n    return gcd(b%a, a);\n}\nvoid siv(int n)\n{\n    bool prime[n+1];\n    memset(prime, true, sizeof(prime));\n    for (int p\u003d2; p*p\u0026lt;\u003dn; p++)\n    {\n        if (prime[p] \u003d\u003d true)\n        {\n            for (int i \u003d p*2; i\u0026lt;\u003dn; i +\u003d p)\n            prime[i] \u003d false;\n        }\n    }\n    int x \u003d 1;\n    for(int k \u003d 2; k \u0026lt;\u003d n; k++)\n    {\n        if(prime[k] \u003d\u003d true)\n        {\n            pi[x] \u003d k;\n            x++;\n        }\n    }\n}\nint main()\n{\n//    freopen(\u0026quot;input_file_subtask_3.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n//    freopen(\u0026quot;output_file_subtask_3.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n    unsigned long long x, y, z, ans \u003d 1;\n    int n;\n    cin \u0026gt;\u0026gt; n;\n    if(n \u003d\u003d 1)\n    {\n        cin \u0026gt;\u0026gt; x;\n        cout \u0026lt;\u0026lt; x % mod \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n        return 0;\n    }\n    else if(n \u003d\u003d 2)\n    {\n        cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n        unsigned long long gx;\n        gx \u003d gcd(x, y); x /\u003d gx; y /\u003d gx;\n        cout \u0026lt;\u0026lt; ((x % mod) * (y % mod)) % mod \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n        return 0;\n    }\n    else if(n \u003d\u003d 3)\n    {\n        cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z;\n        unsigned long long g, gxy, gyz, gzx;\n        g \u003d gcd(gcd(x, y), z);\n        x/\u003dg; y/\u003dg; z/\u003dg;\n        //cout \u0026lt;\u0026lt; g \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n        gxy \u003d gcd(x, y); /*cout \u0026lt;\u0026lt; gxy \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;*/ x/\u003dgxy; y/\u003dgxy; /*printf(\u0026quot;%u %u %u\\n\u0026quot;, x, y, z);*/\n        gyz \u003d gcd(y, z); /*cout \u0026lt;\u0026lt; gyz \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;*/ y/\u003dgyz; z/\u003dgyz; /*printf(\u0026quot;%u %u %u\\n\u0026quot;, x, y, z);*/\n        gzx \u003d gcd(z, x); /*cout \u0026lt;\u0026lt; gzx \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;*/ x/\u003dgzx; z/\u003dgzx; /*printf(\u0026quot;%u %u %u\\n\u0026quot;, x, y, z);*/\n        cout \u0026lt;\u0026lt; ((((x % mod) * (y % mod)) % mod) * (z % mod)) % mod \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n        return 0;\n    }\n    else\n    {\n        for(int i \u003d 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; in[i];\n        siv(8012);\n        sort(in, in+n);\n        for(int z \u003d 1; z \u0026lt; 1010; z++)\n        {\n            int pw \u003d 0, mx \u003d 0, dif \u003d 0;\n            for(int y \u003d 0; y \u0026lt; n; y++)\n            {\n\n                pw \u003d powp(in[y], pi[z]);\n                in[y] /\u003d pow(pi[z], pw);\n                if(pw \u0026gt;\u003d mx){dif \u003d pw - mx; mx \u003d pw;}\n            }\n            for(int q \u003d 1; q \u0026lt;\u003d dif; q++) {ans \u003d (ans*pi[z])%mod;}\n        }\n        sort(in, in+n);\n        for(int r \u003d 0; r \u0026lt; n; r++) if(in[r] !\u003d in[r+1] \u0026amp;\u0026amp; in[r] !\u003d in[r-1]) ans \u003d (ans * in[r]) % mod;\n        cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n        return 0;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTester\u0027s Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#define CLR(o)                                  memset(o, 0x00, sizeof o)\n#define CLR1(o)                                 memset(o, -1, sizeof o)\n#define takei(a)                                scanf(\u0026quot;%d\u0026quot;, \u0026amp;a)\n#define takell(a)                               scanf(\u0026quot;%lld\u0026quot;, \u0026amp;a)\n#define takellu(a)                              scanf(\u0026quot;%llu\u0026quot;, \u0026amp;a)\n#define sf                                      scanf\n#define pb                                      push_back\n#define mp                                      make_pair\n#define ppp                                     system(\u0026quot;pause\u0026quot;)\n#define ok                                      cout \u0026lt;\u0026lt; \u0026quot;OKA\u0026quot; \u0026lt;\u0026lt;endl;\n#define pf                                      printf\n#define NL                                      printf(\u0026quot;\\n\u0026quot;)\n#define PI                                      2*acos(0)\n#define all(o)                                  o.begin(), o.end()\n#define csi                                     pf(\u0026quot;Case %d: \u0026quot;, ++keis)\n#define csii                                     pf(\u0026quot;Case %d:\\n\u0026quot;, ++keis)\n#define _(o)                                    pf(\u0026quot;%d\\n\u0026quot;, o)\n#define ll                                      long long\n#define ull                                     unsigned long long\n#define exx                                     2.7182818284590452353602875\n#define xx                                      first\n#define yy                                      second\n\n///Helper\nusing namespace std;\ntemplate \u0026lt;class T\u0026gt; T MAX(T a, T b)\n{\n    return a\u0026gt;b?a:b;\n}\ntemplate \u0026lt;class T\u0026gt; T MIN(T a, T b)\n{\n    return a\u0026lt;b?a:b;\n}\ntemplate \u0026lt;class T1\u0026gt; void __(T1 p)\n{\n    cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl;\n}\ntemplate \u0026lt;class T1\u0026gt; void deb(T1 p)\n{\n    cout \u0026lt;\u0026lt; \u0026quot;Debugging: \u0026quot; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl;\n}\ntemplate \u0026lt;class T1, class T2\u0026gt; void deb(T1 p, T2 q)\n{\n    cout \u0026lt;\u0026lt; \u0026quot;Debugging: \u0026quot; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026quot;\\t\u0026quot; \u0026lt;\u0026lt; q  \u0026lt;\u0026lt; endl;\n}\ntemplate \u0026lt;class T1, class T2, class T3\u0026gt; void deb(T1 p, T2 q, T3 r)\n{\n    cout \u0026lt;\u0026lt; \u0026quot;Debugging: \u0026quot; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026quot;\\t \u0026quot; \u0026lt;\u0026lt; q \u0026lt;\u0026lt; \u0026quot;\\t \u0026quot; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl;\n}\ntemplate \u0026lt;class T1, class T2, class T3, class T4\u0026gt; void deb(T1 p, T2 q, T3 r, T4 s)\n{\n    cout \u0026lt;\u0026lt; \u0026quot;Debugging: \u0026quot; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026quot;\\t \u0026quot; \u0026lt;\u0026lt; q \u0026lt;\u0026lt; \u0026quot;\\t \u0026quot; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0026quot;\\t \u0026quot; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl;\n}\nlong long int POOW(long long b, long long p)\n{\n    if(p\u003d\u003d0) return 1;\n    return b*POOW(b, p-1);\n}\n//int SET(int mask, int pos){return mask  singlebar  (1\u0026lt;\u0026lt;pos);}\n//bool CHK(int mask, int pos){return (1\u0026amp;(mask\u0026gt;\u0026gt;pos));}\nconst int xx[] \u003d {0, 0, 1, -1, -1, 1, -1, 1};\nconst int yy[] \u003d {1, -1, 0, 0, 1, 1, -1, -1};\nconst int kx[] \u003d {-2, -1, 1, 2, 2, 1, -1, -2};\nconst int ky[] \u003d {1, 2, 2, 1, -1, -2, -2, -1};   // KX-\u0026gt; Knight moves xx-\u0026gt; diagonal -\u0026gt; 8 horizontal/vertical-\u0026gt;4\n#define LT (1\u0026lt;\u0026lt;31)-1\n#define MX\n#define MOD 1000000001\n//#define MY INT_MIN\nll FAST_EXP(ll base, ll power) /*base^power%MOD*/   {ll res\u003d1ll;while(power){if(power\u0026amp;1)res\u003d(res*base)%MOD;base\u003d(base*base)%MOD;power\u0026gt;\u0026gt;\u003d1;}return res%MOD;}\nll ar[100005];\nvector \u0026lt;ll\u0026gt; pr;\nvector \u0026lt; pair \u0026lt;ll, ll\u0026gt; \u0026gt; ans;\nint n;\n#define SIZE 73211336\nbool prime[SIZE];\nvoid SEIEVE()\n{\n    long long i, j, lim \u003d sqrt(SIZE) + 1;\n    for(i\u003d2; i\u0026lt;\u003dlim ; i++)\n    {\n        if(prime[i]\u003d\u003d0)\n        {\n            pr.pb(i);\n            for(j\u003di*i; j\u0026lt;\u003dlim; j+\u003di)\n            {\n                prime[j] \u003d 1;\n            }\n        }\n    }\n    return;\n}\n\nint main()\n{\n    //ios_base::sync_with_stdio(false);\n#ifndef ONLINE_JUDGE\n//    freopen(\u0026quot;input_file_subtask_2.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n    //freopen(\u0026quot;000.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n    //freopen(\u0026quot;output.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n    //clock_t ooo \u003d clock();\n#endif\n    ///                                    MAIN\n    int i, t, j, k, l,  keis(0);\n    ll c, d, x, y, a, b;\n//    char pp[100];\n//    fgets(pp, 100, stdin);\n    t \u003d 1;\n    SEIEVE();\n//    deb(pr.size(), pr[pr.size()-1]);\n    vector \u0026lt;ll\u0026gt; temp;\n//    takei(t);\n    while(t--)\n    {\n        takei(n);\n        ans.clear();\n        for(i\u003d0; i\u0026lt;n; i++)\n        {\n            takell(ar[i]);\n        }\n        ans.clear();\n        if(n\u003d\u003d1)\n        {\n            pf(\u0026quot;%lld\\n\u0026quot;, ar[0]%MOD);\n        }\n        else if(n\u003d\u003d2)\n        {\n            a \u003d __gcd(ar[0], ar[1]);\n            b \u003d ar[0]/a;\n            c \u003d ar[1]/a;\n            pf(\u0026quot;%lld\\n\u0026quot;, ((b%MOD)*(c%MOD))%MOD);\n        }\n        else if(n\u003d\u003d3)\n        {\n            a \u003d __gcd(ar[0], ar[1]);\n            b \u003d ar[0]/a;\n            c \u003d ar[1]/a;\n            if(ar[2]%a\u003d\u003d0)\n                d \u003d ar[2]/a;\n            else\n                d \u003d ar[2];\n            a \u003d __gcd(c, d);\n            c \u003d c/a;\n            d \u003d d/a;\n            if(b%a\u003d\u003d0)\n                b \u003d b/a;\n            a \u003d __gcd(b, d);\n            b \u003d b/a;\n            d \u003d d/a;\n            if(c%a\u003d\u003d0)\n                c \u003d c/a;\n            pf(\u0026quot;%lld\\n\u0026quot;, ((((b%MOD)*(c%MOD))%MOD)*(d%MOD))%MOD);\n        }\n        else\n        {\n            for(i\u003d0; i\u0026lt;pr.size(); i++)\n            {\n                temp.clear();\n                for(j\u003d0; j\u0026lt;n; j++)\n                {\n                    a \u003d 0;\n                    while(ar[j]%pr[i]\u003d\u003d0)\n                    {\n                        a++;\n                        ar[j]/\u003dpr[i];\n                    }\n                    if(a)\n                        temp.pb(a);\n                }\n                if(!temp.size()) continue;\n                sort(all(temp));\n                if(temp.size()\u0026gt;1)\n                    a \u003d temp[temp.size()-2];\n                else\n                    a \u003d 0;\n                if(a\u0026gt;\u003dtemp[temp.size()-1]) ;\n                else ans.pb({pr[i], temp[temp.size()-1]-a});\n            }\n            a \u003d 1ll;\n            for(i \u003d 0; i\u0026lt;ans.size(); i++)\n            {\n//                deb(ans[i].xx, ans[i].yy);\n                a \u003d a * FAST_EXP(ans[i].first, ans[i].second);\n                a%\u003dMOD;\n            }\n            sort(ar, ar+n);\n            for(i\u003d0; i\u0026lt;n; i++)\n            {\n                if(i\u003d\u003d0 and ar[i]!\u003dar[i+1])\n                {\n                    a \u003d a*ar[i];\n                    a%\u003dMOD;\n                }\n                else if(i\u003d\u003dn-1 and ar[i]!\u003dar[i-1])\n                {\n                    a \u003d a*ar[i];\n                    a%\u003dMOD;\n                }\n                else if(ar[i]!\u003dar[i-1] and ar[i]!\u003dar[i+1])\n                {\n                    a \u003d a*ar[i];\n                    a%\u003dMOD;\n                }\n\n\n            }\n            __(a);\n        }\n\n    }\n    /* Coding is FUN  */\n    ///                                    ENDD\n#ifndef ONLINE_JUDGE\n    //pf(\u0026quot;-------ENDS OF OUTPUT------\\n\\n\u0026quot;);\n    //pf(\u0026quot;Time Elapsed: %lu\\n\u0026quot;, (clock()-ooo));\n#endif\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/101353/problem/D\" title\u003d\"2017 Bangladesh National High School Programming Contest ( National Round, Senior Group ), NHSPC 2017\"\u003e101353D - ShaatChara\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eProblem Author: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/immuntasir\" title\u003d\"Expert immuntasir\"\u003eimmuntasir\u003c/a\u003e, Tester: \u003ca class\u003d\"rated-user user-green\" href\u003d\"/profile/raida_ash\" title\u003d\"Pupil raida_ash\"\u003eraida_ash\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAs noted, this is a normal nim game of n piles. In a normal Nim game, the player making the first move has a winning strategy if and only if the nim-sum of the sizes of the piles is nonzero. In this problem we want to know in how many ways the first player can move such that the second player gets a losing state. That means the first player wants to move such that the xor-sum becomes zero. Now note the properties of a xor operation.\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/f0/77/f0777c22f738518d911a8809ccf98441742e328d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cbr /\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6e/46/6e465f6e5489714cd1946002914dfb8f3e65dd02.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cbr /\u003e \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/16/f3/16f3ac7a95176d5d7810ab3ecd66f4492064fc44.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eNow, we can consider the piles in binary and get some rows and columns of 0s and 1s. The first player is only concerned with the number of bits which are 1 in the current xor-sum. Now note that, each 1 bits of the xor-sum are there because there were 1s in that position in odd number of piles. Now, we have to choose such piles where there is a 1 in the same position of the leftmost bit of xor-sum, and choose the bits in a way such that the number of 1s become zero for all column. So, the solution comes down to this: the number of winning moves are the number of 1’s in the leftmost column with an odd number of 1.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem Author\u0027s Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint ara[100010];\nint highestOneBit(int i) {\n    i |\u003d (i \u0026gt;\u0026gt;  1);\n    i |\u003d (i \u0026gt;\u0026gt;  2);\n    i |\u003d (i \u0026gt;\u0026gt;  4);\n    i |\u003d (i \u0026gt;\u0026gt;  8);\n    i |\u003d (i \u0026gt;\u0026gt; 16);\n    return i - (((unsigned)i) \u0026gt;\u0026gt; 1);\n}\nint main () {\n    int T, n;\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;T);\n    assert(T\u0026lt;\u003d1000);\n    for (int cs\u003d1; cs\u0026lt;\u003dT; cs++) {\n        scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n        assert(n\u0026lt;\u003d10000);\n        int xorsum \u003d 0;\n        for (int i\u003d0; i\u0026lt;n; i++) {\n            scanf(\u0026quot;%d\u0026quot;, \u0026amp;ara[i]);\n            assert(ara[i] \u0026lt;\u003d 100000);\n            xorsum ^\u003d ara[i];\n        }\n        int cnt \u003d 0;\n        int pos \u003d highestOneBit(xorsum);\n        for (int i\u003d0; i\u0026lt;n; i++) {\n        \tif (pos \u0026amp; ara[i]) cnt++;\n        }\n        printf(\u0026quot;Case %d: %d\\n\u0026quot;, cs, cnt);\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/101353/problem/E\" title\u003d\"2017 Bangladesh National High School Programming Contest ( National Round, Senior Group ), NHSPC 2017\"\u003e101353E - Just One Swap\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eProblem Author: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/tube_light\" title\u003d\"Expert tube_light\"\u003etube_light\u003c/a\u003e, Tester: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/prophet_ov_darkness\" title\u003d\"Candidate Master prophet_ov_darkness\"\u003eprophet_ov_darkness\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe answer is equal to the number of ways you can choose two different numbers from the given array. It can be done easily with the help of the frequency array of the given numbers. But if there is at least one number having frequency greater than 1, then you can swap any two numbers having the same value and get the initial given array. So, in that case, you need to add 1 to the answer.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem Author\u0027s Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;stdio.h\u0026gt;\n#include\u0026lt;string.h\u0026gt;\n#include\u0026lt;stdbool.h\u0026gt;\n#define MAX     100000\ntypedef long long int LL;\n \nint frq[MAX+5];\n \nint main()\n{\n    int i, t, v, n;\n    LL res;\n    bool flag;\n   \n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;t);\n    while(t--)\n    {\n        flag \u003d false;\n        res \u003d 0;\n        memset(frq, 0, sizeof(frq));\n       \n        scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n        for(i \u003d 1; i \u0026lt;\u003d n; i++){\n            scanf(\u0026quot;%d\u0026quot;, \u0026amp;v);\n            frq[v]++;\n        }\n       \n        for(i \u003d 1; i \u0026lt;\u003d MAX; i++)\n        {\n            res +\u003d (LL) frq[i] * (n - frq[i]);\n            if(frq[i] \u0026gt; 1) flag \u003d true;\n        }\n           \n        printf(\u0026quot;%lld\\n\u0026quot;, res/2 + flag);\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTester\u0027s Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\n#define rep(i,n) for(i\u003d0; i\u0026lt;n; i++)\n#define repl(i,n) for(i\u003d1; i\u0026lt;\u003dn; i++)\n\n#define sz(x) (int) x.size()\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define uu first\n#define vv second\n#define mem(x, y) memset(x, y, sizeof(x))\n#define un(x) x.erase(unique(all(x)), x.end())\n\n#define sdi(x) scanf(\u0026quot;%d\u0026quot;, \u0026amp;x)\n#define sdii(x, y) scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;x, \u0026amp;y)\n#define sdiii(x, y, z) scanf(\u0026quot;%d %d %d\u0026quot;, \u0026amp;x, \u0026amp;y, \u0026amp;z)\n#define sdl(x) scanf(\u0026quot;%lld\u0026quot;, \u0026amp;x)\n#define sdll(x, y) scanf(\u0026quot;%lld %lld\u0026quot;, \u0026amp;x, \u0026amp;y)\n#define sdlll(x, y, z) scanf(\u0026quot;%lld %lld %lld\u0026quot;, \u0026amp;x, \u0026amp;y, \u0026amp;z)\n#define sds(x) scanf(\u0026quot;%s\u0026quot;, x)\n#define pfi(x) printf(\u0026quot;%d\\n\u0026quot;, x)\n#define pfii(x, y) printf(\u0026quot;%d %d\\n\u0026quot;, x, y)\n#define pfiii(x, y, z) printf(\u0026quot;%d %d %d\\n\u0026quot;, x, y, z)\n#define pfl(x) printf(\u0026quot;%lld\\n\u0026quot;, x)\n#define pfll(x, y) printf(\u0026quot;%lld %lld\\n\u0026quot;, x, y)\n#define pflll(x, y, z) printf(\u0026quot;%lld %lld %lld\\n\u0026quot;, x, y, z)\n\n#define eps 1e-9\n#define OK cerr \u0026lt;\u0026lt; \u0026quot;ok\\n\u0026quot;\n#define DB(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026quot; \u003d \u0026quot; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair \u0026lt;int, int\u0026gt; pii;\n\ninline int setBit(int N, int pos) { return N\u003dN | (1\u0026lt;\u0026lt;pos); }\ninline int resetBit(int N, int pos) { return N\u003d N \u0026amp; ~(1\u0026lt;\u0026lt;pos); }\ninline bool checkBit(int N, int pos) { return (bool)(N \u0026amp; (1\u0026lt;\u0026lt;pos)); }\n\n//int kx[] \u003d {+2, +1, -1, -2, -2, -1, +1, +2};\n//int ky[] \u003d {+1, +2, +2, +1, -1, -2, -2, -1}; //Knight Direction\n//int fx[] \u003d {+0, +0, +1, -1, -1, +1, -1, +1};\n//int fy[] \u003d {-1, +1, +0, +0, +1, +1, -1, -1}; //Four \u0026amp; Eight Direction\n\n\nconst int MAX \u003d 100005;\nint n, arr[MAX], freq[MAX];\n\ninline LL solve() {\n    LL ret \u003d 0;\n    int i;\n    if(*max_element(freq, freq+100001) \u0026gt; 1) ret \u003d 1;\n    rep(i, n) {\n        freq[ arr[i] ]--;\n        ret +\u003d n-i-1;\n        ret -\u003d freq[ arr[i] ];\n    }\n    return ret;\n}\n\nint main() {\n//    assert(freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin));\n//    assert(freopen(\u0026quot;out.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout));\n\n    int test, i;\n\n    sdi(test);\n    assert(1\u0026lt;\u003dtest \u0026amp;\u0026amp; test\u0026lt;\u003d5);\n    while(test--) {\n        sdi(n);\n        assert(2\u0026lt;\u003dn \u0026amp;\u0026amp; n\u0026lt;\u003d100000);\n        rep(i, n) {\n            sdi(arr[i]);\n            assert(1\u0026lt;\u003darr[i] \u0026amp;\u0026amp; arr[i]\u0026lt;\u003d100000);\n            freq[ arr[i] ]++;\n        }\n        pfl(solve());\n    }\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/101353/problem/F\" title\u003d\"2017 Bangladesh National High School Programming Contest ( National Round, Senior Group ), NHSPC 2017\"\u003e101353F - Halum and Candies\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eProblem Author: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/shadowfax\" title\u003d\"Expert shadowfax\"\u003eshadowfax\u003c/a\u003e, Tester: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/WALL_E\" title\u003d\"Expert WALL_E\"\u003eWALL_E\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe naïve solution would be to sort the candies in descending order. Now we give a guest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e candies from first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e flavors where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u0026gt; 0, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u0026gt; 0, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e \u0026gt; 0\u003c/span\u003e. Then we sort them again and do the same step until one of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e becomes \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. This method works for the smaller subtask but for bigger constraints of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e it fails to solve within time limit.\u003c/p\u003e\u003cp\u003eTo solve for the larger constraints, we can accelerate the above algorithm. We sort them in descending order and subtract \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. This way we surely have given candies to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e number of guests. Now from the remaining sum of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e flavors, we can assign them in empty spots from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. This means that we could easily chose to give from these flavors when any of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e flavors gets less. We use binary search on answer to find the maximum such assignments.\u003c/p\u003e\u003cp\u003eTester \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/WALL_E\" title\u003d\"Expert WALL_E\"\u003eWALL_E\u003c/a\u003e also used binary search on answer, but with a quite different approach. Let’s say we can satisfy \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e guests. Then we find how many candies we have in total so that we can give \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e guests. Now we just have to check if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eSUM\u003c/i\u003e / \u003ci\u003eX\u003c/i\u003e ≥ \u003ci\u003eK\u003c/i\u003e\u003c/span\u003e, to satisfy our condition.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem Author\u0027s Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n \n#define LL long long\n \nLL a[1005];\n \nbool check(LL mid, LL sum, int n, int k) {\n    for(int i \u003d n-k; i \u0026lt; n; i++) {\n        if(a[i] \u0026gt;\u003d mid) break;\n        if(sum \u0026lt; (mid-a[i])) return 0;\n        sum -\u003d (mid-a[i]);\n    }\n    return 1;\n}\n \nLL bs(LL sum, int n, int k) {\n    LL low\u003d0, high\u003dsum, mid, ret\u003d0;\n    while(low \u0026lt;\u003d high) {\n        mid \u003d (low+high)/2LL;\n        if(check(mid, sum, n, k)) {\n            low \u003d mid+1;\n            ret \u003d mid;\n        } else {\n            high \u003d mid-1;\n        }\n    }\n    return ret;\n}\n \nLL solve(int n, int k) {\n    sort(a, a+n);\n    if(n \u003d\u003d k) return a[0];\n \n    LL ret \u003d a[n-k];\n    for(int i \u003d n-k; i \u0026lt; n; i++)\n        a[i] -\u003d ret;\n    LL sum \u003d 0;\n    for(int i \u003d 0; i \u0026lt; n-k; i++)\n        sum +\u003d a[i];\n \n    return ret+bs(sum, n, k);\n}\n \nint main() {\n    //freopen(\u0026quot;halum_input_task2.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n    //freopen(\u0026quot;halum_output_task2.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\n    int cases, caseno\u003d0, n, k;\n \n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;cases);\n \n    while(cases--) {\n        scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;n, \u0026amp;k);\n        assert(n \u0026gt;\u003d 1 \u0026amp;\u0026amp; n \u0026lt;\u003d 1000 \u0026amp;\u0026amp; k \u0026gt;\u003d 1 \u0026amp;\u0026amp; k \u0026lt;\u003d n);\n \n        for(int i \u003d 0; i \u0026lt; n; i++) {\n            scanf(\u0026quot;%lld\u0026quot;, \u0026amp;a[i]);\n            assert(a[i] \u0026gt;\u003d 0 \u0026amp;\u0026amp; a[i] \u0026lt;\u003d 1000000000);\n        }\n \n        printf(\u0026quot;Case %d: %lld\\n\u0026quot;, ++caseno, solve(n, k));\n    }\n \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTester\u0027s Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#define MAX 101000\n#define INF 100000000000000000LL\nusing namespace std;\nlong long n,a[MAX],k;\nbool can(long long x)\n{\n    long long sum\u003d0;\n    for(int i\u003d0;i\u0026lt;n;i++){\n        if(a[i]\u0026gt;x) sum+\u003dx;\n        else sum+\u003da[i];\n    }\n    return ((sum/x)\u0026gt;\u003dk);\n}\nlong long solve()\n{\n    long long s \u003d1,e\u003dINF,m\u003d0,r\u003d0;\n    while(s\u0026lt;\u003de){\n        m \u003d (s+e+1)/2;\n        if(can(m)){\n            r \u003d m;\n            s \u003d m+1;\n        }\n        else e \u003d m-1;\n    }\n    return r;\n}\nint main()\n{\n    int tc , cn\u003d0;\n    //freopen(\u0026quot;halum_input_task1.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n    //freopen(\u0026quot;alter_halum_output_task1.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\n    scanf(\u0026quot;%d\u0026quot;,\u0026amp;tc);\n    while(tc--){\n        scanf(\u0026quot;%lld %lld\u0026quot;,\u0026amp;n,\u0026amp;k);\n        for(int i\u003d0;i\u0026lt;n;i++) scanf(\u0026quot;%lld\u0026quot;,\u0026amp;a[i]);\n        printf(\u0026quot;Case %d: %lld\\n\u0026quot;,++cn,solve());\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/101353/problem/G\" title\u003d\"2017 Bangladesh National High School Programming Contest ( National Round, Senior Group ), NHSPC 2017\"\u003e101353G - XOR \u0027em all\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eProblem Author: \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/RHaque\" title\u003d\"Specialist RHaque\"\u003eRHaque\u003c/a\u003e, Tester: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/s_h_shahin\" title\u003d\"Expert s_h_shahin\"\u003es_h_shahin\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe first observation to be made here is that if any integer having a parity of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e is XOR\u0027ed with \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e20\u003c/sup\u003e - 1\u003c/span\u003e (a number whose binary representation is \u003cspan class\u003d\"tex-span\"\u003e11111111111111111111\u003c/span\u003e), its parity will become \u003cspan class\u003d\"tex-span\"\u003e20 - \u003ci\u003eX\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTo handle the updates and queries, a segment tree can be used, each of who\u0027s nodes shall contain a bitmask, of \u003cspan class\u003d\"tex-span\"\u003e20\u003c/span\u003e bits each. The \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eth\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e bit of the bitmask in any node shall be \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e if any of the integers in the interval represented by the node has a parity of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e, and \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e otherwise.\u003c/p\u003e\u003cp\u003eThus, during a range update, the new mask of a node can be created simply by reversing the previous mask (since the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eth\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e bit of the new mask will equal the \u003cspan class\u003d\"tex-span\"\u003e(20 - \u003ci\u003ei\u003c/i\u003e)\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eth\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e bit of the old mask).\u003c/p\u003e\u003cp\u003eFor answering the query, if the parity of the given number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e, we first query to find if any number with parity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003c/span\u003e exists in the given range. If not we find the highest parity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e \u0026lt; \u003ci\u003eP\u003c/i\u003e\u003c/span\u003e that exists in the range, and the smallest parity R\u0026gt;P that exist in the same.\u003c/p\u003e\u003cp\u003eCase 1: If \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eP\u003c/i\u003e - \u003ci\u003eQ\u003c/i\u003e) \u0026lt; (\u003ci\u003eR\u003c/i\u003e - \u003ci\u003eP\u003c/i\u003e)\u003c/span\u003e print the position of the leftmost number in the range with parity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eCase 2: If \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eP\u003c/i\u003e - \u003ci\u003eQ\u003c/i\u003e) \u0026gt; (\u003ci\u003eR\u003c/i\u003e - \u003ci\u003eP\u003c/i\u003e)\u003c/span\u003e print the position of the leftmost number in the range with parity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eCase 3: If \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eP\u003c/i\u003e - \u003ci\u003eQ\u003c/i\u003e) \u003d (\u003ci\u003eR\u003c/i\u003e - \u003ci\u003eP\u003c/i\u003e)\u003c/span\u003e find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, the position of the leftmost number in the range with parity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, the position of the leftmost number in the range with parity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e, and print the minimum of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eTo find the position of the leftmost number with a certain parity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e, in a given range, we can query through the segment tree in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/46/0d/460dd127cb2bc381f06e60d3f580bb19f7d55787.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. If we are certain that at least one number with parity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e exists in the range represented by a node, then obviously, either the left child or the right child contains a number with the parity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e. Since we are looking for the leftmost position, if a number with parity p appears in the left interval (which we can find out using a \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/26/48/264879dcd0c82214d8556845e6c7caa3fa731488.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e segment tree query on the range specified by the left interval), we go to the left child, otherwise to the right. Once we reach a leaf of a tree, the array element represented by it is the answer to the query.\u003c/p\u003e\u003cp\u003eTime Complexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a8/a1/a8a11577f3bb2ff1822be9557ba6fef97825248d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem Author\u0027s Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#define SIZE 1000105\n#define callLeft s,mid,nd+nd\n#define callRight mid+1,e,nd+nd+1\nusing namespace std;\nint n, m;\nint ara[SIZE];\nint segTree[4*SIZE];\nbool lazy[4*SIZE];\nbool checkBit(int n, int pos){ return ((n\u0026amp;(1\u0026lt;\u0026lt;pos))!\u003d0);}\nint setBit(int n, int pos){ return (n|(1\u0026lt;\u0026lt;pos));}\n\nvoid build(int s, int e, int nd){\n    lazy[nd]\u003d0;\n    if(s\u003d\u003de){\n        segTree[nd]\u003dsetBit(0, __builtin_popcount(ara[s]));\n        return;\n    }\n    int mid\u003d(s+e)\u0026gt;\u0026gt;1;\n    build(callLeft);\n    build(callRight);\n    segTree[nd]\u003d(segTree[nd+nd] | segTree[nd+nd+1]);\n}\n\nvoid lazy_update(int s, int e, int nd){\n    if(lazy[nd]\u003d\u003dtrue){\n        int newMask\u003d0;\n        for(int i\u003d0; i\u0026lt;\u003d20; i++){\n            if(checkBit(segTree[nd], 20-i)) newMask\u003dsetBit(newMask, i);\n        }\n        segTree[nd]\u003dnewMask;\n        if(s!\u003de){\n            lazy[nd+nd]^\u003d1;\n            lazy[nd+nd+1]^\u003d1;\n        }\n        lazy[nd]\u003dfalse;\n    }\n}\n\nvoid update(int s, int e, int nd, int l, int r){\n    lazy_update(s, e, nd);\n    if(s\u0026gt;r || e\u0026lt;l) return;\n    if(s\u0026gt;\u003dl \u0026amp;\u0026amp; e\u0026lt;\u003dr){\n        lazy[nd]^\u003d1;\n        lazy_update(s, e, nd);\n        return;\n    }\n    int mid\u003d(s+e)\u0026gt;\u0026gt;1;\n    update(callLeft, l, r);\n    update(callRight, l, r);\n    segTree[nd]\u003d(segTree[nd+nd] | segTree[nd+nd+1]);\n}\n\nint query2(int s, int e, int nd, int l, int r){\n    lazy_update(s, e, nd);\n    if(s\u0026gt;r || e\u0026lt;l) return 0;\n    if(s\u0026gt;\u003dl \u0026amp;\u0026amp; e\u0026lt;\u003dr) return segTree[nd];\n    int mid\u003d(s+e)\u0026gt;\u0026gt;1;\n    return (query2(callLeft, l, r) | query2(callRight, l, r));\n}\n\nint query(int s, int e, int nd, int l, int r, int pos){\n    lazy_update(s, e, nd);\n    if(s\u003d\u003de) return s;\n    int mid\u003d(s+e)\u0026gt;\u0026gt;1;\n    if(l\u0026gt;mid){\n        return query(callRight, l, r, pos);\n    }\n    int val\u003dquery2(1, n, 1, l, mid);\n    if(checkBit(val, pos)){\n        return query(callLeft, l, r, pos);\n    }\n    return query(callRight, l, r, pos);\n}\n\nint process_query(int l, int r, int v){\n    int par\u003d__builtin_popcount(v);\n    int d\u003d0;\n    int q1, q2;\n    int d1, d2;\n    d1\u003dd2\u003d100;\n    for(int i\u003dpar; i\u0026gt;\u003d0; i--){\n        if(checkBit(query2(1, n, 1, l, r), i)){\n            q1\u003dquery(1, n, 1, l, r, i);\n            d1\u003dpar-i;\n            break;\n        }\n    }\n    for(int i\u003dpar+1; i\u0026lt;\u003d20; i++){\n        if(checkBit(query2(1, n, 1, l, r), i)){\n            q2\u003dquery(1, n, 1, l, r, i);\n            d2\u003di-par;\n            break;\n        }\n    }\n    if(d1\u003d\u003dd2) return min(q1, q2);\n    if(d1\u0026lt;d2) return q1;\n    if(d2\u0026lt;d1) return q2;\n}\n\nint main()\n{\n    int t, cs\u003d0, l, r, val, type;\n//    freopen(\u0026quot;in3.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n//    freopen(\u0026quot;out3.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;t);\n    assert(t\u0026gt;\u003d1 \u0026amp;\u0026amp; t\u0026lt;\u003d5);\n    while(t--){\n        scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;n, \u0026amp;m);\n        assert(n\u0026gt;\u003d1 \u0026amp;\u0026amp; n\u0026lt;\u003d1000000);\n        assert(m\u0026gt;\u003d1 \u0026amp;\u0026amp; m\u0026lt;\u003d100000);\n        for(int i\u003d1; i\u0026lt;\u003dn; i++){\n            scanf(\u0026quot;%d\u0026quot;, \u0026amp;ara[i]);\n            assert(ara[i]\u0026gt;\u003d0 \u0026amp;\u0026amp; ara[i]\u0026lt;(1\u0026lt;\u0026lt;20));\n        }\n        build(1, n, 1);\n        printf(\u0026quot;Case %d:\\n\u0026quot;, ++cs);\n        for(int i\u003d1; i\u0026lt;\u003dm; i++){\n            scanf(\u0026quot;%d\u0026quot;, \u0026amp;type);\n            assert(type\u003d\u003d1 || type\u003d\u003d2);\n            if(type\u003d\u003d1){\n                scanf(\u0026quot;%d %d %d\u0026quot;, \u0026amp;l, \u0026amp;r, \u0026amp;val);\n                assert(l\u0026gt;\u003d1 \u0026amp;\u0026amp; l\u0026lt;\u003dr \u0026amp;\u0026amp; r\u0026lt;\u003dn);\n                assert(val\u0026gt;\u003d0 \u0026amp;\u0026amp; val\u0026lt;(1\u0026lt;\u0026lt;20));\n                printf(\u0026quot;%d\\n\u0026quot;, process_query(l, r, val));\n            }\n            else{\n                scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;l, \u0026amp;r);\n                assert(l\u0026gt;\u003d1 \u0026amp;\u0026amp; l\u0026lt;\u003dr \u0026amp;\u0026amp; r\u0026lt;\u003dn);\n                update(1, n, 1, l, r);\n            }\n        }\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTester\u0027s Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define si(a)           scanf(\u0026quot;%d\u0026quot;,\u0026amp;a)\n#define sii(a,b)        scanf(\u0026quot;%d %d\u0026quot;,\u0026amp;a,\u0026amp;b)\n#define siii(a,b,c)     scanf(\u0026quot;%d %d %d\u0026quot;,\u0026amp;a,\u0026amp;b,\u0026amp;c)\n\n#define sl(a)           scanf(\u0026quot;%I64d\u0026quot;,\u0026amp;a)\n#define sll(a,b)        scanf(\u0026quot;%I64d %I64d\u0026quot;,\u0026amp;a,\u0026amp;b)\n#define slll(a,b,c)     scanf(\u0026quot;%I64d %I64d %I64d\u0026quot;,\u0026amp;a,\u0026amp;b,\u0026amp;c)\n\n#define pb              push_back\n#define PII             pair \u0026lt;int,int\u0026gt;\n#define PLL             pair \u0026lt;ll,ll\u0026gt;\n#define mp              make_pair\n#define xx              first\n#define yy              second\n#define all(v)          v.begin(),v.end()\n\n#define CLR(a)          memset(a,0,sizeof(a))\n#define SET(a)          memset(a,-1,sizeof(a))\n\n#define eps             1e-9\n#define PI              acos(-1.0)\n#define MAX             1000010\n#define MOD             1000000007\n#define INF             2000000000\n\nint setBit(int n,int pos){ return n \u003d n | (1 \u0026lt;\u0026lt; pos); } //sets the pos\u0027th bit to 1\nint resetBit(int n,int pos){ return n \u003d n \u0026amp; ~(1 \u0026lt;\u0026lt; pos); } //sets the pos\u0027th bit to 0\nbool checkBit(int n,int pos){ return (bool)(n \u0026amp; (1 \u0026lt;\u0026lt; pos)); } //returns the pos\u0027th bit\n\n/******************************************************************************************/\n\nint ara[MAX];\n\nstruct node{\n    int sum;\n} tree[4*MAX];\n\nint lazy[4*MAX];\n\nnode Merge(node a,node b){\n    node ret;\n    ret.sum \u003d a.sum | b.sum;\n    return ret;\n}\n\nvoid lazyUpdate(int n,int st,int ed)\n{\n    lazy[n] %\u003d 2;\n    if(lazy[n]!\u003d0){\n        int x \u003d tree[n].sum;\n        for(int i\u003d0;i\u0026lt;11;i++){\n            if(checkBit(x,i) \u0026amp;\u0026amp; checkBit(x,20-i)){\n            }\n            else if(checkBit(x,i)){\n                x \u003d resetBit(x,i);\n                x \u003d setBit(x,20-i);\n            }\n            else if(checkBit(x,20-i)){\n                x \u003d resetBit(x,20-i);\n                x \u003d setBit(x,i);\n            }\n        }\n        tree[n].sum \u003d x;\n        if(st!\u003ded){\n            lazy[2*n] +\u003d lazy[n];\n            lazy[2*n] %\u003d 2;\n            lazy[2*n+1] +\u003d lazy[n];\n            lazy[2*n+1] %\u003d 2;\n        }\n        lazy[n] \u003d 0;\n    }\n}\n\nvoid build(int n,int st,int ed)\n{\n    lazy[n] \u003d 0;\n    if(st\u003d\u003ded){\n        tree[n].sum \u003d ara[st];\n        return;\n    }\n    int mid \u003d (st+ed)/2;\n    build(2*n,st,mid);\n    build(2*n+1,mid+1,ed);\n    tree[n] \u003d Merge(tree[2*n],tree[2*n+1]);\n}\nvoid update(int n,int st,int ed,int i,int j)\n{\n    lazyUpdate(n,st,ed);\n    if(st\u0026gt;j || ed\u0026lt;i) return;\n    if(st\u0026gt;\u003di \u0026amp;\u0026amp; ed\u0026lt;\u003dj){\n        lazy[n]++;\n        lazy[n] %\u003d 2;\n        lazyUpdate(n,st,ed);\n        return;\n    }\n    int mid \u003d (st+ed)/2;\n    update(2*n,st,mid,i,j);\n    update(2*n+1,mid+1,ed,i,j);\n    tree[n] \u003d Merge(tree[2*n],tree[2*n+1]);\n}\n\nnode query(int n,int st,int ed,int i,int j)\n{\n    lazyUpdate(n,st,ed);\n    if(st\u0026gt;\u003di \u0026amp;\u0026amp; ed\u0026lt;\u003dj) return tree[n];\n    int mid \u003d (st+ed)/2;\n    if(mid\u0026lt;i) return query(2*n+1,mid+1,ed,i,j);\n    else if(mid\u0026gt;\u003dj) return query(2*n,st,mid,i,j);\n    else return Merge(query(2*n,st,mid,i,j),query(2*n+1,mid+1,ed,i,j));\n}\n\nint N;\n\nint query2(int n,int st,int ed,int i,int j,int v)\n{\n    if(st\u003d\u003ded) return st;\n    int mid \u003d (st+ed)/2;\n    if(i\u0026gt;mid) return query2(2*n+1,mid+1,ed,i,j,v);\n    else{\n        int x \u003d query(1,1,N,i,mid).sum;\n        if(checkBit(x,v) \u0026amp;\u0026amp; mid\u0026gt;\u003di) return query2(2*n,st,mid,i,j,v);\n        else return query2(2*n+1,mid+1,ed,i,j,v);\n    }\n}\n\n\nint num[MAX];\n\nint main()\n{\n//    freopen(\u0026quot;in3.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n//    freopen(\u0026quot;alter_out3.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\n\n\n    int t,T,n,m,i,type,l,r,v,j;\n    si(T);\n    assert(T\u0026gt;\u003d1 \u0026amp;\u0026amp; T\u0026lt;\u003d5);\n    for(t\u003d1;t\u0026lt;\u003dT;t++){\n        printf(\u0026quot;Case %d:\\n\u0026quot;,t);\n        sii(n,m);\n        N \u003d n;\n        assert(n\u0026gt;\u003d1 \u0026amp;\u0026amp; n\u0026lt;\u003d1000000 \u0026amp;\u0026amp; m\u0026gt;\u003d1 \u0026amp;\u0026amp; m\u0026lt;\u003d100000);\n\n        int x;\n        for(i\u003d1;i\u0026lt;\u003dn;i++){\n            si(num[i]);\n            assert(num[i]\u0026gt;\u003d0 \u0026amp;\u0026amp; num[i] \u0026lt;\u003d ((1\u0026lt;\u0026lt;20)-1));\n            x \u003d __builtin_popcount(num[i]);\n            ara[i] \u003d setBit(0,x);\n        }\n\n\n        build(1,1,n);\n\n\n\n        int y,dif1,dif2,id1,id2;\n\n\n        for(i\u003d1;i\u0026lt;\u003dm;i++){\n            si(type);\n            assert(type\u0026gt;\u003d1 \u0026amp;\u0026amp; type\u0026lt;\u003d2);\n            if(type\u003d\u003d1){\n                siii(l,r,v);\n                assert(l\u0026gt;\u003d1 \u0026amp;\u0026amp; l\u0026lt;\u003dn \u0026amp;\u0026amp; r\u0026gt;\u003d1 \u0026amp;\u0026amp; r\u0026lt;\u003dn \u0026amp;\u0026amp; v \u0026gt;\u003d0 \u0026amp;\u0026amp; v \u0026lt;\u003d ((1\u0026lt;\u0026lt;20)-1) \u0026amp;\u0026amp; l\u0026lt;\u003dr);\n                x \u003d query(1,1,n,l,r).sum;\n                y \u003d __builtin_popcount(v);\n\n                dif1 \u003d dif2 \u003d 30;\n\n\n\n                for(j\u003dy;j\u0026lt;\u003d20;j++){\n                    if(checkBit(x,j)){\n                        id1 \u003d query2(1,1,n,l,r,j);\n                        dif1 \u003d abs(y-j);\n                        break;\n                    }\n                }\n\n\n                for(j\u003dy-1;j\u0026gt;\u003d0;j--){\n                    if(checkBit(x,j)){\n                        id2 \u003d query2(1,1,n,l,r,j);\n                        dif2 \u003d abs(y-j);\n                        break;\n                    }\n                }\n                if(dif1\u003d\u003ddif2) printf(\u0026quot;%d\\n\u0026quot;,min(id1,id2));\n                else if(dif1\u0026lt;dif2) printf(\u0026quot;%d\\n\u0026quot;,id1);\n                else printf(\u0026quot;%d\\n\u0026quot;,id2);\n            }\n            else{\n                sii(l,r);\n                assert(l\u0026gt;\u003d1 \u0026amp;\u0026amp; l\u0026lt;\u003dn \u0026amp;\u0026amp; r\u0026gt;\u003d1 \u0026amp;\u0026amp; r\u0026lt;\u003dn \u0026amp;\u0026amp; l\u0026lt;\u003dr);\n                update(1,1,n,l,r);\n            }\n        }\n\n    }\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/gym/101353/problem/H\" title\u003d\"2017 Bangladesh National High School Programming Contest ( National Round, Senior Group ), NHSPC 2017\"\u003e101353H - Simple Path\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eProblem Author: \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/prophet_ov_darkness\" title\u003d\"Candidate Master prophet_ov_darkness\"\u003eprophet_ov_darkness\u003c/a\u003e, Tester: \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/tube_light\" title\u003d\"Expert tube_light\"\u003etube_light\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirstly let\u0027s check out an \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ea/26/ea26350dd8496edcc681089063982e2fff6200d4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e optimized brute force solution to this problem. Here we\u0027ll fix a subroot in linear time. Then from each of those subroots we\u0027ll run DFS in the corresponding subtree. For each edge in a subtree, we\u0027ll count the number of times it appears in all possible simple paths present in that subtree. Let\u0027s take an edge \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e - \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is the parent of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. Now the number of times this edge will appear in subtree rooted at node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e) × (\u003ci\u003eS\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e) - \u003ci\u003eS\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e))\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d  \u003ci\u003esize\u003c/i\u003e \u003ci\u003eof\u003c/i\u003e \u003ci\u003esubtree\u003c/i\u003e \u003ci\u003erooted\u003c/i\u003e \u003ci\u003eat\u003c/i\u003e \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. This count will have to be multiplied by the weight of edge \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e - \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and added to the actual result. This part is pretty straight-forward. Think about it for a moment if it\u0027s still unclear.\u003c/p\u003e\u003cp\u003eNow let\u0027s optimize this solution into a linear one. For that we\u0027ll have to use dynamic programming. Let\u0027s say \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eDP\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d  \u003ci\u003eanswer\u003c/i\u003e \u003ci\u003efor\u003c/i\u003e \u003ci\u003esubtree\u003c/i\u003e \u003ci\u003erooted\u003c/i\u003e \u003ci\u003eat\u003c/i\u003e \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Suppose we are computing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eDP\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e now. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e be a child of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e - \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e an edge in the subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e is the parent of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. Firstly we\u0027ll have to add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eDP\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eDP\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e. Secondly we\u0027ll have to add the impact edge \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e puts in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eDP\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e. This part is discussed in the previous paragraph. Finally we\u0027ll have to count all those simple paths which start in the subtree of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e and goes through node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and finishes in another part of the subtree of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Let, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e be the weight of the edge which leads node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to it\u0027s parent.\u003c/p\u003e\u003cp\u003eWe know the impact node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e - \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e puts while computing the answer of subtree rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e) × \u003ci\u003eW\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e) × (\u003ci\u003eS\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e) - \u003ci\u003eS\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e))\u003c/span\u003e\u003c/p\u003e\u003cp\u003eImpact of edge \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e - \u003ci\u003ev\u003c/i\u003e\u003c/span\u003e in the answer of subtree rooted at node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e) × \u003ci\u003eW\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e) × (\u003ci\u003eS\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) - \u003ci\u003eS\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e))\u003c/span\u003e\u003c/p\u003e\u003cp\u003eThe difference is: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e) × \u003ci\u003eW\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e) × (\u003ci\u003eS\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) - \u003ci\u003eS\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e))\u003c/span\u003e\u003c/p\u003e\u003cp\u003eSo, we\u0027ll have to add \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/14/b5/14b58940a4ff4b5c9589ca00a4204b90af276fe2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eDP\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e to get the final answer.\u003c/p\u003e\u003cp\u003eHere, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eST\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d  \u003ci\u003eset\u003c/i\u003e \u003ci\u003eof\u003c/i\u003e \u003ci\u003eproper\u003c/i\u003e \u003ci\u003edescendants\u003c/i\u003e \u003ci\u003eof\u003c/i\u003e \u003ci\u003enode\u003c/i\u003e \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eOverall time complexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d1/49/d149e37848c7f7e231f2f79fcfe74bfa4ddab02a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eProblem Author\u0027s Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\n#define rep(i,n) for(i\u003d0; i\u0026lt;n; i++)\n#define repl(i,n) for(i\u003d1; i\u0026lt;\u003dn; i++)\n\n#define sz(x) (int) x.size()\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define uu first\n#define vv second\n#define mem(x, y) memset(x, y, sizeof(x))\n#define un(x) x.erase(unique(all(x)), x.end())\n\n#define sdi(x) scanf(\u0026quot;%d\u0026quot;, \u0026amp;x)\n#define sdii(x, y) scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;x, \u0026amp;y)\n#define sdiii(x, y, z) scanf(\u0026quot;%d %d %d\u0026quot;, \u0026amp;x, \u0026amp;y, \u0026amp;z)\n#define sdl(x) scanf(\u0026quot;%lld\u0026quot;, \u0026amp;x)\n#define sdll(x, y) scanf(\u0026quot;%lld %lld\u0026quot;, \u0026amp;x, \u0026amp;y)\n#define sdlll(x, y, z) scanf(\u0026quot;%lld %lld %lld\u0026quot;, \u0026amp;x, \u0026amp;y, \u0026amp;z)\n#define sds(x) scanf(\u0026quot;%s\u0026quot;, x)\n#define pfi(x) printf(\u0026quot;%d\\n\u0026quot;, x)\n#define pfii(x, y) printf(\u0026quot;%d %d\\n\u0026quot;, x, y)\n#define pfiii(x, y, z) printf(\u0026quot;%d %d %d\\n\u0026quot;, x, y, z)\n#define pfl(x) printf(\u0026quot;%lld\\n\u0026quot;, x)\n#define pfll(x, y) printf(\u0026quot;%lld %lld\\n\u0026quot;, x, y)\n#define pflll(x, y, z) printf(\u0026quot;%lld %lld %lld\\n\u0026quot;, x, y, z)\n\n#define eps 1e-9\n#define OK cerr \u0026lt;\u0026lt; \u0026quot;ok\\n\u0026quot;\n#define DB(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026quot; \u003d \u0026quot; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair \u0026lt;int, int\u0026gt; pii;\n\ninline int setBit(int N, int pos) { return N\u003dN | (1\u0026lt;\u0026lt;pos); }\ninline int resetBit(int N, int pos) { return N\u003d N \u0026amp; ~(1\u0026lt;\u0026lt;pos); }\ninline bool checkBit(int N, int pos) { return (bool)(N \u0026amp; (1\u0026lt;\u0026lt;pos)); }\n\n//int kx[] \u003d {+2, +1, -1, -2, -2, -1, +1, +2};\n//int ky[] \u003d {+1, +2, +2, +1, -1, -2, -2, -1}; //Knight Direction\n//int fx[] \u003d {+0, +0, +1, -1, -1, +1, -1, +1};\n//int fy[] \u003d {-1, +1, +0, +0, +1, +1, -1, -1}; //Four \u0026amp; Eight Direction\n\n\nconst int MAX \u003d 100005;\nconst LL MOD \u003d 1000000007;\nint n;\nvector \u0026lt; pair \u0026lt;int, LL\u0026gt; \u0026gt; graph[MAX];\nLL wisi[MAX], dp[MAX], subtree[MAX];\n\nvoid dfs(int u, int par\u003d-1) {\n    subtree[u] \u003d 1;\n    wisi[u] \u003d 0;\n    for(auto v:graph[u]) {\n        if(v.uu !\u003d par) {\n            dfs(v.uu, u);\n            subtree[u] +\u003d subtree[v.uu];\n            wisi[u] +\u003d wisi[v.uu];\n            if(wisi[u] \u0026gt;\u003d MOD) wisi[u] -\u003d MOD;\n            wisi[u] +\u003d (v.vv*subtree[v.uu]) % MOD;\n            if(wisi[u] \u0026gt;\u003d MOD) wisi[u] -\u003d MOD;\n        }\n    }\n}\n\nvoid dfs1(int u, int par\u003d-1) {\n    dp[u] \u003d 0;\n    for(auto v:graph[u]) {\n        if(v.uu !\u003d par) {\n            dfs1(v.uu, u);\n            LL temp \u003d v.vv*subtree[v.uu];\n            temp %\u003d MOD;\n            temp *\u003d (subtree[u]-subtree[v.uu]);\n            temp %\u003d MOD;\n            dp[u] +\u003d temp;\n            if(dp[u] \u0026gt;\u003d MOD) dp[u] -\u003d MOD;\n            dp[u] +\u003d dp[v.uu];\n            if(dp[u] \u0026gt;\u003d MOD) dp[u] -\u003d MOD;\n            dp[u] +\u003d ((wisi[v.uu] * (subtree[u]-subtree[v.uu])) % MOD);\n            if(dp[u] \u0026gt;\u003d MOD) dp[u] -\u003d MOD;\n        }\n    }\n}\n\nint main() {\n//    assert(freopen(\u0026quot;large_in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin));\n//    assert(freopen(\u0026quot;large_out.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout));\n\n    clock_t st \u003d clock();\n\n    int test, kase\u003d1, i, u, v;\n    LL w;\n\n    sdi(test);\n    while(test--) {\n        sdi(n);\n        rep(i, n) graph[i].clear();\n        rep(i, n-1) {\n            sdii(u, v);\n            sdl(w);\n            u--, v--;\n            graph[u].pb({ v, w });\n            graph[v].pb({ u, w });\n        }\n        dfs(0);\n        dfs1(0);\n        LL ans \u003d 0;\n        rep(i, n) {\n            ans +\u003d dp[i];\n            if(ans \u0026gt;\u003d MOD) ans -\u003d MOD;\n        }\n        printf(\u0026quot;Case %d: %lld\\n\u0026quot;, kase++, ans);\n    }\n\n    clock_t en \u003d clock();\n    fprintf(stderr, \u0026quot;%.3f sec\\n\u0026quot;, (double)(en-st)/(double)CLOCKS_PER_SEC);\n\n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTester\u0027s Solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define D(x)\tcout \u0026lt;\u0026lt; #x \u0026quot; \u003d \u0026quot; \u0026lt;\u0026lt; (x) \u0026lt;\u0026lt; endl\n#define uu\t\tfirst\n#define cost\tsecond\n#define MOD\t\t1000000007\n#define MAX\t\t100000\ntypedef pair\u0026lt;int,int\u0026gt; pii;\ntypedef long long int LL;\n\nvector\u0026lt; pii \u0026gt; edge[MAX+5];\n\n\nLL lsum[MAX+5], cnt[MAX+5], dp[MAX+5], ans[MAX+5];\n\nvoid dfs(int idx, int p)\n{\n\tLL c \u003d 0;\n\tlsum[idx] \u003d ans[idx] \u003d cnt[idx] \u003d dp[idx] \u003d 0;\n\n\tfor(auto x : edge[idx])\n\t\tif(x.uu !\u003d p)\n\t\t{\n\t\t\tdfs(x.uu, idx);\n\t\t\tc +\u003d (cnt[x.uu] + 1);\n\t\t}\n\n\tfor(int i \u003d 0; i \u0026lt; (int) edge[idx].size(); i++){\n\t\tint x \u003d edge[idx][i].uu;\n\t\tint w \u003d edge[idx][i].cost;\n\n\t\tif(x \u003d\u003d p) continue;\n\t\tcnt[idx] \u003d (cnt[idx] + cnt[x] + 1) % MOD;\n\t\tint current \u003d (lsum[x] + (w * (cnt[x] + 1)))% MOD;\n\n\t\tlsum[idx] \u003d (lsum[idx] + current) % MOD;\n\t\tdp[idx] \u003d (dp[idx] + (current * (c - (cnt[x] + 1) + 1)) % MOD) % MOD;\n\t\tans[idx] \u003d (ans[idx] + ans[x]) % MOD;\n\t}\n\tans[idx] \u003d (ans[idx] + dp[idx]) % MOD;\n}\n\nint main()\n{\n//\tassert(freopen(\u0026quot;large_in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin));\n//\tassert(freopen(\u0026quot;large_out_alter.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout));\n\n\tint t, cs, i, u, v, w, n;\n\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;t);\n\n\tfor(cs \u003d 1; cs \u0026lt;\u003d t; cs++){\n\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\n\t\tfor(i \u003d 1; i \u0026lt; n; i++)\n\t\t{\n\t\t\tscanf(\u0026quot;%d %d %d\u0026quot;, \u0026amp;u, \u0026amp;v, \u0026amp;w);\n\t\t\tedge[u].push_back(make_pair(v, w));\n\t\t\tedge[v].push_back(make_pair(u, w));\n\t\t}\n\n\t\tdfs(1, -1);\n\t\tLL ttl \u003d 0;\n\t\tfor(i \u003d 1; i \u0026lt;\u003d n; i++) ttl \u003d (ttl + ans[i]) % MOD;\n\t\tprintf(\u0026quot;Case %d: %d\\n\u0026quot;, cs, (int) ttl);\n\n\t\tfor(i \u003d 1; i \u0026lt;\u003d n; i++) edge[i].clear();\n\t}\n\treturn 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["nhspc","school olympiad","ioi","editorial","tutorial"]}}