{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1495457735,"rating":3,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1495457914,"id":52119,"title":"\u003cp\u003eNotes on Codeforces Beta Round #47, A, B, C, D(Precision-guaranteed Binary Search), E(Interval Coverage)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA. Domino piling\u003c/p\u003e\u003cp\u003eIf at least one of M and N is an even number, then the answer will be m*n/2; otherwise exactly one square cannot be covered, and gives (m*n-1)/2 as the answer. Nevertheless, by using integer division, m*n/2 will give the correct result for both the case.\u003c/p\u003e\u003cp\u003eB. Choosing Symbol Pairs\u003c/p\u003e\u003cp\u003eFor a given string, we should calculate how many times a character has appeared in it. If a character \u0027c\u0027 has appeared for a[c] times, then the answer is just the sum of a[c]*a[c] where all the characters that have appeared should be considered.\u003c/p\u003e\u003cp\u003eC. Happy Farm 5\u003c/p\u003e\u003cp\u003eAt first, I chose to \u0026quot;scan\u0026quot; first from left to right, and then from right to left, and during this process, I tried to find out the convex hull and record its length. However, this kept failing even though I have tried a lot of times...\u003c/p\u003e\u003cp\u003eFinally, I studied the codes from the other coders, and found out that most of them had used a quite simple method. The main idea is to first draw two lines with -45 degree, and one of them should pass the most upper right point while the other one should pass the most bottom left point. Similarly, we draw another two lines with +45 degree, and let one of them pass the most upper left point while the other one pass the most bottom right point. These four lines will form a rectangular (this is not always true, for instance if only one point exists, however it does not affect the following results), and the answer is just the perimeter plus 4. This works from an intuitive understanding, however I cannot figure out how to prove that it always works.\u003c/p\u003e\u003cp\u003eD. Bombing\u003c/p\u003e\u003cp\u003eI think two programming techniques are involved in this problem. \u003c/p\u003e\u003cp\u003e1) For given N events and the probabilities that each of them occurs, how to calculate the probability that at least K of them occur? A direct enumeration might fail since C(N,K), which means the number of diffierent ways to choose K elements from N elements, turns out to be quite large even for N\u003d100 and K\u003d50. An efficient solution is to use Dynamic Programming to calculate the result. We use Pr[n][m] to denote the probability that among the n events, exactly m of them occur. One can check that this can be computed according to the recursion \u003c/p\u003e\u003cp\u003ePr[n][m]\u003dPr[n-1][m-1]*p[n]+Pr[n-1][m]*(1-p[n])\u003c/p\u003e\u003cp\u003ewhere p[n] denotes the probability that the n-th event occurs. With this recursion, we can calculate Pr[i][j] for every feasible i and j. Then, the required result is Pr[N][K]+Pr[N][K+1]+...+Pr[N][N].\u003c/p\u003e\u003cp\u003e2) Binary serach with required precision. The problem asks to compute the minimum radius R which can meet the requirement. We can start with R1\u003d0 and R2\u003d4000, and then check Rm\u003d(R1+R2)/2 and update the values for the next loop according to the current results. The frequently used termination condition in binary search, i.e., the value that we have found out is exactly equal to the target value, cannot work successfully if we are dealing with \u0026quot;float\u0026quot; number rather than \u0026quot;integer\u0026quot; number. Instead, we can limit the maximum number of implementing the binary search to achieve a similar effect. If we set the maximum number of binary search to T, then the total search space M has been divided into 2^T intervals and each of them has length M/(2^T). To achieve the precision requirement, for instance, an absolute inaccuracy less than some E, we can just choose an appropriate value of T which can satisfy that M/(2^T)\u0026lt;\u003dE.\u003c/p\u003e\u003cp\u003eE. Square Equation Roots\u003c/p\u003e\u003cp\u003eAt first, we write the roots as -b+sqrt(b^2-c) and -b-sqrt(b^2-c), and consider the conditions under which two different pairs (b1,c1) and (b2,c2) can have at least one same root. Suppose that -b1+sqrt(b1^2-c1) and -b2+sqrt(b2^2-c2) are the same. If both sqrt(b1^2-c1) and sqrt(b2^2-c2) are not rational numbers, then we must have b1\u003db2 and b1^2-c1\u003db2^2-c2, which gives that b1\u003db2 and c1\u003dc2. Therefore, no different pairs of (b1,c1) and (b2,c2) can have at least one same root unless both sqrt(b1^2-c1) and sqrt(b2^2-c2) are rational numbers. \u003c/p\u003e\u003cp\u003eWith the above arguments, for each b, any c that results in an irrational value of sqrt(b^2-c) will contribute two different roots, while for the other c, their roots will form two integer intervals as we will see later. Therefore, we can first implement a loop for b, and for each b, we adopt the following steps:\u003c/p\u003e\u003cp\u003e1) Compute the maximum value that c can take, i.e., c\u0026lt;\u003dc_min\u003dmin(b^2,m);\u003c/p\u003e\u003cp\u003e2) Compute all the feasible c that can result in a rational value of sqrt(b^2-c); suppose that x^2\u003db^2-c, then c\u003db^2-x^2, and thus 1\u0026lt;\u003db^2-x^2\u0026lt;\u003dc_min, which gives ceil{sqrt(b^2-c_min)}\u0026lt;\u003dx\u0026lt;\u003db-1; if ceil{sqrt(b^2-c_min)}\u0026lt;\u003db-1, we will have num2\u003db-1-ceil{sqrt(b^2-c_min)}+1 values of c that leads to a rational value of sqrt(b^2-c);\u003c/p\u003e\u003cp\u003e3) For those values of c that lead to an irrational value of sqrt(b^2-c), they will contribute 2*(c_min-num2) different roots to the final answer; while for the other values of c, it can be seen that the roots are -b+x and -b-x, with x belonging to [ceil{sqrt(b^2-c_min)}, b-1]; for convience, we can add 2b to the original roots to \u0026quot;move\u0026quot; all the intervals to the right so that we can adopt a hash table to record the intervals; therefore, we have obtained two intervals [b+ceil{sqrt(b^2-c_min)}ï¼Œ b+b-1] and [b-(b-1), b-ceil{sqrt(b^2-c_min)}], which just give the corresponding roots;\u003c/p\u003e\u003cp\u003e4) As we can have at most 5000000 values of b, it will cost a huge complexity if we \u0026quot;map\u0026quot; each point of an interval into the hash table; instead, for some interval [S,T], we can just set H[S]++ and H[T+1]--, where H[ ] denotes the hash table; when all the intervals have been processed, we scan from the start of the hash table to the end and calculate the prefix sum; the number of non-zero prefix sum is just the number of different points that all the intervals can cover up; intuitively, H[S]++ means that a new interval has began at point S while H[T+1]-- implies that some interval has just terminated at point T+1; whenever the prefix sum is larger than zero, it means that the current point is still covered by at least one interval.\u003c/p\u003e\u003c/div\u003e","tags":[]}}