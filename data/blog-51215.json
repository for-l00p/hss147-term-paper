{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1490496231,"rating":6,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1490496300,"id":51215,"title":"\u003cp\u003eSolutions to Codeforces Beta Round #30, A, B, C\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eA. Accounting\u003c/p\u003e\u003cp\u003eThis problem asks to find out a feasible solution to the equation A*X^n\u003dB. This can be solved based on the following cases:\u003c/p\u003e\u003cp\u003e1) A\u003d0, B!\u003d0: this results in no solution;\u003c/p\u003e\u003cp\u003e2) A\u003d0, B\u003d0: any integer can serve as a feasible solution;\u003c/p\u003e\u003cp\u003e3) A!\u003d0, B%A!\u003d0: this leads to no solution;\u003c/p\u003e\u003cp\u003e4) A!\u003d0, B%A\u003d0, A*B\u0026lt;0, n%2\u003d0: this means that X^n should be a negative integer, however this is impossible since any X^n with n%2\u003d0 must be a positive integer;\u003c/p\u003e\u003cp\u003e5) A!\u003d0, B%A\u003d0, A*B\u0026lt;0, n%2\u003d1: this is equivalent to finding out a solution to A*X^n\u003d(-B), which turns out to be case 6);\u003c/p\u003e\u003cp\u003e6) A!\u003d0, B%A\u003d0, A*B\u0026gt;0: as both the values of A and B are limited to be less than 1000, we can enumerate X from 1 in an increasing order until A*X^n\u0026gt;\u003dB is satisfied. Then, for this X, by checking whether A*X^n\u003dB holds or not, we can obtain the final answer.\u003c/p\u003e\u003cp\u003eB. Codeforces World Finals\u003c/p\u003e\u003cp\u003eThis problem is a little complicated to deal with. To obtain the final answer, we have to check all the feasible 3*2*1\u003d6 dates when Bob \u0026quot;can be born\u0026quot;. As the number of permutation is rather small, we can previously generate it with an array \u003c/p\u003e\u003cp\u003eint permutation[6][3]\u003d{  {0,1,2},  {0,2,1},  {1,0,2},  {1,2,0},  {2,0,1},  {2,1,0}  };\u003c/p\u003e\u003cp\u003eto simplify the following operations. Besides, we can store the number of days in each month by using two arrays as well, one for leap year and one for nonleap year: \u003c/p\u003e\u003cp\u003eint nonleap[12]\u003d{31,28,31,30,31,30,31,31,30,31,30,31};\u003c/p\u003e\u003cp\u003eint leap[12]\u003d{31,29,31,30,31,30,31,31,30,31,30,31};\u003c/p\u003e\u003cp\u003eFor each feasible permutation, we generate the birthday of Bob, and first check whether the month is between 1 and 12, and then check whether the day is between 1 and the last date of this month, to guarantee that this is a reasonable birthday. Then, we compare it with the date of the final. The comparison can be implemented in the order of year, month and day. Take care that all the above operations should be implemented for leap year and nonleap year, respectively.\u003c/p\u003e\u003cp\u003eC. Shooting Gallery\u003c/p\u003e\u003cp\u003eAt first, we should sort all the targets in an increasing order of the time of their appearance. From now on, we assume that the sorting has been completed and the following arguments are all based on the sorted targets.\u003c/p\u003e\u003cp\u003eThen, we can solve the problem based on dynamic programming. It asks to compute the maximum expected value of the amount of targets, and this is in fact equivalent to finding out the the maximum sum of pi we can obtain. We use f[n] to denote the maximum sum of pi we can obtain when the n-th target is exactly hit. Then, we consider what might happen before the n-th target is hit. We can directly aim at the n-th target from the first start while skipping the previous n-1 targets. Besides, we might have hit the i-th target, where i\u0026lt;n, and immediately move to the n-th target. Therefore, f[n] can be calculated in the following manner. For each f[i], i\u0026lt;n, we calculate the time it takes to move from target-i to target-n, and if this time is shorter than the interval between which they appear before and after, we compare f[i]+p[n] with the current value of f[n], and select the larger one to update f[n]. Do not forget that we can aim at the n-th target from the first start. Thus, f[n] cannot be less than p[n], and p[n] can just be used to initialize the value of f[n].\u003c/p\u003e\u003cp\u003eFinally, we find out the maximum one of f[1],f[2],...,f[n], and it just serves as the answer.\u003c/p\u003e\u003c/div\u003e","tags":["dynamic programming"]}}