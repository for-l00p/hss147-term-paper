{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1490192110,"rating":4,"authorHandle":"usernameson","modificationTimeSeconds":1490192380,"id":51141,"title":"\u003cp\u003elambda expressions and pairs\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003eIntroduction\u003c/h4\u003e\u003cp\u003eIn this entry I will show how to use lambda expressions to deal with a fairly common situation that arises in problems. Also this post is specific to C++ 11 and beyond where lambda expressions were introduced to the language.\u003c/p\u003e\u003ch4\u003eThe Situation\u003c/h4\u003e\u003cp\u003eSometimes in problems it is natural to store inputs in pairs. For example it may be important to keep track of both the size of an element and where it occurs in the input; or when an element has two important attributes. This usually results in a vector of pairs. Next it can be useful to apply an algorithm to this vector of pairs and this where lambda expressions shine.\u003c/p\u003e\u003ch4\u003eAn Example\u003c/h4\u003e\u003cp\u003eFor an example problem I will use the codeforces problem The Meeting Place Cannot Be Changed \u003ca href\u003d\"//codeforces.com/problemset/problem/780/B\"\u003ehttp://codeforces.com/problemset/problem/780/B\u003c/a\u003e. The idea of the problem is you have people at n points who each have a maximum speed and who want to meet. You have to figure out the minimum time they can meet. My solution is interesting for three reasons. Firstly and most importantly it uses a lambda expression to sort a vector of pairs. Secondly the approach differs from the editorial approach. Thirdly, the solution passes the system tests but I have a suspicion a specific type of example would cause it to exceed the maximum time limit.\u003c/p\u003e\u003ch4\u003eMy approach\u003c/h4\u003e\u003cp\u003eI started with the basic observation the shortest time any two given people can meet is equal to the distance between them divided by the sum of their max speeds. To keep track of peoples max speeds and positions I stored them as a pair and placed the results in a vector of pairs. Next I concluded that the minimum time all people can meet is the maximum of all the shortest times any two people can meet. Of course at this point I tried to brute force all pairs and exceeded the time limit. To speed up a solution I came up with a way to eliminate some pairs while still getting the same result. To do this I used the basic observation if we have three people p1, p2 and p3 ordered in increasing starting coordinates if p1 is slower than p2 it will take longer for p1 to reach p3 than for p2 to reach p3. This means we can ignore the case of p2 getting to p3 in our calculation. At this point I used a lambda expression to sort the pairs in order of increasing starting points. Then I divided the pairs into two groups. For one group I stored the leftmost pair and all pairs to the right of it that had a lower speed than the leftmost pair. For the other group I stored the rightmost pair and all pairs to the left of it that had a lower speed than the rightmost pair. Next I used the brute force approach from before with pairs where the first element was in one group and the second element in the other. I expected some test to appear where half the elements are in the first group and the other half in the second group resulting in the time limit being exceed. This did not happen and the solution was successful. \u003c/p\u003e\u003ch4\u003eCode\u003c/h4\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;vector\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n#include\u0026lt;iomanip\u0026gt;\n#include\u0026lt;utility\u0026gt;\n\nusing namespace std;\nint main(){\n    int n;\n    cin\u0026gt;\u0026gt;n;\n    vector\u0026lt;int\u0026gt; x,v;\n\n    //store positions and speeds\n    for(int i\u003d0; i\u0026lt;n; i++){\n        int a;\n        cin\u0026gt;\u0026gt;a;\n        x.push_back(a);\n    }\n    for(int j\u003d0; j\u0026lt;n; j++){\n        int b;\n        cin\u0026gt;\u0026gt;b;\n        v.push_back(b);\n    }\n    \n    //store positions and speeds together in a vector pair\n    vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; xv;\n    for(int i\u003d0; i\u0026lt;n; i++){\n        xv.push_back(make_pair(x[i], v[i]));\n    }\n    \n\n    //the lambda expression\n    sort(xv.begin(), xv.end(), [](pair\u0026lt;int,int\u0026gt; vp, \n    pair\u0026lt;int,int\u0026gt; vp2){return vp.first\u0026lt;vp2.first;});\n    \n    vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; lc,rc;\n    \n\n    //splitting into the groups described\n    int vm\u003dxv[0].second;\n    lc.push_back(xv[0]);\n    for(auto p:xv){\n        if(p.second\u0026lt;vm){\n            vm\u003dp.second;\n            lc.push_back(p);\n        }\n        \n    }   \n\n\n    rc.push_back(xv[n-1]);\n    int vm2\u003dxv[n-1].second;\n    for(int i\u003dn-2; i\u0026gt;0; i--){\n        if(xv[i].second\u0026lt;vm2){\n            vm2\u003dxv[i].second;\n            rc.push_back(xv[i]);\n        }\n    }\n    \n    //brute forcing the groups\n    double ans\u003d0;\n    for(auto p:lc){\n        for(auto p2:rc){\n            double d\u003d(double)abs(p.first-p2.first)/(p.second+p2.second);\n            ans\u003dmax(ans,d);\n        }\n    }\n   \n    cout\u0026lt;\u0026lt;setprecision(15)\u0026lt;\u0026lt;ans;\n    \n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003eFinal Comments\u003c/h4\u003e\u003cp\u003eThere are many other approaches to this situation that do not require lambda expressions with pairs. You could create your own class with its own methods or overloaded operators for interacting with STL algorithms. You could define a function, function object or overloaded operator that takes two pairs as arguments and use STL algorithms with these. However, once you understand the syntax for writing simple lambda expressions to use with STL algorithms I think you will find they are the least tedious of all options to code. \u003c/p\u003e\u003c/div\u003e","tags":["lambda expressions","brute force","language features","c++"]}}