{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1463717759,"rating":-1,"authorHandle":"CF2_kafuma","modificationTimeSeconds":1463717759,"id":44970,"title":"\u003cp\u003eHelp in 671B\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003ei was create a algorithm to solved 671B and i did that:\u003c/p\u003e\u003cp\u003ethat running with O( n*log(n) ) { well, i think so } but th judgement gave \u0026quot;RunTime_ERROR\u0026quot;, why do you think??? and how can i better my algorithm??\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n#include\u0026lt;stdio.h\u0026gt;\n\nusing namespace std;\n/*\n    1) idead: using two priority queue to recover the Max and Min values and subtraccion each other.\n        time \u003d\u0026gt; O( n*log(n)*k )--\u0026gt; can swap values max and min on Minimo and Maximo,\n\n    2) idead : using a map tree to sort all values and operate on tree\n        time \u003d\u0026gt; O( n*log( n ) + K*log( n ) ) --\u0026gt; find max/min in O( log(n) )\n\n    3) using range of values are diference between min again this value, and operate using range to reduce\n       K on the time.\n       time \u003d\u0026gt; O( n*log^2( n ) )\n\n*/\nunsigned int Rango \u003d 1;\nunsigned int x \u003d 0;\nunsigned int K \u003d 0;\nunsigned int N \u003d 0;\nunsigned int Mover \u003d 0;\nunsigned int Mayor, Menor;\nunsigned int LimiteMx, LimiteMn;\n\n\nunsigned int Civiles[ 500000 ];\n\nunsigned int BuscarSgte(){\n    int fin \u003d N -1 ; int inicio \u003d 0;\n    int medio \u003d (N - 1)/2;\n\n    while( fin !\u003d inicio + 1 ){\n            if( Civiles[ medio ] \u0026gt; Civiles[ 0 ] ) fin \u003d medio;\n            else if( Civiles[ medio ] \u003d\u003d Civiles[ 0 ] \u0026amp;\u0026amp; Civiles[ medio + 1] \u003d\u003d Civiles[ 0 ] ) inicio \u003d medio;\n            else break;\n            medio \u003d ( fin + inicio )/2;\n    }\n\n    return ( Civiles[ medio + 1 ] \u003d\u003d Civiles[0] )? medio + 1 : medio ;\n}\n\nunsigned int BuscarAnterior(){\n    int medio \u003d (N-1)/2;\n    int fin \u003d N - 1; int inicio \u003d 0;\n\n    while( fin !\u003d 1 + inicio ){\n        if( Civiles[ medio ] \u0026lt; Civiles[ N - 1 ])\n            inicio \u003d medio;\n        else if( Civiles[ medio ] \u003d\u003d Civiles[ N - 1 ] \u0026amp;\u0026amp; Civiles[ medio - 1 ] \u003d\u003d Civiles[ N - 1 ] )\n            fin \u003d medio;\n        else\n            break;\n\n        medio \u003d ( fin + inicio ) / 2;\n    }\n\n    return ( Civiles[ medio ] \u003d\u003d Civiles[ N - 1] )? medio: medio + 1;\n\n}\n\nvoid Actualizar(  int Mn, int Mx , int Base ){\n    for( int i \u003d 0; i \u0026lt; Base ; i++ ){\n        Civiles[ Mn - i ] +\u003d 1;\n        Civiles[ Mx + i ] -\u003d 1;\n    }\n}\n\nint main()\n{\n\n    scanf(\u0026quot;%i %i\u0026quot;, \u0026amp;N , \u0026amp;K );\n\n    for( int i \u003d 0; i \u0026lt; N; i++ ){\n        scanf(\u0026quot;%i\u0026quot;, \u0026amp;Civiles[i] );\n    }\n\n    sort(Civiles, Civiles+N);\n\n    while( K \u0026gt; 0 ){\n        if( Civiles[ 0 ] + 1 \u003d\u003d Civiles[ N - 1 ] || Civiles[0] \u003d\u003d Civiles[ N - 1 ] ) break;\n\n        LimiteMx \u003d BuscarAnterior();\n        LimiteMn \u003d BuscarSgte();\n\n        Mayor \u003d ( N - LimiteMx )*( Civiles[  N - 1 ] - Civiles[ LimiteMx - 1 ] );\n        Menor \u003d ( LimiteMn + 1 )*( Civiles[ LimiteMn + 1 ] - Civiles[ 0 ] );\n\n        Mover \u003d min( Menor, Mayor );\n        if( K \u0026lt;\u003d Mover ){\n            Actualizar( LimiteMn , LimiteMx , K );\n            K \u003d 0;\n        }else{\n            Actualizar( LimiteMn, LimiteMx , Mover );\n            K \u003d K - Mover;\n        }\n\n    }\n\n    cout \u0026lt;\u0026lt;  Civiles[ N - 1 ] - Civiles[ 0 ] ;\n\n\n    return 0;\n}\n\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["671b","algorithm"]}}