{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1477018996,"rating":23,"authorHandle":"haleyk100198","modificationTimeSeconds":1477021435,"id":47898,"title":"\u003cp\u003eCodeforces Round #377 Problem analysis (Unofficial)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eSince the official editorial is yet to be released and people are starting to ask for editorial, I decide to write this problem analysis and hopefully this may help the situation. \u003d]\u003c/p\u003e\u003cp\u003eSorry for my bad English if I made some grammatical mistakes.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/732/A\"\u003e732A. Buying a shovel\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eWe could simulate the buying process — just buy until you can buy without change.\u003c/p\u003e\u003cp\u003eAs the problem statement have already stated, you can always buy 10 shovels without change, so there is at most 10 iterations.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/732/submission/21587769\"\u003eC++ solution\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/732/problem/C\"\u003e732B. Cormen — The Best Friend Of a Man\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eIterate the days from left to right, and increase the days greedily on the right to fulfill the requirement. Take a look at this figure if you don\u0027t understand why this doesn\u0027t know why this works.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" 732 example \" src\u003d\"/predownloaded/5d/38/5d389f2e20103775a0869ea81d0333bdc4de9490.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s say we are deciding to whether increase the days on A or B to make the total walks on those days become \u0026gt;\u003d k. As we are iterating from left to right the blocks to the left are guaranteed to have already fulfilled the requirement. You can see that placing extra walks on day A will be less beneficial, as placing extra walks on day B could possibly help out the block day B and day B+1.\u003c/p\u003e\u003cp\u003eTime complexity: O(N)\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/732/submission/21587712\"\u003eC++ Solution\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/732/problem/C\"\u003e732C. Sanatorium\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLet\u0027s start from scratch, assume that we start and end our vacation before, what is the solution? Let MAX be the most ate meal throughout the vacation, we have to stay at least MAX days to eat enough meals, so the answer is 3*MAX — (sum of meals).\u003c/p\u003e\u003cp\u003eNow we come back to our question — how about if can start and end at anytime? With a little bit of imagination you can see that we could have an extra (or have one less) meal of any combination. As we have discovered before, the solution is 3*MAX — (sum of meals), so we have to greedily reduce the number of MAX to find out the minimal solution.\u003c/p\u003e\u003cp\u003eTime complexity: O(1)\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/732/submission/21610816\"\u003eC++ Solution\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/732/problem/D\"\u003e732D. Exams\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eThe major observation is that the solution is monotonic — if we can complete all the exam on day X, then we can always complete it using more than X days.\u003c/p\u003e\u003cp\u003eThat means we can use binary search to search for the answer. The problem reduces to how to check if one can pass all the exam by day X. We can solve this problem by greedy — Sort all the subjects by the latest date you can take the exam, since we are only checking if you can pass all exams by day X, therefore it is always \u0026quot;safer\u0026quot; to take a late examination instead of an early one. Then, we check if there are enough days for revisioning and taking the examination.\u003c/p\u003e\u003cp\u003eIf there is no solution in the range [1,n], print -1.\u003c/p\u003e\u003cp\u003eTime Complexity: O(N*logN*logM)\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/732/submission/21611387\"\u003eC++ Solution\u003c/a\u003e \u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/732/problem/E\"\u003e732E. Sockets\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eDefine S{X} be the power achievable by adding adapters on a socket that has a power X. One could observe that if power Y is in the set S{X}, then S{Y} is a subset by S{X}. Secondly, you are going to use less or equal adapters if you use socket Y instead of socket X.\u003c/p\u003e\u003cp\u003eUsing these observations, we can solve this problem by greedy (you should be familiar with it by now). Sort the power of the sockets from small to large, and add adapters on the sockets until you find a suitable computer. This guarantees we are using the least amount of adapters while plugging in the most amount of computers.\u003c/p\u003e\u003cp\u003eTime complexity: O(NlogN)\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/732/submission/21611889\"\u003eC++ Solution\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"//codeforces.com/contest/732/problem/F\"\u003e732F. Tourist Reform\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eWe are going to break down the problem with these observations:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eEach connecting components should be considered individually — It is obvious that cities that are not connected (directly or indirectly) are not going to affect each other\u0027s Ri value.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eEach biconnected components could be grouped together — we won\u0027t have problem with reaching from city U to V and back to U if we create a cycle by the biconnected components.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eEach biconnected components will also have other edges linked with it, and they will either become pointing inwards or outwards. As the biconnected components are not biconnected with other components (or else we will just group it), it is guaranteed that \u003cstrong\u003eone of the biconnected components will have all it edges connecting to others pointing inwards.\u003c/strong\u003e\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eThe last observation is significant as it tells out that the solution for each connected component is the size of the largest biconnected component, as it is without doubt the best candidate to have all the edges pointing inwards to it. This also means that the solution is the minimum among all the connected components.\u003c/p\u003e\u003cp\u003eIn order to find out the biconnected components you can use the Tarjan algorithm. I strongly recommend you to learn it if you haven\u0027t, and practice it on this question. \u003ca href\u003d\"//codeforces.com/problemset/problem/652/E\"\u003e652E. Pursuit For Artifacts\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe problem now reduces to how to allocate the direction of edges, from our observations we should allocate them in such way:\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eBuild cycles in each biconnected components.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eMake sure the largest biconnected components is the only one who has all edges pointing towards it in each connected components.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eA simple way to complete the task is to initialize dfs from each largest biconnected components, and order the edges in revrese (i.e. from child to their parents).\u003c/p\u003e\u003cp\u003eTime complexity: O(N+M), O(N+MlogM) if you use maps to store the ID of each edge.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/732/submission/21613253\"\u003eC++ solution in O(N+MlogM)\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}