{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1490773127,"rating":-13,"authorHandle":"usernameson","modificationTimeSeconds":1490780911,"id":51299,"title":"\u003cp\u003eMax Flow Implementation\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003eOverview\u003c/h4\u003e\u003cp\u003eIn this post I will explain with an example one way to code the Edmonds Karp max flow algorithm to solve a problem.\u003c/p\u003e\u003ch4\u003eThe Problem\u003c/h4\u003e\u003cp\u003eThe problem we study is Array and Operations \u003ca href\u003d\"//codeforces.com/problemset/problem/498/C\"\u003ehttp://codeforces.com/problemset/problem/498/C\u003c/a\u003e. The basic idea is you have a sequence of numbers and a bunch of special pairs taken from the sequence. For any of the pairs you can divide each number by a common factor greater than 1 and replace the elements in the pair with the result of this division. The question asks what is the maximum number of times you can do this.\u003c/p\u003e\u003ch4\u003eConverting this to a max flow problem\u003c/h4\u003e\u003cp\u003eThis section is specific to the problem. You can skip it if you just want to know how to implement Edmonds Karp on a given flow network.\u003c/p\u003e\u003cp\u003eBefore we convert this problem to a max flow problem we make some observations. First if we have a pair of numbers the maximum amount of times we can perform the operation described on this pair is equal to the number of prime divisors the pair have in common counting multiplicity (i.e if the same prime divides the pair multiple times we count it multiple times). Next we note this is the same as the number of prime divisors in the greatest common divisor of the pair counting multiplicity.\u003c/p\u003e\u003cp\u003eNext assume we have one number that is paired with multiple other numbers. Then to find the maximum number of times we can perform the operation on this number we first find the gcd between it and it first pairing. Then we count the number of prime divisors in this gcd. Next we replace the original number by the original number divided by the gcd found and repeat the process with the second pairing. We could instead find the gcd of the number and the product of all the numbers paired with it and then count the prime divisors of this gcd to get the same result. However this approach may lead to overflow issues.\u003c/p\u003e\u003cp\u003eNow for any given number we know how to count maximum the number of times we can perform the operation on a pair and the maximum number of times we can perform this operation on the number in total. If we think of the flow as the maximum number of times we can perform the operation we can construct a flow network as follows. We let each number that appears in special pair have two nodes associated with it. Call them the left node and the right node. The left node has a directed edge running from the source to it with a capacity equal to the maximum number of times the operation can be performed on this number in total. The right node has a directed edge running from it to the the sink with the same capacity. Next for each number in a special pair we connect its left node to the right node of the number with which it is paired with a directed edge from left to right with capacity equal to the number of times we can perform the operation on this pair. This gives us our flow network. We also mention it is different from the flow network given in the editorial but it also works. \u003c/p\u003e\u003cp\u003eOf course to do all this we need functions to calculate the number of prime divisors and greatest common divisors. For calculating the greatest common divisor the Euclidean algorithm is fairly easy to implement. Since the numbers given can go up to \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e calculating the number of prime divisor is harder. One approach is to calculate all primes up to 1000 by brute force. Then we can use those as a sieve to get all primes up to 32000. Finally since \u003cspan class\u003d\"tex-span\"\u003e32000\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e \u0026gt; 10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e with all these primes we can find the number of prime divisors for any number up to \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e.\u003c/p\u003e\u003ch4\u003eSet up three graphs\u003c/h4\u003e\u003cp\u003eNow that we have our network and edge capacities we create three graphs. We store these in adjacency matrix form we can use a 2 dimensional array or a vector\u0026lt;vector\u0026gt; here. The first graph is the flow where all entries are set to 0. The second graph is the residual where all the edge values are set to the capacity. Finally the third graph is the network graph where we have a 1 if two edges are connected and 0 otherwise.\u003c/p\u003e\u003ch4\u003eFind an augmenting path\u003c/h4\u003e\u003cp\u003eNext we create a function to find an augmenting path that returns pair\u0026lt;int,vector\u0026gt; where the first term is the capacity and the second is the path. To do this we perform a breadth first search starting from the source. We only need to store the predecessor of each vertex and not the distance. With the predecessors it is easy to find a path by back tracking from the sink. If there is no path we just return an empty pair and deal with it later when we augment along the path. Next we find the capacity of the path by taking the minimum of all capacities of edges included in the path. \u003c/p\u003e\u003ch4\u003eAugmenting along the path\u003c/h4\u003e\u003cp\u003eNext we create a function that takes the path we found before and update both the flow and the residual. It is useful to let this function return a bool which if true if we made an update and false otherwise. First we call our previous function to find a path. If the path is an empty pair we return false. Otherwise take an edge from point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e in the path. For the residual we decrease the capacity of the edge from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e by the capacity of the path and increase the capacity of the edgy from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e by the capacity of the path. For the flow we if the edge from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e is in the network graph we increase the flow from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e by the capacity of the path otherwise we decrease the capacity of the flow from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e by the capacity of the path. We do this for all edges in the path then return true.\u003c/p\u003e\u003ch4\u003eFinding the maximal flow\u003c/h4\u003e\u003cp\u003eTo find the maximal flow we just keep calling the augment function until it returns false.\u003c/p\u003e\u003ch4\u003eFind the answer\u003c/h4\u003e\u003cp\u003eTo find the answer we first find the total flow by adding all the flows leaving the source. We could also have stored total flow as we were augmenting. Finally to get the answer we divide the total flow by since our network counts the application of each operation twice.\u003c/p\u003e\u003ch4\u003eCode\u003c/h4\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e#include\u0026lt;algorithm\u0026gt;\n#include\u0026lt;vector\u0026gt;\n#include\u0026lt;list\u0026gt;\n#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;utility\u0026gt;\n#include\u0026lt;string\u0026gt;\n#include\u0026lt;set\u0026gt;\n#include\u0026lt;queue\u0026gt;\n#include\u0026lt;stack\u0026gt;\n\n\nusing namespace std;\n\n//ps stores all primes below 32000\nvector\u0026lt;long long\u0026gt; ps;\n\n//graph is the network graph, fl is the flow\n//res is the residual\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph,fl,res;\n\n//find an augmenting path\npair\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; getPath(){\n    pair\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; ans;\n    int sz\u003dfl.size();\n    \n    //find predecessors using a breadth first search\n    vector\u0026lt;int\u0026gt; preds(sz,-1);\n    preds[0]\u003d0;\n    queue\u0026lt;int\u0026gt; q;\n    q.push(0);\n\n    \n    while(!q.empty()){\n        int cur\u003dq.front();\n        q.pop();\n        for(int i\u003d0; i\u0026lt;sz; i++){\n            if(res[cur][i] \u0026amp;\u0026amp; preds[i]\u003d\u003d-1){\n                preds[i]\u003dcur;\n                q.push(i);\n            }\n        }\n    }\n    \n    //if there is no path to the sink\n    //return an empty answer\n    if(preds[sz-1]\u003d\u003d-1) return ans;\n    \n\n    //create an augmenting path\n    //from predecessors\n    int pos\u003dsz-1;\n    vector\u0026lt;int\u0026gt; vi;\n    while(pos){\n        vi.push_back(pos);\n        pos\u003dpreds[pos];\n    }\n    vi.push_back(0);\n    reverse(vi.begin(),vi.end());\n    int cap\u003dres[vi[0]][vi[1]];\n\n    //find the capacity of the path\n    for(int i\u003d1; i\u0026lt;vi.size()-1; i++){\n        cap\u003dmin(cap,res[vi[i]][vi[i+1]]);\n    }\n    return make_pair(cap,vi);\n}\n\n//udpate the residual and flow\n//along an augmenting path\nbool augment(){\n\n    //find a path\n    auto path\u003dgetPath();\n    auto vi\u003dpath.second;\n\n    //return false if the path is empty\n    if(!vi.size()) return false;\n    \n    //get the capacity of the path\n    int cap\u003dpath.first;\n    \n    for(int i\u003d0; i\u0026lt;vi.size()-1; i++){\n        //update the residual\n        res[vi[i]][vi[i+1]]-\u003dcap;\n        res[vi[i+1]][vi[i]]+\u003dcap;\n        \n        //update the flow\n        if(graph[vi[i]][vi[i+1]]){\n            fl[vi[i]][vi[i+1]]+\u003dcap;\n        }\n        else{\n            fl[vi[i+1]][vi[i]]-\u003dcap;\n        }\n    }\n    return true;\n    \n}\n\n//count the number of prime\n//divisor in a number\nint divCt(long long num){\n    if(num\u003d\u003d1) return 0;\n    int ct\u003d0;\n    \n    //isP checks we get\n    //a prime greater than\n    //32 000\n    bool isP\u003dfalse;\n    int cur\u003dnum;\n\n    //keep dividing by primes until we get\n    //1 or a prime greater than 32 000\n    while(cur\u0026gt;1 \u0026amp;\u0026amp; !isP){\n        bool found\u003dfalse;\n        for(int i\u003d0; i\u0026lt;ps.size() \u0026amp;\u0026amp; !found; i++){\n            if(!(cur%ps[i])){\n                cur\u003dcur/ps[i];\n                found\u003dtrue;\n                ct++;\n            }\n        }\n        if(!found \u0026amp;\u0026amp; cur\u0026gt;1) isP\u003dtrue;\n    }\n    return ct+isP;\n}\n\n//get the gcd of two numbers using the\n//Euclidean algorithm\nlong long gcd(long long a, long long b){\n    if(b\u0026gt;a) return gcd(b,a);\n    \n    while(b\u0026gt;1){\n        int r\u003da%b;\n        if(!r) return b;\n        \n        a\u003db;\n        b\u003dr;\n        \n    }\n    return 1;\n}\n\n\nint main(){\n    \n    vector\u0026lt;int\u0026gt; psj;\n  \n   //find primes below 1000\n   //by brute force and store\n   //it in psj\n   for(int i\u003d2; i\u0026lt;1000; i++){\n        int cnt\u003d0;\n        for(int j\u003d2; j\u0026lt;i; j++){\n            if(!(i%j)){\n                cnt++;\n            }\n        }\n        \n        if(!cnt){\n            psj.push_back(i);\n        }\n    }\n    \n    //find primes below 32 000\n    //using psj to sieve\n    vector\u0026lt;bool\u0026gt; psb(32000,true);\n    psb[0]\u003dfalse;\n    psb[1]\u003dfalse;\n    for(int i:psj){\n        for(int j\u003d2; i*j\u0026lt;\u003d32000; j++){\n            psb[i*j]\u003dfalse;\n        }\n    }\n    \n    for(int i\u003d0; i\u0026lt;32000; i++){\n        if(psb[i]){ \n            ps.push_back(i);\n        }\n    }\n   \n    //store the sequence given in\n    //the question\n    vector\u0026lt;long long\u0026gt; sequence;\n    sequence.push_back(0);\n    \n    int n,m;\n    cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\n    for(int i\u003d0; i\u0026lt;n; i++){\n        int num;\n        cin\u0026gt;\u0026gt;num;\n        sequence.push_back(num);\n    }\n\n    //store whether two points are in a pair or not\n    vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; basicGraph(n+1,vector\u0026lt;int\u0026gt;(n+1,0));\n    for(int i\u003d0; i\u0026lt;m; i++){\n        int x,y;\n        cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\n        basicGraph[x][y]\u003d1;\n        basicGraph[y][x]\u003d1;\n    }\n    \n    //initialise flow to all 0s\n    vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; flow(2*n+2,vector\u0026lt;int\u0026gt;(2*n+2,0));\n    fl\u003dflow;\n    \n    //initialise the residual\n    vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; residual(2*n+2,vector\u0026lt;int\u0026gt;(2*n+2,0));\n    \n    //fill in values for edges not involving the\n    //source or the sink\n    for(int i\u003d1; i\u0026lt;\u003dn; i++){\n        for(int j\u003d1; j\u0026lt;\u003dn; j++){\n            if(basicGraph[i][j]){\n                auto num\u003dgcd(sequence[i],sequence[j]);\n                residual[i][j+n]\u003ddivCt(num);\n                \n            }\n        }\n    }\n    \n    //fill in values for edges involving the source\n    //or sink\n    \n    for(int i\u003d1; i\u0026lt;\u003dn; i++){\n        int ct\u003d0;\n        long long cur\u003dsequence[i];\n        for(int j\u003d1; j\u0026lt;\u003dn; j++){\n            if(basicGraph[i][j]){\n                long long other\u003dsequence[j];\n                long long num\u003dgcd(cur,other);\n                ct+\u003ddivCt(num);\n                cur\u003dcur/num;\n            }\n        }\n        residual[0][i]\u003dct;\n        residual[n+i][2*n+1]\u003dct;\n        \n    }\n    \n    res\u003dresidual;\n\n    //fill in edge values for the \n    //network graph\n    graph\u003dresidual;\n    \n    for(int i\u003d0; i\u0026lt;2*n+2; i++){\n        for(int j\u003d0; j\u0026lt;2*n+2; j++){\n            graph[i][j]\u003dmin(1,res[i][j]);\n        }\n        \n    }\n    \n    \n   int ans\u003d0;\n\n   //keep augmenting until\n   //we cannot find an augmenting\n   //path\n   while(augment()){}\n   \n   //set ans to the max flow \n   for(int i\u003d0; i\u0026lt;2*n+2; i++){\n       ans+\u003dfl[0][i];\n   }\n   \n   \n   \n   cout\u0026lt;\u0026lt;ans/2;\n   \n   return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["flows","number theory","graph"]}}