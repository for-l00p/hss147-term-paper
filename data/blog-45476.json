{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1466118629,"rating":27,"authorHandle":"tafit3","modificationTimeSeconds":1466118629,"id":45476,"title":"\u003cp\u003eSurprise!\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/blog/entry/45454?#comment-300476\"\u003eMy surprise in the latest Surprise Language Round #8\u003c/a\u003e got me thinking. What is a surprise? Everybody is surprised by different things. If someone is new to competitive programming, there is an easy way to surprise him: just let him multiply two numbers. The constraints don\u0027t even have to be 10^9, 10^5 is enough:) But surprising more experienced coders is much harder.\u003c/p\u003e\u003cp\u003eI like the problems that have some element of surprise or anything non-standard. The problems that somehow force the contestant to dig deeper. Something more than just reading the problem statement and converting it to DP. In the regular rounds most often the surprise comes from the missing knowledge about the particular algorithm. If I didn\u0027t know about the algorithm, I can google it after the contest, study it, add to personal library and wait for the next contest with similar problem. How can a problem statement be even more surprising? \u003c/p\u003e\u003cp\u003eThere is a link between the time limit and the time complexity of the expected solution. Obviously. Is it that obvious? I don\u0027t write problem statements and the problem setters could probably explain it much better, but as I understand it, the time limit cannot be too big, because it won\u0027t force the contestant to come up with the clever solution, but at the same it hints as to what the expected complexity should be. I\u0027d like to see the task in which the most obvious solution is O(nlogn), but the constraint is n\u0026lt;11111. Or maybe a little more so that it is not blatantly obvious that the O(n^2) solution will not be enough. But even if someone come up with O(n^2) coded in such a clever way that it would pass, it would still make the contestant think a little longer as to whether he should go for O(nlogn) or don\u0027t bother and implement O(n^2) more quickly.\u003c/p\u003e\u003cp\u003eBecause of different programming languages picking such tight constraints might be difficult to achieve, but let\u0027s consider a choice of the programming language to be part of the solution. If you choose JavaScript and your solution TLEs, than maybe this wasn\u0027t a good language for this particular problem. I\u0027m not saying that it should be a general rule for every contest, because regular rounds are important and I enjoy them very much. But just some of them might have a few additional quirks like that explicitly stated in the rules.\u003c/p\u003e\u003cp\u003eThe non-helpful constraints could also be taken to the other extreme â€” the constraints so high that the only way to solve the problem would be to upload the solution that outputs: \u0026quot;This does not compute\u0026quot;. It is often the case that the problem statement asks for some solution or \u0026quot;-1\u0026quot; if there is none. What if it was implied in the contest format (in the core rules of the contest, you know the magic numbers: \u003ca href\u003d\"//codeforces.com/blog/entry/456\"\u003e456\u003c/a\u003e, \u003ca href\u003d\"//codeforces.com/blog/entry/4088\"\u003e4088\u003c/a\u003e) that there is a third possiblity, ie. that the problem itself is unsolvable (even if only for some special input data but within the constraints). It is so comfortable to just open a problem statement and think hard about the solution without taking into consideration that it might not have a solution at all.\u003c/p\u003e\u003cp\u003e\u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/Errichto\" title\u003d\"International Grandmaster Errichto\"\u003eErrichto\u003c/a\u003e and \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/ainu7\" title\u003d\"Grandmaster ainu7\"\u003eainu7\u003c/a\u003e wrote about the link between constraints and time limit (\u003ca href\u003d\"//codeforces.com/blog/entry/45080?#comment-296356\"\u003ehere\u003c/a\u003e and \u003ca href\u003d\"//codeforces.com/blog/entry/21861?#comment-265513\"\u003ehere\u003c/a\u003e), so am I right in thinking that there is a chance that the link may just start to break in the near future...\u003c/p\u003e\u003cp\u003eWhat are some other non-standard problem structures?\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003ethe interactive problems, eg. \u003ca href\u003d\"//codeforces.com/contest/679/problem/A\"\u003eBear and Prime 100\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003ebots fighting against each other\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003edistributed problems (like Google Distributed CodeJam)\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThere was something weird about the Distributed CodeJam rounds as opposed to regular CodeJam rounds. Some people were frustrated with the tester tool that DCJ organizers provided and there was also some unexpected placements of the contestants. \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/JohStraat\" title\u003d\"Candidate Master JohStraat\"\u003eJohStraat\u003c/a\u003e wrote \u003ca href\u003d\"//codeforces.com/blog/entry/45109?#comment-296629\"\u003e\u0026quot;I got 7\u0027th place! But why are people so weak in distributed? All of the problems were way easier than in normal rounds...\u0026quot;\u003c/a\u003e Everybody has their ups and downs, but when considering all the contestants of a particular competition as a whole, it is much more likely that red coders will have more points than blue ones as opposed to any other outcome. It is very interesting when there is a kind of imbalance with respect to the expected probabilities (Is there a formula for the weirdness and unexpectedness of the scoreboard, so that after the contest one number could sum up how \u0026quot;regular\u0026quot; it was?). When the results are not as predictable as in regular rounds, it makes one wonder how many of the algorithms are learnt by heart (or siting there in the carefully crafted library and waiting to be used) and how many of them are invented and coded during the contest. Don\u0027t get me wrong, I\u0027m not saying that one cannot prepare before a contest (like prepare your own library... I do), but aren\u0027t the contests that render such a library almost useless somehow more exciting?\u003c/p\u003e\u003cp\u003eIs it difficult to come up with a problem that is solvable only when using threads, so that non-threaded solutions cannot pass? (I mean considering the hardware that already runs the judge)\u003c/p\u003e\u003cp\u003eSurprise Language Round #8 was cool, but still the earlier contests by \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Nickolas\" title\u003d\"Expert Nickolas\"\u003eNickolas\u003c/a\u003e were more fun \u003ca href\u003d\"//codeforces.com/blog/entry/17138\"\u003eVK Cup 2015 Wild Card Round 1\u003c/a\u003e, \u003ca href\u003d\"//codeforces.com/blog/entry/44258\"\u003eVK Cup 2016 Wild Card Round 1\u003c/a\u003e. Kotlin is kinda-sorta Java and even though I have learned something new, Picat and J were in many aspects like nothing I have seen before and this is what makes the big part of Surprise in \u0026quot;Surprise Language Round\u0026quot;.\u003c/p\u003e\u003cp\u003eI don\u0027t necessarily mean that all the contests should be surprising, but there could be some that are more crazy. Also I want to stress that in my opinion the craziness or the new crazy rule shouldn\u0027t be something that makes it almost impossible for the contestant to develop the solution during the contest. It\u0027s not about creating bad experience like \u003ca href\u003d\"//codeforces.com/blog/entry/19010\"\u003eChallenge24\u003c/a\u003e, where problem statements are incomplete or test data is wrong. The rule should be completely logical and yet make the contestant think in different ways than usual.\u003c/p\u003e\u003cp\u003eEverything that doesn\u0027t allow the contestant to use the tools he already has makes the contest more thought-provoking. What are your thoughts on how to make the contests more surprising? Or do you prefer regular rounds instead?\u003c/p\u003e\u003c/div\u003e","tags":["surprise","surprise language","surprise language round","unknown language round"]}}