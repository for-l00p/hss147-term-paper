{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1501245827,"rating":-3,"authorHandle":"Muhammad_Rahimov","modificationTimeSeconds":1501253486,"id":53523,"title":"\u003cp\u003eLevko and Array Recovery masalasi yechimi\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003eMasala Tarjimasi:\u003c/h3\u003e\u003cp\u003eLevko massivlar bilan o\u0027ynashni yaxshi ko\u0027rar ekan. Unda a1, a2, a3 ... an ko\u0027rinishidagi massiv bor ekan. U massiv bilan o\u0027ynash davomida, shu massiv ustida 2 xil amal bajarar ekan.\u003c/p\u003e\u003cp\u003eBu amallar:\u003cbr /\u003e 1. Birinchi turdagi amal bu: massivdagi indekslari L dan R gacha bo\u0027lgan elementlarni D ga oshirish. ya\u0027ni dasturlash tili bilan aytganda:\u003c/p\u003e \u003cpre\u003e\nfor(int i \u003d L; i\u0026lt;\u003dR; i++)\n    a[i]+\u003dD;\n\u003c/pre\u003e \u003col\u003e   \u003cli\u003eIkkinchi turdagi amal: massivdagi indekslari L dan R gacha bo\u0027lgan elementlar ichidan maksimalini topish.\u003c/li\u003e \u003c/ol\u003e \u003cpre\u003e\nfor(int i \u003d L; i\u0026lt;\u003dR; i++)\n   mx \u003d max(mx, a[i]);\n\u003c/pre\u003e\u003cp\u003eLevko sevimli massivini yo\u0027qotib qo\u0027yibdi shuning uchun u sizdan yordam so\u0027rayapdi. Unda faqat massiv ustida bajarilgan amallar ro\u0027yhati bor holos. Levkoga massivni tiklashda yordam bering.\u003c/p\u003e\u003ch4\u003eKiruvchi ma\u0027lumotlar:\u003c/h4\u003e\u003cp\u003eBirinchi bo\u0027lib bizga n va m ketma ket kiritiladi.\u003c/p\u003e\u003cp\u003en -\u0026gt; massiv elementlari soni; 1\u0026lt;\u003dn\u0026lt;\u003d5000\u003cbr /\u003e m -\u0026gt; massiv ustida bajarilgan amallar soni; 1\u0026lt;\u003dm\u0026lt;\u003d5000\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eKeyingi m qatorda quyidagi tartibda ma\u0027lumotlar kiritiladi:\u003cbr /\u003e 1. t -\u0026gt; bajarilgan operatsiya tipi. Agar t \u003d 1 bo\u0027lsa u holda birinchi turdagi amal bajarilgan(qo\u0027shish), agar t \u003d 2 bo\u0027lsa ikkinchi turdagi amal bajarilgan(maksimal topish). 1\u0026lt;\u003dt\u0026lt;\u003d2\u003cbr /\u003e 2. l -\u0026gt; chap chegara 1\u0026lt;\u003dl\u0026lt;\u003dn\u003cbr /\u003e 3. r -\u0026gt; o\u0027ng chegara 1\u0026lt;\u003dr\u0026lt;\u003dn\u003cbr /\u003e 4. d yoki m -\u0026gt; bajarilayotgan amal turiga qarap, agar birinchi turdagi amal bo\u0027lsa qo\u0027shilayotgan son, agar ikkinchi turdagi amal bo\u0027lsa topilgan maksimal son.\u003c/p\u003e\u003ch4\u003eChiquvchi ma\u0027lumotlar:\u003c/h4\u003e\u003cp\u003eYES -\u0026gt; agar yechim bo\u0027lsa\u003cbr /\u003e NO -\u0026gt; agar yechim bo\u0027lmasa\u003cbr /\u003e Agar yechim bo\u0027lsa YES yozuvi ostida massiv elementlari chiqarilsin. Massiv elementlari modul jihatda 1e9 dan oshmaydi. |ai|\u0026lt;\u003d1e9\u003c/p\u003e\u003cp\u003eO\u0027zlaringizda g\u0027oya chiqarib ishlashga urinib ko\u0027ringlar!!! Agar bo\u0027lmasa quyidagi yechimda foydalaninglar.\u003c/p\u003e\u003ch4\u003eMasala Yechimi:\u003c/h4\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eyechimi\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eBu masala yechimida asosoy ro\u0027lni massiv ustida bajarilayotgan amallar o\u0027ynaydi. Birinchi amaldan boshlasak. Birinchi amal haqidagi ma\u0027lumotlardan quyidagicha foydalanamiz: diff nomli massiv olamiz (diff -\u0026gt; difference -\u0026gt; farq) va birinchi amal haqida ma\u0027lumot kelganda diff massivini quyidagi tarzda o\u0027zgartiramiz.\u003c/p\u003e \u003cpre\u003e\nfor(int i \u003d L; i\u0026lt;\u003dR; i++)\n    diff[i]+\u003dD;\n\u003c/pre\u003e\u003cp\u003eBu kodni bajarish orqali biz diff massivda hozirgi holatdagi massiv boshlang\u0027ich massiv elementlaridan qanchaga farq etishini saqlab qo\u0027yamiz. Masalan hozirda diff[2] \u003d 4 bo\u0027lsa demak a massivning 2 elementi boshlang\u0027ich holatda 4 ga katta.\u003c/p\u003e\u003cp\u003eEndi ikkinchi turdagi amallarni ko\u0027rib chiqsak. Bu amallarni qayta ishlash murakkabroq va bu amallar yordamida biz qidirilayotgan massivni hosil qilib olishimiz mumkin. Bu amallarni qayta ishlash uchun bizga javob massivni saqlab qo\u0027yuvchi massiv kerak bo\u0027ladi. Bu massivni ans deb nomlaymiz (ans -\u0026gt; answer -\u0026gt; javob) va uni masala shartidagi massiv elemntlaringing maksimal qiymati bilan to\u0027ldiramiz ya\u0027ni:\u003c/p\u003e \u003cpre\u003e\nfor(int i \u003d 0; i\u0026lt;\u003d5000; i++){\n    ans[i] \u003d 1e9;\n}\n\u003c/pre\u003e\u003cp\u003eMassivning bu holatda turishi bizga keyingi operatsiyalarda kerak bo\u0027ladi. Endi eng qiziqarli qismi. Agar bizga ikkinchi turdagi amal berilsa, L -\u0026gt; R oraliqdagi faqatgina topilgan maksimal elementdan katta bo\u0027lganlarini, shu topilgan maksimal bilan almashtiramiz. Ammo almashtirish davomida shu massiv elementi boshlang\u0027ich holatda qancha siljiganinigam hisobga olamiz:\u003c/p\u003e \u003cpre\u003e\nfor(int i \u003d L; i\u0026lt;\u003dR; i++)\n    ans[i] \u003d min(ans[i], M - diff[i]);\n\u003c/pre\u003e\u003cp\u003eM -\u0026gt; bu yerda L — R oraliqda topilgan maksimal.\u003c/p\u003e\u003cp\u003eShu tarzda barcha amallarni qayta ishlab chiqsak biz natijaviy massivni qo\u0027lga kiritamiz. Ammo bu hali javob degani emas. Biz bu massivni to\u0027g\u0027ri hosil qilinganligiga ishonch hosil qilishimiz kerak. Massivni tekshirish uchun biz diff massivni tozalatmiz ya\u0027ni nollar bilan to\u0027ldiramiz va ok nomli mantiqiy o\u0027zgaruvchi hosil qilamiz. Keyinchalik amallardan yana bir marta o\u0027tib chiqamiz. Agar birinchi turdagi amal kelsa diff massivini yangilaymiz. Agar ikkinchi turdagi element kelsa L — R oraliqda M kamida bir marta uchraydimi yo\u0027qmi tekshiramiz akar bu element uchramay qolsa demak javob NO. Agar barcha M lar uchrasa YES javobini chiqaramiz va massivni chiqaramiz.\u003c/p\u003e\u003cp\u003eShu yechimdan foydalanib kodni o\u0027zingiz yozishga urinib ko\u0027ring. Agar o\u0027xshamasa quyidagi ko\u0027dni o\u0027rganib chiqishingiz mumkin.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ekod\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nconst int N \u003d 5001;\n\nint diff[N], ans[N], t[N], l[N], r[N], d[N];\n\n\nint main()\n{\n    for(int i \u003d 0; i\u0026lt;N; i++)\n        ans[i] \u003d 1e9;\n\n    int n,m;\n    cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\n    for(int i \u003d 0; i\u0026lt;m; i++)\n    {\n        cin\u0026gt;\u0026gt;t[i]\u0026gt;\u0026gt;l[i]\u0026gt;\u0026gt;r[i]\u0026gt;\u0026gt;d[i];\n\n        if(t[i] \u003d\u003d 1)\n        {\n            for(int j \u003d l[i]; j\u0026lt;\u003dr[i]; j++)\n                diff[j]+\u003dd[i];\n        }\n        else\n        {\n            for(int j \u003d l[i]; j\u0026lt;\u003dr[i]; j++)\n                ans[j] \u003d min(ans[j], d[i] - diff[j]);\n        }\n    }\n\n    for(int i \u003d 0; i\u0026lt;N; i++)\n        diff[i] \u003d 0;\n\n    bool ok \u003d 1;\n\n    for(int i \u003d 0; i\u0026lt;m \u0026amp;\u0026amp; ok; i++)\n    {\n        if(t[i] \u003d\u003d 1)\n        {\n            for(int j \u003d l[i]; j\u0026lt;\u003dr[i]; j++)\n                diff[j]+\u003dd[i];\n\n        }\n        else\n        {\n            ok \u003d 0;\n            for(int j \u003d l[i]; j \u0026lt;\u003d r[i]; j++)\n                if(ans[j] + diff[j] \u003d\u003d d[i])\n                {\n                    ok \u003d 1;\n                    break;\n                }\n        }\n    }\n\n    if(ok)\n    {\n        cout\u0026lt;\u0026lt;\u0026quot;YES\u0026quot;\u0026lt;\u0026lt;endl;\n        for(int i \u003d 1; i\u0026lt;\u003dn; i++)\n            cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\n    }\n    else\n    {\n        cout\u0026lt;\u0026lt;\u0026quot;NO\u0026quot;;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}