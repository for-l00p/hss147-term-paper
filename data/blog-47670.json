{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1476188031,"rating":0,"authorHandle":"kb.","modificationTimeSeconds":1476188031,"id":47670,"title":"\u003cp\u003eМоё решение H\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;array\u0026gt;\n#include \u0026lt;cstring\u0026gt;\nusing namespace std;\n\ntypedef long long ll;\nconst int N \u003d 200500;\nconst int A \u003d 26;\n\nchar buf[N];\nstring scan_token()\n{\n\tscanf(\u0026quot;%s\u0026quot;, buf);\n\treturn string(buf);\n}\n\nstruct Trie\n{\n\tint sz;\n\tvector\u0026lt;array\u0026lt;int, A\u0026gt;\u0026gt; go;\n\tvector\u0026lt;int\u0026gt; term, subterm;\n\tll ans;\n\t\n\tvoid inc_size()\n\t{\n\t\tsz++;\n\t\tarray\u0026lt;int, A\u0026gt; tmp;\n\t\tfill(tmp.begin(), tmp.end(), -1);\n\t\tgo.push_back(tmp);\n\t\tterm.push_back(0);\n\t\tsubterm.push_back(0);\n\t}\n\t\n\tTrie()\n\t{\n\t\tsz \u003d ans \u003d 0;\n\t\tinc_size();\n\t}\n\t\n\tvoid add_word(const string \u0026amp;s, int cnt)\n\t{\n\t\tint v \u003d 0;\n\t\tint len \u003d 0;\n\t\tfor (char c : s)\n\t\t{\n\t\t\tsubterm[v] +\u003d cnt;\n\t\t\tans \u003d max(ans, (ll)len * subterm[v]);\n\t\t\tint ch \u003d c - \u0027a\u0027;\n\t\t\tint to \u003d go[v][ch];\n\t\t\tif (to \u003d\u003d -1)\n\t\t\t{\n\t\t\t\tto \u003d go[v][ch] \u003d sz;\n\t\t\t\tinc_size();\n\t\t\t}\n\t\t\tv \u003d to;\n\t\t\tlen++;\n\t\t}\n\t\tsubterm[v] +\u003d cnt;\n\t\tans \u003d max(ans, (ll)len * subterm[v]);\n\t\tterm[v] +\u003d cnt;\n\t}\n\t\n\tvoid merge(Trie \u0026amp;small)\n\t{\n\t\tstring pref;\n\t\tsmall.dfs_and_add(0, *this, pref);\n\t}\n\t\n\tvoid dfs_and_add(int v, Trie \u0026amp;big, string \u0026amp;pref)\n\t{\n\t\tif (term[v] \u0026gt; 0)\n\t\t\tbig.add_word(pref, term[v]);\n\t\tfor (int ch \u003d 0; ch \u0026lt; A; ch++)\n\t\t{\n\t\t\tint to \u003d go[v][ch];\n\t\t\tif (to \u003d\u003d -1)\n\t\t\t\tcontinue;\n\t\t\tpref +\u003d (char)(\u0027a\u0027 + ch);\n\t\t\tdfs_and_add(to, big, pref);\n\t\t\tpref.pop_back();\n\t\t}\n\t}\n};\n\nint n;\nint sz;\nint go[N][A];\nint term[N];\nint vsize[N];\nll ans;\n\nvoid add_word(const string \u0026amp;s)\n{\n\tint v \u003d 0;\n\tfor (char c : s)\n\t{\n\t\tint ch \u003d c - \u0027a\u0027;\n\t\tint \u0026amp;to \u003d go[v][ch];\n\t\tif (to \u003d\u003d -1)\n\t\t\tto \u003d sz++;\n\t\tv \u003d to;\n\t}\n\tterm[v]++;\n}\n\nvoid dfs_vsize(int v)\n{\n\tvsize[v] \u003d 1;\n\tfor (int ch \u003d 0; ch \u0026lt; A; ch++)\n\t{\n\t\tint to \u003d go[v][ch];\n\t\tif (to \u003d\u003d -1)\n\t\t\tcontinue;\n\t\tdfs_vsize(to);\n\t\tvsize[v] +\u003d vsize[to];\n\t}\n}\n\nstring pref;\nvoid dfs(int v, Trie \u0026amp;trie)\n{\n\tint mx \u003d -1;\n\tfor (int ch \u003d 0; ch \u0026lt; A; ch++)\n\t{\n\t\tint to \u003d go[v][ch];\n\t\tif (to \u003d\u003d -1)\n\t\t\tcontinue;\n\t\tif (mx \u003d\u003d -1 || vsize[go[v][mx]] \u0026lt; vsize[to])\n\t\t\tmx \u003d ch;\n\t}\n\t\n\tif (mx !\u003d -1)\n\t{\n\t\tpref +\u003d (char)(\u0027a\u0027 + mx);\n\t\tdfs(go[v][mx], trie);\n\t\tpref.pop_back();\n\t}\n\tif (term[v] \u0026gt; 0)\n\t{\n\t\treverse(pref.begin(), pref.end());\n\t\ttrie.add_word(pref, term[v]);\n\t\treverse(pref.begin(), pref.end());\n\t}\n\t\n\tfor (int ch \u003d 0; ch \u0026lt; A; ch++)\n\t{\n\t\tint to \u003d go[v][ch];\n\t\tif (to \u003d\u003d -1 || ch \u003d\u003d mx)\n\t\t\tcontinue;\n\t\tpref +\u003d (char)(\u0027a\u0027 + ch);\n\t\tTrie small;\n\t\tdfs(to, small);\n\t\tpref.pop_back();\n\t\ttrie.merge(small);\n\t}\n\t\n\tans \u003d max(ans, (ll)pref.size() * trie.ans);\n}\n\nvoid solve()\n{\n\tmemset(go, -1, sizeof(go));\n\tsz \u003d 1;\n\t\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\tfor (int i \u003d 0; i \u0026lt; n; i++)\n\t{\n\t\tstring s \u003d scan_token();\n\t\tadd_word(s);\n\t}\n\t\n\tdfs_vsize(0);\n\tTrie trie;\n\tdfs(0, trie);\n\t\n\tprintf(\u0026quot;%lld\\n\u0026quot;, ans);\n}\n\nint main()\n{\n\tfreopen(\u0026quot;race.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\tfreopen(\u0026quot;race.out\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\t\n\tsolve();\n\t\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}