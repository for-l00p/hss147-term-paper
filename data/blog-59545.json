{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1526644649,"rating":45,"authorHandle":"Hasan0540","modificationTimeSeconds":1526677075,"id":59545,"title":"\u003cp\u003e[Tutorial] 2018 PSUT Coding Marathon\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/gym/101798/problem/A\"\u003e\u003cstrong\u003eA. Two Fashillows\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e ≤ \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e \u0026gt; \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e, we print \u0026quot;good luck\u0026quot;. Otherwise, we print \u0026quot;see you next semester\u0026quot;.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint main() {\n\tint d, w, m;\n\tcin \u0026gt;\u0026gt; d \u0026gt;\u0026gt; w \u0026gt;\u0026gt; m;\n\tif (w + m \u0026lt;\u003d d || w \u0026gt; d)\n\t\tprintf(\u0026quot;good luck\\n\u0026quot;);\n\telse\n\t\tprintf(\u0026quot;see you next semester\\n\u0026quot;);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/gym/101798/problem/B\"\u003e\u003cstrong\u003eB. Two Palindromes\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe can always build a palindrome if we have at most one letter with odd frequency. Since both strings are palindromes, all letters have even frequencies, except he middle letter when the length of the string is odd. So the answer is \u003ccode\u003eNO\u003c/code\u003e only when both strings are of odd length and the middle letters are different.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e| + |\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e|)\u003c/span\u003e for reading, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e to check.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint main() {\n\tstring a, b;\n\tcin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\tif (a.size() % 2 \u003d\u003d 1 \u0026amp;\u0026amp; b.size() % 2 \u003d\u003d 1 \u0026amp;\u0026amp; a[a.size() / 2] !\u003d b[b.size() / 2])\n\t\tputs(\u0026quot;NO\u0026quot;);\n\telse\n\t\tputs(\u0026quot;YES\u0026quot;);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/gym/101798/problem/C\"\u003e\u003cstrong\u003eC. Forest (A) — Egg\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe number of trees is equal to the number of components in the graph. Initially, the number of components is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Adding an edge will always decrease the number of components by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e as the constructed graph doesn\u0027t have cycles.\u003c/p\u003e\u003cp\u003eWe add an edge at node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e if there\u0027s a value greater than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003evalue\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to its left. So we can solve the problem by reading values and keeping the maximum value updated. We add an edge when \u003ccode\u003ecurrentValue \u0026lt; maxValue\u003c/code\u003e and decrease the answer.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint main() {\n\tint n;\n\tcin \u0026gt;\u0026gt; n;\n\tint maxValue \u003d -1;\n\tint res \u003d n;\n\tfor (int i \u003d 1; i \u0026lt;\u003d n; ++i) {\n\t\tint currentValue;\n\t\tcin \u0026gt;\u0026gt; currentValue;\n\t\tif (currentValue \u0026lt; maxValue)\n\t\t\t--res;\n\t\telse\n\t\t\tmaxValue \u003d currentValue;\n\t}\n\tcout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/gym/101798/problem/D\"\u003e\u003cstrong\u003eD. Forest (B) — Chicken\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIf we have multiple trees in the forest, it is clear that the value at the root of the second tree must be greater than all values before it, otherwise it will have a parent.\u003c/p\u003e\u003cp\u003eAlso, removing the root of a tree produces zero or more trees, the root of each of these trees must have a value greater than all values before it other than the removed root.\u003c/p\u003e\u003cp\u003eWe can build the array as follows:\u003c/p\u003e\u003cp\u003eLet the sizes of the trees be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e...\u003c/span\u003e.\u003c/p\u003e\u003cp\u003ePick the first tree, assign the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e to the root, and give each child \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e of the root a consecutive range of values of size equal to the subtree at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. Then recursively, a child will be assigned to the maximum value in the given range, and the remaining range will be diveded over its children.\u003c/p\u003e\u003cp\u003eSo the first tree is built using values \u003cspan class\u003d\"tex-span\"\u003e[1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e]\u003c/span\u003e, the second tree using values \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + 1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e]\u003c/span\u003e, and so on.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint n;\nvector\u0026lt;int\u0026gt; p, sol, sz;\nvector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; g;\nvoid build(int u, int l, int r) {\n\tprintf(\u0026quot;%d \u0026quot;, r);\n\tfor (auto v : g[u]) {\n\t\tbuild(v, l, l + sz[v] - 1);\n\t\tl +\u003d sz[v];\n\t}\n}\nint main() {\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\tp.resize(n);\n\tsz.resize(n);\n\tg.resize(n);\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) {\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;p[i]);\n\t\t--p[i];\n\t\tif (p[i] !\u003d -1)\n\t\t\tg[p[i]].push_back(i);\n\t}\n\tfor (int i \u003d n - 1; i \u0026gt;\u003d 0; --i) {\n\t\t++sz[i];\n\t\tif (p[i] !\u003d -1)\n\t\t\tsz[p[i]] +\u003d sz[i];\n\t}\n\tint l \u003d 1, r \u003d n;\n\tfor (int i \u003d 0; i \u0026lt; n; ++i)\n\t\tif (p[i] \u003d\u003d -1) {\n\t\t\tbuild(i, l, l + sz[i] - 1);\n\t\t\tl +\u003d sz[i];\n\t\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/gym/101798/problem/E\"\u003e\u003cstrong\u003eE. Forest (C)\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTo increase the number of trees, some nodes must become roots. Roots don\u0027t have parents, so the values of these roots must be greater than all values to their left.\u003c/p\u003e\u003cp\u003eCan we make node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e a root by removing at most one element before it? If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is greater than all values before it, we don\u0027t need to remove any element as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is already a root. Otherwise, we can make \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e a root if and only if it has only one value greater than it before \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Removing that value will leave \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e without a parent.\u003c/p\u003e\u003cp\u003eSo we need the maximum value and the second maximum value before an element to decide if we can make it a root or not. And in case we can, we also need the indices of these maximums to know which element should be removed.\u003c/p\u003e\u003cp\u003eWe can count for each index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, the number of indices that need \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e to be removed to become a root. We also decrease \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e by one if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e is a root, as we will lose one root by removing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFor each starting element of a subarray \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, we increment the end of the subarray \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e while updating the array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e. As values in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e are initially 0 or -1, then only increase, it is easy to keep the maximum value in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e while increasing some elements.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint main()\n{\n\tint n;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\tvector\u0026lt;int\u0026gt; v(n);\n\tfor (int i \u003d 0; i \u0026lt; n; ++i)\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;v[i]);\n\tlong long res \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) {\n\t\tvector\u0026lt;int\u0026gt; can(n);\n\t\tint mx1 \u003d -1, mx2 \u003d -1;\n\t\tint at1, at2;\n\t\tint comp \u003d 0, best \u003d 0;\n\t\tfor (int j \u003d i; j \u0026lt; n; ++j) {\n\t\t\tif (mx1 \u0026gt; v[j]) {\n\t\t\t\t--comp;\n\t\t\t\tif (mx2 \u0026lt; v[j]) {\n\t\t\t\t\t++can[at1];\n\t\t\t\t\tbest \u003d max(best, can[at1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tcan[j] \u003d -1;\n\t\t\tif (mx2 \u0026lt; v[j]) {\n\t\t\t\tmx2 \u003d v[j];\n\t\t\t\tat2 \u003d j;\n\t\t\t\tif (mx1 \u0026lt; mx2) {\n\t\t\t\t\tswap(mx1, mx2);\n\t\t\t\t\tswap(at1, at2);\n\t\t\t\t}\n\t\t\t}\n\t\t\t++comp;\n\t\t\tres +\u003d comp + best;\n\t\t}\n\t}\n\tprintf(\u0026quot;%lld\\n\u0026quot;, res);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/gym/101798/problem/F\"\u003e\u003cstrong\u003eF. World Mug (A)\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe can simulate the process recursively or using two vectors and swapping them. The first vector will represent the strengths of the teams in the current round, and the second vector will represent the winners of the current round.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint main()\n{\n\tint n;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\tvector\u0026lt;int\u0026gt; a(n), b;\n\tfor (int i \u003d 0; i \u0026lt; n; ++i)\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]);\n\tlong long res \u003d 0;\n\twhile (a.size() !\u003d 1) {\n\t\tb.clear();\n\t\tfor (int i \u003d 0; i \u0026lt; a.size(); i +\u003d 2) {\n\t\t\tres +\u003d abs(a[i] - a[i + 1]);\n\t\t\tb.push_back(max(a[i], a[i + 1]));\n\t\t}\n\t\ta.swap(b);\n\t}\n\tprintf(\u0026quot;%lld\\n\u0026quot;, res);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/gym/101798/problem/G\"\u003e\u003cstrong\u003eG. World Mug (B)\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e be the height of the tree, that is, \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e \u003d \u003ci\u003en\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe winning team of the tournament will face \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e teams and beat them all, therefore contributing to the answer by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e × \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003ci\u003est\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe second-place team will also face \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e teams, winning \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/span\u003e times and losing the last one. This will contribute to the answer by \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e - 1) × \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003ci\u003end\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003ci\u003end\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e for a total of \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ek\u003c/i\u003e - 2) × \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003ci\u003end\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThrough our previous observation of how much each team\u0027s individual strength contributes to the final answer, it is clear now that the first-place team should be assigned to the team with the maximum strength, and the second-place team to the team with the second maximum strength.\u003c/p\u003e\u003cp\u003eThe next two teams in \u003cspan class\u003d\"tex-span\"\u003e3\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003erd\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e4\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eth\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e place each will win \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 2\u003c/span\u003e times and lose once. \u003cspan class\u003d\"tex-span\"\u003e5\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eth\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e8\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003eth\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e place will win \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e - 3\u003c/span\u003e times and lose once, and so on. We should keep assigning places in decreasing order of strength for these teams.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlogn\u003c/i\u003e)\u003c/span\u003e, as we need to sort the strengths.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint main()\n{\n\tint n;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\tvector\u0026lt;int\u0026gt; v(n);\n\tfor (int i \u003d 0; i \u0026lt; n; ++i)\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;v[i]);\n\tsort(v.begin(), v.end());\n\tint k \u003d 0;\n\twhile ((1 \u0026lt;\u0026lt; k) \u0026lt; n)\n\t\t++k;\n\tlong long res \u003d v[n - 1] * (long long)k;\n\tint teams \u003d 1, win \u003d k - 1;\n\tint i \u003d n - 2;\n\twhile (i \u0026gt;\u003d 0) {\n\t\tint count \u003d teams;\n\t\twhile (count--) {\n\t\t\tres +\u003d v[i] * (long long)(win-1);\n\t\t\t--i;\n\t\t}\n\t\tteams *\u003d 2;\n\t\t--win;\n\t}\n\tprintf(\u0026quot;%lld\\n\u0026quot;, res);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/gym/101798/problem/H\"\u003e\u003cstrong\u003eH. Cylindrical Graphs\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eNote that in a cylinder, the degree of each node is \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e. If we choose one of the vertical edges, mark one end in blue and the other in red, then do a multi-source BFS marking each adjacent node with the color if its parent, we will get one cycle colored in blue and the other colored in red! Check the following animated GIF:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/4f/11/4f118e20b5a2341d518dfe4fb7b442cfa1ee8a47.gif\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eSince we don\u0027t know if an edge is vertical or not, we can try all of the three edges of a node, if one of them produced two cycles of size \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/39/fd/39fdaa6f330f6afe718c8e14bc2d862f48999d59.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, and those two cycles are connected using vertical edges, then we found a solution. Note that sometimes you need to reverse one of the cycles to align the vertical edges.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint main()\n{\n\tint n;\n\tvector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; g;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\tg.resize(n);\n\tfor (int u, v, i \u003d 0; i \u0026lt; 3 * n / 2; ++i) {\n\t\tscanf(\u0026quot;%d%d\u0026quot;, \u0026amp;u, \u0026amp;v);\n\t\t--u; --v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tfor (int i \u003d 0; i \u0026lt; n; ++i)\n\t\tif (g[i].size() !\u003d 3) {\n\t\t\tprintf(\u0026quot;NO\\n\u0026quot;);\n\t\t\treturn 0;\n\t\t}\n\tfor (int i \u003d 0; i \u0026lt; 3; ++i) { // try all edges of node 0\n\t\tint u \u003d 0, v \u003d g[0][i];\n\t\tdeque\u0026lt;int\u0026gt; cycle[2];\n\t\tqueue\u0026lt;int\u0026gt; q;\n\t\tq.push(u);\tq.push(v);\n\t\tvector\u0026lt;int\u0026gt; color(n, -1);\n\t\tcolor[u] \u003d 0;\tcolor[v] \u003d 1;\n\t\twhile (!q.empty()) {\n\t\t\tint w \u003d q.front();\n\t\t\tq.pop();\n\t\t\tif (cycle[color[w]].size() % 2 \u003d\u003d 0)\n\t\t\t\tcycle[color[w]].push_back(w);\n\t\t\telse\n\t\t\t\tcycle[color[w]].push_front(w);\n\t\t\tfor (auto z : g[w])\n\t\t\t\tif (color[z] \u003d\u003d -1) {\n\t\t\t\t\tcolor[z] \u003d color[w];\n\t\t\t\t\tq.push(z);\n\t\t\t\t}\n\t\t}\n\t\tif (cycle[0].size() !\u003d n / 2 || cycle[1].size() !\u003d n / 2)\n\t\t\tcontinue;\n\t\t// check that the last two added nodes in each cycle are adjacent\n\t\tbool bad \u003d false;\n\t\tfor (int it \u003d 0; it \u0026lt; 2; ++it) {\n\t\t\tint a \u003d cycle[it].front();\n\t\t\tint b \u003d cycle[it].back();\n\t\t\tif (find(g[a].begin(), g[a].end(), b) \u003d\u003d g[a].end()) {\n\t\t\t\tbad \u003d true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (bad)\n\t\t\tcontinue;\n\t\t// rotate cycles until u and v are the first in each cycle\n\t\tfor (int it \u003d 0; it \u0026lt; 2; ++it) {\n\t\t\twhile (cycle[it].front() !\u003d u) {\n\t\t\t\tcycle[it].push_back(cycle[it].front());\n\t\t\t\tcycle[it].pop_front();\n\t\t\t}\n\t\t\tswap(u, v);\n\t\t}\n\t\tbool ok \u003d false;\n\t\tfor (int it \u003d 0; it \u0026lt; 2; ++it) { // check vertical edges and reverse one cycle if needed\n\t\t\tok \u003d true;\n\t\t\tfor (int i \u003d 0; i \u0026lt; n / 2; ++i) {\n\t\t\t\tint a \u003d cycle[0][i];\n\t\t\t\tint b \u003d cycle[1][i];\n\t\t\t\tif (find(g[a].begin(), g[a].end(), b) \u003d\u003d g[a].end()) {\n\t\t\t\t\tok \u003d false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok || it \u003d\u003d 1)\n\t\t\t\tbreak;\n\t\t\tcycle[1].pop_front();\n\t\t\treverse(cycle[1].begin(), cycle[1].end());\n\t\t\tcycle[1].push_front(v);\n\t\t}\n\t\tif (!ok)\n\t\t\tcontinue;\n\t\tprintf(\u0026quot;YES\\n\u0026quot;);\n\t\tfor (int it \u003d 0; it \u0026lt; 2; ++it) {\n\t\t\tfor (int i \u003d 0; i \u0026lt; n / 2; ++i)\n\t\t\t\tprintf(\u0026quot;%d \u0026quot;, cycle[it][i] + 1);\n\t\t\tprintf(\u0026quot;\\n\u0026quot;);\n\t\t}\n\t\treturn 0;\n\t}\n\tprintf(\u0026quot;NO\\n\u0026quot;);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/gym/101798/problem/I\"\u003e\u003cstrong\u003eI. Tree Generators\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe main idea is to build a weighted tree that contains only the nodes mentioned in the operations and/or the queries, plus few other nodes that can be the result of the LCA of some pairs.\u003c/p\u003e\u003cp\u003eWe will keep a sorted list of the IDs that will be needed in the operations and the queries.\u003c/p\u003e\u003cp\u003eEach time we activate a generator, we know the number of nodes and the range of IDs that will be generated, if we number the required nodes of each generator in DFS order and sort them, then during our LCA operations we may need those nodes or the LCA of some consecutive nodes. So we add all these nodes to a weighted tree, where the weight of an edge is the number of edges between the two nodes. To find the weight of an edge, we can initially build a sparse table for each generator and store the depths of the nodes. We need the sparse tables for finding the LCAs too.\u003c/p\u003e\u003cp\u003eFinally, we build a sparse table for the weighted tree to answer the queries.\u003c/p\u003e\u003cp\u003eThe total number of nodes in the weighted tree won\u0027t exceed \u003cspan class\u003d\"tex-span\"\u003e2 * (\u003ci\u003ek\u003c/i\u003e + \u003ci\u003eq\u003c/i\u003e)\u003c/span\u003e. Multiplied by \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e because we add the LCA of consecutive nodes in DFS order.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eTlogT\u003c/i\u003e + \u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e \u003d 2 * (\u003ci\u003ek\u003c/i\u003e + \u003ci\u003eq\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e is the total number of nodes in all generators.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\nint n, k, q;\nll cur, sz;\nchar s[200001];\nset\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; nodes;\nmap\u0026lt;ll, int\u0026gt; mp;\nstruct Tree {\n\tvector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; g, dp;\n\tvector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; w;\n\tvector\u0026lt;int\u0026gt; s, e, d;\n\tvector\u0026lt;ll\u0026gt; D;\n\tint dfs;\n\tvoid DFS(int u) {\n\t\ts[u] \u003d ++dfs;\n\t\tfor (int v, i \u003d 0; i \u0026lt; g[u].size(); ++i) {\n\t\t\tv \u003d g[u][i];\n\t\t\td[v] \u003d d[u] + 1;\n\t\t\tif (!w.empty())\n\t\t\t\tD[v] \u003d D[u] + w[u][i];\n\t\t\tdp[0][v] \u003d u;\n\t\t\tDFS(v);\n\t\t}\n\t\te[u] \u003d dfs;\n\t}\n\tvoid buildSparseTable() {\n\t\ts.resize(g.size());\n\t\te.resize(g.size());\n\t\td.resize(g.size());\n\t\tif (!w.empty())\n\t\t\tD.resize(g.size());\n\t\tdfs \u003d 0;\n\t\tint l \u003d 0;\n\t\twhile ((1 \u0026lt;\u0026lt; l) \u0026lt;\u003d g.size())\n\t\t\t++l;\n\t\tdp.resize(l, vector\u0026lt;int\u0026gt;(g.size(), -1));\n\t\tDFS(0);\n\t\tfor (int k \u003d 1; k \u0026lt; l; ++k)\n\t\t\tfor (int u \u003d 0; u \u0026lt; g.size(); ++u)\n\t\t\t\tif (dp[k - 1][u] !\u003d -1)\n\t\t\t\t\tdp[k][u] \u003d dp[k - 1][dp[k - 1][u]];\n\t}\n\tvoid build(char *str) {\n\t\tint cur \u003d 0;\n\t\tstack\u0026lt;int\u0026gt; S;\n\t\tS.push(0);\n\t\tg.resize(1);\n\t\tfor (int i \u003d 0; str[i]; ++i)\n\t\t\tif (str[i] \u003d\u003d \u0027(\u0027) {\n\t\t\t\tg[S.top()].push_back(g.size());\n\t\t\t\tS.push(g.size());\n\t\t\t\tg.push_back(vector\u0026lt;int\u0026gt;());\n\t\t\t}\n\t\t\telse\n\t\t\t\tS.pop();\n\t\tbuildSparseTable();\n\t}\n\tint LCA(int u, int v) {\n\t\tif (d[u] \u0026lt; d[v])\n\t\t\tswap(u, v);\n\t\tint l \u003d 0;\n\t\twhile ((1 \u0026lt;\u0026lt; l) \u0026lt;\u003d d[u])\n\t\t\t++l;\n\t\t--l;\n\t\tfor (int i \u003d l; i \u0026gt;\u003d 0; --i)\n\t\t\tif (d[u] - (1 \u0026lt;\u0026lt; i) \u0026gt;\u003d d[v])\n\t\t\t\tu \u003d dp[i][u];\n\t\tif (u \u003d\u003d v)\n\t\t\treturn u;\n\t\tfor (int i \u003d l; i \u0026gt;\u003d 0; --i)\n\t\t\tif (dp[i][u] !\u003d dp[i][v]) {\n\t\t\t\tu \u003d dp[i][u];\n\t\t\t\tv \u003d dp[i][v];\n\t\t\t}\n\t\treturn dp[0][u];\n\t}\n\tvoid addEdges(int u);\n};\nTree G;\nvoid Tree::addEdges(int u) {\n\tif (u \u0026amp;\u0026amp; mp[sz + u] \u003d\u003d 0) {\n\t\tmp[sz + u] \u003d G.g.size();\n\t\tG.g.push_back(vector\u0026lt;int\u0026gt;());\n\t\tG.w.push_back(vector\u0026lt;int\u0026gt;());\n\t}\n\tauto it \u003d nodes.lower_bound(make_pair(s[u], -1));\n\tif (it !\u003d nodes.end() \u0026amp;\u0026amp; it-\u0026gt;second \u003d\u003d u)\n\t\t++it;\n\twhile (it !\u003d nodes.end() \u0026amp;\u0026amp; it-\u0026gt;first \u0026lt;\u003d e[u]) {\n\t\taddEdges(it-\u0026gt;second);\n\t\tG.g[mp[u \u003d\u003d 0 ? cur : sz + u]].push_back(mp[sz + it-\u0026gt;second]);\n\t\tG.w[mp[u \u003d\u003d 0 ? cur : sz + u]].push_back(d[it-\u0026gt;second] - d[u]);\n\t\tit \u003d nodes.erase(it);\n\t}\n}\nint main()\n{\n\tscanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;n, \u0026amp;k, \u0026amp;q);\n\tvector\u0026lt;Tree\u0026gt; t(n);\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) {\n\t\tscanf(\u0026quot;%s\u0026quot;, s);\n\t\tt[i].build(s);\n\t}\n\tvector\u0026lt;ll\u0026gt; seen;\n\tvector\u0026lt;pair\u0026lt;char, ll\u0026gt; \u0026gt; op(k);\n\tvector\u0026lt;pair\u0026lt;ll, ll\u0026gt; \u0026gt; queries(q);\n\tfor (auto \u0026amp;o : op) {\n\t\tscanf(\u0026quot; %c%lld\u0026quot;, \u0026amp;o.first, \u0026amp;o.second);\n\t\tif (o.first \u003d\u003d \u0027s\u0027)\n\t\t\tseen.push_back(o.second);\n\t}\n\tfor (auto \u0026amp;q : queries) {\n\t\tscanf(\u0026quot;%lld%lld\u0026quot;, \u0026amp;q.first, \u0026amp;q.second);\n\t\tseen.push_back(q.first);\n\t\tseen.push_back(q.second);\n\t}\n\tsort(seen.begin(), seen.end());\n\tseen.resize(unique(seen.begin(), seen.end()) - seen.begin());\n\tmp[1] \u003d 0;\n\tcur \u003d 1;\n\tsz \u003d 1;\n\tG.g.reserve(200000);\n\tG.g.resize(1);\n\tG.w.resize(1);\n\tfor (auto \u0026amp;o : op) {\n\t\tif (o.first \u003d\u003d \u0027s\u0027)\n\t\t\tcur \u003d o.second;\n\t\telse {\n\t\t\tTree \u0026amp;tree \u003d t[o.second - 1];\n\t\t\tll l \u003d sz + 1;\n\t\t\tll r \u003d sz + tree.g.size() - 1;\n\t\t\tvector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; curNodes;\n\t\t\tfor (int i \u003d lower_bound(seen.begin(), seen.end(), l) - seen.begin();\n\t\t\t\ti \u0026lt; seen.size() \u0026amp;\u0026amp; seen[i] \u0026lt;\u003d r; ++i) {\n\t\t\t\tint u \u003d seen[i] - sz;\n\t\t\t\tcurNodes.push_back(make_pair(tree.s[u], u));\n\t\t\t}\n\t\t\tnodes.clear();\n\t\t\tsort(curNodes.begin(), curNodes.end());\n\t\t\tfor (int i \u003d 0; i \u0026lt; curNodes.size(); ++i) {\n\t\t\t\tnodes.insert(curNodes[i]);\n\t\t\t\tif (i + 1 \u003d\u003d curNodes.size())\n\t\t\t\t\tbreak;\n\t\t\t\tint u \u003d curNodes[i].second;\n\t\t\t\tint v \u003d curNodes[i + 1].second;\n\t\t\t\tint lca \u003d tree.LCA(u, v);\n\t\t\t\tnodes.insert(make_pair(tree.s[lca], lca));\n\t\t\t}\n\t\t\ttree.addEdges(0);\n\t\t\tsz +\u003d tree.g.size() - 1;\n\t\t}\n\t}\n\tG.buildSparseTable();\n\tfor (auto \u0026amp;q : queries) {\n\t\tint u \u003d mp[q.first];\n\t\tint v \u003d mp[q.second];\n\t\tint lca \u003d G.LCA(u, v);\n\t\tprintf(\u0026quot;%lld\\n\u0026quot;, G.D[u] + G.D[v] - 2 * G.D[lca]);\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/gym/101798/problem/J\"\u003e\u003cstrong\u003eJ. Complete the Square\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eDrawing a side of a square that already has \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e drawn sides will get us one point and allow us to draw another edge.\u003c/p\u003e\u003cp\u003eCount for each square the number of missing sides, put all squares with \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e missing side in a queue and process them one by one by filling the missing side, increasing the answer by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, and decreasing the number of missing sides of the adjacent square by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. If the adjacent square now has one missing side, add it to the queue.\u003c/p\u003e\u003cp\u003eBe careful with your implementation. It is possible for an edge to complete two squares at the same moment. If the other square is already in the queue, you should not process it or increase the answer by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eComplexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eR\u003c/i\u003e × \u003ci\u003eC\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint R, C;\nchar g[2001][2001];\nint in[2001][2001];\nconst int dr[4] \u003d { -1,1,0,0 };\nconst int dc[4] \u003d { 0,0,-1,1 };\nint main()\n{\n\tscanf(\u0026quot;%d%d\u0026quot;, \u0026amp;R, \u0026amp;C);\n\tqueue\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; q;\n\tfor (int i \u003d 0; i \u0026lt; 2 * R - 1; ++i)\n\t\tscanf(\u0026quot;%s\u0026quot;, g[i]);\n\tfor (int i \u003d 1; i \u0026lt; 2 * R - 1; i +\u003d 2)\n\t\tfor (int j \u003d 1; j \u0026lt; 2 * C - 1; j +\u003d 2) {\n\t\t\tin[i][j] \u003d 4;\n\t\t\tfor (int d \u003d 0; d \u0026lt; 4; ++d) {\n\t\t\t\tint r \u003d i + dr[d];\n\t\t\t\tint c \u003d j + dc[d];\n\t\t\t\tif (g[r][c] \u003d\u003d \u0027.\u0027)\n\t\t\t\t\t--in[i][j];\n\t\t\t}\n\t\t\tif (in[i][j] \u003d\u003d 3)\n\t\t\t\tq.push(make_pair(i, j));\n\t\t}\n\tint res \u003d 0;\n\twhile (!q.empty()) {\n\t\tint r \u003d q.front().first;\n\t\tint c \u003d q.front().second;\n\t\tq.pop();\n\t\tif (in[r][c] \u003d\u003d 4)\n\t\t\tcontinue;\n\t\tin[r][c] \u003d 4;\n\t\t++res;\n\t\tfor (int d \u003d 0; d \u0026lt; 4; ++d) { // find the missing side\n\t\t\tint nr \u003d r + dr[d];\n\t\t\tint nc \u003d c + dc[d];\n\t\t\tif (g[nr][nc] \u003d\u003d \u0027.\u0027) {\n\t\t\t\tg[nr][nc] \u003d d \u0026lt; 2 ? \u0027-\u0027 : \u0027|\u0027;\n\t\t\t\tnr \u003d r + 2 * dr[d];\n\t\t\t\tnc \u003d c + 2 * dc[d];\n\t\t\t\tif (nr \u0026gt;\u003d 0 \u0026amp;\u0026amp; nr \u0026lt; 2 * R - 1 \u0026amp;\u0026amp; nc \u0026gt;\u003d 0 \u0026amp;\u0026amp; nc \u0026lt; 2 * C - 1) {\n\t\t\t\t\t++in[nr][nc];\n\t\t\t\t\tif (in[nr][nc] \u003d\u003d 4)\n\t\t\t\t\t\t++res;\n\t\t\t\t\telse if (in[nr][nc] \u003d\u003d 3)\n\t\t\t\t\t\tq.push(make_pair(nr, nc));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\u0026quot;%d\\n\u0026quot;, res);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}