{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1430513622,"rating":12,"authorHandle":"yermak0v","modificationTimeSeconds":1430723565,"id":17663,"title":"\u003cp\u003eМакросы в С++\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eВсем привет.\u003cbr /\u003e\u003cb\u003e\u003ca name\u003d\"intro\"\u003e\u003c/a\u003eПосле того\u003c/b\u003e как \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/yeputons\" title\u003d\"Международный гроссмейстер yeputons\"\u003eyeputons\u003c/a\u003e разочаровал меня сказав, что \u003ca href\u003d\"//codeforces.com/blog/entry/17660\"\u003eэту задачу\u003c/a\u003e нельзя решить адекватным способом, и дал ссылку на полезные данные по макросам, я решил, что этим всем нужно поделиться со всеми.\u003cbr /\u003eЗначит приступим.\u003cbr /\u003e Для тех, кто не в курсе, макрос — это фрагмент кода, которому дается имя. Когда это имя используется — оно заменяется на содержание макроса. Есть два типа макросов: обычные и функциональные(на английском они называются object-like и function-like, но я бы назвал их именно так).\u003cbr /\u003e\u003cb\u003e\u003ca name\u003d\"object\"\u003e\u003c/a\u003eОбычный макрос\u003c/b\u003e — это простой идентификатор, который будет заменен фрагментом кода. В основном используется как константа, или чтобы дать имя списку чисел и/или константным значениям других типов.\u003cbr /\u003e\u003ci\u003e\u003ca name\u003d\"1\"\u003e\u003c/a\u003eПример 1.\u003c/i\u003e\u003cbr /\u003e\u003ccode\u003e#define MAXN 1000\u003c/code\u003e\u003cbr /\u003eТеперь всегда когда мы будем писать \u003ccode\u003eMAXN\u003c/code\u003e будет использоваться число \u003ccode\u003e1000\u003c/code\u003e.\u003cbr /\u003e\u003ci\u003e\u003ca name\u003d\"2\"\u003e\u003c/a\u003eПример 2.\u003c/i\u003e\u003cbr /\u003e\u003ccode\u003e#define nums 1, 2, 3\u003c/code\u003e Теперь вместо слова \u003ccode\u003enums\u003c/code\u003e будет подставляться \u003ccode\u003e1, 2, 3\u003c/code\u003e\u003cbr /\u003e\u003ci\u003e\u003ca name\u003d\"3\"\u003e\u003c/a\u003eПример 3.\u003c/i\u003e\u003cbr /\u003e\u003ccode\u003e#define mc my_class_with_very_very_long_name\u003c/code\u003e\u003cbr /\u003eТеперь вместо написания иногда очень долгих имен типов мы просто напишем \u003ccode\u003emc\u003c/code\u003e.\u003cbr /\u003e\u003cb\u003e\u003ca name\u003d\"function\"\u003e\u003c/a\u003eФункциональный макрос\u003c/b\u003e — который будет использоваться как функция. Имеет очень много возможностей.\u003cbr /\u003e\u003ci\u003e\u003ca name\u003d\"4\"\u003e\u003c/a\u003eПример 4.\u003c/i\u003e\u003cbr /\u003e\u003ccode\u003e#define abs(x) ((x)\u0026gt;\u003d0?(x):-(x))\u003c/code\u003e\u003cbr /\u003eТеперь мы можем использовать функцию abs(x), при чем \u003ccode\u003ex\u003c/code\u003e может быть любого типа для которого будет работать сравнение \u003ccode\u003ex\u0026gt;\u003d0\u003c/code\u003e.\u003cbr /\u003e\u003ci\u003e\u003ca name\u003d\"5\"\u003e\u003c/a\u003eПример 5.\u003c/i\u003e\u003cbr /\u003e\u003ccode\u003e#define max(a,b) ((a)\u0026gt;(b)?(a):(b))\u003c/code\u003e\u003cbr /\u003eТакой макрос можно спокойно (ну почти спокойно... См. Предупреждение 3.) использовать для нахождения максимума, и как и в прошлом примере для корректности работы необходимо, чтобы выражение \u003ccode\u003e(a)\u0026gt;(b)\u003c/code\u003e имело смысл.\u003cbr /\u003e\u003cb\u003e\u003ca name\u003d\"w1\"\u003e\u003c/a\u003eПредостережение 1.\u003c/b\u003e\u003cbr /\u003eВсе переменные имеет смысл, а иногда даже нужно, брать во скобки, чтобы избежать проблем со старшинством операций. Например, если в качестве аргумента пойдет выражение с битовыми операциями. \u003c/p\u003e\u003cp\u003eМакросы могут вызывать друг друга, и в отличии от функций макрос может вызывать макрос, который описан позже него. Но с рекурсией макросы не дружат — ни с прямой, ни с непрямой.\u003cbr /\u003e\u003cb\u003e\u0026lt;a name\u003d\u0026quot;stringification\u0026gt;Перевод имени переменной в строку\u003c/b\u003e (англ. \u003cb\u003estringification\u003c/b\u003e. Кто-то может перевести это слово?). Можно получить имя переменной как строку.\u003cbr /\u003e\u003ci\u003e\u003ca name\u003d\"6\"\u003e\u003c/a\u003eПример 6.\u003c/i\u003e\u003cbr /\u003e\u003ccode\u003e#define id(x) #x\u003c/code\u003e\u003cbr /\u003e\u003ca href\u003d\"//codeforces.com/blog/entry/17660\"\u003eТут\u003c/a\u003e я немного о ней рассуждал. Единственное скажу — поистине магическая штука...\u003cbr /\u003e\u003cb\u003e\u003ca name\u003d\"concat\"\u003e\u003c/a\u003eКонкатенация строки к имени переменной\u003c/b\u003e. Сразу перейдем к примеру.\u003cbr /\u003e\u003ci\u003e\u003ca name\u003d\"7\"\u003e\u003c/a\u003eПример 7.\u003c/i\u003e\u003cbr /\u003e\u003ccode\u003e#define get(name) (get_##name())\u003c/code\u003e\u003cbr /\u003eОчень полезно в том же самом ООП, когда методов геттеров много. Хотя по сути жизнь и без этого прекрасна.\u003cbr /\u003eОчень много \u003cb\u003e\u003ca name\u003d\"std\"\u003e\u003c/a\u003eстандартных макросов\u003c/b\u003e в С++. Думаю очень много внимания этому уделять не стоит. Кто хочет — \u003ca href\u003d\"https://gcc.gnu.org/onlinedocs/cpp/Predefined-Macros.html#Predefined-Macros\"\u003eпочитайте тут\u003c/a\u003e.\u003cbr /\u003e\u003cb\u003e\u003ca name\u003d\"redef\"\u003e\u003c/a\u003eПереопределение\u003c/b\u003e и \u003cb\u003e\u003ca name\u003d\"undef\"\u003e\u003c/a\u003eудаление макросов\u003c/b\u003e. Переопределение производится новым вызовом директивы \u003ccode\u003e#define name\u003c/code\u003e, где \u003ccode\u003ename\u003c/code\u003e имя уже используемого макроса. Макрос можно переопределить в обычный или функциональный независимо от того, каким он был до этого. Удаление макроса используется при помощи директивы \u003ccode\u003e#undef name\u003c/code\u003e, где \u003ccode\u003ename\u003c/code\u003e имя макроса.\u003cbr /\u003e\u003ci\u003e\u003ca name\u003d\"8\"\u003e\u003c/a\u003eПример 8.\u003c/i\u003e\u003cbr /\u003e\u003ccode\u003e#define func 2\u003c/code\u003e — обычный макрос, который возвращает 2\u003cbr /\u003e\u003ccode\u003e#undef func\u003c/code\u003e — теперь \u003ccode\u003efunc\u003c/code\u003e это обычное имя переменной\u003cbr /\u003e\u003ccode\u003e#define func 5\u003c/code\u003e — снова обычный макрос\u003cbr /\u003e\u003ccode\u003e#define func(x) ((x)+5)\u003c/code\u003e — переопределение в функциональный\u003cbr /\u003eМакрос может быть переопределен даже во время его использования.\u003cbr /\u003e\u003ci\u003e\u003ca name\u003d\"9\"\u003e\u003c/a\u003eПример 9.\u003c/i\u003e \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#define f(a,b) ((a)*(b))\n...  \nf(2,  \n#undef f  \n#define f 3  \nf)  \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eТакой код спокойно возвратит 6. Компилятор при этом будет молчать.\u003cbr /\u003e\u003cb\u003e\u003ca name\u003d\"variable\"\u003e\u003c/a\u003eМакросы с переменным числом аргументов.\u003c/b\u003e Принцип работы примерно такой же, как и в функциях и/или шаблонах с переменным числом аргументов. Примеры \u003ca href\u003d\"https://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html#Variadic-Macros\"\u003eтут\u003c/a\u003e. От себя, к сожалению, ничего не добавлю.\u003cbr /\u003e\u003cb\u003e\u003ca name\u003d\"w2\"\u003e\u003c/a\u003eПредостережение 2.\u003c/b\u003e\u003cbr /\u003eНе желательно передавать аргументами макроса функции. Лучше передать ее результат. Ибо если та переменная в макросе используется больше раза — то функция вызовется очень много раз.\u003cbr /\u003e\u003ci\u003e\u003ca name\u003d\"10\"\u003e\u003c/a\u003eПример 10.\u003c/i\u003e\u003cbr /\u003eВспомним макрос \u003ccode\u003emax\u003c/code\u003e и попробуем запустить такой код \u003ccode\u003emax(x, func(y))\u003c/code\u003e. Этот код после окончательной замены будет выглядеть вот так: \u003ccode\u003e((x)\u0026gt;(func(y))?(x):(func(y))\u003c/code\u003e. Как видим \u003ccode\u003efunc(y)\u003c/code\u003e вызывается два раза. В худшем случае это может существенно повлиять на время работы.\u003cbr /\u003e\u003cb\u003e\u003ca\u003e\u003c/a\u003eПеревод строки\u003c/b\u003e в макросе. Если нужно записать макрос в нескольких строках можно использовать перевод строки \u003ccode\u003e\\\u003c/code\u003e. Думаю к этому можно обойтись и без примера.\u003cbr /\u003e\u003cb\u003e\u003ca name\u003d\"bad-semicolon\"\u003e\u003c/a\u003eБорьба с нежелательной точкой с запятой\u003c/b\u003e.\u003cbr /\u003e\u003ci\u003e\u003ca name\u003d\"11\"\u003e\u003c/a\u003eПример 11.\u003c/i\u003e\u003cbr /\u003eДопустим у нас был такой код: \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#define cnt(x, y)\\  \n{\\  \ny \u003d 0;\\  \nwhile (x \u0026gt; 0) {\\  \n    ++y;\\  \n    x /\u003d 10;\\  \n}  \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЭтот код узнает сколько цифр в числе \u003ccode\u003ex\u003c/code\u003e и записывает результат в \u003ccode\u003ey\u003c/code\u003e (кстати в этом примере скобки не нужны, так как отправь мы в этот макрос не переменную, код не будет компилироваться). Тогда, если вставить его перед \u003ccode\u003eelse\u003c/code\u003e, компилятор заругается на синтаксическую ошибку. Эта проблема решается вот так: \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#define cnt(x, y)\\  \ndo {\\  \ny \u003d 0;\\  \nwhile (x \u0026gt; 0) {\\  \n    ++y;\\  \n    x /\u003d 10;\\  \n} while (0)  \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eИ теперь после него можно всегда ставить точку с запятой.\u003cbr /\u003e\u003cb\u003e\u003ca name\u003d\"examples\"\u003e\u003c/a\u003eИ еще несколько примеров.\u003c/b\u003e\u003cbr /\u003e\u003ci\u003e\u003ca name\u003d\"12\"\u003e\u003c/a\u003eПример 12.\u003c/i\u003e\u003cbr /\u003e\u003ccode\u003e#define forn(i,a,b) for(int i \u003d (a); i \u0026lt; (b); ++i)\u003c/code\u003e\u003cbr /\u003eСамый частый макрос, для упрощения написания циклов.\u003cbr /\u003e\u003ci\u003e\u003ca name\u003d\"13\"\u003e\u003c/a\u003eПример 13.\u003c/i\u003e\u003cbr /\u003e\u003ccode\u003e#define sum(a,b) ((a)+(b))\u003c/code\u003e\u003cbr /\u003eБесполезный, но прикольный макрос, для нахождения оператора \u003ccode\u003e+\u003c/code\u003e двух переменных. Сумма для чисел, конкатенация для строк и т.д.\u003cbr /\u003e\u003cb\u003e\u003ca name\u003d\"outro\"\u003e\u003c/a\u003eНадеюсь\u003c/b\u003e эта запись будет полезна для вас.\u003cbr /\u003e\u003cb\u003e\u003ca name\u003d\"upd\"\u003e\u003c/a\u003e\u003ca name\u003d\"w3\"\u003e\u003c/a\u003eUPD. Предупреждение 3.\u003c/b\u003e\u003cbr /\u003eСпасибо \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/hellman1908\" title\u003d\"Кандидат в мастера hellman1908\"\u003ehellman1908\u003c/a\u003e за пример с инкрементом.\u003cbr /\u003eДаже скобки не всегда могут от всего спасти. Поэтому можно либо следить за всеми переменными, или более реальный вариант — использовать такой или похожий макрос:\u003cbr /\u003e\u003ccode\u003e#define max(a,b) ((___x \u003d (a)) \u0026gt; (___y \u003d (b)) ? x : y)\u003c/code\u003e\u003cbr /\u003eНо тогда переменные \u003ccode\u003e___x\u003c/code\u003e и \u003ccode\u003e___y\u003c/code\u003e придется описать сразу. И тогда вылезают проблемы, ибо \u003ccode\u003e___x\u003c/code\u003e и \u003ccode\u003e___y\u003c/code\u003e у нас статистического типа и т.д. Поэтому полноценного варианта с помощью макроса я не знаю. Но в большинстве случаев первый работает очень хорошо. Могу посоветовать просто не кидать туда никакие выражения.\u003c/p\u003e\u003c/div\u003e","tags":["макросы","с++","#define"]}}