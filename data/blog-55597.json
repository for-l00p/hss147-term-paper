{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1509890953,"rating":-10,"authorHandle":"winner15599","modificationTimeSeconds":1509891106,"id":55597,"title":"\u003cp\u003eSegment tree big integer\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eGiven an array of integers A1,A2,…,AN and the initial value of all elements are 0. Now you are given M queries, each belongs to one of three following types:\u003c/p\u003e\u003cp\u003e0 x y: Find the sum of all elements from index x to index y modulo 109+7\u003c/p\u003e\u003cp\u003e1 x y: Add 1×2×3 to Ax, add 2×3×4 to Ax+1, …, add (i+1)×(i+2)×(i+3) to Ax+iand so on until Ay\u003c/p\u003e\u003cp\u003e2 x y: Subtract 1×2×3 from Ax, subtract 2×3×4 from Ax+1, …, subtract (i+1)×(i+2)×(i+3) from Ax+i and so on until Ay\u003c/p\u003e\u003cp\u003eInput\u003c/p\u003e\u003cp\u003eThe first line contains two integers N and M (1≤N,M≤10^5) — the size of the array and the number of queries, respectively.\u003c/p\u003e\u003cp\u003eEach of the next M lines containts three integers t x y denotes type and range of the query.\u003c/p\u003e\u003cp\u003eOutput\u003c/p\u003e\u003cp\u003eFor each query of type 0, print the required answer in a single line.\u003c/p\u003e\u003cp\u003eSample testcase:\u003c/p\u003e\u003cp\u003eInput\u003c/p\u003e\u003cp\u003e8 4\u003c/p\u003e\u003cp\u003e1 1 8\u003c/p\u003e\u003cp\u003e0 2 8\u003c/p\u003e\u003cp\u003e2 4 6\u003c/p\u003e\u003cp\u003e0 5 6\u003c/p\u003e\u003cp\u003eOuput\u003c/p\u003e\u003cp\u003e1974\u003c/p\u003e\u003cp\u003e462\u003c/p\u003e\u003cp\u003eSample Clarification\u003c/p\u003e\u003cp\u003eIn the example below:\u003c/p\u003e\u003cp\u003eAfter the first query, the array is [6,24,60,120,210,336,504,720]\u003c/p\u003e\u003cp\u003eThe answer for the second query is 24+60+120+210+336+504+720\u003d1974\u003c/p\u003e\u003cp\u003eAfter the third query, the array is [6,24,60,114,186,276,504,720]\u003c/p\u003e\u003cp\u003eThe answer for the last query is 186+276\u003d462\u003c/p\u003e\u003cp\u003eThe above is the subject and the bottom is my code. I don\u0027t understand why it wrong answer. Can you explain to me? Thank you!\u003c/p\u003e\u003cp\u003e#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std;\u003c/p\u003e\u003ch1\u003edefine ll long long\u003c/h1\u003e\u003ch1\u003edefine mod 1000000007\u003c/h1\u003e\u003cp\u003ell arr[100006]; ll t[262200]; ll lazy[262200];\u003c/p\u003e\u003cp\u003evoid build(ll node, ll a, ll b) {  if(a\u0026gt;b) return;  if (a\u003d\u003db)  {  t[node]\u003darr[a];  return;  }\u003c/p\u003e \u003cpre\u003ebuild(node*2, a, (a+b)/2);\nbuild(node*2+1,(a+b)/2+1,b);\n\nt[node]\u003dt[node*2]+t[node*2+1];\u003c/pre\u003e\u003cp\u003e}\u003c/p\u003e\u003cp\u003ell query(ll node, ll a, ll b, ll i, ll j) {  if(a\u0026gt;b||a\u0026gt;j||b\u0026lt;i) return 0;  if (lazy[node] !\u003d0 )  {  t[node]+\u003d (lazy[node]*(b-a+1));  if (a!\u003db)  {  lazy[node*2]+\u003dlazy[node];  lazy[node*2+1]+\u003dlazy[node];  }  lazy[node]\u003d0;  }\u003c/p\u003e \u003cpre\u003eif (a\u0026gt;\u003di \u0026amp;\u0026amp; b\u0026lt;\u003dj) return t[node];\n\nll q1\u003dquery(node*2, a, (a+b)/2, i, j);\nll q2\u003dquery(node*2+1, (a+b)/2+1, b, i, j);\n\nreturn q1+q2;\u003c/pre\u003e\u003cp\u003e}\u003c/p\u003e\u003cp\u003evoid update(ll node, ll a, ll b, ll i, ll j, ll inc) {  if(a\u0026gt;b) return;  if (lazy[node]!\u003d0)  {  t[node]+\u003dlazy[node]*(b-a+1);  if (a!\u003db)  {  lazy[node*2]+\u003dlazy[node];  lazy[node*2+1]+\u003dlazy[node];  }  lazy[node]\u003d0;  }  if(a\u0026gt;b||a\u0026gt;j||b\u0026lt;i) return;\u003c/p\u003e \u003cpre\u003eif (a\u0026gt;\u003di \u0026amp;\u0026amp; b\u0026lt;\u003dj)\n{\n    t[node]+\u003d (inc*(b-a+1)) % mod;\n    if (a!\u003db)\n    {\n        lazy[node*2]+\u003d (inc % mod);\n        lazy[node*2+1]+\u003d (inc % mod);\n    }\n    return;\n}\n\nupdate(node*2, a, (a+b)/2, i, j, inc);\nupdate(node*2+1, (a+b)/2+1, b,i, j, inc);\nt[node] \u003d t[node*2] + t[node*2+1];\u003c/pre\u003e\u003cp\u003e} int main(int argc, char const *argv[]) {  ios_base::sync_with_stdio(0);  ll t,n,m,q,p,a;\u003c/p\u003e \u003cpre\u003ecin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\n    build(1,0,n-1);\n    memset(lazy, 0, sizeof(lazy));\n    while(m--)\n    {\n        cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;p\u0026gt;\u0026gt;q;\n        if (a\u003d\u003d0)\n        {\n            cout\u0026lt;\u0026lt; query(1,0,n-1,p-1,q-1) % mod\u0026lt;\u0026lt;endl;\n        }\n        else if(a \u003d\u003d 1)\n        {\n            ll cnt \u003d 0, res;\n            for(int t \u003d p-1; t \u0026lt;\u003d q-1; t++){\n                res \u003d ((cnt + 1) * (cnt + 2) * (cnt + 3)) % mod;\n                update(1,0,n-1,t,t,res);\n                cnt++;\n            }\n\n        }\n        else if(a \u003d\u003d 2)\n        {\n            ll cnt \u003d 0, res;\n            for(int t \u003d p-1; t \u0026lt;\u003d q-1; t++){\n                res \u003d ((cnt + 1) * (cnt + 2) * (cnt + 3)) % mod;\n                update(1,0,n-1,t,t, -res);\n                cnt++;\n            }\n        }\n    }\n\n\nreturn 0;\u003c/pre\u003e\u003cp\u003e}\u003c/p\u003e\u003c/div\u003e","tags":["c++"]}}