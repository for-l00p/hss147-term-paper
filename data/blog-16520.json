{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1424430089,"rating":-17,"authorHandle":"Amit_Pradhan","modificationTimeSeconds":1424430627,"id":16520,"title":"\u003cp\u003eBug found in Darth Vader and Tree\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cbr /\u003e\u003cbr /\u003e[Porblem](http://codeforces.com/contest/514/problem/E)\n\nHi guys,\n\n\nI think the solution provided for this problem is wrong. I solved this problem in two ways. I have given my solutions below. Please correct me if I am wrong.\n\nApproach-1(recursion) \n-\u0026gt; Start with root \n-\u0026gt; form child nodes if(distance\u0026lt;x) and call this method for all new nodes\n--\u0026gt; count the no of nodes\n- \n**java code:**\n****\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class maxtree {\n\tstatic int count\u003d1;\npublic static void main(String args[]){\n\tScanner sc\u003dnew Scanner(System.in);\n\tint n\u003dsc.nextInt();\n\tint x\u003dsc.nextInt();\n\tint[] d\u003dnew int[n];\n\tfor(int i\u003d0;i\u0026lt;n;i++){\n\t\td[i]\u003dsc.nextInt();\n\t}\n\tArrays.sort(d);\n\t//System.out.println(n+x);\n\tnode n2\u003dnew node(0);\n\t//n2.setDistance(0);\n\tbuild(n2,x,d);\n\tSystem.out.println(count);\n}\npublic static void build(node n,int x,int[] d){\n\tint di\u003dn.getDistance();\n\tif(di\u0026lt;x){\n\t\t//System.out.println(di);\n\t\tint dummy\u003dx-di;\n\t\tint len\u003dd.length;\n\t\tfor(int i\u003d0;i\u0026lt;len \u0026amp;\u0026amp; dummy\u0026gt;\u003dd[i];i++){\n\t\t\tn\u003dnew node(di+d[i]);\n\t\t\t//n.setDistance(di+d[i]);\n\t\t\tcount++;\n\t\t\t//System.out.println(count);\n\t\t\tbuild(n,x,d);\n\t\t}\n\t}\n}\n}\nclass node{\n\tint distance\u003dInteger.MAX_VALUE;\npublic node(int d){\n\tdistance\u003dd;\n}\n\tpublic int getDistance() {\n\t\treturn distance;\n\t}\n\n\tpublic void setDistance(int distance) {\n\t\tthis.distance \u003d distance;\n\t}\n\t\n}\n\n**Second approach(DP):**\n\n-\u0026gt; take all distinct di and sort them \n- \u0026gt;Let the number of vertexes in the tree at distance from the root equal to at most x\u003dno \n- \u0026gt;no(0)\u003d1;\n- \u0026gt;no(1)\u003d2 if di contains 1\n- \u0026gt;for(x\u003dn), this no will be\n-\u0026gt; no(n-d1)+no(n-d2)+no(n-d3)+...........till n\u0026gt;\u003ddi\n\n\n**Java code:**\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class maxtree1 {\n\t//static int count\u003d1;\npublic static void main(String args[]){\n\tScanner sc\u003dnew Scanner(System.in);\n\tint n\u003dsc.nextInt();\n\tint x\u003dsc.nextInt();\n\tint[] d\u003dnew int[n];\n\tfor(int i\u003d0;i\u0026lt;n;i++){\n\t\td[i]\u003dsc.nextInt();\n\t}\n\tArrays.sort(d);\n\t//System.out.println(n+x);\n\tlong[] table\u003dnew long[x];\n\tif(d[0]\u003d\u003d1){\n\t\ttable[0]\u003d2;\n\t}else{\n\t\ttable[0]\u003d1;\n\t}\n\tint count\u003d0;\n\tfor(int i\u003d1;i\u0026lt;x;i++){\n\t\tcount\u003d1;\n\t\tfor(int j\u003d0;j\u0026lt;n \u0026amp;\u0026amp; i+1\u0026gt;\u003dd[j];j++){\n\t\t\tif(i+1!\u003dd[j]){\n\t\t\tcount+\u003dtable[i-d[j]];\n\t\t\t}else{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\ttable[i]\u003dcount;\n\t\t}\n\t\tSystem.out.println(table[i]);\n\t}\n}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["darth vader and tree","bug","error"]}}