{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1520066628,"rating":81,"authorHandle":"lewin","modificationTimeSeconds":1520066628,"id":58135,"title":"\u003cp\u003eEditorial Round 1 of Yandex.Algorithm 2018\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ePolice Patrol\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFirst, let\u0027s try to find the largest block that two patrols can cover (hint, it\u0027s not k). For instance, we can have one patrol cover \u003cspan class\u003d\"tex-span\"\u003e1, 2, ..., \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. and the other cover \u003cspan class\u003d\"tex-span\"\u003e2, 3, ..., \u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSo, we can split \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e houses into blocks of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/span\u003e. Now, we have to look at what to do with the leftover houses. If there are more than two empty blocks, we need two patrols to cover both blocks. If there is only one empty block, we only need one patrol. Thus, the answer can be computed by the formula in the code below\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003en,k \u003d map(int, raw_input().split())\nprint (n/(k+1))*2 + min(2, n%(k+1))\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eAlphabetic Subsequence\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eWe can check that this is equivalent to counting the number of permutations of \u003cspan class\u003d\"tex-span\"\u003e0, 1, 2, ..., 9\u003c/span\u003e that appear in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThere are two solutions:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003esolution 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eJust do it. This is O(10! * |s|) ~ 3*10^8. This is fast enough in some languages.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define forn(i, n) for (int i \u003d 0; i \u0026lt; (int)(n); ++i)\n#define fore(i, b, e) for (int i \u003d (int)(b); i \u0026lt;\u003d (int)(e); ++i)\n#define ford(i, n) for (int i \u003d (int)(n) - 1; i \u0026gt;\u003d 0; --i)\n#define pb push_back\n#define fi first\n#define se second\n#define all(x) (x).begin(), (x).end()\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef pair\u0026lt;int, int\u0026gt; pii;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef long double ld;\ntypedef long long ll;\n\nconst int maxn \u003d 105;\n\nint n;\nint a[maxn];\nint p[maxn];\n\nbool check() {\n    int cur \u003d 0;\n    forn(i, n) {\n        if (p[a[i]] \u003d\u003d cur) ++cur;\n    }\n    return cur \u003d\u003d 10;\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\u0026quot;b.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n#endif\n\n    char c;\n    while (cin \u0026gt;\u0026gt; c) { a[n++] \u003d c-\u00270\u0027; }\n    forn(i, 10) p[i] \u003d i;\n    int cnt \u003d 0;\n    do {\n        cnt +\u003d check();\n    } while (next_permutation(p, p+10));\n    cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl;\n\n#ifdef LOCAL\n    cerr \u0026lt;\u0026lt; \u0026quot;Time elapsed: \u0026quot; \u0026lt;\u0026lt; clock() / 1000 \u0026lt;\u0026lt; \u0026quot; ms\u0026quot; \u0026lt;\u0026lt; endl;\n#endif\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003esolution 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eWe can do a bitmask dp. We need to be careful not to double count, so we advance our index to the first occurence of some character to take it. See the code for more details.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;vector\u0026gt;\nusing namespace std;\n\nconst int N \u003d 105;\nvector\u0026lt;int\u0026gt; pos[N];\n\nchar buf[N];\n\nconst int MSK \u003d 1 \u0026lt;\u0026lt; 10;\nint D[MSK][N];\n\nconst int K \u003d 10;\n\nint main() {\n    scanf(\u0026quot;%s\u0026quot;, buf);\n    int n \u003d strlen(buf);\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        pos[buf[i] - \u00270\u0027].push_back(i);\n    }\n    D[0][0] \u003d 1;\n    for (int msk \u003d 0; msk \u0026lt; MSK - 1; msk++) {\n        for (int i \u003d 0; i \u0026lt; K; i++) {\n            if ((msk \u0026gt;\u0026gt; i) \u0026amp; 1) {\n                continue;\n            }\n            for (int j \u003d 0; j \u0026lt;\u003d n + 1; j++) {\n                if (j \u003d\u003d n + 1) {\n                    D[msk | (1 \u0026lt;\u0026lt; i)][j] +\u003d D[msk][j];\n                } else {\n                    int p \u003d lower_bound(pos[i].begin(), pos[i].end(), j) - pos[i].begin();\n                    if (p \u003d\u003d pos[i].size()) {\n                        p \u003d n + 1;\n                    } else {\n                        p \u003d pos[i][p];\n                    }\n                    D[msk | (1 \u0026lt;\u0026lt; i)][p + 1] +\u003d D[msk][j];\n                }\n            }\n        }\n    }\n    int ans \u003d 0;\n    for (int i \u003d 0; i \u0026lt;\u003d n; i++) {\n        ans +\u003d D[MSK - 1][i];\n    }\n    printf(\u0026quot;%d\\n\u0026quot;, ans);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eInfinite Graph Game\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eConsider at each step, instead of adding our score to a global counter, we incremented the score at a particular vertex. So, we only need to simulate one round, and can multiply by an appropriate constant to get the limit value. We can also check the infinite case here (the contribution of a node is nonzero and it never gets chosen so its value never gets reduced).\u003c/p\u003e\u003cp\u003eThe problem is that this approach takes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enk\u003c/i\u003e)\u003c/span\u003e time in the worst case. Let\u0027s look at each edge individually. If node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e appears \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e times, and node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e appears \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e times in our sequence, we can get the contribution of this edge onto each node\u0027s values in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e time. We can also further reduce this to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003emin\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e) * \u003ci\u003elog\u003c/i\u003e(\u003ci\u003emax\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/sub\u003e)))\u003c/span\u003e time by iterating through the explicit occurences of the node that appears fewer times, and using some data structures to count the number of occurences of the other node between any two explicit occurences.\u003c/p\u003e\u003cp\u003eWith this reduction, this brings our running time to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e * \u003ci\u003esqrt\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e) * \u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e (for example, see this problem for analysis: \u003ca href\u003d\"//codeforces.com/problemset/problem/804/D\"\u003ehttp://codeforces.com/problemset/problem/804/D\u003c/a\u003e)\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ec++ code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;vector\u0026gt;\nusing namespace std;\n\nconst int MOD \u003d 1000 * 1000 * 1000 + 7;\n\ninline int add(int a, int b) {\n    if ((a +\u003d b) \u0026gt;\u003d MOD) {\n        a -\u003d MOD;\n    }\n    return a;\n}\n\ntypedef long long llong;\n\ninline int mul(int a, int b) {\n    return ((llong)a) * b % MOD;\n}\n\ninline int sub(int a, int b) {\n    if ((a -\u003d b) \u0026lt; 0) {\n        a +\u003d MOD;\n    }\n    return a;\n}\n\nint powmod(int a, int b) {\n    int res \u003d 1;\n    while (b \u0026gt; 0) {\n        if (b \u0026amp; 1) {\n            res \u003d mul(res, a);\n        }\n        a \u003d mul(a, a);\n        b \u0026gt;\u0026gt;\u003d 1;\n    }\n    return res;\n}\n\nint inv(int x) {\n    return powmod(x, MOD - 2);\n}\n\nconst int N \u003d 100500;\n\nint V[N];\n\nvector\u0026lt;int\u0026gt; history[N];\n\nint AF[N];\n\nvoid die() {\n    puts(\u0026quot;-1\u0026quot;);\n    exit(0);\n}\n\nint pw2[N];\n\nint main() {\n    int n, m, k;\n    scanf(\u0026quot;%d %d %d\u0026quot;, \u0026amp;n, \u0026amp;m, \u0026amp;k);\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        scanf(\u0026quot;%d\u0026quot;, \u0026amp;V[i]);\n    }\n    for (int i \u003d 0; i \u0026lt; k; i++) {\n        int s;\n        scanf(\u0026quot;%d\u0026quot;, \u0026amp;s);\n        --s;\n        history[s].push_back(i);\n    }\n    pw2[0] \u003d 1;\n    for (int i \u003d 0; i \u0026lt; k; i++) {\n        pw2[i + 1] \u003d (pw2[i] % 2 \u003d\u003d 0) ? pw2[i] / 2 : (pw2[i] + MOD) / 2;\n    }\n\n    for (int i \u003d 0; i \u0026lt; m; i++) {\n        int a, b;\n        scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;a, \u0026amp;b);\n        --a, --b;\n        if (history[a].size() \u0026gt; history[b].size()) {\n            swap(a, b);\n        }\n        if (history[b].empty()) {\n            continue;\n        } else if (history[a].empty()) {\n            if (V[a] \u003d\u003d 0) {\n                continue;\n            } else {\n                die();\n            }\n        } else {\n            int prv \u003d 0;\n            for (int i \u003d 0; i \u0026lt; (int)history[a].size(); i++) {\n                int x \u003d history[a][i];\n                int p \u003d lower_bound(history[b].begin(), history[b].end(), x) - history[b].begin();\n                AF[b] \u003d add(AF[b], pw2[p]);\n                AF[a] \u003d add(AF[a], mul(p - prv, pw2[i]));\n                prv \u003d p;\n            }\n            AF[a] \u003d add(AF[a], mul((int)history[b].size() - prv, pw2[(int)history[a].size()]));\n        }\n    }\n\n    int ans \u003d 0;\n\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        if (AF[i] !\u003d 0) {\n            assert(!history[i].empty());\n        }\n        int k \u003d pw2[(int)history[i].size()];\n        int num \u003d mul(AF[i], V[i]);\n        int den \u003d sub(1, k);\n        ans \u003d add(ans, mul(num, inv(den)));\n    }\n    printf(\u0026quot;%d\\n\u0026quot;, ans);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ejava code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.stream.Stream;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream \u003d System.in;\n        OutputStream outputStream \u003d System.out;\n        InputReader in \u003d new InputReader(inputStream);\n        OutputWriter out \u003d new OutputWriter(outputStream);\n        InfiniteGraphGame solver \u003d new InfiniteGraphGame();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class InfiniteGraphGame {\n        public int mod \u003d 1000000007;\n        int[] cc;\n        int[] sz;\n        ArrayList\u0026lt;Integer\u0026gt;[] pos;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n \u003d in.nextInt(), m \u003d in.nextInt(), k \u003d in.nextInt();\n            int[] v \u003d in.readIntArray(n);\n            int[] s \u003d in.readIntArray(k);\n            for (int i \u003d 0; i \u0026lt; k; i++) s[i]--;\n            pos \u003d Stream.generate(ArrayList::new).limit(n).toArray(ArrayList[]::new);\n            for (int i \u003d 0; i \u0026lt; n; i++) pos[i].add(0);\n            cc \u003d new int[k + 1];\n            sz \u003d new int[n];\n            for (int i \u003d 1; i \u0026lt;\u003d k; i++) {\n                cc[i] \u003d pos[s[i - 1]].size();\n                pos[s[i - 1]].add(i);\n                sz[s[i - 1]]++;\n            }\n\n            long[] div2 \u003d new long[k + 1];\n            div2[0] \u003d 1;\n            long mult \u003d Utils.inv(2, mod);\n            for (int i \u003d 1; i \u0026lt; div2.length; i++) {\n                div2[i] \u003d div2[i - 1] * mult % mod;\n            }\n\n            long ans \u003d 0;\n            for (int i \u003d 0; i \u0026lt; m; i++) {\n                int a \u003d in.nextInt() - 1, b \u003d in.nextInt() - 1;\n                if (sz[a] \u0026gt; sz[b]) {\n                    int t \u003d a;\n                    a \u003d b;\n                    b \u003d t;\n                }\n                if (sz[b] \u0026gt; 0 \u0026amp;\u0026amp; sz[a] \u003d\u003d 0 \u0026amp;\u0026amp; v[a] \u0026gt; 0) {\n                    out.println(-1);\n                    return;\n                }\n\n                long sa \u003d 0, sb \u003d 0;\n                int da \u003d 0, db \u003d 0;\n                int lastw \u003d 0;\n                for (int q : pos[a]) {\n                    if (q \u003d\u003d 0) continue;\n                    int curw \u003d cc[pos[b].get(-Collections.binarySearch(pos[b], q) - 2)];\n                    long w \u003d curw - lastw;\n                    lastw \u003d curw;\n\n                    sa \u003d (sa + 1L * w * v[a] % mod * div2[da]) % mod;\n                    db +\u003d w;\n                    sb \u003d (sb + v[b] * div2[db]) % mod;\n                    da++;\n                }\n                {\n                    long w \u003d sz[b] - lastw;\n                    sa \u003d (sa + 1L * w * v[a] % mod * div2[da]) % mod;\n                    db +\u003d w;\n                }\n\n                sa \u003d sa * Utils.inv(1 - div2[da] + mod, mod) % mod;\n                sb \u003d sb * Utils.inv(1 - div2[db] + mod, mod) % mod;\n                ans \u003d (ans + sa + sb) % mod;\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer \u003d new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer \u003d new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf \u003d new byte[1 \u0026lt;\u0026lt; 16];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream \u003d stream;\n        }\n\n        public int[] readIntArray(int tokens) {\n            int[] ret \u003d new int[tokens];\n            for (int i \u003d 0; i \u0026lt; tokens; i++) {\n                ret[i] \u003d nextInt();\n            }\n            return ret;\n        }\n\n        public int read() {\n            if (this.numChars \u003d\u003d -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar \u0026gt;\u003d this.numChars) {\n                    this.curChar \u003d 0;\n\n                    try {\n                        this.numChars \u003d this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars \u0026lt;\u003d 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c \u003d this.read(); isSpaceChar(c); c \u003d this.read()) {\n                ;\n            }\n\n            byte sgn \u003d 1;\n            if (c \u003d\u003d 45) {\n                sgn \u003d -1;\n                c \u003d this.read();\n            }\n\n            int res \u003d 0;\n\n            while (c \u0026gt;\u003d 48 \u0026amp;\u0026amp; c \u0026lt;\u003d 57) {\n                res *\u003d 10;\n                res +\u003d c - 48;\n                c \u003d this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c \u003d\u003d 32 || c \u003d\u003d 10 || c \u003d\u003d 13 || c \u003d\u003d 9 || c \u003d\u003d -1;\n        }\n\n    }\n\n    static class Utils {\n        public static long inv(long N, long M) {\n            long x \u003d 0, lastx \u003d 1, y \u003d 1, lasty \u003d 0, q, t, a \u003d N, b \u003d M;\n            while (b !\u003d 0) {\n                q \u003d a / b;\n                t \u003d a % b;\n                a \u003d b;\n                b \u003d t;\n                t \u003d x;\n                x \u003d lastx - q * x;\n                lastx \u003d t;\n                t \u003d y;\n                y \u003d lasty - q * y;\n                lasty \u003d t;\n            }\n            return (lastx + M) % M;\n        }\n\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eStamp Stamp Stamp\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThe bounds might look a bit strange, and it was a bit hard to find good bounds for this. Originally, I wanted to set bounds higher so only \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e·\u003ci\u003elogn\u003c/i\u003e)\u003c/span\u003e solutions could pass, but it seems the constant factor for that solution is too high. So, I set bounds low enough so a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e)\u003c/span\u003e solution could pass as well.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eO(n^4)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFor an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e4\u003c/sup\u003e)\u003c/span\u003e solution, we can check all O(n^2) substrings. Now, we want to know if this string can stamp out the entire string. We can do this with dp. Let dp[i][j] be true if it is possible to stamp out the prefix \u003cspan class\u003d\"tex-span\"\u003e1, ..., \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ej\u003c/i\u003e + 1, ..., \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e possibly left over the right edge. You can see the code below on how to update the dp table. This takes O(m^2) time per string so overall runtime is O(n^4) with a fairly low constant. We can get some more constant factor optimizations by doing some early breaks.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define forn(i, n) for (int i \u003d 0; i \u0026lt; (int)(n); ++i)\n#define fore(i, b, e) for (int i \u003d (int)(b); i \u0026lt;\u003d (int)(e); ++i)\n#define ford(i, n) for (int i \u003d (int)(n) - 1; i \u0026gt;\u003d 0; --i)\n#define pb push_back\n#define fi first\n#define se second\n#define all(x) (x).begin(), (x).end()\ntypedef vector\u0026lt;int\u0026gt; vi;\ntypedef pair\u0026lt;int, int\u0026gt; pii;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef long double ld;\ntypedef long long ll;\n\nconst int maxn \u003d 500;\n\nint n, m;\nstring s;\nstring t;\nchar d[maxn][maxn];\n\nvoid scan() {\n    cin \u0026gt;\u0026gt; s;\n    n \u003d s.size();\n}\n\nbool check() {\n    memset(d, 0, sizeof d);\n    m \u003d t.size();\n    if (s[0] !\u003d t[0]) return false;\n    d[1][1] \u003d 1;\n    fore(i, 2, n) fore(j, 1, m) if (t[j-1] \u003d\u003d s[i-1]) {\n        if (d[i-1][j-1]) d[i][j] \u003d 1;\n        if (d[i-1][m]) d[i][j] \u003d 1;\n        if (j \u003d\u003d 1) fore(k, 1, m-1) if (d[i-1][k]) { d[i][j] \u003d 1; break; }\n    }\n    return d[n][m];\n}\n\nvoid solve() {\n    set\u0026lt;string\u0026gt; res;\n    set\u0026lt;string\u0026gt; seen;\n    forn(i, n) forn(len, n-i+1) if (len) {\n        t \u003d s.substr(i, len);\n        if (seen.count(t)) continue;\n        seen.insert(t);\n        if (check()) res.insert(t);\n    }\n    for (auto s: res) {\n        cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n    }\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\u0026quot;e.in\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n#endif\n\n    scan();\n    solve();\n\n#ifdef LOCAL\n    cerr \u0026lt;\u0026lt; \u0026quot;Time elapsed: \u0026quot; \u0026lt;\u0026lt; clock() / 1000 \u0026lt;\u0026lt; \u0026quot; ms\u0026quot; \u0026lt;\u0026lt; endl;\n#endif\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eO(n^3 log n)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFor an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e·\u003ci\u003elogn\u003c/i\u003e)\u003c/span\u003e solution, consider all occurences of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e (these can be found in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003es\u003c/i\u003e| + |\u003ci\u003et\u003c/i\u003e|)\u003c/span\u003e time). Then, consider extending a region as far as we can left by prepending a prefix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e, and extending a region as far as we can to the right by appending a suffix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e. This can be done with a stack or segment trees. Then, we have a set of intervals, and we want to check it covers \u003cspan class\u003d\"tex-span\"\u003e1, ..., \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. This can also be done in time after sorting. Note, there is some tricky case in that if there can be gaps between the intervals, but these gaps need to consist of substrings of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e. This can also be checked in linear time using suffix automaton.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main2 {\n    public static void main(String[] args) {\n        InputStream inputStream \u003d System.in;\n        OutputStream outputStream \u003d System.out;\n        InputReader in \u003d new InputReader(inputStream);\n        OutputWriter out \u003d new OutputWriter(outputStream);\n        StampStampStamp solver \u003d new StampStampStamp();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class StampStampStamp {\n        String s;\n        SegmentTreeFast st;\n        int[] r1;\n        int[] r2;\n        int[] left;\n        int[] right;\n        Pair\u0026lt;Integer, Integer\u0026gt;[] pp;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            s \u003d in.next();\n            int n \u003d s.length();\n            r1 \u003d new int[n];\n            r2 \u003d new int[n];\n            left \u003d new int[n];\n            right \u003d new int[n];\n            st \u003d new SegmentTreeFast(n);\n            pp \u003d new Pair[n];\n            HashSet\u0026lt;String\u0026gt; ss \u003d new HashSet\u0026lt;\u0026gt;();\n            HashSet\u0026lt;String\u0026gt; t \u003d new HashSet\u0026lt;\u0026gt;();\n            for (int i \u003d 0; i \u0026lt; n; i++) {\n                for (int j \u003d i; j \u0026lt; n; j++) {\n                    String test \u003d s.substring(i, j + 1);\n                    if (t.add(test) \u0026amp;\u0026amp; ok(test, s)) {\n                        ss.add(test);\n                    }\n                }\n            }\n            ArrayList\u0026lt;String\u0026gt; ans \u003d new ArrayList\u0026lt;\u0026gt;(ss);\n            Collections.sort(ans);\n            for (String x : ans) out.println(x);\n        }\n\n        boolean ok(String sub, String all) {\n            if (sub.charAt(0) !\u003d all.charAt(0) || sub.charAt(sub.length() - 1) !\u003d all.charAt(all.length() - 1))\n                return false;\n            HashSet\u0026lt;Character\u0026gt; tt \u003d new HashSet\u0026lt;\u0026gt;();\n            for (char k : sub.toCharArray()) tt.add(k);\n            for (char k : all.toCharArray()) if (!tt.contains(k)) return false;\n            char[] c1 \u003d (sub + \u0026quot;*\u0026quot; + all).toCharArray();\n            int[] z1 \u003d ZAlgorithm.zAlgorithm(c1);\n            char[] c2 \u003d (new StringBuffer(sub).reverse().toString() + \u0026quot;*\u0026quot; +\n                    new StringBuffer(all).reverse().toString()).toCharArray();\n            int[] z2 \u003d ZAlgorithm.zAlgorithm(c2);\n\n            int m \u003d sub.length();\n            int n \u003d all.length();\n            st.clear();\n            for (int i \u003d n - 1; i \u0026gt;\u003d 0; i--) {\n                int z \u003d z1[i + m + 1];\n                if (z \u003d\u003d 0) {\n                    r1[i] \u003d -1;\n                } else {\n                    r1[i] \u003d Math.max(i + z - 1, st.query(i + 1, i + z));\n                }\n                st.modify(i, i, r1[i]);\n                pp[i] \u003d new Pair(-r1[i], i);\n            }\n            Arrays.sort(pp);\n            int idx \u003d 0;\n            int min \u003d n;\n            for (int i \u003d n - 1; i \u0026gt;\u003d 0; i--) {\n                while (idx \u0026lt; n \u0026amp;\u0026amp; -pp[idx].u \u0026gt;\u003d i) {\n                    min \u003d Math.min(min, pp[idx].v);\n                    idx++;\n                }\n                left[i] \u003d Math.min(min, i + 1);\n            }\n\n            st.clear();\n            int[] right \u003d new int[n];\n            for (int i \u003d 0; i \u0026lt; n; i++) {\n                int z \u003d z2[n - i - 1 + m + 1];\n                if (z \u003d\u003d 0) {\n                    r2[i] \u003d n + 1;\n                } else {\n                    r2[i] \u003d Math.min(i - z + 1, -st.query(i - z, i - 1));\n                }\n                st.modify(i, i, -r2[i]);\n                pp[i] \u003d new Pair(r2[i], i);\n            }\n            Arrays.sort(pp);\n            idx \u003d 0;\n            int max \u003d -1;\n            for (int i \u003d 0; i \u0026lt; n; i++) {\n                while (idx \u0026lt; n \u0026amp;\u0026amp; pp[idx].u \u0026lt;\u003d i) {\n                    max \u003d Math.max(max, pp[idx].v);\n                    idx++;\n                }\n                right[i] \u003d Math.max(i - 1, max);\n            }\n\n            ArrayList\u0026lt;Integer\u0026gt; evts \u003d new ArrayList\u0026lt;\u0026gt;();\n\n            for (int i \u003d 0; i \u0026lt; n; i++) {\n                if (z1[i + m + 1] \u003d\u003d m) {\n                    evts.add((i \u003d\u003d 0 ? 0 : left[i - 1]) * 2 + 0);\n                    evts.add(right[i] * 2 + 1);\n                }\n            }\n            Collections.sort(evts);\n            SuffixAutomaton.State[] automaton \u003d SuffixAutomaton.buildSuffixAutomaton(sub);\n            int psum \u003d 0;\n            for (int i \u003d 0; i + 1 \u0026lt; evts.size(); i++) {\n                int k \u003d evts.get(i);\n                if (k % 2 \u003d\u003d 0) psum++;\n                else psum--;\n                if (psum \u003d\u003d 0) {\n                    int cur \u003d k / 2 + 1;\n                    int nxt \u003d evts.get(i + 1) / 2;\n                    int node \u003d 0;\n                    for (int j \u003d cur; j \u0026lt; nxt; j++) {\n                        int next \u003d automaton[node].next[all.charAt(j)];\n                        if (next \u003d\u003d -1) return false;\n                        node \u003d next;\n                    }\n                }\n            }\n            return evts.get(0) / 2 \u003d\u003d 0 \u0026amp;\u0026amp; evts.get(evts.size() - 1) / 2 \u003d\u003d n - 1;\n        }\n\n    }\n\n    static class ZAlgorithm {\n        public static int[] zAlgorithm(char[] let) {\n            int N \u003d let.length;\n            int[] z \u003d new int[N];\n            int L \u003d 0, R \u003d 0;\n            for (int i \u003d 1; i \u0026lt; N; i++) {\n                if (i \u0026gt; R) {\n                    L \u003d R \u003d i;\n                    while (R \u0026lt; N \u0026amp;\u0026amp; let[R - L] \u003d\u003d let[R])\n                        R++;\n                    z[i] \u003d R - L;\n                    R--;\n                } else {\n                    int k \u003d i - L;\n                    if (z[k] \u0026lt; R - i + 1)\n                        z[i] \u003d z[k];\n                    else {\n                        L \u003d i;\n                        while (R \u0026lt; N \u0026amp;\u0026amp; let[R - L] \u003d\u003d let[R])\n                            R++;\n                        z[i] \u003d R - L;\n                        R--;\n                    }\n                }\n            }\n            z[0] \u003d N;\n            return z;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer \u003d new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer \u003d new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i \u003d 0; i \u0026lt; objects.length; i++) {\n                if (i !\u003d 0) {\n                    writer.print(\u0027 \u0027);\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class SuffixAutomaton {\n        public static SuffixAutomaton.State[] buildSuffixAutomaton(CharSequence s) {\n            int n \u003d s.length();\n            SuffixAutomaton.State[] st \u003d new SuffixAutomaton.State[Math.max(2, 2 * n - 1)];\n            st[0] \u003d new SuffixAutomaton.State();\n            st[0].suffLink \u003d -1;\n            int last \u003d 0;\n            int size \u003d 1;\n            for (int i \u003d 0; i \u0026lt; s.length(); i++) {\n                char c \u003d s.charAt(i);\n                int cur \u003d size++;\n                st[cur] \u003d new SuffixAutomaton.State();\n                st[cur].length \u003d i + 1;\n                st[cur].firstPos \u003d i;\n                int p \u003d last;\n                for (; p !\u003d -1 \u0026amp;\u0026amp; st[p].next[c] \u003d\u003d -1; p \u003d st[p].suffLink) {\n                    st[p].next[c] \u003d cur;\n                }\n                if (p \u003d\u003d -1) {\n                    st[cur].suffLink \u003d 0;\n                } else {\n                    int q \u003d st[p].next[c];\n                    if (st[p].length + 1 \u003d\u003d st[q].length) {\n                        st[cur].suffLink \u003d q;\n                    } else {\n                        int clone \u003d size++;\n                        st[clone] \u003d new SuffixAutomaton.State();\n                        st[clone].length \u003d st[p].length + 1;\n                        System.arraycopy(st[q].next, 0, st[clone].next, 0, st[q].next.length);\n                        st[clone].suffLink \u003d st[q].suffLink;\n                        for (; p !\u003d -1 \u0026amp;\u0026amp; st[p].next[c] \u003d\u003d q; p \u003d st[p].suffLink) {\n                            st[p].next[c] \u003d clone;\n                        }\n                        st[q].suffLink \u003d clone;\n                        st[cur].suffLink \u003d clone;\n                    }\n                }\n                last \u003d cur;\n            }\n            for (int i \u003d 1; i \u0026lt; size; i++) {\n                st[st[i].suffLink].invSuffLinks.add(i);\n            }\n            return Arrays.copyOf(st, size);\n        }\n\n        public static class State {\n            public int length;\n            public int suffLink;\n            public List\u0026lt;Integer\u0026gt; invSuffLinks \u003d new ArrayList\u0026lt;\u0026gt;(0);\n            public int firstPos \u003d -1;\n            public int[] next \u003d new int[128];\n\n            {\n                Arrays.fill(next, -1);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf \u003d new byte[1 \u0026lt;\u0026lt; 16];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream \u003d stream;\n        }\n\n        public int read() {\n            if (this.numChars \u003d\u003d -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar \u0026gt;\u003d this.numChars) {\n                    this.curChar \u003d 0;\n\n                    try {\n                        this.numChars \u003d this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars \u0026lt;\u003d 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public String next() {\n            int c;\n            while (isSpaceChar(c \u003d this.read())) {\n                ;\n            }\n\n            StringBuilder result \u003d new StringBuilder();\n            result.appendCodePoint(c);\n\n            while (!isSpaceChar(c \u003d this.read())) {\n                result.appendCodePoint(c);\n            }\n\n            return result.toString();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c \u003d\u003d 32 || c \u003d\u003d 10 || c \u003d\u003d 13 || c \u003d\u003d 9 || c \u003d\u003d -1;\n        }\n\n    }\n\n    static class SegmentTreeFast {\n        int[] value;\n        int[] delta;\n\n        public SegmentTreeFast(int n) {\n            value \u003d new int[2 * n];\n            for (int i \u003d 0; i \u0026lt; n; i++) {\n                value[i + n] \u003d getInitValue();\n            }\n            for (int i \u003d 2 * n - 1; i \u0026gt; 1; i -\u003d 2) {\n                value[i \u0026gt;\u0026gt; 1] \u003d queryOperation(value[i], value[i ^ 1]);\n            }\n            delta \u003d new int[2 * n];\n            Arrays.fill(delta, getNeutralDelta());\n        }\n\n        public void clear() {\n            int n \u003d value.length / 2;\n            for (int i \u003d 0; i \u0026lt; n; i++) {\n                value[i + n] \u003d getInitValue();\n            }\n            for (int i \u003d 2 * n - 1; i \u0026gt; 1; i -\u003d 2) {\n                value[i \u0026gt;\u0026gt; 1] \u003d queryOperation(value[i], value[i ^ 1]);\n            }\n            Arrays.fill(delta, getNeutralDelta());\n        }\n\n        int modifyOperation(int x, int y) {\n            return Math.max(x, y);\n        }\n\n        int queryOperation(int leftValue, int rightValue) {\n            return Math.max(leftValue, rightValue);\n        }\n\n        int deltaEffectOnSegment(int delta, int segmentLength) {\n            if (delta \u003d\u003d getNeutralDelta()) return getNeutralDelta();\n            // Here you must write a fast equivalent of following slow code:\n            // int result \u003d delta;\n            // for (int i \u003d 1; i \u0026lt; segmentLength; i++) result \u003d queryOperation(result, delta);\n            // return result;\n            return delta;\n//        return delta * segmentLength;\n        }\n\n        int getNeutralDelta() {\n            return -(1 \u0026lt;\u0026lt; 29);\n        }\n\n        int getInitValue() {\n            return -(1 \u0026lt;\u0026lt; 29);\n        }\n\n        int joinValueWithDelta(int value, int delta) {\n            if (delta \u003d\u003d getNeutralDelta()) return value;\n            return modifyOperation(value, delta);\n        }\n\n        int joinDeltas(int delta1, int delta2) {\n            if (delta1 \u003d\u003d getNeutralDelta()) return delta2;\n            if (delta2 \u003d\u003d getNeutralDelta()) return delta1;\n            return modifyOperation(delta1, delta2);\n        }\n\n        void pushDelta(int i) {\n            int d \u003d 0;\n            for (; (i \u0026gt;\u0026gt; d) \u0026gt; 0; d++) {\n            }\n            for (d -\u003d 2; d \u0026gt;\u003d 0; d--) {\n                int x \u003d i \u0026gt;\u0026gt; d;\n                value[x \u0026gt;\u0026gt; 1] \u003d joinNodeValueWithDelta(x \u0026gt;\u0026gt; 1, 1 \u0026lt;\u0026lt; (d + 1));\n                delta[x] \u003d joinDeltas(delta[x], delta[x \u0026gt;\u0026gt; 1]);\n                delta[x ^ 1] \u003d joinDeltas(delta[x ^ 1], delta[x \u0026gt;\u0026gt; 1]);\n                delta[x \u0026gt;\u0026gt; 1] \u003d getNeutralDelta();\n            }\n        }\n\n        int joinNodeValueWithDelta(int i, int len) {\n            return joinValueWithDelta(value[i], deltaEffectOnSegment(delta[i], len));\n        }\n\n        public int query(int from, int to) {\n            to \u003d Math.min(to, value.length / 2 - 1);\n            from \u003d Math.max(from, 0);\n            if (to \u0026lt; from) return getInitValue();\n            from +\u003d value.length \u0026gt;\u0026gt; 1;\n            to +\u003d value.length \u0026gt;\u0026gt; 1;\n            pushDelta(from);\n            pushDelta(to);\n            int res \u003d 0;\n            boolean found \u003d false;\n            for (int len \u003d 1; from \u0026lt;\u003d to; from \u003d (from + 1) \u0026gt;\u0026gt; 1, to \u003d (to - 1) \u0026gt;\u0026gt; 1, len \u0026lt;\u0026lt;\u003d 1) {\n                if ((from \u0026amp; 1) !\u003d 0) {\n                    res \u003d found ? queryOperation(res, joinNodeValueWithDelta(from, len)) : joinNodeValueWithDelta(from, len);\n                    found \u003d true;\n                }\n                if ((to \u0026amp; 1) \u003d\u003d 0) {\n                    res \u003d found ? queryOperation(res, joinNodeValueWithDelta(to, len)) : joinNodeValueWithDelta(to, len);\n                    found \u003d true;\n                }\n            }\n            if (!found) throw new RuntimeException();\n            return res;\n        }\n\n        public void modify(int from, int to, int delta) {\n            if (from \u0026gt; to) return;\n            from +\u003d value.length \u0026gt;\u0026gt; 1;\n            to +\u003d value.length \u0026gt;\u0026gt; 1;\n            pushDelta(from);\n            pushDelta(to);\n            int a \u003d from;\n            int b \u003d to;\n            for (; from \u0026lt;\u003d to; from \u003d (from + 1) \u0026gt;\u0026gt; 1, to \u003d (to - 1) \u0026gt;\u0026gt; 1) {\n                if ((from \u0026amp; 1) !\u003d 0) {\n                    this.delta[from] \u003d joinDeltas(this.delta[from], delta);\n                }\n                if ((to \u0026amp; 1) \u003d\u003d 0) {\n                    this.delta[to] \u003d joinDeltas(this.delta[to], delta);\n                }\n            }\n            for (int i \u003d a, len \u003d 1; i \u0026gt; 1; i \u0026gt;\u0026gt;\u003d 1, len \u0026lt;\u0026lt;\u003d 1) {\n                value[i \u0026gt;\u0026gt; 1] \u003d queryOperation(joinNodeValueWithDelta(i, len), joinNodeValueWithDelta(i ^ 1, len));\n            }\n            for (int i \u003d b, len \u003d 1; i \u0026gt; 1; i \u0026gt;\u0026gt;\u003d 1, len \u0026lt;\u0026lt;\u003d 1) {\n                value[i \u0026gt;\u0026gt; 1] \u003d queryOperation(joinNodeValueWithDelta(i, len), joinNodeValueWithDelta(i ^ 1, len));\n            }\n        }\n\n    }\n\n    static class Pair\u0026lt;U extends Comparable\u0026lt;U\u0026gt;, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; implements Comparable\u0026lt;Pair\u0026lt;U, V\u0026gt;\u0026gt; {\n        public final U u;\n        public final V v;\n\n        public Pair(U u, V v) {\n            this.u \u003d u;\n            this.v \u003d v;\n        }\n\n        public int hashCode() {\n            return (u \u003d\u003d null ? 0 : u.hashCode() * 31) + (v \u003d\u003d null ? 0 : v.hashCode());\n        }\n\n        public boolean equals(Object o) {\n            if (this \u003d\u003d o)\n                return true;\n            if (o \u003d\u003d null || getClass() !\u003d o.getClass())\n                return false;\n            Pair\u0026lt;U, V\u0026gt; p \u003d (Pair\u0026lt;U, V\u0026gt;) o;\n            return (u \u003d\u003d null ? p.u \u003d\u003d null : u.equals(p.u)) \u0026amp;\u0026amp; (v \u003d\u003d null ? p.v \u003d\u003d null : v.equals(p.v));\n        }\n\n        public int compareTo(Pair\u0026lt;U, V\u0026gt; b) {\n            int cmpU \u003d u.compareTo(b.u);\n            return cmpU !\u003d 0 ? cmpU : v.compareTo(b.v);\n        }\n\n        public String toString() {\n            return String.format(\u0026quot;[Pair \u003d (%s, %s)\u0026quot;, u.toString(), v.toString());\n        }\n\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eIncreasing Sequence\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eBe careful, it is not true in general that the set of valid \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e forms an interval. For example, consider this case [6, 4, 4, 6]. k \u003d 7 works, by turning the array into [1, 3, 4, 6]. k \u003d 9 works by turning the array into [3, 4, 5, 6]. But, k \u003d 8 doesn\u0027t work since the middle two elements will stay the same.\u003c/p\u003e\u003cp\u003eOur solution will eliminate intervals of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e that are bad if we choose to flip or not flip certain elements. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e be the set of intervals that is bad if we flip element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, and let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e be the set of intervals that is bad if we don\u0027t flip element \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFor each individual element, if we choose to flip it, and this adds the inequality \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, so this adds the bad interval \u003cspan class\u003d\"tex-span\"\u003e[0, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - 1]\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFor a pair of adjacent indices \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e, we can check we can check what inequalities it imposes on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e if we decide to flip or not flip certain elements (you can see the code for the exact cases).\u003c/p\u003e\u003cp\u003eAfter getting these bad intervals, it suffices to try to find some point such that this point is not in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e or not in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. This can be done with a line sweep.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;cassert\u0026gt;\nusing namespace std;\n\nconst int N \u003d 200500;\n\nint B[N];\n\nint W[N];\n\nint bad \u003d 0;\n\nint getbad(int i) {\n    return (W[2 * i] \u0026gt; 0 \u0026amp;\u0026amp; W[2 * i + 1] \u0026gt; 0) ? 1 : 0;\n}\n\nvoid add(int i, int w) {\n    bad -\u003d getbad(i / 2);\n    W[i] +\u003d w;\n    bad +\u003d getbad(i / 2);\n}\n\nstruct ev {\n    int t;\n    int i;\n    int d;\n    friend bool operator \u0026lt;(const ev\u0026amp; a, const ev\u0026amp; b) {\n        return a.t \u0026lt; b.t;\n    }\n};\n\nvector\u0026lt;ev\u0026gt; evts;\n\nconst int INF \u003d 2e9 + 42;\n\nvoid add(int l, int r, int i) {\n    evts.emplace_back(ev{l, i, 1});\n    evts.emplace_back(ev{r + 1, i, -1});\n}\n\nint A[N];\n\nvoid die() {\n    puts(\u0026quot;-1\u0026quot;);\n    exit(0);\n}\n\nint T(int x) {\n    return 2 * x + 1;\n}\n\nint F(int x) {\n    return 2 * x;\n}\n\nint main() {\n    int n;\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        scanf(\u0026quot;%d\u0026quot;, \u0026amp;A[i]);\n    }\n\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        add(0, A[i] - 1, F(i));\n    }\n    bool f \u003d false;\n    for (int i \u003d 0; i \u0026lt; n - 1; i++) {\n        int a \u003d A[i];\n        int b \u003d A[i + 1];\n        int s \u003d a + b;\n        if (a \u003d\u003d b) {\n            add(0, s, F(i + 1));\n            add(0, s, T(i));\n            add(s, INF, F(i));\n            add(s, INF, T(i + 1));\n        } else if (a \u0026gt; b) {\n            add(0, s, T(i));\n            add(s, INF, T(i + 1));\n        } else {\n            add(0, s, F(i + 1));\n            add(s, INF, F(i));\n        }\n    }\n\n    add(0, -1, 0); // touch\n\n    sort(evts.begin(), evts.end());\n\n    int goodk \u003d -1;\n\n    for (int l \u003d 0, r \u003d 0; l \u0026lt; (int)evts.size(); l \u003d r) {\n        if (evts[l].t \u0026gt;\u003d INF - 2) {\n            break;\n        }\n        while (r \u0026lt; (int)evts.size() \u0026amp;\u0026amp; evts[r].t \u003d\u003d evts[l].t) {\n            r++;\n        }\n        for (int i \u003d l; i \u0026lt; r; i++) {\n            add(evts[i].i, evts[i].d);\n        }\n        if (bad \u003d\u003d 0) {\n            goodk \u003d evts[l].t;\n            break;\n        }\n    }\n    printf(\u0026quot;%d\\n\u0026quot;, goodk);\n    if (goodk !\u003d -1) {\n        assert(W[2 * n] \u003d\u003d 0 || W[2 * n + 1] \u003d\u003d 0);\n        for (int i \u003d 0; i \u0026lt; n; i++) {\n            assert(W[2 * i] \u003d\u003d 0 || W[2 * i + 1] \u003d\u003d 0);\n            printf(\u0026quot;%d \u0026quot;, (B[i] \u003d ((W[2 * i] \u0026gt; 0) ? A[i] : goodk - A[i])));\n        }\n        printf(\u0026quot;\\n\u0026quot;);\n        for (int i \u003d 0; i \u0026lt; n - 1; i++) {\n            assert(B[i] \u0026lt; B[i + 1]);\n        }\n        for (int i \u003d 0; i \u0026lt; n; i++) {\n            assert(B[i] \u0026gt;\u003d 0);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eYet Another Binary Matrix\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThere may be some exponential time solutions, which is why bounds are set a bit low, but you can also solve this in polynomial time with the matroid intersection algorithm in O(n^4). It might also be possible to solve this with some hill climbing algorithms, the idea is to try to maximize \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003erank\u003c/i\u003e(\u003ci\u003eW\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e, \u003ci\u003eB\u003c/i\u003e + \u003ci\u003eX\u003c/i\u003e)) + \u003ci\u003erank\u003c/i\u003e(\u003ci\u003eW\u003c/i\u003e(\u003ci\u003eR\u003c/i\u003e - \u003ci\u003eA\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e - \u003ci\u003eB\u003c/i\u003e - \u003ci\u003eX\u003c/i\u003e))\u003c/span\u003e. I\u0027ll describe the matroid intersection algorithm. \u003c/p\u003e\u003cp\u003eThe matroids here in this case are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e \u003d set of columns \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e such \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e(\u003ci\u003eA\u003c/i\u003e, \u003ci\u003eX\u003c/i\u003e)\u003c/span\u003e is linearly independent, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e \u003d set of columns \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e such that the rank of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e(\u003ci\u003eR\u003c/i\u003e - \u003ci\u003eA\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e - \u003ci\u003eY\u003c/i\u003e)\u003c/span\u003e is at least \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eR\u003c/i\u003e| - |\u003ci\u003eA\u003c/i\u003e|\u003c/span\u003e (here, the rank is the maximum size of a subset of rows that is linearly independent).\u003c/p\u003e\u003cp\u003eThe algorithm is similar to bipartite matching (in fact, bipartite matching is a special case of the matroid intersection algorithm). The rough steps are as follows. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e be some set of elements that is in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b6/c8/b6c84ea37f3bc5f6183db06e18f8ee785029c207.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. Initially \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e is empty. To increase the size of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e, make a directed graph as follows:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eMake a node for every column in the graph. Also make a node for a \u0026quot;source\u0026quot; and a \u0026quot;sink\u0026quot;.\u003c/li\u003e   \u003cli\u003eFor simplicity, I\u0027ll refer to a node not in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and a node in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eFor two nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, draw a directed edge from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e + \u003ci\u003ex\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e belongs in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eFor two nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, draw a directed edge from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e + \u003ci\u003ex\u003c/i\u003e - \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e belongs in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eConnect the source to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e + \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e belongs in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eConnect \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e to the sink if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e + \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e belongs in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eWe then find an \u0026quot;augmenting\u0026quot; path from the source to the sink, and we can xor this with our original set to get a set with one size larger (i.e. if it was in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e remove it, otherwise add it).\u003c/p\u003e\u003cp\u003eThe proof isn\u0027t too easy though, but you can google some papers about the algorithm for proof/more details (\u003ca href\u003d\"http://math.mit.edu/~goemans/18438F09/lec11.pdf\"\u003ehere\u003c/a\u003e and \u003ca href\u003d\"https://courses.engr.illinois.edu/cs598csc/sp2010/Lectures/Lecture17.pdf\"\u003ehere\u003c/a\u003e). \u003c/p\u003e\u003cp\u003eOf course, this only deals with the unweighted case, so to add back \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e into consideration, we can give columns in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e weight 1 and other columns with weight 0. We can adapt the algorithm above to find the maximum weight instead, and check it contains all elements of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ecode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.TreeSet;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream \u003d System.in;\n        OutputStream outputStream \u003d System.out;\n        InputReader in \u003d new InputReader(inputStream);\n        OutputWriter out \u003d new OutputWriter(outputStream);\n        YetAnotherBinaryMatrix solver \u003d new YetAnotherBinaryMatrix();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class YetAnotherBinaryMatrix {\n        int n;\n        int na;\n        int nb;\n        int[][] mat;\n        int[] a;\n        int[] b;\n        long[] A;\n        long[] nA;\n        boolean[] ba;\n        boolean[] bb;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            n \u003d in.nextInt();\n            na \u003d in.nextInt();\n            nb \u003d in.nextInt();\n            a \u003d in.readIntArray(na);\n            b \u003d in.readIntArray(nb);\n            ba \u003d new boolean[n];\n            for (int x : a) ba[x - 1] \u003d true;\n            bb \u003d new boolean[n];\n            for (int x : b) bb[x - 1] \u003d true;\n            mat \u003d new int[n][n];\n            for (int i \u003d 0; i \u0026lt; n; i++) {\n                char[] c \u003d in.next().toCharArray();\n                for (int j \u003d 0; j \u0026lt; n; j++)\n                    mat[i][j] \u003d c[j] - \u00270\u0027;\n            }\n            A \u003d new long[n];\n            nA \u003d new long[n];\n            for (int i \u003d 0; i \u0026lt; n; i++) {\n                for (int j \u003d 0; j \u0026lt; n; j++) {\n                    if (ba[j]) A[i] \u003d A[i] * 2 + mat[j][i];\n                    else nA[i] \u003d nA[i] * 2 + mat[j][i];\n                }\n            }\n            Basis bs \u003d new Basis();\n            for (int i \u003d 0; i \u0026lt; n; i++) bs.add(nA[i]);\n            if (bs.size \u0026lt; n - na) {\n                out.println(-1);\n                return;\n            }\n            boolean[] ss \u003d new boolean[n];\n            while (true) {\n                int[] x \u003d findPath(ss);\n                if (x \u003d\u003d null) break;\n                for (int j : x) {\n                    ss[j] \u003d !ss[j];\n                }\n            }\n            int count \u003d 0;\n            for (boolean w : ss) if (w) count++;\n            if (count !\u003d na) {\n                out.println(-1);\n                return;\n            }\n            count \u003d 0;\n            for (int i \u003d 0; i \u0026lt; n; i++) {\n                if (bb[i] \u0026amp;\u0026amp; !ss[i]) {\n                    out.println(-1);\n                    return;\n                } else if (ss[i] \u0026amp;\u0026amp; !bb[i]) {\n                    count++;\n                }\n            }\n\n            out.println(count);\n            int[] ret \u003d new int[count];\n            int idx \u003d 0;\n            for (int i \u003d 0; i \u0026lt; n; i++) if (ss[i] \u0026amp;\u0026amp; !bb[i]) ret[idx++] \u003d i + 1;\n            out.println(ret);\n        }\n\n        public boolean ok1(boolean[] ss) {\n            Basis bs \u003d new Basis();\n            for (int j \u003d 0; j \u0026lt; n; j++) {\n                if (ss[j]) {\n                    if (!bs.add(A[j]))\n                        return false;\n                }\n            }\n            return true;\n        }\n\n        public boolean ok2(boolean[] ss) {\n            Basis bs \u003d new Basis();\n            for (int j \u003d 0; j \u0026lt; n; j++) {\n                if (!ss[j]) {\n                    bs.add(nA[j]);\n                }\n            }\n            return bs.size \u0026gt;\u003d n - na;\n        }\n\n        public int[] findPath(boolean[] ss) {\n            int nnodes \u003d n + 2;\n            List\u0026lt;Integer\u0026gt;[] graph \u003d Stream.generate(ArrayList::new).limit(nnodes).toArray(List[]::new);\n            for (int i \u003d 0; i \u0026lt; n; i++) {\n                for (int j \u003d 0; j \u0026lt; n; j++) {\n                    if (!ss[i] \u0026amp;\u0026amp; ss[j]) {\n                        ss[i] \u003d true;\n                        ss[j] \u003d false;\n                        if (ok1(ss)) graph[i].add(j);\n                        if (ok2(ss)) graph[j].add(i);\n                        ss[i] \u003d false;\n                        ss[j] \u003d true;\n                    }\n                }\n            }\n\n            for (int i \u003d 0; i \u0026lt; n; i++) {\n                if (!ss[i]) {\n                    ss[i] \u003d true;\n                    if (ok2(ss)) graph[nnodes - 1].add(i);\n                    if (ok1(ss)) graph[i].add(nnodes - 2);\n                    ss[i] \u003d false;\n                }\n            }\n\n\n            int[] prev \u003d new int[nnodes];\n            int[] dist \u003d new int[nnodes];\n            Arrays.fill(prev, -1);\n            Arrays.fill(dist, 1 \u0026lt;\u0026lt; 25);\n            TreeSet\u0026lt;Integer\u0026gt; ts \u003d new TreeSet\u0026lt;\u0026gt;(Comparator.comparingInt(x -\u0026gt; dist[x] * (n + 10) + x));\n            dist[nnodes - 1] \u003d 0;\n            ts.add(nnodes - 1);\n            while (ts.size() \u0026gt; 0) {\n                int f \u003d ts.pollFirst();\n                for (int nxt : graph[f]) {\n                    int weight \u003d (nxt \u0026lt; n ? 100 * (bb[nxt] ? -1 : 1) * (ss[nxt] ? -1 : 1) : 0) + 1;\n                    if (dist[f] + weight \u0026lt; dist[nxt]) {\n                        ts.remove(nxt);\n                        dist[nxt] \u003d dist[f] + weight;\n                        prev[nxt] \u003d f;\n                        ts.add(nxt);\n                    }\n                }\n            }\n            if (prev[nnodes - 2] \u003d\u003d -1) return null;\n            int[] p \u003d new int[nnodes];\n            int cur \u003d prev[nnodes - 2];\n            int id \u003d 0;\n            do {\n                p[id++] \u003d cur;\n                cur \u003d prev[cur];\n            } while (cur !\u003d nnodes - 1);\n\n            return Arrays.copyOf(p, id);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf \u003d new byte[1 \u0026lt;\u0026lt; 16];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream \u003d stream;\n        }\n\n        public int[] readIntArray(int tokens) {\n            int[] ret \u003d new int[tokens];\n            for (int i \u003d 0; i \u0026lt; tokens; i++) {\n                ret[i] \u003d nextInt();\n            }\n            return ret;\n        }\n\n        public int read() {\n            if (this.numChars \u003d\u003d -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar \u0026gt;\u003d this.numChars) {\n                    this.curChar \u003d 0;\n\n                    try {\n                        this.numChars \u003d this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars \u0026lt;\u003d 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c \u003d this.read(); isSpaceChar(c); c \u003d this.read()) {\n                ;\n            }\n\n            byte sgn \u003d 1;\n            if (c \u003d\u003d 45) {\n                sgn \u003d -1;\n                c \u003d this.read();\n            }\n\n            int res \u003d 0;\n\n            while (c \u0026gt;\u003d 48 \u0026amp;\u0026amp; c \u0026lt;\u003d 57) {\n                res *\u003d 10;\n                res +\u003d c - 48;\n                c \u003d this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public String next() {\n            int c;\n            while (isSpaceChar(c \u003d this.read())) {\n                ;\n            }\n\n            StringBuilder result \u003d new StringBuilder();\n            result.appendCodePoint(c);\n\n            while (!isSpaceChar(c \u003d this.read())) {\n                result.appendCodePoint(c);\n            }\n\n            return result.toString();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c \u003d\u003d 32 || c \u003d\u003d 10 || c \u003d\u003d 13 || c \u003d\u003d 9 || c \u003d\u003d -1;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer \u003d new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer \u003d new PrintWriter(writer);\n        }\n\n        public void print(int[] array) {\n            for (int i \u003d 0; i \u0026lt; array.length; i++) {\n                if (i !\u003d 0) {\n                    writer.print(\u0027 \u0027);\n                }\n                writer.print(array[i]);\n            }\n        }\n\n        public void println(int[] array) {\n            print(array);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class Basis {\n        public int size;\n        public long[] basis;\n\n        public Basis() {\n            basis \u003d new long[100];\n            size \u003d 0;\n        }\n\n        public boolean add(long x) {\n            for (int i \u003d size - 1; i \u0026gt;\u003d 0; i--) {\n                x \u003d Math.min(x, x ^ basis[i]);\n            }\n            if (x \u003d\u003d 0) return false;\n            basis[size++] \u003d x;\n            for (int i \u003d size - 2; i \u0026gt;\u003d 0; i--) {\n                if (basis[i] \u0026gt; basis[i + 1]) {\n                    long t \u003d basis[i + 1];\n                    basis[i + 1] \u003d basis[i];\n                    basis[i] \u003d t;\n                }\n            }\n            return true;\n        }\n\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}