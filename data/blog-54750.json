{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1506290314,"rating":26,"authorHandle":"bharat.khanna.cse14","modificationTimeSeconds":1506490900,"id":54750,"title":"\u003cp\u003eEditorial â€” Manthan Codefest \u002717\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"855A\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define sd(x) scanf(\u0026quot;%d\u0026quot;,\u0026amp;x)\n#define slld(x) scanf(\u0026quot;%lld\u0026quot;,\u0026amp;x)\n#define ss(x) scanf(\u0026quot;%s\u0026quot;,x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair\u0026lt;int,int\u0026gt;\nint main()\n{\n    //freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n    //freopen(\u0026quot;out.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\n    int n,i,j;\n    string s[102];\n    sd(n);\n    for(i\u003d0;i\u0026lt;n;i++)\n    {\n    \tcin\u0026gt;\u0026gt;s[i];\n    \tfor(j\u003d0;j\u0026lt;i;j++)\n    \t{\n    \t\tif(s[i]\u003d\u003ds[j])\n    \t\t\tbreak;\n    \t}\n    \tif(j\u003d\u003di)\n    \t\tprintf(\u0026quot;NO\\n\u0026quot;);\n    \telse\n    \t\tprintf(\u0026quot;YES\\n\u0026quot;);\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"855B\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eDP solution 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define sd(x) scanf(\u0026quot;%d\u0026quot;,\u0026amp;x)\n#define slld(x) scanf(\u0026quot;%lld\u0026quot;,\u0026amp;x)\n#define ss(x) scanf(\u0026quot;%s\u0026quot;,x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair\u0026lt;int,int\u0026gt;\nint a[100005];\nll dp[100005][3];\nint main()\n{\n    //freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n    //freopen(\u0026quot;out.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\n    int n,p,q,r,i;\n    sd(n);\n    sd(p);\n    sd(q);\n    sd(r);\n    for(i\u003d0;i\u0026lt;n;i++)\n    \tsd(a[i]);\n    dp[0][0]\u003d1ll*p*a[0];\n    for(i\u003d1;i\u0026lt;n;i++)\n    \tdp[i][0]\u003dmax(dp[i-1][0],1ll*p*a[i]);\n    dp[0][1]\u003ddp[0][0]+1ll*q*a[0];\n    for(i\u003d1;i\u0026lt;n;i++)\n    \tdp[i][1]\u003dmax(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n    dp[0][2]\u003ddp[0][1]+1ll*r*a[0];\n    for(i\u003d1;i\u0026lt;n;i++)\n    \tdp[i][2]\u003dmax(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n    printf(\u0026quot;%lld\\n\u0026quot;,dp[n-1][2]);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eDP solution 2 with minimum and maximum computation\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define sd(x) scanf(\u0026quot;%d\u0026quot;,\u0026amp;x)\n#define slld(x) scanf(\u0026quot;%lld\u0026quot;,\u0026amp;x)\n#define ss(x) scanf(\u0026quot;%s\u0026quot;,x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair\u0026lt;int,int\u0026gt;\n#define pii pair\u0026lt;pi,int\u0026gt;\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;p\u0026gt;\u0026gt;q\u0026gt;\u0026gt;r;\n\tfor(i\u003d1;i\u0026lt;\u003dn;i++)\n\t\tsd(a[i]);\n\tminleft[1]\u003dmaxleft[1]\u003da[1];\n\tminright[n]\u003dmaxright[n]\u003da[n];\n\tfor(i\u003d2;i\u0026lt;\u003dn;i++)\n\t{\n\t\tminleft[i]\u003dmin(minleft[i-1],a[i]);\n\t\tmaxleft[i]\u003dmax(maxleft[i-1],a[i]);\n\t}\n\tfor(i\u003dn-1;i\u0026gt;\u003d1;i--)\n\t{\n\t\tminright[i]\u003dmin(minright[i+1],a[i]);\n\t\tmaxright[i]\u003dmax(maxright[i+1],a[i]);\n\t}\n\tll ans\u003d-3e18;\n\tfor(i\u003d1;i\u0026lt;\u003dn;i++)\n\t{\n\t\tll leftval \u003d (p\u0026lt;0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval \u003d (r\u0026lt;0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans\u003dmax(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"855C\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define sd(x) scanf(\u0026quot;%d\u0026quot;,\u0026amp;x)\n#define slld(x) scanf(\u0026quot;%lld\u0026quot;,\u0026amp;x)\n#define ss(x) scanf(\u0026quot;%s\u0026quot;,x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair\u0026lt;int,int\u0026gt;\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector \u0026lt;int\u0026gt; q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j\u003d0,l,r,temp;\n\tfor(i\u003d0;i\u0026lt;q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]\u003d\u003dpar)\n\t\t\tcontinue;\n\t\tj\u003d1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]\u003dk-1;\n\t\tdp[cur][1][1]\u003d1;\n\t\tdp[cur][2][0]\u003dm-k;\n\t\treturn;\n\t}\n\tfor(i\u003d0;i\u0026lt;3;i++)\n\t{\n\t\tfor(j\u003d0;j\u0026lt;\u003dx;j++)\n\t\t{\n\t\t\ta[i][j]\u003d0;\n\t\t\tb[i][j]\u003d0;\n\t\t}\n\t}\n\tfor(i\u003d0;i\u0026lt;3;i++)\n\t\ta[i][0]\u003d1;\n\tfor(i\u003d0;i\u0026lt;q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]\u003d\u003dpar)\n\t\t\tcontinue;\n\t\tfor(j\u003d0;j\u0026lt;3;j++)\n\t\t{\n\t\t\tfor(l\u003d0;l\u0026lt;\u003dx;l++)\n\t\t\t{\n\t\t\t\tfor(r\u003d0;r\u0026lt;\u003dx;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r\u0026gt;x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j\u003d\u003d0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp\u003ddp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp\u0026gt;\u003dmod)\n\t\t\t\t\t\t\ttemp-\u003dmod;\n\t\t\t\t\t\ttemp+\u003ddp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp\u0026gt;\u003dmod)\n\t\t\t\t\t\t\ttemp-\u003dmod;\n\t\t\t\t\t\tb[j][l+r]+\u003d(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]\u0026gt;\u003dmod)\n\t\t\t\t\t\t\tb[j][l+r]-\u003dmod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j\u003d\u003d1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+\u003d(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]\u0026gt;\u003dmod)\n\t\t\t\t\t\t\tb[j][l+r]-\u003dmod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp\u003ddp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp\u0026gt;\u003dmod)\n\t\t\t\t\t\t\ttemp-\u003dmod;\n\t\t\t\t\t\tb[j][l+r]+\u003d(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]\u0026gt;\u003dmod)\n\t\t\t\t\t\t\tb[j][l+r]-\u003dmod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(j\u003d0;j\u0026lt;3;j++)\n\t\t{\n\t\t\tfor(l\u003d0;l\u0026lt;\u003dx;l++)\n\t\t\t{\n\t\t\t\ta[j][l]\u003db[j][l];\n\t\t\t\tb[j][l]\u003d0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l\u003d0;l\u0026lt;\u003dx;l++)\n\t{\n\t\tdp[cur][0][l]\u003d(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l\u0026gt;\u003d1)\n\t\t\tdp[cur][1][l]\u003da[1][l-1];\n\t\tdp[cur][2][l]\u003d(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n    //freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n    //freopen(\u0026quot;out.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\n    int n,i,j,ans;\n    sd(n);\n    sd(m);\n    for(i\u003d1;i\u0026lt;n;i++)\n    {\n    \tsd(j);\n    \tsd(k);\n    \tq[j].pb(k);\n    \tq[k].pb(j);\n    }\n    sd(k);\n    sd(x);\n    dfs(1,0);\n    ans\u003d0;\n    for(i\u003d0;i\u0026lt;3;i++)\n    {\n    \tfor(j\u003d0;j\u0026lt;\u003dx;j++)\n    \t{\n    \t\t//printf(\u0026quot;%d %d %d\\n\u0026quot;,i,j,dp[1][i][j]);\n    \t\tans+\u003ddp[1][i][j];\n    \t\tif(ans\u0026gt;\u003dmod)\n    \t\t\tans-\u003dmod;\n    \t}\n    }\n    printf(\u0026quot;%d\\n\u0026quot;,ans);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"855D\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define sd(x) scanf(\u0026quot;%d\u0026quot;,\u0026amp;x)\n#define slld(x) scanf(\u0026quot;%lld\u0026quot;,\u0026amp;x)\n#define ss(x) scanf(\u0026quot;%s\u0026quot;,x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair\u0026lt;int,int\u0026gt;\n#define pii pair\u0026lt;pi,int\u0026gt;\n#define mp make_pair\nvector\u0026lt;int\u0026gt;v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]\u003d\u003dnode ? node : parr[node]\u003dfindpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]\u003dpar;\n\tinherit[node]\u003dinh;\n\tcomp[node]\u003dcom;\n\theight[node]\u003dheight[par]+1;\n\tfor(int i\u003d1;i\u0026lt;\u003d20;i++)\n\t{\n\t\tparent[node][i]\u003dparent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i\u003d0;i\u0026lt;v[node].size();i++)\n\t{\n\t\tif(v[node][i]\u003d\u003dpar)\n\t\t\tcontinue;\n\t\tif(v2[node][i]\u003d\u003d0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]\u0026gt;height[v])\n\t\tswap(u,v);\n\tfor(int i\u003d20;i\u0026gt;\u003d0;i--)\n\t{\n\t\tif(height[parent[v][i]]\u0026gt;\u003dheight[u])\n\t\t{\n\t\t\tv\u003dparent[v][i];\n\t\t}\n\t}\n\tif(u!\u003dv)\n\t{\n\t\tfor(int i\u003d20;i\u0026gt;\u003d0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!\u003dparent[v][i])\n\t\t\t{\n\t\t\t\tu\u003dparent[u][i];\n\t\t\t\tv\u003dparent[v][i];\n\t\t\t}\n\t\t}\n\t\tu\u003dparent[u][0];\n\t\tv\u003dparent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i\u003d1;i\u0026lt;\u003dn;i++)\n\t\tparr[i]\u003di;\n\tfor(i\u003d1;i\u0026lt;\u003dn;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j\u003d\u003d-1 \u0026amp;\u0026amp; k\u003d\u003d-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x\u003dfindpar(i);\n\t\tint y\u003dfindpar(j);\n\t\tif(x!\u003dy)\n\t\t\tparr[x]\u003dy;\n\t}\n\tfor(i\u003d1;i\u0026lt;\u003dn;i++)\n\t{\n\t\tif(parent[i][0]\u003d\u003d0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x\u003dfindpar(j);\n\t\tint y\u003dfindpar(k);\n\t\tif(x!\u003dy)\n\t\t{\n\t\t\tprintf(\u0026quot;NO\\n\u0026quot;);\n\t\t\tcontinue;\n\t\t}\n\t\tx\u003dfindlca(j,k);\n\t\tif(i\u003d\u003d1)\n\t\t{\n\t\t\tif(x!\u003dj || comp[k]-comp[x]!\u003d0 || j\u003d\u003dk)\n\t\t\t{\n\t\t\t\tprintf(\u0026quot;NO\\n\u0026quot;);\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\u0026quot;YES\\n\u0026quot;);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!\u003d0 || comp[j]-comp[x]!\u003d0 || x\u003d\u003dk)\n\t\t\t\tprintf(\u0026quot;NO\\n\u0026quot;);\n\t\t\telse\n\t\t\t\tprintf(\u0026quot;YES\\n\u0026quot;);\n\t\t}\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"855E\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define sd(x) scanf(\u0026quot;%lld\u0026quot;,\u0026amp;x)\n#define slld(x) scanf(\u0026quot;%lld\u0026quot;,\u0026amp;x)\n#define ss(x) scanf(\u0026quot;%s\u0026quot;,x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair\u0026lt;int,int\u0026gt;\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!\u003d-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos\u003d\u003d0)\n\t{\n\t\tif(in!\u003d0\u0026amp;\u0026amp;m\u003d\u003d0)\n\t\t\treturn dp[b][in][m][pos]\u003d1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]\u003d0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j\u003d0;\n\tif(in\u003d\u003d0)\n\t\tj+\u003df(b,0,m,pos-1);\n\telse\n\t\tj+\u003df(b,1,(m^1),pos-1);\n\tfor(ll i\u003d1;i\u0026lt;b;i++)\n\t\tj+\u003df(b,1,(m^(1\u0026lt;\u0026lt;i)),pos-1);\n\tdp[b][in][m][pos]\u003dj;\n\treturn j;\n}\nint main()\n{\n    //freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\n    //freopen(\u0026quot;out.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\n    ll n,i,j,k,in;\n    ll ans,l,r,m,q,b;\n    k\u003d1e18;\n    memset(dp,-1,sizeof dp);\n    for(i\u003d2;i\u0026lt;\u003d10;i++)\n    {\n    \tlen[i]\u003d1;\n    \tj\u003di;\n    \twhile(j\u0026lt;k)\n    \t{\n    \t\tlen[i]++;\n    \t\tj*\u003di;\n    \t}\n    \tf(i,0,0,len[i]+1);\n    }\n    sd(q);\n    while(q--)\n    {\n    \tsd(b);\n    \tsd(l);\n    \tsd(r);\n    \tans\u003d0;\n    \tl--;\n    \tif(l)\n    \t{\n    \t\tj\u003dl;\n    \t\ti\u003d0;\n    \t\twhile(j)\n    \t\t{\n    \t\t\ta[i]\u003dj%b;\n    \t\t\tj/\u003db;\n    \t\t\ti++;\n    \t\t}\n    \t\tm\u003d0;\n    \t\tin\u003d0;\n    \t\tfor(j\u003di-1;j\u0026gt;\u003d0;j--)\n    \t\t{\n    \t\t\tfor(k\u003d0;k\u0026lt;a[j];k++)\n    \t\t\t{\n    \t\t\t\tif(k!\u003d0)\n    \t\t\t\t\tin\u003d1;\n    \t\t\t\tif(in\u003d\u003d0)\n    \t\t\t\t\tans-\u003ddp[b][0][m][j];\n    \t\t\t\telse\n    \t\t\t\t\tans-\u003ddp[b][1][(m^(1\u0026lt;\u0026lt;k))][j];\n    \t\t\t}\n    \t\t\tif(in|a[j])\n    \t\t\t{\n    \t\t\t\tin\u003d1;\n    \t\t\t\tm\u003d(m^(1\u0026lt;\u0026lt;a[j]));\n    \t\t\t}\n    \t\t}\n    \t\tans-\u003ddp[b][in][m][0];\n    \t}\n    \tj\u003dr;\n    \ti\u003d0;\n    \twhile(j)\n    \t{\n    \t\ta[i]\u003dj%b;\n    \t\tj/\u003db;\n    \t\ti++;\n    \t}\n    \tin\u003d0;\n    \tm\u003d0;\n\t\tfor(j\u003di-1;j\u0026gt;\u003d0;j--)\n\t\t{\n\t\t\tfor(k\u003d0;k\u0026lt;a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!\u003d0)\n\t\t\t\t\tin\u003d1;\n\t\t\t\tif(in\u003d\u003d0)\n\t\t\t\t\tans+\u003ddp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+\u003ddp[b][1][(m^(1\u0026lt;\u0026lt;k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin\u003d1;\n\t\t\t\tm\u003d(m^(1\u0026lt;\u0026lt;a[j]));\n\t\t\t}\n\t\t}\n\t\tans+\u003ddp[b][in][m][0];\n\t\tprintf(\u0026quot;%lld\\n\u0026quot;,ans);\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"855F\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n#define sd(x) scanf(\u0026quot;%d\u0026quot;,\u0026amp;x)\n#define slld(x) scanf(\u0026quot;%lld\u0026quot;,\u0026amp;x)\n#define ss(x) scanf(\u0026quot;%s\u0026quot;,x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair\u0026lt;int,int\u0026gt;\n#define pii pair\u0026lt;pi,int\u0026gt;\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap \u0026lt;int,int\u0026gt; low[1000],up[1000];\nmap \u0026lt;int,int\u0026gt; vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]\u0026lt;\u003dval)\n\t\treturn;\n\t//map\u0026lt;int,int\u0026gt; m;\n\tmap\u0026lt;int,int\u0026gt; :: iterator it;\n\t//m.clear();\n\tfor(int j\u003dl;j\u0026lt;\u003dr;j++)\n\t{\n\t\tif(minup[j]\u0026gt;val)\n\t\t{\n\t\t\tif(minup[j]\u003d\u003dmod\u0026amp;\u0026amp;mindown[j]\u003d\u003dmod\u0026amp;\u0026amp;upper[i]\u003d\u003dmod\u0026amp;\u0026amp;lower[i]\u003d\u003dmod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+\u003dval;\n\t\t\t}\n\t\t\telse if(minup[j]\u003d\u003dmod\u0026amp;\u0026amp;upper[i]\u003d\u003dmod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp\u003dmin(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]\u003d\u003d0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-\u003dmin(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+\u003dval;\n\t\t\t\tans[i]+\u003dmin(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]\u003d\u003dmod\u0026amp;\u0026amp;lower[i]\u003d\u003dmod)\n\t\t\t{\n\t\t\t\tint temp\u003dmin(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]\u003d\u003d0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+\u003dval-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]\u003dval;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val\u0026gt;\u003dupper[i])\n\t\treturn;\n\tmap \u0026lt;int,int\u0026gt; :: iterator it; \n\tint n\u003dup[i].size();\n\tn--;\n\tll sum\u003d0;\n\tint len2\u003d0;\n\tfor(it\u003dvnotup[i].begin();it!\u003dvnotup[i].end();it++)\n\t{\n\t\tans[i]+\u003d1ll*(it-\u0026gt;fi)*(it-\u0026gt;se)+1ll*(it-\u0026gt;se)*val;\n\t\tlen2+\u003dit-\u0026gt;se;\n\t\tlow[i][it-\u0026gt;fi]+\u003dit-\u0026gt;se;\n\t}\n\tvnotup[i].clear();\n\tit\u003dvnotdown[i].upper_bound(val);\n\tint temp\u003d0;\n\tfor(it;it!\u003dvnotdown[i].end();it++)\n\t{\n\t\ttemp+\u003dit-\u0026gt;se;\n\t}\n\tit\u003dvnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+\u003dtemp+notboth[i];\n\tnotboth[i]\u003d0;\n\tint len\u003d0;\n\tit\u003dup[i].upper_bound(val);\n\tfor(it;it!\u003dup[i].end();it++)\n\t{\n\t\tsum+\u003d1ll*(it-\u0026gt;fi)*(it-\u0026gt;se);\n\t\tlen+\u003dit-\u0026gt;se;\n\t}\n\tit\u003dup[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+\u003d1ll*len*val-sum;\n\tup[i][val]+\u003dlen+len2;\n\tupper[i]\u003dval;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]\u0026lt;\u003dval)\n\t\treturn;\n\t//map\u0026lt;int,int\u0026gt; m;\n\tmap\u0026lt;int,int\u0026gt; :: iterator it;\n\t//m.clear();\n\tfor(int j\u003dl;j\u0026lt;\u003dr;j++)\n\t{\n\t\tif(mindown[j]\u0026gt;val)\n\t\t{\n\t\t\tif(mindown[j]\u003d\u003dmod\u0026amp;\u0026amp;minup[j]\u003d\u003dmod\u0026amp;\u0026amp;upper[i]\u003d\u003dmod\u0026amp;\u0026amp;lower[i]\u003d\u003dmod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+\u003dval;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]\u003d\u003dmod\u0026amp;\u0026amp;lower[i]\u003d\u003dmod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp\u003dmin(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]\u003d\u003d0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-\u003dmin(upper[i],minup[j]);\n\t\t\t\tans[i]+\u003dval;\n\t\t\t\tans[i]+\u003dmin(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]\u003d\u003dmod\u0026amp;\u0026amp;upper[i]\u003d\u003dmod)\n\t\t\t{\n\t\t\t\tint temp\u003dmin(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]\u003d\u003d0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+\u003dval-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]\u003dval;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val\u0026gt;\u003dlower[i])\n\t\treturn;\n\tmap \u0026lt;int,int\u0026gt; :: iterator it; \n\tint n\u003dlow[i].size();\n\tn--;\n\tll sum\u003d0;\n\tint len2\u003d0;\n\tfor(it\u003dvnotdown[i].begin();it!\u003dvnotdown[i].end();it++)\n\t{\n\t\tans[i]+\u003d1ll*(it-\u0026gt;fi)*(it-\u0026gt;se)+1ll*(it-\u0026gt;se)*val;\n\t\tlen2+\u003dit-\u0026gt;se;\n\t\tup[i][it-\u0026gt;fi]+\u003dit-\u0026gt;se;\n\t}\n\tvnotdown[i].clear();\n\tit\u003dvnotup[i].upper_bound(val);\n\tint temp\u003d0;\n\tfor(it;it!\u003dvnotup[i].end();it++)\n\t{\n\t\ttemp+\u003dit-\u0026gt;se;\n\t}\n\tit\u003dvnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+\u003dtemp+notboth[i];\n\tnotboth[i]\u003d0;\n\tint len\u003d0;\n\tit\u003dlow[i].upper_bound(val);\n\tfor(it;it!\u003dlow[i].end();it++)\n\t{\n\t\tsum+\u003d1ll*(it-\u0026gt;fi)*(it-\u0026gt;se);\n\t\tlen+\u003dit-\u0026gt;se;\n\t}\n\tit\u003dlow[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+\u003d1ll*len*val-sum;\n\tlow[i][val]+\u003dlen+len2;\n\tlower[i]\u003dval;\n}\nll query(int i,int l,int r)\n{\n\tll sum\u003d0;\n\tfor(int j\u003dl;j\u0026lt;\u003dr;j++)\n\t{\n\t\tif(min(upper[i],minup[j])\u0026lt;mod\u0026amp;\u0026amp;min(lower[i],mindown[j])\u0026lt;mod)\n\t\t\tsum+\u003dmin(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn\u003d100000;\n\tfor(i\u003d0;i\u0026lt;1000;i++)\n\t\tlower[i]\u003dupper[i]\u003dmod;\n\tfor(i\u003d0;i\u0026lt;\u003d100000;i++)\n\t\tminup[i]\u003dmindown[i]\u003dmod;\n\tblock\u003d300;\n\tfor(i\u003d1;i\u0026lt;\u003dn;i++)\n\t{\n\t\tj\u003di/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t\u003d\u003d1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti\u003dl/block;\n\t\t\tj\u003dr/block;\n\t\t\tif(val\u0026gt;0)\n\t\t\t{\n\t\t\t\tif(i\u003d\u003dj)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i\u0026lt;j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i\u003d\u003dj)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i\u0026lt;j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts\u003d0;\n\t\t\ti\u003dl/block;\n\t\t\tj\u003dr/block;\n\t\t\tif(i\u003d\u003dj)\n\t\t\t\ts\u003dquery(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts\u003dquery(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i\u0026lt;j)\n\t\t\t\t{\n\t\t\t\t\t//s+\u003dquery(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+\u003dqueryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+\u003dquery(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\u0026quot;%lld\\n\u0026quot;,s);\n\t\t}\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"855G\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nusing ll \u003d long long;\nusing ld \u003d long double;\nusing D \u003d double;\nusing uint \u003d unsigned int;\ntemplate\u0026lt;typename T\u0026gt;\nusing pair2 \u003d pair\u0026lt;T, T\u0026gt;;\n\n#ifdef WIN32\n    #define LLD \u0026quot;%I64d\u0026quot;\n#else\n    #define LLD \u0026quot;%lld\u0026quot;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn \u003d 200005;\n\nstruct tpath\n{\n    int rep, sz;\n    ll ansmiddle;\n    int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector\u0026lt;tpath\u0026gt; path, path2;\nvector\u0026lt;int\u0026gt; gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n    return (a \u003d\u003d p[a] ? a : p[a] \u003d find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n    return tin[a] \u0026lt;\u003d tin[b] \u0026amp;\u0026amp; tout[a] \u0026gt;\u003d tin[b];\n}\n\nvoid unite(int a, int b)\n{\n    a \u003d find(a);\n    b \u003d find(b);\n    if (a \u003d\u003d b) return;\n    if (s[a] \u0026gt; s[b]) swap(a, b);\n    p[a] \u003d b;\n    if (s[a] \u003d\u003d s[b]) s[b]++;\n    if (tin[top[a]] \u0026lt; tin[top[b]])\n    {\n        sz[top[a]] +\u003d sz[top[b]];\n        top[b] \u003d top[a];\n    } else\n    {\n        sz[top[b]] +\u003d sz[top[a]];\n    }\n}\n\nvoid findpath(int a, int b)\n{\n    a \u003d top[find(a)];\n    b \u003d top[find(b)];\n//     cout \u0026lt;\u0026lt; \u0026quot;findpath \u0026quot; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl;\n    int lastdowna \u003d 0;\n    while (!isparent(a, b))\n    {\n        path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n        lastdowna \u003d down[a];\n        a \u003d top[find(up[a])];\n    }\n    path2.clear();\n    int lastdownb \u003d 0;\n    while (a !\u003d b)\n    {\n        path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n        lastdownb \u003d down[b];\n        b \u003d top[find(up[b])];\n    }\n    path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n    reverse(all(path2));\n    for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n    if (find(a) \u003d\u003d find(b)) return;\n    path.clear();\n    findpath(a, b);\n    \n//     cout \u0026lt;\u0026lt; \u0026quot;addedge \u0026quot; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl;\n//     for (auto t : path) cout \u0026lt;\u0026lt; \u0026quot;(\u0026quot; \u0026lt;\u0026lt; t.rep \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; t.sz \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; t.ansmiddle \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; t.edgeleft \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; t.edgeright \u0026lt;\u0026lt; \u0026quot;)\u0026quot; \u0026lt;\u0026lt; endl;\n    \n    // 3\n    ll cnt0 \u003d 1;\n    ll cnt1 \u003d 0;\n    ll cnt2 \u003d 0;\n    for (auto t : path)\n    {\n        answer -\u003d t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n        cnt2 +\u003d t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n        cnt1 +\u003d t.sz * cnt0;\n    }\n    ll sum \u003d cnt1;\n    answer +\u003d ((ll)sum * (sum - 1) * (sum - 2));\n    \n//     cout \u0026lt;\u0026lt; \u0026quot;after 3: \u0026quot; \u0026lt;\u0026lt; answer \u0026lt;\u0026lt; endl;\n    \n    // 2\n    cnt1 \u003d 0;\n    for (auto t : path)\n    {\n        answer +\u003d cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n        cnt1 +\u003d t.sz;\n    }\n    cnt1 \u003d 0;\n    for (int i \u003d (int)path.size() - 1; i \u0026gt;\u003d 0; i--)\n    {\n        auto \u0026amp;t \u003d path[i];\n        answer +\u003d cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n        cnt1 +\u003d t.sz;\n    }\n\n//     cout \u0026lt;\u0026lt; \u0026quot;after 2: \u0026quot; \u0026lt;\u0026lt; answer \u0026lt;\u0026lt; endl;    \n    \n    // 1\n    cnt1 \u003d 0;\n    cnt2 \u003d 0;\n    for (auto t : path)\n    {\n        answer +\u003d cnt2 * t.sz * 2;\n        cnt2 +\u003d (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n        cnt1 +\u003d n - t.edgeright - t.edgeleft - t.sz;\n    }\n    cnt1 \u003d 0;\n    cnt2 \u003d 0;\n    for (int i \u003d (int)path.size() - 1; i \u0026gt;\u003d 0; i--)\n    {\n        auto \u0026amp;t \u003d path[i];\n        answer +\u003d cnt2 * t.sz * 2;\n        cnt2 +\u003d (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n        cnt1 +\u003d n - t.edgeleft - t.edgeright - t.sz;\n    }\n//     cout \u0026lt;\u0026lt; \u0026quot;after 1 old: \u0026quot; \u0026lt;\u0026lt; answer \u0026lt;\u0026lt; endl;\n    ll ttldown1 \u003d 0;\n    ll ttldown2 \u003d 0;\n    for (auto t : path)\n    {\n        ll curdown \u003d n - t.edgeleft - t.edgeright - t.sz;\n        ll curdown2 \u003d t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n        answer +\u003d curdown2 * (sum - t.sz);\n        ttldown2 \u003d ttldown2 + curdown2 + ttldown1 * curdown * 2;\n        ttldown1 +\u003d curdown;\n    }\n\n//     cout \u0026lt;\u0026lt; \u0026quot;after 1: \u0026quot; \u0026lt;\u0026lt; answer \u0026lt;\u0026lt; endl;\n    \n    for (int i \u003d 1; i \u0026lt; (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n    ansmiddle[top[find(path[0].rep)]] \u003d ttldown2;\n}\n\nint go(int cur, int pr)\n{\n    down[cur] \u003d 1;\n    up[cur] \u003d pr;\n    dp1[cur] \u003d 0;\n    ansmiddle[cur] \u003d 0;\n    tin[cur] \u003d timer++;\n    for (auto t : gr[cur]) if (t !\u003d pr)\n    {\n        down[cur] +\u003d go(t, cur);\n        answer +\u003d (ll)dp1[t] * dp1[cur] * 2;\n        answer +\u003d (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n        ansmiddle[cur] +\u003d (ll)dp1[t] * dp1[cur] * 2;\n        answer +\u003d dp2[t] * 2;\n        dp2[cur] +\u003d dp2[t];\n        dp1[cur] +\u003d dp1[t];\n    }\n    ansmiddle[cur] +\u003d (ll)(n - down[cur]) * dp1[cur] * 2;\n    dp2[cur] +\u003d dp1[cur];\n    dp1[cur] +\u003d 1;\n    tout[cur] \u003d timer - 1;\n//     cout \u0026lt;\u0026lt; \u0026quot;exit \u0026quot; \u0026lt;\u0026lt; cur \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; answer \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; dp1[cur] \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; dp2[cur] \u0026lt;\u0026lt; endl;\n    return down[cur];\n}\n\nint main()\n{\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    for (int i \u003d 0; i \u0026lt; n - 1; i++)\n    {\n        int a, b;\n        scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;a, \u0026amp;b);\n        a--, b--;\n        gr[a].pb(b);\n        gr[b].pb(a);\n    }\n    go(0, -1);\n    for (int i \u003d 0; i \u0026lt; n; i++)\n    {\n        p[i] \u003d i;\n        s[i] \u003d 0;\n        top[i] \u003d i;\n        sz[i] \u003d 1;\n    }\n    printf(\u0026quot;%lld\\n\u0026quot;, answer);\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;m);\n    for (int i \u003d 0; i \u0026lt; m; i++)\n    {\n        int a, b;\n        scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;a, \u0026amp;b);\n        a--, b--;\n        addedge(a, b);\n        printf(\u0026quot;%lld\\n\u0026quot;, answer);\n    }\n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["editorial","manthan","codefest"]}}