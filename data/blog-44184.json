{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1459811247,"rating":1,"authorHandle":"dorellin","modificationTimeSeconds":1459901297,"id":44184,"title":"\u003cp\u003eSoluções da Aula 4\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eOi!\u003c/p\u003e\u003cp\u003eFaz um tempo que não posto nada aqui, então vou tentar discutir os problemas dessa semana bem :)\u003c/p\u003e\u003cp\u003ePrimeiramente, parabéns a todos que estão tentando resolver os problemas (\u003ca href\u003d\"/group/gy03x0glsj/contest/206736/standings/groupmates/true\" title\u003d\"Standings - Gema Aula 4\"\u003estandings\u003c/a\u003e). Nenhuma das aulas/provas foram fáceis, in fact, estão bem mais difíceis que as do ano passado. \u003c/p\u003e\u003cp\u003eSem mais, vamos para os problemas.\u003c/p\u003e\u003ch2\u003eProblema D — Esse eu Passo\u003c/h2\u003e\u003cp\u003eEsse problema pedia para que você descobrisse quantas strings únicas existiam na entrada. Diferentemente dos problemas recentes, não é dado o número de strings que você deve ler. Quando isso ocorre, você deve ler da entrada padrão enquanto não há mais nada para ser lido. \u003c/p\u003e\u003cp\u003eUsando \u003ccode\u003ecin\u003c/code\u003e, podemos fazer \u003ccode\u003ewhile (cin \u0026gt;\u0026gt; x)\u003c/code\u003e. Quando o final do arquivo é atingido, o \u003ccode\u003ecin\u003c/code\u003e retorna \u003ccode\u003efalse\u003c/code\u003e. Usando \u003ccode\u003escanf\u003c/code\u003e, você pode fazer \u003ccode\u003ewhile (scanf(\u0026quot;%s\u0026quot;, s) !\u003d EOF)\u003c/code\u003e — ou seja — o \u003ccode\u003escanf\u003c/code\u003e retorna o valor \u003ccode\u003eEOF\u003c/code\u003e quando encontra o final de arquivo. Para emular a entrada, você pode executar seu programa com um arquivo no lugar da entrada padrão (\u003ccode\u003e./exec \u0026lt; entrada.in\u003c/code\u003e — veja mais no post das aulas passadas) ou enviar \u003ccode\u003ectr+D\u003c/code\u003e no terminal para simular final de arquivo. \u003c/p\u003e\u003cp\u003eVamos então para o problema. Queremos contar quantas strings diferentes há no conjunto. Inicialmente, você pode pensar em fazer isso:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// Le as strings\nint res \u003d 0;\nfor (int i \u003d 0; i \u0026lt; n; ++i) {\n   bool unique \u003d true;\n   for (int j \u003d 0; unique and j \u0026lt; i; ++j) {\n      if (v[i] \u003d\u003d v[j]) unique \u003d false;\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAqui, basicamente, estamos comparando cada string com todas que apareceram antes e vendo se há alguma outra ocorrência. Dessa forma, toda primeira ocorrência de uma string somamos +1 na resposta. O problema dessa abordagem é que ela é muito lenta. Se tivermos \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 10\u003csup class\u003d\"upper-index\"\u003e5\u003c/sup\u003e\u003c/span\u003e strings, fazendo esse procedimento temos que percorrer, no caso em que todas as strings são únicas, \u003cspan class\u003d\"tex-span\"\u003e1 + 2 + ... + \u003ci\u003en\u003c/i\u003e\u003c/span\u003e strings, que é \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e (soma da P.A.!) — o que nos dá algo em torno de \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e10\u003c/sup\u003e\u003c/span\u003e operações — isso se ignorarmos as operações para comparar que duas strings são iguais.\u003c/p\u003e\u003cp\u003eEspero ter te convencido que essa abordagem é lenta. Se você não está convencido, implemente e teste você mesmo.\u003c/p\u003e\u003cp\u003eA abordagem esperada era armazenar as strings em um \u003ccode\u003eset\u003c/code\u003e. Um \u003ccode\u003eset\u003c/code\u003e é uma estrutura de dados existente na biblioteca padrão do \u003ccode\u003eC++\u003c/code\u003e que nos permite encontrar se um elemento está presente nela de forma muito mais rápido do que comparando um a um, utilizando árvores binárias de busca. Para referência, para encontrar uma string num \u003ccode\u003eset\u003c/code\u003e, o set faz no máximo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elogN\u003c/i\u003e\u003c/span\u003e comparações — onde \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e é o número de elementos do conjunto. \u003c/p\u003e\u003cp\u003eAs operações de inserção, busca e remoção nessa estrutura de dados levam todas tempo proporcional a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003elogN\u003c/i\u003e\u003c/span\u003e. Além disso, ao inserir duas vezes o mesmo valor no \u003ccode\u003eset\u003c/code\u003e, a segunda inserção será ignorada. Portanto, se inserirmos todas as strings em um \u003ccode\u003eset\u003c/code\u003e e no final pegarmos o número de elementos, temos a resposta!\u003c/p\u003e\u003cp\u003eO código está abaixo:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;string\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;set\u0026gt;\n\nusing namespace std;\n\nint main (void) {\n\tstring a;\n\tset\u0026lt;string\u0026gt; s;\n\tint n;\n\tcin \u0026gt;\u0026gt; n;\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) {\n\t\tcin \u0026gt;\u0026gt; a;\n\t\ts.insert(a);\n\t}\n\tcout \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl;\n\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eUm detalhe importante é que não podemos criar um \u003ccode\u003eset\u0026lt;char*\u0026gt;\u003c/code\u003e. Apesar de possível declarar algo assim, quand são feitas as comparaṍes para encontrar um elemento, um \u003ccode\u003eset\u0026lt;char*\u0026gt;\u003c/code\u003e irá comparar o valor dos ponteiros — que é um endereço. \u003c/p\u003e\u003cp\u003eÉ importante lembrar que \u003ccode\u003eset\u003c/code\u003e e \u003ccode\u003emap\u003c/code\u003e mantém seus elementos ordenados, utilizando a relação de ordem definida pelo operador \u003ccode\u003e\u0026lt;\u003c/code\u003e.. Em C++, esse operador já é definido por padrão para \u003ccode\u003estrings\u003c/code\u003e, e nada mais é que a comparação alfabética entre as duas strings. \u003c/p\u003e\u003cp\u003eO número de operações realizado no final por essa solução é proporcional a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eNlogN\u003c/i\u003e\u003c/span\u003e, pois cada inserção no \u003ccode\u003eset\u003c/code\u003e leva tempo proporcional \u003ccode\u003elog N\u003c/code\u003e — e são feitas \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e inserções.\u003c/p\u003e\u003cp\u003eOutra possível solução seria algo parecido com o seguinte:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003esort (strings.begin(), strings.end());\nres \u003d 1;\nfor (int i \u003d 1; i \u0026lt; n; ++i) {\n   if (strings[i] !\u003d strings[i-1]) res++;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNessa solução, primeiramente ordenamos um \u003ccode\u003evector\u003c/code\u003e que contém todas as strings. O custo da ordenação padrão do C++ é o mesmo da nossa outra solução — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003enlogn\u003c/i\u003e\u003c/span\u003e, mas é até mais rápido. Com o vetor já ordenado, achamos a primeira ocorrência única de cada string comparando cada elemento do vetor com o anterior — quando esses valores são diferentes, estamos em uma string única. \u003c/p\u003e\u003cp\u003eDaqui alguns meses todos vocês que estão se empenhando vão com certeza olhar para trás e rir ao perceber quão simples era esse problema — quando isso acontecer venham me contar! :) Apesar disso, é um problema bom para praticar.\u003c/p\u003e\u003ch2\u003eProblema G — Trem de Letras\u003c/h2\u003e\u003cp\u003eEsse problema parece confuso no início. Processamos a sequência da esquerda para a direita. São dadas algumas regras para calcular a pontuação de uma sequência de letras — cada letra maíscula perde 100 pontos. Para as letras minúsculas temos alguns casos, dependendo das letras maísculas que já apareceram até esse ponto\u003c/p\u003e \u003cul\u003e   \u003cli\u003eSe não apareceram letras maísculas ainda, ou se todas as que apareceram já foram utilizadas, perde-se 300 pontos\u003c/li\u003e   \u003cli\u003eSe ainda há letras maísculas não processadas que aparecem antes da letra atual, pegue a letra que apareceu mais recentemente. Se ela for igual à letra minúscula em questão (por exemplo, \u003ccode\u003eA\u003c/code\u003e e \u003ccode\u003ea\u003c/code\u003e) ganha-se 200 pontos; se ela for diferente — perdem-se 100 pontos. Essa letra maiúscula que acabou de ser utilizada não pode ser mais utilizada pelas próximas letras minúsculas.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eA descrição do procedimento para calcular a pontuação já nos fornece um algoritmo para calcular seu valor. Esse algoritmo não é bom, pois, como veremos, é muito lento — mas é interessante que você consiga implementá-lo. Vamos ao código.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003econst int N \u003d 1000001;\nint used[N];\n\nint main (void) {\n    string s;\n    cin \u0026gt;\u0026gt; s;\n    int res \u003d 0;\n    for (int i \u003d 0; i \u0026lt; n; ++i) {\n       if (s[i] \u0026gt;\u003d \u0027A\u0027 and s[i] \u0026lt;\u003d \u0027Z\u0027) res -\u003d 100;\n       else {\n           // Procuramos uma letra maiscula disponivel\n           bool achou \u003d false;\n           for (int j \u003d i - 1; j \u0026gt;\u003d 0; --j) {\n               if (s[j] \u0026gt;\u003d \u0027A\u0027 and s[j] \u0026lt;\u003d \u0027Z\u0027 and used[j] \u003d\u003d false) {\n                   if (s[j] - \u0027A\u0027 + \u0027a\u0027 \u003d\u003d s[i]) res +\u003d 200;\n                   else res -\u003d 100;\n                   achou \u003d true;\n                   used[j] \u003d true;\n                   break;\n               }\n           }\n           if (!achou) res -\u003d 300;\n       }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAqui, utilizamos o truque de manter um vetor adicional dizendo, para cada posição, se ela já foi utilizada — e então ao encontrar uma letra minúscula literalmente procuramos alguma letra maíscula para trás (tomando o cuidado de passar primeiro pelas mais recentes) que ainda não foi utilizada.\u003c/p\u003e\u003cp\u003eCom essa abordagem, podemos ter que fazer um número quadrático de operações. Imagine que o seu vetor só tem letras minúsculas — para cada letra minúscula, iremos passar por todos os elementos que aparecem antes. Esse é o mesmo número de operações da solução \u0027simples\u0027 do problema anterior — e é proporcional a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eÉ importante fazer uma pausa agora. Você pode pensar em, por exemplo, guardar quantas letras maísculas ainda estão disponíveis para trás, e só buscar quando realmente existirem letras maísculas para encontrar. De fato, se você fizer isso, para o caso onde só há letras minúsculas (\u0027aaaaazsaflsaf\u0027, por exemplo), seu algoritmo vai ser rápido. É preciso tomar cuidado com esse tipo de \u0027otimização\u0027 — que resolve um problema específico, pois podem existir outros casos de teste que continuam lentos. \u003c/p\u003e\u003cp\u003eUm exemplo seria um caso de teste assim: \u003ccode\u003eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u003c/code\u003e. Para as letras \u003ccode\u003ea\u003c/code\u003e que estão no final, ainda teremos que percorrer quase a string inteira para encontrar seu equivalente. Ou seja, a \u0027otimização\u0027 que encontramos não nos dá garantir nenhuma de que faremos menos operações. \u003c/p\u003e\u003cp\u003eO problema dessa solução é o fato de termos que percorrer coisas inúteis — letras minúsculas e letras maísculas já processadas. Para resolver isso, mantemos uma pilha (lembre-se: na pilha, o elemento que entrou mais recentemente é o próximo a sair) com as letras maísculas. Quando encontramos uma minúscula, basta checar o topo da pilha para ver se há uma letra maíscula correspondente — e, se houver, removemos essa letra maíscula da pilha — deixando no topo agora a letra que apareceu exatamente antes dela. \u003c/p\u003e\u003cp\u003eAs operações de inserção e remoção na pilha levam tempo constante — ou seja, não dependem do tamanho da pilha. Então, em geral, faremos um número de operações proporcional apenas ao tamanho da sequuência — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Segue a solução:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint main (void) {\n    string s;\n    cin \u0026gt;\u0026gt; s;\n    stack \u0026lt;char\u0026gt; v;\n    int res \u003d 0;\n    for (int i \u003d 0; i \u0026lt; s.size(); ++i) {\n        if (s[i] \u0026gt;\u003d \u0027A\u0027 and s[i] \u0026lt;\u003d \u0027Z\u0027) {\n            v.push (s[i]);\n            res -\u003d 100;\n        } else {\n            if (v.empty()) res -\u003d 300;\n            else {\n                char c \u003d v.top(); v.pop();\n                if (c \u003d\u003d s[i]-\u0027a\u0027+\u0027A\u0027) res +\u003d 200;\n                else res -\u003d 100;\n            }\n        }\n    }\n    cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEsse problema, no final, tinha uma estrutura similar ao problema da sequência de parênteses — resolvido em aulas. Se quiser treinar algum outro problema assim, tente esse aqui: \u003ccode\u003ehttps://uva.onlinejudge.org/index.php?option\u003dcom_onlinejudge\u0026amp;Itemid\u003d8\u0026amp;page\u003dshow_problem\u0026amp;problem\u003d614\u003c/code\u003e! :D\u003c/p\u003e\u003ch2\u003eProblema F — As Abelhas de Nabucodonosor\u003c/h2\u003e\u003cp\u003eNesse problemas, nos deparamos com uma questão que nos diz exatamente o que fazer e, surpreendentemente, dessa vez, basta fazer o que é pedido e não levaremos \u003ccode\u003eTime Limit Exceeded\u003c/code\u003e. O rei Nabucodonosor II (\u003ca href\u003d\"https://en.wikipedia.org/wiki/Nebuchadnezzar_II\"\u003ehttps://en.wikipedia.org/wiki/Nebuchadnezzar_II\u003c/a\u003e — o cara era fera, construiu os jardins suspensos) resolveu mandar seus súditos para proteger algumas colméias, que estão localizadas em alguns pontos de um plano cartesiano. \u003c/p\u003e\u003cp\u003eEle fará isso em ordem, porém se algum súdito que está defendendo alguma das colméias já atribuídas consegue defender a próxima colméia, o rei decide que não precisa colocar um guarda nessa colméia (cada súdito tem um raio de visão \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e, que é um círculo). \u003c/p\u003e\u003cp\u003ePara resolver esse problema, para cada novo súdito, marcamos uma \u003ccode\u003eflag\u003c/code\u003e como positiva para todas as colméias que ele enxerga. Se chegar no momento de avaliar uma colméia e sua flag está positiva, significa que não colocamos guarda nessa colméia. Aqui, a complexidade da solução é também proporcional ao quadrado do número de colméias — mas o número de colméias era baixo (1000).\u003c/p\u003e\u003cp\u003eSegue a solução!\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nconst int N \u003d 1000;\nlong long x[N], y[N];\nbool good[N];\n\nlong long dist (int a, int b) {\n\treturn ((x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]));\n}\n\nint main (void) {\n\tint n;\n\tcin \u0026gt;\u0026gt; n;\n\tlong long r;\n\tcin \u0026gt;\u0026gt; r;\n        r *\u003d r;\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; y[i];\n\tint ans \u003d 0;\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) {\n\t\tif (good[i]) continue;\n\t\tans++;\n\t\tfor (int j \u003d i + 1; j \u0026lt; n; ++j) {\n\t\t\tif (dist(i, j) \u0026lt;\u003d r) good[j] \u003d true;\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRepare que aqui, utilizamos o quadrado do raio para calcular a distância sem precisar tirar raiz quadrada — esse é um procedimento bastante comum. Sempre que é possível evitar fazer contas com ponto flutuante, evite! Além disso, utilizamos \u003ccode\u003elong long int\u003c/code\u003e, pois a distância entre duas colméias pode estourar a capacidade de um inteiro!\u003c/p\u003e\u003ch2\u003eProblema E — Ping Pong\u003c/h2\u003e\u003cp\u003eNesse problema, temos \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e\u003c/span\u003e palavras, de até \u003cspan class\u003d\"tex-span\"\u003e20\u003c/span\u003e caracteres cada, que compõe um dicionário. Queremos saber, para cada palavra, se ela é a junção de duas outras palavras do dicionário.\u003c/p\u003e\u003cp\u003eVamos pensar inicialmente numa solução \u0026quot;burra\u0026quot;, mas que resolveria o problema para casos pequenos. O problema envolve quebrar strings em duas partes não vazias — e verificar se as duas partes estão no dicionário. Vamos utilizar a função \u003ccode\u003esubstr\u003c/code\u003e da \u003ccode\u003estring\u003c/code\u003e do C++. Porém, é importante ter uma idéia de como fazer essas coisas. Por exemplo, se quisessemos gerar todas as possíveis formas de dividir uma string, mas não sabemos que existe a função \u0027substr\u0027, podemos fazer assim:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid gera_divisoes (string s) {\n    string esq \u003d \u0026quot;\u0026quot;;\n    string dir \u003d s;\n    for (int i \u003d 0; i \u0026lt; s.size()-1; ++i) {\n       esq +\u003d s[i];\n       dir.erase(1);\n       cout \u0026lt;\u0026lt; esq \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; dir \u0026lt;\u0026lt; endl;\n    }\n} \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAqui, passamos pela string, atualizando as strings da esquerda e da direita a cada passo. Repare, entretanto, que utilizamos o método \u003ccode\u003eerase\u003c/code\u003e da \u003ccode\u003estring\u003c/code\u003e — esse método pode executar um número de operações proporcional ao tamanho da string. Ou seja, se nossa \u003ccode\u003estring\u003c/code\u003e fosse muito grande, poderíamos ter um problema. Não é o caso nesse problema, já que os tamanhos vão até \u003cspan class\u003d\"tex-span\"\u003e20\u003c/span\u003e apenas.\u003c/p\u003e\u003cp\u003eA função \u003ccode\u003esubstr\u003c/code\u003e da string nos retorna uma \u003ccode\u003estring\u003c/code\u003e, e recebe dois argumentos: a posição inicial onde desejamos extrair a substring, e o tamanho.\u003c/p\u003e\u003cp\u003eCom isso, iremos utilizar a mesma abordagem da solução do primeiro problema: iremos manter um \u003ccode\u003eset\u003c/code\u003e com todas as strings, e, para cada string, checar para todas as possíveis divisões se o lado direito e o lado esquerdo estão no \u003ccode\u003eset\u003c/code\u003e. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nint main(void) {\n\tset \u0026lt;string\u0026gt; s;\n\tvector \u0026lt;string\u0026gt; v;\n\tstring in;\n\n\twhile (cin \u0026gt;\u0026gt; in){\n\t\ts.insert (in);\n\t\tv.push_back (in);\n\t}\n\n\tint ans \u003d 0;\n\tfor (int i\u003d0; i\u0026lt;v.size(); i++){\n\t\tfor (int t \u003d 1; t \u0026lt;\u003d v[i].size()-1; t++){\n\t\t\tstring esq \u003d v[i].substr (0, t);\n\t\t\tstring dir \u003d v[i].substr (t, v[i].size() - t);\n\t\t\tif (s.count(esq) \u0026gt; 0 and s.count(dir) \u0026gt; 0){\n\t\t\t\tans ++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eProblema C — O Mapa de Zomberterson\u003c/h2\u003e\u003cp\u003eMais um problema em que precisamos checar se um elemento já apareceu mais de uma vez na sequência...tá ficando óbvio já. Dessa vez nem pensamos mais na solução computacionalmente mais cara — já pensamos diretamente em utilizar um map — não utilizamos set, pois queremos contar quantas vezes cada elemento já ocorreu — e não apenas descobrir se ele está presente ou não. \u003c/p\u003e\u003cp\u003eAqui, o único problema era a sintaxe para utilizar uma estrutura própria em um \u003ccode\u003emap\u003c/code\u003e. Por \u0026quot;sorte\u0026quot;, eu passei exatamente isso na aula — mas você pode rever o código aqui. \u003c/p\u003e\u003cp\u003eAlém disso, você devia tomar cuidado nesse problema: as distâncias eram números reais, e a aproximação só ocorria no final. Além disso, mais uma vez a multiplicação das coordenadas poderia passar do limite representável pelo tipo \u003ccode\u003eint\u003c/code\u003e — logo, utilizamos \u003ccode\u003elong long\u003c/code\u003e. Segue a solução.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;cstdio\u0026gt;\n\nusing namespace std;\n\nstruct Ponto {\n\tlong long x, y;\n\n\tbool operator \u0026lt; (const Ponto \u0026amp;b) const {\n\t\tif (x !\u003d b.x) return x \u0026lt; b.x;\n\t\treturn y \u0026lt; b.y;\n\t}\n\n\tdouble distance (Ponto b) {\n\t\treturn sqrt( (x-b.x)*(x-b.x) + (y-b.y)*(y-b.y));\n\t}\n};\n\nint main (void) {\n\tmap \u0026lt;Ponto, int\u0026gt; m;\n\tint n;\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\tPonto atual;\n\tatual.x \u003d 0, atual.y \u003d 0;\n\tdouble ans \u003d 0.0;\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) {\n\t\tPonto p;\n\t\tscanf(\u0026quot;%lld %lld\u0026quot;, \u0026amp;p.x, \u0026amp;p.y);\n\t\tif (m[p] \u0026lt; 2) {\n\t\t\tm[p]++;\n\t\t\tans +\u003d atual.distance(p);\n\t\t\tatual \u003d p;\n\t\t}\n\t}\n\tprintf(\u0026quot;%lld\\n\u0026quot;, (long long int)ans);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSe estiver em dúvida sobre a síntaxe, e o que faz cada coisa nesse código, recomendo codificar algo parecido e ver como funciona — crie uma struct própria para representar o que quiser e tente armazená-la em um \u003ccode\u003emap\u003c/code\u003e. ;)\u003c/p\u003e\u003cp\u003ePS: Nesse problema, use \u003ccode\u003escanf\u003c/code\u003e para ler os dados, pois é um pouco mais rápido, ou coloque a seguinte linha no início do seu programa (dentro da main): \u003ccode\u003eios::sync_with_stdio(false)\u003c/code\u003e. Lembre-se de não misturar \u003ccode\u003escanf\u003c/code\u003e com \u003ccode\u003ecin\u003c/code\u003e!\u003c/p\u003e\u003ch2\u003eProblema B\u003c/h2\u003e\u003cp\u003eNesse problema, possuímos um conjunto de moedas (das quais temos uma quantidade infinita de cada uma), e gostaríamos de saber de quantas formas podemos dar um troco de \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003ePor exemplo, se o conjunto de moedas for \u003cspan class\u003d\"tex-span\"\u003e{2, 3, 6}\u003c/span\u003e, e queremos dar um troco de \u003cspan class\u003d\"tex-span\"\u003e8\u003c/span\u003e, podemos fazer das seguintes maneiras:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e2, 2, 2, 2\u003c/li\u003e   \u003cli\u003e2, 3, 3\u003c/li\u003e   \u003cli\u003e2, 6\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eRepare que temos que tomar cuidado para não contar várias vezes a mesma combinação. \u003cspan class\u003d\"tex-span\"\u003e{2, 3, 3}\u003c/span\u003e é a mesma maneira de dar troco que \u003cspan class\u003d\"tex-span\"\u003e{3, 2, 3}\u003c/span\u003e, uma vez que a ordem não importa.\u003c/p\u003e\u003cp\u003eComo resolvemos esse problema? Uma boa maneira de pensar é tentar todas as combinações possíveis de moedas. Nesse caso, temos que tomar cuidado para não gerar combinações que já foram geradas antes. Para fazer isso, vamos utilizar a seguinte invariante: ao utilizar a i-ésima moeda, não iremos utilizar nenhuma moeda que aparece antes no nosso array.\u003c/p\u003e\u003cp\u003eComo isso resolve o problema das repetições? Vamos supor que a sequência seja: \u003cspan class\u003d\"tex-span\"\u003e{2, 3, 6}\u003c/span\u003e novamente. Vamos supor que já utilizamos duas vezes a primeira moeda e uma vez a segunda moeda. Como estamos observando a segunda moeda, não iremos mais utilizar moedas que apareceram para trás. Isso nos impede de gerar a sequência \u003cspan class\u003d\"tex-span\"\u003e{2, 2, 3, 2}\u003c/span\u003e. Logo, se formos dar um troco utilizando um subconjunto \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e das moedas, nós iremos gerar apenas uma ordem desse subconjunto, que é a ordem em que as moedas aparecem na entrada.\u003c/p\u003e\u003cp\u003eCom essa idéia em mente, ainda temos um problema. Como fazemos parar gerar tais conjuntos? Sabemos que precisamos conhecer a moeda que estamos olhando atualmente, pois sem essa informação não conseguimos evitar a geração de conjuntos repetidos (leia acima mais uma vez se você não entendeu o motivo disso). \u003c/p\u003e\u003cp\u003eO que mais é necessário saber para ser capaz de dar o troco? A quantidade que falta para completar. Vamos pensar então em uma função dessas duas variáveis: T (quanto falta para dar de troco) e M (a moeda que estamos olhando atualmente — só podemos utilizar as moedas à partir dessa). \u003c/p\u003e\u003cp\u003eQueremos então calcular \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003eT\u003c/i\u003e, \u003ci\u003eM\u003c/i\u003e)\u003c/span\u003e, que é o número de formas de retornar T de troco podendo utilizar todas as moedas à partir da M-ésima moeda. \u003c/p\u003e\u003cp\u003eNesse tipo de problema, é comum pensar em quais são as possibilidades dado que estamos em um determinado estado. Aqui, temos duas opções: utilizar a M-ésima moeda ou não utilizar.\u003c/p\u003e\u003cp\u003eVamos supor que resolvemos utilizar a M-ésima moeda. Suponha que o troco atual é \u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e e a M-ésima moeda vale \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e. Se utilizarmos essa moeda, nosso valor de troco cairá para \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e, mas ainda podemos utilizar essa moeda mais uma vez. Faz sentido então dizer que, se resolvermos utilizar a M-ésima moeda, todas as maneiras de gerar \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e - \u003ci\u003ev\u003c/i\u003e[\u003ci\u003eM\u003c/i\u003e]\u003c/span\u003e de troco, podendo utilizar todas as moedas à partir da i-ésima também são formas de dar \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e de troco. (aqui, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e[\u003ci\u003eM\u003c/i\u003e]\u003c/span\u003e é o valor da M-ésima moeda).\u003c/p\u003e\u003cp\u003eUma maneira alternativa de entender esse pensamento é o seguinte. Imagine o conjunto \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e de todas os conjuntos de de moedas que nos permitem devolver \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e - \u003ci\u003ev\u003c/i\u003e[\u003ci\u003eM\u003c/i\u003e]\u003c/span\u003e de troco. Se as moedas forem \u003cspan class\u003d\"tex-span\"\u003e{2, 3, 6}\u003c/span\u003e e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e \u003d 5\u003c/span\u003e e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e[\u003ci\u003eM\u003c/i\u003e] \u003d 3\u003c/span\u003e (logo, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e \u003d 2\u003c/span\u003e, temos que \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u003d {}\u003c/span\u003e — que é o conjunto de todos os conjuntos de moedas que permitem devolver \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e de troco usando todas as moedas que aparecem depois da segunda ou ela mesma. O fato de \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e ser vazio nos indica que é impossível devolver \u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e de troco utilizando essas moedas (isso não é difícil de ver). Se, ao invés de \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e \u003d 5\u003c/span\u003e, T valesse \u003cspan class\u003d\"tex-span\"\u003e6\u003c/span\u003e, teríamos \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u003d {{3}}\u003c/span\u003e ou seja, é possível devolver \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e de troco, e só há uma maneira: utilizando a terceira moeda. Logo, para devolver \u003cspan class\u003d\"tex-span\"\u003e6\u003c/span\u003e de troco podemos contar todas as formas de devolver \u003cspan class\u003d\"tex-span\"\u003e3\u003c/span\u003e de troco. Nesse caso, nosso \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003c/span\u003e para \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e \u003d 6\u003c/span\u003e seria \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e \u003d {{3, 3}}\u003c/span\u003e (basta adicionar a moeda atual a cada um dos conjuntos que resolvia o problema para o troco restante)!\u003c/p\u003e\u003cp\u003eQuando decidimos não utilizar a moeda atual, o raciocínio é semelhante, porém agora nosso troco não muda, mas \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e avança no array. Logo, temos a fórmula recursiva\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003eT\u003c/i\u003e, \u003ci\u003eM\u003c/i\u003e) \u003d \u003ci\u003eF\u003c/i\u003e(\u003ci\u003eT\u003c/i\u003e - \u003ci\u003ev\u003c/i\u003e[\u003ci\u003eM\u003c/i\u003e], \u003ci\u003eM\u003c/i\u003e) + \u003ci\u003eF\u003c/i\u003e(\u003ci\u003eT\u003c/i\u003e, \u003ci\u003eM\u003c/i\u003e + 1)\u003c/span\u003e\u003c/p\u003e\u003cp\u003eTemos que tomar cuidado com os casos base. Quando o \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e \u003d 0\u003c/span\u003e, dizemos que há 1 maneira de devolver esse troco — que é não devolver nada. Quando \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e \u0026lt; 0\u003c/span\u003e ou \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003c/span\u003e ultrapassa a posição da última moeda, não há nada mais que possamos fazer — então retornamos 0. \u003c/p\u003e\u003cp\u003ePor fim, a última coisa que queremos fazer é calcular o resultado dessa conta — que pode ser muito grande — módulo \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e. Para isso, utilizamos a operação de mod a cada soma que fazemos — pois assim evitamos que o resultado dê overflow durante as contas. O código pode ser visto abaixo\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nconst int N \u003d 2000;\nconst int M \u003d 1000000000;\nint n, m;\nint moedas[N];\nint dp[N][N];\n\nint solve (int i, int v) {\n\tif (v \u0026gt; m) return 0;\n\tif (v \u003d\u003d m) return 1;\n\tif (i \u003d\u003d n) return 0;\n\tint \u0026amp;res \u003d dp[i][v];\n\tif (res !\u003d -1) return res;\n\tres \u003d solve (i, v + moedas[i]);\n\tres \u003d (res + solve(i + 1, v))%M;\n\treturn res;\n}\n\nint main (void) {\n\tmemset (dp, -1, sizeof dp);\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; moedas[i];\n\tcout \u0026lt;\u0026lt; solve(0, 0) \u0026lt;\u0026lt; endl;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eComo em alguns outros problemas, guardamos os resultados parciais em uma matriz (pois temos duas variáveis como estados) para evitar calcular coisas que já calculamos. \u003c/p\u003e\u003cp\u003eFiz um gráfico com todas as chamadas recursivas utilizadas para calcular o resultado para \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e \u003d 12\u003c/span\u003e de troco e as moedas \u003cspan class\u003d\"tex-span\"\u003e{2, 3, 5}\u003c/span\u003e, que pode ser visto na imagem nesse link: \u003ca href\u003d\"http://postimg.org/image/ivrc2oho1/\"\u003eIMAGEM\u003c/a\u003e\u003c/p\u003e\u003ch2\u003eProblema A — Rackoon Mario\u003c/h2\u003e\u003cp\u003ePor fim, o problema mais difícil da prova. Se você chegou até aqui (alguém chegou? :P), vamos lá que tá acabando.\u003c/p\u003e\u003cp\u003eNesse problema, temos o mesmo impasse do problema anterior: em uma determinada etapa, precisamos fazer uma decisão. A decisão aqui é pegar ou não pegar uma moeda. Porém, dessa vez, estamos interessados no melhor resultado, e não no número de formas de fazer algo. Portanto, podemos escolher apenas o melhor entre duas coisas: pegar ou não pegar a moeda.\u003c/p\u003e\u003cp\u003eSe colocarmos apenas a moeda atual como estado, não sabemos dizer quando iremos começar a voar. Uma coisa que você deve reparar para resolver o problema é que, uma vez que começamos a voar, devemos continuar voando até voltar para o chão, pegando todas as moedas no caminho. Não há necessidade de fazer decisões durante o o vôo, uma vez que o Mário pega as moedas tanto do chão quanto da terra durante esse tempo.\u003c/p\u003e\u003cp\u003eVocê pode estar se perguntando por quê podemos decidir deixar uma moeda passar. Basta olhar os casos de exemplo para descobrir — podemos tentar atrasar o início do vôo, para aproveitá-lo melhor.\u003c/p\u003e\u003cp\u003ePara saber se começamos a voar, devemos saber quantas moedas já estão no contador. Isso nos remete a dois estados: A moeda em que estamos atualmente, e qual o valor do contador de moedas. Vamos novamente chamar nossa solução de \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003eP\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e)\u003c/span\u003e, uma função do valor do contador e da moeda atual.\u003c/p\u003e\u003cp\u003eAqui, fica fácil dizer o que acontece quando resolvemos não pegar a moeda atual. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003eP\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e) \u003d \u003ci\u003eF\u003c/i\u003e(\u003ci\u003eP\u003c/i\u003e + 1, \u003ci\u003eC\u003c/i\u003e)\u003c/span\u003e, ou seja, se não pegamos moeda, apenas avançamos para a próxima moeda. Note que se a moeda está voando, essa é a única opção possível!\u003c/p\u003e\u003cp\u003eA parte complicada acontece quando resolvemos pegar a moeda. Se o valor no contador ainda não é o valor do vôo, temos uma chamada simples. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003eP\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e) \u003d \u003ci\u003emax\u003c/i\u003e(\u003ci\u003eF\u003c/i\u003e(\u003ci\u003eP\u003c/i\u003e + 1, \u003ci\u003eC\u003c/i\u003e), \u003ci\u003eF\u003c/i\u003e(\u003ci\u003eP\u003c/i\u003e + 1, \u003ci\u003eC\u003c/i\u003e + 1) + 1)\u003c/span\u003e. O lado esquerdo corresponde à opção de não pegar a moeda — o lado direito corresponde à opção de pegar a moeda. Note que somamos um ao resultado do lado direito, pois estamos aumentando nossa resposta em 1 pegando uma moeda. \u003c/p\u003e\u003cp\u003eSe ignorarmos o problema do vôo, ainda temos que tratar os casos base, que são simples nesse problema. Se chegamos na última moeda, não podemos fazer mais pontos, então retornamos 0. Ou seja, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e) \u003d 0\u003c/span\u003e , onde \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e é o número de moedas e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e\u003c/span\u003e é qualquer valor no contador. \u003c/p\u003e\u003cp\u003eVamos agora resolver o problema do vôo. Para isso, note que se tentarmos pegar uma moeda e começamos a voar, pegamos todas as moedas em uma distância \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e[\u003ci\u003eP\u003c/i\u003e] + \u003ci\u003eD\u003c/i\u003e\u003c/span\u003e (onde \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e[\u003ci\u003eP\u003c/i\u003e]\u003c/span\u003e é a posição da P-ésima moeda). Podemos então fazer um loop para descobrir qual a posição da moeda imediatamente posterior ao final do vôo — todas as moedas no caminho serão coletadas. Então, quando começamos a voar, temos \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003eP\u003c/i\u003e, \u003ci\u003eC\u003c/i\u003e) \u003d \u003ci\u003emax\u003c/i\u003e(\u003ci\u003eF\u003c/i\u003e(\u003ci\u003eP\u003c/i\u003e + 1, \u003ci\u003eC\u003c/i\u003e), \u003ci\u003eF\u003c/i\u003e(\u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003evoo\u003c/i\u003e\u003c/sub\u003e, 0) + \u003ci\u003eM\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003evoo\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e , onde o lado esquerdo novamente é a escolha de não pegar a moeda que nos faria começar a voar. Note que \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003evoo\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e pode ser achado com um loop simples à partir da posição atual, e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003evoo\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e é o número de moedas coletada durante o vôo.\u003c/p\u003e\u003cp\u003ePara encontrar \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eP\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003evoo\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eM\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003evoo\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, é possível utilizar uma busca binária. Suponha que você está na i-ésima posição. Vamos chutar que é possível chegar até a posição que fica na metade entre o final do vetor e a posição do início do vôo. Se a distância do início até a moeda nessa posição for menor que \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e, sabemos que podemos pegar todas as moedas que estão à esquerda com certeza; se for maior, sabemos que não podemos pegar nenhuma à direita. \u003c/p\u003e\u003cp\u003eEssa observação nos permite deixar nossa solução mais rápida.\u003c/p\u003e\u003cp\u003eSegue o código\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N \u003d 4000;\nll in[N][2];\nint dp[N][N];\nint n, x;\nll d;\n\nint next (int i) {\n\tint lo \u003d i, hi \u003d n-1;\n\twhile (hi !\u003d lo) {\n\t\tint mi \u003d (hi + lo + 1)/2;\n\t\tll dist \u003d in[mi][0] - in[i][0];\n\t\tif (dist \u0026lt;\u003d d) lo \u003d mi;\n\t\telse hi \u003d mi - 1;\n\t}\n\treturn lo;\n}\n\nint solve (int i, int j) {\n\tif (i \u003d\u003d n) {\n\t\treturn 0;\n\t}\n\tint\u0026amp; res \u003d dp[i][j];\n\tif (res !\u003d -1) return res;\n\tres \u003d solve (i +1, j);\n\tif (in[i][1]) {\n\t\tif (j !\u003d x-1) {\n\t\t\tres \u003d max(res, 1 + solve(i + 1, j + 1));\n\t\t} else {\n\t\t\tint k \u003d next(i);\n\t\t\tres \u003d (k - i + 1) + solve(k + 1, 0);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main (void) {\n\tmemset (dp, -1, sizeof dp);\n\tcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x \u0026gt;\u0026gt; d;\n\tfor (int i \u003d 0; i \u0026lt; n; ++i) {\n\t\tcin \u0026gt;\u0026gt; in[i][0] \u0026gt;\u0026gt; in[i][1];\n\t}\n\tcout \u0026lt;\u0026lt; solve (0, 0) \u0026lt;\u0026lt; endl;\t\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDICA: tente fazer esse problema. ;)\u003c/p\u003e\u003cp\u003ePor essa semana é isso.\u003c/p\u003e\u003cp\u003eBesos.\u003c/p\u003e\u003c/div\u003e","tags":[]}}