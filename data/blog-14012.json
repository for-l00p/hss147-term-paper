{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1411826987,"rating":0,"authorHandle":"Fcdkbear","modificationTimeSeconds":1411826987,"id":14012,"title":"\u003cp\u003eРазбор тренировки о хешах\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eПрежде всего, ссылка на разбор от авторов контеста:\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://vk.com/doc1852326_141572193?hash\u003d001257d203b5d76dba\"\u003ehttps://vk.com/doc1852326_141572193?hash\u003d001257d203b5d76dba\u003c/a\u003e\u003c/p\u003e\u003cp\u003eНа момент написания разбора, я его не читал, сейчас напишу как я решал задачи\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача А\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗаметим, что если у строк есть общая подстрока длины k, то у них есть и общая подстрока длины k-1. Значит, длина общей подстроки — бинарная функция, и перебирать ее длину можно бинарным поиском. Так и поступим.\u003c/p\u003e\u003cp\u003eТеперь у нас на каждом этапе бинарного поиска есть фиксированная длина. Как проверить, или у строк есть общая подстрока заданной длины?\u003c/p\u003e\u003cp\u003eЗаведем структуру данных, которая будет для каждой строки поддерживать множество индексовстрок, в которую эта подстрока входит. Тогда, нам нужно проверить, есть ли подстрока, у которой размер множества различных строк, в которые она входиткак подстрока, равен количеству строк, которыеу нас есть.\u003c/p\u003e\u003cp\u003eПоследний шаг — вместо самих строкв нашей структуре, конечно же, будем поддерживать хеши.\u003c/p\u003e\u003cp\u003eСложность решения — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNKlogN\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/sWQaqfnk\"\u003eКод\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача B\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eДавайте перебирать размер ответа. Теперь нам нужно сказать, есть ли у нас подмассивы, для которых выполняется свойство, описанное в условии. \u003c/p\u003e\u003cp\u003eКак это быстро проверять?\u003c/p\u003e\u003cp\u003eДавайте каждый подмассив представим при помощи другого массива. Первыйэлемент этого массива говорит нам, сколько элементов изначального подмассива встречаю.тся в нем только раз, второй- ровно 2 раза и так далее. Заметим, что при переходе к следующему подмассиву мы можем пересчитывать наш новый массив за O(1), обновив всего два элемента. Вместо самого второго массива, будем поддерживать его хеш, который тоже можно пересчитывать эффективно, добавляя/отнимая некоторую степеньчисла, выбранного нами в качестве базы.\u003c/p\u003e\u003cp\u003eСоответственно, полный алгоритм выглядит следующим образом:\u003c/p\u003e\u003cp\u003e1) Перебираем длину ответа. \u003c/p\u003e\u003cp\u003e2) Считаем хеши всех новых массивов от всех подмассивов заданой длины нашего первого массива. Складвыаем их в хеш-таблицу.\u003c/p\u003e\u003cp\u003e3) Считаем хеши всех новых массивов от всех подмассивов заданой длины нашего второго массива. Ищем найденныйе хеши в хеш таблице. Если находим — ура, мы нашли ответ (если перебирать длину от большей к меньшей — найденная длина и будет ответом)\u003c/p\u003e\u003cp\u003eВ задаче довольно жесткие ограничения, поэтому чтобы пропихнуть ее в ТЛ, нужно делать неасимптотические оптимизации (например, юзать свою хештаблицу, а не unordered_map)\u003c/p\u003e\u003cp\u003eСложность — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/H1AJ22TT\"\u003eКод\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача С\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eНам нужно посчитать количество палиндромов в строке, длина которіх больше 1.\u003c/p\u003e\u003cp\u003eТакая задача может быть решена хешами. Посчитаем хеш обычной и перевернутой строки. Далее отдельно рассмотрим палиндромы четной и нечетной длины. Я расскажу как решать задачу для палиндромов нечетной длины (для четной- все аналогично)\u003c/p\u003e\u003cp\u003eПереберем центр нашего палиндрома. Далее заметим, что длина палиндрома с заданным центром — бинарная функция. Переберм эту длину бинарным поиском. Для проверки строк заданной длины на равенство используем посчитанные выше хеши.\u003c/p\u003e\u003cp\u003eСложность — \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/hviQP1X1\"\u003eКод\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЗадача D\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eМое решение основывается на \u003ca href\u003d\"https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%D0%BA%D1%81_%D0%B4%D0%BD%D0%B5%D0%B9_%D1%80%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F\"\u003eПарадоксе дней рождения\u003c/a\u003e\u003c/p\u003e\u003cp\u003eИдея в том, что если сгенерировать достаточно большое количество строк, то вероятность того, что хеши двух из них совпадут, очень и очень высока. Точные формулы можете посмотреть по ссылке выше. И того, мы просто генерируем случайные строки до тех пор, пока не найдем две разыне строки с одинаковым хешем. \u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/g5V9kK3B\"\u003eКод\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["хэши","разбор","тренировка"]}}