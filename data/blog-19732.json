{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1439358515,"rating":0,"authorHandle":"DedMaxim","modificationTimeSeconds":1439366062,"id":19732,"title":"\u003cp\u003eТеория. Библиотека STL.\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eЭто пожалуй одна из самых важных причин, почему многие используют язык \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e +  + \u003c/span\u003e. Библиотека STL — это набор встроенных в этот язык полезных и бесполезных штук, делающих вашу работу максимально приятной. Вам предлагается прочесть \u003ca href\u003d\"http://informatics.mccme.ru/mod/book/view.php?id\u003d492\"\u003eотличную статью\u003c/a\u003e, в которой рассказывается о некоторых контейнерах (структурах) этой библиотеки. Чтобы завлечь вас, я покажу вам, что могут эти контейнеры.\u003c/p\u003e\u003cp\u003e1) Вам нужно реализовать множество каких-то элементов (чисел, символов, строк, векторов, ...). Вы должны уметь вставлять в это множество, удалять из него, а также уметь проверять, есть ли заданный элемент в множестве. Причём, на каждый запрос, нужно отвечать за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e. Было бы неплохо также говорить максимальный и минимальный элемент в множестве (например, для строк, это максимальные и минимальные в лексикографическом порядке строки) за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e. Это и многое другое, может делать контейнер \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eset\u003c/i\u003e\u003c/span\u003e. Вам предлагалось реализовать такое множество в последней задаче Тренировочного контеста 5. Стоит заметить, что если вы не хотите использовать \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eset\u003c/i\u003e\u003c/span\u003e, то вам придётся написать собственное декартово дерево. \u003c/p\u003e\u003cp\u003e2) Что если, вам не нужно теперь искать минимальный и максимальный элементы, а вставлять, удалять и проверять на существование в множестве вам нужно за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e? Тут вам поможет хеш-таблица. Её писать куда проще, чем декартово дерево, но \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e +  + \u003c/span\u003e уберёг вас и от этого, создав контейнер \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eunordered\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eset\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e3) Что если вам нужно сделать массив, у которого вам придётся обращаться к индексу 10000000000? Заведёте такой массив? Что ж, удачи). Лично я воспользуюсь контейнером \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emap\u003c/i\u003e\u003c/span\u003e, который позволяет это сделать за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e. Он также может сделать массив, у которого индексом будет... Строка!!! или вектор... Вот вам пример кода.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003emap \u0026lt;string, int\u0026gt; m;\nstring s \u003d \u0026quot;A\u0026quot;, t \u003d \u0026quot;B\u0026quot;;\nm[s] \u003d 1, m[t] \u003d 2;\ncout \u0026lt;\u0026lt; m[s] \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; m[t];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eЗнаете, что он выведет? Проверьте)\u003c/p\u003e\u003cp\u003e4) Вам очень часто нужно хранить не одно число, а два — например, координаты точек. Тут вам поможет контейнер \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epair\u003c/i\u003e\u003c/span\u003e. Пожалуй один из самых простых контейнеров. Вот пример кода.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epair \u0026lt;int, int\u0026gt; x[MAXN];\nint n;\n...\ncin \u0026gt;\u0026gt; n;\nfor (int i \u003d 0; i \u0026lt; n; i++) \n    cin \u0026gt;\u0026gt; x[i].first \u0026gt;\u0026gt; x[i].second;\nsort(x, x + n);\nfor (Int i \u003d 0; i \u0026lt; n; i++) {\n    cout \u0026lt;\u0026lt; x[i].first \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; x[i].second \u0026lt;\u0026lt; endl;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eА эта штука отсортирует вам массив пар, сначала по первому числу, а в случае равенства — по второму.\u003c/p\u003e\u003cp\u003e5) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eString\u003c/i\u003e\u003c/span\u003e — это тоже STL...\u003c/p\u003e\u003cp\u003e6) Есть ещё \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003evector\u003c/i\u003e\u003c/span\u003e. Эта штука, как массив, у которого, заранее может быть не известен размер. Вот пример:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector \u0026lt;int\u0026gt; a;\nint x;\n...\nwhile (cin \u0026gt;\u0026gt; x) {\n    a.push_back(x);\n}\nfor (int i \u003d 0; i \u0026lt; (int) a.size(); i++) \n    cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0027 \u0027; \\\\выводит содержимое вектора\n\u003c/code\u003e\u003c/pre\u003e \u003col\u003e   \u003cli\u003eА ещё там есть стек (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003estack\u003c/i\u003e\u003c/span\u003e), очередь (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003equeue\u003c/i\u003e\u003c/span\u003e), дек(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edeque\u003c/i\u003e\u003c/span\u003e), куча(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epriorityqueue\u003c/i\u003e\u003c/span\u003e) и многое другое.\u003c/li\u003e \u003c/ol\u003e\u003c/div\u003e","tags":[]}}