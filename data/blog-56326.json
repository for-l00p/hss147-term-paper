{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1513171664,"rating":14,"authorHandle":"Lance_HAOH","modificationTimeSeconds":1513392383,"id":56326,"title":"\u003cp\u003eGraph theory problem that requires transitive reduction\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi. I am trying to solve \u003ca href\u003d\"https://dunjudge.me/analysis/problems/1433/\"\u003ethis\u003c/a\u003e problem.\u003c/p\u003e\u003cp\u003eFor convenience, I have summarized the problem statement below (based on my understanding):\u003c/p\u003e\u003cp\u003e\u003cem\u003eGiven a directed graph with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e vertices and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eE\u003c/i\u003e\u003c/span\u003e edges (with cycles and not necessarily connected), find the minimum number of edges that we need to retain such that connectivity between vertices is retained as given in the original graph.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eInput size: \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003eN\u003c/i\u003e, \u003ci\u003eE\u003c/i\u003e ≤ 2\u003ci\u003ee\u003c/i\u003e5\u003c/span\u003e \u003cbr /\u003e Time limit: \u003cspan class\u003d\"tex-span\"\u003e1\u003ci\u003es\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eFor example, for the following graph:\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\"graph\" border\u003d\"0\" src\u003d\"/predownloaded/50/f2/50f2b9f3553e771421d06a3cc3c96e67a058b1a2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eWe should retain the edges:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e0 -\u0026gt; 1\n1 -\u0026gt; 2\n1 -\u0026gt; 3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo we must use a minimum of 3 edges.\u003c/p\u003e\u003cp\u003eNote that:\u003cbr /\u003e \u003ccode\u003e0 -\u0026gt; 2\u003c/code\u003e is redundant as we can use the path \u003ccode\u003e0 -\u0026gt; 1 -\u0026gt; 2\u003c/code\u003e to get from \u003ccode\u003e0\u003c/code\u003e to \u003ccode\u003e2\u003c/code\u003e.\u003cbr /\u003e \u003ccode\u003e0 -\u0026gt; 3\u003c/code\u003e is redundant as we can use the path \u003ccode\u003e0 -\u0026gt; 1 -\u0026gt; 3\u003c/code\u003e to get from \u003ccode\u003e0\u003c/code\u003e to \u003ccode\u003e3\u003c/code\u003e. (Thanks \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/filippos\" title\u003d\"Expert filippos\"\u003efilippos\u003c/a\u003e for catching this mistake!)\u003cbr /\u003e\u003c/p\u003e\u003cp\u003eThis problem seems to be asking for the transitive reduction of a graph which can only be found in at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e based on what I found on Google and this clearly wouldn\u0027t pass the time limit. Furthermore, the list of AC solutions suggests that there is a linear time solution to this problem.\u003c/p\u003e\u003cp\u003eCould someone please advise me on how to solve this problem?\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUPD\u003c/strong\u003e Managed to solve this problem (thank you \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/yosei-san\" title\u003d\"International master yosei-san\"\u003eyosei-san\u003c/a\u003e for your incredible patience and explanation!).\u003c/p\u003e\u003cp\u003eI indeed had a wrong understanding of this problem and overly constrained it.\u003c/p\u003e\u003cp\u003eFor readers who are looking for the solution to this problem, I have posted my solution below:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eMy approach\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eInitially, we build a graph where the nodes represent towns and edges represent the direction of required trips between two towns.\u003c/p\u003e\u003cp\u003eNow we view this graph as an \u003cstrong\u003eundirected\u003c/strong\u003e graph. Clearly, the graph has at least 1 connected component.\u003c/p\u003e\u003cp\u003eThen, we separate the original graph into its connected components (i.e no edges exist between components). Some possible ways to do this are DFS and DSU. \u003c/p\u003e\u003cp\u003eNow that we have \u003cstrong\u003edisjoint\u003c/strong\u003e components of the graph, we \u0026quot;restore\u0026quot; the direction of the graph\u0027s edges (i.e. view it as a directed graph again).\u003c/p\u003e\u003cp\u003eFor each component, clearly, it either has cycle(s) or it is a DAG.\u003c/p\u003e\u003cp\u003eIf a component has a cycle among some of its nodes (and assuming it has K nodes), we can easily include all nodes into the cycle by doing 1 -\u0026gt; 2 -\u0026gt; ... -\u0026gt; K -\u0026gt; 1. So we need to add K edges, for each of these components, to the answer.\u003c/p\u003e\u003cp\u003eIf a component is a DAG (and assuming it has K nodes), the last node in the topological sort order of the component doesn\u0027t need to navigate anywhere else. So we only add K — 1 edges, for each of these components, to the answer.\u003c/p\u003e\u003cp\u003eHence the final answer is #Towns — #DAGs.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eMy accepted code\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nconst int maxn \u003d 2e5 + 5;\nint n, m, a, b, ans, par[maxn];\nvector\u0026lt;int\u0026gt; to[maxn];\nbool has[maxn], vis[maxn];\nunordered_set\u0026lt;int\u0026gt; path;\n\nint find(int u) {\n\treturn par[u] \u003d\u003d u ? u : par[u] \u003d find(par[u]);\n}\n\nvoid dfs(int u) {\n\tvis[u] \u003d 1;\n\tpath.insert(u);\n\tfor(int i \u003d 0; i \u0026lt; (int) to[u].size(); i++) {\n\t\tint v \u003d to[u][i];\n\t\tif(find(u) !\u003d find(v)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif(vis[v] \u0026amp;\u0026amp; path.find(v) !\u003d path.end()) {\n\t\t\thas[find(v)] \u003d 1;\n\t\t}\n\t\tif(!vis[v]) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\tpath.erase(u);\n}\n\nvoid addEdge(int u, int v) {\n\tto[u].push_back(v);\n\tpar[find(u)] \u003d find(v);\n}\n\nint main() {\n\tscanf(\u0026quot;%d %d\u0026quot;, \u0026amp;n, \u0026amp;m);\n\n\tans \u003d n;\n\n\tfor(int i \u003d 0; i \u0026lt; n; i++) {\n\t\tpar[i] \u003d i;\n\t}\n\tfor(int i \u003d 0; i \u0026lt; m; i++) {\n\t\tscanf(\u0026quot;%d %d\u0026quot;, \u0026amp;a, \u0026amp;b);\n\t\taddEdge(a, b);\n\t}\n\tfor(int i \u003d 0; i \u0026lt; n; i++) {\n\t\tint r \u003d find(i);\n\t\tif(has[r]) {\n\t\t\tvis[i] \u003d 1;\n\t\t}\n\t\tif(!vis[i]) {\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tfor(int i \u003d 0; i \u0026lt; n; i++) {\n\t\tint r \u003d find(i);\n\t\tif(vis[i] \u0026amp;\u0026amp; !has[r]) {\n\t\t\thas[r] \u003d 1;\n\t\t\tans--;\n\t\t}\n\t}\n\tprintf(\u0026quot;%d\\n\u0026quot;, ans);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["#graph","#algorithms","#connectivity","#dunjudgeme","#teleportation"]}}