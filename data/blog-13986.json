{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1411744397,"rating":186,"authorHandle":"marat.snowbear","modificationTimeSeconds":1411881701,"id":13986,"title":"\u003cp\u003eCodeforces Round #269 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/471/problem/A\" title\u003d\"Codeforces Round 269 (Div. 2)\"\u003e471A - MUH and Sticks\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eGiven six sticks and their lengths we need to decide whether we can make an elephant or a bear using those sticks. The only common requirement for both animals is that four leg-sticks should have same length. This means that the answer \u0026quot;Alien\u0026quot; should be given \u003cstrong\u003eonly\u003c/strong\u003e if we can\u0027t find four sticks for the legs. Otherwise we will be able to make some animal. The type of the animal will depend on the relation of the remaining sticks\u0027 lengths. If they are equal then it will an elephant, if they are different we will have a bear. \u003c/p\u003e\u003cp\u003eSo this algorithm should solve the problem: \u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eFind the number which appears at least four times in the input.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eIf no such number exist then the answer is \u0026quot;Alien\u0026quot;. \u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eOtherwise remove four entries of that number from the input. \u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eAfter removing that number you will have two numbers left, compare them and decide whether it\u0027s an elephant or a bear. \u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eOne shortcut for this problem might be to sort the input array, then if it\u0027s a bear or an elephant then 3rd and 4th elements in the sorted should be animal\u0027s legs. So you can assume that one of these numbers is the length of the leg and count how many times you see this number in the input. \u003c/p\u003e\u003cp\u003eAuthor\u0027s solution: \u003ca href\u003d\"/contest/471/submission/7977022\" title\u003d\"Submission 7977022 by marat.snowbear\"\u003e7977022\u003c/a\u003e\u003c/p\u003e\u003cp\u003eSince the numbers in the input are very small you can implement \u0027brute force\u0027 solution as well. By brute force solution in this case I mean that you can actually check all possible values for leg-length, head-length and body-length. If in total they give the same set as the input then you found a matching, all you need is to check whether it\u0027s a bear or an elephant. And it\u0027s an alien if you checked all possible combinations and found nothing matching to the input. Though in this case the brute force solution is not easier than another one. \u003c/p\u003e\u003cp\u003eChecking all possible lengths solution: \u003ca href\u003d\"/contest/471/submission/7975645\" title\u003d\"Submission 7975645 by marat.snowbear\"\u003e7975645\u003c/a\u003e \u003c/p\u003e\u003cp\u003eIt seems that there were two common mistakes people were making in this problem: \u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eNot taking into account that legs can be of the same length as body or head. So you can\u0027t just count the number of distinct numbers in the input to decide which type of animal is that. We assumed that people might make such a mistake, there was a relevant warning in the statement.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eTrying to sort the input and then check whether some elements in this array are equal to other elements and based on this comparison decide which type of animal is that. People were simply making mistakes when deciding which elements to compare. The correct way to implement this is:\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e \u003cpre\u003e\u003ccode\u003e // 0-indexing below, array is assumed to be sorted\n\n     if (l[0] \u003d\u003d l[3]) cout \u0026lt;\u0026lt; (l[4] \u003d\u003d l[5] ? \u0026quot;Elephant\u0026quot; : \u0026quot;Bear\u0026quot;);\nelse if (l[1] \u003d\u003d l[4]) cout \u0026lt;\u0026lt; \u0026quot;Bear\u0026quot;;\nelse if (l[2] \u003d\u003d l[5]) cout \u0026lt;\u0026lt; (l[0] \u003d\u003d l[1] ? \u0026quot;Elephant\u0026quot; : \u0026quot;Bear\u0026quot;);\nelse cout \u0026lt;\u0026lt; \u0026quot;Alien\u0026quot;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSolution: \u003ca href\u003d\"/contest/471/submission/7977214\" title\u003d\"Submission 7977214 by marat.snowbear\"\u003e7977214\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis solution seems to be shorter but there are many failed solutions like this because people were not paying enough attention to the details. So I would prefer implementing more straightforward approach. \u003c/p\u003e\u003cp\u003eHope you liked the pictures! \u003c/p\u003e \u003chr /\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/471/problem/B\" title\u003d\"Codeforces Round 269 (Div. 2)\"\u003e471B - MUH and Important Things\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eYou need to check whether exist three pairwise different permutations of the indices of the input which result in array being sorted. Generally you can count the number of total permutation which give non-decreasing array. This number might be very large and it might easily overflow even long integer type. And what is more important is that you don\u0027t actually need to count the exact number of such permutations. \u003c/p\u003e\u003cp\u003eLet\u0027s tackle this problem from another angle. Assume you already sorted the input array and you have the corresponding permutation of indices. This already gives you one array for the result, you only need to find two more. Let\u0027s look for any pair of equal numbers in the input array, if we swap them then we will get another valid permutation. And if we find one more pair of equal numbers then swapping them you can get third permutation and that will be the answer. You need to keep in mind here that one of the indices when swapping the second time might be the same as one of the numbers in the first swap, that\u0027s ok as soon as second index is different. So all you need to do is to find two pairs of indices which point to the equal elements.\u003c/p\u003e\u003cp\u003eThe entire algorithm is as follows: \u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eTransform the input array into array of pairs (tuples), first element of the pair will be the number given in the input array, the second element will be the index of that number.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eSort that array of pairs by the first element of the pairs. Then the second elements will give you one correct permutation. \u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eScan this array in order to find possible swaps. You just iterate over this array and check if the first element in the current pair equals to the first element of the previous pair. If it equals you remember the indices of these two pairs. You stop scanning the array as soon as you have two swaps. \u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThen you check how many swaps you have, if you have less than two swaps then there are no three distinct permutations. \u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eOtherwise you have two swaps which means that you have an answer. So you print the current permutation, then you execute the first swap (you just swap those two elements you remembered in the first swap), then you print the permutation array received after executing that swap. And you execute the second swap and print the permutation array third time. \u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eAuthor\u0027s solution: \u003ca href\u003d\"/contest/471/submission/7977528\" title\u003d\"Submission 7977528 by marat.snowbear\"\u003e7977528\u003c/a\u003e \u003c/p\u003e \u003chr /\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/471/problem/C\" title\u003d\"Codeforces Round 269 (Div. 2)\"\u003e471C - MUH and House of Cards\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eCard house. This problem required some maths, but just a little bit. So in order to start here let\u0027s first observe that the number of cards you need to use for a complete floor with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e rooms equals to: \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e \u003d \u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003erooms\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003eC\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eceiling\u003c/i\u003e\u003c/sub\u003e \u003d 2·\u003ci\u003eR\u003c/i\u003e + (\u003ci\u003eR\u003c/i\u003e - 1) \u003d 3·\u003ci\u003eR\u003c/i\u003e - 1\u003c/span\u003e\u003c/p\u003e\u003cp\u003eThen if you have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003c/span\u003e floors with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e rooms on the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th floor then the total number of cards would be: \u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/b0/24/b02469c7da3062fbc02c25a977f0a6bd074b1a0c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003ewhere \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e\u003c/span\u003e is the total number of the rooms in the card house. \u003c/p\u003e\u003cp\u003eThis already gives you an important property — if you divide \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e + \u003ci\u003eF\u003c/i\u003e\u003c/span\u003e on 3 then the remainder of this division should be 0. This means that if you have found some minimum value of floors somehow and you found maximum possible number of floors in the house, then within that interval only every third number will be a part of the solution, the rest of the numbers will give a non-zero remainder in the equation above. \u003c/p\u003e\u003cp\u003eNow let\u0027s think what is the highest house we can build using \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e cards. In order to build the highest possible house obviously you need to put as few cards on each floor as you can. But we have a restriction that every floor should have less rooms than the floor below. This gives us the following strategy to maximize the height of the house: we put 1 room on the top floor, then 2 rooms on the floor below, then 3 rooms on the next floor, etc. In total then the number of cards we will need equals to: \u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/78/8b/788b878455e8c347491600422977615706af92dc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThis is minimum number of cards we need in order to build a house with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003c/span\u003e floors. This gives us a way to calculate the maximum height of the house we can build using \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e cards, we just need to find maximum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003c/span\u003e which gives \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003emin\u003c/i\u003e\u003c/sub\u003e \u0026lt;  \u003d \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e. Mathematicians would probably solve the quadratic inequation, programmers have two options: \u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eCheck all possible \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003c/span\u003e until you hit that upper bound. Since \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003emin\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e grows quadratically with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e\u003c/span\u003e then you will need to check only up to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/b8/32b8fb2f012074729903ad7e933425031aaadf4a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e numbers. This gives \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8f/20/8f2069319f5fdf2601feb6ee936430dbd6460752.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time complexity and fits nicely in the given time limit.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThe second approach would be a binary search. Using binary search to find maximum number of the floors would give you \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e time complexity. This was the intended originally solution but it was decided to lower the constraints in order to allow sqrt solutions as well. \u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eNow that you know the maximum number of the floors in the house you might need to correct it a bit because of that remainder thing we discussed above, this might make your maximum height one or two floors lower. Looking again at the remainder discussion on top we can see that starting from here only every third number will be valid for an answer. Now you can either count them brutally (back to \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8f/20/8f2069319f5fdf2601feb6ee936430dbd6460752.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e solution) or you can simply calculate them using this formulae: \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eans\u003c/i\u003e \u003d (\u003ci\u003eF\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/sub\u003e + 3 - 1) / 3\u003c/span\u003e (integer division)\u003c/p\u003e\u003cp\u003eThat seems to be it, just don\u0027t forget to use longs all the time in this problem.\u003c/p\u003e\u003cp\u003eAuthor\u0027s \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e solution: \u003ca href\u003d\"/contest/471/submission/7977863\" title\u003d\"Submission 7977863 by marat.snowbear\"\u003e7977863\u003c/a\u003e \u003c/p\u003e\u003cp\u003eAuthors \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/8f/20/8f2069319f5fdf2601feb6ee936430dbd6460752.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e solution: \u003ca href\u003d\"/contest/471/submission/7977888\" title\u003d\"Submission 7977888 by marat.snowbear\"\u003e7977888\u003c/a\u003e \u003c/p\u003e \u003chr /\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/471/problem/D\" title\u003d\"Codeforces Round 269 (Div. 2)\"\u003e471D - MUH and Cube Walls\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eIn this problem we are given two arrays of integers and we need to find how many times we can see second array as a subarray in the first array if we can add some arbitrary constant value to every element of the second array. Let\u0027s call these arrays \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. As many people noticed or knew in advance this problem can be solved easily if we introduce difference arrays like that: \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eaDiff\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e (for every \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u003d  \u003d 0..\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e) \u003c/p\u003e\u003cp\u003eIf we do that with both input arrays we will receive two arrays both of which have one element less than original arrays. Then with these arrays the problem simply becomes the word search problem (though with possibly huge alphabet). This can be solved using your favourite string data structure or algorithm. Originally it was intended to look for linear solution but then we made time limit higher in case if somebody will decide to send \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e solution. I haven\u0027t seen such solutions (that is understandable) but some people tried to squeeze in a quadratic solution. \u003c/p\u003e\u003cp\u003eLinear solution can be made using Z-function or KMP algorithm. In order to add a logarithmic factor you can exercise with suffix array for example. I had suffix array solution as well, but it\u0027s a lot messier than linear solution. \u003c/p\u003e\u003cp\u003eThere is one corner case you need to consider — when Horace\u0027s wall contains only one tower, then it matches bears\u0027 wall in every tower so the answer is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Though for some algorithms it might not even be a corner case if you assume that empty string matches everywhere. Another error which several people did was to use actual string data structures to solve this problem, so they converted the differences to chars. This doesn\u0027t work since char can\u0027t hold the entire range an integer type can hold. \u003c/p\u003e\u003cp\u003eI didn\u0027t think that switching to difference arrays will be that obvious or well-known, so I didn\u0027t expect that this problem will be solved by that many people. \u003c/p\u003e\u003cp\u003eAuthor\u0027s Z-function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003ew\u003c/i\u003e)\u003c/span\u003e solution: \u003ca href\u003d\"/contest/471/submission/7978022\" title\u003d\"Submission 7978022 by marat.snowbear\"\u003e7978022\u003c/a\u003e \u003c/p\u003e\u003cp\u003eAuthor\u0027s suffix array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003en\u003c/i\u003e + \u003ci\u003ew\u003c/i\u003e)·\u003ci\u003elog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003ew\u003c/i\u003e))\u003c/span\u003e solution: \u003ca href\u003d\"/contest/471/submission/7978033\" title\u003d\"Submission 7978033 by marat.snowbear\"\u003e7978033\u003c/a\u003e \u003c/p\u003e \u003chr /\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/471/problem/E\" title\u003d\"Codeforces Round 269 (Div. 2)\"\u003e471E - MUH and Lots and Lots of Segments\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eGiven a set of horizontal/vertical lines you need to erase some parts of the lines or some lines completely in order to receive single connected drawing with no cycles. \u003c/p\u003e\u003cp\u003eFirst of all let\u0027s go through naive \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e solution which won\u0027t even remove cycles. In order to solve this problem you will need a DSU data structure, you put all your lines there and then for every pair of horizontal and vertical line you check if they intersect and if they do you join them in DSU. Also your DSU should hold the sum of the lengths of the joined lines. Initially it should be equal to the line lengths. Since there might be up to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e / 4\u003c/span\u003e intersections between lines we receive a quadratic solution. \u003c/p\u003e\u003cp\u003eNow let\u0027s get rid of cycles. Having the previous solution we can do it pretty easily, all we need is to change the way we were connecting the sets in DSU if some lines intersect. Previously we were simply asking DSU to join them even if they already belong to the same set. Now what we will do is when finding some pair of lines which intersects and is already joined in DSU instead of asking DSU to join them again we will ask DSU to decrement their length sum. In terms of the problem it is equivalent to erasing a unit piece of segment in the place where these two lines intersect and this will break the cycle. With this change we already have a correct solution which is too slow to pass the time limits. \u003c/p\u003e\u003cp\u003eNow we need to make our solution work faster. We still might have up to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e / 4\u003c/span\u003e intersections so obviously if we want to have a faster solution we can\u0027t afford to process intersections one by one, we need to process them in batches. All our lines are horizontal and vertical only, so let\u0027s do a sweep line, this should make our life easier. \u003c/p\u003e\u003cp\u003eLet\u0027s assume that we\u0027re sweeping the lines from the left to the right. Obviously then the code where the intersections will be handled is the code where we process the vertical line. Let\u0027s look at this case closer. We can assume that we\u0027re going to add some vertical line on with coordinates \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e1, \u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e2)\u003c/span\u003e, we can also assume that there are some horizontal lines which go through the given \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e coordinate, we track this set of lines while sweeping left to right. So we\u0027re going to add a vertical line and let\u0027s say that it has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e intersections with horizontal line. Previously we were handling each intersection separately, but you can see that if some horizontal lines already belong to the same set in DSU and they go next to each other then we don\u0027t need to handle them one by one anymore. They already belong to the set in DSU so there is no need to join them, we might only need to count the number of them between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e2\u003c/span\u003e coordinates, but that can be calculated in logarithmic time. So the trick to get rid of quadratic time complexity is to avoid storing horizontal lines one by one and store instead an interval (across y coordinate) of horizontal lines which belong to the same set in DSU. I will call these intervals \u003cstrong\u003echunks\u003c/strong\u003e. You will need to manipulate these chunks in logarithmic time and you will need to locate them by y coordinate so you need to store them in a treap or a STL map for example with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e coordinate serving as a key. \u003c/p\u003e\u003cp\u003eTo be clear let\u0027s see what data each of these chunks will hold: \u003c/p\u003e \u003cpre\u003e\u003ccode\u003estruct chunk{\n\tint top, bottom; // two coordinates which describe the interval covered by the chunk\n\tint id; // id of this chunk in DSU. Several chunks might have the same id here if they belong to the same set in DSU\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd we agreed that data structure which holds these chunks can manipulate them in logarithmic time. \u003c/p\u003e\u003cp\u003eLet\u0027s now get into details to see how exactly it works. While sweeping we will have one of three possible events (listed in the order we need to handle them): new horizontal line starting, vertical line added, horizontal line finishing. First and third operation only update our chunks data structure while the second operation uses it and actually joins the sets. Let\u0027s look into each of these operations: \u003c/p\u003e\u003cp\u003e\u003cstrong\u003ehorizontal line start\u003c/strong\u003e. We need to add one more chunk which will consist of a single point. The only additional operation we might need to do happens when this new line goes through some chunk whose interval already covers this point. In this case we need to split this covering chunk into two parts — top and bottom one. It\u0027s a constant number of updates/insertions/removals in our chunk data structure and we agreed that each of these operations can be done in logarithmic time so the time complexity of a single operation of this time is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e. It should be also mentioned here that during processing a single operation of this type we might add at most two new blocks. Since in total we have no more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e operations of this type them it means that in total we will have no more than \u003cspan class\u003d\"tex-span\"\u003e2·\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e blocks created. This is important for the further analysis. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003evertical line\u003c/strong\u003e. In this operation we need to find all chunks affected by this vertical line and join them. Each join of two chunks takes logarithmic time and we might have up to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e chunks present there, so we might need up \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e time to draw a single vertical line. This doesn\u0027t give us a good estimate. But we can see that we have only two ways to get new chunks — they are either added in the step 1 because it\u0027s a new line or one chunk is being split into two when we add a line in between. But we have an upper bound on total number of the chunks in our structure as shown above. Ans since we have such an upper bound then we can say that it doesn\u0027t matter how many chunks will join a single vertical line because in total all vertical lines will not join more than \u003cspan class\u003d\"tex-span\"\u003e2·\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e chunks. So we have an amortized time complexity analysis here, in total all vertical line operations will take \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e time. \u003c/p\u003e\u003cp\u003eThere are some other details we need to handle here. For example we need to avoid cycles correctly. This margin is too narrow to contain the proof but the formulae to correct the length sum is like this: \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e \u003d \u003ci\u003ey\u003c/i\u003e2 - \u003ci\u003ey\u003c/i\u003e1 - (\u003ci\u003eN\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eintersections\u003c/i\u003e\u003c/sub\u003e - 1) + \u003ci\u003eN\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003edistinctsets\u003c/i\u003e\u003c/sub\u003e - 1\u003c/span\u003e\u003c/p\u003e\u003cp\u003ewhere \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e — the number you need to add to the sum of the lengths in DSU \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eintersections\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — number of horizontal lines intersecting with the given vertical line, I used a separate segment tree to get this value in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003edistinctsets\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — number of distinct sets in DSU joined by this vertical line, you need to count them while joining \u003c/p\u003e\u003cp\u003eSo this gives you a way to correct the lengths sums. There is one more thing that needs to be mentioned here — it might happen that your vertical line will be contained by some chunk but will not intersect any horizontal lines in it. In this case you simply ignore this vertical line as if it doesn\u0027t overlap any chunk at all. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003ehorizontal line end\u003c/strong\u003e. Finally we came here and it seems to be simple. When some horizontal line ends we might need to update our chunks. There are three cases here: \u003c/p\u003e\u003cp\u003ea. This line is the only line in the chunks — we simply delete the chunk then. \u003c/p\u003e\u003cp\u003eb. This line lays on some end of the interval covered by the chunk — we update that end. In order to update it we need to know the next present horizontal line or the previous present horizontal line. I used the same segment tree mentioned above to handle these queries. \u003c/p\u003e\u003cp\u003ec. This line lays inside some chunk — we don\u0027t need to update that chunk at all. \u003c/p\u003e\u003cp\u003eAnd that\u0027s it! In total it gives \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e solution. \u003c/p\u003e\u003cp\u003eAuthor\u0027s solution: \u003ca href\u003d\"/contest/471/submission/7978166\" title\u003d\"Submission 7978166 by marat.snowbear\"\u003e7978166\u003c/a\u003e (that chunk data structure is called \u0027linked_list\u0027 in the code because originally I thought it would be a linked list with some way to manipulate it quickly and later I removed all the list functionality). \u003c/p\u003e \u003chr /\u003e\u003cp\u003eThis editorial was written very late in the night, I\u0027m pretty sure there are tons of typos here, I will proof read it tomorrow, but please don\u0027t hesitate to report typos and some minor error to be fixed in private messages. \u003c/p\u003e\u003c/div\u003e","tags":["cf-269","editorial"]}}