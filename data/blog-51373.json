{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1491069343,"rating":25,"authorHandle":"I_love_Hoang_Yen","modificationTimeSeconds":1491130975,"id":51373,"title":"\u003cp\u003eThi thử VNOI lần 1 (Luật ACM ICPC) — Lời giải\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eLời giải các bài VNOI lần 1 ---\u003c/p\u003e\u003cp\u003eTất cả các code ở \u003ca href\u003d\"https://github.com/ngthanhtrung23/VNOI_contests/tree/master/VNOI_1\"\u003eGithub\u003c/a\u003e.\u003c/p\u003e\u003ch1\u003e\u003ca href\u003d\"/group/FLVn1Sc504/contest/212925/problem/A\" title\u003d\"[Test] Thi thử VNOI lần 1 (Luật ACM ICPC)\"\u003e212925A - THSEQ - Dãy số\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eĐể làm đc bài này các bạn cần biết QHĐ. Nếu bạn chưa biết có thể lên đọc \u003ca href\u003d\"http://vnoi.info/wiki/Home\"\u003eVNOI wiki\u003c/a\u003e.\u003c/p\u003e\u003ch2\u003eDP N^3:\u003c/h2\u003e\u003cp\u003eĐặt \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e \u003d độ dài dãy B lớn nhất, nếu 2 phần tử cuối là \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e và \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eĐể tính \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e, ta xét các \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u0026lt; \u003ci\u003ei\u003c/i\u003e\u003c/span\u003e mà \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ej\u003c/i\u003e) \u003d \u003ci\u003eA\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e) + \u003ci\u003eA\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e, rồi lấy \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e, \u003ci\u003ei\u003c/i\u003e) + 1\u003c/span\u003e cập nhật cho \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eGiải thích: từ dãy B kết thúc ở k và i, ta có thể nới rộng dãy B thêm phần tử j.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor(int i \u003d 0; i \u0026lt; n; i++)\n    for(int j \u003d i+1; j \u0026lt; n; j++) {\n        f[i][j] \u003d 2;\n        for(int k \u003d 0; k \u0026lt; i; k++) {\n            if (a[k] + a[i] \u003d\u003d a[j])\n                f[i][j] \u003d max(f[i][j], f[k][i] + 1);\n        }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eDP N^2\u003c/h2\u003e\u003cp\u003eNhận xét:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eNếu cố định i\u003c/li\u003e   \u003cli\u003eNếu \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e1 \u0026lt; \u003ci\u003ek\u003c/i\u003e2\u003c/span\u003e và \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e1) \u003d \u003ci\u003eA\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e2)\u003c/span\u003e thì \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e1, \u003ci\u003ei\u003c/i\u003e) ≤ \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e2, \u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eChứng minh:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eXét \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e1 \u0026lt; \u003ci\u003ek\u003c/i\u003e2\u003c/span\u003e và \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e1) \u003d \u003ci\u003eA\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e2)\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eGiả sử \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e1, \u003ci\u003ei\u003c/i\u003e) \u0026gt; \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e2, \u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e, nghĩa là độ dài lớn nhất của dãy B1 kết thúc ở \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e1)\u003c/span\u003e và \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e lớn hơn độ dài lớn nhất của dãy B2 kết thúc ở \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e2)\u003c/span\u003e và \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e. Ta thay \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e1)\u003c/span\u003e trong dãy B1 thành \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e2)\u003c/span\u003e. Rõ ràng, dãy mới vẫn đảm bảo tính chất, có độ dài bằng dãy B1, và kết thúc ở \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e2)\u003c/span\u003e và \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eTừ nhận xét, khi tính \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e, ta chỉ cần tìm chỉ số k lớn nhất, nhỏ hơn i mà \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003ek\u003c/i\u003e) \u003d \u003ci\u003eA\u003c/i\u003e(\u003ci\u003ej\u003c/i\u003e) - \u003ci\u003eA\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e. Từ đó chỉ cần dùng mảng đánh dấu là được.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// happyboy99x\nvoid solve() {\n    memset(pos, -1, sizeof pos); // pos[i] \u003d map(value --\u0026gt; index lớn nhất)\n\tint res \u003d 0;\n\tfor(int i \u003d 0; i \u0026lt; n; ++i) {\n\t\tfor(int j \u003d i + 1; j \u0026lt; n; ++j) {\n            int p \u003d pos[a[j] - a[i] + ZERO];  // a[j] - a[i] co\u0027 the \u0026lt; 0\n\t\t\tif(p !\u003d -1) f[i][j] \u003d f[p][i] + 1;\n\t\t\telse f[i][j] \u003d 2;\n\t\t\tres \u003d max(res, f[i][j]);\n\t\t}\n\t\tpos[a[i] + (MAX \u0026lt;\u0026lt; 1)] \u003d i;\n\t}\n\tcout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch1\u003e\u003ca href\u003d\"/group/FLVn1Sc504/contest/212925/problem/B\" title\u003d\"[Test] Thi thử VNOI lần 1 (Luật ACM ICPC)\"\u003e212925B - THTIME - Hành trình vượt thời gian\u003c/a\u003e\u003c/h1\u003e\u003ch2\u003eDijkstra:\u003c/h2\u003e\u003cp\u003eNếu chưa biết Dijkstra bạn có thể đọc trong \u003ca href\u003d\"http://vnoi.info/wiki/algo/basic/Tai-Lieu-Thuat-Toan\"\u003esách thầy Hoàng\u003c/a\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003eXét đồ thị với các đỉnh là \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003etime\u003c/i\u003e)\u003c/span\u003e, với \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003eM\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e1 ≤ \u003ci\u003ej\u003c/i\u003e ≤ \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e và \u003cspan class\u003d\"tex-span\"\u003e0 ≤ \u003ci\u003etime\u003c/i\u003e ≤ 1\u003c/span\u003e, thể hiện trạng thái đang ở ô \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e và time thể hiện đang ở quá khứ hay hiện tại.\u003c/li\u003e   \u003cli\u003eGiữa 2 đỉnh có thể có cạnh bằng 0 hoặc 1\u003c/li\u003e   \u003cli\u003eTìm đường đi ngắn nhất --\u0026gt; Dijkstra\u003c/li\u003e \u003c/ul\u003e\u003ch2\u003eLoang theo lớp\u003c/h2\u003e \u003cul\u003e   \u003cli\u003eD queue\u003c/li\u003e   \u003cli\u003equeue 0: các đỉnh có khoảng cách bằng 0.\u003c/li\u003e   \u003cli\u003equeue 1: các đỉnh có khoảng cách bằng 1.\u003c/li\u003e   \u003cli\u003equeue 2: các đỉnh có khoảng cách bằng 2. ...\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003eq[0] \u003d {start}\nfor (int time \u003d 0; ; ++time) {\n    for(state in q[time]) {\n        for(u in neighbor(state), cost(state, u) \u003d\u003d 0) {\n            q[time].push(state);\n        }\n    }\n\n    for(state in q[time]) {\n        for(u in neighbor(state), cost(state, u) \u003d\u003d 1) {\n            q[time+1].push(state);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eBFS 0-1\u003c/h2\u003e \u003cul\u003e   \u003cli\u003eBFS dùng deque, cạnh \u003d\u003d 0 --\u0026gt; đẩy vào đầu, cạnh \u003d\u003d 1 --\u0026gt; đẩy vào cuối\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003eq \u003d empty deque\nwhile (!q.empty()) {\n    state u \u003d q.front(); q.pop();\n    for(state v in neighbour(u))\n        if (!visited[v]) {\n            if (cost(u, v) \u003d\u003d 0) q.push_front(v);\n            else q.push_back(v);\n        }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch1\u003e\u003ca href\u003d\"/group/FLVn1Sc504/contest/212925/problem/C\" title\u003d\"[Test] Thi thử VNOI lần 1 (Luật ACM ICPC)\"\u003e212925C - THMST - Đồ thị nhỏ nhất của cây khung\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eNếu chưa biết tìm cây khung nhỏ nhất, bạn có thể đọc trong \u003ca href\u003d\"http://vnoi.info/wiki/algo/basic/Tai-Lieu-Thuat-Toan\"\u003esách thầy Hoàng\u003c/a\u003e.\u003c/p\u003e\u003ch2\u003eKruskal\u003c/h2\u003e\u003cp\u003eLặp \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - 1\u003c/span\u003e bước, tại mỗi bước:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eTìm 1 cạnh \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e với trọng số nhỏ nhất nối 2 thành phần liên thông khác nhau\u003c/li\u003e   \u003cli\u003eThêm cạnh \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e vào cây khung.\u003c/li\u003e \u003c/ul\u003e\u003ch2\u003eThuật Toán\u003c/h2\u003e\u003cp\u003eGiờ giả sử ta đã tìm được đồ thị đầy đủ theo yêu cầu. --\u0026gt; ở mỗi bước, chỉ có 1 lựa chọn duy nhất cho cạnh \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003eLần lượt xét các cạnh của cây T theo thứ tự tăng dần.\u003c/li\u003e   \u003cli\u003eKhi xét đến cạnh \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e, vì T là cây, nên rõ ràng \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e và \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e thuộc 2 thành phần liên thông khác nhau. Các cạnh của đồ thị được chia thành 3 loại:   \u003cul\u003e     \u003cli\u003eNối giữa cùng thành phần liên thông\u003c/li\u003e     \u003cli\u003eNối giữa thành phần liên thông chứa u và thành phần liên thông chứa v.\u003c/li\u003e     \u003cli\u003eNối giữa 2 thành phần liên thông khác nhau, mà ko phải thuộc loại 2 :v\u003c/li\u003e   \u003c/ul\u003e\u003c/li\u003e   \u003cli\u003eỞ bước xét cạnh \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e, ta xác định được trọng số của các cạnh loại 2 (bằng \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eweight\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e) + 1\u003c/span\u003e) --\u0026gt; các cạnh loại 1 đc xác định trọng số ở bước trước đó, và các cạnh loại 3 được xác định trọng số ở bước sau đó.\u003c/li\u003e \u003c/ul\u003e\u003ch1\u003e\u003ca href\u003d\"/group/FLVn1Sc504/contest/212925/problem/D\" title\u003d\"[Test] Thi thử VNOI lần 1 (Luật ACM ICPC)\"\u003e212925D - THSTONE - Chuyển đá\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eBài này sử dụng \u003ca href\u003d\"http://vnoi.info/wiki/translate/topcoder/Greedy-is-Good\"\u003eTham lam\u003c/a\u003e.\u003c/p\u003e\u003ch2\u003eÝ tưởng\u003c/h2\u003e \u003cul\u003e   \u003cli\u003eĐặt \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e \u003d số sỏi chuyển từ hộp i sang hộp i+1. Nếu \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u0026lt; 0\u003c/span\u003e thì nghĩa là ta chuyển từ hộp i+1 về hộp i.\u003c/li\u003e   \u003cli\u003eTính \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e \u003d số sỏi cuối cùng trong mỗi hộp sau toàn bộ quá trình đổi. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e \u003d \u003ci\u003esum\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]) / \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Nếu \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e không phải là số nguyên thì vô nghiệm.\u003c/li\u003e   \u003cli\u003e\u003cp\u003eRõ ràng: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e[1] \u003d \u003ci\u003ea\u003c/i\u003e[1] - \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e[2] \u003d \u003ci\u003ea\u003c/i\u003e[2] + \u003ci\u003el\u003c/i\u003e[1] - \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. ... --\u0026gt; tính được tất cả các \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eKết quả \u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e(\u003ci\u003eabs\u003c/i\u003e(\u003ci\u003el\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]))\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eChứng minh:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eVới 1 cặp \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e và \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e, ta cần chuyển \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e từ hộp \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e sang hộp \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e. Ta sẽ bắt đầu quá trình chuyển này từ thời điểm \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e - \u003ci\u003el\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eMấu chốt của vấn đề là có thời điểm nào ta không có sỏi để chuyển không.\u003c/li\u003e   \u003cli\u003eTa chứng minh rằng sau mỗi bước luôn chuyển được. Xét bước đầu tiên: Ta chuyển những vị trí có \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] \u003d \u003ci\u003emax\u003c/i\u003e\u003c/span\u003e. Những vị trí này tạo thành các dải liên tiếp, với mỗi dải ta cần đẩy \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/span\u003e viên sỏi sang trái hoặc sang phải. Như vậy ở bước này ta luôn chuyển được ở tất cả các vị trí. Sau khi chuyển xong, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/span\u003e giảm đi 1 đơn vị. Cứ lặp lại như vậy đến khi \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/span\u003e về 0.\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e\u003ccode\u003eFOR(i,1,n) {\n    l[i] \u003d a[i] + l[i-1] - sum / n;\n}\n\nint res \u003d 0;\nFOR(i,1,n) res \u003d max(res, llabs(l[i]));\ncout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl;\n\u003c/code\u003e\u003c/pre\u003e\u003ch1\u003e\u003ca href\u003d\"/group/FLVn1Sc504/contest/212925/problem/E\" title\u003d\"[Test] Thi thử VNOI lần 1 (Luật ACM ICPC)\"\u003e212925E - Dãy ngoặc\u003c/a\u003e\u003c/h1\u003e\u003ch2\u003eDãy ngoặc đúng\u003c/h2\u003e\u003cp\u003e1 dãy ngoặc là dãy ngoặc đúng nếu:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eĐi từ trái sang phải, tại mọi thời điểm, số ngoặc mở lớn hơn hoặc bằng số ngoặc đóng.\u003c/li\u003e   \u003cli\u003eĐến cuối, số ngoặc mở bằng số ngoặc đóng.\u003c/li\u003e \u003c/ul\u003e\u003ch2\u003eLời giải\u003c/h2\u003e \u003cul\u003e   \u003cli\u003eĐi từ trái sang phải, tại mỗi bước, nếu gặp \u003ccode\u003e?\u003c/code\u003e, thử thay bằng đóng ngoặc. Nếu tại 1 thời điểm mà đóng ngoặc nhiều hơn mở ngoặc --\u0026gt; cần chọn 1 đóng ngoặc trước đó để đổi thành mở ngoặc.\u003c/li\u003e   \u003cli\u003eĐến cuối, nếu số đóng ngoặc bằng số mở ngoặc --\u0026gt; tìm được dãy ngoặc thỏa mãn.\u003c/li\u003e \u003c/ul\u003e\u003ch2\u003eChứng minh:\u003c/h2\u003e \u003cul\u003e   \u003cli\u003eNếu code ra vô nghiệm --\u0026gt; test đó vô nghiệm?\u003c/li\u003e   \u003cli\u003eCode luôn sinh ra dãy ngoặc đúng (do luôn ưu tiên thêm đóng ngoặc, và nếu không thỏa mãn điều kiện 1 thì đã đổi 1 dấu ? trước đó thành mở ngoặc).\u003c/li\u003e   \u003cli\u003eChi phí nhỏ nhất. Rõ ràng số ngoặc đổi thành mở và đóng là cố định?\u003c/li\u003e \u003c/ul\u003e\u003ch1\u003e\u003ca href\u003d\"/group/FLVn1Sc504/contest/212925/problem/F\" title\u003d\"[Test] Thi thử VNOI lần 1 (Luật ACM ICPC)\"\u003e212925F - Vòng tròn nhị phân\u003c/a\u003e\u003c/h1\u003e\u003cp\u003eBài này là 1 bài tìm 1 nghiệm với \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e cho trước. Với bài kiểu này ta có 1 vài hướng thông thường:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eDuyệt để tìm pattern.\u003c/li\u003e   \u003cli\u003eXây dựng nghiệm với \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e từ các nghiệm với các \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e nhỏ hơn.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eỞ bài này ta xây dựng nghiệm \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e từ nghiệm của \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - 2\u003c/span\u003e.\u003c/p\u003e \u003cul\u003e   \u003cli\u003eVới \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e ≤ 3\u003c/span\u003e, nghiệm đã được cho trong đề bài.\u003c/li\u003e   \u003cli\u003eVới \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e ≥ 4\u003c/span\u003e, đầu tiên ta sinh kết quả cho \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - 2\u003c/span\u003e, sau đó ta ghép 4 bộ nghiệm lại, đồng thời thêm các cặp 2 ký tự cuối vào sao cho phù hợp. Chú ý rằng ta có thể làm như vậy được do tính chất vòng tròn của bài toán.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eKhi ghép, ta cần đảm bảo:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eKhông có 2 xâu nào trùng nhau. Vì ta lặp lại kết quả của \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - 2\u003c/span\u003e 4 lần, nên với xâu, trong 4 lần lặp, ta phải thêm các cặp 2 bit khác nhau.\u003c/li\u003e   \u003cli\u003eĐảm bảo 2 xâu liên tiếp khác nhau \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e / 2\u003c/span\u003e bit: với 2 xâu liên tiếp, nó đã khác nhau \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eN\u003c/i\u003e - 2) / 2\u003c/span\u003e bit rồi, nên khi thêm 2 bit mới, 1 trong 2 bit của 2 xâu liên tiếp phải khác nhau.\u003c/li\u003e \u003c/ul\u003e\u003ch1\u003e\u003ca href\u003d\"/group/FLVn1Sc504/contest/212925/problem/G\" title\u003d\"[Test] Thi thử VNOI lần 1 (Luật ACM ICPC)\"\u003e212925G - Đếm nghịch thế\u003c/a\u003e\u003c/h1\u003e\u003ch2\u003eĐếm nghịch thế\u003c/h2\u003e\u003cp\u003eGiả sử ta cần đếm số cặp nghịch thế của 1 dãy cho trước (không có thao tác thay đổi các số), thì ta có thể dễ dàng đếm bằng BIT:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (i \u003d 0; i \u0026lt; n; ++i) {\n    bit.count(0, a[i] - 1);  // đếm số số trong khoảng [0, a[i])\n    bit.update(a[i], + 1);   // thêm 1 số có giá trị a[i]\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eTruy vấn thay đổi\u003c/h2\u003e\u003cp\u003eBản chất của bài toán nghịch thế như trên là có 2 chiều: index và giá trị.\u003c/p\u003e\u003cp\u003eỞ cách đếm nghịch thế (offline) trên, ta xử lý lần lượt theo chiều index, nên có thể sử dụng CTDL 1D với chiều giá trị.\u003c/p\u003e\u003cp\u003eKhi thêm các truy vấn, thực chất bài toán trở thành 3D: thời gian, index và giá trị. Ta buộc phải xử lý theo trục thời gian, nên bài toán chỉ có thể đưa về 2D. Do đó cần sử dụng các CTDL 2D để giải quyết.\u003c/p\u003e\u003ch2\u003eCách 1: chia block\u003c/h2\u003e\u003cp\u003eChia dãy số thành \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e block, mỗi block có \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e phần tử. (Nói cách khác là \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e \u003d \u003ci\u003eN\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eNói theo cách hiểu về chiều của bài toán, thì ta chia block để xử lý chiều index. Sau đó ta dùng BIT để quản lý chiều giá trị.\u003c/p\u003e\u003cp\u003eNghĩa là:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eChia dãy thành \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e block, mỗi block gồm \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eK\u003c/i\u003e\u003c/span\u003e phần tử\u003c/li\u003e   \u003cli\u003eỞ mỗi block, dùng 1 BIT để quản lý các số.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eBan đầu, ta khởi tạo số nghịch thế của dãy, và với mỗi block, ta thêm các số của block đó vào trong BIT:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (block \u003d 0; block \u0026lt; K; ++block) {\n    int from \u003d block * K, to \u003d from + K - 1;  // chú ý khi code thật phải cẩn thận `to` nhảy ra ngoài mảng (\u0026gt; N)\n    for (int i \u003d from; i \u0026lt;\u003d to; ++i) {\n        bit[block].update(a[i]);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eMỗi khi sửa 1 số \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003eX\u003c/i\u003e) \u003d \u003ci\u003eY\u003c/i\u003e\u003c/span\u003e, xét các cặp nghịch thế bị thay đổi (thêm vào hoặc mất đi)\u003c/p\u003e \u003cul\u003e   \u003cli\u003eGọi \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003c/span\u003e là giá trị cũ của \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e(\u003ci\u003eX\u003c/i\u003e)\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eBlock trước \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eblock\u003c/i\u003e(\u003ci\u003eX\u003c/i\u003e)\u003c/span\u003e, bỏ đi các số lớn hơn \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003c/span\u003e, thêm vào các số lớn hơn \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eBlock sau \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eblock\u003c/i\u003e(\u003ci\u003eX\u003c/i\u003e)\u003c/span\u003e, bỏ đi các số nhỏ hơn \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eV\u003c/i\u003e\u003c/span\u003e, thêm vào các số nhỏ hơn \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eY\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eVới \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eblock\u003c/i\u003e(\u003ci\u003eX\u003c/i\u003e)\u003c/span\u003e, ta làm tương tự 2 trường hợp trên.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eĐến đây, các thao tác đều đưa về 1D.\u003c/p\u003e\u003ch2\u003eCách 2: Cây trong cây\u003c/h2\u003e\u003cp\u003eBIT1D:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint get1D(int u) { // lấy đoạn 1 - u\n    int res \u003d 0;\n    for(; u \u0026gt; 0; u -\u003d u \u0026amp; -u) {\n        res +\u003d node[u];\n    }\n    return res;\n}\n\nvoid update1D(int u, int val) { // cập nhật vị trí u\n    for(; u \u0026lt; n; u +\u003d u \u0026amp; -u) {\n        node[u] +\u003d val;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHình dung: mỗi nút của BIT là 1 cây BIT. Từ đó ta có thể code lại các thao tác update và get như sau:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint get2D(int u, int v) {  // lấy tổng hình chữ nhật (1, 1) - (u, v)\n    int res \u003d 0;\n    for (; u \u0026gt; 0; u -\u003d u \u0026amp; -u) {  // đang xét đến cây u\n        for(int x \u003d v; x \u0026gt; 0; x -\u003d x \u0026amp; -x) { // xét trên cây node[u]\n            res +\u003d node[u][v];\n        }\n    }\n    return res;\n}\nvoid update2D(int u, int v, int val) { // cập nhật điểm (u, v)\n    for(; u \u0026lt; n; u +\u003d u \u0026amp; -u) {  // đang xét cây u\n        for(int x \u003d v; x \u0026lt; n; x +\u003d x \u0026amp; -x) {\n            node[u][v] +\u003d val;\n        }\n    }\n}\n\n// node[u][v] là 1 cấu trúc dữ liệu kiểu mảng 2D, ví dụ có thể dùng map \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCài đặt như trên bị lợn, do mảng node quá lớn (hoặc nếu dùng map thì bị thêm log). Ngoài ra số nút truy cập vào cũng nhiều hơn cần thiết.\u003c/p\u003e\u003cp\u003eĐể giảm độ phức tạp, ta chỉ xét những nút cần động vào. Để làm được việc này, ta cần biết trước tất cả các truy vấn mà ta sẽ phải thực hiện, sau đó chỉ thêm các nút cần thiết vào cây:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid fakeUpdate(int u, int v) {\n    for(int x \u003d u; x \u0026lt;\u003d n; x +\u003d x \u0026amp; -x)\n        nodes[x].push_back(v);\n}\n\nvoid fakeGet(int u, int v) {\n    for(int x \u003d u; x \u0026gt; 0; x -\u003d x \u0026amp; -x)\n        nodes[x].push_back(v);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e2 hàm fakeUpdate và fakeGet tạo ra tất cả các nút cần thiết.\u003c/p\u003e\u003cp\u003eSau đấy, để thực hiện truy vấn thì ta làm kiểu này:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evoid update(int u, int v) {\n    for(int x \u003d u; x \u0026lt;\u003d n; x +\u003d x \u0026amp; -x)\n        for(int y \u003d lower_bound(nodes[x].begin(), nodes[x].end(), v) - nodes[x].begin() + 1; y \u0026lt;\u003d nodes[x].size(); y +\u003d y \u0026amp; -y)\n            f[x][y]++;\n}\n\nint get(int u, int v) {\n    int res \u003d 0;\n    for(int x \u003d u; x \u0026gt; 0; x -\u003d x \u0026amp; -x)\n        for(int y \u003d upper_bound(nodes[x].begin(), nodes[x].end(), v) - nodes[x].begin(); y \u0026gt; 0; y -\u003d y \u0026amp; -y)\n            res +\u003d f[x][y];\n    return res;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eChú ý là sau khi tìm được tất cả các nút cần truy vấn, ta nén lại (đánh số từ 1 đến số nút trên mỗi cây BIT), và từ đó thực hiện truy vấn nhanh chóng.\u003c/p\u003e\u003c/div\u003e","tags":[]}}