{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1432928216,"rating":14,"authorHandle":"akulsareen","modificationTimeSeconds":1432931343,"id":18215,"title":"\u003cp\u003eASC 16 editorial (work in progress)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThis is not supposed to be a complete editorial or an official one. I am just putting this blog up so that as and when we solve the questions we have a common place to share our solutions. I am currently writing my solutions for the handful of questions I managed to solve. If any of you have a better approach or a solution for some other problem do share it .\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem A : Cactus\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eLets say we have some tree T. Let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eC\u003c/i\u003e(\u003ci\u003eT\u003c/i\u003e)\u003c/span\u003e be its cactusability. Now if we add an edge between any 2 non-adjacent vertices u and v in T then we make exactly one cycle. If we remove the vertices that lie on this cycle(since every vertex can lie on at most one cycle) then we are left with a forest of smaller trees, say, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e...\u003ci\u003eT\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Then it is clear that:\u003c/p\u003e\u003cp\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/16/c3/16c3c6657b42a12fc71752d6843a602951bfdd83.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e i.e. either we don\u0027t add any edge or for every edge that we add we also add the product of cactusabilities of the forest that cycle creates to our answer.\u003c/p\u003e\u003cp\u003eNow, we need a systematic way to carry out these operations. I chose an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e DP during the contest.\u003c/p\u003e\u003cp\u003eLet dp1[i] be the cactusability of the subtree rooted at i. Before we start calculating dp1[i] we first calculate dp1 for all its children. Now, we process the children of i one by one. Lets say we have processed the first j children. Then let dp2[i][j] denote the cactusability of the subtree consisting of i and the subtrees rooted at its first j children. Now we need to extend our solution to dp2[i][j+1]. There are now 3 cases:\u003c/p\u003e\u003cp\u003e1) I do not add any more edges, so \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e2[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e + 1] \u003d \u003ci\u003edp\u003c/i\u003e2[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e + 1] + (\u003ci\u003edp\u003c/i\u003e2[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e] × \u003ci\u003edp\u003c/i\u003e1[\u003ci\u003echild\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/sub\u003e])\u003c/span\u003e\u003c/p\u003e\u003cp\u003e2) I add an edge between i and some vertex in the subtree rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003echild\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e. Now if I remove this cycle the the forest that is formed consists of the subtrees rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003echild\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, ... , \u003ci\u003echild\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, and certain other subtrees inside the subtree rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003echild\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e. All these cases can be handled by doing a suitable dfs from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003echild\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e3) I add an edge between some vertex that lies in one of the subtrees rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003echild\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, ... , \u003ci\u003echild\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and a vertex that lies in the subtree rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003echild\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e. If I remove the cycle formed I get a forest which comprises of all but one of \u003cspan class\u003d\"tex-span\"\u003e{\u003ci\u003echild\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, ... , \u003ci\u003echild\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e}\u003c/span\u003e and certain subtrees of the subtree rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003echild\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThis question also required a BigInteger library since the answers could be huge.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem B: Darts\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eI will only describe this briefly as this was a pretty straightforward question.\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e be the set of valid moves to 0 from i with j moves left. For every (i,j) just try out every possible throw to transition to some previous state and update answer accordingly.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eProblem C: Domino in Casino\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eNotice that whenever you put a domino it always covers one cell whose sum of indices is divisible by 2 and one cell whose sum of indices is not. So split the cells into two sets, one containing cells with sum of indices divisible by two and one containing cells whose sum of indices is not divisible by two.\u003c/p\u003e\u003cp\u003eAdd an edge from source to dummy vertex of capacity k and cost 0.\u003c/p\u003e\u003cp\u003eAdd edges from dummy vertex to all nodes in set 1 of capacity 1 and cost 0.\u003c/p\u003e\u003cp\u003eNow, if it is possible to put a domino on cell x and cell y, and cell x lies in set 1, then add an edge between x and y with capacity 1 and cost \u003cspan class\u003d\"tex-span\"\u003e - \u003ci\u003eval\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) × \u003ci\u003eval\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eAdd edges from all nodes in set 2 to sink of capacity 1 and cost 0.\u003c/p\u003e\u003cp\u003eNow find minimum cost flow. This way you are actually selecting at most k pairs, with each cell being used at most once, such that the sum of the negative values of the pairs taken is minimised i.e. maximised.\u003c/p\u003e\u003cp\u003eOutput negative of the minimum cost.\u003c/p\u003e\u003c/div\u003e","tags":["andrew stankevich","editorial","whoreadstaganyway"]}}