{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1481102745,"rating":0,"authorHandle":"elena","modificationTimeSeconds":1481151009,"id":48884,"title":"\u003cp\u003eЗадачи на использование циклов — часть I\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eСнова несколько простых задач с Timus — теперь учимся применять циклы. \u003cbr /\u003e\u003c/p\u003e\u003cp\u003eЗадача 1991 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1991\"\u003eБитва у болота\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЗадача 1607 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1607\"\u003eТакси\u003c/a\u003e (можно и без циклов)\u003c/p\u003e\u003cp\u003eЗадача 1131 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1131\"\u003eКопирование\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЗадача 1502 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1502\"\u003eТочки домино\u003c/a\u003e\u003c/p\u003e\u003cp\u003eЗадача 1139 \u003ca href\u003d\"http://acm.timus.ru/problem.aspx?space\u003d1\u0026amp;num\u003d1139\"\u003eГородские кварталы\u003c/a\u003e\u003c/p\u003e\u003cp\u003eНекоторые небесполезные советы.\u003c/p\u003e\u003cp\u003eЕсли пытаться \u0026quot;воспроизвести процесс копирования\u0026quot; в задаче 1131, можно легко получить вердикт \u003cem\u003eTime Limit on test ...\u003c/em\u003e, свидетельствующий о том, что Ваш алгоритм работает чересчур долго. \u003c/p\u003e\u003cp\u003eПри решении задачи 1502 полезно вывести некоторые формулы и воспользоваться ими (конечно, велик соблазн заставить компьютер считать всё, но об эффективности программы забывать не стоит).\u003c/p\u003e\u003cp\u003eДля двух целых чисел \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e можно определить их наибольший общий делитель. Его обозначают либо \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eGCD\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e (от \u003cem\u003eGreat Common Divisor\u003c/em\u003e), либо \u003cem\u003eНОД(a,b)\u003c/em\u003e (сокращая русское название до аббревиатуры). Для вычисления \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eGCD\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e обычно используют алгоритм Евклида. Если вдруг Вы забыли его, напомним, что состоит он в следующем. \u003cbr /\u003e 1. Если \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, ответом является любое из этих чисел. Если одно из чисел равно нулю, ответом является другое число. \u003cbr /\u003e 2. Если же это не так, выберем большее из этих чисел (пусть это будет \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, иначе — поменяем числа местами). Сделаем замену: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/18/1a/181a0fa9a73e079340b421e100ce716ec77ffaeb.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e (где \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ef/a8/efa8f0891cb15bc0e4b503f090f6c8d8b1d9d6b4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e — взятие остатка от деления). После этого вернёмся к п.1.\u003c/p\u003e\u003cp\u003eКонечно, можно найти наибольший общий делитель и другими способами, но этот, пожалуй, наиболее эффективен. \u003c/p\u003e\u003cp\u003eПодумайте, во-первых, как доказать, что это корректный способ вычисления наибольшего общего делителя, и, во-вторых, в какой задаче это может Вам понадобиться. \u003c/p\u003e\u003cp\u003eНесколько слов о синтаксисе циклов. \u003c/p\u003e\u003cp\u003eПростой \u003cstrong\u003eцикл с предусловием\u003c/strong\u003e выглядит так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003ewhile (\u0026lt;условие\u0026gt;) {\n   \u0026lt;операторы\u0026gt;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eУсловие — это логическое выражение, т.е. оно может принимать значение \u003ccode\u003etrue\u003c/code\u003e или \u003ccode\u003efalse\u003c/code\u003e. Обратите внимание, что условие обязательно заключать в круглые скобки, а каждый оператор должен завершаться точкой с запятой. Если оператор один, то фигурные скобки можно не писать (это относится и к другим циклам, которые описаны ниже).\u003c/p\u003e\u003cp\u003eКак работает этот цикл? \u003cbr /\u003e 1. Выполняется проверка условия. \u003cbr /\u003e 2. Если условие истинно (\u003ccode\u003etrue\u003c/code\u003e), то выполняются записанные в теле цикла операторы. Когда будут выполнены все операторы, возвращаемся к п.1. Если условие ложно (\u003ccode\u003efalse\u003c/code\u003e), то осуществляется переход к оператору, следующему непосредственно за циклом.\u003c/p\u003e\u003cp\u003eПрактический вывод из этого описания состоит в том, что в теле цикла должны присутствовать операторы, меняющие условие цикла (иначе цикл будет работать бесконечно, а в большинстве случаев это не нужно).\u003c/p\u003e\u003cp\u003eИногда бывает удобно выполнять первую итерацию цикла без проверки условия. В этом случае может оказаться полезен \u003cstrong\u003eцикл с постусловием\u003c/strong\u003e. Он выглядит так:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003edo {\n   \u0026lt;операторы\u0026gt;\n}\nwhile (\u0026lt;условие\u0026gt;) \n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eКак работает этот цикл? \u003cbr /\u003e 1. Выполняются операторы, записанные в теле цикла. \u003cbr /\u003e 2. Выполняется проверка условия. Если условие истинно (\u003ccode\u003etrue\u003c/code\u003e), то возвращаемся к п.1. Если условие ложно (\u003ccode\u003efalse\u003c/code\u003e), то осуществляется переход к оператору, следующему непосредственно за циклом.\u003c/p\u003e\u003cp\u003eЕщё один цикл с предусловием — цикл \u003ccode\u003efor\u003c/code\u003e. Он имеет более сложную структуру, нежели \u003ccode\u003ewhile\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003efor (\u0026lt;секция инициализации\u0026gt;; \u0026lt;условие\u0026gt;; \u0026lt;секция итерации\u0026gt;){\n    \u0026lt;операторы\u0026gt;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eУсловие имеет тот же смысл, что и в предыдущих циклах. \u003c/p\u003e\u003cp\u003eСекция инициализации может содержать операторы присваивания значений каким-либо переменным, которые могут быть совмещены с объявлениями этих переменных. Если переменные объявлены в секции инициализации, то по завершении цикла они прекратят свое существование. В частности, это означает, что имена переменных можно будет использовать повторно — однако лучше не злоупотреблять такой возможностью. Вполне допустимо, например, использовать \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e или \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e в качестве счётчиков в нескольких независимых циклах. \u003c/p\u003e\u003cp\u003eСекция итерации может содержать операторы присваивания, изменяющие какие-либо переменные. \u003c/p\u003e\u003cp\u003eЕсли секции инициализации и итерации содержат несколько операторов присваивания, они разделяются запятыми. (На самом деле есть ряд тонких моментов, но представляется, что на этапе первого знакомства с циклами их можно опустить).\u003c/p\u003e\u003cp\u003eЛюбая из секций цикла \u003ccode\u003efor\u003c/code\u003e может быть пустой (причём пустыми могут быть и две, и даже все три секции одновременно). Однако точки с запятыми при этом всё равно должны ставиться (они разграничивают секции и потому необходимы). \u003c/p\u003e\u003cp\u003eЦикл \u003ccode\u003efor\u003c/code\u003e работает следующим образом: \u003cbr /\u003e 0. Однократно выполняются операторы секции инициализации (если есть). \u003cbr /\u003e 1. Проверяется условие. Если оно истинно, то выполняются операторы тела цикла, если же ложно — цикл завершается, управление передается оператору, следующему за циклом. \u003cbr /\u003e 2. После выполнения операторов тела цикла выполняются операторы секции итерации (если есть). После этого происходит переход к п.1\u003c/p\u003e\u003cp\u003eВажно отметить, что работа всех циклов описана в предположении, что в теле цикла нет операторов \u003ccode\u003ebreak\u003c/code\u003e или \u003ccode\u003econtinue\u003c/code\u003e, которые меняют \u0026quot;естественный ход\u0026quot; цикла. Оператор \u003ccode\u003ebreak\u003c/code\u003e прерывает исполнение цикла в том месте, где он записан; управление передается оператору, следующему за циклом. Оператор \u003ccode\u003econtinue\u003c/code\u003e прерывает текущую итерацию цикла и передает управление в заголовок цикла. \u003c/p\u003e\u003cp\u003eИ оператор \u003ccode\u003ebreak\u003c/code\u003e, и оператор \u003ccode\u003econtinue\u003c/code\u003e могут использоваться вместе с \u003cem\u003eметкой\u003c/em\u003e. Метка — это некоторая последовательность символов, подчиняющаяся тем же правилам, что и имя переменной. Метка может быть расположена перед заголовком какого-либо цикла. В этом случае, если после \u003ccode\u003ebreak\u003c/code\u003e будет указана эта же метка, то прерван будет именно этот цикл. Если же метка будет указана после \u003ccode\u003econtinue\u003c/code\u003e, то, соответственно, управление будет передано именно в этот заголовок цикла. Общее правило состоит в том, что передавать управление можно только изнутри наружу — т.е. оператор \u003ccode\u003ebreak\u003c/code\u003e или \u003ccode\u003econtinue\u003c/code\u003e, используемый с меткой, должен находиться внутри того цикла, который отмечен меткой (например, допустимо, чтобы оператор \u003ccode\u003ebreak\u003c/code\u003e находился внутри цикла, вложенного в другой цикл, и прерывал именно этот другой цикл).\u003c/p\u003e\u003c/div\u003e","tags":["java","циклы"]}}