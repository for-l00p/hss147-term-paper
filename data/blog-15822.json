{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1421379847,"rating":15,"authorHandle":"Betlista","modificationTimeSeconds":1421661646,"id":15822,"title":"\u003cp\u003eBetlista\u0027s TopCoder SRM 646 editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eIn SRM there were 849 registered participants — DIV1 383, DIV2 410 + 56 newcomers\u003c/p\u003e\u003ch3\u003eDIV2 — easy (250)\u003c/h3\u003e\u003cp\u003e\u003ca href\u003d\"http://community.topcoder.com/stat?c\u003dproblem_statement\u0026amp;pm\u003d13626\u0026amp;rd\u003d16278\"\u003e(link)\u003c/a\u003e\u003c/p\u003e\u003cp\u003eif k \u003d\u003d 1, the answer is 0 (we have consecutive sequence of length 1 already)\u003c/p\u003e\u003cp\u003eFor k \u003d\u003d 2, one can use sort, find the smallest difference d and return d-1.\u003c/p\u003e\u003cp\u003eUnfortunately elements in input were distinct, so one corner case less :-(\u003c/p\u003e\u003ch3\u003eDIV2 — medium (500)\u003c/h3\u003e\u003cp\u003e\u003ca href\u003d\"http://community.topcoder.com/stat?c\u003dproblem_statement\u0026amp;pm\u003d13628\u0026amp;rd\u003d16278\"\u003e(link)\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIt\u0027s a graph problem, one have to find how far we can move in 1000 steps. On empty board our max coordinates are like -1000..1000, so I modified those to be in 0..2000 and used 2D array to prevent visiting (processing) same point twice during BFS from (0, 0) coordinate... To prevent moving on invalid coordinate I simple marked those as visited before queue processing.\u003c/p\u003e\u003cp\u003eSo I used queue, added (0, 0) to it with 0 as number of steps. Then while q is not empty I removed first position from queue, marked this position as visited and added next steps if the number of steps so far is less than k.\u003c/p\u003e\u003cp\u003eMy Java code which I used in contest available on \u003ca href\u003d\"http://ideone.com/FYXEHN\"\u003eideone\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e My solution is checking current x coordinate, in problem statement is asked \u0026quot;where you can get in (exactly) k seconds (steps)\u0026quot;, but notice, that also to stay at the same position is valid move.\u003c/p\u003e\u003ch3\u003eDIV2 — hard (1000)\u003c/h3\u003e\u003cp\u003e\u003ca href\u003d\"http://community.topcoder.com/stat?c\u003dproblem_statement\u0026amp;pm\u003d13630\u0026amp;rd\u003d16278\"\u003e(link)\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAll solutions I saw just handle few cases. \u003ca href\u003d\"http://community.topcoder.com/tc?module\u003dMemberProfile\u0026amp;cr\u003d22855213\"\u003efluxay\u003c/a\u003e\u0027s simply found values for LEY ( \u003cstrong\u003eL\u003c/strong\u003eess than or \u003cstrong\u003eE\u003c/strong\u003equal \u003cstrong\u003eY\u003c/strong\u003eour score), LEY3 (...your score + \u003cstrong\u003e3\u003c/strong\u003e), LEY6 (...your score + \u003cstrong\u003e6\u003c/strong\u003e), R (rest, which is basically greater than you score + 6). Then he calculated the number of victories V \u003d LEY + LEY3 + LY6 + R + 1 (basically number of teams, plus one for our team). We can let LEY and R to win twice -\u0026gt; V -\u003d 2 * (LEY — R) and let those teams in LEY3 win once -\u0026gt; V -\u003d LYE3. Now we have to check, whether we didn\u0027t let too many teams to win (V is lower than zero, if so set it to 0) and the result is R + (V+1)/2 + 1 (+1 for 1-based index)\u003c/p\u003e\u003cp\u003eIn pseudo code:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e// LEY, LEY3, LEY6 and R calculated from input\nV \u003d  LEY + LEY3 + LY6 + R + 1\nV -\u003d 2 * (LEY — R)     // let those, that has more points to win twice and also those that cannot go ahead of us\nV -\u003d LYE3              // we can still be better, it those in this group win just once\nreturn R + (V+1)/2 + 1 // every second victory remaining moves us one rank down\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003eOpened questions:\u003c/h4\u003e\u003cp\u003eI had similar idea for hard problem, but I\u0027m not convinced now, that all corner cases are handled properly, I\u0027ll try .\u003c/p\u003e\u003ch4\u003eLinks:\u003c/h4\u003e \u003cul\u003e   \u003cli\u003eI liked the most \u003ca href\u003d\"http://community.topcoder.com/stat?c\u003dproblem_solution\u0026amp;rm\u003d324859\u0026amp;rd\u003d16278\u0026amp;pm\u003d13630\u0026amp;cr\u003d22855213\"\u003efluxay\u0027s solution\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"//codeforces.com/blog/entry/15813\"\u003eCF announcement\u003c/a\u003e\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://apps.topcoder.com/wiki/display/tc/SRM+646\"\u003eofficial editorial\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e\u003c/div\u003e","tags":["topcode","srm","646","srm646"]}}