{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1526138299,"rating":-16,"authorHandle":"Dream_kid","modificationTimeSeconds":1526138413,"id":59416,"title":"\u003cp\u003eGetting Wa in codechef problem from sep17 long can\u0027t find any test case i use two segment tree for this problem\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cpre\u003e\u003ccode\u003e//problem link : [SEACO](https://www.codechef.com/SEPT17/problems/SEACO/)\n#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\ntypedef long long ll;\n#define inf 100010\n#define mod1 1000000007\nstruct node1\n{\n    ll pre,post,lef,rig;\n} tree[4*inf+10];\nvoid push_down(ll node,ll type)\n{\n    if(type)\n    {\n        tree[2*node].post+\u003dtree[node].post;\n        tree[2*node].post\u003dtree[2*node].post%mod1;\n        tree[2*node+1].post+\u003dtree[node].post;\n        tree[2*node+1].post\u003dtree[2*node+1].post%mod1;\n        tree[node].post\u003d0;\n    }\n    else\n    {\n        tree[2*node].pre+\u003dtree[node].pre;\n        tree[2*node].pre\u003dtree[2*node].pre%mod1;\n        tree[2*node+1].pre+\u003dtree[node].pre;\n        tree[2*node+1].pre\u003dtree[2*node+1].pre%mod1;\n        tree[node].pre\u003d0;\n    }\n}\nvoid update(ll node,ll l,ll r,ll p,ll q,ll val,ll type)\n{\n    if(l\u0026gt;q or r\u0026lt;p)\n        return;\n    if(l\u0026gt;\u003dp and r\u0026lt;\u003dq)\n    {\n        if(type)\n        {\n            tree[node].post+\u003dval;\n            tree[node].post\u003dtree[node].post%mod1;\n        }\n        else\n        {\n            tree[node].pre+\u003dval;\n            tree[node].pre\u003dtree[node].pre%mod1;\n        }\n        return;\n    }\n    if(type\u0026amp;\u0026amp;tree[node].post)\n    {\n        push_down(node,type);\n    }\n    else if(tree[node].pre\u0026amp;\u0026amp;!type)\n    {\n        push_down(node,type);\n    }\n    update(2*node,l,(l+r)/2,p,q,val,type);\n    update(2*node+1,(l+r)/2+1,r,p,q,val,type);\n}\nll query(ll node,ll l,ll r,ll p,ll q,ll type)\n{\n    if(l\u0026gt;q or r\u0026lt;p)\n        return 0;\n    if(l\u0026gt;\u003dp and r\u0026lt;\u003dq)\n    {\n        if(type)\n            return tree[node].post;\n        else\n            return   tree[node].pre;\n    }\n    if(type\u0026amp;\u0026amp;tree[node].post)\n    {\n        push_down(node,type);\n    }\n    else if(tree[node].pre\u0026amp;\u0026amp;!type)\n    {\n        push_down(node,type);\n    }\n    return (query(2*node,l,(l+r)/2,p,q,type)+\n            query(2*node+1,(l+r)/2+1,r,p,q,type))%mod1;\n}\nvector\u0026lt;ll\u0026gt;pre,post;\nint main()\n{\n    ll ts,type,l,r;\n    scanf(\u0026quot;%lld\u0026quot;,\u0026amp;ts);\n    for(ll t\u003d1; t\u0026lt;\u003dts; t++)\n    {\n        memset(tree,0,sizeof tree);\n        pre.clear();\n        post.clear();\n        ll total,cnt;\n        scanf(\u0026quot;%lld %lld\u0026quot;,\u0026amp;total,\u0026amp;cnt);\n        for(ll i\u003d1; i\u0026lt;\u003dcnt; i++)\n        {\n            scanf(\u0026quot;%lld %lld %lld\u0026quot;,\u0026amp;type,\u0026amp;l,\u0026amp;r);\n            tree[i].lef\u003dl;\n            tree[i].rig\u003dr;\n            if(type\u003d\u003d1)\n            {\n                post.push_back(i);\n            }\n            else\n                pre.push_back(i);\n        }\n        reverse(pre.begin(),pre.end());\n        for(ll i\u003d0; i\u0026lt;pre.size(); i++)\n        {\n            ll val\u003dquery(1,1,total,pre[i],pre[i],0);\n            update(1,1,total,tree[pre[i]].lef,tree[pre[i]].rig,(val+1)%mod1,0);\n        }\n        for(ll i\u003d0; i\u0026lt;post.size(); i++)\n        {\n            ll val\u003dquery(1,1,total,post[i],post[i],0);\n            update(1,1,total,tree[post[i]].lef,tree[post[i]].rig,(val+1)%mod1,1);\n        }\n        for(ll i\u003d1; i\u0026lt;\u003dtotal; i++)\n        {\n            printf(\u0026quot;%lld \u0026quot;,(query(1,1,total,i,i,1)%mod1));\n        }\n        printf(\u0026quot;\\n\u0026quot;);\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":[]}}