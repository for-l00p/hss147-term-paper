{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1502150540,"rating":67,"authorHandle":"DanAlex","modificationTimeSeconds":1502236918,"id":53738,"title":"\u003cp\u003eYet another LCA walkthrough\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThis is the first article I have written after a one-year pause. So let\u0027s just start...\u003c/p\u003e\u003ch2\u003eCutting to the chase\u003c/h2\u003e\u003cp\u003eThere are articles on LCA on many sites(Topcoder, Codeforces), Youtube videos, the Wiki is quite explicative. So why do I write this? The answer is actually simple. I have no friends. \u003c/p\u003e\u003cp\u003eOn a more serious note, I think most LCA articles don\u0027t mention the off-line and no-query cases . \u003c/p\u003e\u003ch2\u003eThe classic Lowest Common Ancestor\u003c/h2\u003e\u003cp\u003eTake a tree with a fixed root. The Lowest Common Ancestor of two nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e is the lowest(i.e. most far from the root) node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e such that both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e are descendants of the node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e. For the following tree, we have:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eLCA(4, 6) \u003d 2\nLCA(5, 10) \u003d 1\nLCA(6, 9) \u003d 6\nLCA(8, 9) \u003d 2\nLCA(4, 5) \u003d 2\netc.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/7f/57/7f5762b29fc69c5bdb93a63fc0ba49cd312bdd3d\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eSuppose that we want to respond to multiple queries of type \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLCA\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e) \u003d ?\u003c/span\u003e. Assume you do not know all the queries in advance. \u003c/p\u003e\u003cp\u003eLet us start with the simple solution: just iterate through the ancestors of both x and y, keep the ancestors in two vectors and, finally, find the one that is the lowest one. This is awfully slow. A minor optimization is to actually stop at the LCA rather than at the root. Thus, we can calculate \u003ccode\u003edepth[x] \u003d the distance from the root to node x\u003c/code\u003e. Now we can start with the node that has the maximum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edepth\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e]\u003c/span\u003e and go the the ancestors until we reach \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edepth\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e] \u003d \u003ci\u003edepth\u003c/i\u003e[\u003ci\u003ey\u003c/i\u003e]\u003c/span\u003e. Then we keep going with both the nodes to the ancestors until \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u003d \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. This will be the LCA. \u003c/p\u003e\u003cp\u003eThis is nice, we used precomputed information to make this thing a bit more faster. Let us think a bit of what we did so far: we saw that going upper than the LCA was not necessary, so we filtered those nodes; in the second phase we considered the candidates at each level, until we found the right one. We basically found a way to filter out nodes that are not good to be our ancestor.\u003c/p\u003e\u003cp\u003eLet\u0027s make some observations regarding the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d \u003ci\u003eLCA\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e. Particularly, we want to:\u003c/p\u003e \u003col\u003e   \u003cli\u003edistinguish \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e from its ancestors\u003c/li\u003e   \u003cli\u003edistinguish \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e from other nodes on the path from x to y\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eWe also want a different criteria to do this, as we want to combine those criteria into a single one. \u003c/p\u003e\u003cp\u003eFor (1), the path between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e passes through \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and does \u003cstrong\u003enot\u003c/strong\u003e pass through any of the ancestors of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e.\u003cbr /\u003eAn obvious choice for (2) is that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edepth\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e] ≤ \u003ci\u003edepth\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e]\u003c/span\u003e for whatever k on the path from x to y. \u003c/p\u003e\u003cp\u003eThe second criterion is a minimization problem, thus we think of using a data structure to get the minimum from a structure. This would be really a classic case if we had an array, thus we begin to think on how to flatten the tree. Addressing the first criterion, we need to flatten the tree such that between the positions of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e we can find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and we can not find any ancestor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eSuch a flattening is the Euler tour of the tree. The Euler tour of a tree is traversing the tree in a depth first form and adding the current node each time we arrive in it(i.e. even when we return from the recursion). The following picture is quite explicative.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/33/7f/337f44a6f57af3a2bc8556428be64b915dc6acd2.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eNow, let us see how to find the LCA of two nodes on this flattening. The LCA of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e is the array element with the minimum depth that is placed in the sequence between the first appearance of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. For nodes \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e5\u003c/span\u003e, we look at the sequence \u003cspan class\u003d\"tex-span\"\u003e4, 2, 5, 8, 5, 9\u003c/span\u003e. Node \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e has the smallest depth.\u003c/p\u003e\u003cp\u003eThe final details is that we need a data structure that can compute the minimum from a substring fast. \u003c/p\u003e\u003ch2\u003eBig Small Excursion\u003c/h2\u003e\u003cp\u003eThe problem we arrived at is: Given a fixed array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e elements, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e queries of type \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e]\u003c/span\u003e, for each query \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e]\u003c/span\u003e find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e], \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + 1], ..., \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + 1])\u003c/span\u003e. This is exactly the Range Minimum Query problem. \u003c/p\u003e\u003cp\u003eLet us start small again. It is clear that we want to process stuff before the queries rather that using the naive solution. We observe that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e], ..., \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e]) \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003emin\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e], ..., \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - 1]), \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e])\u003c/span\u003e. This gives the idea of solving with DP: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e][\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e] \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e], ..., \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e])\u003c/span\u003e, with the recurrence\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e][\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e] \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e][\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - 1], \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e])\u003c/span\u003e. This gives a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e solution.\u003c/p\u003e\u003cp\u003eThe inefficiency in our solution seems to come from the fact that we do minimum of arrays \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e], \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + 1], ..., \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - 1])\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e])\u003c/span\u003e, rather than splitting equally the workload: \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e], \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + 1], ..., \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e])\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e + 1], \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ek\u003c/i\u003e + 2], ..., \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e])\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d (\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e) / 2\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eStarting from this idea and from the fact that we can overlap two parts of a query, let\u0027s define:\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e] \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e], \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e + 1], ..., \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e + 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e])\u003c/span\u003e\u003cbr /\u003eThe recurrence will be: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e] \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e][\u003ci\u003ek\u003c/i\u003e - 1], \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e + 2\u003csup class\u003d\"upper-index\"\u003e\u003c/sup\u003e(\u003ci\u003ek\u003c/i\u003e - 1)][\u003ci\u003ek\u003c/i\u003e - 1])\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eTo respond to a query we \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e, we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e], ..., \u003ci\u003ea\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e]) \u003d \u003ci\u003emin\u003c/i\u003e(\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e][\u003ci\u003ek\u003c/i\u003e], \u003ci\u003edp\u003c/i\u003e[\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e + 1][\u003ci\u003ek\u003c/i\u003e])\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e is the biggest number s.t. \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e ≤ \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e - \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + 1\u003c/span\u003e. Refer to the stolen picture from Topcoder for details.\u003c/p\u003e\u003cp\u003eThat gives a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e·\u003ci\u003elogn\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e solution as we can also precompute \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e. That\u0027s quite fast. That\u0027s what she said...\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/52/ae/52ae359f00f47d9a348cb80131cef818d4ec0664.gif\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch2\u003eNo-query case\u003c/h2\u003e\u003cp\u003eMoving to the hipster stuff, let\u0027s look a bit at the simple case of LCA of two nodes. (this is also explained — I think quite similarly — in an older post of mine)\u003c/p\u003e\u003cp\u003eThe obvious solution is to go upwards to the root and store the distances between the nodes(\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e) and the root. As long as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edist\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003eroot\u003c/i\u003e) \u0026lt; \u003ci\u003edist\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e, \u003ci\u003eroot\u003c/i\u003e)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e will become \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e. When the distances are equal we are going upwards with both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. The complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eR\u003c/i\u003e)\u003c/span\u003e , where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eR\u003c/i\u003e \u003d \u003ci\u003emax\u003c/i\u003e(\u003ci\u003edist\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003eroot\u003c/i\u003e), \u003ci\u003edist\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e, \u003ci\u003eroot\u003c/i\u003e))\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eA better solution comes with an observation. Take distance distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e \u003d \u003ci\u003emax\u003c/i\u003e(\u003ci\u003edist\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003eLCA\u003c/i\u003e), \u003ci\u003edist\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e, \u003ci\u003eLCA\u003c/i\u003e))\u003c/span\u003e. Now if you go \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e nodes upwards from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e nodes upwards from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e at some point in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e’s upwards movement, you encounter the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLCA\u003c/i\u003e\u003c/span\u003e. If you go a distance \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e’ ≥ \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e, then you end up meeting at a common ancestor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, but not the lowest one. From here you can count the number of upward movements for each node and afterwards find the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eLCA\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/70/a5/70a5a5b5d141fdb98f1b70683a9f667240bcaf39\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThe only problem now is how to find a value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e’ ≥ \u003ci\u003eL\u003c/i\u003e\u003c/span\u003e which has the same order of complexity as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. We can use binary search. We will do the algorithm described before with lengths \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d 2\u003csup class\u003d\"upper-index\"\u003e0\u003c/sup\u003e, 2\u003csup class\u003d\"upper-index\"\u003e1\u003c/sup\u003e, 2\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e, …\u003c/span\u003e until we will have the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e which will be larger than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eL\u003c/i\u003e\u003c/span\u003e. The complexity will be: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1 + 2 + 4 + … + 2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sup\u003e) \u003d \u003ci\u003eO\u003c/i\u003e(2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e + 1\u003c/sup\u003e) \u003d \u003ci\u003eO\u003c/i\u003e(\u003ci\u003eL\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eA different idea is to alternate when we move , we apply the ascending function once for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, twice for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, 4 times for x and so on. We have the guarantee that the roads will overlap at some moment. So we’ve managed to reduce the constant using that trick.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/33/29/332911e24cd378f8ee0645f2fbf217ae230e9f5a\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch2\u003eOff-line case\u003c/h2\u003e\u003cp\u003eOff-line queries allow a different approach. \u003c/p\u003e\u003cp\u003eGiven the fact that we attach the queries to the tree, we can keep the lowest common ancestor of partial trees that have been traversed so far. This forest of trees traversed so far can be imagined as a \u0026quot;wave\u0026quot; that propagates from left to right. \u003c/p\u003e\u003cp\u003eAn algorithm based on this is \u003cstrong\u003eTarjan\u0027s off-line lowest common ancestors algorithm\u003c/strong\u003e. The idea behind the algorithm is that we can process the queries from the leafs up to the root. I find the code very clean and clear. The set P is the set of queries, node u is the current node being traversed and the Union and Find operations are operations on disjoint data sets.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e   function TarjanOLCA(u)\n    \tMakeSet(u);\n    \tu.ancestor :\u003d u;\n    \tfor each v in u.children do\n    \t\tTarjanOLCA(v);\n    \t\tUnion(u,v);\n    \t\tFind(u).ancestor :\u003d u;\n    \tu.colour :\u003d black;\n    \tfor each v such that {u,v} in P do\t\n    \t\tif v.colour \u003d\u003d black\n    \t\t\tprint \u0026quot;Tarjan\u0027s Lowest Common Ancestor of \u0026quot; + u +\n    \t\t\t\t\u0026quot; and \u0026quot; + v + \u0026quot; is \u0026quot; + Find(v).ancestor + \u0026quot;.\u0026quot;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eA node is marked black if its subtree has been processed. You can see that the union between subtrees of node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e(say \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e2\u003c/span\u003e) is made before the full tree has been processed. This is done so we can embed the queries in set P right on the tree. It is also important to note that the pair of nodes \u003cspan class\u003d\"tex-span\"\u003e{\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e}\u003c/span\u003e is processed immediately after node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e has been colored in black.\u003c/p\u003e\u003cp\u003eThe algorithm\u0027s correctness can be proved by contradiction: suppose the ancestor found is not the lowest, then we can prove it should have been found on previous steps of the algorithm. The complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e((\u003ci\u003eN\u003c/i\u003e + \u003ci\u003eM\u003c/i\u003e)·\u003ci\u003elog\u003c/i\u003e * \u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e. \u003ca href\u003d\"https://pastebin.com/YTQtwNjc\"\u003eHere\u003c/a\u003e is an implementation for reference.\u003c/p\u003e\u003ch2\u003ePS\u003c/h2\u003e\u003cp\u003eThank you for reading and please state your opinion on my tutorial. (or, more specifically, on my writing style and how useful you find the material presented) \u003c/p\u003e\u003cp\u003eAny suggestions for next tutorial are welcome.\u003c/p\u003e\u003cp\u003eI found the off-line case quite cool when I found about it. Hope you enjoyed!\u003c/p\u003e\u003c/div\u003e","tags":["lca","rmq"]}}