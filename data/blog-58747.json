{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1522940633,"rating":43,"authorHandle":"retrograd","modificationTimeSeconds":1522940633,"id":58747,"title":"\u003cp\u003eA (possibly simpler) algorithm for closest pair problem\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI wanted to showcase a simpler algorithm for the closest pair of points in 2D problem, and maybe to discuss its performance / countercases.\u003c/p\u003e\u003cp\u003eThe problem is:\u003c/p\u003e\u003cp\u003e\u003cem\u003eGiven \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e distinct points in Euclidean 2D space, compute the minimum (squared) distance between any two distinct points.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eThe usual approach here is a divide-and-conquer algorithm, which can be found virtually anywhere, including on \u003ca href\u003d\"https://en.wikipedia.org/wiki/Closest_pair_of_points_problem\"\u003eWikipedia\u003c/a\u003e. The complexity of this algorithm is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e, but it is rather tricky to achieve this complexity.\u003c/p\u003e\u003cp\u003eThe alternative approach (based on the same algorithm), is to do sweep-line. We sort the points based on the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-coordinate and we keep a set of the points in the region \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - \u003ci\u003ed\u003c/i\u003e, \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, sorted by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e coordinate. Here \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e is the smallest distance so far (we do that with the two-pointers technique). Now, for each new point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, we query the whole range \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e - \u003ci\u003ed\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e + \u003ci\u003ed\u003c/i\u003e\u003c/span\u003e in this set and possibly update our answer.\u003c/p\u003e\u003cp\u003eDue to the proof of the D\u0026amp;C algorithm, at each time the quieried range should be of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e on average, so total complexity would be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003enlog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e. Code is below:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003elong long ClosestPair(vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pts) {\n    int n \u003d pts.size();\n    sort(pts.begin(), pts.end());\n    set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; s;\n\n    long long best_dist \u003d 1e18;\n    int j \u003d 0;\n    for (int i \u003d 0; i \u0026lt; n; ++i) {\n        int d \u003d ceil(sqrt(best_dist));\n        while (pts[i].first - pts[j].first \u0026gt;\u003d best_dist) {\n            s.erase({pts[j].second, pts[j].first});\n            j +\u003d 1;\n        }\n\n        auto it1 \u003d s.lower_bound({pts[i].second - d, pts[i].first});\n        auto it2 \u003d s.upper_bound({pts[i].second + d, pts[i].first});\n        \n        for (auto it \u003d it1; it !\u003d it2; ++it) {\n            int dx \u003d pts[i].first - it-\u0026gt;second;\n            int dy \u003d pts[i].second - it-\u0026gt;first;\n            best_dist \u003d min(best_dist, 1LL * dx * dx + 1LL * dy * dy);      \n        } \n        s.insert({pts[i].second, pts[i].first}); \n    }\n    return best_dist;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhat do you think? Are there any special cases (e.g. many points at the same \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e coordinate) that would break the solution?\u003c/p\u003e\u003c/div\u003e","tags":["closest pair","#geometry"]}}