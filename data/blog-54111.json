{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1503909919,"rating":63,"authorHandle":"J-C","modificationTimeSeconds":1503909961,"id":54111,"title":"\u003cp\u003eNumber of Solutions to a Linear Algebraic Equation\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003e\u003cstrong\u003eThe Basic Problem\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eSuppose, we have a Linear Algebraic Equation, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + \u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e \u003d 5\u003c/span\u003e. Here the values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e\u003c/span\u003e can be non-negative integers. We want to know in how many ways we can assign values to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e\u003c/span\u003e so that the summation is 5.\u003c/p\u003e\u003cp\u003eWe can consider this problem as dividing 5 objects among 3 persons. And below are some possible ways to do it —  \u003ca href\u003d\"https://imgbb.com/\"\u003e\u003cimg alt\u003d\"Capture\" border\u003d\"0\" src\u003d\"/predownloaded/e6/e0/e6e059a7f930d99d0727b735a5a8b7b5436733ff.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eHere by O the objects are being represented and | represents partition. As the objects are divided among 3 persons we need 2 partitions which is pretty clear from the partitioning instances above. \u003c/p\u003e\u003cp\u003eWe can finalize this problem as simple combinatorial problem of number of ways of arranging 7 objects where 5 are of first kind and the other 2 are of second kind. And the answer is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/bd/55/bd55ca055a7509ac0f1508254e688d932998d8a8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e So if we have n objects in total and we want to divide those among k persons, we can do that in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7a/f7/7af73f5b8c9c03a66d53e1c30afd949a66b962b4.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e ways.\u003c/p\u003e\u003ch3\u003e\u003cstrong\u003eAdding Upper Bound\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eNow let\u0027s modify the above problem by a bit. Let\u0027s set upper bounds on the terms of the above equation. Suppose, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e≤2, \u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e≤ 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e≤ 3\u003c/span\u003e and we want to know the number of solutions to the equation. In the result we calculated above there are some solutions where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u0026gt; 2\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u0026gt; 1\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e \u0026gt; 3.\u003c/span\u003e If we can figure out the number of invalid solutions and deduct it from the above result then we can get our desired result. Let\u0027s first figure out the number of solutions where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u0026gt; 2\u003c/span\u003e. We can simply deduct 3 from the total number of objects and give those to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and then divide the rest of the objects among all the terms. In this way \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e obviously exceeds its bound of 2. So solving the equation \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + \u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e \u003d 2\u003c/span\u003e, we get the number of solutions where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e exceeds its bound. Following the similar way we can find out the number of solutions where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e\u003c/span\u003e exceeds their bounds. Then we can deduct all of these invalid solutions from the above result to remove the invalid results. \u003c/p\u003e\u003cp\u003eNow we\u0027ve actually removed some invalid solutions more than once. When finding out the number of solutions where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e exceeds 2 and solving \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + \u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e \u003d 2\u003c/span\u003e, we\u0027ve also removed the solutions where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e exceeds 1. And then again we\u0027ve removed it separately for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e. So same invalid configuration is actually removed twice and we have to add the number of solutions where both \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e exceeds their bounds to the above result. This is actually a classical \u003ca href\u003d\"https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle\"\u003eInclusion-Exclusion\u003c/a\u003e problem. If we choose odd number of terms and find out the numbers of solutions where they exceed bounds, we deduct it from the result and if we choose even number of terms and find out the numbers of solutions where they exceed bounds, we add it to the result. Finally we get the number of solutions where all the terms are under the bound.\u003c/p\u003e\u003ch3\u003e\u003cstrong\u003eAdding Lower Bound\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eLastly consider that some lower bounds are set on the terms of the equation. Suppose, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ≥ 1\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e ≥  0\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e ≥  2\u003c/span\u003e and we want to know the number of solutions to the equation. If you observe carefully you will notice that if we decrease the particular upper bounds by their lower bounds and reset them and also decrease the total number of objects by the summation of lower bounds then the problem is just similar to the previous problem of finding number of solutions with upper bounds. Now the number of solutions to the newly set equation is actually the numbers of solutions to a Linear Algebraic Equation with both upper and lower bounds.\u003c/p\u003e\u003ch3\u003e\u003cstrong\u003ePractice Problems\u003c/strong\u003e\u003c/h3\u003e \u003cul\u003e   \u003cli\u003e\u003ca href\u003d\"http://lightoj.com/volume_showproblem.php?problem\u003d1102\"\u003eProblem Makes Problem\u003c/a\u003e This problem is quite similar to the basic problem discussed above.\u003c/li\u003e \u003c/ul\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace  std;\n\ntypedef long long ll;\nconst ll mod \u003d 1000000007;\n\n#define SZ 2000010\n\nll BigMod (ll B, ll P, ll M) {\n    ll R \u003d 1 % M;\n    while (P \u0026gt; 0) {\n        if(P % 2 \u003d\u003d 1) {\n            R \u003d (R * B) % M;\n        }\n        P /\u003d 2;\n        B \u003d (B * B) % M;\n    }\n    return R;\n}\n\nll fact[SZ];\n\nint main() {\n    fact[0] \u003d 1;\n    for(ll i \u003d 1; i\u0026lt;SZ; i++)\n        fact[i] \u003d (i * fact[i-1]) % mod;\n\n    int t;\n    scanf(\u0026quot;%d\u0026quot;,\u0026amp;t);\n\n    for (int cs \u003d 0; cs \u0026lt; t; cs++) {\n        ll n, k;\n        scanf(\u0026quot;%lld %lld\u0026quot;,\u0026amp;n,\u0026amp;k);\n\n        ll ans \u003d fact[n+k-1];\n        ans \u003d (ans * BigMod(fact[n], mod - 2, mod)) % mod;\n        ans \u003d (ans * BigMod(fact[k-1], mod - 2, mod)) % mod;\n\n        printf(\u0026quot;Case %d: %lld\\n\u0026quot;, cs + 1, ans);\n    }\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cul\u003e   \u003cli\u003e\u003ca href\u003d\"http://lightoj.com/volume_showproblem.php?problem\u003d1124\"\u003eCricket Ranking\u003c/a\u003e This problem is quite similar to the problem of solving Linear Algebraic Equation with upper and lower bounds discussed above.\u003c/li\u003e \u003c/ul\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace  std;\n\ntypedef long long ll;\n\nconst ll mod \u003d 100000007;\n\n#define SZ 1000000+10\n\nll BigMod (ll B, ll P, ll M) {\n    ll R \u003d 1 % M;\n    while (P \u0026gt; 0) {\n        if(P % 2 \u003d\u003d 1) {\n            R \u003d (R * B) % M;\n        }\n        P /\u003d 2;\n        B \u003d (B * B) % M;\n    }\n    return R;\n}\n\nll nCr (int n, int r, vector \u0026lt;ll\u0026gt;\u0026amp; fact) {\n    if(r \u0026gt; n) return 0LL;\n    ll ans \u003d fact[n];\n    ans \u003d (ans * BigMod(fact[r], mod-2, mod)) % mod;\n    ans \u003d (ans * BigMod(fact[n-r], mod-2, mod)) % mod;\n    return ans;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    vector \u0026lt;ll\u0026gt; fact(1000001, 1);\n    for (int i \u003d 1; i \u0026lt;\u003d 1000000; i++) {\n        fact[i] \u003d ((ll)i * fact[i-1]) % mod;\n    }\n\n    int t;\n    cin \u0026gt;\u0026gt; t;\n\n    for (int cs \u003d 0; cs \u0026lt; t; cs++) {\n        int k, n;\n        cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; n;\n\n        vector \u0026lt;int\u0026gt; low(k), high(k);\n\n        for (int i \u003d 0; i \u0026lt; k; i++) {\n            cin \u0026gt;\u0026gt; low[i] \u0026gt;\u0026gt; high[i];\n        }\n\n        ll ans \u003d 0LL;\n        int lim \u003d (1 \u0026lt;\u0026lt; k);\n\n        for (int mask \u003d 0; mask \u0026lt; lim; mask++) {\n            int tot \u003d n, cnt \u003d 0;\n\n            for (int i \u003d 0; i \u0026lt; k; i++) {\n                if (mask \u0026amp; (1\u0026lt;\u0026lt;i)) {\n                    tot -\u003d (high[i] + 1);\n                    cnt++;\n                } else {\n                    tot -\u003d low[i];\n                }\n            }\n\n            if (tot \u0026lt; 0) continue;\n\n            if (cnt \u0026amp; 1) ans \u003d ans - nCr(tot + k - 1, k - 1, fact);\n            else ans \u003d ans + nCr(tot + k - 1, k - 1, fact);\n\n            if (ans \u0026lt; 0) ans +\u003d mod;\n            if (ans \u0026gt;\u003d mod) ans -\u003d mod;\n        }\n\n        printf(\u0026quot;Case %d: %lld\\n\u0026quot;, cs + 1, ans);\n    }\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cul\u003e   \u003cli\u003e\u003ca href\u003d\"https://toph.co/p/biswa-the-digital-gutibaj\"\u003eToph Biswa the Digital Gutibaj\u003c/a\u003e In this problem you also need to find the number of solutions to a Linear Algebraic Equation with upper and lower bounds. But here you can use as many terms as you want. So just choose some terms at each step and then solve for them. You also need to multiply the answer at each step with the factorial of number of terms chosen as the requirement of the problem. Here the number of objects can be as large as \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e12\u003c/sup\u003e\u003c/span\u003e but the number of terms is at most 10. You can simply iterate to find out the nCr value.\u003c/li\u003e \u003c/ul\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026quot;bits/stdc++.h\u0026quot;\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll mod \u003d 1E9 + 7;\n\nll f[12];\nll inv[12];\n\nll BigMod (ll B, ll P) {\n    ll R \u003d 1 % mod;\n    while (P \u0026gt; 0) {\n        if (P \u0026amp; 1) {\n            R \u003d (R * B) % mod;\n        }\n        P /\u003d 2;\n        B \u003d (B * B) % mod;\n    }\n    return R;\n}\n\nll nCr (ll n, int r) {\n    if (r \u0026gt; n) return 0LL;\n    if (n \u003d\u003d r || r \u003d\u003d 0) return 1LL;\n\n    if (r \u0026gt; n-r)\n        r \u003d n-r;\n    n %\u003d mod;\n\n    ll ans \u003d 1LL;\n    for (int i \u003d 1; i \u0026lt;\u003d r; i++) {\n        ans \u003d (ans * ((n - (ll)i + 1LL + mod) % mod)) % mod;\n        ans \u003d (ans * inv[i]) % mod;\n    }\n\n    return ans;\n}\n\nint main () {\n    ios::sync_with_stdio(false);\n\n    f[0] \u003d 1;\n    for (int i \u003d 1; i \u0026lt;\u003d 10; i++) {\n        inv[i] \u003d BigMod(i, mod - 2LL);\n        f[i] \u003d ((ll)i * f[i-1]) % mod;\n    }\n\n    int n;\n    ll l;\n\n    while (cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; l) {\n        vector \u0026lt;ll\u0026gt; a(n);\n\n        for (int i \u003d 0; i \u0026lt; n; i++) {\n            cin \u0026gt;\u0026gt; a[i];\n        }\n\n        ll ans \u003d 0;\n        int lim \u003d (1 \u0026lt;\u0026lt; n);\n\n        for (int taken \u003d 1; taken \u0026lt; lim; taken++) {\n            int k \u003d __builtin_popcount(taken);\n\n            vector \u0026lt;ll\u0026gt; v;\n            for (int i \u003d 0; i \u0026lt; n; i++) {\n                if (taken \u0026amp; (1\u0026lt;\u0026lt;i)) {\n                    v.push_back(a[i]);\n                }\n            }\n\n            int tlim \u003d (1 \u0026lt;\u0026lt; k);\n\n            for (int mask \u003d 0; mask \u0026lt; tlim; mask++) {\n                ll tot \u003d l, cnt \u003d 0;\n\n                for (int i \u003d 0; i \u0026lt; k; i++) {\n                    if(mask \u0026amp; (1 \u0026lt;\u0026lt; i)) {\n                        tot -\u003d (v[i] + 1);\n                        cnt++;\n                    } else {\n                        tot -\u003d 1;\n                    }\n                }\n\n                if(tot \u0026lt; 0) continue;\n\n                ll tmp \u003d (nCr(tot+k-1, k-1) * f[k]) % mod;\n\n                if(cnt \u0026amp; 1) ans \u003d ans - tmp;\n                else ans \u003d ans + tmp;\n\n                if(ans \u0026lt; 0) ans +\u003d mod;\n                if(ans \u0026gt;\u003d mod) ans -\u003d mod;\n            }\n        }\n\n        cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n    }\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["math","equation","linear algebra","tutorial","bitmask","combinatorics"]}}