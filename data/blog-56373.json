{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1513362726,"rating":10,"authorHandle":"s3ct4l-r3x","modificationTimeSeconds":1513362726,"id":56373,"title":"\u003cp\u003eXOR path (ACM ICPC dhaka regionals 2017)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThis question appeared in icpc regionals dhaka 2017. Click \u003ca href\u003d\"https://icpcarchive.ecs.baylor.edu/index.php?option\u003donlinejudge\u0026amp;Itemid\u003d8\u0026amp;category\u003d770\u0026amp;page\u003dshow_problem\u0026amp;problem\u003d6105\"\u003ehere\u003c/a\u003e for the question.\u003c/p\u003e\u003cp\u003eMy approach to solve the problem is to traverse the tree once using DFS considering any node as the root and maintaining the xor distance along a path from the root. Since the edge weights cant exceed 2^16-1, every xor distance can be hashed in an array storing its frequency as the value.\u003c/p\u003e\u003cp\u003eNow the problem reduces to finding pairs of numbers whose xor is equal to x, for all 0\u0026lt;\u003dx\u0026lt;\u003d2^16-1. Let say the pair of numbers are a and b. Then if a ⊕ b\u003d x, then x ⊕ a \u003d b. Hence for every a present in the hashmap frequency of b can be found and finding the count of pairs accordingly. Do this for all 0\u0026lt;\u003d x \u0026lt;\u003d2^16-1.\u003c/p\u003e\u003cp\u003ethis turns out to be O(2^32),which is not feasible. Please suggest some alternate approach for finding count of such pairs or a different solution altogether for this problem.\u003c/p\u003e\u003c/div\u003e","tags":[]}}