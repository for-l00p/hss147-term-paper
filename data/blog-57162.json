{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1516115044,"rating":1,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1516115086,"id":57162,"title":"\u003cp\u003eNotes on Codeforces Beta Round #109, Div2- A, B, C, D, E (hash algorithm)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/155/problem/A\" title\u003d\"Codeforces Round 109 (Div. 2)\"\u003e155A - I_love_\\%username\\%\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe should keep updating the maximum and minimum values that we have obtained, and increase the counter according to the requirements.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/155/problem/B\" title\u003d\"Codeforces Round 109 (Div. 2)\"\u003e155B - Combination\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe main idea is greedy algorithm. We sort the cards in a decreasing order of the number of cards that we can further check, and if the numbers are equal, we sort them in a decreasing order of scores. After sorting, we start from the first card and implement the simulation step by step.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/155/problem/C\" title\u003d\"Codeforces Round 109 (Div. 2)\"\u003e155C - Hometask\u003c/a\u003e\u003c/p\u003e\u003cp\u003eNote that any single letter will not appear in more than one constraint, and thus we can deal with the constraints one by one in an independent manner.\u003c/p\u003e\u003cp\u003eGiven a constraint, i.e., two letters \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e, we can find all the consecutive intervals \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e so that only the two letters are included. For each interval \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e, we also count the number of letter \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e, respectively. It is obvious that we must either delete all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e or all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e, since otherwise we can always find two neighboring letters of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e. Thus, we should delete the letter corresponding to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003en\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e for this interval.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/155/problem/D\" title\u003d\"Codeforces Round 109 (Div. 2)\"\u003e155D - Colliders\u003c/a\u003e\u003c/p\u003e\u003cp\u003eA key observation is that \u003cspan class\u003d\"tex-span\"\u003e100000 \u0026lt; 2 × 3 × 5 × 7 × 9 × 11 × 13\u003c/span\u003e, implying that any integer that does not exceed \u003cspan class\u003d\"tex-span\"\u003e100000\u003c/span\u003e can have at most \u003cspan class\u003d\"tex-span\"\u003e7\u003c/span\u003e (strictly speaking \u003cspan class\u003d\"tex-span\"\u003e6\u003c/span\u003e) different prime divisors.\u003c/p\u003e\u003cp\u003eBased on the above observation, we can implement sieve function to find out all the prime integers and also the prime divisors that each integer has. Then, when an integer is added, we find all its prime divisors and check whether these divisors have already appeared before or not, to determine whether this integer can be successfully inserted or not. If an integer is deleted, we should delete all their prime divisors at the same time. \u003c/p\u003e\u003cp\u003eIn other words, we can maintain multiple sets \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e, so that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e (it is a set) contains all the integers which have been added and have such a prime divisor (this implies that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e should be some prime integer), and update these sets whenever an integer is inserted or deleted.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/155/problem/E\" title\u003d\"Codeforces Round 109 (Div. 2)\"\u003e155E - Double Profiles\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe idea is a little weird (from the tutorials). The essential issue is to determine whether two sets contain exactly the same integers or not.\u003c/p\u003e\u003cp\u003eWe find a prime integer, for instance \u003cspan class\u003d\"tex-span\"\u003e29\u003c/span\u003e, and assign integer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e with a weight \u003cspan class\u003d\"tex-span\"\u003e29\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e. Then, for some set containing integers \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e, ...)\u003c/span\u003e, we compute its hash value as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e × 29\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sup\u003e + \u003ci\u003ej\u003c/i\u003e × 29\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sup\u003e + ...\u003c/span\u003e (if we use “long long int”, the modulo operation is automatically implemented). Two sets are exactly the same if they have the same hash value. For simplicity, we use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e to denote the hash value of the set that node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e has.\u003c/p\u003e\u003cp\u003eNote that we should check every pair of two nodes. We can divide all the pairs into two types, one containing those which have direct edges, while the other one containing those that do not have direct edges.\u003c/p\u003e\u003cp\u003eFor the first type, we can check each of them in the order of given edges. Be careful that we should delete the hash value of the neighboring node from the total hash value.\u003c/p\u003e\u003cp\u003eFor the second type, we can sort \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e in an increasing order, and find out all the intervals of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e that have the same value. For instance, some interval contains \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e same values, and then it contributes \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/98/63/98634946a0d86d7446930ebea99a5337da697b3f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e to the final answer.\u003c/p\u003e\u003c/div\u003e","tags":[]}}