{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1465500897,"rating":8,"authorHandle":"arsijo","modificationTimeSeconds":1465752906,"id":45338,"title":"\u003cp\u003eGeometry Contest #1\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi everyone!\u003c/p\u003e\u003cp\u003eI have prepared a geometry contest for you. It contains 6 problems. Two of them are from UOI (Ukrainian Olympiad in Informatics), other are from CF rounds. \u003c/p\u003e\u003cp\u003eMy \u0026quot;English\u0026quot; is not very good, so write me, if you see something wrong.\u003c/p\u003e\u003cp\u003eGood luck!\u003c/p\u003e\u003cp\u003eTutorials:\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eA\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFirst, we note that all the operations delete several points can be divided into elementary operations removing a single point. As each point is added to the upper chain is not more than once, in the amount and delete operations will no longer than N. Let we have built the convex hull of the points in a given time. Consider the segment connecting the leftmost and the rightmost point of the set. Part of the convex hull, which lies over this segment with its two ends, is called the convex hull of the upper link. another part of the shell and the two ends of the favorites of the segment is called the convex hull of the lower link. Thus, the leftmost and rightmost points belong to both circuits simultaneously. Upper and lower chain segment with the selected form convex polygons. The area of ​​the convex hull of the whole is the sum of the areas of two polygons. So learn enough to fulfill all the necessary operations to the upper link and the lower for all will be similar.\u003c/p\u003e\u003cp\u003eA partial solution.\u003c/p\u003e\u003cp\u003eHead of the stack, in which to store the upper circuit point. Adding a new point will be the same as in Graham algorithm. Namely, delete the last point to the stack until the last turn of the stack between the two points (call them A and B) and a new point (D) will not be the right (i.e. the vector product AB * AD \u0026lt;0). Then add a new point to the stack. To find except the circuit also its area, together with the need to store each point area of ​​a convex polygon formed by all the points are in the stack in front of it (including). Then when you add a new point to the already saved enough space to add a circuit area of ​​the triangle formed by the first and last points of the stack, as well as a new point.\u003c/p\u003e\u003cp\u003eWe already know how to add points to the top of the chain, and then consider its area. But the algorithm described above can not be deleted from the set point. Namely, adding a new point we remove the last few points from the stack. Now, when the delete operation again we return to the point stack. To do this, we can establish another stack, where we will translate the point when they are removed from the first stack. If you need to return multiple remote locations in the stack first, then we can take them on the other. It is only necessary for each request additional memory of the second stack in order for us to know how many points you want to return to the upper chain. This algorithm can handle all types of transactions and the time complexity is O (NM), where M — the number of rows of the input file, which is asked to remove the last few points.\u003c/p\u003e\u003cp\u003eA complete solution.\u003c/p\u003e\u003cp\u003eFor the complete solution you need to understand what place is the slowest in this algorithm. Consider the following scenario: suppose we have built the upper circuit a set of points (stored in the stack). Then we add a new point that is far above all others, and therefore are removed from the stack all the points except the first. Now we remove this point, all the points are transferred back from one stack to another. So, for 2 operation algorithm has O (N) operations. If they are repeated many times, the complexity is O (N ^ 2).\u003c/p\u003e\u003cp\u003eWe replace our usual array stack interchange, for which we will further keep in mind the number of points belonging to the upper chain (stack size). When adding a new point of binary search we find the number of points that you want to remove from the stack before they put this new point to it. Instead of shifting all the points in the second stack, we assume there is only the upper circuit size, as well as all the information about the last of the points are removed (that is, its number in the array, its coordinates, as well as the area of ​​the polygon associated with it). After that, we will replace it with a new point, we list for her area and change the size of the chain. All the other points that are to be removed, in the array remain unchanged (but they are outside the circuit). When you remove the last point it is sufficient to change only the size of the circuit and replaced by a single point to the one that is stored in the second stack. The complexity of such a decision — O (NlogN).\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eB\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFirst, consider the problem of effectively finding the intersection of a convex polygon and the vertical line. Obviously, the number of crossing points is less than 2, unless the line does not contain the vertical side of the polygon. We split a polygon on the top and bottom of the chain: find the left-most (as of all such — the lowest) and the right-most (from all these — the highest) vertex of the polygon. We draw a straight line between these points. All the vertices of the polygon lying above the drawn line, belong to the upper circuit, and the other — the lower. After such a division in the top of each chain ordered by the abscissa. This allows you to find the point of intersection of the vertical line with a convex polygon of O (logN) operations using a binary search.\u003c/p\u003e\u003cp\u003eNow, as the range of any natural radius R intersects with exactly 2R + 1 integer vertical line, the total number of lines intersecting at least one round, no more than 2S + M \u003d O (S), where S — the total range of all M circles . Consider the corresponding 2S + M the intersection of the segments and arrange them in order of increasing abscissas, while at the same abscissa — ascending ordinates of the lower end. For each segment for O (logN), using described in the preceding paragraph by the method, we find the number of lattice points on the segment lying inside the polygon. At the same time, not to be considered a few times the points lying simultaneously on several segments for each new abscissa remember ordinate, which ended the previous reporting segment, and from which, consequently, need to continue to consider the point. Found total number of points and will be the answer. The complexity of the algorithm — O (S (log S + log N) + N), or if the use of segments and ordering instead follow the binary search circuits linearly, O (S log S + N).\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}