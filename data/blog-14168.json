{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1412763912,"rating":224,"authorHandle":"marat.snowbear","modificationTimeSeconds":1412981504,"id":14168,"title":"\u003cp\u003eBayan 2015 Contest Warm Up Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/475/problem/A\" title\u003d\"Bayan 2015 Contest Warm Up\"\u003e475A - Bayan Bus\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAs usual for A we have an implementation problem and the main question is how to implement it quickly in the easiest (thus less error-prone) way. During the contest I spent almost no time thinking about it and decided to implement quite straightforward approach — start with empty string and concatenate different symbols to the end of it. The \u003ca href\u003d\"/contest/475/submission/8161787\"\u003eresult\u003c/a\u003e is quite messy and worst of all I forgot one of the main principles in the [commercial] programming — separate logic from its presentation. The \u0026quot;presentation\u0026quot; here is all these bus characters which are all the same across different inputs. So I paid my price, my original solution failed on system tests. \u003c/p\u003e\u003cp\u003eMuch better approach afterwards I looked up in \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Swistakk\" title\u003d\"Master Swistakk\"\u003eSwistakk\u003c/a\u003e\u0027s solution — you copy\u0026amp;paste the \u0026quot;template\u0026quot; of the bus from the example test into your source code, then you just change the characters for each of 34 possible seats. Result becomes much cleaner — \u003ca href\u003d\"/contest/475/submission/8140120\" title\u003d\"Submission 8140120 by marat.snowbear\"\u003e8140120\u003c/a\u003e.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/475/problem/B\" title\u003d\"Bayan 2015 Contest Warm Up\"\u003e475B - Strongly Connected City\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eFor B we already might need some kind of algorithm to solve it, though for the constraints given you might use almost any approach. If you just have a directed graph then in order to check whether you can reach all nodes from all other nodes you can do different things — \u003ca href\u003d\"/contest/475/submission/8140566\"\u003eyou can dfs/bfs from all nodes\u003c/a\u003e, \u003ca href\u003d\"/contest/475/submission/8140615\"\u003etwo dfs/bfs from the single node\u003c/a\u003e to check that every other node has both paths \u003cstrong\u003eto\u003c/strong\u003e and \u003cstrong\u003efrom\u003c/strong\u003e that node, or you can employ different \u0026quot;min distance between all pairs of nodes\u0026quot; algorithm. All of these seem to work fine for this problem. \u003c/p\u003e\u003cp\u003eBut we shouldn\u0027t ignore here that the input graph has a special configuration — it\u0027s a grid of vertical and horizontal directed lines. For this graph all you need is to check whether four outer streets form a cycle or not. If they form a cycle then the answer is \u0026quot;YES\u0026quot;, otherwise \u0026quot;NO\u0026quot;. The good explanation why this works was \u003ca href\u003d\"http://codeforces.ru/blog/entry/14077#comment-191440\"\u003ealready given\u003c/a\u003e by \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/shato\" title\u003d\"Expert shato\"\u003eshato\u003c/a\u003e. And then the entire solution takes just 10 lines of code — \u003ca href\u003d\"/contest/475/submission/8140438\" title\u003d\"Submission 8140438 by marat.snowbear\"\u003e8140438\u003c/a\u003e.\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/475/problem/C\" title\u003d\"Bayan 2015 Contest Warm Up\"\u003e475C - Kamal-ol-molk\u0027s Painting\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eThere are probably several completely different ways to solve this problem, I will describe only the one I implemented during the round. The start point for the solution is that there are three cases we need to cover: either first time we move the brush right or we move it down or we do not move it at all. Let\u0027s start with the last one. Since we\u0027re not moving the brush at all then it\u0027s obvious that altered cells on the painting form a rectangle. It can also be proven that the only case we need to consider here is the rectangle 1x1, that\u0027s the only rectangle which cannot be achieved by moving some smaller rectangle. So we need to count the number of altered cells, if it is equal to 1 then the answer is 1. \u003c/p\u003e\u003cp\u003eNow we\u0027re left with two cases to consider, you start by moving right in the case and you move down in the second case. You can write some code to cover each of those cases, but you can also notice that they are symmetric in some sense. To be more clear, they are symmetric against the diagonal line which goes from (0, 0) point through (1, 1) point. If you have some code to solve \u0026quot;move down first\u0026quot; case, then you don\u0027t need to write almost completely the same code to solve \u0026quot;move right\u0026quot; case, you can simply mirror the image against that diagonal and invoke \u0026quot;move down\u0026quot; method again. Small trick which saves a lot of time and prevents copy-pasting of the code. \u003c/p\u003e\u003cp\u003eNow let\u0027s try to solve this last case. Basically the approach I used can be shortly described like that: we start in the leftmost topmost altered cell, then we move down and that move already leaves us only one option what do in the next moves until the end, so we get the entire sequence of moves. As well as getting these moves we also get the only possible width and height of the brush, so we know everything, I was not very strict while moving the brush so at the end I also compared whether these moves and these sizes in fact give exactly the same image as we get in the input. \u003c/p\u003e\u003cp\u003eThat was the brief explanation of the \u0026quot;move down\u0026quot; method, now let\u0027s get into details. First of all since we move down immediately from the start point then there is only one value which can be valid for the brush width — it is the number of altered cells which go to the right from the start point. So we know one dimension. Now let\u0027s try moving the brush. Ok, first time as we said we move it down, what is next? Then you might have a choice whether you want to move right or to move down again. The answer is to move right first because your width is already fixed while height might be unknown still, so if you miss point to be altered in the left column of the brush and you move right, you might still have a chance to paint it if you take the correct height of the brush. But if you miss the point to the right of the current topmost brush row then you won\u0027t be able to cover it later, because your width was fixed on the first step. Here is a picture: \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/b7/45/b7455bd858217dcc1de9d8da2723faeee515cb8a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eGrayed out is the current position of the brush. So what I\u0027m saying is that you should move to the right if the cell in the red area is painted, otherwise you will definitely miss it. So this simple thing gives you the entire idea on how to build the only possible sequence of moves. You also need to calculate some possible value for the brush height. It can be calculated just before moving right, in order not to miss any painted cells you need to extend you height of the brush to cover all the painted cells in the leftmost column of you current brush position (this was highlighted as green on the image above). Now you know all the information about the probable painting — you have both dimensions of the brush and you know how it was moving, as I said before all you need to do is to double check that these moves and these dimensions in fact give you the same painting you get. If it gives the same painting then the answer for this case is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ewidth\u003c/i\u003e·\u003ci\u003eheight\u003c/i\u003e\u003c/span\u003e, otherwise there is no answer for this particular case. \u003c/p\u003e\u003cp\u003eIf you implement all of these steps carefully and you won\u0027t paint cells more than one time, then you will be able to achieve an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e·\u003ci\u003eM\u003c/i\u003e)\u003c/span\u003e complexity. \u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/475/problem/D\" title\u003d\"Bayan 2015 Contest Warm Up\"\u003e475D - CGCDSSQ\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eIt seems that all the solutions for this problem based on the same observation. Let\u0027s introduce two number sequences: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e, \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003egcd\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e. Then the observation is that the number of distinct values in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e sequence is no more than \u003cspan class\u003d\"tex-span\"\u003e1 + \u003ci\u003elog\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003c/span\u003e. It can be proven by taking into account that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is non-increasing sequence and value for greatest common divisor in case if it decreases becomes at most half of the previous value. \u003c/p\u003e\u003cp\u003eSo we have this observation and we want to calculate the count of GCD values across all the intervals, I see couple of ways how we can exploit the observation: \u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eWe can fix the left side of the interval and look for the places where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egcd\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e function will decrease. Between the points where it decreases it will stay flat so we can add the size of this flat interval to the result of this particular \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egcd\u003c/i\u003e\u003c/span\u003e. There are different ways how to find the place where the function changes its value, some people were using sparse tables, I have never used those so won\u0027t give this solution here. Otherwise you can use segment tree to calculate gcd on the interval and then do a binary search to find where this value changes. This adds squared logarithmic factor to the complexity, not sure if that passes the TL easily. Otherwise you can do basically the same by doing only one descent in the segment tree. Then you get rid of one logarithmic factor in the complexity but that will make segment tree a bit more complicated.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eAnother solution seems to be much simpler, you just go left to right and you calculate what is the number of segments started to the left of current element and what is the greatest common divisors values on those intervals. These values you need to store grouped by the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egcd\u003c/i\u003e\u003c/span\u003e value. This information can be easily updated when you move to the next element to the right — you can check that part in my submission. Our observation guarantees that the number of different \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003egcd\u003c/i\u003e\u003c/span\u003e values that we have to track is quite small all the time, it\u0027s no more than \u003cspan class\u003d\"tex-span\"\u003e1 + \u003ci\u003elogA\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003emax\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Submission: \u003ca href\u003d\"/contest/475/submission/8141810\" title\u003d\"Submission 8141810 by marat.snowbear\"\u003e8141810\u003c/a\u003e, maps are used here to count gcd values, using the vectors instead makes it running two times faster but the code is not that clear then. \u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/475/problem/E\" title\u003d\"Bayan 2015 Contest Warm Up\"\u003e475E - Strongly Connected City 2\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eHere we can start with the simple observation — if we have a cycle then we can choose such an orientation for the edges such that it will become a directed cycle. In this case all nodes in the cycle will be accessible from all other nodes of the same cycle. I was using the bridges finding algorithm to find the cycles. So you find all the cycles, for each cycle of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e you add \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e to the answer. Then you can collapse all the cycles into the single node (storing the cycle size as well). After merging all cycles into single nodes original graph becomes a tree. \u003c/p\u003e\u003cp\u003eNow it comes to some kind of a magic, as far as I\u0027ve seen from the discussions here people were make an assumption about the optimal solution, but nobody proved this assumption. Assumption goes like this: \u0026quot;there exists an optimal solution which has some node (let\u0027s call it \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e) such that for every other node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e you can either reach \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e or you can reach \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e using directed edges of this optimal solution\u0026quot;. Intuitively this assumption makes sense because probably in order to increase the number of pairs of reachable nodes you will try to create as least as possible components in the graph which will be mutually unreachable. So we have this assumption, now in order to solve the problem we can iterate over all nodes in the tree and check what will be the answer if we will make this node to be a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e from the assumption. \u003c/p\u003e\u003cp\u003eLet\u0027s draw some example of the graph which might be a solution according to our assumption: \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/94/26/942655464fb6a096b25b0bdef42011106d2ef5f6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eHere the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e is drawn on top and every other node has either a path to the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e or a path from the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e. So let\u0027s say we decided that some node will be a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e but we didn\u0027t decide yet for each of its children whether their edges will directed to the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e or from the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e. In order to fulfil our assumption the orientation of the edges within some child\u0027s subtree should be the same as the orientation of the edge between the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e and its child. There will be two more numbers which we need to add to the result — pairs of reachable nodes within some child\u0027s (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e children only!) subtree and pairs of reachable nodes for nodes from different subtrees. Let\u0027s introduce some variables: \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — size of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th cycle from the step when we were merging the cycles. In our tree all cycles are already merged into a single node, so \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is a weight of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th node. It can be equal to 1 if node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e did not belong to any cycle. \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e — weight of the entire subtree rooted at node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eIt can be seen that if we orient all edges in the subtree in the same manner according to our assumption then the number of reachable pairs of nodes will not depend on the chosen orientation. Each particular node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e adds the following term to the final result: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e·(\u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e. Now we need to decide what should be the orientation of all the edges adjacent to the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e. Let\u0027s declare two more variables: \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ein\u003c/i\u003e\u003c/span\u003e — sum of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e\u0027s children whose edge is directed towards the root. \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eout\u003c/i\u003e\u003c/span\u003e — same for the children whose edge is directed from the root. \u003c/p\u003e\u003cp\u003eSo if we have those definitions then the last term for the result will be equal to: \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ein\u003c/i\u003e + \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/sub\u003e)·\u003ci\u003eout\u003c/i\u003e + \u003ci\u003ein\u003c/i\u003e·\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. We can see that this term depends only on the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ein\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eout\u003c/i\u003e\u003c/span\u003e values, it doesn\u0027t depend on which particular children contribute to each of these values. We check which values for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ein\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eout\u003c/i\u003e\u003c/span\u003e we can achieve, we can do it using the DP similar to the one used in knapsack. So we check every possible value for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ein\u003c/i\u003e\u003c/span\u003e, based on this we can calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eout\u003c/i\u003e\u003c/span\u003e value because their sum is fixed and equals to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eW\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, then we put them into the formula above and check whether it gives us a better total answer. \u003c/p\u003e\u003cp\u003eThere is one more thing to be noted about this solution — you can see that I said that we need to iterate over all nodes and make them to be the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e, then you will need to get all the sizes of the children for particular \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e and for those sizes you will need to find all the possible values for their sums. The sum can be up to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e, for some \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e we might have up to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e children, so if you\u0027ve fixed the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eroot\u003c/i\u003e\u003c/span\u003e then the rest might have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e complexity. This might lead you to a conclusion that the entire algorithm then has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003c/sup\u003e)\u003c/span\u003e complexity, which is too slow for the given constraints. But that is not the case because outermost and innermost loops depend on each other, basically there you iterate over all the parent-children relations in the tree, and we know that this number in the tree equals to \u003cspan class\u003d\"tex-span\"\u003e2(\u003ci\u003eN\u003c/i\u003e - 1)\u003c/span\u003e, less than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e, so in total it gives \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e complexity for this solution. \u003c/p\u003e\u003cp\u003eSubmission: \u003ca href\u003d\"/contest/475/submission/8168350\" title\u003d\"Submission 8168350 by marat.snowbear\"\u003e8168350\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href\u003d\"/contest/475/problem/F\" title\u003d\"Bayan 2015 Contest Warm Up\"\u003e475F - Meta-universe\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLet\u0027s try to solve this problem naively first, the approach should be obvious then — you have a set of points, you iterate them left to right and you mind the gap between them. If there is such a gap between two neighbours you split this meta-universe with vertical line and do the same thing for each of two subsets. If you found no such gap by going left to right, you do the same going top to bottom. If you are unlucky again then you are done, this is a universe, it cannot be split. Let\u0027s think about the complexity of this approach now, even if get the points sorted and split for free then the complexity will highly depend on how soon you found a place where you could split the meta-universe. For example if you are lucky and you will always split close to the start of the sequence then your total complexity would be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e, which is very good indeed. If you will encounter the option to split somewhere in the middle of the sequence, which means that you split the meta-universe in two halves, you will get a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e solution, not linear but still good enough for this problem. The worst case occurs when you split always after iterating through the entire sequence, that means that in order to extract one point from the set you will have to iterate through all of them, now the complexity becomes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e, that\u0027s not enough already. \u003c/p\u003e\u003cp\u003eLet\u0027s think about it again, we got several cases, two of them are good (when we split in the beginning or in the middle) and the third one is too slow, it happens when we split always in the end. We need to make our solution better in this particular case and that should be almost enough to solve the entire problem. The obvious approach how to get rid of \u0026quot;split at the end\u0026quot; case is to start iterating from the end initially. And it should be obvious as well that it doesn\u0027t change much because your old start becomes the end now. But what we can do instead is to start iterating from both sides, then in any case you are winner! Intuitively, if you encountered a way to split at some end of the sequence then you\u0027re good to go because you spent almost no time on this particular step and you already found a way to split it further. In the opposite case, if you had to iterate through the entire sequence and found a split point in the middle you should be still happy about it because it means that on the next steps each of your new sets will be approximately two times smaller, that leads you back to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e complexity. Also you should not forget that you need to do the same for Y coordinate as well, that means that you need to have four iterators and you need to check them simultaneously. \u003c/p\u003e\u003cp\u003eThis is the basic idea for my solution, there is just one more detail to be added. Initially I told that our complexity estimate is given if we \u0026quot;sort and split for free\u0026quot;. That\u0027s not that easy to achieve, but we can achieve something else almost as good as this one. In order to split cheaply all you need to do is to avoid the actual split :-) Instead of splitting the sequence into two subsequences you can just leave the original sequence and extract part of it which will become a new subsequence. Obviously if you want to make this operation cheaper you need to extract the smaller part. For example if you have a sequence of points sorted by X and you found a split point by iterating from the end of the sequence then you can be sure that the right subsequence will not be longer than the left sequence, because you iterate from the left-hand side and from the right-hand side simultaneously. Now we need to take care about sorting part as well. This one is easy, all you need to do is instead of storing one sequence of points you store all the points in two sorted sets — one by X and one by Y coordinate. In total this should add just one more logarithmic factor to the complexity. \u003c/p\u003e\u003cp\u003eThat is the entire solution, I\u0027d like to get back one more time to the complexity analysis. We have a recurring algorithm, on every step of the recurrence we\u0027re looking for the split point, then we split and invoke this recurring algorithm two more times. It looks that for the worst case (which is split in the middle) we will split a sequence into two subsequences of the same size, so we have a full right to apply a \u003ca href\u003d\"http://en.wikipedia.org/wiki/Master_theorem\"\u003eMaster theorem\u003c/a\u003e here. On each step our complexity seems to be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e (log factor because of using sets) so the \u0026quot;Case 2. Generic form\u0026quot; section from the Wiki gives us a solution that our entire algorithm has an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlog\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e time complexity. Am I correct? \u003c/p\u003e\u003cp\u003eMy submission — \u003ca href\u003d\"/contest/475/submission/8138406\" title\u003d\"Submission 8138406 by marat.snowbear\"\u003e8138406\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["editorial","bayan","bayan2014"]}}