{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1516632569,"rating":6,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1516632569,"id":57281,"title":"\u003cp\u003eNotes on Codeforces Beta Round #110, Div2- A, B, C, D, E, Div1-D (Caylay\u0027s formula and prufer sequence)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/157/problem/A\" title\u003d\"Codeforces Round 110 (Div. 2)\"\u003e157A - Game Outcome\u003c/a\u003e\u003c/p\u003e\u003cp\u003eStraightforward implementation.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/157/problem/B\" title\u003d\"Codeforces Round 110 (Div. 2)\"\u003e157B - Trace\u003c/a\u003e\u003c/p\u003e\u003cp\u003eCalculate the answer based on whether the given number is odd or even.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/157/problem/C\" title\u003d\"Codeforces Round 110 (Div. 2)\"\u003e157C - Message\u003c/a\u003e\u003c/p\u003e\u003cp\u003eOne should observe that inserting a letter at any end of the string is always equivalent to the following operation: we insert an auxiliary (or dummy) letter first, for instance “*”, and then replace it with the desired letter. Besides, in fact we will never need implement any deleting operation, since on one hand, it is not necessary to take a longer string and delete some letters to make it have the same length as our target string; on the other hand, if we have taken the string with the same length, for instance, “abcd”, and the target string is “abce”, instead of first deleting “d” and then inserting “e”, we can directly replace “d” with “e”.\u003c/p\u003e\u003cp\u003eAccording to the above arguments, we can always only use replacement operations to obtain the target string, with the minimum number of modification. Therefore, suppose that the length of the target string is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and the given string has length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Then, we insert \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e auxiliary letters, for instance “*”, both to the head and end of string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to obtain a new string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u0027\u003c/span\u003e with length of \u003cspan class\u003d\"tex-span\"\u003e2\u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Next, we check all the substrings of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u0027\u003c/span\u003e with length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and find the one that has the minimum number of different letters corresponding to the same indices. This number just indicates how many replacement operations should be implemented.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/157/problem/D\" title\u003d\"Codeforces Round 110 (Div. 2)\"\u003e157D - Suspects\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe should first find out all the potential criminals. We check for each person that if he is the unique criminal, whether there are exactly \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e true claims. By some simple precalculation, we can find all the potential criminals with complexity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThen, for each person, we check the result of its claim. For “+i”, there are three possible cases: 1) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is the unique criminal; 2) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is not included in the set of potential criminals; 3) \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is not the only potential criminal. Similarly, there are also three cases for “-i”, and omitted here.\u003c/p\u003e\u003cp\u003eWe can adopt “set” to store the potential criminals, and thus we can handle any of the above cases with complexity of order \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003elogn\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/157/problem/E\" title\u003d\"Codeforces Round 110 (Div. 2)\"\u003e157E - Cipher\u003c/a\u003e\u003c/p\u003e\u003cp\u003eOne can check that no matter how many operations have been implemented, the sum of the string will always be the same. Two strings are equivalent if and only if they have both the same length and the same sum (I did not figure out how to prove this...).\u003c/p\u003e\u003cp\u003eTherefore, we can adopt dfs with memorization. We use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e to store the number of equivalent strings that have length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and sum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e, while using function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edfs\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e to denote the number of equivalent strings whose first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e letters have sum equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. When we reach \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edfs\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e, we should recursively call function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edfs\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e - 1, \u003ci\u003ej\u003c/i\u003e - 0)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edfs\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e - 1, \u003ci\u003ej\u003c/i\u003e - 1)\u003c/span\u003e,..., \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edfs\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e - 1, \u003ci\u003ej\u003c/i\u003e - 25)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e means letter “a”, and in fact we are enumerating from “a” to “z” for the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th position (remember to memorize the answers in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eOne could also calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edp\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e in previous, and this is less time comsuming than the above method.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/156/problem/D\" title\u003d\"Codeforces Round 110 (Div. 1)\"\u003e156D - Clues\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis turns out to be another classic problem !! One can check Caylay\u0027s formula for some preliminaries. \u003c/p\u003e\u003cp\u003eThis problem can be viewed as an advanced version of Caylay\u0027s formula. For the original version, all the nodes are simple nodes, while in this problem, one node may be a “big node”, which in fact is a connected component.\u003c/p\u003e\u003cp\u003eThe proof for this advanced version can be found in the Russian tutorials (I use google translation and I think it works quite well)...\u003c/p\u003e\u003c/div\u003e","tags":[]}}