{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1433444296,"rating":126,"authorHandle":"subscriber","modificationTimeSeconds":1433452253,"id":18331,"title":"\u003cp\u003eSRM 660 d1hard (hi, I\u0027m a beginner)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi, It\u0027s my first blogpost on codeforces.\u003c/p\u003e\u003cp\u003eI was preparing problems for today srm and now want to tell about hardest problem from problemset.\u003c/p\u003e\u003cp\u003eThis is a short editorial for srm 660 div1hard problem.\u003c/p\u003e\u003cp\u003eYou probably should not read it if you dont know the problem yet and want to train to solve hard problems by yourself :)\u003c/p\u003e\u003cp\u003eHere is a \u003ca href\u003d\"http://community.topcoder.com/stat?c\u003dproblem_statement\u0026amp;pm\u003d13696\"\u003elink\u003c/a\u003e for the statement.\u003c/p\u003e\u003cp\u003eFirst you can see that morphing operation is reversible(if you can transform array a to array b, then you can also transform b to a by the same operation). So if you imagine that arrays are vertices of some graph where two arrays is connected if it\u0027s possible to transform one from another, the minimal number of vertices needed so any can be reached is just a number of connected components in this graph.\u003c/p\u003e\u003cp\u003eNow I say that this problem about counting non-isomorphic directed graphs with outgoing degree 1 and ingoing at most k. You can see why :)\u003c/p\u003e\u003cp\u003eFirst lets consider that some array is a matrix of 0s and 1s. For each i, lets put 1 in cell(i, a[i]) in matrix. We\u0027ve got a matrix with one 1 in each row and at most k 1s in each column. So there is a bijection between arrays and matrixes. It should to be noticed that morphing operation works on matrix as swap of two rows (x, y), and two columns (x, y).\u003c/p\u003e\u003cp\u003eOk. We know that matrix of 0s and 1s could be used as presentation of directed unweighted graph. So not lets consider that array from this problem is directed graph, additional requarement is that outgoing degree of each vertes is 1 and ingoing is at most k. And finally morphing operation is just a swap of indexes of two vertexes.\u003c/p\u003e\u003cp\u003ePicture shows what happens with array {2,3,2,4} and corresponding matrix and graph when morph operation (2,3) applied.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/77/d0/77d0c20098f7f4a4ed4b35e7f86612c702c15762.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003ePossibility to swap two indexes makes possible to renumber vertices in any way. It means that one graph can be reached from other if and only if they are isomorphic! So if we count the number of non-isomorphic graphs we\u0027ll get required number of equivalence classes. Limitation on outgoing degree(\u003d1) makes it possible to count this number in polynomial time.\u003c/p\u003e\u003cp\u003eEveryone knows that this graphs look as several suns (each component is cycle with some trees connected to its vertices). \u003cimg alt\u003d\" \" src\u003d\"/predownloaded/ed/01/ed01c63790b4398c1b23ac97f449a1838c560670.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eFirst step is to count the number of rooted trees(with no more than k childs in each vertex). It\u0027s not very hard, you just need to remember not to count isomorphic ones few times, consider rooted tree as unordered list of rooted trees.\u003c/p\u003e\u003cp\u003eNext step is to count the number of non-isomorphic suns. If we consider sun as ordered list of rooted trees(with number of childs in root at most k-1), the only mistake that will occur, is that two lists should not be counted twice if they are cyclic shift of each other. If you are familiar with Burnside\u0027s lemma you know how to fix it. Here is just a simple case, you can count the number of different strings when you know the number of all.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e//all[i] - number of all strings.\n//g[i] - number of different strings without lesser period (two strings are equal if one is cyclic shift of another).\n//res[i] - number of different strings (two strings are equal if one is cyclic shift of another).\n\nforeach(i) {\n\tg[i] \u003d all[i]\n\tforeach(j \u0026lt; i : i % j \u003d\u003d 0) g[i] -\u003d g[j] * j;\n\tg[i] /\u003d i //all strings here have period i and each is counted i times\n}\nforeach(i) {\n\tres[i] \u003d 0;\n\tforeach(j \u0026lt;\u003d i : i % j \u003d\u003d 0) res[i] +\u003d g[j];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn this problem you also need to remember sizes of everything, so it adds one more parameter size to all arrays.\u003c/p\u003e\u003cp\u003eThe final part is to collect suns in whole graph, same as in tree counting need to consider graph as unordered list of suns.\u003c/p\u003e\u003cp\u003eThe fact that no one could solve this problem in round time made me sad, but I hope you like this problem and will solve it even without this editorial :)\u003c/p\u003e\u003c/div\u003e","tags":[]}}