{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1456780098,"rating":113,"authorHandle":"ecnerwala","modificationTimeSeconds":1456783151,"id":43467,"title":"\u003cp\u003e8VC Venture Cup 2016 — Final Round Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/635/problem/A\" title\u003d\"8VC Venture Cup 2016 - Final Round (Div. 2 Edition)\"\u003e635A - Orchestra\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eWe can iterate over each possible rectangle and count the number of violists enclosed. This can be optimized with rectangular prefix sums, though the simple brute force is sufficient for this problem.\u003c/p\u003e\u003cp\u003eRuntime: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e6\u003c/sup\u003e)\u003c/span\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/634/problem/A\" title\u003d\"8VC Venture Cup 2016 - Final Round (Div. 1 Edition)\"\u003e634A - Island Puzzle\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eNotice that, as we move the empty pedestal around the circle, we cyclically permute the statues (and the empty pedestal can be anywhere). Thus, we can reach one state from another if and only if, after removing the empty pedestal, they are cyclic shifts of each other. The starting and ending configurations are permutations, so we can check this in linear time.\u003c/p\u003e\u003cp\u003eRuntime: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/627/problem/A\" title\u003d\"8VC Venture Cup 2016 - Final Round\"\u003e627A - XOR Equation\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eFor any two integers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, we have \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/2b/8a/2b8a72b04cdf596d78079b9fbd051f05d64827c9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, where \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/32/eb/32eb11ca3b3e1412a8a8cf28f1e899063f73cd50.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is the xor and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u0026amp;\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e is the bitwise AND. This is because \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7b/ea/7beade55e90846d70020a3d03521d3458b66751b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e is non-carrying binary addition. Thus, we can find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u0026amp;\u003ci\u003eb\u003c/i\u003e \u003d (\u003ci\u003es\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e) / 2\u003c/span\u003e (if this is not an integer, there are no solutions).\u003c/p\u003e\u003cp\u003eNow, for each bit, we have \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e cases: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/da/9f/da9f1d0f8d24f8520ecfb07a352ee07f957049db.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, and \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ee/e2/eee2e90c852bf2914218eefeca67c478e6396452.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. If \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1a/6c/1a6cfe5971b353cc1d21ea9224a94316a8dcd48d.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, then \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, so we have one possibility: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u0026amp;\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. If \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/fd/8d/fd8d87e6cdc4012cbf8897f181ab476f6b6a2f7c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, then we must have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u0026amp;\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 0\u003c/span\u003e (otherwise we print \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e), and we have two choices: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 0\u003c/span\u003e or vice versa. Thus, we can return \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e is the number of one-bits in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. (Remember to subtract \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e for the cases \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d 0\u003c/span\u003e or \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e \u003d 0\u003c/span\u003e if necessary.)\u003c/p\u003e\u003cp\u003eRuntime: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4f/ca/4fcab5be94d2636f4ce6a1b44117e9d69302e1be.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/627/problem/B\" title\u003d\"8VC Venture Cup 2016 - Final Round\"\u003e627B - Factory Repairs\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eUsing two binary-indexed trees, we can maintain the prefix and suffix sums of the amounts we can produce with maximum production rates of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e, respectively. Then we can just query the binary-indexed trees to find the maximum possible production given the start and end of the repairs.\u003c/p\u003e\u003cp\u003eRuntime: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/1f/cf/1fcfbb5eb86ad0f70b16afccea3ad8c84bc0f8d3.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/627/problem/C\" title\u003d\"8VC Venture Cup 2016 - Final Round\"\u003e627C - Package Delivery\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eWe solve this with a greedy algorithm: for each gas station, we fill our tank to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003emin\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e, \u003ci\u003ed\u003c/i\u003e)\u003c/span\u003e liters of gasoline, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e is the distance to the next gas station with cheaper (or equal) gas. This is optimal, as, if we can make it to a station with cheaper gas without buying expensive gas, we should (and fill up our tank at the cheaper station). Otherwise, all stations within range \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e are more expensive, so we should buy as much gas as possible right now.\u003c/p\u003e\u003cp\u003eAlternatively, if we say that we always “use” the gasoline we buy in the order we buy it, then the gasoline used in the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003eth unit must have been purchased within the last \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e units. Then we can greedily use the cheapest gas within the last \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e miles. We can maintain this in a queue with range-min-query, which gives us linear runtime (after sorting).\u003c/p\u003e\u003cp\u003eRuntime: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ac/36/ac36dbafdcbd9d6dec78253d2bc93f03352f5cae.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/627/problem/D\" title\u003d\"8VC Venture Cup 2016 - Final Round\"\u003e627D - Preorder Test\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eWe binary search on the answer, so we need to answer queries of the following form: is the a depth-first search traversal such that the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e vertices all have value at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e? We can answer this with a greedy tree-DP: for each subtree, we compute whether or not all its vertices have value at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, and if not, the longest possible prefix with all values at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. Then, our transition function can be greedy: the maximum possible prefix with all values at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e is the sum of the sizes of all child subtrees which are all at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e plus the largest prefix of all child subtrees.\u003c/p\u003e\u003cp\u003eRuntime: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/20/a8/20a8762d067caf71762b17b146c0777fd113d4f8.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/627/problem/E\" title\u003d\"8VC Venture Cup 2016 - Final Round\"\u003e627E - Orchestra\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eWe can think of a rectangle in the grid as a pair of an \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003exlo\u003c/i\u003e, \u003ci\u003exhi\u003c/i\u003e)\u003c/span\u003e interval and a \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eylo\u003c/i\u003e, \u003ci\u003eyhi\u003c/i\u003e)\u003c/span\u003e interval. Suppose we fix the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e-interval and want to determine the number of corresponding \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e intervals which create rectangles containing at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e violists. Given a sorted list of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e-coordinates of all violists in the range, this is simple: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e violists split the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/span\u003e-coordinates into \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e + 1\u003c/span\u003e (possibly empty) intervals that span all the columns, and the number of total intervals that work is simply the number of pairs of points that are at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e intervals apart.\u003c/p\u003e\u003cp\u003eAs we sweep over the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exhi\u003c/i\u003e\u003c/span\u003e coordinate and maintain the list of violists, we want to insert each violist into a sorted list and look at its \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e nearest neighbors to determine the change in number of intervals. Inserting violists into a sorted list, however, is difficult to do in constant time. Instead, we sweep in reverse. Start with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exhi\u003c/i\u003e \u003d \u003ci\u003er\u003c/i\u003e\u003c/span\u003e and a linked list containing all the desired violists; decrementing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003exhi\u003c/i\u003e\u003c/span\u003e is now a simple process of removing the necessary elements from a linked list and examining their neighbors as we do so.\u003c/p\u003e\u003cp\u003eRuntime: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003er\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003ci\u003ek\u003c/i\u003e + \u003ci\u003ernk\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/627/problem/F\" title\u003d\"8VC Venture Cup 2016 - Final Round\"\u003e627F - Island Puzzle\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eFirst, if we never move the empty pedestal through any cycle, then moving the empty pedestal to and from any given position cannot change the location of the statues, as performing a move in the opposite direction as the previous undoes the previous move.\u003c/p\u003e\u003cp\u003eThus, in our graph with one cycle, we can only do the following two operations: move the empty pedestal from one location to another (without loss of generality, only using the original tree), and cyclically permute the elements along the one cycle (except the element closest to the root).\u003c/p\u003e\u003cp\u003eNow, to check satisfiability, we can greedily first move the empty pedestal from its start position to its end position -- since this procedure can be undone, it will never change the satisfiability of the rearrangement. Then, we only have to check that all changed elements lie on a possible cycle. This uniquely determines the edge to be added.\u003c/p\u003e\u003cp\u003eTo compute the minimum number of moves, we compute the minimum moves to move the empty pedestal from the start to the cycle, the minimum moves to permute the cycle as desired, and the minimum moves from the cycle to the end point.\u003c/p\u003e\u003cp\u003eRuntime: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}