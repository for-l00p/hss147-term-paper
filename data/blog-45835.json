{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1467441301,"rating":239,"authorHandle":"Al.Cash","modificationTimeSeconds":1485723174,"id":45835,"title":"\u003cp\u003eFast and furious C++ I/O\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eFor a long time I\u0027ve been upset with C++ standard input/output. First of all, I heard that \u003ccode\u003efread\u003c/code\u003e/\u003ccode\u003efwrite\u003c/code\u003e are much faster than everything else, and it\u0027s impossible to get good times on problems with huge input or output without using those. Secondly, it\u0027s really annoying to write formatting string and ampersands in \u003ccode\u003escanf\u003c/code\u003e, especially with many variables to read. Thirdly, the only way to expand I/O to custom types is by overloading \u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e and \u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e operators on streams, but they are the slowest. I tried to tackle all these issues in my implementation. Remember, that it\u0027s targeted for the common use case in programming contests, so it\u0027s not as flexible as one might wish.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/X1tP8Q\"\u003eThe code is here\u003c/a\u003e \u003cstrong\u003eDoesn\u0027t compile with MSVS.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eI apologize in advance to everyone, who will be scrolling through this 500 lines trying to read my solutions. Also it\u0027s not advised for people without broad experience with C++ to try to understand the entirety of it (dangerous for your mental health). There are 3 major components.\u003c/p\u003e\u003ch3\u003e1. File management\u003c/h3\u003e\u003cp\u003eThis is done by classes \u003ccode\u003eInputFile\u003c/code\u003e and \u003ccode\u003eOutputFile\u003c/code\u003e. Indeed, I use \u003ccode\u003efread\u003c/code\u003e/\u003ccode\u003efwrite\u003c/code\u003e with a buffer of size \u003cspan class\u003d\"tex-span\"\u003e2\u003csup class\u003d\"upper-index\"\u003e12\u003c/sup\u003e\u003c/span\u003e, but there is one catch. \u003ccode\u003efread\u003c/code\u003e doesn\u0027t work for interactive problems, because input isn\u0027t fully buffered there, it\u0027s line buffered. I use \u003ccode\u003efgets\u003c/code\u003e in this case, but make sure to call correct constructor, it should look like this (input and output are smart pointers):\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#ifdef ONLINE_JUDGE\n  input.reset(new InputFile(stdin, false));    // usual problem\n  input.reset(new InputFile());                // interactive problem\n  output.reset(new OutputFile());\n#else\n  input.reset(new InputFile());                // local testing using a console\n  input.reset(new InputFile(\u0026quot;input.txt\u0026quot;));     // local testing using a file\n  output.reset(new OutputFile());              // output to console\n  output.reset(new OutputFile(\u0026quot;output.txt\u0026quot;));  // output to a file\n#endif\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAlso it\u0027s possible to read or write to a string using \u003ccode\u003eInputString\u003c/code\u003e and \u003ccode\u003eOutputString\u003c/code\u003e classes. They are used similarly:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estring s;\ninput.reset(new InputString(s));\noutput.reset(new OutputString(s));\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e2. String parsing\u003c/h3\u003e\u003cp\u003eNext step is to convert standard types to/from a buffer of characters. To my deepest disappointment, even this problem isn\u0027t solved efficiently in standard C++ library. Just look at this benchmarks (situation with \u003cem\u003eatoi\u003c/em\u003e and \u003cem\u003eatod\u003c/em\u003e is similar):\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttps://github.com/miloyip/itoa-benchmark\u003cbr /\u003e\u003c/a\u003e \u003ca href\u003d\"https://github.com/miloyip/dtoa-benchmark\"\u003ehttps://github.com/miloyip/dtoa-benchmark\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI didn\u0027t want to go too deep, so I used the simplest code to read/write integer types similar to this one \u003ca href\u003d\"/contest/645/submission/16792284\" title\u003d\"Submission 16792284 by Burunduk1\"\u003e16792284\u003c/a\u003e. Then, I cheated with double treating it as two integers separated by a decimal point. This approach won\u0027t work for huge numbers or precision of more than 18 digits after the decimal point, but I\u0027ve never seen such cases in the programming contests. All related methods are located inside \u003ccode\u003eInputDevice\u003c/code\u003e and \u003ccode\u003eOutputDevice\u003c/code\u003e classes.\u003c/p\u003e\u003ch3\u003e3. User interface\u003c/h3\u003e\u003cp\u003eEverything above was about being efficient. But the main goal during a contest is to code fast, so I wrapped all the efficiency into functions \u003ccode\u003eread\u003c/code\u003e/\u003ccode\u003ewrite\u003c/code\u003e, similar to \u003ccode\u003escanf\u003c/code\u003e/\u003ccode\u003eprintf\u003c/code\u003e. Of course, they offer much more. You don\u0027t need to write format strings. Range input and output are supported. You can read a string until the character satisfies some termination criterion. Write will insert delimiters for you automatically and can be configured with \u003ccode\u003esetPrecision\u003c/code\u003e, \u003ccode\u003esetFill\u003c/code\u003e and other modifiers similar to the ones in \u003ca href\u003d\"http://en.cppreference.com/w/cpp/header/iomanip\"\u003eiomanip header\u003c/a\u003e. Full list of supported parameters is given in the comment after the code. Here\u0027s an example of reading and writing \u003cem\u003en\u003c/em\u003e, \u003cem\u003em\u003c/em\u003e, then \u003cem\u003en\u003c/em\u003e by \u003cem\u003em\u003c/em\u003e character grid (without whitespaces), then array \u003cem\u003ea\u003c/em\u003e of length \u003cem\u003en\u003c/em\u003e, then array \u003cem\u003eb\u003c/em\u003e of length \u003cem\u003em\u003c/em\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003econst int N \u003d 1001;\nint n, m;\nchar s[N][N];\nint a[N], b[N];\n\nread(n, m, s, n, a, n, b, m);\nwriteln(n, m, \u0027\\n\u0027, setDelimiter(\u0026quot;\\n\u0026quot;), s, n);\nwriteln(setDelimiter(\u0026quot;, \u0026quot;), a, n, \u0027\\n\u0027, b, m);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnother feature is extensibility, for example you can create your own \u003ccode\u003ePoint\u003c/code\u003e class, implement \u003ccode\u003eread\u003c/code\u003e and \u003ccode\u003ewrite\u003c/code\u003e methods for it, and use it later combined with all other features, for example read an array and then 2 more points.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etemplate \u0026lt;class T\u0026gt;\nstruct Point {\n  T x, y;\n\n  bool read(InputDevice\u0026amp; input) { return input.read(x, y); }\n  int write(OutputDevice\u0026amp; output) const { return output.write(x, \u0027,\u0027, y); }\n};\n\n// later in the code\nconst int N \u003d 1001;\nint n;\nPoint\u0026lt;int\u0026gt; p[N], s, t;\n\nread(n, p, n, s, t);\nwriteln(n, setDelimiter(\u0026quot;\\n\u0026quot;), p, n, s, setDelimiter(), t);\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eSpeed\u003c/h3\u003e\u003cp\u003eI spent a lot of time optimizing the code. To prove it, I included my methods in \u003ca href\u003d\"//codeforces.com/blog/entry/5217\"\u003ethis benchmark\u003c/a\u003e. Below are the results with clang compiler (my methods are named fast).\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003ebenchmark results\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003eint, printf         1.34   1.43   1.33\nint, cout           7.22   6.78   6.72\nint, custom/out     3.41   3.46   3.53\nint, fast/out       0.28   0.27   0.28\nint, scanf          1.20   1.21   1.14\nint, cin           24.93  25.29  26.27\nint, custom/in      3.08   3.04   3.02\nint, fast/in        0.14   0.14   0.15\ndouble, printf      3.17   3.20   3.16\ndouble, cout       12.60  12.67  12.76\ndouble, fast/out    0.60   0.61   0.59\ndouble, scanf       2.06   2.17   2.00\ndouble, cin        46.38  43.31  45.82\ndouble, fast/in     0.40   0.39   0.36\nchar, putchar       4.28   4.16   4.24\nchar, cout          6.37   6.57   6.68\nchar, fast/out      0.36   0.37   0.37\nchar, getchar       4.08   4.02   3.83\nchar, cin           4.95   5.03   5.21\nchar, fast/in       0.29   0.29   0.28\nchar *, printf      0.82   0.80   0.80\nchar *, puts        0.81   0.81   0.81\nchar *, cout       11.76  11.97  10.93\nchar *, fast/out    0.22   0.22   0.23\nchar *, scanf       0.89   0.89   0.93\nchar *, fgets       0.53   0.53   0.53\nchar *, cin        23.91  23.44  22.71\nchar *, fast/in     0.25   0.24   0.25\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch4\u003eUpdate 01/29/2017\u003c/h4\u003e \u003cul\u003e   \u003cli\u003eCustom types must implement member functions \u003ccode\u003eread\u003c/code\u003e and \u003ccode\u003ewrite\u003c/code\u003e to be supported.\u003c/li\u003e   \u003cli\u003e\u003ccode\u003eread\u003c/code\u003e now returns bool success flag instead of number of arguments read.\u003c/li\u003e   \u003cli\u003eFloating point write bug was fixed. It caused errors on numbers like \u003cspan class\u003d\"tex-span\"\u003e1 - ε\u003c/span\u003e because of rounding.\u003c/li\u003e   \u003cli\u003e\u003ccode\u003eis_iterator\u003c/code\u003e trait was implemented and SFINAE was improved. This fixed ambiguous overload resolution that happened in some cases.\u003c/li\u003e   \u003cli\u003e\u003ccode\u003ewrite\u003c/code\u003e and \u003ccode\u003eread\u003c/code\u003e methods were moved inside classes to improve flexibility. Out of class methods now simply forward the parameters.\u003c/li\u003e   \u003cli\u003eOversight was fixed which made calls like \u003ccode\u003ewrite(vector.begin(), vector.size())\u003c/code\u003e impossible, because only \u003ccode\u003eint\u003c/code\u003e size was supported.\u003c/li\u003e   \u003cli\u003e\u003ccode\u003ecomplex\u003c/code\u003e and \u003ccode\u003estring\u003c/code\u003e are now fully supported.\u003c/li\u003e   \u003cli\u003eSome erroneous calls could compile with unexpected results instead of giving CE. This was fixed.\u003c/li\u003e \u003c/ul\u003e\u003c/div\u003e","tags":["fast input","fast output"]}}