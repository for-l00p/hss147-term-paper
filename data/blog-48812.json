{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1480771791,"rating":38,"authorHandle":"dreamoon","modificationTimeSeconds":1480771791,"id":48812,"title":"\u003cp\u003eWeekly Training Farm #14 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThanks \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/drazil\" title\u003d\"Candidate Master drazil\"\u003edrazil\u003c/a\u003e to translate the \u003ca href\u003d\"http://dreamoon4.blogspot.tw/2016/11/14.html\"\u003eChinese editorial\u003c/a\u003e to English.\u003c/p\u003e\u003cp\u003eTwo of the problems in this week are created by modifying input constraints of recent Atcoder problems. The other three are a series of problems. Thus, in this editorial we won\u0027t follow the order of the problems but begin with the problems which are modified from Atcoder problems and put the series problems to the last.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/group/gRkn7bDfsN/contest/210166/problem/B\"\u003eProblem B — Write a Special Judge!\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThis problem is modified from \u003ca href\u003d\"http://agc007.contest.atcoder.jp/tasks/agc007_a\"\u003eAGC007 — Shik and Stone\u003c/a\u003e, which is originally created by Dreamoon as well. The difference in the Atcoder version is that the input must be a valid path (starting at the top left corner and ending at the bottom right corner). In fact, this modified version is the very first version proposed. But the contest organizers at Atcoder think this (modified) version is not easy enough resulting the constraint to the input. With the constraint we only need to verify whether the number of \u0027#\u0027s is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e - 1\u003c/span\u003e or not (you can justify why this solution will fail in the modified version).\u003c/p\u003e\u003cp\u003eAlthough we cannot count the number of \u0027#\u0027s directly in the modified version, this problem still has many ways to solve. Here we demonstrate a straightforward and easy to code one: Travel all cells in the order of left to right, top to bottom. Each time when we meet a \u0027#\u0027, check if it is to the right or bottom of the last met \u0027#\u0027. Also don\u0027t forget to make sure the first and the last \u0027#\u0027 are located at the top left and the bottom right cell respectively.\u003c/p\u003e\u003cp\u003ePS. Tester got accepted two times using incorrect code. Thanks him for making the test cases strong enough!\u003c/p\u003e\u003cp\u003eHere is the judge\u0027s code:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;cstdio\u0026gt;\nint main(){\n    int n,m;\n    scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\n    char s[12];\n    int x\u003d0,y\u003d1;\n    for(int i\u003d1;i\u0026lt;\u003dn;i++){\n        scanf(\u0026quot;%s\u0026quot;,s+1);\n        for(int j\u003d1;j\u0026lt;\u003dm;j++){\n            if(s[j]\u003d\u003d\u0027#\u0027){\n                if((i\u003d\u003dx\u0026amp;\u0026amp;j\u003d\u003dy+1)||(i\u003d\u003dx+1\u0026amp;\u0026amp;j\u003d\u003dy)){\n                    x\u003di;y\u003dj;\n                }\n                else return 0*puts(\u0026quot;Wrong Answer\u0026quot;);\n            }\n        }\n    }\n    if(x!\u003dn||y!\u003dm)puts(\u0026quot;Wrong Answer\u0026quot;);\n    else puts(\u0026quot;Accepted\u0026quot;);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/group/gRkn7bDfsN/contest/210166/problem/D\"\u003eProblem D — Edit Sequence\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThis problem is modified from \u003ca href\u003d\"http://arc063.contest.atcoder.jp/tasks/arc063_b\"\u003eARC063 — An Invisible Hand\u003c/a\u003e. The difference is that the input numbers in the modified version are not unique (and also we simply the statement a lot). To be honest I didn\u0027t realized that the numbers are unique while participating in ARC063 (so I was shocking that many of the contestants got accepted so fast ... and I find out I ignored that condition after the contest when I look at the solutions of other contestants).\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e) \u003d \u003ci\u003eh\u003c/i\u003e\u003c/span\u003e. Intuitively, we may list all numbers that contributes to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e) \u003d \u003ci\u003eh\u003c/i\u003e\u003c/span\u003e first, then modify some of them to make \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e)\u003c/span\u003e smaller. For example, when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d [3, 5, 3, 3, 5, 2, 3, 4, 3, 3, 2, 4, 1, 2, 3]\u003c/span\u003e. Now we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e \u003d 2\u003c/span\u003e and the contributing numbers are \u003cspan class\u003d\"tex-span\"\u003e[3, 5, 3, 3, 5, 2, \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e, 4, \u003c/span\u003e , , \u003cspan class\u003d\"tex-span\"\u003e2, 4, 1, , 3]\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIt\u0027s not hard to find out that we can split those contributing numbers into non-overlapping segments (such as \u003cspan class\u003d\"tex-span\"\u003e[3, 5, 3, 3, 5]\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e[2, 4, 2, 4]\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e[1, 3]\u003c/span\u003e in the above example) so that in each segment there are only two values and the lower values in each segment are decreasing (from left to right).\u003c/p\u003e\u003cp\u003eAfter splitting, we now need to further split each segment into two halves (with possibly an empty half). For each segment, if we modify all values in the left half to the larger values of the two and all values in the right half to the smaller value of the two, then the segment becomes valid. Again in the above example, \u003cspan class\u003d\"tex-span\"\u003e[5, 5, 3, 3, 3][4, 4, 2, 2], [3, 3]\u003c/span\u003e is one of the valid example. After all those modifications, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ea\u003c/i\u003e)\u003c/span\u003e becomes smaller!\u003c/p\u003e\u003cp\u003eSo the answer to the problem can be obtained by finding the smallest numbers of values need to be modified in each segment among all possible splits. A DP approach along with some simple counting can be utilized to get the answer in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e, details are in the code.\u003c/p\u003e\u003cp\u003eAt Codeforces, a contestant proposes exploiting the relation between matching and maximum flow to greedily compute the sub-answer for each segmentation. His code is HERE.\u003c/p\u003e\u003cp\u003eHere is the judge\u0027s code:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int INF \u003d 1023456789;\nconst int SIZE \u003d 200002;\nint A[SIZE],left_mi[SIZE],right_ma[SIZE];\nint solve(vector\u0026lt;int\u0026gt;\u0026amp; seq){\n    int now\u003d0,ret;\n    for(int i\u003d0;i\u0026lt;seq.size();i++){\n        if(seq[i]!\u003dseq[0])now++;\n    }\n    ret\u003dnow;\n    for(int i\u003d0;i\u0026lt;seq.size();i++){\n        if(seq[i]\u003d\u003dseq[0])now++;\n        else now--;\n        ret\u003dmin(ret,now);\n    }\n    return ret;\n}\nint main(){\n    int N,h\u003d0;\n    scanf(\u0026quot;%d\u0026quot;,\u0026amp;N);\n    for(int i\u003d1;i\u0026lt;\u003dN;i++)scanf(\u0026quot;%d\u0026quot;,\u0026amp;A[i]);\n    left_mi[0]\u003dINF;\n    for(int i\u003d1;i\u0026lt;\u003dN;i++){\n        left_mi[i]\u003dmin(left_mi[i-1],A[i]);\n    }\n    right_ma[N+1]\u003d-INF;\n    for(int i\u003dN;i\u0026gt;0;i--){\n        right_ma[i]\u003dmax(right_ma[i+1],A[i]);\n        h\u003dmax(h,right_ma[i]-left_mi[i-1]);\n    }\n    int low\u003dINF,an\u003d0;\n    vector\u0026lt;int\u0026gt;seq;\n    for(int i\u003d1;i\u0026lt;\u003dN;i++){\n        if(A[i]\u0026lt;low){\n            an+\u003dsolve(seq);\n            seq.clear();\n            low\u003dA[i];\n        }\n        if(A[i]\u003d\u003dlow+h)seq.push_back(A[i]);\n        else if(A[i]\u003d\u003dlow\u0026amp;\u0026amp;right_ma[i+1]\u003d\u003dlow+h)seq.push_back(A[i]);\n    }\n    an+\u003dsolve(seq);\n    printf(\u0026quot;%d\\n\u0026quot;,an);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/group/gRkn7bDfsN/contest/210166/problem/A\"\u003eProblem A — Score Distribution 1\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThis is the first problem of the series. Let\u0027s assume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ≤ \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e ≤ ... ≤ \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e since the order of scores doesn\u0027t matter. The minimum possible total score of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e problems is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e2/c2/e2c2e358c138d6766e02d08732bee7bf097813d1.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, while the maximum possible total score of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e problems is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/43/e9/43e9891a71d904d538eac42aed7dde8f107ba619.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. So the problem asks us to make sure the minimum score of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e problems is always strictly greater than the maximum score of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e problems for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e from \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e - 1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eOf course, we cannot calculate the summation in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e for each \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e separately. We must use a more efficient algorithm.\u003c/p\u003e\u003cp\u003eHere is the judge\u0027s code:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nconst int SIZE \u003d 200001;\nint p[SIZE];\nint main(){\n    int N;\n    scanf(\u0026quot;%d\u0026quot;,\u0026amp;N);\n    for(int i\u003d1;i\u0026lt;\u003dN;i++)scanf(\u0026quot;%d\u0026quot;,\u0026amp;p[i]);\n    sort(p+1,p+N+1);\n    long long left_part\u003dp[1],right_part\u003d0;\n    for(int i\u003d2;i\u0026lt;\u003dN;i++){\n        left_part+\u003dp[i];\n        right_part+\u003dp[N+2-i];\n        if(left_part\u0026lt;\u003dright_part)\n            return 0*printf(\u0026quot;bad\\n%d\\n\u0026quot;,i-1);\n    }\n    return 0*puts(\u0026quot;good\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/group/gRkn7bDfsN/contest/210166/problem/C\"\u003eProblem C — Score Distribution 2\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThis is the second problem of the series, from now on we assume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ≤ \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e ≤ ... ≤ \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIf you\u0027re guessing purely by looking at sample test cases, you may think that the answer is using binary search to find the smallest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e consecutive numbers that satisfy the constraints. But sorry, I\u0027m not a kind problem setter \u0026gt;_\u0026lt;. If you use this kind of methods, you may end up with values greater than \u003cspan class\u003d\"tex-span\"\u003e10\u003csup class\u003d\"upper-index\"\u003e9\u003c/sup\u003e\u003c/span\u003e. There are some other ways to get answers in the allowed range!\u003c/p\u003e\u003cp\u003eHere are some notations we will use later:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0e/3e/0e3ebd466fe7da9840ce9509110fe91eafcb7e3c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, which is the sum of the smallest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/span\u003e problems minus the sum of the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e largest problem.\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is bad if and only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ 0\u003c/span\u003e, in this case the condition is violated.\u003c/li\u003e   \u003cli\u003eAll division from now on is integer division.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eBefore solving this problem. Let\u0027s prove an important property of this series: If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is bad, then for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e ≤ \u003ci\u003ej\u003c/i\u003e ≤ (\u003ci\u003eN\u003c/i\u003e - 1) / 2\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e is bad.\u003c/p\u003e\u003cp\u003eProve: We can observed that Si first decreases then increases (actually non-increases and non-decreases). The minimum value in Si will occur at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e(\u003ci\u003eN\u003c/i\u003e - 1) / 2\u003c/sub\u003e\u003c/span\u003e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is bad means \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ 0\u003c/span\u003e, which indicates that all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eN\u003c/i\u003e - 1) / 2\u003c/span\u003e is bad since in that range \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is decreasing (actually non-increasing).\u003c/p\u003e\u003cp\u003eNote that from now on we define \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e(\u003ci\u003eN\u003c/i\u003e - 1) / 2\u003c/sub\u003e\u003c/span\u003e as the discriminant of the related sequence \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e, denoted as \u003cspan class\u003d\"tex-span\"\u003eΔ(\u003ci\u003ep\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFrom the property above, we know that if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ey\u003c/i\u003e \u0026gt; (\u003ci\u003eN\u003c/i\u003e - 1) / 2\u003c/span\u003e the answer must be Impossible, and we also know that in all other cases \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e ≤ 0\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eS\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e−1\u003c/sub\u003e \u0026gt; 0\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow we consider a special sequence p only consists of two values: the first \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eN\u003c/i\u003e + 1) / 2\u003c/span\u003e numbers are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e1\u003c/span\u003e and the last \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e / 2\u003c/span\u003e numbers are \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e2\u003c/span\u003e. Under this assumption we must satisfy \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e1 × \u003ci\u003ey\u003c/i\u003e \u0026gt; \u003ci\u003ev\u003c/i\u003e2 × (\u003ci\u003ey\u003c/i\u003e - 1)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e1 × (\u003ci\u003ey\u003c/i\u003e + 1) ≤ \u003ci\u003ev\u003c/i\u003e2 × \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e to comply with the condition. With some intuition we can see \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e1 \u003d \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e2 \u003d \u003ci\u003ey\u003c/i\u003e + 1\u003c/span\u003e perfectly fits the requirements!\u003c/p\u003e\u003cp\u003eHere is the judge\u0027s code:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include\u0026lt;bits/stdc++.h\u0026gt;\nint N,p[200001];\nint main(){\n    int x,y;\n    scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;x,\u0026amp;y);\n    N\u003dx;\n    if(y*2+1\u0026gt;N)puts(\u0026quot;Impossible\u0026quot;);\n    else{\n        printf(\u0026quot;%d\\n\u0026quot;,N);\n        for(int i\u003d1;i\u0026lt;\u003d(N+1)/2;i++)printf(\u0026quot;%d \u0026quot;,y);\n        for(int i\u003d(N+1)/2+1;i\u0026lt;\u003dN;i++)printf(\u0026quot;%d%c\u0026quot;,y+1,\u0026quot; \\n\u0026quot;[i\u003d\u003dN]);\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e\u003ca href\u003d\"//codeforces.com/group/gRkn7bDfsN/contest/210166/problem/E\"\u003eProblem E — Score Distribution 3\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThis is the third problem in the series, as usual we assume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ≤ \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e ≤ ... ≤ \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and integer division.\u003c/p\u003e\u003cp\u003eFirst we define a subsequence \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e \u003d \u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u003d \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/sub\u003e, \u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u003d \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/sub\u003e, ..., \u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e\u003c/span\u003e of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u0026lt; \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e... \u0026lt; \u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e) is good if and only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e satisfy the conditions (i.e. \u003cspan class\u003d\"tex-span\"\u003eΔ(\u003ci\u003eq\u003c/i\u003e) \u0026gt; 0\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eA key observation is that is that for a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and a related good subsequence \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e, if we keep all values in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e not changed and modify all other numbers in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e to the value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e(\u003ci\u003em\u003c/i\u003e + 2) / 2\u003c/sub\u003e\u003c/sub\u003e\u003c/span\u003e, then the modified \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u0027\u003c/span\u003e will become good because \u003cspan class\u003d\"tex-span\"\u003eΔ(\u003ci\u003ep\u003c/i\u003e\u0027) \u003d Δ(\u003ci\u003eq\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSecondly, we can see that if there exists some good \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e, then there exists some good \u0026quot;continuous\u0026quot; subsequence \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u0027\u003c/span\u003e of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e which is also good. One way of constructing such \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u0027\u003c/span\u003e is to take consecutive \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e values in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e where the \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003em\u003c/i\u003e + 1) / 2\u003c/span\u003e-th number in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u0027\u003c/span\u003e is the \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003em\u003c/i\u003e + 1) / 2\u003c/span\u003e-th number in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e (because \u003cspan class\u003d\"tex-span\"\u003eΔ(\u003ci\u003eq\u003c/i\u003e\u0027) ≤ Δ(\u003ci\u003eq\u003c/i\u003e)\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eLast key observation: if a continuous subsequence \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e is good, then any continuous subsequence of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e is also good.\u003c/p\u003e\u003cp\u003eProve:  Assume \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e is of length \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e. We construct \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u0027\u003c/span\u003e by removing the rightmost value in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e is even, \u003cspan class\u003d\"tex-span\"\u003eΔ(\u003ci\u003eq\u003c/i\u003e) - \u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e / 2 + 1\u003c/sub\u003e + \u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e \u003d Δ(\u003ci\u003eq\u003c/i\u003e\u0027)\u003c/span\u003e. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e is odd, \u003cspan class\u003d\"tex-span\"\u003eΔ(\u003ci\u003eq\u003c/i\u003e) - \u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e(\u003ci\u003em\u003c/i\u003e + 1) / 2\u003c/sub\u003e + \u003ci\u003eq\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/sub\u003e \u003d Δ(\u003ci\u003eq\u003c/i\u003e\u0027)\u003c/span\u003e. So we have \u003cspan class\u003d\"tex-span\"\u003eΔ(\u003ci\u003eq\u003c/i\u003e′) ≥ Δ(\u003ci\u003eq\u003c/i\u003e)\u003c/span\u003e, that means a good subsequence is still good if the rightmost value is removed. A similar prove can show that this conclusion holds for removing the leftmost value. In addition, any continuous subsequence of q can be obtained by removing values from left or right in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eq\u003c/i\u003e\u003c/span\u003e, q.e.d.\u003c/p\u003e\u003cp\u003eAt this point, the problem is identical to find the longest continuous good subsequence. We can iterate all right boundaries and binary search for the left boundary to find the longest good continuous subsequence. Note that to check a continuous subsequence q is good or not only required \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e time after \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e preprocessing since we only need to know \u003cspan class\u003d\"tex-span\"\u003eΔ(\u003ci\u003eq\u003c/i\u003e)\u003c/span\u003e. Also note that if the input is sorted there exists an \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e)\u003c/span\u003e solution.\u003c/p\u003e\u003cp\u003eHere is the judge\u0027s code:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#define SZ(X) ((int)(X).size())\n#define MP make_pair\n#define PB push_back\n#define PII pair\u0026lt;int,int\u0026gt;\n#define VPII vector\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt;\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int SIZE \u003d 200*1000+1;\nVPII pp;\nlong long sum[SIZE];\nint an[SIZE];\nint main(){\n    int N;\n    scanf(\u0026quot;%d\u0026quot;,\u0026amp;N);\n    pp.PB(MP(0,0));\n    for(int i\u003d1;i\u0026lt;\u003dN;i++){\n        int x;\n        scanf(\u0026quot;%d\u0026quot;,\u0026amp;x);\n        pp.PB(MP(x,i));\n    }\n    sort(pp.begin(),pp.end());\n    for(int i\u003d1;i\u0026lt;\u003dN;i++){\n        sum[i]\u003dsum[i-1]+pp[i].F;\n    }\n    int ma\u003d1,anL\u003d1,anR\u003d2;\n    for(int i\u003dN;i\u0026gt;ma;i--){\n        int ll\u003d1,rr\u003di-1;\n        while(ll\u0026lt;rr){\n            int mm\u003d(ll+rr)/2;\n            if(sum[(mm+i)/2]-sum[mm-1]\u0026gt;sum[i]-sum[(mm+i+1)/2])rr\u003dmm;\n            else ll\u003dmm+1;\n        }\n        if(ma\u0026lt;i-ll+1){\n            ma\u003di-ll+1;\n            anL\u003dll;\n            anR\u003di+1;\n        }\n    }\n    int v\u003dpp[(anL+anR)/2].first;\n    for(int i\u003d1;i\u0026lt;anL;i++)an[pp[i].second]\u003dv;\n    for(int i\u003danL;i\u0026lt;anR;i++)an[pp[i].second]\u003dpp[i].first;\n    for(int i\u003danR;i\u0026lt;\u003dN;i++)an[pp[i].second]\u003dv;\n    for(int i\u003d1;i\u0026lt;\u003dN;i++)printf(\u0026quot;%d%c\u0026quot;,an[i],\u0026quot; \\n\u0026quot;[i\u003d\u003dN]);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["weekly training farm","taiwan"]}}