{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1413574174,"rating":87,"authorHandle":"I_love_Hoang_Yen","modificationTimeSeconds":1417115049,"id":14319,"title":"\u003cp\u003e[GYM] 2014-2015 CT S02E06 — Solution\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100506/problem/A\" title\u003d\"2014-2015 CT S02E06: Codeforces Trainings Season 2 Episode 6 - 2007 Benelux Algorithm Programming Contest (BAPC 2007)\"\u003e100506A - Average distance\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFor this problem, you need to calculate:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e(\u003ci\u003edistance\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)) / (\u003ci\u003esome\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003econstant\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003eHow to calculte \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e(\u003ci\u003edistance\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e))\u003c/span\u003e efficiently? Obviously, you cannot iterate through all pair of vertices u and v. That would take at least \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWhen calculating the sum, notice that you need to add one edge multiple times. There are only N edges, but for each edge, in naive solution, you added it multiple times. So now you can see an idea for optimizing the naive solution: For each edge, count how many times it appear in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esum\u003c/i\u003e(\u003ci\u003edistance\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e))\u003c/span\u003e and add it to result.\u003c/p\u003e\u003cp\u003eTurns out this is quite simple: For edge \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e where u is parent of v in the tree, the path going through it must have the form: \u0026quot;something --\u0026gt; u --\u0026gt; v --\u0026gt; something\u0026quot;. The number of such path is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esize\u003c/i\u003e(\u003ci\u003esubtree\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e)) * (\u003ci\u003en\u003c/i\u003e - \u003ci\u003esubtree\u003c/i\u003e(\u003ci\u003ev\u003c/i\u003e))\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/DLQFOJ\"\u003eMy code\u003c/a\u003e \u003ca href\u003d\"/gym/100506/problem/B\" title\u003d\"2014-2015 CT S02E06: Codeforces Trainings Season 2 Episode 6 - 2007 Benelux Algorithm Programming Contest (BAPC 2007)\"\u003e100506B - Bus Pass\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s call the vertices which at least one bus trip go through \u0026quot;important vertices\u0026quot;. It is easy to see that there are at most 200 important vertices (10 trips * 20 each).\u003c/p\u003e\u003cp\u003eSo for each important vertex, you can do BFS to calculate the distance to every other vertices. --\u0026gt; You get all distance from every vertex to each important vertex. Using this information, it is quite simple to get the result.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/kOyz0C\"\u003eMy code\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100506/problem/C\" title\u003d\"2014-2015 CT S02E06: Codeforces Trainings Season 2 Episode 6 - 2007 Benelux Algorithm Programming Contest (BAPC 2007)\"\u003e100506C - Cutting Banknotes\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirst let\u0027s get rid of floating numbers by multiply everything with 100. Now, because dividing the notes by 2 is always better, split each note until you cannot (e.g. for note with value 2.00, multiply it by 100 --\u0026gt; 200, and then split it to 100, then 50, then 25. For note with value 3.00, multiply it by 100 --\u0026gt; 300, and then split it to 150, then 75). After doing this, the problem becomes, given a set of notes, check if you can use these notes to make certain sum (note that you can subtract). In math, this is check if an integer S can be represented as:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e * \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e + \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e * \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e + ...\u003c/span\u003e\u003c/p\u003e\u003cp\u003efor some constants \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ...\u003c/span\u003e\u003c/p\u003e\u003cp\u003eNow this is application of \u003ca href\u003d\"http://mathworld.wolfram.com/LinearCongruenceEquation.html\"\u003econgruence equation\u003c/a\u003e, which to check if there is a solution, you just need to check if everything is divisible by gcd.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/kFCVUs\"\u003eMy code\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100506/problem/D\" title\u003d\"2014-2015 CT S02E06: Codeforces Trainings Season 2 Episode 6 - 2007 Benelux Algorithm Programming Contest (BAPC 2007)\"\u003e100506D - Dice Password Security\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is a dynamic programming problem.\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e) \u003d \u003c/span\u003e number of ways to use exactly N words to get a string of length j.\u003c/p\u003e\u003cp\u003eThen, to calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e, consider all word that can be added next --\u0026gt; you can use \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e to update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003el\u003c/i\u003e + \u003ci\u003ea\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e))\u003c/span\u003e, with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d \u003c/span\u003e some string length\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/wge73M\"\u003eMy code\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100506/problem/E\" title\u003d\"2014-2015 CT S02E06: Codeforces Trainings Season 2 Episode 6 - 2007 Benelux Algorithm Programming Contest (BAPC 2007)\"\u003e100506E - Lingo\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis problem requires \u003ca href\u003d\"http://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle\"\u003einclusion exclusion principle\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThe basic idea is to loop through all subsets and calculate the necessary probabilities.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/23W9YH\"\u003eMy code\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100506/problem/F\" title\u003d\"2014-2015 CT S02E06: Codeforces Trainings Season 2 Episode 6 - 2007 Benelux Algorithm Programming Contest (BAPC 2007)\"\u003e100506F - Splitting the Loot\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s say you\u0027re given N gold bar of weight \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. What is the smallest weight that you need?\u003c/p\u003e\u003cp\u003eInterestingly, this is a well known problem: \u003ca href\u003d\"http://en.wikipedia.org/wiki/Huffman_coding\"\u003eHuffman encoding\u003c/a\u003e. To solve it, you just need to use the following greedy: take 2 smallest bar, merge them into one. Repeat until you have only 1 gold bar left. The length of this gold bar is the result.\u003c/p\u003e\u003cp\u003eNow you have a way to check if you can divide the given gold to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. You can easily take care of \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e case. But how to find answer in other case? You can use Binary search! Let\u0027s say you want to check if you can keep X gram. You just need to run the above algorithm to check if you can divide the initial gold bar to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/tHUocB\"\u003eMy code\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100506/problem/G\" title\u003d\"2014-2015 CT S02E06: Codeforces Trainings Season 2 Episode 6 - 2007 Benelux Algorithm Programming Contest (BAPC 2007)\"\u003e100506G - Pachinko\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is another DP problem. The idea is, for each column, calculate: If you drop the ball at this column, what is the probability that it ends up in every cell.\u003c/p\u003e\u003cp\u003eThe formula is straight-forward:\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e) \u003d \u003c/span\u003e probability that the ball goes to cell \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e. Then if cell \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e is empty, then from cell \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e, the ball can only go to below cell \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e. Thus, we update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003ej\u003c/i\u003e) +  \u003d \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e. If that cell is \u0027*\u0027, then the ball can go to 2 diagonal adjacent cells of the next row, thus we update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003ej\u003c/i\u003e - 1) +  \u003d \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e + 1, \u003ci\u003ej\u003c/i\u003e + 1) +  \u003d \u003ci\u003ef\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/7XccD3\"\u003eMy code\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100506/problem/H\" title\u003d\"2014-2015 CT S02E06: Codeforces Trainings Season 2 Episode 6 - 2007 Benelux Algorithm Programming Contest (BAPC 2007)\"\u003e100506H - Hiking\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI haven\u0027t solved it. But here\u0027s a solution by \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/qwerty787788\" title\u003d\"International Grandmaster qwerty787788\"\u003eqwerty787788\u003c/a\u003e :\u003c/p\u003e\u003cp\u003e\u0026quot;Let\u0027s create a set of interesting points. We add to this set start and end points. Also let\u0027s consider all pairs of towers. Let\u0027s look at intersection points of two circles with centers in this towers. If such point isn\u0027t covered by any other circle, we add it to our set.\u003c/p\u003e\u003cp\u003eNow for each pair of points in set we should find if we can go directly between them. So we just intersect this segment with all circles and look if all points in this segment is covered by at least one circle.\u003c/p\u003e\u003cp\u003eAnd now we can use dijkstra on this points to find a shortest distance.\u0026quot;\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100506/problem/I\" title\u003d\"2014-2015 CT S02E06: Codeforces Trainings Season 2 Episode 6 - 2007 Benelux Algorithm Programming Contest (BAPC 2007)\"\u003e100506I - Ranking\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is an implementation problem. You just need to implement everything that is said on the problem statement. The trick is in the sentence: \u0026quot;If ties remain at the end of the contest, the point of comparison between tied teams will be the last point in time where their scores differed\u0026quot;.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/tg4fto\"\u003eMy code\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100506/problem/J\" title\u003d\"2014-2015 CT S02E06: Codeforces Trainings Season 2 Episode 6 - 2007 Benelux Algorithm Programming Contest (BAPC 2007)\"\u003e100506J - Stock\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFor this problem, you need to solve it bottom up. Thus we go from the last day until day 1. Let use the example input to illustrate:\u003c/p\u003e\u003cp\u003eAt day 6, you can sell 3 stock at price 3. And you receive 2 stocks. If you don\u0027t do anything with these stocks, you will have to throw them away. So selling them is the best option. So you sell 2 stocks, receive 6 money and can still sell 1 stock at price 3 in day 6. Total money \u003d 6. And can sell 1 stock at day 6.\u003c/p\u003e\u003cp\u003eAt day 5, you can sell 2 stock at price 2. And you receive 2 more stocks. Using the same logic as previously, you must sell these stocks. The best way is to sell 1 stock at day 6 for 3 money, and sell 1 stock at day 5 for 2 money. Total money \u003d 11, and can sell 1 stock at day 5. ...\u003c/p\u003e\u003cp\u003eNow the solution should be quite clear: Going from the last day to first day. At each day, try to sell all stock. When you sell, always sell at the highest price that you can. You can keep track of the price that you can sell using C++ set. Please refer to my code for more details.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/zLxDzD\"\u003eMy code\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}