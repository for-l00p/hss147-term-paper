{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1414316148,"rating":16,"authorHandle":"Fcdkbear","modificationTimeSeconds":1414324249,"id":14445,"title":"\u003cp\u003eРазбор задач на тему \u0026quot;Алгоритм Ахо-Корасик\u0026quot;\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"http://www.codechef.com/problems/FAVNUM\"\u003ehttp://www.codechef.com/problems/FAVNUM\u003c/a\u003e\u003c/p\u003e\u003cp\u003eДоольно непростая задача. Идея №1 — будем использовать бинарный поиск по ответу. Пусть у нас есть фиксированный ответ m. Теперь нам нужно узнать, сколько хороших чисел находятся на отрезке от l до m. Предположим, что мы умеем это делать на отрезке от 0 до x. Тогда посчитаем ответ на отрезке от 0 до m, и отнимем от него ответ на отрезке от 0 до l-1. Если полученное число больше k — двигаем правую границу бинпоиска иначе — левую.\u003c/p\u003e\u003cp\u003eОсталось научиться считать количество хороших чисел на отрезке от 0 до х. Задачу будем решать динамикой. В динамике мы будем проставлять разряды чисел, которые не превосходят x. В процессе проставления нам нужно знать, не стало ли это число хорошим (то есть не встретилось ли в нем одно из чисел словаря в качестве подстроки). Для этого нам и нужен алгоритм Ахо-Корасик. Перед запуском бинарного поиска построим наш автомат по заданному словарю. И того, динамика будет по следующим параметрам:\u003c/p\u003e\u003cp\u003e1) Номер разряда \u003c/p\u003e\u003cp\u003e2) Номер вершины автомата Ахо-Корасик\u003c/p\u003e\u003cp\u003e3) Флаг, который показывает, правда ли, что наше текущее число меньше x. (нужен, чтобы знать, в каком промежутке мы можем подбирать очередной разряд)\u003c/p\u003e\u003cp\u003e4) Флаг, который показывает, хорошее ли наше число, то есть были ли мы в какойто вершине v, которая является терминальной (либо такой, из которой по суффиксным ссылкам достижима терминальная вершина)\u003c/p\u003e\u003cp\u003eПереходы динамики — перебор очередного разряда и пересчет всех параметров.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/0ac1rWNi\"\u003eКод\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://community.topcoder.com/stat?c\u003dproblem_statement\u0026amp;pm\u003d11514\u0026amp;rd\u003d14544\"\u003ehttp://community.topcoder.com/stat?c\u003dproblem_statement\u0026amp;pm\u003d11514\u0026amp;rd\u003d14544\u003c/a\u003e\u003c/p\u003e\u003cp\u003eОпять-таки, здача на динамику. Построим автомат Ахо-Корасик по заданному набору строк. Так же для каждой вершины автомата посчитаем такую динамику: какое множество слов из словаря заканчиваются в этой вершине и в ее суффиксных ссылках (удобно поддерживать при помощи масок). Далее — довольно несложная динамика. Параметры динамики: позиция в слове, номер вершины автомата Ахо-Корасик, текущая маска уже набранных слов. На каждом шаге динамики перебираем очередную букву слова и переходим в новое состояние с новой маской.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/9piWhSXJ\"\u003eКод\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://community.topcoder.com/stat?c\u003dproblem_statement\u0026amp;pm\u003d6017\"\u003ehttp://community.topcoder.com/stat?c\u003dproblem_statement\u0026amp;pm\u003d6017\u003c/a\u003e\u003c/p\u003e\u003cp\u003eПостроим автомат Ахо-Корасик абсолютно аналогичный тому, который мы строили в прошлой задаче (тоже будем хранить аналогичные маски-множества). Переберем первую целочисленную точку (без учета (0;0)), которую пересечет наш луч (заметим, что у такой точки gcd(x,y)\u003d\u003d1; действительно, если это не так — поделим обе координаты на их наибольший общий делитель и получим точку, которая встречается на луче раньше). Теперь переберем N (что такое N — обьясню далее) первых точек на луче, узнаая соответсвующие буквы. При помощи построенного автомата (просто делая переходы по очередной букве) и масок-множеств мы сможем узнавать, ответ для каких слов уеличивает текущий луч.\u003c/p\u003e\u003cp\u003eОсталось определить число N. Можно заметить, что индексы (i;j) массива g циклятся с периодом, не превосходящим n*m, где n,m — размеры матрицы g. До хода в период было пройдено не более n*m-1 шагов. Так же возможен вариант, при котором некоторое слово начинается в конце периода — тогда нам нужно посмотреть еще не более maxLen-1 символом, где maxLen — максимальная длина слов из словаря. В итоге: N \u003d 2*n*m+maxLen-2. Можно сегда использовать N\u003d2500.\u003c/p\u003e\u003cp\u003eТакое решение получает АС с двоекратным запасом времени\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://pastebin.com/UF8thrqx\"\u003eКод\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["разбор","ахо-корасик"]}}