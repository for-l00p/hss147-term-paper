{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1522551456,"rating":501,"authorHandle":"Sharon","modificationTimeSeconds":1522551456,"id":58667,"title":"\u003cp\u003eGrandmasters HATE this one weird trick!!! Top ten tips to speed up your program (NUMBER THREE WILL SHOCK YOU!!)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eIt is currently 12:00AM, March 32nd. I was digging through the deep web and I found out about a couple tricks that legendary grandmasters have been using on this website for ages, though it was kept secret from the rest of humanity. These tricks are too dangerous for dangerous people to know (Kim Jong Un if you are reading this please stop). However, I am personally sick of the inequality and I think it is time to let the world know the secrets to make your programs run super fast.\u003c/p\u003e\u003cp\u003eTrick 1: The O(N) to O(1) trick.\u003c/p\u003e\u003cp\u003eConsider \u003ca href\u003d\"//codeforces.com/problemset/problem/955/C\"\u003ethis problem\u003c/a\u003e. The bounds are clearly too large for an O(N) solution (looping from L to R). However, what if I told you that you could easily modify your O(N) code to make it O(1)?\u003c/p\u003e\u003cp\u003eConsider this piece of code:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003elong sum \u003d 0;\nfor(long i \u003d 0; i \u0026lt; N; i++){\n   sum +\u003d i;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe can clearly see that for large N, such as 10^18, the program will take a long time to run. BUT!!! We can turn every linear time algorithm into constant time by considering the maximum value of N (which is always given by problemsetters in the description in Codeforces). Here is the SAME code, but in constant time.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003elong sum \u003d 0;\nfor(long i \u003d 0; i \u0026lt; 1000000000000000000L; i++){\n   sum +\u003d i;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow with your new knowledge, you can solve the problem above.\u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/10/d5/10d5239e18cf6d789b92a02ad1782a30fb99eca2.gif\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eTrick 2: Thread.Sleep, a trick for the Java folks that are sick and tired of C++\u0027s supremacy.\u003c/p\u003e\u003cp\u003eNow, you are reading this trick and thinking I am crazy. \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Sharon\" title\u003d\"Expert Sharon\"\u003eSharon\u003c/a\u003e, how is it possible? Do you even know how to program? Thread.Sleep() slows your program down... It literally stops the program for the amount of time that you specify.\u003c/p\u003e\u003cp\u003eNow, I don\u0027t blame you for getting confused. I was too, originally. Until I found out you can manipulate the laws of the universe using this function to make your program run faster, like magic!\u003c/p\u003e\u003cp\u003eHere is what I mean. Have you ever considered passing a negative integer as an argument to that method? I bet you have not. What do you think it does? Well, we can follow simple logical reasoning. When we plug in a positive integer, the program stops for that amount of time. Therefore, when we plug in a negative number, the program should stop for a negative amount of time. In order to do that, it must start earlier, therefore faster, so the whole program runs faster!\u003c/p\u003e\u003cp\u003eHere is an example program:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eimport java.util.*;\n\npublic class R468A {\n\n\tpublic static void main(String[] args) {\n\t\tThread.Sleep(-99999999999999999999999999999999999999999999999999999999999999999999999999999999999999);\n\t\tScanner scan \u003d new Scanner(System.in);\n\t\tint a \u003d scan.nextInt();\n\t\tint b \u003d scan.nextInt();\n\t\tif(a \u0026gt; b){\n\t\t\tint temp \u003d b;\n\t\t\tb \u003d a;\n\t\t\ta \u003d temp;\n\t\t}\n\t\tlong ans \u003d 0;\n\t\tlong t1 \u003d 0;\n\t\tlong t2 \u003d 0;\n\t\t\n\t\twhile(a \u0026lt; b){\n\t\t\t//System.out.println(a+\u0026quot; \u0026quot;+b);\n\t\t\tt1++;\n\t\t\ta++;\n\t\t\tans +\u003d t1;\n\t\t\tif(a \u003d\u003d b) break;\n\t\t\tb--;\n\t\t\tt2++;\n\t\t\tans +\u003d t2;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen you run this program, you will see that it terminates nearly instantly. This is the true power of the Thread.Sleep trick.\u003c/p\u003e\u003cp\u003eAnyway, I hope you enjoy my tutorial and that it will provide you with many AC solutions and high rating. I will be on the lookout for more weird tricks and I will make sure to share them as I find any.\u003c/p\u003e\u003c/div\u003e","tags":["april 1st"]}}