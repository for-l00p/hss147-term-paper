{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1485531474,"rating":8,"authorHandle":"IWannaBeTheVeryBest","modificationTimeSeconds":1485531474,"id":50052,"title":"\u003cp\u003eLCS of updated strings\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eDefining substring For a string P with characters P1, P2 ,…, Pq, let us denote by P[i, j] the substring Pi, Pi+1 ,…, Pj.\u003c/p\u003e\u003cp\u003eGiven a string S with small alphabet characters S1, S2 ,…, SN, return an array with two elements. First is the smallest j (1 ≤ j \u0026lt; N) for which LCS(S[1, j], rev(S[j + 1, N])) is maximal and second is the maximal value of LCS(S[1, j], rev(S[j + 1, N])). Here, rev(A) denotes reverse of string A.\u003c/p\u003e\u003cp\u003eFor example,\u003c/p\u003e\u003cp\u003eS\u003d\u0026quot;abba\u0026quot;\u003c/p\u003e\u003cp\u003eLCS(S[1, 1], rev(S[2, 4])) \u003d LCS(\u0026quot;a\u0026quot;, \u0026quot;abb\u0026quot;) \u003d 1\u003c/p\u003e\u003cp\u003eLCS(S[1, 2], rev(S[3, 4])) \u003d LCS(\u0026quot;ab\u0026quot;, \u0026quot;ab\u0026quot;) \u003d 2\u003c/p\u003e\u003cp\u003eLCS(S[1, 3], rev(S[4, 4])) \u003d LCS(\u0026quot;abb\u0026quot;, \u0026quot;a\u0026quot;) \u003d 1\u003c/p\u003e\u003cp\u003eHence, we return [2, 2].\u003c/p\u003e\u003cp\u003eWhat I have done so far is finding a O(N^3) algorithm which is done by trying all i (1\u0026lt;\u003di\u0026lt;n) and find lcs of both strings. How can we reduce the time complexity ?\u003c/p\u003e\u003cp\u003eP.s. This was an interview question so there\u0027s no constraint on the string length and time limit. Just wondering how to improve the algorithm.\u003c/p\u003e\u003c/div\u003e","tags":["#lcs","#dp","#strings"]}}