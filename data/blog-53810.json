{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1502545517,"rating":349,"authorHandle":"retrograd","modificationTimeSeconds":1502621594,"id":53810,"title":"\u003cp\u003eMinima/maxima over all fixed-size arrays (multi-dimensional)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThis article will be presenting a rather classical problem that can be solved using deques, along with an extension that allows you to solve the problem in its more general multi-dimensional case. I have decided to write this article after \u003ca href\u003d\"//codeforces.com/blog/entry/45485?#comment-377649\"\u003ethis discussion on 2D range-minimum query\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThe article will be mainly based on this following \u003cstrong\u003eproblem\u003c/strong\u003e:\u003c/p\u003e\u003ch4\u003eYou are given an array of numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[]\u003c/span\u003e of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and a number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e\u003c/span\u003e. Find the minimum value for each continuous subarray of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e.\u003c/h4\u003e\u003cp\u003eWe will be now focusing on the linear-time solution to this problem.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSolution:\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eConsider sweeping from left to right through the array. At every moment we keep a list of \u0026quot;candidates\u0026quot; for minimum values throughout the process. That means that at each moment, you have to add one element to the list and (potentially) remove one element from the list.\u003c/p\u003e\u003cp\u003eThe key observation is that, during the sweep line process, we find two values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e which have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003ej\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e] ≥ \u003ci\u003eA\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e, then we can safely discard \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e. That is because, intuitively, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e will continue to \u0026quot;live\u0026quot; in our sweep line more than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e, and we will never prefer \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e instead of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eWe should now consider pruning all the \u0026quot;useless\u0026quot; values (\u0026quot;useless\u0026quot; as in the statement above). It is easy to see now that doing this will lead to a \u003cstrong\u003estrictly increasing\u003c/strong\u003e list of candidates (why?). In this case, the minimum will always be the \u003cstrong\u003efirst element\u003c/strong\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e query).\u003c/p\u003e\u003cp\u003eIn order to insert an element to the back of the pruned candidate list, we will do a stack-like approach of removing all elements that are greater than it, and to erase on element, we just pop the front of the list (if it is not already removed).\u003c/p\u003e\u003cp\u003eThis is a well-known approach for finding minima over fixed-size continuous subarrays. I will now present an extensions that allows you to do the same trick in matrices and even \u003cstrong\u003emulti-dimensional\u003c/strong\u003e arrays.\u003c/p\u003e\u003ch2\u003eThe \u003cstrong\u003emulti-dimensional extension\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eProblem (2D):\u003c/strong\u003e\u003c/p\u003e\u003ch4\u003eYou are given an matrix of numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e[][]\u003c/span\u003e of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e × \u003ci\u003em\u003c/i\u003e\u003c/span\u003e and two numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e ≤ \u003ci\u003en\u003c/i\u003e, \u003ci\u003el\u003c/i\u003e ≤ \u003ci\u003em\u003c/i\u003e\u003c/span\u003e. Find the minimum value for each continuous submatrix of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e × \u003ci\u003el\u003c/i\u003e\u003c/span\u003e.\u003c/h4\u003e\u003cp\u003e\u003cstrong\u003eSolution:\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eConsider the matrix as a list of rows. For each row vector of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e, use the 1D algorithm to compute the minimum value over all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e-length subarrays, and store them in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eColMin\u003c/i\u003e[][]\u003c/span\u003e (obviously, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eColMin\u003c/i\u003e[][]\u003c/span\u003e is now a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e × (\u003ci\u003em\u003c/i\u003e - \u003ci\u003el\u003c/i\u003e + 1)\u003c/span\u003e-sized matrix). \u003c/p\u003e\u003cp\u003eNow, consider the new matrix as a list of columns. For each column vector of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eColMin\u003c/i\u003e\u003c/span\u003e, use the algorithm to compute the minimum value over all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e-length subarrays, and store them in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAns\u003c/i\u003e[][]\u003c/span\u003e (of size \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003en\u003c/i\u003e - \u003ci\u003ek\u003c/i\u003e + 1) × (\u003ci\u003em\u003c/i\u003e - \u003ci\u003el\u003c/i\u003e + 1)\u003c/span\u003e). \u003c/p\u003e\u003cp\u003eThe \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAns\u003c/i\u003e[][]\u003c/span\u003e is the solution to our problem.\u003c/p\u003e\u003cp\u003e\u003cem\u003eThe following picture shows the intutition behind how it works for computing \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eAns\u003c/i\u003e[1][1]\u003c/span\u003e\u003c/em\u003e for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 5\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e \u003d 7\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e \u003d 3\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e \u003d 4\u003c/span\u003e \u003cimg alt\u003d\" \" src\u003d\"/predownloaded/fd/2b/fd2b8a0adc02e2b1aa5610f9c522c424654855a9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eThe \u003cstrong\u003epseudocode\u003c/strong\u003e is as follows:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003edef solve_2d(M, k, l):\n  column_minima \u003d {} # empty list\n  for each row in M.rows:\n    # We suppose we have the algorithm that solves\n    # the 1D problem\n    min_row \u003d solve_1d(row, l)\n    column_minima.append_row(min_row)\n  \n  ans \u003d {}\n  for each col in column_minima.cols:\n    min_col \u003d solve_1d(col, k)\n    ans.append_col(min_col)\n  \n  return ans\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNote that the pseudocode is (deliberately) hiding some extra complexity of extracting rows / columns and adapting the 1D algorithm to the 2D problem, in order to make the understanding of the solution clearer.\u003c/p\u003e\u003cp\u003eThe total complexity of the algorithm can be easily deduced to be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e * \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003ch4\u003e\u003cstrong\u003eMulti-dimensional case analysis\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003eThe solution can be extended to an arbitrary order of dimensions. For a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/span\u003e-dimensional matrix of size \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e, \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e, ..., \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, the time-complexity of the problem is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ed\u003c/i\u003e * \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e * ... * \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e, and the memory complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e * ... * \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e. This is much better than other algorithms that do the same thing on non-fixed size submatrices (e.g. multi-dimensional RMQ has \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e * ... * \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sub\u003e * \u003ci\u003elog\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e) * ... * \u003ci\u003elog\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ed\u003c/i\u003e\u003c/sub\u003e))\u003c/span\u003e time and memory complexity).\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003eFinding the best k minima\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eThe deque approach itself is limited in the sense that it allows you to find only the minimum value over the ranges. But what happens if you want to calculate more that one minimum? We will discuss an approach that I used during a national ACM-style contest where we were able to calculate the best 2 minima, and then argue that you can extend to an arbitrary number of minimum values.\u003c/p\u003e\u003cp\u003eIn order to store the lowest 2 values, we will do the following:\u003c/p\u003e\u003cp\u003eKeep 2 deques, namely \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e2\u003c/span\u003e. Do a similar algorithm of \u0026quot;stack-like popping\u0026quot; on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e1\u003c/span\u003e when you add a new element, but instead of discarding elements from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e1\u003c/span\u003e when popping, transfer them down to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e2\u003c/span\u003e and \u0026quot;stack-like pop\u0026quot; it.\u003c/p\u003e\u003cp\u003eIt is easy to see why the lowest 2 elements will always be in one of the two deques. Moreover, there are only 2 cases for the lowest two elements: they are either the first two elements of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e1\u003c/span\u003e, or the first elements of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e2\u003c/span\u003e subsequently. Checking the case should be an easy thing to do.\u003c/p\u003e\u003cp\u003eThe extension to an arbitrary number of minima is, however, not so great, in the sense that the complexity of this approach becomes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e * \u003ci\u003ek\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e for a \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e-sized array, currently bottlenecked by the number of elements you have to consider in order to find the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e minima. \u003cstrong\u003e[Maybe you can come up with a cleverer way of doing that?]\u003c/strong\u003e\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003eUseful links\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eThis is the problem I referred to above: \u003ca href\u003d\"http://www.infoarena.ro/problema/smax\"\u003ehttp://www.infoarena.ro/problema/smax\u003c/a\u003e. I recommend trying to think it through and implementing it, and translating the statement via Google Translate or equivalent.\u003c/p\u003e\u003c/div\u003e","tags":["rmq","deque","2d"]}}