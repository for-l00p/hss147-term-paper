{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1456707863,"rating":-18,"authorHandle":"qzqzgfy","modificationTimeSeconds":1456707863,"id":43445,"title":"\u003cp\u003eE. Robot Arm （618E）\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cpre\u003eE. Robot Arm\n                             time limit per test8 seconds\n                          memory limit per test256 megabytes\n                                    inputstandard input\n                                    outputstandard output\u003c/pre\u003e\u003cp\u003eRoger is a robot. He has an arm that is a series of n segments connected to each other. The endpoints of the i-th segment are initially located at points (i - 1, 0) and (i, 0). The endpoint at (i - 1, 0) is colored red and the endpoint at (i, 0) is colored blue for all segments. Thus, the blue endpoint of the i-th segment is touching the red endpoint of the (i + 1)-th segment for all valid i.\u003c/p\u003e\u003cp\u003eRoger can move his arm in two different ways:\u003c/p\u003e\u003cp\u003eHe can choose some segment and some value. This is denoted as choosing the segment number i and picking some positive l. This change happens as follows: the red endpoint of segment number i and segments from 1 to i - 1 are all fixed in place. Imagine a ray from the red endpoint to the blue endpoint. The blue endpoint and segments i + 1 through n are translated l units in the direction of this ray. \u003cimg alt\u003d\" \" src\u003d\"/predownloaded/7a/4f/7a4f347509b70f6cec206d7378f032597bb88438.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e In this picture, the red point labeled A and segments before A stay in place, while the blue point labeled B and segments after B gets translated.\u003c/p\u003e\u003cp\u003eHe can choose a segment and rotate it. This is denoted as choosing the segment number i, and an angle a. The red endpoint of the i-th segment will stay fixed in place. The blue endpoint of that segment and segments i + 1 to n will rotate clockwise by an angle of a degrees around the red endpoint. \u003cimg alt\u003d\" \" src\u003d\"/predownloaded/f8/60/f860f1c57df319b49143c71199d70b8dd6f83f0f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e In this picture, the red point labeled A and segments before A stay in place, while the blue point labeled B and segments after B get rotated around point A.\u003c/p\u003e\u003cp\u003eRoger will move his arm m times. These transformations are a bit complicated, and Roger easily loses track of where the blue endpoint of the last segment is. Help him compute the coordinates of the blue endpoint of the last segment after applying each operation. Note that these operations are cumulative, and Roger\u0027s arm may intersect itself arbitrarily during the moves.\u003c/p\u003e\u003cp\u003eInput The first line of the input will contain two integers n and m (1 ≤ n, m ≤ 300 000) — the number of segments and the number of operations to perform.\u003c/p\u003e\u003cp\u003eEach of the next m lines contains three integers xi, yi and zi describing a move. If xi \u003d 1, this line describes a move of type 1, where yi denotes the segment number and zi denotes the increase in the length. If xi \u003d 2, this describes a move of type 2, where yi denotes the segment number, and zi denotes the angle in degrees. (1 ≤ xi ≤ 2, 1 ≤ yi ≤ n, 1 ≤ zi ≤ 359)\u003c/p\u003e\u003cp\u003eOutput Print m lines. The i-th line should contain two real values, denoting the coordinates of the blue endpoint of the last segment after applying operations 1, ..., i. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 4.\u003c/p\u003e\u003cp\u003eNamely, let\u0027s assume that your answer for a particular value of a coordinate is a and the answer of the jury is b. The checker program will consider your answer correct if \u003cimg alt\u003d\" \" src\u003d\"/predownloaded/35/23/35238dfe6de4fab6370431765da4775d5abf010f.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003efor all coordinates.\u003c/p\u003e\u003cp\u003eExamples input 5 4 1 1 3 2 3 90 2 5 48 1 4 1 output 8.0000000000 0.0000000000 5.0000000000 -3.0000000000 4.2568551745 -2.6691306064 4.2568551745 -3.6691306064\u003c/p\u003e\u003cp\u003e：用线段树维护，将相邻两个节点之间向量作为线段树的叶子节点，然后就可以发现（0,0）加上线段树的总和就是N的坐标，接下来就能发现让某个区间的节点绕前一个节点旋转就相当于让这个区间的向量同时旋转这个角度，这相当于区间修改，而移动一个区间就相当于加长一个向量，这相当于单点修改，由于向量可以相加减并且满足交换律，因此用线段树维护是可以保证正确性的。 \u003cimg alt\u003d\" \" src\u003d\"/predownloaded/1c/20/1c20f9bc498932c1090f47419d1e726187117deb.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;queue\u0026gt;\n#include \u0026lt;stack\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;map\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;functional\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;sstream\u0026gt;\n#include \u0026lt;set\u0026gt;\n#include \u0026lt;deque\u0026gt;\n#define Rep(i, l, r) for (int i \u003d l; i \u0026lt;\u003d r; ++i)\n#define Req(i, l, r) for (int i \u003d l; i \u0026gt;\u003d r; --i)\nstruct tree{\n\tdouble x,y,f;\n}t[5000005];\nint n,m,opt,pos;\ndouble d,eps\u003d1e-8;\nvoid updata(int k){\n\tt[k].x\u003dt[k*2].x+t[k*2+1].x;\n\tt[k].y\u003dt[k*2].y+t[k*2+1].y;\n}\ndouble dis(double x,double y){\n\treturn sqrt(x*x+y*y);\n}\nvoid pushdown(int k,int l,int r){\n\tif (l\u003d\u003dr) return;\n\tif (fabs(t[k].f)\u0026gt;eps){\n\t\tdouble ccos\u003dcos(t[k].f),ssin\u003dsin(t[k].f);\n\t\tt[k*2].f+\u003dt[k].f;\n\t\tt[k*2+1].f+\u003dt[k].f;\n\t\tt[k].f\u003d0;\n\t    double x,y;\n\t    x\u003dt[k*2].x*ccos-t[k*2].y*ssin;\n\t    y\u003dt[k*2].x*ssin+t[k*2].y*ccos;\n\t    t[k*2].x\u003dx;t[k*2].y\u003dy;\n\t    \n\t    x\u003dt[k*2+1].x*ccos-t[k*2+1].y*ssin;\n\t    y\u003dt[k*2+1].x*ssin+t[k*2+1].y*ccos;\n\t    t[k*2+1].x\u003dx;t[k*2+1].y\u003dy;\n\t}\n}\nvoid build(int k,int l,int r){\n\tint mid\u003d(l+r)/2;\n\tif (l\u003d\u003dr){\n\t\tt[k].x\u003d1.0;\n\t\tt[k].y\u003d0.0;\n\t\tt[k].f\u003d0;\n\t\treturn;\n\t}\n\tbuild(k*2,l,mid);\n\tbuild(k*2+1,mid+1,r);\n\tupdata(k);\n}\nvoid change(int k,int l,int r,int pos,double d){\n\tint mid\u003d(l+r)/2;\n\tpushdown(k,l,r);\n\tif (l\u003d\u003dr){\n\t    double len\u003ddis(t[k].x,t[k].y);\n\t    double x\u003dt[k].x/len*d,y\u003dt[k].y/len*d;\n\t    t[k].x+\u003dx;\n\t    t[k].y+\u003dy;\n\t    return;\n\t}\n\tif (pos\u0026lt;\u003dmid) change(k*2,l,mid,pos,d);\n\telse change(k*2+1,mid+1,r,pos,d);\n\tupdata(k);\n}\nvoid turn_angle(int k,int l,int r,int x,int y,double d){\n\tpushdown(k,l,r);\n\tif (l\u003d\u003dx\u0026amp;\u0026amp;y\u003d\u003dr){\n\t\tdouble ccos\u003dcos(d),ssin\u003dsin(d);\n\t\tdouble x,y;\n\t    x\u003dt[k].x*ccos-t[k].y*ssin;\n\t    y\u003dt[k].x*ssin+t[k].y*ccos;\n\t    t[k].x\u003dx;t[k].y\u003dy;\n\t    t[k].f+\u003dd;\n\t    pushdown(k,l,r);\n\t    return;\n\t}\n\tint mid\u003d(l+r)/2;\n\tif (y\u0026lt;\u003dmid) turn_angle(k*2,l,mid,x,y,d);\n\telse\n\tif (x\u0026gt;\u003dmid+1) turn_angle(k*2+1,mid+1,r,x,y,d);\n\telse{\n\t\tturn_angle(k*2,l,mid,x,mid,d);\n\t\tturn_angle(k*2+1,mid+1,r,mid+1,y,d);\n\t}\n\tupdata(k);\n}\nint main(){\n\tscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\n\tbuild(1,1,n);\n\tfor (int i\u003d1;i\u0026lt;\u003dm;i++){\n\t\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;opt);\n\t\tif (opt\u003d\u003d1){\n\t\t\tscanf(\u0026quot;%d%lf\u0026quot;,\u0026amp;pos,\u0026amp;d);\n\t\t\tchange(1,1,n,pos,d);\n\t\t\tprintf(\u0026quot;%.12f %.12f\\n\u0026quot;,t[1].x,t[1].y);\n\t\t}\n\t\telse{\n\t\t\tscanf(\u0026quot;%d%lf\u0026quot;,\u0026amp;pos,\u0026amp;d);\n\t\t\td\u003dd/(180.0)*acos(-1);\n\t\t\td\u003d-d;\n\t\t\tturn_angle(1,1,n,pos,n,d);\n\t\t\tprintf(\u0026quot;%.12f %.12f\\n\u0026quot;,t[1].x,t[1].y);\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["计算几何","线段树","数据结构","水题"]}}