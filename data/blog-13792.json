{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1410765772,"rating":0,"authorHandle":"Binary_ToothLess","modificationTimeSeconds":1411028174,"id":13792,"title":"\u003cp\u003eCoin Change(Dynamic Programming)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI just write here a structure for coin change problem:\u003c/p\u003e\u003cp\u003e433A — Kitahara Haruki\u0027s Gift\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/433/A\"\u003ehttp://codeforces.com/problemset/problem/433/A\u003c/a\u003e\u003c/p\u003e\u003cp\u003eint recursion(int index, int amount){//initially index is 0, amount \u003d amount of destination money\u003c/p\u003e\u003cp\u003eif(i \u0026gt;\u003d total_types_of_Coin){//e.g:1c,5,10c \u003d 3 types of coin here..\u003c/p\u003e \u003cpre\u003eif(amount \u003d\u003d 0)return 1;// base case\n\nelse return 0;\u003c/pre\u003e\u003cp\u003e}\u003c/p\u003e\u003cp\u003eint way1 \u003d 0, way2 \u003d 0;\u003c/p\u003e\u003cp\u003eif(dp[index][amount] !\u003d -3)dp[index][amount];//dp was memset by the value of -3 in main function\u003c/p\u003e\u003cp\u003eif(amount-Coin[index] \u0026gt;\u003d 0)way1 \u003d recursion(index, amount-Coin[index]);//if we get same coin for several times otherwise index will be (index+1) that means try next coins;\u003c/p\u003e\u003cp\u003eway2 \u003d recursion(index+1, amount);\u003c/p\u003e\u003cp\u003ereturn dp[index][amount] \u003d way1+way2;\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003cp\u003etry it...i think this will work for following problems... UVa — 357, 674, 11137, 562;\u003c/p\u003e\u003c/div\u003e","tags":[]}}