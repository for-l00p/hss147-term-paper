{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1505738353,"rating":0,"authorHandle":"Light","modificationTimeSeconds":1505738353,"id":54602,"title":"\u003cp\u003eWeek 7 Discussion\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eThis week\u0027s class was all about solving problems using Brute Force and Recursion, here are the problems we discussed:\u003c/p\u003e \u003chr /\u003e\u003ch2\u003eLongest Increasing Subsequence (LIS)\u003c/h2\u003e\u003cp\u003e\u003ca href\u003d\"http://www.spoj.com/problems/ELIS/\"\u003ehttp://www.spoj.com/problems/ELIS/\u003c/a\u003e\u003c/p\u003e\u003cp\u003eProblem statement: given an array of N (1\u0026lt;\u003dN\u0026lt;\u003d15) integers, find the longest subsequence of the array such that each element is bigger than the one before it.\u003c/p\u003e\u003cp\u003eSolution: we found that greedy solutions won\u0027t work here, and since the limit is too small, we can try checking all possible increasing subsequences of the array and storing the maximum one. Complexity O(2^n)\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint n,v[21];\nvector\u0026lt;int\u0026gt; cur, best;\n\nvoid calc(int u){\n\tif(u\u003d\u003dn){\n\t\tif(cur.size()\u0026gt;best.size())\n\t\t\tbest\u003dcur;\n\t\treturn;\n\t}\n\tif(cur.empty() || v[u]\u0026gt;cur[cur.size()-1]){\n\t\tcur.push_back(v[u]);\n\t\tcalc(u+1);\n\t\tcur.resize(cur.size()-1);\n\t}\n\tcalc(u+1);\n}\nint main(){\n\tcin\u0026gt;\u0026gt;n;\n\tfor(int i\u003d0; i\u0026lt;n; ++i)\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;v[i]);\n\tcalc(0);\n\tcout\u0026lt;\u0026lt;best.size()\u0026lt;\u0026lt;endl;\n\tfor(int i\u003d0; i\u0026lt;best.size(); ++i)\n\t\tprintf(\u0026quot;%d \u0026quot;, best[i]);\n\tprintf(\u0026quot;\\n\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003chr /\u003e\u003ch2\u003eCoin Change\u003c/h2\u003e\u003cp\u003e-Note that the code here will be a bit different from the one in class for better complexity-\u003c/p\u003e\u003cp\u003eproblem statement: given an array of size N of available coins (1\u0026lt;\u003dN\u0026lt;\u003d4) and the Change (C) you need to make (1\u0026lt;\u003dC\u0026lt;\u003d50), what\u0027s the minimum number of coin pieces you need to make C change?\u003c/p\u003e\u003cp\u003esolution: We can see that most greedy algorithms won\u0027t work on all cases, and since the limits are low we can implement a Brute Force solution to try all different combinations of coins, the way we\u0027ll do it is that we will have in our parameters, how much change is left and the current coin I\u0027m using (index), such that if I\u0027m at coins #1, I\u0027ll either try to take this coin from the change left or move on to the next coin (coin #2) and so on. This will make our base case is reaching the end of the coins and having no change left.\u003c/p\u003e\u003cp\u003eComplexity: O(c^n)\u003c/p\u003e\u003cp\u003e(Notice that, in the worst case this solution will run and finish in less than a second, but the other solution we wrote will take around 405092592 million years to run! Try to figure out why by calculating the complexity for both solutions :D )\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\nint n, coins[5], c;\n\nint calc(int change, int idx){\n\tif(idx\u003d\u003dn){\n\t\tif(change\u0026gt;0)\n\t\t\treturn 1e9;\n\t\treturn 0;\n\t}\n\tint x\u003dcalc(change, idx+1);\n\tif(coins[idx]\u0026lt;\u003dchange)\n\t\tx\u003dmin(x, 1+calc(change-coins[idx], idx));\n\treturn x;\n}\n\nint main(){\n\tcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;c;\n\tfor(int i\u003d0 ;i\u0026lt;n; ++i)\n\t\tcin\u0026gt;\u0026gt;coins[i];\n\n\tcout\u0026lt;\u0026lt;calc(c,0)\u0026lt;\u0026lt;endl;\t\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003chr /\u003e\u003ch2\u003ePlus or Minus A\u003c/h2\u003e\u003cp\u003ewww.codeforces.com/problemset/gymProblem/100989/L\u003c/p\u003e\u003cp\u003eThis problem wanted us to find the minimum number of \u0027+\u0027 or \u0027-\u0027 signs to invert such that the answer of the equation will become 0, and again since the limits are low we can use try all possibilities (2^n possibilities, either keep the sign as it is or invert it) and check the minimum number of inversions to do so.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint n, v[21];\n\nint calc(int u, int sum){\n\tif(u\u003d\u003dn){\n\t\tif(sum!\u003d0)\n\t\t\treturn 1000;\n\t\treturn 0;\n\t}\n\tint res\u003dcalc(u+1, sum+v[u]);\n\tres\u003dmin(res, 1+calc(u+1, sum-v[u]));\n\treturn res;\n}\nint main(){\n\tcin\u0026gt;\u0026gt;n;\n\tcin\u0026gt;\u0026gt;v[0];\n\tchar x;\n\tfor(int i\u003d1; i\u0026lt;n; ++i){\n\t\tscanf(\u0026quot; %c%d\u0026quot;,\u0026amp;x,\u0026amp;v[i]);\n\t\tif(x\u003d\u003d\u0027-\u0027)\n\t\t\tv[i]*\u003d-1;\n\t}\n\tint ans\u003dcalc(1, v[0]);\n\tif(ans\u003d\u003d1000)\n\t\tans\u003d-1;\n\tcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003chr /\u003e\u003ch2\u003e0-1 Knapsack\u003c/h2\u003e\u003cp\u003eAnd the last problem we talked about was 0-1 Knapsack, where you have N items (1\u0026lt;\u003dN\u0026lt;\u003d20) and you have to choose which items to take such that their total price is maximum and their total weight is less than or equal to C (1\u0026lt;\u003dC\u0026lt;\u003d1000).\u003c/p\u003e\u003cp\u003eSince the number of items is low, we can try all possibilities of either taking or not taking each item, complexity will be O(2^n) which will pass even in the worst case.\u003c/p\u003e\u003cp\u003eThe solution is similar to others that we discussed but it only differs that instead of adding 1 when counting the number of things we did, we will add the price of the item when we take it because we want the total price to be maximum (not the number of items).\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eCode\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\nusing namespace std;\n\nint n, cap, price[21], weight[21];\n\nint calc(int u, int left){\n\tif(u\u003d\u003dn)\n\t\treturn 0;\n\tint x\u003dcalc(u+1, left);\n\tif(left\u0026gt;\u003dweight[u])\n\t\tx\u003dmax(x, price[u]+calc(u+1, left-weight[u]));\n\treturn x;\n}\n\nint main(){\n\tcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;cap;\n\tfor(int i\u003d0; i\u0026lt;n; ++i)\n\t\tcin\u0026gt;\u0026gt;price[i]\u0026gt;\u0026gt;weight[i];\n\tcout\u0026lt;\u0026lt;calc(0,cap)\u0026lt;\u0026lt;endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003chr /\u003e\u003cp\u003eAnd that\u0027s all for this week\u0027s discussion, practice these techniques well and be sure to write them yourselves!\u003c/p\u003e\u003c/div\u003e","tags":[]}}