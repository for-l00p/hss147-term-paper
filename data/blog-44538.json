{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1461545064,"rating":37,"authorHandle":"AlexFetisov","modificationTimeSeconds":1462518700,"id":44538,"title":"\u003cp\u003eVK Cup 2016 — Раунд 2 (editorial)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/669/A\"\u003eProblem A (div2)\u003c/a\u003e:\u003c/h4\u003e\u003cp\u003eIt is obvious that we need to make sequence of moves like: 1, 2, 1, 2, ...\u003c/p\u003e\u003cp\u003eSo the answer is 2 * n / 3. After that we have either 0, 1 or 2 stones left. If we have 0, we are done, otherwise we have 1 or 2 left, so we only can give 1 more stone.\u003c/p\u003e\u003cp\u003eFinal formula is: (2 * n) / 3 + (n % 3 !\u003d 0 ? 1 : 0);\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/669/B\"\u003eProblem B (div2)\u003c/a\u003e:\u003c/h4\u003e\u003cp\u003eWe can just emulate grasshopper behavior and save all positions it visits. It is obvious that we will have no more than O(n) different positions. If grasshopper appears in the same position twice that means that there is a loop and the answer is INFINITE. Otherwise the answer is FINITE. \u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/669/C\"\u003eProblem A(div1)/C(div2)\u003c/a\u003e:\u003c/h4\u003e\u003cp\u003eLet\u0027s have 2 matrices: a, idx. In a we will have NULL for cell if we don\u0027t know the value or the value. idx will be initialized with idx[i][j] \u003d {i, j}; Then we need to emulate the process on matrix idx. If we have 3rd query we can set up the value in matrix a, because we know the original position of that cell keeping idx.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/669/D\"\u003eProblem B(div1)/D(div2)\u003c/a\u003e:\u003c/h4\u003e\u003cp\u003eThe key in this problem is that order of all elements in odd positions and in even positions is the same. Let\u0027s say we have 2 arrays: [1, 3, 5, ...] and [2, 4, ...] (odd positions and even positions). Now if we call 2nd commands we just swap these 2 arrays, but order is the same. Obviously 1st command also keeps the order. By order I mean cyclic order (right neighbor is the same in cycle position).\u003c/p\u003e\u003cp\u003eLet\u0027s just keep the position of 1st boy and 2nd boy. Now if we apply 1st operation we move it by X or -X. Second type of the query just swaps the positions. In the end we can construct the answer if we know positions of 1st and 2nd boys.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/641/D\"\u003eProblem C(div1)\u003c/a\u003e:\u003c/h4\u003e\u003cp\u003eFirst, let\u0027s solve inverse problem: find minimum (maximum) of two distributions. Let\u0027s use the following formulas:\u003c/p\u003e\u003cp\u003eP(a \u003d k) \u003d P(a \u0026lt;\u003d k) — P(a \u0026lt;\u003d k-1) P(max(a, b) \u0026lt;\u003d k) \u003d P(a \u0026lt;\u003d k) * P(b \u0026lt;\u003d k)\u003c/p\u003e\u003cp\u003eFor minimum:\u003c/p\u003e\u003cp\u003eP(min(a, b) \u0026gt;\u003d k) \u003d P(a \u0026gt;\u003d k) * P(b \u0026gt;\u003d k) \u003d (1 — P(a \u0026lt;\u003d k-1)) *(1 — P(b \u0026lt;\u003d k-1))\u003c/p\u003e\u003cp\u003eNow in our original problem minimum and maximum defines system of square equations for each pair P(a \u0026lt;\u003d k), P(b \u0026lt;\u003d k).\u003c/p\u003e\u003cp\u003eSolving these equations we get P(a\u0026lt;\u003dk), P(b\u0026lt;\u003dk) \u003d (u + v ± sqrt((u + v)^2 — 4u)) / 2, where u \u003d P(max(a,b) \u0026lt;\u003d k), v \u003d P(min(a,b) \u0026lt;\u003d k). Now we can notice that if there exists an answer, then there exists an answer when we chose the signs for each pair equally (check out this \u003ca href\u003d\"//codeforces.com/blog/entry/44524?locale\u003dru#comment-290486\"\u003ecomment\u003c/a\u003e)\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/641/E\"\u003eProblem D(div1)/E(div2)\u003c/a\u003e:\u003c/h4\u003e\u003cp\u003eThere are many ways to solve this problem. One of the ways was SQRT-decomposition. First let\u0027s compress all times. Now for each block in the decomposition we will store for each element the balance in that block. So to answer the query we need to calculate sum of balances from first block to the block before the one where our element is located and then just process all requests in the current block.\u003c/p\u003e\u003cp\u003eAnother way was to use data structure from std library, described \u003ca href\u003d\"//codeforces.com/blog/entry/11080\"\u003ehere\u003c/a\u003e. For each element we have two trees: remove times and add times. Then by getting order of the time in remove and add tree we can calculate the answer.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/641/F\"\u003eProblem E(div1)\u003c/a\u003e:\u003c/h4\u003e\u003cp\u003eLet\u0027s build for both 2-SAT formulas \u003ca href\u003d\"https://en.wikipedia.org/wiki/Implication_graph\"\u003eimplication graph\u003c/a\u003e and let\u0027s find strong connected components in this graph. If both of the formulas are not satisfiable then the answer is SIMILAR. If only one formula is not satisfiable then we can find an answer for the second one and output it.\u003c/p\u003e\u003cp\u003eNow, let\u0027s assume both formulas are satisfiable. Let\u0027s have a transitive closure for both of the graphs. Let\u0027s call the variable X fixed in the formula F if there is a path -\u0026gt; x or (x -\u0026gt; ). If there is a fixed variable in one formula, but not fixed in the other (or fixed but has other value) we can find the solution for that second formula with opposite value of that fixed variable — that will be an answer. If we could not find these variables, we can remove all of them. There is no fixed variables in the rest of them. Let\u0027s find an edge u-\u0026gt;v, presented in one graph, but not presented in the other. Let\u0027s find the solution for formula without the edge with u \u003d 1 and v \u003d 0 (we always can find it). That is the answer.\u003c/p\u003e\u003ch4\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/641/G\"\u003eProblem F(div1)\u003c/a\u003e:\u003c/h4\u003e\u003cp\u003eLet\u0027s define k-clique B the descendant of k-clique A, if B could be produced from A with the sequence of the following steps: add vertex to the clique, connected with all clique vertices in the graph description and remove exactly one other vertex. Let\u0027s calculate the DP with states (k-clique, separation its vertices to the components) — number of spanning forests int the graph, induced by the clique and all its descendants so that clique will be divided to different connected components according to the defined vertices separation (all of the rest vertices will be connected with some of these components). To calculate that we need to precalculate all separations from k to k+1 elements and transitions:\u003c/p\u003e\u003cp\u003e1) (separation of k+1 vertices) x (separation k+1 vertices) -\u0026gt; (separation k+1 vertices | null), transform pair of separations — forests to the set of connected components of their union or null if there appears a cycle.\u003c/p\u003e\u003cp\u003e2) (separation of k+1 vertices) x (vertex) -\u0026gt; (separation of k+1 vertices | null), transform forest to the new forest, generated by adding new edge from vertex to vertex k+1 (or null, if there appears a cycle)\u003c/p\u003e\u003cp\u003e3) (separation of k+1 vertices) -\u0026gt; (separation of k vertices | null), projecting the separation on the first k vertices (or null, if k+1-th vertex creates a separate component)\u003c/p\u003e\u003cp\u003eCheck out details in the \u003ca href\u003d\"https://gist.github.com/winger/612429959a953104d7b05b72f290c8a8\"\u003eauthor solution\u003c/a\u003e. \u003c/p\u003e\u003c/div\u003e","tags":[]}}