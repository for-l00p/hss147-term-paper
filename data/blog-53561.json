{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1501420337,"rating":-8,"authorHandle":"Unlimited_Time","modificationTimeSeconds":1501420337,"id":53561,"title":"\u003cp\u003eNotes on Codeforces Beta Round #64, A, B, C (Binary search in segment tree)\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/70/problem/A\" title\u003d\"Codeforces Beta Round 64\"\u003e70A - Cookies\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe use a[n] to denote the number of empty cells for a square of size 2^n*2^n. The square of size 2^(n+1)*2^(n+1) can be built from the smaller one of size 2^n*2^n. Moreover, it can be observed that if we divide the larger square into four smaller ones, the left upper, left bottom and right bottom ones are just exactly the same copies of the smaller one, while the right upper one is fully filled. Thus, a[n+1]Ôºù3*a[n]. Note that for the special case n\u003d0, the answer should be 1.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/70/problem/B\" title\u003d\"Codeforces Beta Round 64\"\u003e70B - Text Messaging\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAt first, we find out all the independent sentences, and store them in the same order as they are given. Then, we keep merging the sentences into a message as long as its length does not exceed the requirement. Be careful that if two messages are combined together, the space between should also be counted, while if they belong to different messages, the space must be omitted.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/70/problem/C\" title\u003d\"Codeforces Beta Round 64\"\u003e70C - Lucky Tickets\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWe use rev[i] to denote the integer obtained by reversing i. Next, we use g[i] to denote the GCD of i and rev[i]. Note that i/rev[i] can be further reduced to (i/g[i])/(rev[i]/g[i]), and thus it can be observed that j must be a multiple of rev[i]/g[i]. \u003c/p\u003e\u003cp\u003eWith the above observations, we can directly enumerate x from 1 to maxx while y from 1 to maxy bit with j\u003dj+rev[i]/g[i]. During this process, once we find that i*j\u003drev[i]*rev[j], we store j by using the segment tree. Then, we implement binary search to find out the smallest y so that the number of i*j\u003drev[i]*rev[j] is no less than w. Therefore, we can check the value of x*y and obtain the minimum answer.\u003c/p\u003e\u003cp\u003eRemember to calculate all g[i] and rev[i] previously; otherwise it might lead to TLE.\u003c/p\u003e\u003c/div\u003e","tags":[]}}