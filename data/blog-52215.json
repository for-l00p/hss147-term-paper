{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1495880630,"rating":-21,"authorHandle":"joker70","modificationTimeSeconds":1495880630,"id":52215,"title":"\u003cp\u003eUnderstanding BigMod\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eGuys who are new to competitive programming, they want to learn basic programming algorithm\u0027s like Binary Search, BigMod, Cumulative Sum, Two pointer etc. In this post, I am going to give a short description on BigMod.\u003c/p\u003e\u003cp\u003eBigmod is an algorithm which determines a^b (mod m) . Here a, b and m are integers. In programming, when someone tells you to find a^b (mod m) what you do is at first determine a^b and then mod it by m. But, this is a really naive approach. So, I have written a code that will help you to understand the basics of bigmod.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;stdio.h\u0026gt;\n\nint bigmod(long long int a,long long int b,int m);\n\nint main() {\n\n    int a, b, m, rem, ans;\n\n    scanf(\u0026quot;%lld %lld %lld\u0026quot;, \u0026amp;a, \u0026amp;b, \u0026amp;m);      // Taking input a, b and m\n\n    ans \u003d bigmod(a, b, m);                               // getting answer from a function\n\n    printf(\u0026quot;%d\\n\u0026quot;, ans);                                    // printing the answer\n\n    return 0;\n}\n\n/***********************************************************************************\n The idea behind bigmod is simple.\nLet\u0027s assume, the desired remainder is x.\nThen we want to determine a^b \u003d x (mod m)\nwe can do it by calulating a%m and multiplying it b times and mod it every time to get the answer\n\n(a^b)%m \u003d ( (a%m) * (a%m) * ......... (a%m) )%m         [Time Complexity O(b)]\n                          -----------------------------------------\n                                                 |\n                                          b times\n\nBut in this code\u0027s function we used a more time efficient approach.\nThat is instead of taking b times a%m , we can divide the b in little parts which we can\neasily determine,\nWe will divide b to it\u0027s binary representation.\nLet\u0027s assume b\u003d25\nThen we can divide b into these parts,\n\n25 \u003d  11001\n25 \u003d 16*1 + 8*1 + 4*0 + 2*0 + 1*1\n\nSo, now we can determine (a^25)%m easily,\n(a^25)%m \u003d (a^16)%m * (a^8)%m * (a^1)%m\n\nNow, we can take a%m in a variable and keep multiplying by itself by itself,\n\nThus , rem \u003d (a^1)%m\n              rem \u003d (rem * rem)%m \u003d (a^2)%m\n              rem \u003d (rem * rem)%m \u003d (a^4)%m\n              rem \u003d (rem * rem)%m \u003d (a^8)%m\n            .\n            .\n            .\n\nNow we use the idea how we use to determine the binary representation of a number.\nWe will divide  the number by two, if it was an odd then the last digit would be 1 ,\nin other case it will be 0.\nSo, when we will found b as odd we will multiply the rem with the answer.\nWhen b becomes 0, then the loop will break and we will get the answer.\n\nThe time complexity of this process would be O(log b).\n\n                             - Merajul Arefin Pial\n                                Computer Science and Engineering Department, University of Dhaka.\n\n*******************************************************************************************/\n\nint bigmod(long long int a, long long int b, int M) { // a function to determine a^b(mod M)\n\n    int remainder, answer \u003d 1;                            // set two variables for remainder and answer\n\n    remainder \u003d a%M;                                          // setting remainder as\n\n    while(b!\u003d0)                                                     //  loop occurs until b is not equal to 0\n    {\n        if(b%2\u003d\u003d1)                                                           // checking if b is odd\n        {\n            answer \u003d (answer*remainder)%M;    // taking the present remainder in the answer if b is odd\n        }\n\n        remainder \u003d (remainder*remainder)%M;    // making remainder double on each turn of the loop\n\n        b/\u003d2;                                                                      // reducing b by dividing it by 2 in every turn,\n    }\n    return answer;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHope you like it. and it helps you to understand.\u003c/p\u003e\u003c/div\u003e","tags":["beginner","bigmod"]}}