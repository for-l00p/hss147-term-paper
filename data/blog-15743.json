{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1421021824,"rating":81,"authorHandle":"savinov","modificationTimeSeconds":1421157152,"id":15743,"title":"\u003cp\u003eCodeforces Round #285 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/contest/501/problem/A\" title\u003d\"Codeforces Round 285 (Div. 2)\"\u003e501A - Contest\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIn this problem one need to determine the number of points for both guys and find out who got more points.\u003c/p\u003e\u003cp\u003eTime complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/501/problem/B\" title\u003d\"Codeforces Round 285 (Div. 2)\"\u003e501B - Misha and Changing Handles\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe problem can be formulated as follows: The directed graph is given, its vertices correspond to users\u0027 handles and edges — to requests. It consists of a number of chains, so every vertex ingoing and outgoing degree doesn\u0027t exceed one. One need to find number of chains and first and last vertices of every chain. The arcs of this graph can be stored in dictionary(one can use \u003cstrong\u003estd::map\\unoredered_map\u003c/strong\u003e in C++ and \u003cstrong\u003eTreeMap\\HashMap\u003c/strong\u003e in Java) with head of the arc as the key and the tail as the value.\u003c/p\u003e\u003cp\u003eEach zero ingoing degree vertex corresponds to unique user as well as first vertex of some chain. We should iterate from such vertices through the arcs while it\u0027s possible. Thus we find relation between first and last vertices in the chain as well as relation between the original and the new handle of some user.\u003c/p\u003e\u003cp\u003eYou can see my \u003ca href\u003d\"http://ideone.com/UH49U3\"\u003esolution\u003c/a\u003e for details.\u003c/p\u003e\u003cp\u003eTime complexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/3b/40/3b402f66640c33d5141c83dcacfb8e4f04e31871.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/504/problem/A\" title\u003d\"Codeforces Round 285 (Div. 1)\"\u003e504A - Misha and Forest\u003c/a\u003e\u003c/p\u003e\u003cp\u003eNote that every non-empty forest has a leaf(vertex of degree \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e). Let\u0027s remove edges one by one and maintain actual values \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003edegree\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e as long as graph is not empty. To do so, we can maintain the queue(or stack) of the leaves. On every iteration we dequeue vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e and remove edge \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ev\u003c/i\u003e, \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e and update values for vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edegree\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e\u003c/span\u003e -\u003d \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/sub\u003e\u003c/span\u003e ^\u003d \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e. If degree of vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e becomes equal to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, we enqueue it.\u003c/p\u003e\u003cp\u003eWhen dequeued vertex has zero degree, just ignore it because we have already removed all edges of corresponding tree.\u003c/p\u003e\u003cp\u003eYou can see my \u003ca href\u003d\"http://ideone.com/H7Vawi\"\u003esolution\u003c/a\u003e for details.\u003c/p\u003e\u003cp\u003eTime complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/504/problem/B\" title\u003d\"Codeforces Round 285 (Div. 1)\"\u003e504B - Misha and Permutations Summation\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTo solve the problem, one need to be able to find the index of given permutation in lexicographical order and permutation by its index. We will store indices in factorial number system. Thus number \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is represented as \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/a6/48/a648ece0f65430fd649a545d48e2f7c6432cbd77.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e. You can find the rules of the transform \u003ca href\u003d\"http://en.wikipedia.org/wiki/Factorial_number_system\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eTo make the transform, you may need to use data structures such as binary search tree or binary indexed tree (for maintaining queries of finding \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e-th number in the set and finding the amount of numbers less than given one).\u003c/p\u003e\u003cp\u003eSo, one need to get indices of the permutations, to sum them modulo \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e!\u003c/span\u003e and make inverse transform. You can read any accepted solution for better understanding.\u003c/p\u003e\u003cp\u003eTime complexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e or \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ca/4c/ca4c38da7d143fc87534d50aa6d551dd861caae9.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/504/problem/C\" title\u003d\"Codeforces Round 285 (Div. 1)\"\u003e504C - Misha and Palindrome Degree\u003c/a\u003e\u003c/p\u003e\u003cp\u003eNote that if the amount of elements, which number of occurrences is odd, is greater than one, the answer is zero. On the other hand, if array is the palindrome, answer is \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6f/14/6f140d431ab6e4b2f3e4e7d08a65bbb168825912.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eLet\u0027s cut equal elements from the end and the beginning of array while it is possible. Let\u0027s call remaining array as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e and its length as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e. We are interested in segments \u003cspan class\u003d\"tex-span\"\u003e[\u003ci\u003el\u003c/i\u003e, \u003ci\u003er\u003c/i\u003e]\u003c/span\u003e which cover some prefix or suffix of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe need to find the minimum length of such prefix and suffix. Prefix and suffix can overlap the middle of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e and these cases are needed to maintain. To find minimum length you can use binary search or simply iterating over array and storing the amount of every element to the left and right from the current index. Let\u0027s call minimum length of prefix as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epref\u003c/i\u003e\u003c/span\u003e and as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esuf\u003c/i\u003e\u003c/span\u003e of suffix. So \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/4d/85/4d8597f5d54700217a817cbbf1fed2138413c121.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003eTime complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e or \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e7/0f/e70fbdc8079c0b9ff4f31073012937bac199bc6b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/504/problem/D\" title\u003d\"Codeforces Round 285 (Div. 1)\"\u003e504D - Misha and XOR\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFirstly, we convert each number into a binary system: it can be done in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eMAXBITS\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eMAXBITS\u003c/i\u003e ≤ 2000\u003c/span\u003e with rather small constant(we store number in system with big radix).\u003c/p\u003e\u003cp\u003eTo solve the problem we need to modify Gauss elimination algorithm. For each row we should store set of row\u0027s indices which we already XORed this row to get row echelon form (we can store it in bitset), also for each bit \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e we store index \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e]\u003c/span\u003e of row, which lowest set bit is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e in row echelon form.\u003c/p\u003e\u003cp\u003eMaintaining the query we try to reset bits from lowest to highest using array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and save information, which rows were XORed with current number. If we can reset whole number, the answer is positive and we know indices of answer. We update array \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e, otherwise.\u003c/p\u003e\u003cp\u003eTime complexity: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003em\u003c/i\u003e × \u003ci\u003eMAXBITS\u003c/i\u003e × (\u003ci\u003eMAXBITS\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e))\u003c/span\u003e with small constant due to bit compression.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/504/problem/E\" title\u003d\"Codeforces Round 285 (Div. 1)\"\u003e504E - Misha and LCP on Tree\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s build heavy-light decomposition of given tree and write all strings corresponding to heavy paths one by one in one string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e, every path should be written twice: in the direct and reverse order.\u003c/p\u003e\u003cp\u003eMaintaining query we can split paths \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ec\u003c/i\u003e, \u003ci\u003ed\u003c/i\u003e)\u003c/span\u003e into parts, which completely belongs to some heavy paths. There can be at most \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e such parts. Note that every part corresponds to some substring of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow we only need to find longest common prefix of two substrings in string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e. It can be done building suffix array of string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eT\u003c/i\u003e\u003c/span\u003e and lcp array. So, we can find longest common prefix of two substring in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e constructing rmq sparse table on lcp array.\u003c/p\u003e\u003cp\u003eTime complexity: \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/6c/f8/6cf8b4e405a025a9db037689055a5ce1bff3417c.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003eFor the better understanding see my \u003ca href\u003d\"https://ideone.com/42hc8F\"\u003esolution\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eP.S.\u003c/strong\u003e One can uses hashes instead of suffix array.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eADD:\u003c/strong\u003e There is another approach to solve this problem in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/98/9d/989d21e17251c318c690d6d663d712dff89231dd.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e but it\u0027s rather slow in practice. We can do binary search on answer and use hashes, but we do it for all queries at one time. The only problem is to find \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e-th vertex on the path, we can do it offline for all queries in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e + \u003ci\u003em\u003c/i\u003e)\u003c/span\u003e time. We run dfs and maintain stack of vertices. See my \u003ca href\u003d\"http://ideone.com/2OxibB\"\u003esolution\u003c/a\u003e for details.\u003c/p\u003e\u003c/div\u003e","tags":[]}}