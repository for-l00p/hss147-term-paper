{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1468155718,"rating":0,"authorHandle":"Silver_","modificationTimeSeconds":1468155718,"id":45979,"title":"\u003cp\u003eNCD Training Advanced #1 Tutorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch3\u003e\u003cstrong\u003eA.Comparing Two Long Integers:\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eNote that solutions in Java with BigInteger class or input() function in Python2 will fail in this problem. The reason is the next: standard objects stores numbers not in decimal system and need a lot of time to convert numbers from decimal system. Actually they are working in O(n^2), where n is the legth of the number.\u003c/p\u003e\u003cp\u003eTo solve this problem you should simply read the numbers to strings and add leading zeroes to the shorter one until the numbers will be of the same length. After that you should simply compare them alphabetically.\u003c/p\u003e\u003cp\u003eComplexity: O(n).\u003c/p\u003e\u003ch3\u003e\u003cstrong\u003eB.ZgukistringZ:\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eFirst, calculate the number of occurences of every English letter in strings a, b, and c. \u003c/p\u003e\u003cp\u003eWe can now iterate by number of non-overlapping substrings of the resulting string equal  to b, then we can calculate in constant time how many substrings equal to c can be formed (by simple operations on the number of occurences of English letters in c). In every iteration, maximise the sum of numbers of b and c. Number of iterations is not greater than |a|. At the end, we can easily build the resulting string by concatenating previously calculated number of strings b and c, and add the rest of the letters to get the string obtainable from a.\u003c/p\u003e\u003cp\u003eTotal complexity is O(|a| + |b| + |c|).\u003c/p\u003e\u003ch3\u003e\u003cstrong\u003eC.A simple Task\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eIn this problem we will be using counting sort. So for each query we will count the number of occurrences for each character, and then update the range like this\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor(int j\u003dx;j\u0026lt;\u003dy;j++)\n  cnt[s[j] - \u0027a\u0027]++;\nind \u003d 0;\nfor(int j\u003dx;j\u0026lt;\u003dy;j++)\n{\n  while(cnt[ind] \u003d\u003d 0)\n    ind++;\n  s[j] \u003d ind + \u0027a\u0027;\n  cnt[ind]--;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut this is too slow. We want a data structure that can support the above operations in appropriate time. Let’s make 26 segment trees each one for each character. Now for each query let’s get the count of every character in the range, and then arrange them and update each segment tree with the new values. We will have to use lazy propagation technique for updating ranges.\u003c/p\u003e\u003cp\u003eTime complexity: where sz is the size of the alphabet (i.e. \u003d 26).\u003c/p\u003e\u003cp\u003e****\u003c/p\u003e\u003ch3\u003e\u003cstrong\u003eD.Special Offer! Super Price 999 Bourles!\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eThe following observation will help you code the solution: The largest number smaller than p ending with at least k nines is p — p MOD 10^k — 1 If the result turns out to be -1 , you can not reach a positive number with k or more nines. \u003c/p\u003e\u003cp\u003eI will not explain the solution in detail — be careful when coding and have all the task statements in mind.\u003c/p\u003e\u003ch3\u003e\u003cstrong\u003eE.Cinema Line\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eIn the problem you need to decide whether cashier can give a change to all customers if the price of the ticket is 25 rubles and there\u0027s 3 kinds of bills: 25, 50 and 100 rubles. \u003c/p\u003e\u003cp\u003eThere\u0027s no money in the ticket office in the beginning. Let\u0027s consider 3 cases:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eCustomer has 25 rubles hence he doesn\u0027t need a change.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eCustomer has 50 rubles hence we have to give him 25 rubles back.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eCustomer has 100 rubles hence we need to give him 75 rubles back. It can be done in 2 ways. 75\u003d25+50 и 75\u003d25+25+25. Notice that it\u0027s always worth to try 25+50 first and then 25+25+25. It\u0027s true because bills of 25 rubles can be used both to give change for 50 and 100 rubles and bills of 50 rubles can be used only to give change for 100 rubles so we need to save as much 25 ruble bills as possible.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThe solution is to keep track of the number of 25 and 50 ruble bills and act greedily when giving change to 100 rubles — try 25+50 first and then 25+25+25.\u003c/p\u003e\u003c/div\u003e","tags":[]}}