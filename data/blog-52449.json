{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1496848362,"rating":222,"authorHandle":"cyand1317","modificationTimeSeconds":1501056963,"id":52449,"title":"\u003cp\u003eCodeforces Round #418 (Div. 2) Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eGreetings!\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/contest/814\" title\u003d\"Codeforces Round 418 (Div. 2)\"\u003eCodeforces Round #418 (Div. 2)\u003c/a\u003e has just come to an end. This is my first round here, and hope you all enjoyed the contest! \u0026gt; \u0026lt;\u003c/p\u003e\u003cp\u003eSeems the statements still created a few issues :( Anyway hope you liked it, and the characters feature the \u003cem\u003eMonogatari\u003c/em\u003e anime series. Let me state again that the statements has little to do with the actual plot — they\u0027re inspired by five theme songs actually — and I\u0027m \u003cem\u003enot\u003c/em\u003e spoiling anyone of the series! ^ ^\u003c/p\u003e\u003cp\u003eSympathy for those failing system tests on B... This problem was intended to experience a lot of hacks but somehow there are not so many.\u003c/p\u003e\u003cp\u003eHere are the detailed solutions to the problems. Feel free to write in the comments if there\u0027s anything incorrect or unclear.\u003c/p\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"814A\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\nstatic const int MAXN \u003d 102;\n\nint n, k;\nint a[MAXN], b[MAXN];\n\nint main()\n{\n    scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;k);\n    int last_zero \u003d -1;\n    for (int i \u003d 0; i \u0026lt; n; ++i) {\n        scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]);\n        if (a[i] \u003d\u003d 0) last_zero \u003d i;\n    }\n    for (int i \u003d 0; i \u0026lt; k; ++i) scanf(\u0026quot;%d\u0026quot;, \u0026amp;b[i]);\n\n    if (k \u0026gt; 1) {\n        puts(\u0026quot;Yes\u0026quot;);\n    } else {\n        a[last_zero] \u003d b[0];\n        bool valid \u003d false;\n        for (int i \u003d 1; i \u0026lt; n; ++i)\n            if (a[i] \u0026lt;\u003d a[i - 1]) { valid \u003d true; break; }\n        puts(valid ? \u0026quot;Yes\u0026quot; : \u0026quot;No\u0026quot;);\n    }\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution 2\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\nstatic const int MAXN \u003d 102;\n\nint n, k;\nint a[MAXN], b[MAXN];\nint p[MAXN], r[MAXN];\n\ninline bool check()\n{\n    for (int i \u003d 1; i \u0026lt; n; ++i) if (r[i] \u0026lt;\u003d r[i - 1]) return true;\n    return false;\n}\n\nint main()\n{\n    scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;k);\n    int last_zero \u003d -1;\n    for (int i \u003d 0; i \u0026lt; n; ++i) {\n        scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]);\n        if (a[i] \u003d\u003d 0) last_zero \u003d i;\n    }\n    for (int i \u003d 0; i \u0026lt; k; ++i) scanf(\u0026quot;%d\u0026quot;, \u0026amp;b[i]);\n\n    bool valid \u003d false;\n    for (int i \u003d 0; i \u0026lt; k; ++i) p[i] \u003d i;\n    do {\n        for (int i \u003d 0, ptr \u003d 0; i \u0026lt; n; ++i) {\n            r[i] \u003d (a[i] \u003d\u003d 0) ? b[p[ptr++]] : a[i];\n        }\n        if (check()) { valid \u003d true; break; }\n    } while (std::next_permutation(p, p + k));\n    puts(valid ? \u0026quot;Yes\u0026quot; : \u0026quot;No\u0026quot;);\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"814B\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution 1\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cstring\u0026gt;\nstatic const int MAXN \u003d 1e3 + 4;\n\nint n;\nint a[MAXN], b[MAXN];\nint pa[2][MAXN], pb[2][MAXN];\n\ninline void try_recover(int *a, int *p1, int *p2)\n{\n    int dup_ct \u003d 0;\n    int dup1 \u003d -1, dup2 \u003d -1, absent \u003d -1;\n    for (int i \u003d 0; i \u0026lt; n; ++i)\n        for (int j \u003d i + 1; j \u0026lt; n; ++j)\n            if (a[i] \u003d\u003d a[j]) dup1 \u003d i, dup2 \u003d j;\n    for (absent \u003d 1; absent \u0026lt;\u003d n; ++absent) {\n        bool occurred \u003d false;\n        for (int i \u003d 0; i \u0026lt; n; ++i) if (a[i] \u003d\u003d absent) { occurred \u003d true; break; }\n        if (!occurred) break;\n    }\n\n    memcpy(p1, a, n * sizeof(int));\n    memcpy(p2, a, n * sizeof(int));\n    p1[dup1] \u003d absent;\n    p2[dup2] \u003d absent;\n}\n\nint main()\n{\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    for (int i \u003d 0; i \u0026lt; n; ++i) scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]);\n    for (int i \u003d 0; i \u0026lt; n; ++i) scanf(\u0026quot;%d\u0026quot;, \u0026amp;b[i]);\n\n    try_recover(a, pa[0], pa[1]);\n    try_recover(b, pb[0], pb[1]);\n    int *ans \u003d NULL;\n    if (memcmp(pa[0], pb[0], n * sizeof(int)) \u003d\u003d 0 || memcmp(pa[0], pb[1], n * sizeof(int)) \u003d\u003d 0)\n        ans \u003d pa[0];\n    else ans \u003d pa[1];\n\n    for (int i \u003d 0; i \u0026lt; n; ++i) printf(\u0026quot;%d%c\u0026quot;, ans[i], i \u003d\u003d n - 1 ? \u0027\\n\u0027 : \u0027 \u0027);\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution 2 - Casework\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;utility\u0026gt;\nstatic const int MAXN \u003d 1e3 + 4;\n\nint n;\nint a[MAXN], b[MAXN];\n\nstd::pair\u0026lt;int, int\u0026gt; get_duplication(int *a)\n{\n    static int occ[MAXN];\n    for (int i \u003d 1; i \u0026lt;\u003d n; ++i) occ[i] \u003d -1;\n    for (int i \u003d 0; i \u0026lt; n; ++i) {\n        if (occ[a[i]] !\u003d -1) return std::make_pair(occ[a[i]], i);\n        else occ[a[i]] \u003d i;\n    }\n    return std::make_pair(-1, -1);\n}\n\ninline void fix_permutation(int pos)\n{\n    static bool occ[MAXN];\n    for (int i \u003d 1; i \u0026lt;\u003d n; ++i) occ[i] \u003d false;\n    for (int i \u003d 0; i \u0026lt; n; ++i) if (i !\u003d pos) occ[a[i]] \u003d true;\n    for (int i \u003d 1; i \u0026lt;\u003d n; ++i) if (!occ[i]) { a[pos] \u003d i; return; }\n}\n\nint main()\n{\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    for (int i \u003d 0; i \u0026lt; n; ++i) scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]);\n    for (int i \u003d 0; i \u0026lt; n; ++i) scanf(\u0026quot;%d\u0026quot;, \u0026amp;b[i]);\n\n    std::pair\u0026lt;int, int\u0026gt; dup_a, dup_b;\n    dup_a \u003d get_duplication(a);\n    dup_b \u003d get_duplication(b);\n\n    if (dup_a \u003d\u003d dup_b) {\n        a[dup_a.first] \u003d b[dup_b.first];\n    } else if (dup_a.first \u003d\u003d dup_b.first || dup_a.first \u003d\u003d dup_b.second) {\n        a[dup_a.second] \u003d b[dup_a.second];\n        fix_permutation(dup_a.first);\n    } else if (dup_a.second \u003d\u003d dup_b.first || dup_a.second \u003d\u003d dup_b.second) {\n        a[dup_a.first] \u003d b[dup_a.first];\n        fix_permutation(dup_a.second);\n    } else {\n        a[dup_a.first] \u003d b[dup_a.first];\n        a[dup_a.second] \u003d b[dup_a.second];\n    }\n\n    for (int i \u003d 0; i \u0026lt; n; ++i) printf(\u0026quot;%d%c\u0026quot;, a[i], i \u003d\u003d n - 1 ? \u0027\\n\u0027 : \u0027 \u0027);\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"814C\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\nstatic const int MAXN \u003d 1502;\nstatic const int ALPHABET \u003d 26;\n\nint n;\nchar s[MAXN];\nint ans[ALPHABET][MAXN] \u003d {{ 0 }};\nint q, m_i;\nchar c_i;\n\nint main()\n{\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); getchar();\n    for (int i \u003d 0; i \u0026lt; n; ++i) s[i] \u003d getchar() \u0026amp;mdash; \u0027a\u0027;\n\n    for (char c \u003d 0; c \u0026lt; ALPHABET; ++c) {\n        for (int i \u003d 0; i \u0026lt; n; ++i) {\n            int replace_ct \u003d 0;\n            for (int j \u003d i; j \u0026lt; n; ++j) {\n                if (s[j] !\u003d c) ++replace_ct;\n                ans[c][replace_ct] \u003d std::max(ans[c][replace_ct], j - i + 1);\n            }\n        }\n        for (int i \u003d 1; i \u0026lt; MAXN; ++i)\n            ans[c][i] \u003d std::max(ans[c][i], ans[c][i - 1]);\n    }\n\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;q);\n    for (int i \u003d 0; i \u0026lt; q; ++i) {\n        scanf(\u0026quot;%d %c\u0026quot;, \u0026amp;m_i, \u0026amp;c_i);\n        printf(\u0026quot;%d\\n\u0026quot;, ans[c_i - \u0027a\u0027][m_i]);\n    }\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"814D\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution 1 - DP on trees\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;vector\u0026gt;\ntypedef long long int64;\nstatic const int MAXN \u003d 1004;\n#ifndef M_PI\nstatic const double M_PI \u003d acos(-1.0);\n#endif\n\nint n;\nint x[MAXN], y[MAXN], r[MAXN];\nint par[MAXN];\nstd::vector\u0026lt;int\u0026gt; e[MAXN];\n\n// Whether one of C[u] and C[v] is contained in another\ninline bool circle_contains(int u, int v)\n{\n    return ((int64)(x[u] - x[v]) * (x[u] - x[v]) + (int64)(y[u] - y[v]) * (y[u] - y[v]) \u0026lt;\u003d (int64)(r[u] - r[v]) * (r[u] - r[v]));\n}\n\nint64 f[MAXN][2][2];\n\nvoid dfs_dp(int u)\n{\n    int64 g[2][2] \u003d {{ 0 }};\n    for (int v : e[u]) {\n        dfs_dp(v);\n        for (int i \u003d 0; i \u0026lt;\u003d 1; ++i)\n            for (int j \u003d 0; j \u0026lt;\u003d 1; ++j)\n                g[i][j] +\u003d f[v][i][j];\n    }\n    for (int i \u003d 0; i \u0026lt;\u003d 1; ++i)\n        for (int j \u003d 0; j \u0026lt;\u003d 1; ++j) {\n            f[u][i][j] \u003d std::max(\n                // (1) \u0026lt;u\u0026gt; is assigned to the first group\n                g[i ^ 1][j] + (int64)r[u] * r[u] * (i \u003d\u003d 0 ? +1 : -1),\n                // (2) \u0026lt;u\u0026gt; is assigned to the second group\n                g[i][j ^ 1] + (int64)r[u] * r[u] * (j \u003d\u003d 0 ? +1 : -1)\n            );\n        }\n}\n\nint main()\n{\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    for (int i \u003d 0; i \u0026lt; n; ++i) scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;x[i], \u0026amp;y[i], \u0026amp;r[i]);\n\n    for (int i \u003d 0; i \u0026lt; n; ++i) {\n        par[i] \u003d -1;\n        for (int j \u003d 0; j \u0026lt; n; ++j)\n            if (r[j] \u0026gt; r[i] \u0026amp;\u0026amp; circle_contains(i, j)) {\n                if (par[i] \u003d\u003d -1 || r[par[i]] \u0026gt; r[j]) par[i] \u003d j;\n            }\n        e[par[i]].push_back(i);\n    }\n\n    int64 ans \u003d 0;\n    for (int i \u003d 0; i \u0026lt; n; ++i) if (par[i] \u003d\u003d -1) {\n        dfs_dp(i);\n        ans +\u003d f[i][0][0];\n    }\n    printf(\u0026quot;%.8lf\\n\u0026quot;, (double)ans * M_PI);\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution 2 - Greedy\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;vector\u0026gt;\ntypedef long long int64;\nstatic const int MAXN \u003d 1004;\n#ifndef M_PI\nstatic const double M_PI \u003d acos(-1.0);\n#endif\n\nint n;\nint x[MAXN], y[MAXN], r[MAXN];\nint par[MAXN];\nstd::vector\u0026lt;int\u0026gt; e[MAXN];\n\nbool level[MAXN];\n\n// Whether one of C[u] and C[v] is contained in another\ninline bool circle_contains(int u, int v)\n{\n    return ((int64)(x[u] - x[v]) * (x[u] - x[v]) + (int64)(y[u] - y[v]) * (y[u] - y[v]) \u0026lt;\u003d (int64)(r[u] - r[v]) * (r[u] - r[v]));\n}\n\nvoid dfs_colour(int u, bool c)\n{\n    level[u] \u003d c;\n    for (int v : e[u]) dfs_colour(v, c ^ 1);\n}\n\nint main()\n{\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    for (int i \u003d 0; i \u0026lt; n; ++i) scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;x[i], \u0026amp;y[i], \u0026amp;r[i]);\n\n    for (int i \u003d 0; i \u0026lt; n; ++i) {\n        par[i] \u003d -1;\n        for (int j \u003d 0; j \u0026lt; n; ++j)\n            if (r[j] \u0026gt; r[i] \u0026amp;\u0026amp; circle_contains(i, j)) {\n                if (par[i] \u003d\u003d -1 || r[par[i]] \u0026gt; r[j]) par[i] \u003d j;\n            }\n        e[par[i]].push_back(i);\n    }\n\n    for (int i \u003d 0; i \u0026lt; n; ++i) if (par[i] \u003d\u003d -1) dfs_colour(i, false);\n    int64 ans \u003d 0;\n    for (int i \u003d 0; i \u0026lt; n; ++i)\n        ans +\u003d (int64)r[i] * r[i] * (par[i] \u003d\u003d -1 || (level[i] \u003d\u003d true) ? +1 : -1);\n    printf(\u0026quot;%.8lf\\n\u0026quot;, (double)ans * M_PI);\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eOne more thing — Staying up late is bad for health.\u003c/p\u003e \u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"814E\"\u003eTutorial is loading...\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution 1 - O(n^5)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cstring\u0026gt;\ntypedef long long int64;\nstatic const int MAXN \u003d 52;\nstatic const int MODULUS \u003d 1e9 + 7;\n#define _  %  MODULUS\n#define __ %\u003d MODULUS\n\nint n, d[MAXN];\nint64 f[2][MAXN][MAXN][MAXN][MAXN] \u003d {{{{{ 0 }}}}};\n\nint main()\n{\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    for (int i \u003d 0; i \u0026lt; n; ++i) scanf(\u0026quot;%d\u0026quot;, \u0026amp;d[i]);\n\n    int cur \u003d 0, next \u003d 1;\n    f[cur][d[0] \u003d\u003d 2][d[0] \u003d\u003d 3][d[1] \u003d\u003d 2][d[1] \u003d\u003d 3] \u003d 1;\n    for (int i \u003d 1; i \u0026lt; n - 1; ++i) {\n        memset(f[next], 0, sizeof f[next]);\n        for (int p1 \u003d 0; p1 \u0026lt;\u003d n; ++p1)\n            for (int p2 \u003d 0; p1 + p2 \u0026lt;\u003d n; ++p2)\n                for (int c1 \u003d 0; c1 + p1 + p2 \u0026lt;\u003d n; ++c1)\n                    for (int c2 \u003d 0; c1 + c2 + p1 + p2 \u0026lt;\u003d n; ++c2) if (f[cur][p1][p2][c1][c2] \u0026gt; 0) {\n                        int64 val \u003d f[cur][p1][p2][c1][c2];\n                        // (1) Start a new level\n                        if (p1 \u003d\u003d 0 \u0026amp;\u0026amp; p2 \u003d\u003d 0) {\n                            (f[cur][c1][c2][0][0] +\u003d val)__;\n                            continue;\n                        }\n                        // (2) Stay on current level\n                        // Which type of vertex in the last level?\n                        for (int last_level \u003d 0; last_level \u0026lt;\u003d 1; ++last_level) {\n                            int last_ways;\n                            if (last_level \u003d\u003d 0) {\n                                last_ways \u003d p1;\n                                if (--p1 \u0026lt; 0) { ++p1; continue; }\n                            } else {\n                                last_ways \u003d p2;\n                                if (--p2 \u0026lt; 0) { ++p2; continue; } else ++p1;\n                            }\n                            // Which type of vertices in the current level?\n                            if (d[i + 1] \u003d\u003d 2) {\n                                // a) Leave as it is\n                                (f[next][p1][p2][c1 + 1][c2] +\u003d val * last_ways)__;\n                                // b) 1-plug\n                                if (c1 \u0026gt;\u003d 1)\n                                    (f[next][p1][p2][c1 - 1][c2] +\u003d val * last_ways * c1)__;\n                                // c) 2-plug\n                                if (c2 \u0026gt;\u003d 1)\n                                    (f[next][p1][p2][c1 + 1][c2 - 1] +\u003d val * last_ways * c2)__;\n                            } else {\n                                // a) Leave as it is\n                                (f[next][p1][p2][c1][c2 + 1] +\u003d val * last_ways)__;\n                                // b) 1-plug\n                                if (c1 \u0026gt;\u003d 1)\n                                    (f[next][p1][p2][c1][c2] +\u003d val * last_ways * c1)__;\n                                // c) 2-plug\n                                if (c2 \u0026gt;\u003d 1)\n                                    (f[next][p1][p2][c1 + 2][c2 - 1] +\u003d val * last_ways * c2)__;\n                                // d) 1-plug + 1-plug\n                                if (c1 \u0026gt;\u003d 2)\n                                    (f[next][p1][p2][c1 - 2][c2] +\u003d val * last_ways * c1 * (c1 - 1) / 2)__;\n                                // e) 2-plug + 2-plug\n                                if (c2 \u0026gt;\u003d 2)\n                                    (f[next][p1][p2][c1 + 2][c2 - 2] +\u003d val * last_ways * c2 * (c2 - 1) / 2)__;\n                                // f) 1-plug + 2-plug\n                                if (c1 \u0026gt;\u003d 1 \u0026amp;\u0026amp; c2 \u0026gt;\u003d 1)\n                                    (f[next][p1][p2][c1][c2 - 1] +\u003d val * last_ways * c1 * c2)__;\n                            }\n                            if (last_level \u003d\u003d 0) ++p1; else ++p2, --p1;\n                        }\n                    }\n        cur ^\u003d 1, next ^\u003d 1;\n    }\n\n    printf(\u0026quot;%lld\\n\u0026quot;, f[cur][0][0][0][0]);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution 2 - O(n^3) by KAN\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nusing ll \u003d long long;\nusing ld \u003d long double;\nusing D \u003d double;\nusing uint \u003d unsigned int;\ntemplate\u0026lt;typename T\u0026gt;\nusing pair2 \u003d pair\u0026lt;T, T\u0026gt;;\n\n#ifdef WIN32\n    #define LLD \u0026quot;%I64d\u0026quot;\n#else\n    #define LLD \u0026quot;%lld\u0026quot;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn \u003d 55;\nconst int MOD \u003d 1000000007;\n\nint ways[maxn][maxn][maxn];\nint answer[maxn][maxn];\nint n;\nint d[maxn];\nint sumd[maxn];\n\ninline void add(int \u0026amp;a, ll b)\n{\n    a \u003d (a + b) % MOD;\n}\n\nint main()\n{\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    for (int i \u003d 0; i \u0026lt; n; i++) scanf(\u0026quot;%d\u0026quot;, \u0026amp;d[i]);\n    \n    ways[0][0][0] \u003d 1;\n    for (int c0 \u003d 0; c0 \u0026lt;\u003d n; c0++)\n    {\n        for (int c2 \u003d 0; c2 \u0026lt;\u003d n; c2++)\n        {\n            for (int c1 \u003d 0; c1 \u0026lt;\u003d n; c1++) if (c1 + c2 \u0026gt; 0)\n            {\n                if (c2 \u0026gt; 0)\n                {\n                    if (c0 \u0026gt; 1) add(ways[c0][c1][c2], (ll)ways[c0 - 2][c1][c2 - 1] * (c0 * (c0 - 1) / 2)); // 2-0, 2-0\n                    if (c2 \u0026gt; 1 \u0026amp;\u0026amp; c0 \u0026gt; 0) add(ways[c0][c1][c2], (ll)ways[c0 - 1][c1 + 1][c2 - 2] * (c2 - 1) * c0); // 2-2, 2-0\n                    if (c2 \u0026gt; 2) add(ways[c0][c1][c2], (ll)ways[c0][c1 + 2][c2 - 3] * ((c2 - 1) * (c2 - 2) / 2)); // 2-2, 2-2\n                    if (c1 \u0026gt; 0 \u0026amp;\u0026amp; c2 \u0026gt; 1) add(ways[c0][c1][c2], (ll)ways[c0][c1][c2 - 2] * c1 * (c2 - 1)); // 2-2, 2-1\n                    if (c1 \u0026gt; 0 \u0026amp;\u0026amp; c0 \u0026gt; 0) add(ways[c0][c1][c2], (ll)ways[c0 - 1][c1 - 1][c2 - 1] * c1 * c0); // 2-1, 2-0\n                    if (c1 \u0026gt; 1) add(ways[c0][c1][c2], (ll)ways[c0][c1 - 2][c2 - 1] * (c1 * (c1 - 1) / 2)); // 2-1, 2-1\n                } else\n                {\n                    if (c0 \u0026gt; 0) add(ways[c0][c1][c2], (ll)ways[c0 - 1][c1 - 1][c2] * c0); // 1-0\n                    if (c1 \u0026gt; 1) add(ways[c0][c1][c2], (ll)ways[c0][c1 - 2][c2] * (c1 - 1)); // 1-1\n                }\n            }\n        }\n    }\n    \n    for (int i \u003d 0; i \u0026lt; n; i++) sumd[i + 1] \u003d sumd[i] + d[i];\n    answer[n][n - 1] \u003d 1;\n    for (int l \u003d n - 1; l \u0026gt; 0; l--)\n    {\n        for (int r \u003d l; r \u0026lt; n; r++)\n        {\n            int cnt2 \u003d sumd[r + 1] - sumd[l] - 2 * (r - l + 1);\n            int cnt1 \u003d r - l + 1 - cnt2;\n            for (int nextlvl \u003d 0; nextlvl \u0026lt;\u003d 2 * cnt2 + cnt1 \u0026amp;\u0026amp; nextlvl \u0026lt;\u003d n; nextlvl++)\n            {\n                int curways \u003d ways[nextlvl][cnt1][cnt2];\n                if (r + nextlvl \u0026lt; n)\n                {\n                    add(answer[l][r], (ll)answer[r + 1][r + nextlvl] * curways);\n                }\n            }\n        }\n    }\n    if (d[0] + 1 \u0026gt; n) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl;\n    else cout \u0026lt;\u0026lt; answer[1][d[0]] \u0026lt;\u0026lt; endl;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eThis is the round with the most solutions so far perhaps? There are at least \u003cspan class\u003d\"tex-span\"\u003e3 × 2 × 3 × 3 × 3 \u003d 162\u003c/span\u003e different ways to pass all problems in this round \u003dD\u003c/p\u003e \u003cblockquote\u003e\u003cp\u003ePla-tinum happy though I\u0027m supposed to be\u003cbr /\u003ePla-tinum sad is somehow how I get\u003c/p\u003e \u003c/blockquote\u003e\u003cp\u003ePersonally I\u0027d like to express my gratitude to the community for creating this amazing first-time experience for me. Thank you, and see you next round. Probably it will be for Ha... Well, let\u0027s wait and see :)\u003c/p\u003e\u003cp\u003eCheers \\(^ ^)/\u003c/p\u003e\u003c/div\u003e","tags":[]}}