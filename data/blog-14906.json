{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1417113124,"rating":67,"authorHandle":"I_love_Hoang_Yen","modificationTimeSeconds":1417615981,"id":14906,"title":"\u003cp\u003e[GYM] 2014-2015 CT S02E11 — Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100540/problem/A\"\u003e100540A - Army buddies\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s restate the problem statement:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eYou need to maintain a set of alive soldiers.\u003c/li\u003e   \u003cli\u003eYou are asked to perform some queries [L, R]: remove all soldiers with index in range [L, R]. And then find the soldier with maximum index which is still less than L, and the soldier with minimum index which is still greater than R.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThe most simple way to implement this is to use C++ set. For each query:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eFind one soldier whose index is in range [L, R].\u003c/li\u003e   \u003cli\u003eRemove that soldier\u003c/li\u003e   \u003cli\u003eRepeat until there is no soldier in range [L, R].\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThis implementation runs in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e * \u003ci\u003elogN\u003c/i\u003e)\u003c/span\u003e, because:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eFor each soldier, he is only removed once from the set.\u003c/li\u003e   \u003cli\u003eFor each query, if we remove k soldiers, we need to do binary search (lower_bound) on the set k+1 times. So the total number of times we binary search is at most \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eN\u003c/i\u003e + \u003ci\u003eQ\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/2aWywr\"\u003eCode\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100540/problem/B\"\u003e100540B - Ball Stacking\u003c/a\u003e\u003c/p\u003e\u003cp\u003eConsider the figure in the problem statement. In here we have 4 columns:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eColumn 1: 3, -5, -8, 3\u003c/li\u003e   \u003cli\u003eColumn 2: 3, 2, 9\u003c/li\u003e   \u003cli\u003eColumn 3: -8, -2\u003c/li\u003e   \u003cli\u003eColumn 4: 7\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eConsider a possible configuration of choosing balls.\u003c/p\u003e\u003cp\u003eLet\u0027s call the number of balls chosen for at each column \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u003d 1..\u003ci\u003eN\u003c/i\u003e\u003c/span\u003e. In the example, we have:\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e \u003d 4\u003c/span\u003e\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e \u003d 3\u003c/span\u003e\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e \u003d 0\u003c/span\u003e\u003c/li\u003e   \u003cli\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e4\u003c/sub\u003e \u003d 0\u003c/span\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eIt is easy to see that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e ≥ \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e ≥ ... ≥ \u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eN\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eFrom this observation, we have the following DP:\u003c/p\u003e\u003cp\u003ef(j, k) \u003d maximum value, if we consider the first j columns, and at column j, we choose at least k balls.\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ej\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e) \u003d \u003ci\u003emax\u003c/i\u003e(\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ej\u003c/i\u003e - 1, \u003ci\u003ek\u003c/i\u003e\u0027) + \u003ci\u003ea\u003c/i\u003e(\u003ci\u003ej\u003c/i\u003e, 1) + \u003ci\u003ea\u003c/i\u003e(\u003ci\u003ej\u003c/i\u003e, 2) + ... + \u003ci\u003ea\u003c/i\u003e(\u003ci\u003ej\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e))\u003c/span\u003e for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u0027 ≥ \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/QPsSqd\"\u003eCode\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100540/problem/C\"\u003e100540C - Candys Candy\u003c/a\u003e\u003c/p\u003e\u003cp\u003eYou can read \u003ca href\u003d\"/blog/entry/14906#comment-199375\"\u003ethis comment\u003c/a\u003e. Thanks \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/sandyeep\" title\u003d\"Эксперт sandyeep\"\u003esandyeep\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100540/problem/D\"\u003e100540D - Diccionario Portunol\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTo solve this problem, you must first know about \u003ca href\u003d\"http://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eFirst, construct 2 tries. One for prefixes of Portugese words, and the other for suffixes of Spanish words.\u003c/p\u003e\u003cp\u003eFor example, in the first example, the prefix trie for Portugese words will contain:\u003c/p\u003e \u003cul\u003e   \u003cli\u003em, ma, mai, mais\u003c/li\u003e   \u003cli\u003eg, gr, gra, gran, grand, grande\u003c/li\u003e   \u003cli\u003eun, und, undo.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eNote that I intentionally removed the prefix \u0026quot;m\u0026quot; of the 3rd word, because it is repeated.\u003c/p\u003e\u003cp\u003eAfter building 2 tries, you can see that the answer is \u0026quot;near\u0026quot; (size of trie 1) * (size of trie 2). I said near, because there are some words that were counted more than once, for example: \u003cspan class\u003d\"tex-span\"\u003e\u0026quot;\u003ci\u003egrande\u003c/i\u003e\u0026quot; \u003d \u0026quot;\u003ci\u003eg\u003c/i\u003e\u0026quot; + \u0026quot;\u003ci\u003erande\u003c/i\u003e\u0026quot; \u003d \u0026quot;\u003ci\u003egr\u003c/i\u003e\u0026quot; + \u0026quot;\u003ci\u003eande\u003c/i\u003e\u0026quot; \u003d \u0026quot;\u003ci\u003egra\u003c/i\u003e\u0026quot; + \u0026quot;\u003ci\u003ende\u003c/i\u003e\u0026quot; \u003d ...\u003c/span\u003e\u003c/p\u003e\u003cp\u003eSo you need to find how many words are counted more than once. This can also be solved using the tries we just built.\u003c/p\u003e\u003cp\u003eLet denote by + the string concatenation operation, and let a, b, x, y be strings and w be a character.\u003c/p\u003e\u003cp\u003eConsider Portugese words: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + \u003ci\u003ew\u003c/i\u003e + \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e + \u003ci\u003ew\u003c/i\u003e + \u003ci\u003ey\u003c/i\u003e\u003c/span\u003e. We can easily see that for each non-empty string a and y, this word is counted at least twice. To count these duplication, we need to count how many pairs of (x, b) exists for each w. For each character w, this value equals to the number of suffix of Portugese words starts with w, times the number of prefix of Spanish words ends with w.\u003c/p\u003e\u003cp\u003eSee \u003ca href\u003d\"http://ideone.com/MpKN1N\"\u003emy code\u003c/a\u003e for more details.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100540/problem/E\"\u003e100540E - Electrical Pollution\u003c/a\u003e\u003c/p\u003e\u003cp\u003eLet\u0027s denote by F(x) the anomalies produced by generator at point(x, x).\u003c/p\u003e\u003cp\u003eI have not solved this, but I have the following idea:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eCreate a graph. For each equation of the form: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) + \u003ci\u003eF\u003c/i\u003e(\u003ci\u003ey\u003c/i\u003e) \u003d \u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, add edge between vertex x and y.\u003c/li\u003e   \u003cli\u003eFor each connected component of the graph, choose one vertex z, and represents all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e) \u003d \u003ci\u003econst\u003c/i\u003e - \u003ci\u003eF\u003c/i\u003e(\u003ci\u003ez\u003c/i\u003e)\u003c/span\u003e. After doing this, for components with cycles, you should be able to get values of all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e.\u003c/li\u003e   \u003cli\u003eTo answer queries, just use the values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eF\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e calcualted above.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSince I haven\u0027t implemented this idea, I\u0027m not sure if I\u0027ve missed something.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100540/problem/F\"\u003e100540F - File Retrieval\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis problem requires Suffix Array.\u003c/p\u003e\u003cp\u003eFirst of all, concat all the strings in input, separated by some unique characters (For example, use characters with ASCII code 1 to F).\u003c/p\u003e\u003cp\u003eBuild Suffix Array on this string, and calculate LCP array.\u003c/p\u003e\u003cp\u003eNow, to count the number of searchable set, observe the following facts:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eFor each searchable set, there\u0027s a keyword K for this set.\u003c/li\u003e   \u003cli\u003eThis keyword K corresponds to a prefix of a suffix in our Suffix Array.\u003c/li\u003e   \u003cli\u003eIt\u0027s transparent that the searchable sets have consecutive suffixes in our Suffix Array, where K is their prefixes. Because of this, the corresponding LCP of these will be at least \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003eK\u003c/i\u003e|\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSo, we can iterate through all searchable set, by iterating through K, but we must do this while keeping the following in mind:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eFor each searchable set, there can be more than one K. They can be substring of each other. To avoid duplication, we must store all the searchable sets in a hash table (for example, use C++ set).\u003c/li\u003e   \u003cli\u003eWhen we iterate, we use Suffix Array. For each position, we consider it as having the smallest value of LCP in our set.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThere are some more implementation details, and it is hard to explain everything here. Please refer to \u003ca href\u003d\"http://ideone.com/GPwGVF\"\u003ecode\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/GPwGVF\"\u003eCode\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100540/problem/G\"\u003e100540G - Garden Fence\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis should be a sweep line problem. During contest, I\u0027ve tried rotating the points, but it did not work (probably because the function we\u0027re calculating is not continuous, so rotating can not work well?)\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100540/problem/H\"\u003e100540H - Hedge Mazes\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is a graph theory problem. To solve this problem, you must be familiar with [bridges](\u003ca\u003ehttp://en.wikipedia.org/wiki/Bridge_(graph_theory\u003c/a\u003e) ).\u003c/p\u003e\u003cp\u003eLet\u0027s say we need to answer query A B. Find an arbitrary path from A to B. Then, you can see that this path is unique, if and only if all the edges on the path are bridges of the graph. Proving this is a bit tricky, though it is easy to understand why this is correct:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eIf one edge on the path is not bridge, you\u0027ll be able to construct another path from A to B.\u003c/li\u003e   \u003cli\u003eIf all edges on the path are bridges, obviously, you have only one path.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eBased on the above observation, you can solve the problem as follows:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eFirst, remove all edges of the graph which are not bridges.\u003c/li\u003e   \u003cli\u003eThen, use disjoint set (also known as DSU) to maintain the connected components in this new graph.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eFor each query, you just need to make queries on disjoint set to check if 2 vertices belong to same connected component of the new graph.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/RvuuND\"\u003eMy code\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100540/problem/I\"\u003e100540I - In Braille\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is a straight-forward implementation problem:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eFor instruction of type B, just compare the input with each Braille characters to find the corresponding digit.\u003c/li\u003e   \u003cli\u003eFor instruction of type S, just print the Braille characters corresponding to each digit in input.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSince the size of input is small, any naive implementation should run in time.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"http://ideone.com/0lmf3i\"\u003eCode\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100540/problem/J\"\u003e100540J - Jupiter Attacks!\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIn this problem, you are asked to perform two types of queries:\u003c/p\u003e \u003cul\u003e   \u003cli\u003eModify one element of array\u003c/li\u003e   \u003cli\u003eCalculate hash value of a subarray.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eThe most straight-forward way to solve this type of problem, is to use some Data structures that can handle range update \u0026amp; query. I used segment tree. If you are not familiar with it, you can read more \u003ca href\u003d\"https://www.topcoder.com/tc?module\u003dStatic\u0026amp;d1\u003dtutorials\u0026amp;d2\u003dlowestCommonAncestor#Segment_Trees\"\u003ehere\u003c/a\u003e and \u003ca href\u003d\"//codeforces.com/blog/entry/3327\"\u003ehere\u003c/a\u003e or at many other places on the Internet.\u003c/p\u003e\u003cp\u003eIn addition to Segment tree, you need to know how to do combine the Hash values of 2 consecutive segments. Let\u0027s say you have segment [u, v] and [x, y] where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e + 1 \u003d \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. If you know \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehash\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehash\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e, you can calculate \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehash\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e:\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ehash\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e) \u003d \u003ci\u003ehash\u003c/i\u003e(\u003ci\u003eu\u003c/i\u003e, \u003ci\u003ev\u003c/i\u003e) * \u003ci\u003eB\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ey\u003c/i\u003e - \u003ci\u003ex\u003c/i\u003e + 1\u003c/sup\u003e + \u003ci\u003ehash\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e, \u003ci\u003ey\u003c/i\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eYou can read \u003ca href\u003d\"http://ideone.com/TStVLu\"\u003emy code\u003c/a\u003e to see how I implemented this Segment tree.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100540/problem/K\"\u003e100540K - Kings Poker\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis is again an implementation. Though, you need to handle corner cases very carefully. One downfall is that each number cannot appear more than 4 times. Let\u0027s call the 3 numbers in input a, b, and c.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003cp\u003eif \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d \u003ci\u003eb\u003c/i\u003e \u003d \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e: Then, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d 13\u003c/span\u003e, there is no solution, otherwise, the optimal solution is set containing three \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e + 1\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eif a, b, c are pairwise distinct: You can use the smallest pair: 1 1 2. This works because no number can appear more than 4 times.\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThe last case is where a, b and c forms a pair. For this case, I used brute-force to check for every pair. If no pair is greater than this pair, this pair must be 13 13 12, and you can use the set 1 1 1.\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSee \u003ca href\u003d\"http://ideone.com/ACOA3z\"\u003emy code\u003c/a\u003e for more details.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100540/problem/L\"\u003e100540L - Gates\u003c/a\u003e\u003c/p\u003e\u003cp\u003eL \u0026amp; M solution will be updated if I can solve them.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"/gym/100540/problem/M\"\u003e100540M - Game\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":["acm","gym","editorial"]}}