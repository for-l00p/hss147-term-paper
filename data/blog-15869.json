{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1421627992,"rating":140,"authorHandle":"MikeMirzayanov","modificationTimeSeconds":1421629586,"id":15869,"title":"\u003cp\u003eTODO: Open addressing hash table on C++\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHello, Codeforces!\u003c/p\u003e\u003cp\u003eIn late December and early January, I wrote a proof-of-concept of separate service in C ++, to take out heavy data from the Codeforces Java-code to C++. Long time I have not written in C ++, experienced a funny sense of immersion into another world.\u003c/p\u003e\u003cp\u003eI was surprised to find the lack of open-addressing hashmap in the C++ standard library, and indeed in the boost, and in other popular libraries. It is strange somehow, because often open addressing should be better than separate chaining both in time and memory. And since I intend to keep small objects, then sure.\u003c/p\u003e\u003cp\u003eI quickly sketched a prototype that actually shows that open addressing in 2-3 times faster than the standard std::unordered_map. Here\u0027s the output of the benchmark on my laptop:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estd :: map takes 15779 ms\nstd :: unordered_map takes 4698 ms\noaht :: hash_map takes 1473 ms\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI think that there is no good implementation of such container in stl-style with the support of C++11 (move semantics). Maybe someone will show, but I have not found.\u003c/p\u003e\u003cp\u003eHere is my prototype on github: \u003ca href\u003d\"https://github.com/MikeMirzayanov/open_addressing_hash_table\"\u003ehttps://github.com/MikeMirzayanov/open_addressing_hash_table\u003c/a\u003e Unfortunately, I\u0027m not cool C ++ expert, and I have no time to implement.\u003c/p\u003e\u003cp\u003eOn the other hand, on Codeforces where were many C ++- discussions, and seems there many users who understand modern C ++. Also algorithms are water and air of Codeforces! I have hope that the universal mind Codeforces and straight hands of someone in the community will help bring to life such a container. Of course, we want maximum compatibility with std::unordered_map (API and semantics should be equivalent where it is possible). Here is a sample list of features that I want to see:\u003c/p\u003e \u003col\u003e   \u003cli\u003eOne more template type parameter \u003ccode\u003eclass Pred \u003d std::equal_to\u0026lt;Key\u0026gt;\u003c/code\u003e\u003c/li\u003e   \u003cli\u003eMember function \u003ccode\u003eat\u003c/code\u003e\u003c/li\u003e   \u003cli\u003eMember function \u003ccode\u003eclear\u003c/code\u003e\u003c/li\u003e   \u003cli\u003eMember function \u003ccode\u003eempty\u003c/code\u003e\u003c/li\u003e   \u003cli\u003eMember function \u003ccode\u003einsert\u003c/code\u003e\u003c/li\u003e   \u003cli\u003eMember function \u003ccode\u003eequal_range\u003c/code\u003e\u003c/li\u003e   \u003cli\u003eMember function \u003ccode\u003eswap\u003c/code\u003e\u003c/li\u003e   \u003cli\u003eMember function \u003ccode\u003eoperator\u003d\u003c/code\u003e\u003c/li\u003e   \u003cli\u003eMember functions \u003ccode\u003eload_factor\u003c/code\u003e, \u003ccode\u003emax_load_factor\u003c/code\u003e, \u003ccode\u003erehash\u003c/code\u003e, \u003ccode\u003ereserve\u003c/code\u003e\u003c/li\u003e   \u003cli\u003eConstant members\u003c/li\u003e   \u003cli\u003eMember types: \u003ccode\u003edifference_type\u003c/code\u003e, \u003ccode\u003ehasher\u003c/code\u003e, \u003ccode\u003ekey_type\u003c/code\u003e, \u003ccode\u003emapped_type\u003c/code\u003e, \u003ccode\u003ereference\u003c/code\u003e, \u003ccode\u003esize_type\u003c/code\u003e, \u003ccode\u003evalue_type\u003c/code\u003e, \u003ccode\u003epointer\u003c/code\u003e, \u003ccode\u003econst_reference\u003c/code\u003e, \u003ccode\u003ekey_equal\u003c/code\u003e\u003c/li\u003e   \u003cli\u003eIterators: member types \u003ccode\u003eiterator\u003c/code\u003e, \u003ccode\u003econst_iterator\u003c/code\u003e, member functions \u003ccode\u003ebegin\u003c/code\u003e, \u003ccode\u003eend\u003c/code\u003e, \u003ccode\u003ecbegin\u003c/code\u003e, \u003ccode\u003ecend\u003c/code\u003e\u003c/li\u003e   \u003cli\u003eMember function \u003ccode\u003eemplace\u003c/code\u003e\u003c/li\u003e   \u003cli\u003eMember function \u003ccode\u003eemplace_hint\u003c/code\u003e\u003c/li\u003e   \u003cli\u003eRelational operators\u003c/li\u003e   \u003cli\u003eNon-member function overload: swap\u003c/li\u003e   \u003cli\u003eMove semantics\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eIn addition, I want to keep it working on popular C ++ 11 compilers: g ++, Visual Studio 13+, clang. Please try to follow the code style of \u003ccode\u003eoaht.h\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eI\u0027ll be happy to delegate the management of this project to someone who has the enthusiasm, knowledge of C ++ and have proven experience in the problems. I\u0027m looking for volunteer! Codeforces t-shirt and +5 to your honor guaranteed.\u003c/p\u003e\u003cp\u003eP.S. As a result we want to have a good implementation, so there is a desire to put into the project only correct and well-written code.\u003c/p\u003e\u003c/div\u003e","tags":["hash","hashtable","c++","c++11","hashmap","open addressing"]}}