{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1491553838,"rating":5,"authorHandle":"Lance_HAOH","modificationTimeSeconds":1500279788,"id":51472,"title":"\u003cp\u003eInteractive sorting problem in atcoder\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI am trying to solve an interactive problem from atcoder\u0027s practice contest. The abridged problem statement is as follows:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eGiven the value of N where N ranges from [1,26] and Q where Q is the maximum number of queries that one can make, sort a list of distinct uppercase alphabets in ascending order. N indicates that there are N characters starting from \u0027A\u0027. Hence, N \u003d 5 means that our final list must contain \u0027A\u0027, \u0027B\u0027, \u0027C\u0027, \u0027D\u0027 and \u0027E\u0027.\n\nA single query is defined as printing out a string \u0026quot;? x y\u0026quot; where x and y represent the characters we want to check the relation between (e.g. \u0026quot;? A B\u0026quot;). The problem restricts the number of such queries to Q. Hence, we must determine the final order of the characters using at most Q queries.\n\nFor each query, we get a binary answer \u0027\u0026lt;\u0027 or \u0027\u0026gt;\u0027 from stdin. \u0027\u0026lt;\u0027 indicates that x comes before y in the final list. \u0027\u0026gt;\u0027 means otherwise.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eProblem link: \u003ca href\u003d\"http://practice.contest.atcoder.jp/tasks/practice_2\"\u003ehere\u003c/a\u003e (Do note that atcoder account is needed to view the task)\u003c/p\u003e\u003cp\u003eMy attempt:\u003c/p\u003e\u003cp\u003eI tried using merge sort to solve the problem — I changed the comparison at the merging step to get the ordering of characters using the console. I managed to solve constraints for N\u003d26, Q\u003d100. However, the strictest task requires a solution that fulfils the constraints N\u003d5, Q\u003d7.\u003c/p\u003e\u003cp\u003eAfter some research, I found that merge sort\u0027s worst case number of comparisons is n * ceil(logn) — 2^(ceil(logn)) + 1 which gives 8 in this case. I couldn\u0027t find a better sorting algorithm that would solve the problem — I even tried STL sort which proved to be worse than merge sort.\u003c/p\u003e\u003cp\u003eCould anyone please advise me on how I could solve this problem?\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eU.D.\u003c/strong\u003e I just revisited this problem today. I solved it by using a single comparison to detect if there were exactly 5 elements with at most 7-comparisons. If this were true, I hard-coded a separate comparison-efficient function to handle this. Otherwise, just use merge-sort.\u003c/p\u003e\u003cp\u003eAC code \u003ca href\u003d\"http://practice.contest.atcoder.jp/submissions/1435009\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e","tags":["sorting","interactive problem","atcoder"]}}