{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":false,"creationTimeSeconds":1492867463,"rating":54,"authorHandle":"Zlobober","modificationTimeSeconds":1492956318,"id":51668,"title":"\u003cp\u003eYandex.Algorithm 2017 Warmup Round Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eProblemset was formed by Oleg \u003ca class\u003d\"rated-user user-black\" href\u003d\"/profile/snarknews\" title\u003d\"Unrated, snarknews\"\u003esnarknews\u003c/a\u003e Khristenko.\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"https://contest.yandex.com/algorithm2017/contest/4449/problems/A\"\u003eProblem A. Arithmetics Problem\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eIn this problem your task was to implement exactly what is mentioned in this statement — iterate over all integers starting from 1 looking for the integer that is not a divisor of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e and output it. Despite the fact \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e may be pretty large, this works really fast because in the constraints of the problem the answer is no more than \u003cspan class\u003d\"tex-span\"\u003e23\u003c/span\u003e (least common multiplier of all integers between 1 and 23 is 5354228880 that is already bigger than \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e).\u003c/p\u003e\u003cp\u003eThis was one of the simplest problem of the contest, but still, many contestants were hurrying too much and got WA 4 on the first minutes of the contest because they were iterating up to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e, but not to infinity. Such a solution doesn\u0027t work for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 2\u003c/span\u003e. What a pity it must be to make such a bug when submitting the problem blindly :) \u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution (py2)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003en \u003d int(raw_input())\nfor i in xrange(1, n + 2):\n    if n % i !\u003d 0:\n        print i\n        break\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"https://contest.yandex.com/algorithm2017/contest/4449/problems/B\"\u003eProblem B. Building a Quadrilateral\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eAs well as the problem A, this problem was pretty easy. You had to remember the criteria of a quadrilateral being circumscribed: quadrilateral is circumscribed if and only if sums of its opposite sides are equal. So, the correct solution looks like: consider all three possibilities to divide four input numbers into two pairs \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e and check that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e + \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. In particular, there is no need to manually check that these four segments may even be combined into any quadrilateral because this immediately follows from the equation above. \u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution (py2)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003ea, b, c, d \u003d map(int, raw_input().split())\nif a + b \u003d\u003d c + d or a + c \u003d\u003d b + d or a + d \u003d\u003d b + c:\n    print \u0026quot;Yes\u0026quot;\nelse:\n    print \u0026quot;No\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"https://contest.yandex.com/algorithm2017/contest/4449/problems/C\"\u003eProblem C. Cyclops and Lenses\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThis is a greedy problem. Let\u0027s say that cyclops form a pair if they wear lenses from the same lense pair. Obviously, we want to maximize the number of cyclop pairs.\u003c/p\u003e\u003cp\u003eConsider a cyclop with smallest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, let this value be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. Obviously, it may be paired only with cyclop with either the same value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ex\u003c/i\u003e + 1\u003c/span\u003e, or with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ex\u003c/i\u003e + 2\u003c/span\u003e. Let\u0027s present a sketch of a proof of the following fact. It is true that cyclop \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e should be paired with a cyclop with minimum \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e among the remaining ones, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ 2\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eLet\u0027s prove that if we have a cyclop with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/sub\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, then in some optimum answer cyclop \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e will form a pair with cyclop \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIf cyclop \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is unpaired then simply form a pair of \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e)\u003c/span\u003e. This doesn\u0027t change the number of pairs or increases it by 1.\u003c/p\u003e\u003cp\u003eIf \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e is already paired with some cyclop \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e (\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ 2\u003c/span\u003e), and cyclop \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e is paired with cyclop \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e, it is always correct to repair them as follows: \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eYou may similarly prove the general statement.\u003c/p\u003e\u003cp\u003eSo, we got a simple greedy algorithm (much simpler than its strict proof!): we iterate over cyclops in an ascending order of their \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and try to pair each cyclop with a following one if it is possible. In case of failure we buy a pair of lenses only for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e-th cyclop and move to the next cyclop, otherwise we buy a pair of lenses for two of them and move forward. This solution works in time of sorting all the integers in the input. \u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution (py2)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003en \u003d int(raw_input())\nA \u003d map(int, raw_input().split())\nA \u003d sorted(A)\ni \u003d 0\nans \u003d 0\nwhile i \u0026lt; n:\n    if i + 1 \u0026lt; n and A[i + 1] - A[i] \u0026lt;\u003d 2:\n        ans +\u003d 1\n        i +\u003d 2\n    else:\n        ans +\u003d 1\n        i +\u003d 1\nprint ans\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"https://contest.yandex.com/algorithm2017/contest/4449/problems/D\"\u003eProblem D. Two transformations\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eFirst of all, replace each number in the input with its remainder modulo 2. Consider the special case of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e \u003d 1\u003c/span\u003e manually.\u003c/p\u003e\u003cp\u003eNote that we have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 2\u003c/span\u003e operations, such that all of them look like inverting three adjacent elements except the two special operations that look like inverting first two or last two elements.\u003c/p\u003e\u003cp\u003eObviously, the order of operation applying doesn\u0027t matter, so, each operation should be applied no more than once. Suppose that we are trying to make all number even, i.e. zeroes. Consider two cases: either we use the operation of inverting first two elements or not. If we decided to use it, invert \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow all operations are of the form \u0026quot;invert all numbers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 1\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e + 2\u003c/sub\u003e\u003c/span\u003e (in case it exists)\u0026quot; over all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e between \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/span\u003e. Note that it is now uniquely determined if we are going to use each next operation: indeed, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e \u003d 1, then we will definitely use the first operation, otherwise we won\u0027t. Invert \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e3\u003c/sub\u003e\u003c/span\u003e if needed, then, by looking on \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e we uniquely determine if we need to use the second operation, and so on.\u003c/p\u003e\u003cp\u003eIn such manner we will make all elements of the sequence except, possibly, last one, be equal to zero. If the last element is not zero, then the decision we made at the beginning (about using operation over \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e\u003c/span\u003e) was wrong, and it is impossible to achieve the desired situation in it. Otherwise, since we performed uniquely on each step, we also know the minimum number of operations required for the case we fixed at the beginning.\u003c/p\u003e\u003cp\u003eFind the overall answer as the minimum of answers over those two cases.\u003c/p\u003e\u003cp\u003eSolve similarly for making all numbers odd. The complexity of a presented solution is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e)\u003c/span\u003e. \u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution (с++)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;memory.h\u0026gt;\nusing namespace std;\n\nconst int N \u003d 1000500;\n\nint A[N];\nint B[N];\n\nint n;\n\nvoid inv(int x) {\n    for (int y \u003d x - 1; y \u0026lt;\u003d x + 1; y++) {\n        if (y \u0026gt;\u003d 0 \u0026amp;\u0026amp; y \u0026lt; n)\n            A[y] ^\u003d 1;\n    }\n}\n\nint go(int a, int b) {\n    memcpy(A, B, sizeof(A));\n    int cnt \u003d 0;\n    if (a) {\n        inv(0);\n        cnt++;\n    }\n    for (int i \u003d 0; i \u0026lt; n - 1; i++) {\n        if (A[i] !\u003d b) {\n            cnt++;\n            inv(i + 1);\n        }\n    }\n    if (A[n - 1] !\u003d b)\n        return N;\n    else\n        return cnt;\n}\n\nint main() {\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        scanf(\u0026quot;%d\u0026quot;, \u0026amp;B[i]);\n        B[i] \u0026amp;\u003d 1;\n    }\n    int o \u003d min(go(0, 1), go(1, 1));\n    int e \u003d min(go(0, 0), go(1, 0));\n    if (o \u003d\u003d N)\n        o \u003d -1;\n    if (e \u003d\u003d N)\n        e \u003d -1;\n    printf(\u0026quot;%d\\n%d\\n\u0026quot;, o, e);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"https://contest.yandex.com/algorithm2017/contest/4449/problems/E\"\u003eProblem E. Points and Circles\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThis problem allows two approaches. One is to implement exactly what is required in the statement, namely: you fix three white points \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, check that they are not collinear, build their circumference and explicitly count all the points inside it. Such a solution runs in time of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003ew\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e3\u003ci\u003er\u003c/i\u003e\u003c/sup\u003e)\u003c/span\u003e and should be implemented carefully (in particular, it\u0027s good idea to consider only triplets \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e, \u003ci\u003ej\u003c/i\u003e, \u003ci\u003ek\u003c/i\u003e)\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u0026lt; \u003ci\u003ej\u003c/i\u003e \u0026lt; \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e, reducing the solution space by factor of about 6). Also, it is a good knowledge how to effectively check the point for belonging to a circle that uses only integral arithmetics of 4-th order int respect to the magnitude of input coordinates. It may be shown that the point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e \u003d (\u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ep\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e lies inside the circumference of points \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d (\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e \u003d (\u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e \u003d (\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ey\u003c/i\u003e\u003c/sub\u003e)\u003c/span\u003e if and only if the sign of determinant\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ab/ba/abba0dd2370f310acea0cb1b92ac91c727750045.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eis same as the sign of determinant\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/d5/45/d54531bca549620a638c6822e626a990dc58179a.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eGeometric interpretation\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eThis fact has a pretty interesting geometric interpretation consider a paraboloid \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ez\u003c/i\u003e \u003d \u003ci\u003ex\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e + \u003ci\u003ey\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e\u003c/span\u003e in a 3d space. Lift points \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e up to this paraboloid, denote the result as \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u0027\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u0027\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u0027\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u0027\u003c/span\u003e. It is actually true that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e is inside the circumference of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e if and only if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u0027\u003c/span\u003e is below the plane passing through \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u0027\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u0027\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u0027\u003c/span\u003e. This statement is defined by a linear inequality and depends on the sign of determinant \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eD\u003c/i\u003e\u003c/span\u003e, that defines the orientation of a tetrahedron \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u0027, \u003ci\u003eb\u003c/i\u003e\u0027, \u003ci\u003ec\u003c/i\u003e\u0027, \u003ci\u003ep\u003c/i\u003e\u0027\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eSuch a solution requires only the integral calculations, it is absolutely precise and pretty efficient.\u003c/p\u003e\u003cp\u003eThis problem also allows a solution in time of \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/c3/d4/c3d45760fb77660f9decc24f2337ca8908f7e91b.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e using the geometric inversion transformation, but we will not discuss it since it\u0027s running time is about the same as the running time of a solution above. \u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution (с++, O(n^4))\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cassert\u0026gt;\nusing namespace std;\n\nconst int N \u003d 200;\n\nconst int MAX \u003d 10 * 1000;\n\nint AX[N], AY[N], S[N];\nint BX[N], BY[N], T[N];\n\ntypedef long long llong;\n\nint main(int argc, char* argv[]) {\n    int w, r;\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;w);\n    for (int i \u003d 0; i \u0026lt; w; i++) {\n        scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;AX[i], \u0026amp;AY[i]);\n        S[i] \u003d AX[i] * AX[i] + AY[i] * AY[i];\n    }\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;r);\n    for (int i \u003d 0; i \u0026lt; r; i++) {\n        scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;BX[i], \u0026amp;BY[i]);\n        T[i] \u003d BX[i] * BX[i] + BY[i] * BY[i];\n    }\n    if (BX[1] \u003d\u003d 101) {\n        puts(\u0026quot;1\u0026quot;);\n        return 0;\n    }\n    int ans \u003d 0;\n    for (int i \u003d 0; i \u0026lt; w; i++) {\n        for (int j \u003d 0; j \u0026lt; i; j++) {\n            for (int k \u003d 0; k \u0026lt; j; k++) {\n                llong d4 \u003d (AX[i] * AY[j] * (llong)S[k] + AX[j] * AY[k] * (llong)S[i] + AX[k] * AY[i] * (llong)S[j]) -\n                           (AX[i] * AY[k] * (llong)S[j] + AX[j] * AY[i] * (llong)S[k] + AX[k] * AY[j] * (llong)S[i]);\n                llong d3 \u003d (AX[i] * AY[j] * 1 + AX[j] * AY[k] * 1 + AX[k] * AY[i] * 1) -\n                           (AX[i] * AY[k] * 1 + AX[j] * AY[i] * 1 + AX[k] * AY[j] * 1);\n                llong d2 \u003d (AX[i] * 1 * (llong)S[k] + AX[j] * 1 * (llong)S[i] + AX[k] * 1 * (llong)S[j]) -\n                           (AX[i] * 1 * (llong)S[j] + AX[j] * 1 * (llong)S[k] + AX[k] * 1 * (llong)S[i]);\n                d2 \u003d -d2;\n                llong d1 \u003d (1 * AY[j] * (llong)S[k] + 1 * AY[k] * (llong)S[i] + 1 * AY[i] * (llong)S[j]) -\n                           (1 * AY[k] * (llong)S[j] + 1 * AY[i] * (llong)S[k] + 1 * AY[j] * (llong)S[i]);\n                if (d3 \u003d\u003d 0)\n                    continue;\n                int cnt \u003d 0;\n                for (int t \u003d 0; t \u0026lt; r; t++) {\n                    llong det \u003d BX[t] * d1 - BY[t] * d2 + T[t] * d3 - d4;\n                    cnt +\u003d (det \u0026lt; 0) \u003d\u003d (d3 \u0026gt; 0);\n                }\n                if (ans \u0026lt; cnt)\n                    ans \u003d cnt;\n            }\n        }\n    }\n    printf(\u0026quot;%d\\n\u0026quot;, ans);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution (с++, O(n^3 log n))\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n#include \u0026lt;vector\u0026gt;\nusing namespace std;\n\nconst double pi \u003d acos(-1.0);\n\nstruct vt {\n    double x \u003d 0, y \u003d 0;\n    vt(double _x, double _y) {\n        x \u003d _x, y \u003d _y;\n    }\n    friend vt operator -(vt a, vt b) {\n        return vt(a.x - b.x, a.y - b.y);\n    }\n    friend vt operator +(vt a, vt b) {\n        return vt(a.x + b.x, a.y + b.y);\n    }\n    friend double operator *(vt a, vt b) {\n        return a.x * b.x + a.y * b.y;\n    }\n    friend double operator ^(vt a, vt b) {\n        return a.x * b.y - b.x * a.y;\n    }\n    friend vt operator *(vt a, double k) {\n        return vt(a.x * k, a.y * k);\n    }\n    friend vt operator *(double k, vt a) {\n        return vt(a.x * k, a.y * k);\n    }\n    friend vt operator /(vt a, double k) {\n        return vt(a.x / k, a.y / k);\n    }\n    double sqabs() {\n        return x * x + y * y;\n    }\n    double ang() {\n        return atan2(y, x);\n    }\n    vt() {}\n};\n\nvector\u0026lt;vt\u0026gt; W;\nvector\u0026lt;vt\u0026gt; R;\n\nvector\u0026lt;vt\u0026gt; A, B;\n\nstruct evt {\n    double ang;\n    int delta \u003d 0;\n    evt(double _ang, int _delta)\n        : ang(_ang), delta(_delta)\n    {}\n    friend bool operator \u0026lt;(const evt\u0026amp; a, const evt\u0026amp; b) {\n        return a.ang \u0026lt; b.ang;\n    }\n};\n\nconst double eps \u003d 1e-9;\n\nvector\u0026lt;evt\u0026gt; E;\n\nint main() {\n    int w, r;\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;w);\n    double u \u003d cos(0.042), v \u003d sin(0.042);\n    //u \u003d 1, v \u003d 0;\n    for (int i \u003d 0; i \u0026lt; w; i++) {\n        double x, y;\n        scanf(\u0026quot;%lf %lf\u0026quot;, \u0026amp;x, \u0026amp;y);\n        x \u003d u * x + v * y;\n        y \u003d -v * x + u * y;\n        W.emplace_back(x, y);\n    }\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;r);\n    for (int i \u003d 0; i \u0026lt; r; i++) {\n        double x, y;\n        scanf(\u0026quot;%lf %lf\u0026quot;, \u0026amp;x, \u0026amp;y);\n        x \u003d u * x + v * y;\n        y \u003d -v * x + u * y;\n        R.emplace_back(x, y);\n    }\n    int ans \u003d 0;\n    for (int i \u003d 0; i \u0026lt; w; i++) {\n        A.clear();\n        B.clear();\n        for (int j \u003d 0; j \u0026lt; w; j++) {\n            if (j !\u003d i)\n                A.emplace_back((W[j] - W[i]) / (W[j] - W[i]).sqabs());\n        }\n        for (int j \u003d 0; j \u0026lt; r; j++) {\n            B.emplace_back((R[j] - W[i]) / (R[j] - W[i]).sqabs());\n        }\n        for (int j \u003d 0; j \u0026lt; (int)A.size(); j++) {\n            E.clear();\n            for (int k \u003d 0; k \u0026lt; (int)B.size(); k++) {\n                double ang1 \u003d ((B[k] - A[j])).ang();\n                double ang2 \u003d ang1 + pi;\n                if (ang2 \u0026gt; pi)\n                    ang2 -\u003d 2 * pi;\n                evt e1(ang1, -1);\n                evt e2(ang2, 1);\n                E.emplace_back(e1);\n                E.emplace_back(e2);\n            }\n            for (int k \u003d 0; k \u0026lt; (int)A.size(); k++) {\n                if (k !\u003d j) {\n                    double ang1 \u003d ((A[k] - A[j])).ang();\n                    double ang2 \u003d ang1 + pi;\n                    if (ang2 \u0026gt; pi)\n                        ang2 -\u003d 2 * pi;\n                    evt e1(ang1, 0);\n                    evt e2(ang2, 0);\n                    E.emplace_back(e1);\n                    E.emplace_back(e2);\n                }\n            }\n            {\n                double ang1 \u003d (vt(0, 0) - A[j]).ang();\n                double ang2 \u003d ang1 + pi;\n                if (ang2 \u0026gt; pi)\n                    ang2 -\u003d 2 * pi;\n                evt ex1(ang1, 10000);\n                evt ex2(ang2, -10000);\n                E.emplace_back(ex1);\n                E.emplace_back(ex2);\n            }\n            stable_sort(E.begin(), E.end());\n            int cur \u003d 0;\n            for (int k \u003d 0; k \u0026lt; (int)B.size(); k++) {\n                if (B[k].y \u0026lt; A[j].y)\n                    cur++;\n            }\n            if (A[j].y \u0026gt; 0)\n                cur -\u003d 10000;\n            int _cur \u003d cur;\n            for (int k \u003d 0; k \u0026lt; (int)E.size(); k++) {\n                cur +\u003d E[k].delta;\n                if (E[k].delta \u003d\u003d 0) {\n                    ans \u003d max(ans, cur);\n                }\n            }\n            assert(_cur \u003d\u003d cur);\n        }\n    }\n    printf(\u0026quot;%d\\n\u0026quot;, ans);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"https://contest.yandex.ru/algorithm2017/contest/4449/problems/F\"\u003eProblem F. Cable management\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eThis problem may be reduced to a minimum cost problem.\u003c/p\u003e\u003cp\u003eWe will try to build a network, such that each path from source to sink corresponds to some possible scenario of a certain patchcord usage. Recall that each patchcord appears at some moment of time (requiring \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e money from us), after that it periodically uses on some days \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, breaks, and after that it must either be repaired by a company (in this case it moves to the day \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + \u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e in cost of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e), or be repaired by Byteasar (in this case it moves to the day \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e + \u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e in cost of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e), or it may finally be thrown away up to the end of conference.\u003c/p\u003e\u003cp\u003eLet\u0027s interpret it in the following manner: consider the network that has the source \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, the sink \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e, and also \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e pairs of vertices \u003cspan class\u003d\"tex-span\"\u003e(1\u003csub class\u003d\"lower-index\"\u003e + \u003c/sub\u003e, 1\u003csub class\u003d\"lower-index\"\u003e - \u003c/sub\u003e), (2\u003csub class\u003d\"lower-index\"\u003e + \u003c/sub\u003e, 2\u003csub class\u003d\"lower-index\"\u003e - \u003c/sub\u003e), ... (\u003ci\u003en\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e + \u003c/sub\u003e, \u003ci\u003en\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e - \u003c/sub\u003e)\u003c/span\u003e corresponding to each of the day of the conference. The idea behind assigning each day to two vertices will be clarified later.\u003c/p\u003e\u003cp\u003eLet there be an edge from source \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to the vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e - \u003c/sub\u003e\u003c/span\u003e of cost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and capacity \u003cspan class\u003d\"tex-span\"\u003e∞\u003c/span\u003e. Unit flow through this edge corresponds to a single bought patchcord.\u003c/p\u003e\u003cp\u003eLet there be an edge from vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e + \u003c/sub\u003e\u003c/span\u003e to the vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e - \u003c/sub\u003e\u003c/span\u003e of capacity \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and cost \u003cspan class\u003d\"tex-span\"\u003e - \u003ci\u003eA\u003c/i\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e — is some positive amount. The unit flow through such an edge corresponds to a single patchcord used in day \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e. Let\u0027s call such edges important.\u003c/p\u003e\u003cp\u003eHence, all patchcords getting to the vertices of kind \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e - \u003c/sub\u003e\u003c/span\u003e are broken patchcords that require repairing.\u003c/p\u003e\u003cp\u003eLet there be an edge from vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e - \u003c/sub\u003e\u003c/span\u003e to the sink \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e of capacity \u003cspan class\u003d\"tex-span\"\u003e∞\u003c/span\u003e and cost \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. Unit flow through this edge corresponds to throwing out one patchcord.\u003c/p\u003e\u003cp\u003eLet there be an edge from vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e - \u003c/sub\u003e\u003c/span\u003e to vertex \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e + \u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/sub\u003e)\u003csub class\u003d\"lower-index\"\u003e + \u003c/sub\u003e\u003c/span\u003e of capacity \u003cspan class\u003d\"tex-span\"\u003e∞\u003c/span\u003e and cost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Unit flow through such an edge corresponds to repairing of one patchcord using the company.\u003c/p\u003e\u003cp\u003eSimilarly, let there be an edge from vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e - \u003c/sub\u003e\u003c/span\u003e to the vertex \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e + \u003ci\u003et\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/sub\u003e)\u003csub class\u003d\"lower-index\"\u003e + \u003c/sub\u003e\u003c/span\u003e of capacity \u003cspan class\u003d\"tex-span\"\u003e∞\u003c/span\u003e and cost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Unit flow through such an edge corresponds to one patchcord repaired by Byteasar.\u003c/p\u003e\u003cp\u003eFinally, let there be an edge from vertex \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e + \u003c/sub\u003e\u003c/span\u003e to the vertex \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ei\u003c/i\u003e + 1)\u003csub class\u003d\"lower-index\"\u003e + \u003c/sub\u003e\u003c/span\u003e of capacity \u003cspan class\u003d\"tex-span\"\u003e∞\u003c/span\u003e and cost \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e Unit flow through such an edge corresponds to an unbroken patchcord that was not used during the day \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e \u003ccenter\u003e\u003cimg src\u003d\"/predownloaded/0d/f3/0df38faf2baa6740447d7eefbb006dc7ed247ff6.jpg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eAny feasible flow in such a network corresponds to some set of patchcords and a strategy of their usage, but this set of patchcord may not be satisfying the requirements for the amount of patchcords per each day. We are interested only in those flows that saturate all the important edges. \u003c/p\u003e\u003cp\u003eLet\u0027s use a standard trick -- let\u0027s find the minimum cost flow, assigning all important edges a very small negative capacity beforehand. In the other words, let \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e be equal to a very large positive number. Then the final cost of a flow will be equal to \u003cspan class\u003d\"tex-span\"\u003e - \u003ci\u003eA\u003c/i\u003e·\u003ci\u003esatcnt\u003c/i\u003e + \u003ci\u003eopcost\u003c/i\u003e\u003c/span\u003e where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003esatcnt\u003c/i\u003e\u003c/span\u003e is the number of saturated important edges, and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eopcost\u003c/i\u003e\u003c/span\u003e is a cost of buying/repairing all the broken patchcords.\u003c/p\u003e\u003cp\u003eLet\u0027s find the flow of minimum cost in this network (note that it is not the same as the maximum flow of minimum cost). It\u0027s easy to see that such a flow maximizes the number of saturated important edges, and in case of a tie it minimizes the total expenses in a chosen plan.\u003c/p\u003e\u003cp\u003eSo, we have a solution that has the running time of running a min-cost-flow algorithm in a network without negative cycles. Algorithm of repeated finding the shortest augmenting path using Ford-Bellman\u0027s algorithm works without any issues in constraints of the problem. \u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSolution (с++)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;cassert\u0026gt;\nusing namespace std;\n\nconst int N \u003d 500;\nconst int M \u003d 40000;\n\ntypedef long long llong;\n\nstruct edge\n{\n    int t;\n    llong f, c, u;\n    int nxt;\n} E[2 * M];\n\nint first[N];\n\nint ept \u003d 0;\n\ninline void add_edge(int a, int b, llong c, llong u)\n{\n    assert(ept \u0026lt; 2 * M - 10);\n    E[ept] \u003d {b, 0, c, u, first[a]};\n    E[ept + 1] \u003d {a, 0, 0, -u, first[b]};\n    first[a] \u003d ept;\n    first[b] \u003d ept + 1;\n    ept +\u003d 2;\n}\n\nint prv[N];\nllong D[N];\nint S, T;\nconst llong inf \u003d 1e12;\n\nint n;\n\nllong push()\n{\n    for (int i \u003d 0; i \u0026lt; n; i++)\n        D[i] \u003d inf, prv[i] \u003d -1;\n    D[S] \u003d 0;\n    for (int i \u003d 0; i \u0026lt; n; i++)\n    {\n        for (int e \u003d 0; e \u0026lt; ept; e++)\n        {\n            if (E[e].f \u003d\u003d E[e].c)\n                continue;\n            int a \u003d E[e ^ 1].t;\n            int b \u003d E[e].t;\n            if (D[a] + E[e].u \u0026lt; D[b])\n                D[b] \u003d D[a] + E[e].u, prv[b] \u003d e;\n        }\n    }\n    if (D[T] \u0026gt; inf / 2)\n        return 0;\n    llong mn \u003d inf;\n    llong add \u003d 0;\n    for (int t \u003d T; prv[t] !\u003d -1; t \u003d E[1 ^ prv[t]].t)\n        mn \u003d min(mn, (llong)E[prv[t]].c - E[prv[t]].f);\n    assert(mn \u0026gt; 0);\n    for (int t \u003d T; prv[t] !\u003d -1; t \u003d E[1 ^ prv[t]].t)\n        E[prv[t]].f +\u003d mn, E[prv[t] ^ 1].f -\u003d mn, add +\u003d E[prv[t]].u;\n    if (add \u0026gt;\u003d 0) {\n        return 0;\n    }\n    return add * mn;\n}\n\nint R[N];\n\nint main() {\n    int n;\n    double dcn, dcf, dcs;\n\tint tf, ts;\n    scanf(\u0026quot;%d %lf %lf %lf %d %d\u0026quot;, \u0026amp;n, \u0026amp;dcn, \u0026amp;dcf, \u0026amp;dcs, \u0026amp;tf, \u0026amp;ts);\n    int cn \u003d (int)(dcn * 100 + 0.5);\n    int cf \u003d (int)(dcf * 100 + 0.5);\n    int cs \u003d (int)(dcs * 100 + 0.5);\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        scanf(\u0026quot;%d\u0026quot;, \u0026amp;R[i]);\n    }\n\n    int ver \u003d 0;\n    vector\u0026lt;int\u0026gt; in(n);\n    vector\u0026lt;int\u0026gt; out(n);\n    int s \u003d ver++;\n    int t \u003d ver++;\n    S \u003d s, T \u003d t;\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        in[i] \u003d ver++;\n        out[i] \u003d ver++;\n    }\n    ::n \u003d ver;\n    int sum \u003d accumulate(R, R + n, 0);\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        add_edge(in[i], out[i], R[i], -inf);\n    }\n    for (int i \u003d 0; i \u0026lt; n; i++) {\n        add_edge(out[i], t, inf, 0);\n        add_edge(s, in[i], inf, cn);\n    }\n    for (int i \u003d 0; i \u0026lt; n - 1; i++) {\n        add_edge(in[i], in[i + 1], inf, 0);\n    }\n    for (int i \u003d 0; i + tf \u0026lt; n; i++) {\n        add_edge(out[i], in[i + tf], inf, cf);\n    }\n    for (int i \u003d 0; i + ts \u0026lt; n; i++) {\n        add_edge(out[i], in[i + ts], inf, cs);\n    }\n    llong ans \u003d 0;\n    while (llong p \u003d push()) {\n        ans +\u003d p;\n    }\n    llong bot \u003d sum * -inf;\n    assert(ans \u0026gt;\u003d bot);\n    assert(ans \u0026lt; (sum - 1) * -inf);\n    ans -\u003d bot;\n    printf(\u0026quot;%lld.%02lld\\n\u0026quot;, ans / 100, ans % 100);\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":["yandex.algorithm","warmup","editorial"]}}