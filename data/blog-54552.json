{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1505507600,"rating":3,"authorHandle":"Motarack","modificationTimeSeconds":1505509574,"id":54552,"title":"\u003cp\u003eDay 7 Contest Tutorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003ca href\u003d\"https://a2oj.com/contest?ID\u003d33470\"\u003econtest link\u003c/a\u003e \u003c/p\u003e\u003ch1\u003eResources Distribution\u003c/h1\u003e\u003cp\u003etake any square and the square that faces it on the other side, for example squares the square that faces 8 is 22 in the picture in the problem statement.\u003cbr /\u003emake the sum of them equal to 1 + 6n^2, we can do that by giving the first pair of facing squares the numbers 1 and 6n^2, the second pair 2 and 6n^2 — 1 and so on.\u003cbr /\u003enow take any path, it will consist of 2n pairs, and it\u0027s sum will equal 2 * n * (1 + 6n^2).\u003cbr /\u003e\u003ca href\u003d\"https://ideone.com/Bpz5Oz\"\u003ehttps://ideone.com/Bpz5Oz\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eGOV-internship 2\u003c/h1\u003e\u003cp\u003erealize that for any two arrays, the distance between them is the number of pairs of numbers such that the first number is from the first array and the second is from the second array.\u003cbr /\u003enow let\u0027s say the first array didn\u0027t have any zeroes, how should we fill the missing numbers in the second array?\u003cbr /\u003ewe can see that the cost of changing a 0 to x in the second array is equal to the length of the first array — the frequency of x in the first array.\u003cbr /\u003eso we should change all zeros to the number with the highest frequency in the first array, since adding it adds the lowest possible cost.\u003cbr /\u003enow if both arrays have zeroes: for the same reason above we can see that it\u0027s optimal to change all the zeros in a single array to a single value.\u003cbr /\u003ewe can try all possible values to replace the zeros in the first array and choose the most frequent value in the first array to replace the zeros in the second.\u003cbr /\u003e\u003ca href\u003d\"https://ideone.com/KC1rjj\"\u003ehttps://ideone.com/KC1rjj\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eSummit Online Judge\u003c/h1\u003e\u003cp\u003eWe discussed this question, first we see that the numbers we can make are actually made of intervals x-y, 2x-2y, 3x-3y...\u003cbr /\u003eat some point these intervals will start intersecting, we can binary search this moment and all numbers to the right of it and get the numbers to the left with a formula.\u003cbr /\u003ealso be careful to handle the cases where the border of the query is in the middle of an interval.\u003cbr /\u003e\u003ca href\u003d\"https://ideone.com/w5Q8ri\"\u003ehttps://ideone.com/w5Q8ri\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eBest of a bad lot\u003c/h1\u003e\u003cp\u003elet\u0027s draw a graph where every node resembles a passenger, now add an edge between any two passengers that contradicts each other.\u003cbr /\u003esince it\u0027s impossible for 2 people who tells the truth to contradict each other, and the same is true for any 2 murderers, our graph will be a bipartite graph, since there wont be any odd cycle, if there was one, then that means there are at least 2 murderers contradicting each other or at least 2 innocent people contradicting each other.\u003cbr /\u003enow color the graph with 2 colors using a normal dfs and add the group with the smallest size to the answer.\u003cbr /\u003ejust be very careful when thinking of when two people contradict each other or you will get a lot of WA.\u003cbr /\u003e\u003ca href\u003d\"https://ideone.com/LtadRX\"\u003ehttps://ideone.com/LtadRX\u003c/a\u003e \u003c/p\u003e\u003ch1\u003eBricks\u003c/h1\u003e\u003cp\u003ethe trick in this question is that we can rotate the brick.\u003cbr /\u003efirst place the brick in such a way that the face with the minimum area is parallel with the face of the hole, now we have two rectangles, the hole and the face of the brick.\u003cbr /\u003elet a and b be the small side of the hole and the big side of the hole, and let x and y be the small side of the face and the large side of the face.\u003cbr /\u003enow if a \u0026gt;\u003d x \u0026amp;\u0026amp; b \u0026gt;\u003d y we can place the brick in the hole.\u003cbr /\u003eif a \u0026gt; x \u0026amp;\u0026amp; b \u0026lt; y then we can rotate the face like this: \u003c/p\u003e\u003cp\u003e\u003cimg alt\u003d\" \" src\u003d\"/predownloaded/21/ae/21ae835a355be014ba1b59b694f14a150549c8b5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/p\u003e\u003cp\u003enow when we rotate the face, it\u0027s height will stay higher than the hole\u0027s height, then it will be equal, then it will become less. and since the width will be increasing most of the time(at least the time that a rotation would make the face fit), we can do a binary search on the angle to find the first angle of rotation at which our face\u0027s height will be equal to the hole\u0027s.\u003cbr /\u003eif a \u0026lt; x then we can\u0027t do it no matter what, since a rotation can\u0027t decrease the width of our face.\u003cbr /\u003e\u003ca href\u003d\"https://ideone.com/YCj5Pw\"\u003ehttps://ideone.com/YCj5Pw\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eMichael and Cryptography\u003c/h1\u003e\u003cp\u003esince we need exactly 20 divisors, at worst case there will be only a single prime larger than 2e6 as a factor of n.\u003cbr /\u003eto prove this let there be two primes \u0026gt; 2e6, then divide 1e18 by them, we are left with 250000, so we need 18 more factors, but the smallest number with such factors is 2^18 which is equal to 262144 and is larger than 250000.\u003cbr /\u003eso we only need to count the numbers of prime divisors less than 2e6 and divide n by them, if n !\u003d 1 after dividing, the we have another prime divisors, so we increase our prime divisors counter.\u003cbr /\u003e\u003ca href\u003d\"https://ideone.com/Pjnv9m\"\u003ehttps://ideone.com/Pjnv9m\u003c/a\u003e\u003c/p\u003e\u003ch1\u003eSea Burial\u003c/h1\u003e\u003cp\u003elet\u0027s mark the sea where the first shaman drowned with a dfs, now start a dfs from the map\u0027s border and mark everything without passing throw the sea where the first shaman drowned(we already marked it).\u003cbr /\u003enow simply count the number of islands that are not marked yet with a simple dfs.\u003cbr /\u003e\u003ca href\u003d\"https://ideone.com/6MnZnq\"\u003ehttps://ideone.com/6MnZnq\u003c/a\u003e \u003c/p\u003e\u003cp\u003eanother more complicated solution but has a useful idea is to think of the islands and the seas as nodes and create a tree where every two adjacent sea and island have an edge between them, and you also add a node that resembles an outer layer outside the map\u0027s border.\u003cbr /\u003enow root the tree in that node, our answer is the number of island nodes in the sub-tree of the node of the sea where the first shaman drowned.\u003cbr /\u003e\u003ca href\u003d\"https://ideone.com/u0hmwI\"\u003ehttps://ideone.com/u0hmwI\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e","tags":[]}}