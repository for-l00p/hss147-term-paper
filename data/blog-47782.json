{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1476555933,"rating":4,"authorHandle":"sw1ft","modificationTimeSeconds":1476555933,"id":47782,"title":"\u003cp\u003ePrinting DP TSP path\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHey everyone. I was looking at the code in CP3 book to solve the TSP using top-down DP in O(n^2*2^n) and was trying to print the path, but it seems impossible to me. \u003c/p\u003e\u003cp\u003eI thought about creating something like a \u0026quot;parent\u0026quot; array and then reconstruct, but couldn\u0027t.\u003c/p\u003e\u003cp\u003eThis is the code:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estatic void tsp() {\n// n \u003d graph\u0027s number of vertices\nmemo \u003d new double[n][1 \u0026lt;\u0026lt; n];\nfor (int i \u003d 0; i \u0026lt; n; ++i)\n\tfor (int j \u003d 0; j \u0026lt; 1 \u0026lt;\u0026lt; n; ++j)\n\t\tmemo[i][j] \u003d Double.MIN_VALUE;\ndouble distance \u003d tsp(0, 1);\n// Build ath - pending\nSystem.out.println(\u0026quot;Distance:\u0026quot; + distance);\n}\n\nstatic double dp(int pos, int bitmask) {\n\tif (bitmask \u003d\u003d (1 \u0026lt;\u0026lt; n) - 1)\n\t\treturn graph[pos][0];\n\tif (Double.compare(memo[pos][bitmask], Double.MIN_VALUE) !\u003d 0)\n\t\treturn memo[pos][bitmask];\n\tdouble ans \u003d Double.MAX_VALUE;\n\tfor (int nxt \u003d 0; nxt \u0026lt; n; ++nxt)\n\t\tif (nxt !\u003d pos \u0026amp;\u0026amp; (bitmask \u0026amp; (1 \u0026lt;\u0026lt; nxt)) \u003d\u003d 0)\n\t\t\tans \u003d Double.min(ans, graph[pos][nxt] + dp(nxt, bitmask | (1 \u0026lt;\u0026lt; nxt)));\n\tmemo[pos][bitmask] \u003d ans;\n\treturn ans;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAny help? Thanks!\u003c/p\u003e\u003c/div\u003e","tags":["tsp","dp"]}}