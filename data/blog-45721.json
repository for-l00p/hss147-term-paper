{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1467124747,"rating":-2,"authorHandle":"aostankov","modificationTimeSeconds":1467197090,"id":45721,"title":"\u003cp\u003eДень 2. Поиск в ширину\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e\u003cstrong\u003eДейкстра\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗапускаем алгоритм дейкстры от стартовой вершины. Можно за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eN\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e, можно за \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eMlog\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e. Для проверки существования заполняем изначально массив расстояний некоторой большой константой \u003cspan class\u003d\"tex-span\"\u003e \u003d \u003ci\u003eINF\u003c/i\u003e\u003c/span\u003e. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eРасстояние между вершинами\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗдесь уже придётся честно писать дейкстру с кучей или сетом. Также заведём массив предков для восстановления пути \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eparent\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e, в котором будет хранится предок вершины v, из которого мы пришли в данную вершину. Обновляем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eparent\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e в двух случая, когда первый раз пришли в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e или же получили расстояние меньшее, чем \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edistance\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]\u003c/span\u003e. Если путь существует, то путь, как раз, восстановим с помощью массива предков, начиная из конечной вершины, поднимаясь по предкам, пока не дойдём до стартовой. Также стоит отметить, что здесь обязательно нужно писать алгоритм дейкстры на списках смежности.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eКратчайший путь\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗапустим алгоритм Форда-Беллмана. Проверка на не существование пути делается стандартно — если после \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/span\u003e итераций \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003edist\u003c/i\u003e[\u003ci\u003eu\u003c/i\u003e] \u003d \u003ci\u003eINF\u003c/i\u003e\u003c/span\u003e(который вы задали изначально), то пути из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e не существует. Заметим, что бесконечно-короткий путь может быть только в случае существования цикла отрицательного веса, но это ещё не всё. Помимо того, что такой цикл должен существовать, он ещё должен быть достижим из стартовой вершины, а также из этого цикла должна быть достижима конечная вершина. С помощью Форд-Беллмана находим по одной вершины из каждого цикла. Заведём, например, два булевых массива \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epath\u003c/i\u003e[]\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epathrev\u003c/i\u003e[]\u003c/span\u003e, где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epath\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e] \u003d \u003ci\u003etrue\u003c/i\u003e\u003c/span\u003e, если мы можем из стартовой вершины добраться до \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epathrev\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e] \u003d \u003ci\u003etrue\u003c/i\u003e\u003c/span\u003e, если мы можем добрать от вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e до вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e. Первый массив заполняется с помощью поиска в глубину на исходном графе, а \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epathrev\u003c/i\u003e[]\u003c/span\u003e на транспонированном. Теперь, если существует вершина \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ev\u003c/i\u003e\u003c/span\u003e, которая принадлежит какому-либо отрицательному циклу, а также для неё верно, что \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003epath\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e]·\u003ci\u003epathrev\u003c/i\u003e[\u003ci\u003ev\u003c/i\u003e] \u003d \u003ci\u003etrue\u003c/i\u003e\u003c/span\u003e, то ответ будет \u0027-\u0027, иначе расстояние, найденное алгоритмом Форда-Беллмана.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eФлойд\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eСтандартный алгоритм Флойда, разобранный на вчерашней лекции.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eЛабиринт знаний\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eАналогичная задача задаче \u0026quot;Кратчайший путь\u0026quot;, но здесь нужно сделать трюк, т.к нам нужно найти не самый коротки, а самый длинный путь, то нужно изменить все веса рёбер на противоположные — умножить на -1.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eПоиск в ширину\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eСтандартный bfs на единичном графе, ничего особенного, разобранный на вчерашней лекции.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eКратчайший путь коня\u003c/strong\u003e Представим шахматные клетки как вершины графа. Две вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e, \u003ci\u003eB\u003c/i\u003e\u003c/span\u003e будут связаны между собой, если конь может перейти из \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eA\u003c/i\u003e\u003c/span\u003e в \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eB\u003c/i\u003e\u003c/span\u003e. Каждое такое ребро будет иметь единичный вес. Осталось запустить поиск в ширину, а затем восстановить путь.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eКратчайший путь двух коней\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eГраф такой же как и в предыдущей задаче. Теперь в очереди(векторе) будем хранить не только координаты одного коня, а сразу координаты двух коней, плюс ко всему нам нужно запоминать, кто из коней сейчас совершает следующий ход. Изначально положим в очередь стартовые координаты двух коней, а также некоторые флаг, соответствующий тому, что ходит первый конь(по условию). Заведём массив used[], где \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eused\u003c/i\u003e[\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e][\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e][\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e][\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e] \u003d \u003ci\u003etrue\u003c/i\u003e\u003c/span\u003e, если ранее уже существовало положение двух коней, в котором первый конь стоит в \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e;\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e)\u003c/span\u003e, а второй в \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ex\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e;\u003ci\u003ey\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e2\u003c/sub\u003e)\u003c/span\u003e. Очередной шаг поиска в ширину будет заключаться в следующем: мы из очереди (вектора) достаём очередную пару координат, если used от данного состояния равен true, то делам continue, иначе смотрим на то, какой из коней сейчас ходит и пытаемся перейти в соответствующее состояние, то есть мы подразумеваем, что кони ходят по очереди — достали пару координат, посмотрели на то, чей сейчас ход и изменили координату данного коня, если used от нового состояния false, то положили в очередь). Если в какой то момент мы обнаружили, что координаты обоих коней совпадают с их конечными назначения, то завершаем bfs и восстанавливаем предков. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e\u003cem\u003eЗамечание:\u003c/em\u003e\u003c/strong\u003e в данной задаче лучше хранить состояния не в очереди, а в векторе, и заместо while делать по данному вектору простой for, так как с вектором удобнее восстанавливать предков, всё что будет нужно для восстановления предков в случае с вектором, это в каждом состоянии также хранить и индекс родительского состояния в векторе. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eОстровные государства\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eЗдесь уже просто так запустить bfs не получится, так как у нас присутствуют рёбра, которые имеют вес 0, 1, 2. Как ищется кратчайший путь в случае с графом 0-1, мы разобрали на лекции, но что делать с рёбрами веса 2. Ответ простой — разбить вершину на две. Например, у нас есть две вершины \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, вес ребра мужду которыми равно двум. Мы заведём фиктивную вершину \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003c/span\u003e, и заменим ребро \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e веса два на два ребра \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ea\u003c/i\u003e, \u003ci\u003ec\u003c/i\u003e)\u003c/span\u003e и \u003cspan class\u003d\"tex-span\"\u003e(\u003ci\u003ec\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e)\u003c/span\u003e веса один, так для кадого ребра веса 2. В итоге получим граф, у которого все рёбра имеют вес \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e или \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, а кратчайший путь для такой задачи мы уже сможем найти через \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ebfs\u003c/i\u003e\u003c/span\u003e. Стоит не забыть, когда будем восстанавливать путь, про нашу замену, и не выводить фиктивные вершины.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eРасстояние от корня\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eДанная задача является последней по порядку, но явно не самой сложной, молодцы те, у кого хватило сил дочитать условия всех задач до конца. Решение простое — можно запустить bfs, Форд-Беллмана, Дейкстру, Флойда или даже обычный dfs, так как в задаче дано дерево. Затем найти расстояние до всех вершин от стартовой, для dfs расстояние тоже самое, что высота вершины в дереве.\u003c/p\u003e\u003c/div\u003e","tags":[]}}