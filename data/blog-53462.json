{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1500917644,"rating":-6,"authorHandle":"rusins","modificationTimeSeconds":1500917644,"id":53462,"title":"\u003cp\u003eShort algorithm for constructing suffix array?\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eI\u0027d love it if people shared in the comments below the code they usually write during a contest when a suffix array is needed. I am aware there are short O(Nlog^2N) solutions, and I\u0027d love to see some of those if you want to share them, but specifically I\u0027m looking for an O(NlogN) solution.\u003c/p\u003e\u003cp\u003eHere\u0027s the code I use, but it takes me an average of 30 minutes to write and debug (easy to make mistakes), so it\u0027s not good enough for competitions.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nconst long N \u003d 1e5;\n\nstruct row {\n  long pos[N];\n  long elem[N];\n  long bucket[N];\n} *cur \u003d new row(), *prv \u003d new row();\n\nstring s;\nlong bucket_spot[N]; // coordinate of bucket start\n\nbool cmp(long a, long b) { return s[a] \u0026lt; s[b]; }\n\nvoid bring_to_front(long e) { // Move element to start of its bucket\n  long bucket \u003d prv-\u0026gt;bucket[prv-\u0026gt;pos[e]];\n  cur-\u0026gt;pos[e] \u003d bucket_spot[bucket]++;\n  cur-\u0026gt;elem[cur-\u0026gt;pos[e]] \u003d e;\n}\n\nvoid calc_suffix_array() {\n  long n \u003d s.size();\n\n  // Init\n  for (long i \u003d 0; i \u0026lt; n; ++i)\n\tcur-\u0026gt;elem[i] \u003d i;\n  sort(cur-\u0026gt;elem, cur-\u0026gt;elem + n, cmp);\n  for (long i \u003d 0; i \u0026lt; n; ++i)\n\tcur-\u0026gt;pos[cur-\u0026gt;elem[i]] \u003d i;\n  cur-\u0026gt;bucket[0] \u003d prv-\u0026gt;bucket[0] \u003d 0;\n  long buckets \u003d 1;\n  for (long i \u003d 1; i \u0026lt; n; ++i)\n\tif (s[cur-\u0026gt;elem[i]] \u003d\u003d s[cur-\u0026gt;elem[i - 1]])\n\t  cur-\u0026gt;bucket[i] \u003d buckets - 1;\n\telse\n\t  cur-\u0026gt;bucket[i] \u003d buckets++;\n\n  // Loop\n  for (long delta \u003d 1; buckets \u0026lt; n; delta *\u003d 2) {\n\tswap(cur, prv);\n\t// Update bucket spots\n\tfor (long i \u003d n - 1; i \u0026gt;\u003d 0; --i)\n\t  bucket_spot[prv-\u0026gt;bucket[i]] \u003d i;\n\t// Lower last elements\n\tfor (long i \u003d 0; i \u0026lt; delta; ++i)\n\t  bring_to_front(n - i - 1);\n\t// Sort elements\n\tfor (long i \u003d 0; i \u0026lt; n; ++i) {\n\t  if (prv-\u0026gt;elem[i] \u0026lt; delta) continue;\n\t  bring_to_front(prv-\u0026gt;elem[i] - delta);\n\t}\n\t// Create new bucket boundaries\n\tfor (long i \u003d 1; i \u0026lt; n; ++i) {\n\t  cur-\u0026gt;bucket[i] \u003d prv-\u0026gt;bucket[i];\n\t  if (cur-\u0026gt;bucket[i] !\u003d cur-\u0026gt;bucket[i - 1]) continue;\n\t  long suf1 \u003d cur-\u0026gt;elem[i - 1] + delta;\n\t  long suf2 \u003d cur-\u0026gt;elem[i] + delta;\n\t  if (suf1 \u0026gt;\u003d n or suf2 \u0026gt;\u003d n) continue;\n\t  if (prv-\u0026gt;bucket[prv-\u0026gt;pos[suf1]] \u003d\u003d prv-\u0026gt;bucket[prv-\u0026gt;pos[suf2]]) continue;\n\t  for (long j \u003d i - 1; j \u0026gt;\u003d 0 and cur-\u0026gt;bucket[j] \u003d\u003d cur-\u0026gt;bucket[i]; --j)\n\t\tcur-\u0026gt;bucket[j] \u003d buckets;\n\t  ++buckets;\n\t}\n  }\n}\n\nint main() {\n  cin \u0026gt;\u0026gt; s;\n  s.append(1, \u0027a\u0027 - 1); // Sentinel\n  calc_suffix_array();\n  long n \u003d s.size();\n  cout \u0026lt;\u0026lt; \u0026quot;Suffix array of \u0026quot; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl;\n  for (long i \u003d 0; i \u0026lt; n; ++i)\n\tcout \u0026lt;\u0026lt; cur-\u0026gt;elem[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; s.substr(cur-\u0026gt;elem[i], n) \u0026lt;\u0026lt; endl;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","tags":["suffix array"]}}