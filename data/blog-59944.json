{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1528655203,"rating":-1,"authorHandle":"zys23736748","modificationTimeSeconds":1528704555,"id":59944,"title":"\u003cp\u003eECR45-problemB\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003e简单排序+贪心。 一开始用vector做不知道为什么超时。 后改贪心，其中两种情况没有返回 i\u003dj-1；卡了半天。\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;cmath\u0026gt;\n\nusing namespace std;\n#define MAXN 100010\n\nint Micro[MAXN*2];\nint n,K;\nint tim\u003d0;\n\nbool cmp(int a, int b)\n{\n    return a\u0026lt;b;\n}\n\nint main()\n{\n\n    cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;K;\n    for(int i\u003d0;i\u0026lt;n;i++)\n        cin\u0026gt;\u0026gt;Micro[i];\n\n    sort(Micro,Micro + n,cmp);\n\n    int flag \u003d 0;\n    int ans\u003d0;\n\n    for(int i\u003d0;i\u0026lt;n;i++)\n    {\n        int j\u003di+1;\n\n        while( Micro[i] \u003d\u003d Micro[j] ){\n            j++;\n\n            if( j \u003d\u003d n) i\u003dj-1;\n            \n            if(Micro[j] \u0026lt;\u003d Micro[i] + K \u0026amp;\u0026amp; Micro[i]!\u003dMicro[j] \u0026amp;\u0026amp; j\u0026lt;n ){\n               for(int t\u003di;t\u0026lt;j-1;t++)  Micro[t]\u003d0;\n            i\u003dj-1;\n            }\n\n            else if (Micro[j] \u0026gt; Micro[i] + K)   i \u003d j-1;\n        }\n\n        if(Micro[j] \u0026lt;\u003d Micro[i] + K \u0026amp;\u0026amp; j\u0026lt;n ){\n            Micro[i] \u003d 0;\n        }\n    }\n\n    for(int i\u003d0;i\u0026lt;n;i++){\n        if(Micro[i]!\u003d0) ans++;\n    }\n    cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e参考其他代码，有直接用pos记录upper_loader返回值的做法。 另外没有清零，直接对答案进行记录。 代码简洁了很多。\u003c/p\u003e\u003c/div\u003e","tags":["education"]}}