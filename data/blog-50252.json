{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1486243081,"rating":0,"authorHandle":"mutreta","modificationTimeSeconds":1487709283,"id":50252,"title":"\u003cp\u003eStrings: Hashing\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch1\u003eHashing\u003c/h1\u003e\u003cp\u003eHash functions are widely used in programming to cryptography, checking data integrity, etc. In competitive programming we use it the most used as a good alternative to build fast data structures and methods.\u003c/p\u003e\u003cp\u003eThe main idea is to calculate a (or a set of) integer for a string, such that we can safely assume that every pair of strings that have the same hash value is equal, and every pair that the hash value differs is different. In this way we can make string comparisons in constant time.\u003c/p\u003e\u003cp\u003eA function that allow us to quickly calculate hash values for several substrings of a string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e is the polynomial function:\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e) \u003d (\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e0\u003c/sup\u003e + \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e1\u003c/sup\u003e + ... + \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sup\u003e)\u003ci\u003emodm\u003c/i\u003e\u003c/span\u003e\u003c/center\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/0b/65/0b655d67eee3f8a519a7467aa40f1e2e49b5b7e7.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eAn easier alternative for some problems is to apply the same polynomial in the reversed string:\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e) \u003d (\u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e0\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sup\u003e + \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e1\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003en\u003c/i\u003e - 2\u003c/sup\u003e + ... + \u003ci\u003es\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e - 1\u003c/sub\u003e\u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e0\u003c/sup\u003e)\u003ci\u003emodm\u003c/i\u003e\u003c/span\u003e\u003c/center\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/e8/9e/e89e1557b9580fd020ce107c18c1245ad2ce2ad5.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eIt\u0027s good practice to use primes values for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e should be as large as possible, while \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e should be bigger than the size of the alphabet you are using. Frequently, \u003cspan class\u003d\"tex-span\"\u003e1\u003ci\u003ee\u003c/i\u003e9 + 7\u003c/span\u003e is the value picked for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e. Any of the following value is usually suitable for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e     31     37     41     43     47     53     59     61     67     71\n     73     79     83     89     97    101    103    107    109    113\n    127    131    137    139    149    151    157    163    167    173\n    179    181    191    193    197    199    211    223    227    229\n    233    239    241    251    257    263    269    271    277    281\n    283    293    307    311    313    317    331    337    347    349\n    353    359    367    373    379    383    389    397    401    409\n    419    421    431    433    439    443    449    457    461    463\n    467    479    487    491    499    503    509    521    523    541\n    547    557    563    569    571    577    587    593    599    601\n    607    613    617    619    631    641    643    647    653    659\n    661    673    677    683    691    701    709    719    727    733\n    739    743    751    757    761    769    773    787    797    809\n    811    821    823    827    829    839    853    857    859    863\n    877    881    883    887    907    911    919    929    937    941\n    947    953    967    971    977    983    991    997   1009   1013\n   1019   1021   1031   1033   1039   1049   1051   1061   1063   1069\n   1087   1091   1093   1097   1103   1109   1117   1123   1129   1151\n   1153   1163   1171   1181   1187   1193   1201   1213   1217   1223\n   1229   1231   1237   1249   1259   1277   1279   1283   1289   1291\n   1297   1301   1303   1307   1319   1321   1327   1361   1367   1373\n   1381   1399   1409   1423   1427   1429   1433   1439   1447   1451\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf you are having problems with your hash function, it may be a good idea to change values for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and even to use two different hash functions for the same string.\u003c/p\u003e\u003cp\u003eInstead of using two integers in the hash function, we can use a long long integer. The downside of this approach is that you have to deal with overflows. For it you can pick \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003em\u003c/i\u003e \u003d 1\u003ci\u003ee\u003c/i\u003e18 + 9\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d 1009\u003c/span\u003e. To deal with overflows you can use the following function:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etypedef unsigned long long ul;\n\n// returns a*b % m\n// where 0 \u0026lt;\u003d a, b, \u0026lt; m\n\nul mul(ul a, ul b, ul m) {\n  // Here we calculate q with possible precision errors\n  ul q \u003d (ul) ((1.0*a*b/m);\n\n  ul r \u003d a*b - m*q; // We have the same overflow on both multiplications, so we cancel it with the subtraction.\n\n  // If we don\u0027t have any precision errors calculating q, then r is our response.\n  // If we got q wrong by one unit, then r differ from the response by m.\n  // Since we know that 0 \u0026lt;\u003d r \u0026lt; m, we use it to the the correct value for r.\n\n  while (r \u0026lt; 0) r +\u003d m;\n  while (r \u0026gt;\u003d  m) r -\u003d m;\n\n  return r\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eApplications\u003c/h2\u003e \u003cul\u003e   \u003cli\u003eGiven a string \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e, find the number of different substrings \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e such that the reverse of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003et\u003c/i\u003e\u003c/span\u003e is contained exaclty once in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e.\u003c/li\u003e \u003c/ul\u003e\u003cp\u003eSolve this problem with hash is pretty simple, we use the following loop structure:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor (int l\u003d0; s[l]; ++l) {\n  h \u003d 0;\n  for (int r\u003dl; s[r]; ++r) {\n    h +\u003d (a*h + s[r]) % m; // hash of the substring s[l..r]\n    // Rest of the logic\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFirstly, we use the loop on the reversed sring of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e to store all the hashes it\u0027s substrings in a \u003ccode\u003e(hash_)map\u003c/code\u003e. Now we now how many times each substring shows up in the reversed string.\u003c/p\u003e\u003cp\u003eSecondly and lastly, we apply the same loop at the original string and if the hash of the substring appeared in the inversed string only once, we store it in a \u003ccode\u003eset\u003c/code\u003e. Each hash in the set represents a distinc string that has only one occurence in the reversed string. Therefore, our answer is the size of the set. The complexity is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003ci\u003elog\u003c/i\u003e\u003c/sup\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e.\u003c/p\u003e\u003ch3\u003eRabin-Karp\u003c/h3\u003e\u003cp\u003eRabin-Karp is another algorithm to solve the matching problem. To do it we calculate the hash \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e\u003c/span\u003e of the pattern \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e and try to compare it with all hashes of substrings of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e\u003c/span\u003e that have the same length of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNaively, this can be done in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003es\u003c/i\u003e||\u003ci\u003ep\u003c/i\u003e|)\u003c/span\u003e. But because we chose our hash function wisely, we can do it in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(|\u003ci\u003es\u003c/i\u003e| + |\u003ci\u003ep\u003c/i\u003e|)\u003c/span\u003e. This happens because of hash function is also a rolling hash, which means that if we have the hash of the substring \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e..\u003ci\u003er\u003c/i\u003e]\u003c/span\u003e we can get the hash of s[l+1..r]$ and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003es\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e..\u003ci\u003er\u003c/i\u003e + 1]\u003c/span\u003e in \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(1)\u003c/span\u003e. Considering \u003cspan class\u003d\"tex-span\"\u003e|\u003ci\u003ep\u003c/i\u003e| \u003d \u003ci\u003ek\u003c/i\u003e\u003c/span\u003e:\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/ff/54/ff5466cd44b30303ddd8c64a2bc64f2ff74bd159.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eAnd also:\u003c/p\u003e \u003ccenter\u003e\u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/15/97/1597d2428e27074a7b70bd9817e1a84ae6547467.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/center\u003e\u003cp\u003eThus:\u003c/p\u003e \u003ccenter\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eh\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e + 1..\u003ci\u003er\u003c/i\u003e + 1]) \u003d \u003ci\u003ea\u003c/i\u003e(\u003ci\u003eh\u003c/i\u003e(\u003ci\u003es\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e..\u003ci\u003er\u003c/i\u003e) - \u003ci\u003es\u003c/i\u003e[\u003ci\u003el\u003c/i\u003e]\u003ci\u003ea\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e\u003ci\u003ek\u003c/i\u003e - 1\u003c/sup\u003e) + \u003ci\u003es\u003c/i\u003e[\u003ci\u003er\u003c/i\u003e + 1](\u003ci\u003emodm\u003c/i\u003e)\u003c/span\u003e\u003c/center\u003e\u003cp\u003e// TODO CREATE CODE FOR RABIN KARP WITH ADD, REM AND ROLL FUNCTIONS\u003c/p\u003e\u003cp\u003eRabin-Karp can be used to solve multiple matching problems when we have patterns with same length.\u003c/p\u003e\u003cp\u003e// TODO EXPLAIN HOW TO FIND HOW MANY MATCHES IN TEXT T OF ANY CICLIC SHIFT OF PATTERN P\u003c/p\u003e\u003cp\u003e// TODO EXPLAIN HOW TO COMPAIR TO COMPAIR TWO SUBSEGMENTS IN O(1) USING O(N) PREPROCESSING: // TWO APPROACHES: dp[i] \u003d h(s[0..i]) \u003d\u0026gt; h(s[i..j]) \u003d dp[j] — dp[i-1]*a^{j-i+1} // TWO APPROACHES: dp[i] \u003d dp[i-1] + a^{i}*s[i] \u003d\u0026gt; h(s[i..j]) \u003d (dp[j]-dp[i-1])*a^{n-r-1}\u003c/p\u003e\u003cp\u003e// TODO EXPLAIN HOW TO GET BIGGEST PALLINDROME WITH BINARY SEARCH AND HASHING.\u003c/p\u003e\u003cp\u003e// TODO TWO DIMENSIONAL SEARCH\u003c/p\u003e\u003c/div\u003e","tags":[]}}